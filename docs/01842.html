<html>
<head>
<title>Road to Genius: advanced #30</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">天才之路:高级#30</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/road-to-genius-advanced-30-4d3d4fb7559?source=collection_archive---------49-----------------------#2020-07-12">https://blog.devgenius.io/road-to-genius-advanced-30-4d3d4fb7559?source=collection_archive---------49-----------------------#2020-07-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/903efcef1948f1ff78341cd12c7e072d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZN3jFS4lswivkHPa.png"/></div></div></figure><p id="896c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每天我都要解决几个Codr分级模式的编码挑战和难题。目标是达到天才的等级，在这个过程中我解释了我是如何解决这些问题的。你不需要任何编程背景就可以开始，而且你会学到很多新的有趣的东西。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="e5af" class="lc ld in ky b gy le lf l lg lh">function canJump(nums) {<br/>  let max = 0; <br/>  for(let i = 0; i &lt; nums.length; i++) {<br/>      if (max &lt; i) return false; <br/>      max = Math.max(nums[i] + i, max);<br/>  }<br/>  return max &gt;= nums.length - 1<br/>}</span><span id="eb62" class="lc ld in ky b gy li lf l lg lh">let A = canJump([5,0,0,6,4,6]);</span><span id="c3b7" class="lc ld in ky b gy li lf l lg lh">// A = ? (boolean)</span></pre><p id="73d4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个挑战的代码很短，让我们看看它到底是怎么回事。我们必须弄清楚<code class="fe lj lk ll ky b">A</code>的布尔值:<br/> <code class="fe lj lk ll ky b">let A = canJump([5,0,0,6,4,6]);</code></p><p id="db3e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">乍一看，我不知道函数<code class="fe lj lk ll ky b">canJump</code>是做什么的，所以我们必须更仔细地分析它。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="74ef" class="lc ld in ky b gy le lf l lg lh">for (let i = 0; i &lt; nums.length; i++) {<br/>    if (max &lt; i) return false; <br/>    max = Math.max(nums[i] + i, max);<br/>}</span></pre><p id="5948" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这三行代码做了以下事情:迭代数组<code class="fe lj lk ll ky b">nums</code>中的每个数字；检查<code class="fe lj lk ll ky b">max</code>是否小于<code class="fe lj lk ll ky b">i</code>，如果是，函数立即返回假；最后，它确定新的最大值。if条件实际上确保了<code class="fe lj lk ll ky b">max</code>跳转大小大于for循环的当前索引<code class="fe lj lk ll ky b">i</code>。</p><p id="821a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该算法实际上是关于确定它是否能够“跳到”某个位置，其中每个数字代表最大跳跃长度。</p><p id="b2ee" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后一行代码揭示了它的最终条件:<br/> <code class="fe lj lk ll ky b">return max &gt;= nums.length - 1</code> <br/>它检查max是否大于或等于<code class="fe lj lk ll ky b">nums</code>的数组大小，这意味着整个算法检查是否可以从第一个索引开始到达数组的末尾。</p><p id="a445" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是一些伪代码来说明这一点:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="cb85" class="lc ld in ky b gy le lf l lg lh">nums = [5, 0, 0, 6, 4, 6]</span><span id="2a4f" class="lc ld in ky b gy li lf l lg lh">-&gt; i = 0<br/>   nums[i] = 5<br/>   max = max(5+0, 0) = 5<br/>   * from this index, we can jump max 5 positions further</span><span id="75f8" class="lc ld in ky b gy li lf l lg lh">-&gt; i = 1<br/>   nums[i] = 0<br/>   max = max(0+1, 5) = 5<br/>   * if we jump to here, we cannot jump any further (= 0)</span><span id="ae91" class="lc ld in ky b gy li lf l lg lh">-&gt; i = 2<br/>   nums[i] = 0<br/>   max = max(0+2, 5) = 5<br/>   * if we jump to here, we cannot jump any further (= 0)</span><span id="b4a2" class="lc ld in ky b gy li lf l lg lh">-&gt; i = 3<br/>   nums[i] = 6<br/>   max = max(6+3, 5) = 9<br/>   * if we jump to here, we can jump max 6 positions further</span><span id="f95d" class="lc ld in ky b gy li lf l lg lh">-&gt; i = 4<br/>   nums[i] = 4<br/>   max = max(4+4, 9) = 9<br/>   * if we jump to here, we can jump max 4 positions further</span><span id="8d6f" class="lc ld in ky b gy li lf l lg lh">-&gt; i = 5<br/>   nums[i] = 6<br/>   max = max(6+5, 9) = 11<br/>   * if we jump to here, we can jump max 6 positions further</span></pre><p id="d198" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个挑战很简单，对我们有利，因为我们可以从第一个索引到达数组的末尾(i = 5 );因为第一个数字是5。</p><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/068325a50255ced882630310e54cc5c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:590/format:webp/0*7RmcGUb0iJmtTVTP.png"/></div></figure><p id="f2da" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们甚至可以通过执行以下操作来优化该算法:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="a054" class="lc ld in ky b gy le lf l lg lh">function canJump(nums) {<br/>  let max = 0; <br/>  for(let i = 0; i &lt; nums.length; i++) {<br/>      if (max &lt; i) return false; <br/>      else if (max &gt;= nums.length - 1) return true;<br/>      max = Math.max(nums[i] + i, max);<br/>  }<br/>  return max &gt;= nums.length - 1<br/>}</span><span id="9573" class="lc ld in ky b gy li lf l lg lh">let A = canJump([5,0,0,6,4,6]);</span></pre><p id="e138" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">额外的else语句使函数在检测到可以到达末尾时更快地返回，因此它不必迭代所有的数字。</p><p id="b0d3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">编写这段代码的另一种方法是:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="b63f" class="lc ld in ky b gy le lf l lg lh">function canJump(nums) {<br/>  let max = 0; <br/>  for(let i = 0; i &lt; nums.length; i++) {<br/>      if (max &lt; i) return false; <br/>      max = Math.max(nums[i] + i, max);<br/>      if (max &gt;= nums.length - 1) return true;<br/>  }<br/>  return false;<br/>}</span><span id="9fa5" class="lc ld in ky b gy li lf l lg lh">let A = canJump([5,0,0,6,4,6]);</span></pre><p id="69af" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过解决这些挑战，你可以训练自己成为一名更好的程序员。您将学到更新更好的分析、调试和改进代码的方法。因此，你在商业上会更有效率和价值。在<a class="ae ln" href="https://nevolin.be/codr/" rel="noopener ugc nofollow" target="_blank">https://nevolin.be/codr/</a>加入我的天才之路，提升你的编程技能</p></div></div>    
</body>
</html>