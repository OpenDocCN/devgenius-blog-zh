<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://blog.devgenius.io/python-map-reduce-and-filter-lets-give-up-for-loops-8d2f6c1968e?source=collection_archive---------10-----------------------#2020-06-12">https://blog.devgenius.io/python-map-reduce-and-filter-lets-give-up-for-loops-8d2f6c1968e?source=collection_archive---------10-----------------------#2020-06-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div class="gh gi il"><img src="../Images/b30567810376de577285dc62781ab73f.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/0*HckOyViGub2DDUDo.jpg"/></div></figure><p id="c216" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">如果你有Hadoop的MapReduce的经验，在Python中找到map，Reduce函数一定感觉很熟悉。</p><p id="2deb" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">等等，Hadoop中的MapReduce是分布式计算工具，但是Python中的map/reduce是什么？实际上，Hadoop和Python中map/reduce的用法非常相似，Python吸收了这一特性，因为Python是一门非常年轻的语言，仍在发展中。它从其他领域获得灵感是很正常的，MapReduce就是一个例子。</p><h2 id="c80a" class="jr js iu bd jt ju jv dn jw jx jy dp jz je ka kb kc ji kd ke kf jm kg kh ki kj bi translated">地图</h2><p id="e409" class="pw-post-body-paragraph is it iu iv b iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ko jo jp jq ig bi translated">Map是指两个对象之间的关系，比如我们在C++和Java中有一个结构叫做‘map’，它可以存储键和值的映射。</p><p id="4012" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">我们都知道，在数学中，函数也是一种映射。它将X映射到y。在Python中，map意味着将函数映射到序列变量。这意味着对序列中的所有变量应用函数。</p><p id="2664" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">例如，假设我们有一个点，我们想得到它和原点之间的距离。很简单，我们只要用距离公式计算就可以了。</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="e467" class="jr js iu ku b gy ky kz l la lb">def dis(point):<br/>    return math.sqrt(point[0]**2 + point[1]**2)</span></pre><p id="da32" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">但是如果我们有很多点，我们需要使用for循环来实现。</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="f16c" class="jr js iu ku b gy ky kz l la lb">points = [[0, 1], [2, 4], [3, 2]]<br/><br/>for point in points:<br/>    print(dis(point))</span></pre><p id="02bf" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">既然我们有了‘map’，我们可以把上面的代码缩短为一行。</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="d51b" class="jr js iu ku b gy ky kz l la lb">map(dis, points)</span></pre><p id="e1a6" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">注意，‘map’返回的结果不是数组而是迭代器。如果我们直接打印出来，我们可以看到这样的信息。</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="381b" class="jr js iu ku b gy ky kz l la lb">&gt;&gt;&gt; print(map(dis, points))<br/>&lt;map object at 0x107aad1d0&gt;</span></pre><p id="ef52" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">获取完整内容的最简单方法是将其转换为列表。</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="4a7b" class="jr js iu ku b gy ky kz l la lb">&gt;&gt;&gt; print(list(map(dis, points)))<br/>[1.0, 4.47213595499958, 3.605551275463989]</span></pre><p id="d9cf" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">我们可以用匿名函数来进一步简化。对于已经用过的函数，没有必要构建一个完整的函数。我们可以使用“lambda”来实现一个匿名函数。</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="53af" class="jr js iu ku b gy ky kz l la lb">map(lambda x: math.sqrt(x[0]**2 + x[1] ** 2), points)</span></pre><p id="8e47" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">总之，“map”运行一个映射操作，它可以将一个函数映射到一个序列，以避免使用for-loop。在大多数情况下，它可以简化代码。</p><h2 id="7128" class="jr js iu bd jt ju jv dn jw jx jy dp jz je ka kb kc ji kd ke kf jm kg kh ki kj bi translated">减少</h2><p id="5bbf" class="pw-post-body-paragraph is it iu iv b iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ko jo jp jq ig bi translated">与地图相比，“减少”功能更难理解。它还将一个函数映射到一个序列。但是“reduce”将返回单个值，而不是其他序列。reduce一次合并两个值，直到只剩下一个值。</p><p id="4bfa" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">仅通过陈述很难理解，我们来看一个例子。</p><p id="5ba7" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">我们有一个数组[1，2，3，4]和一个函数f，它返回两个数的和。当我们执行reduce(f，[1，2，3，4])时，它会先用1和2调用f，得到3。然后它会继续用3和3调用f，然后得到6，再用6和4调用，然后返回10。现在我们只剩下一个值，所以它会返回。</p><p id="2b43" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">这个过程等于把所有的值加在一起。换句话说，reduce使用一个函数来合并整个序列。</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="c5e6" class="jr js iu ku b gy ky kz l la lb">from functools import reduce<br/><br/>def f(a, b):<br/>    return a + b<br/>    <br/>print(reduce(f, [1, 2, 3, 4]))</span></pre><p id="f7fd" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">同样，我们可以用匿名函数来代替普通函数。</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="306c" class="jr js iu ku b gy ky kz l la lb">print(reduce(lambda x, y: x + y, [1, 2, 3, 4]))</span></pre><h2 id="99c8" class="jr js iu bd jt ju jv dn jw jx jy dp jz je ka kb kc ji kd ke kf jm kg kh ki kj bi translated">MapReduce</h2><p id="e067" class="pw-post-body-paragraph is it iu iv b iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ko jo jp jq ig bi translated">现在我们引入了‘map’和‘reduce’，可以把它们结合起来一起使用。这就是Hadoop的方式。虽然在Python中我们将只有一个线程来运行它，如果我们不启动多线程，但它至少可以简化我们的编码。我们以经典的字数问题为例。</p><p id="aa34" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">如果我们使用map/reduce，工作流程就非常清晰了。我们只是在map阶段进行分词，然后在reduce中进行计数。</p><p id="bfa7" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">但是当你开始实施的时候，你会发现这比你想象的要难一点。因为在Hadoop中，在map和reduce之间有一个称为shuffing的中间阶段，它将通过键对map的结果进行分组，以确保具有相同键的行落在相同的reducer中。</p><p id="8ec0" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">当我们实现它时，我们没有中间阶段，所以我们需要自己动手。我们可以添加另一张“地图”来扮演shulffing stage的角色。让我们看看代码。</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="a435" class="jr js iu ku b gy ky kz l la lb">from collections import Counter, defaultdict<br/><br/>texts = ['apple bear peach grape', 'grape orange pear']<br/><br/># the first map，split string and give 1 frequency to each word<br/>def mp1(text):<br/>    ret = []<br/>    words = text.split(' ')<br/>    for word in words:<br/>        ret.append((word, 1))<br/>    return ret<br/><br/><br/># the second map, convert list to dict<br/>def mp2(arr):<br/>    d = defaultdict(int)<br/>    for k, v in arr:<br/>        d[k] += v<br/>    return d<br/><br/># reduce，merge dict<br/>def rd(x, y):<br/>    x.update(y)<br/>    return x<br/><br/>print(reduce(rd, map(mp2, map(mp1, texts))))</span></pre><p id="67bf" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">如果我们不想使用两个阶段的地图呢？也有可能，我们只是需要一些额外的工具，比如计数器工具。它可以计算文本的频率。</p><p id="ac29" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">如果你对计数器工具一无所知，就去谷歌一下。这很容易学。</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="7845" class="jr js iu ku b gy ky kz l la lb">from collections import Counter<br/><br/>texts = ['apple bear peach grape', 'grape orange pear']<br/><br/>def mp(text):<br/>    words = text.split(' ')<br/>    return Counter(words)<br/><br/>print(reduce(lambda x, y: x + y, map(mp, texts)))</span></pre><p id="e4b2" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">当我们完成了地图阶段，结果已经被字典，我们只是总结他们。</p><h2 id="b65c" class="jr js iu bd jt ju jv dn jw jx jy dp jz je ka kb kc ji kd ke kf jm kg kh ki kj bi translated">过滤器</h2><p id="9caa" class="pw-post-body-paragraph is it iu iv b iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ko jo jp jq ig bi translated">“过滤器”是另一个有用的工具，我们可以用它来过滤列表或其他集合。</p><p id="3455" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">过滤器接收一个函数和一个列表，它将对每个元素执行函数，只有当结果为真时，元素才会被留下。</p><p id="8601" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">例如，如果我们只想保持奇数，最初的方法是在循环中使用条件。</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="b712" class="jr js iu ku b gy ky kz l la lb">arr = [1, 3, 2, 4, 5, 8]<br/><br/>[i for i in arr if i % 2 &gt; 0 ]</span></pre><p id="bf15" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">使用' filter '时，不需要使用for-loop。</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="385d" class="jr js iu ku b gy ky kz l la lb">list(filter(lambda x: x % 2 &gt; 0, arr))</span></pre><p id="b50a" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">它看起来很相似，但是当情况非常复杂时，很难在for循环中实现，否则使用' filter '将非常有用。</p><p id="b765" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">最后让我们看看另一种用法，这里有一个函数叫做“压缩”。通过使用它，我们可以使用一个数组作为条件来过滤另一个数组。</p><p id="3e10" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">例如，假设我们有两个数组。</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="a287" class="jr js iu ku b gy ky kz l la lb">student = ['James', 'Bob', 'Joe', 'Kitty']<br/>scores = [60, 70, 80, 40]</span></pre><p id="ab1a" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">我们想要60分以上的学生。通常，我们可以使用for循环来解决这个问题。但是如果我们使用compress，我们可以只使用一行代码，而不是使用for循环。</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="c45a" class="jr js iu ku b gy ky kz l la lb">from itemtools import compress<br/><br/>&gt;&gt;&gt; pass = [i &gt; 60 for i in scores]<br/>&gt;&gt;&gt; print(pass)<br/>[False, True, True, False]<br/><br/>&gt;&gt;&gt; list(compress(student, pass))<br/>['Bob', 'Joe']</span></pre><p id="f108" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">注意“compress”返回的结果是一个迭代器，如果我们需要特定的值，我们可以把它转换成列表。</p><p id="d950" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">虽然今天推荐的工具在我们的日常工作中不是必须的，但是如果我们很好地使用它们，它可能会节省我们很多时间。特别是，如果你在面试中，面试官让你写一些代码，使用这些先进的工具可能会给人留下好印象。</p><p id="57a4" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">今天的文章到此结束，祝你有一个愉快的Python之旅。</p></div></div>    
</body>
</html>