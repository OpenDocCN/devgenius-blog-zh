# Swift 中的存储库模式

> 原文：<https://blog.devgenius.io/repository-pattern-in-swift-a8eda25b515d?source=collection_archive---------3----------------------->

![](img/6529222701219c479048c96c135ecb49.png)

# 背景

所有开发的应用程序都需要某种描述的数据。这些数据存储在某个地方，可能在设备本身、远程数据库/服务或两者的组合中。让我们看看最常见的数据来源:

这些方法中的每一种都以不同的格式保存数据。现在，我敢肯定，在你的应用程序中，至少有一种方法是你用来检索/保存数据的。

当不使用存储库模式时，直接访问和使用这些元素是很常见的，要么在 ViewController 中，要么在应用程序的其他部分，这取决于它的结构。

# 问题是

这种做法有什么问题？你的应用变得难以维护。现在，如果你只有一个只有几个屏幕的小应用程序，那么这不是一个大问题，因为只有几个元素需要改变。

然而，如果你和几个开发人员一起开发一个大型应用程序，并且有很多代码，那该怎么办呢？例如，你可以让 [NSManagedObjects](https://developer.apple.com/documentation/coredata/nsmanagedobject) 或 [Codable](https://developer.apple.com/documentation/swift/codable) 对象散布在整个代码库中。如果您希望删除核心数据，会发生什么情况？或许搬到王国去？您需要修改代码库中使用核心数据对象的所有类。

类似地，如果您直接从 JSON 响应中使用可编码对象。当您的后端团队更改 API 或者您切换到不同的 API 提供商时会发生什么？数据的结构可能会改变，这意味着您的可编码对象可能会改变。同样，如果你在一个大的应用上工作，你将需要修改大量的类。

我们还可以将此应用于其他选项，例如从第三方框架访问数据。如果我们直接使用从框架返回的对象，如果我们改变提供者或者 SDK 改变，它们都需要改变。

还有查询语言的问题。Web 服务使用头和 [URLQueryItem](https://developer.apple.com/documentation/foundation/urlqueryitem) ，核心数据使用[谓词](https://developer.apple.com/documentation/foundation/nspredicate)等等。每一个查询数据的入口点都必须知道并理解底层的查询语言，以便一次就获得信息。同样，如果这种变化，我们需要改变每个查询点的新格式。

让我们看看下图:

![](img/9a23688b5bf992fb94f151641a54d7a5.png)

这里我们有一个利用核心数据的应用程序结构。有一个对象正被用来访问返回一些数据的堆栈。假设这个例子是新闻文章。这些新项目必须从 NSManagedObject 继承，才能在核心数据中使用。现在，如果我们的数据层将 NSManagedObjects 返回到我们应用程序结构的其余部分，我们现在就有了核心数据和应用程序中其余文件之间的依赖关系。例如，如果我们希望移动到 Realm，或者切换到使用其他形式的数据存储，我们需要修改应用程序中所有的文件。这个例子中的应用程序很小，想象一下一个大得多的应用程序必须这样做！

# 域对象和存储库

这就是域对象的用武之地。域对象是由应用程序定义的值对象。我们不是使用应用程序外部定义的对象和结构，而是定义我们希望对象看起来是什么样子。然后由存储库将数据存储对象/结构映射到这些值对象。

当我们这样做时，这意味着对数据访问层的任何更改，正如我们前面讨论的那样，如数据结构的更改或提供者的更改不会影响应用程序的其余部分。应用程序中唯一需要更新的部分是存储库及其到域对象的映射。

下面的引文总结了该模式的思想:

> 储存库是封装了访问数据源所需的逻辑的类或组件。它们集中了常见的数据访问功能，提供了更好的可维护性，并将用于访问数据库的基础设施或技术从域模型层中分离出来。

让我们看看前面的例子，但是修改后使用了存储库和域对象:

![](img/d0a88f32185eaf7120ac95e678a2a851.png)

那么这里的区别是什么呢？如您所见，核心数据堆栈仍在返回 NSManagedObjects，但是存储库正在将其转换为域对象。此对象不从 NSManagedObject 继承，它的结构和属性也是由应用程序定义的，而不是由数据存储中的内容定义的。

现在，如果我们想从核心数据转移到其他东西，唯一需要改变的类是核心数据堆栈和存储库。应用程序的其余部分不需要更改，因为我们可以使用存储库将新的数据存储类型映射到我们的域对象。

# 例子

为了展示一个小的工作示例，我们将使用几个[免费公共 API](https://github.com/public-apis/public-apis)(如果你想构建一个演示应用或实验，强烈推荐这个资源)。我们将使用 2 个返回用户的 API。但是他们以不同的格式返回它们。

【https://jsonplaceholder.typicode.com/users/1 

[https://randomuser.me/api/](https://randomuser.me/api/)

正如我们在[之前的博文](https://pyartez.github.io/networking/simple-json-decoder-in-swift-and-combine.html)中所做的，我们将使用 [QuickType](https://app.quicktype.io) 从我们的 JSON 响应中生成我们的可编码对象。我们将从第一个请求开始。

这个结构将允许我们解码第一个请求的响应。让我们做一个简单的例子，它接受响应并输出一些数据。我们将使用来自我们的简单 JSON 解码器的代码来处理输出，所以如果你看到的代码没有意义，请随意阅读。

让我们来看看这里发生了什么:

1.  首先，我们使用简单的 JSON 解码器发出请求，返回新的用户类型。
2.  输出任何错误
3.  因此，我们在这里输出我们得到的用户的姓名、地址和位置。现在超级简单。

# 管理变革

现在假设我们改变了供应商。也许我们的后端团队改变了 API，或者我们转换了数据提供者，或者从 2 个不同的数据提供者 SDK。在我们的例子中，我们将从第一个 URL([https://jsonplaceholder.typicode.com/users/1](https://jsonplaceholder.typicode.com/users/1))切换到第二个([https://randomuser.me/api/](https://randomuser.me/api/))。

我们需要做的第一件事是改变所有的可编码对象，因为响应的结构是不同的。让我们再次使用 QuickType 来给出新的结构:

对于我们的例子来说，这要复杂得多，但我把它留在这里，作为一个极端的例子，说明事情可以有多么不同。正如您可能已经知道的，从我们的第一个例子开始，结构和类型已经发生了巨大的变化。因此，让我们尝试输出与上一个示例相同的数据。我们可以忽略请求部分，只关注数据输出，这样我们就可以看到不同之处:

从这个简单的例子就可以看出。我们将不得不更改 7 行代码，只是为了产生相同的输出。现在想象这种变化发生在一个更大的项目中！可能有数百行代码需要更新，这都是因为 API 响应发生了变化。

# 知识库模式

这就是存储库模式的用武之地。我们可以创建一个用户存储库，获取用户并将其转换为我们的域对象。这样我们就不需要更新输出。

首先要做的是设计我们的域对象，它将在我们的系统中代表一个用户。现在我们在这个简单的例子中所做的就是输出一些属性，所以让我们只使用这些属性来设计我们的对象，因为我们不需要其他的属性。

这里我们有一个用户对象的简单表示。不需要考虑从 API 返回的任何其他可能的属性。我们不会在应用程序中使用它们，它们只会占用宝贵的内存。您还会注意到，该对象不符合 Codable 或 NSManagedObject 子类。这是因为 DomainObject 不应该包含任何关于它们如何存储的知识。这是存储库的责任。

为了设计我们的存储库，我们可以利用泛型和协议来设计一个可以用于任何事情的存储库，而不仅仅是我们的域用户。让我们看一看:

在这里，我们有不同的功能来完成我们能做的所有操作。您会注意到，这些函数都没有指定数据存储在哪里或者如何存储。还记得我们一开始谈到的不同储物选项吗？我们可以实现一个与 API 对话的 repo(就像我们的例子一样)，一个在核心数据中存储内容的 repo，或者一个向用户默认值写入内容的 repo。由实现协议的存储库来决定这些细节，我们所关心的是我们可以从某个地方加载和保存数据。

# 看它行动

现在我们已经定义了什么是存储库模式，让我们创建 2 个实现。一个用于我们的第一个请求，一个用于第二个请求。两者都应该返回域对象，而不是从请求中返回的类型。

这里有相当多的代码，所以让我们一步一步来。

1.  首先，我们已经定义了一个新的错误，如果我们没有从 API 接收到任何用户信息，就返回这个错误。
2.  这与我们在之前的示例中进行的调用相同。
3.  现在，我们获取返回的可编码用户，并将其转换为新的 DomainUser 类。
4.  在这个例子中，我们没有实现其他函数，所以暂时将它们留空以消除错误。
5.  这个结构是我们发出的第二个请求，这里我们再次将用户的可编码类型从第二个请求映射到我们的 DomainUser。

现在我们已经创建了两个存储库，让我们展示如何在不破坏/改变代码的情况下在它们之间快速切换。

这是本文前面的例子，但是更新后使用了新的存储库。在这里，我们获取用户并打印他们的详细信息，和以前一样。现在下面我们可以切换到我们的第二个请求，看看这将如何工作。

现在注意我们唯一改变的部分是实现类。代码的其余部分保持不变，即使数据的来源发生了变化，并以完全不同的结构返回。现在想象一下，我们在许多地方使用这个回购来获取用户详细信息。我们可以在不同的数据源之间快速切换，而无需更改使用它的代码。我们必须做的唯一更改是对 repo 和数据映射代码进行更改。所以只有一个变化，而不是每个使用这些对象的类都有变化。

# 结论

让我们回顾一下我们在这里讨论的内容:

*   首先，我们讨论了在整个代码库中使用数据存储类的问题。尤其是在需要切换数据源/结构的大型项目中。
*   然后，我们讨论了使用存储库模式和映射到域对象，而不是使用数据存储类，如何使您的代码在将来更容易更改。
*   我们研究了一些改变 API 结构如何影响代码的例子。
*   然后，我们实现了一个映射到域对象的基本存储库模式，以展示这样做如何使更新项目变得更容易。

最后，让我们讨论一下这种方法的利弊:

# 优势

*   如果需要切换数据源或结构，代码更容易更改
*   将数据存储在何处/如何的问题与应用程序的其他部分分开

# 不足之处

*   增加了更多代码和复杂性
*   需要为每个对象编写到域对象的映射器
*   在较小的个人项目中不需要

请随意[下载操场](https://github.com/pyartez/blog-samples)并自己玩这些例子

*原载于 2020 年 7 月 19 日*[*https://pyartez . github . io*](https://pyartez.github.io/architecture/repository-pattern-in-swift-and-combine.html)*。*