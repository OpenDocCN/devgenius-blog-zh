<html>
<head>
<title>Auto reload client-side after deployment with Angular 9 and firebase</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Angular 9 和 firebase 部署后自动重新加载客户端</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/auto-reload-client-side-after-deployment-with-angular-9-and-firebase-e2a9a5d8e9fb?source=collection_archive---------6-----------------------#2020-05-29">https://blog.devgenius.io/auto-reload-client-side-after-deployment-with-angular-9-and-firebase-e2a9a5d8e9fb?source=collection_archive---------6-----------------------#2020-05-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jk jl jm jn gh gi paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="gh gi gj"><img src="../Images/c8c405ba465ed1d412f2785955f80732.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BLfok3S-f1D6QQmtGt09OA.jpeg"/></div></div></figure><p id="76ab" class="pw-post-body-paragraph ju jv in jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ig bi translated">我相信，在频繁部署到生产环境的 Angular 应用程序中，每个人都面临的一个常见问题是用户对浏览器的硬刷新。我在网上遇到过几个解决方案，但是我想到了一个更简单的解决方案，那就是我现在正在使用的堆栈。因此，如果你正在使用 GitHub (CI/CD)，Firebase 函数，Firebase 实时数据库和 Angular 作为你的堆栈，那么系好安全带，因为它会变得像 ctrl+c，ctrl+v 一样简单。😁</p><p id="d0d5" class="pw-post-body-paragraph ju jv in jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ig bi translated">让我们将整个过程分成几个步骤:</p><ol class=""><li id="3c6f" class="ks kt in jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">部署时触发一个函数，在实时数据库中存储一个新的提交 id。</li><li id="144b" class="ks kt in jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">在一个主服务中编写一段代码，检查数据库中的提交 id 是否与浏览器中存储的 id 相匹配。</li></ol><p id="5cd0" class="pw-post-body-paragraph ju jv in jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ig bi translated">让我们首先从向 deploy.yml 文件的。github/workflows 将触发您的 firebase 功能。<br/>您需要在 jobs/deploy-dev/steps:下添加的行是-</p><figure class="lg lh li lj gt jn"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="15a0" class="pw-post-body-paragraph ju jv in jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ig bi translated">最后，您的 deploydev.yml 应该如下所示:</p><figure class="lg lh li lj gt jn"><div class="bz fp l di"><div class="lk ll l"/></div></figure></div><div class="ab cl lm ln hr lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ig ih ii ij ik"><p id="a984" class="pw-post-body-paragraph ju jv in jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ig bi translated">一旦我们完成了这一部分，我们已经成功地确保在我们的部署过程中，一个 firebase 函数将被触发。现在我们需要确保 firebase 函数确实将 GitHub 生成的提交 id 写入我们的 firebase 实时数据库。我们将从编写函数文件开始:</p><figure class="lg lh li lj gt jn"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="565f" class="pw-post-body-paragraph ju jv in jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ig bi translated">我们上面的简单函数检查在部署期间发送的请求体的类型，并获取秘密的惟一 github.sha，并将其用作提交 id。不要忘记将它添加到 firebase 函数的索引文件中:</p><figure class="lg lh li lj gt jn"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="1c44" class="pw-post-body-paragraph ju jv in jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ig bi translated">部署后，我们应该会在实时数据库的根节点下看到一个<em class="lt"> commitid </em>集合，看起来应该是这样的:</p><figure class="lg lh li lj gt jn gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/875c22d459de51c33a75f115cf22758e.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*eSpSqKb-n4JC1D10oynMUQ.png"/></div></figure></div><div class="ab cl lm ln hr lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ig ih ii ij ik"><p id="e617" class="pw-post-body-paragraph ju jv in jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ig bi translated">太好了！现在我们也在向数据库写入数据。剩下的就是在客户端读取它，并通过比较提交 id 来确保浏览器是最新部署的。我们将在任何主要服务中添加我们的代码片段。如果没有，可以在中创建一个，方法是转到项目目录的根目录并运行:</p><blockquote class="lv"><p id="5560" class="lw lx in bd ly lz ma mb mc md me kr dk translated"><em class="mf"> ng 生成服务系统</em></p></blockquote><p id="f9bd" class="pw-post-body-paragraph ju jv in jw b jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ig bi translated">在您的主服务文件中，您应该添加如下代码片段:</p><figure class="lg lh li lj gt jn"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="74ef" class="pw-post-body-paragraph ju jv in jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ig bi translated">一旦添加，这应该弹出一个基本的警告给用户，询问他们是否要重新加载浏览器。您的最终文件应该如下所示:</p><figure class="lg lh li lj gt jn"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="daaa" class="pw-post-body-paragraph ju jv in jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ig bi translated">你们都完了！现在，每当你部署一个新版本的应用程序时，所有的浏览器都会看到一个警告，要求它们重新加载，或者通知它们有一个新的版本。你也可以在浏览器的本地存储中看到这个提交 id，方法是进入你的 Chrome 开发者工具，在 Application:</p><figure class="lg lh li lj gt jn gh gi paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="gh gi ml"><img src="../Images/4721ba3619f5596084ecc60a30d3080e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v4vK6lODjy6HLLMdyHFAlQ.png"/></div></div></figure></div></div>    
</body>
</html>