<html>
<head>
<title>Flutter Protocol Oriented Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向颤振协议的编程</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/flutter-protocol-oriented-programming-c27082af9bfc?source=collection_archive---------4-----------------------#2020-07-11">https://blog.devgenius.io/flutter-protocol-oriented-programming-c27082af9bfc?source=collection_archive---------4-----------------------#2020-07-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="b0a7" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">抽象类实现</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/061b912358e9a523836db2baf1b81bf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*p4EIY5x5BgOQXQuS"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">由<a class="ae ks" href="https://unsplash.com/@arianismmm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Arian Darvishi </a>在<a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="e79f" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">为什么？</h1><p id="56fc" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">像 Swift 和 Kotlin 这样的语言大量依赖于面向协议的编程，因为它们有助于模块化、依赖注入、更简洁的代码和更容易的单元测试设置。</p><p id="fc4b" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">在 Flutter 的 Dart 语言中，我们有这样的<code class="fe mm mn mo mp b">abstract</code>类:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h1 id="ba98" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">这个怎么用？</h1><p id="b803" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">它们不能被直接实例化，当您无意中试图实例化容器装饰的<code class="fe mm mn mo mp b">border</code>属性的<code class="fe mm mn mo mp b">BoxBorder</code>时，您可能已经看到了这一点。但是它需要的类型是 BoxBorder，那么我该如何使用它呢？您可以简单地创建一个实现它的类，IDE 将自动添加它应该具有的所有属性和方法。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ms"><img src="../Images/f22386c3421a2fb8a1b3bdd6f979fed4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z0roNOKAcf7EGJNayYzADw.png"/></div></div></figure><p id="174e" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">抽象类是 Flutter 的协议类型，它不实例化对象，而是给其他类必要的功能和属性，以符合给定的目的。</p><p id="4c9f" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">这有助于<strong class="ln io">你</strong>开发人员组织你的代码，确保一个特定的类包含必要的函数和变量，并对一个类进行分段，以便调用它的对象只能使用它特别需要的函数。</p><p id="e8b7" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">基于基本协议的交互可以是:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mt"><img src="../Images/fe23f88592709ad1e47a5a8fe4056efa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fYPAko5QzkKLYgUmKrtAhQ.png"/></div></div></figure><p id="1718" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">我们是否有一个<code class="fe mm mn mo mp b">ServiceClass</code>包含两个不同类型的类所需的必要函数，但是依赖于 ServiceClass，因为它拥有获取函数的方法(想想 REST 端点、数据库等)。</p><p id="c389" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">和另外两个使用<code class="fe mm mn mo mp b">ServiceClass</code>的类，但是通过不使用 ServiceClass()对象而是使用它的实现类，它们只需要特定的函数。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="ba6b" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">为了分解它，我们有我们的<code class="fe mm mn mo mp b">abstract</code>类，我们的<code class="fe mm mn mo mp b">ServiceClass</code>将实现它，这个类将包含处理我们在其他类上需要的信息的所有逻辑。</p><p id="966f" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">其他类使用相同的<code class="fe mm mn mo mp b">ServiceClass</code>实例，但是只能访问协议允许它们使用的函数。为了确保它们使用正确的协议，你也可以为此创建新的<code class="fe mm mn mo mp b">abstract</code>类。</p><p id="bb9a" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">你在这里的好处，只是更好地划分你的代码。</p><p id="1a3d" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">但这其中真正的妙处可以在下面看到。</p><p id="e353" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">如果我们给我们的时钟添加另一个“复杂因素”，我们实际上可以告诉<code class="fe mm mn mo mp b">ServiceClass</code>以相同的分段方式执行来自我们其他类的代码，使我们的用户类更加简洁、整洁，并且只负责显示信息而不是处理信息的逻辑。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mt"><img src="../Images/7d62eafe3f433b0c97ccfde4badeb79b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lePrc-T6iD_JKvkKPIGN9A.png"/></div></div></figure><p id="c8af" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">看起来会像这样:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mu mr l"/></div></figure><p id="0b48" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">我们的初始设置是这样的:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="cb88" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">正如您所看到的，我们的委托的 setNameOrId 被重用了，现在我们不必编写两个单独的函数来管理 Id 或名称更新，它只需传递从 ServiceClass 发送的值。</p><p id="f7dd" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">这是这个例子的完整代码:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="8e3c" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">你可能已经注意到我在这里使用了另一个关键字，那就是 delegate。简单来说，委托是负责在另一个对象中执行代码的对象。当我们写 object.delegate = this 时，这是一种强调另一个对象将使用这个对象应该拥有的函数的方式，因此我们使用协议实现来确保我们拥有这个函数。</p><p id="662e" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">有关 dart 语言的更多信息，请查看官方文档:</p><p id="1160" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated"><a class="ae ks" href="https://dart.dev/samples#:~:text=more%20about%20mixins.-,Interfaces%20and%20abstract%20classes,you%20can%20implement%20any%20class.&amp;text=You%20can%20create%20an%20abstract,implemented)%20by%20a%20concrete%20class." rel="noopener ugc nofollow" target="_blank">飞镖样品</a></p><p id="fecd" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">我绝不认为自己是不可毁灭的，所以欢迎任何建议或评论。</p><p id="b573" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">页（page 的缩写）我推迟了 delegate 关键字的使用，以保持对面向协议的交互的关注。</p></div></div>    
</body>
</html>