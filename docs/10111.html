<html>
<head>
<title>Architecture Modelling &amp; Diagramming As Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">作为代码的架构建模和图表</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/architecture-modelling-diagramming-as-code-3636b42fdd17?source=collection_archive---------1-----------------------#2022-10-08">https://blog.devgenius.io/architecture-modelling-diagramming-as-code-3636b42fdd17?source=collection_archive---------1-----------------------#2022-10-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/06d6edfb3442f9fc552ed3a4c35b6ad2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IK2HFKD16ZY8kYfTQwNa-g.png"/></div></div></figure><p id="e0e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在过去几年中,“作为代码”这个术语已经成为“作为代码的基础设施”领域的主流。该领域的一个明显趋势是，越来越多的工具允许使用通用编程语言(如 TypeScript、Java 和 C#)而不是配置语言(如 YAML 或 JSON)来定义基础设施，如<a class="ae kw" href="https://aws.amazon.com/de/cdk/" rel="noopener ugc nofollow" target="_blank"> AWS CDK </a>或<a class="ae kw" href="https://www.pulumi.com/" rel="noopener ugc nofollow" target="_blank"> Pulumi </a>。</p><p id="8290" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我们将探索将“as code”范例应用于架构文档意味着什么，看看可用的工具以及依靠通用编程语言可以获得的好处。</p><h1 id="e1ae" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">作为代码的建筑是关于什么的？</h1><p id="4404" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">简而言之，它是关于以一种不主要依赖于绘图和图表的方式记录和描述您的系统架构，而是使用更接近于开发人员经常使用的工具。</p><p id="cb0f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">周围已经有一些工具允许“作为配置来绘图”，即<a class="ae kw" href="https://mermaid-js.github.io/mermaid" rel="noopener ugc nofollow" target="_blank">美人鱼</a>、<a class="ae kw" href="https://plantuml.com" rel="noopener ugc nofollow" target="_blank"> PlantUML </a>和<a class="ae kw" href="https://www.ilograph.com" rel="noopener ugc nofollow" target="_blank"> Ilograph </a>。所有这些都是将文本描述转换成可视化图表的工具。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/a980f1f8cfa9a26d1c7096c4e8e6618c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/1*7c0LtlVtI-UBicK2jLafMw.png"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">美人鱼图示例</figcaption></figure><p id="d7cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这些工具中，Mermaid 的优势在于能够将图表直接嵌入 markdown 文件中，并且有一些工具——包括 GitHub 呈现结果图表，而不是定义文本。</p><p id="966c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一方面，Ilograph 呈现了非常好的交互图，并且迈出了将架构模型从图中分离出来的第一步——但是后面会详细介绍。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/84dc0793e617f4f504fb850c6f121b39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*AP7ki031p-3V0fxSFViROQ.gif"/></div></figure><p id="ff03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，所有这些工具都有一些缺陷(从代码架构的角度来看):</p><ul class=""><li id="a9bf" class="mk ml iq ka b kb kc kf kg kj mm kn mn kr mo kv mp mq mr ms bi translated">它们依赖于配置语言，而不是通用编程语言</li><li id="2a73" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv mp mq mr ms bi translated">他们要么根本没有将架构模型从图中分离出来的概念(像 Mermaid 和 PlantUML)，要么将建模和图表混合在一起(像 Ilograph)</li></ul><h1 id="3335" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">使用 Structurizr 将架构模型从图的创建中分离出来</h1><p id="8679" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">为了更好地理解最后两个要点，让我们看看另一个工具:<a class="ae kw" href="https://structurizr.com/" rel="noopener ugc nofollow" target="_blank"> Structurizr </a>。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/b23b39dfe12e50e6e0bc4047371fb42e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8pMeAScneOWcFH-HFdoKpA.png"/></div></div></figure><p id="9c37" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我强调一下上面代码片段的一些内容:</p><ul class=""><li id="c56b" class="mk ml iq ka b kb kc kf kg kj mm kn mn kr mo kv mp mq mr ms bi translated">它使用 Java，而不是配置语言</li><li id="45da" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv mp mq mr ms bi translated">它清楚地将定义架构模型(意思是:系统的构建块以及它们之间的关系)与定义基于该模型的图分开</li><li id="8104" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv mp mq mr ms bi translated">它没有说这些图是如何呈现的。这是因为——虽然自带渲染引擎——Structurizr 可以与不同的渲染引擎一起使用，包括 Mermaid、PlantUML 和 Ilograph</li></ul><p id="fa52" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用 Structurizr 通常包括 3 个不同的步骤:</p><h2 id="cfbc" class="mz ky iq bd kz na nb dn ld nc nd dp lh kj ne nf ll kn ng nh lp kr ni nj lt nk bi translated"><strong class="ak"> 1。为您的架构建模</strong></h2><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/a05fde7398060f4123b9c90de1313436.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h32xmAd0q6_Xgk4D9qZPjg.png"/></div></div></figure><p id="759a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，您已经可以看到使用通用编程语言来描述您的架构的好处之一:它允许您应用相同的工具和技术来结构化和重构您的架构文档，就像您对“生产性”代码所做的那样。</p><h2 id="aea4" class="mz ky iq bd kz na nb dn ld nc nd dp lh kj ne nf ll kn ng nh lp kr ni nj lt nk bi translated"><strong class="ak"> 2。基于定义的模型定义图表</strong></h2><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/88c28cdd9785f1a378a630c6cbe23db5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ypEmSbJIquQ6YS2mo16iQ.png"/></div></div></figure><p id="fb01" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将图的定义从模型中分离出来，可以让您控制模型的哪些元素与图相关，而不需要跨图重复元素定义。</p><h2 id="7147" class="mz ky iq bd kz na nb dn ld nc nd dp lh kj ne nf ll kn ng nh lp kr ni nj lt nk bi translated"><strong class="ak"> 3。渲染图</strong></h2><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/a718ad849309322ad141c4d0a9df2f89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dx6lkZZiIly9lFUATxr8DA.png"/></div></div></figure><p id="6f73" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦您定义了您的模型和图，您就可以利用许多方法来呈现图:</p><ul class=""><li id="6a03" class="mk ml iq ka b kb kc kf kg kj mm kn mn kr mo kv mp mq mr ms bi translated">使用付费的<a class="ae kw" href="https://structurizr.com/help/cloud-service/getting-started" rel="noopener ugc nofollow" target="_blank"> Structurizr 云服务</a></li><li id="133d" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv mp mq mr ms bi translated">使用免费的<a class="ae kw" href="https://structurizr.com/help/lite" rel="noopener ugc nofollow" target="_blank"> Structurizr Lite </a> Docker 图像</li><li id="160e" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv mp mq mr ms bi translated">使用 PlantUML，Mermaid，Ilograph 等，详见<a class="ae kw" href="https://structurizr.org/" rel="noopener ugc nofollow" target="_blank">https://structurizr.org/</a></li></ul><h1 id="8bab" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">建模优于作图的优势</h1><p id="47e0" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">通过将架构模型从图的定义中分离出来，您获得了一些可能性，这些可能性在记录非平凡系统的架构(并且必须维护所述文档)时被证明是非常有价值的。</p><h2 id="5d32" class="mz ky iq bd kz na nb dn ld nc nd dp lh kj ne nf ll kn ng nh lp kr ni nj lt nk bi translated">创建多个一致的视图</h2><p id="707b" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">最大和最突出的好处之一是能够在同一个模型上创建多个一致的视图。</p><ul class=""><li id="a9ac" class="mk ml iq ka b kb kc kf kg kj mm kn mn kr mo kv mp mq mr ms bi translated">针对不同的受众，在不同的抽象层次上创建图表</li><li id="72a7" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv mp mq mr ms bi translated">创建包含系统组件不同子集的图表，突出不同的用例</li></ul><p id="72b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面的例子显示了两个不同的代码片段，在代码片段的旁边产生了图。两个图都是从同一个模型中创建的。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/21c2c8b002bdc9f7ae6e8ace23609a61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e-2Ugz8nG1eecLgzRHSeYQ.png"/></div></div></figure><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/5699d96b72874cbe326b512f49f9b772.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dlmNQCTYnFm6o7NFjDLGaA.png"/></div></div></figure><h2 id="5e33" class="mz ky iq bd kz na nb dn ld nc nd dp lh kj ne nf ll kn ng nh lp kr ni nj lt nk bi translated">重新设计图表</h2><p id="3fe8" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">您获得的第二个最有用的优势是能够快速和一致地(重新)样式化您的所有图表:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/d1266b3a56126ccf64c64d26a7188348.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DPzisJO6lfsyLd6Kz7Vdpw.png"/></div></div></figure><h1 id="7bdc" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">编码优于绘图的优势</h1><p id="7e94" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">最后，让我们更深入地了解使用通用编程语言创建架构模型和图表所能实现的类型——相对于基于配置的解决方案，如 Mermaid、PlantUML 或 Ilograph，或经典的绘图工具，如<a class="ae kw" href="https://diagrams.net/" rel="noopener ugc nofollow" target="_blank">diagrams.net</a>或 Visio。</p><h2 id="f592" class="mz ky iq bd kz na nb dn ld nc nd dp lh kj ne nf ll kn ng nh lp kr ni nj lt nk bi translated">更轻松的文档版本管理</h2><p id="ebee" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">这主要适用于比较基于代码的解决方案，如 Structurizr 和经典的绘图工具，如 diagrams.net。其他基于配置的解决方案，如 Mermaid，也获得了部分好处。</p><p id="88c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面的截图显示了…</p><ul class=""><li id="2737" class="mk ml iq ka b kb kc kf kg kj mm kn mn kr mo kv mp mq mr ms bi translated">一个使用 diagrams.net 创建的<code class="fe nr ns nt nu b">.drawio</code>文件，只做了一个小的布局更改</li></ul><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/a6f0065b2a84484df8c346be3181fe0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P_QpK6qhuUM8XJM74HhCRg.png"/></div></div></figure><ul class=""><li id="0220" class="mk ml iq ka b kb kc kf kg kj mm kn mn kr mo kv mp mq mr ms bi translated">在向系统架构中添加关于全新组件的文档之后的结构化模型</li></ul><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/2c70bd4f3bd453258b4891259b7347f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*daM-ak-xF1R7R1VZzE8qWw.png"/></div></div></figure><p id="8963" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于这些差异中哪一个更容易审查并带来更多价值，应该没有太多问题…</p><h2 id="73a3" class="mz ky iq bd kz na nb dn ld nc nd dp lh kj ne nf ll kn ng nh lp kr ni nj lt nk bi translated">工具之间的互操作性</h2><p id="4da0" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">当使用通用编程语言时，通常很容易添加与另一个工具的互操作性。我给你举个例子。假设您已经使用 Structurizr 创建了一个架构模型，但是想要使用 Ilograph 来呈现图表。使用像<a class="ae kw" href="https://github.com/ChristianEder/ilograph-typescript" rel="noopener ugc nofollow" target="_blank"> ilograph-typescript </a>这样的库，从你的结构化模型创建 ilograph 图只需要几行代码就可以实现:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/ab06db241f18ffb2606ac15964c3d8fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jDMJdm4lOEgWMrL6Eu6Vag.png"/></div></div></figure><h2 id="65fb" class="mz ky iq bd kz na nb dn ld nc nd dp lh kj ne nf ll kn ng nh lp kr ni nj lt nk bi translated">组件依赖一致地出现在图和代码中</h2><p id="60f1" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我就用一张图来说明这一点:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/f3de8f3e7025e448b14ec4f2c61d8cc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1DYuIfSXSHbzmg-fazuncw.png"/></div></div></figure><h2 id="9ea4" class="mz ky iq bd kz na nb dn ld nc nd dp lh kj ne nf ll kn ng nh lp kr ni nj lt nk bi translated">您的文档将更有可能保持最新</h2><p id="2e2f" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">让我们面对现实吧——大多数开发人员更喜欢编写代码，而不是使用 Visio 或其他绘图工具来使文档与不断变化的代码库保持一致。结果是，许多架构文档都过时了。使用源代码作为文档工作的基础，您可以将文档更新包含到 CI/CD 流程中。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/fc3ead6f97832fc9a59a002caf5e5880.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z_jhzOYX6bS0jVdSYWzLEw.png"/></div></div></figure></div><div class="ab cl oa ob hu oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ij ik il im in"><p id="f396" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">觉得这篇文章有用？在 Medium 上关注我(<a class="ae kw" href="https://medium.com/@christian.johann.eder" rel="noopener"> Christian Eder </a>)并查看我下面关于 Azure、AWS、基础设施代码和物联网的文章！不要忘记👏这篇文章分享一下吧！</p><ul class=""><li id="df22" class="mk ml iq ka b kb kc kf kg kj mm kn mn kr mo kv mp mq mr ms bi translated"><a class="ae kw" href="https://medium.com/@christian.johann.eder/using-newtonsoft-json-in-asp-net-core-and-signalr-55b0fa4645aa" rel="noopener">使用 Newtonsoft。ASP.NET 的 JSON Core 和 SignalR </a></li><li id="a678" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv mp mq mr ms bi translated"><a class="ae kw" href="https://awstip.com/deploying-an-asp-net-core-api-to-aws-fargate-using-cdk-dab10bef51a1" rel="noopener ugc nofollow" target="_blank">使用 CDK 将 ASP.NET 核心 API 部署到 AWS Fargate】</a></li><li id="862b" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv mp mq mr ms bi translated"><a class="ae kw" href="https://medium.com/@christian.johann.eder/consumer-driven-contract-testing-hosting-a-mocked-api-using-azure-functions-a42d634c47fd" rel="noopener">消费者驱动的契约测试——使用 Azure 函数托管模拟 API</a></li><li id="7ac8" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv mp mq mr ms bi translated"><a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/grouping-by-calendar-week-using-entity-framework-core-and-postgresql-49d24412e0e5">使用实体框架核心和 PostgreSQL 按日历周分组</a></li></ul><p id="5c74" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另外，如果你还不是中等会员，可以考虑在这里加入<a class="ae kw" href="https://medium.com/@christian.johann.eder/membership" rel="noopener"/>。</p></div></div>    
</body>
</html>