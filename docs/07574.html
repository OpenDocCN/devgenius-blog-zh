<html>
<head>
<title>A simple lexical analyser</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个简单的词法分析器</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/a-simple-lexical-analyser-aaa4329b18d0?source=collection_archive---------10-----------------------#2022-04-06">https://blog.devgenius.io/a-simple-lexical-analyser-aaa4329b18d0?source=collection_archive---------10-----------------------#2022-04-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="3861" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要求:为了能够看到你自己的词法分析器，确保你是在一个基于 Linux 的环境中工作。(对于 Windows 用户，请查看 WSL)</p><p id="faab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我将使用 Linux 提供的 lex 工具，它可以按照<a class="ae ki" href="https://stackoverflow.com/questions/3871425/how-to-install-lex-and-yacc-in-ubuntu" rel="noopener ugc nofollow" target="_blank">提到的</a>进行安装</p><p id="764f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">编译过程的第一步(即把源代码转换成机器码)是词法分析。合乎逻辑的第一步是确保程序只包含有效的字符和符号。一旦这一点得到确认，下一步就是解释代码的正确含义。</p><p id="5056" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">词法分析器将字符流转换成标记流。令牌是指一组有意义的字符。例如:标识符、整数、关键字、空白等等。每个程序都要运行一个词法分析器，词法分析器是一个定义语言接受的标记的程序。即什么是有效的。</p><p id="bbda" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我解释词法分析器工作的方式。<br/>只要输入被提供<br/> -保持两个指针，一个在字符串的开始，另一个指针向右移动，只要满足一个正则表达式条件。<br/> -当不存在匹配条件时，开始指针被移动到结束指针的位置(这标志着在开始和结束指针之间创建了一个令牌)，结束指针继续向右移动。</p><blockquote class="kj kk kl"><p id="50df" class="jk jl km jm b jn jo jp jq jr js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kh ig bi translated">现在让我们构建一个简单的词法分析器来计算给定文本中的字符和单词的数量，这将用 C 编写</p></blockquote><p id="11a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">词法分析器由 3 部分组成</p><p id="a2df" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">1.声明(用 C 语言编写)</p><p id="79ef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.规则(Regex 和 C)</p><p id="35be" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.辅助功能(用 C 语言编写)</p><blockquote class="kj kk kl"><p id="4a6a" class="jk jl km jm b jn jo jp jq jr js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kh ig bi translated">申报</p></blockquote><p id="f74b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">声明由头文件、变量定义等组成。它还可能包含正则表达式的模板</p><blockquote class="kj kk kl"><p id="b711" class="jk jl km jm b jn jo jp jq jr js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kh ig bi translated">规则</p></blockquote><p id="8373" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从字符流中识别标记的规则是基于正则表达式决定的。每个正则表达式规则都是以互斥的方式一个接一个地编写的。在一个空格之后，写入所需 C 代码的期望动作</p><blockquote class="kj kk kl"><p id="59de" class="jk jl km jm b jn jo jp jq jr js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kh ig bi translated">辅助功能</p></blockquote><p id="1549" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">C 语言中执行一些计算的函数，或者这里包含的主函数</p><p id="f039" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">密码</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="10ca" class="kz la in kv b gy lb lc l ld le">// Declaration enclosed in % { %}</span><span id="78f4" class="kz la in kv b gy lf lc l ld le">%{</span><span id="4723" class="kz la in kv b gy lf lc l ld le">#include&lt;stdio.h&gt;</span><span id="36f5" class="kz la in kv b gy lf lc l ld le">#include&lt;string.h&gt;      </span><span id="69bd" class="kz la in kv b gy lf lc l ld le">int word = 0;</span><span id="eaa3" class="kz la in kv b gy lf lc l ld le">int chars = 0;</span><span id="4569" class="kz la in kv b gy lf lc l ld le">%}<br/></span><span id="e023" class="kz la in kv b gy lf lc l ld le">// Rules specified as regex space action enclosed in %%</span><span id="43f8" class="kz la in kv b gy lf lc l ld le">%%                          </span><span id="fdbe" class="kz la in kv b gy lf lc l ld le">[a-zA-Z]+ {word += 1;  chars += strlen(yytext);} </span><span id="4af7" class="kz la in kv b gy lf lc l ld le">// yytext stores the latest token encountered, getting its length to get the length of the word</span><span id="cd0d" class="kz la in kv b gy lf lc l ld le"># return 0; // # indicated the end of the input</span><span id="2cee" class="kz la in kv b gy lf lc l ld le">. ;  // on any other character do nothing</span><span id="d677" class="kz la in kv b gy lf lc l ld le">%%</span><span id="353c" class="kz la in kv b gy lf lc l ld le">// Auxillary functions</span><span id="9cfb" class="kz la in kv b gy lf lc l ld le">// This returns an error if not included, doesnt mean anything but include this function prototype</span><span id="2979" class="kz la in kv b gy lf lc l ld le">int yywrap(){return 0;}</span><span id="0c6d" class="kz la in kv b gy lf lc l ld le">int main(){</span><span id="d207" class="kz la in kv b gy lf lc l ld le">printf("Enter the input \n");</span><span id="7d64" class="kz la in kv b gy lf lc l ld le">// this function has an in-built scanf, or can read from a file input</span><span id="a6ab" class="kz la in kv b gy lf lc l ld le">yylex();    </span><span id="092c" class="kz la in kv b gy lf lc l ld le">printf("The number of words are %d \n" , word);</span><span id="f8ec" class="kz la in kv b gy lf lc l ld le">printf("The number of characters are %d \n ", chars);</span><span id="10a3" class="kz la in kv b gy lf lc l ld le">return 0;</span><span id="bb1a" class="kz la in kv b gy lf lc l ld le">}</span></pre><p id="b843" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">给定一个输入，词法分析器将返回包含的单词数和字符数。通过键盘输入#时，函数 yylex()返回。yylex()是 lex 实用程序的内置函数。</p><p id="5d2e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的代码被粘贴到一个带有<strong class="jm io">的文件中。l </strong>扩展，即可以是<strong class="jm io"> main.l </strong></p><p id="c53c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">执行命令</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="d704" class="kz la in kv b gy lb lc l ld le">lex main.l</span></pre><p id="3764" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">它生成了一个 C 文件，命名为 lex . YY . C</strong></p><p id="0a08" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">lex 实用程序主要负责将正则表达式转换成 C 语言</strong>。这也可以手动完成，但会变得非常复杂😅</p><p id="db79" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们有了一个 C 文件，只需按照通常的方式编译它</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="7431" class="kz la in kv b gy lb lc l ld le">gcc lex.yy.c // gived an executable a.out<br/>./a.out</span></pre><figure class="kq kr ks kt gt lh gh gi paragraph-image"><div class="gh gi lg"><img src="../Images/de64ccfa94d30a8f599df88c35b9aafe.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*43P1HyUrnHRyP0EeQQ_cNw.png"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated">生成的输出</figcaption></figure></div></div>    
</body>
</html>