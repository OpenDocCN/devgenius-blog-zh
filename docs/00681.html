<html>
<head>
<title>Debouncing in React with our own Custom React hook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用我们自己定制的 React 钩子去抖</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/debouncing-in-react-with-our-own-custom-react-hook-f9032bcfb3de?source=collection_archive---------13-----------------------#2020-06-14">https://blog.devgenius.io/debouncing-in-react-with-our-own-custom-react-hook-f9032bcfb3de?source=collection_archive---------13-----------------------#2020-06-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a8b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">simple 软件开发中的去抖是一种用于节省计算资源的技术，当输入变化非常频繁时，只对最新输入进行昂贵的计算。这里只有最新输入的输出是相关的。<a class="ae kl" href="https://codesandbox.io/s/debounce-example-48dzj?fontsize=14&amp;hidenavigation=1&amp;theme=dark" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">这里直接跳转到代码</strong> </a></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/d3fed6dce245b940ebf8ff6a725dc3c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EoLVerPHAEP0BSo6YR2MUA.jpeg"/></div></div></figure><p id="28de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，典型且非常常见的去抖用例是在搜索页面的前端开发中。比方说，去其他星系旅行是现实。现在，你是一个崭露头角的企业家，想开发一个星际旅行计划应用程序。人们可以搜索地点(目前我们只关心这个)，也可以做其他典型的事情。你建造了一切。</p><p id="2cb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你的网站获得了真正的吸引力，有成千上万的人在寻找他们的下一次星际冒险。你的后端经常崩溃。您需要扩展您的搜索服务后端，这将随着用户呈指数级增长。天气晴朗的一天，你意识到人们打字真的很快，平均每分钟约 175 个字符。当他们打出“开普勒”(某些开普勒的班加罗尔)时，你每次按键都会向后端发出请求。但是只有“kepalore”的结果与用户相关。此外，你的用户分析显示，如果用户希望看到搜索结果，那么在按键过程中会有间隙。所以，你找到了它，一个在不影响用户体验的情况下优化或最小化后端调用数量的地方。</p><p id="2bd9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只有当用户停止输入一段时间后，你才可以进行后端调用，在这个例子中是 300 毫秒。</p><p id="c84f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您正在使用 Reactjs 作为您的前端框架，并且碰巧使用了 react 钩子。最重要的是，你有一个严格的第三方一揽子规则。你打电话给我寻求一些初步的指导。</p><p id="9634" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[理解需求后]</p><p id="a901" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">我:</strong>浏览器里已经有一些东西可以用来在一定时间后触发呼叫。我们可以将后端调用函数作为参数传递给 setTimeout，并将超时设置为 300。我们可以使用下面的代码。</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="0b63" class="ld le iq kz b gy lf lg l lh li">// inside the search change event (or the input onchange handler)<br/>setTimeout(() =&gt; getResultsFromBackend(searchTerm), 300)</span></pre><p id="fb23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你:这太棒了，但是我发现上面的代码有问题。即使调用是在 300 毫秒后进行的，后端仍然会为每个字符调用。</p><p id="1767" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">我:</strong>是的，我现在看到问题了。让我想一想。哦，对了，setTimeout 返回<strong class="jp ir"> timerId </strong>，如果在 300 毫秒内按下一个新字符，我们可以用它来清除旧的超时。</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="e76f" class="ld le iq kz b gy lf lg l lh li">// timerId is declared in a upper scope say.<br/>if (timerId) {<br/>// if there is a timerId they we know there was a key press and the getResultsFromBackend is scheduled to be called in sometime but as there is a new key press we only want getResultsFromBackend to be called after 300ms with the new search term.</span><span id="4c66" class="ld le iq kz b gy lj lg l lh li">clearTimeout(timerId);</span><span id="698b" class="ld le iq kz b gy lj lg l lh li">// this will clear the timer and not call getResultsFromBackend for the old value</span><span id="7a9d" class="ld le iq kz b gy lj lg l lh li">}<br/>timerId = setTimeout(() =&gt; getResultsFromBackend(searchTerm), 300);</span><span id="08c8" class="ld le iq kz b gy lj lg l lh li">// this sets the getResultsFromBackend to be called in 300ms with the new search term</span><span id="cfce" class="ld le iq kz b gy lj lg l lh li"><br/>// Example </span><span id="f8b7" class="ld le iq kz b gy lj lg l lh li">Keypress:  'k'</span><span id="4fc6" class="ld le iq kz b gy lj lg l lh li">Backend is set to be called in 300ms with search value 'k'</span><span id="34b4" class="ld le iq kz b gy lj lg l lh li">Keypress (within 300ms) : 'e'</span><span id="da3b" class="ld le iq kz b gy lj lg l lh li">Clears the scheduled called of backend with 'k'<br/>Schedules new call with value 'ke' in 300ms</span><span id="bc15" class="ld le iq kz b gy lj lg l lh li">Keypress (within 300ms) : 'p'</span><span id="fd04" class="ld le iq kz b gy lj lg l lh li">Clears the scheduled called of backend with 'ke'<br/>Schedules new call with value 'kep' in 300ms</span><span id="cb89" class="ld le iq kz b gy lj lg l lh li">User stops for 300ms</span><span id="5f6f" class="ld le iq kz b gy lj lg l lh li">Sends the backend call for Kep.</span></pre><p id="eeba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你:这正是我们想要的。现在让我们用 react hook 实现它。</p><p id="23d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> React 钩子去抖实现</strong></p><p id="072d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们开始吧</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="1eea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以通过多接受一个函数作为参数来使钩子更加通用，该函数将获取事件作为参数并返回格式化的值。这将允许您处理所有类型的输入。</p><p id="a230" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随时重用和指出任何问题。</p></div></div>    
</body>
</html>