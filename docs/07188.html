<html>
<head>
<title>Deploy Socket.io to Kubernetes - Part 1: Chat Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将 Socket.io 部署到 Kubernetes -第 1 部分:聊天应用程序</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/deploy-socket-io-to-kubernetes-part-1-chat-application-f0824fed648a?source=collection_archive---------3-----------------------#2022-03-04">https://blog.devgenius.io/deploy-socket-io-to-kubernetes-part-1-chat-application-f0824fed648a?source=collection_archive---------3-----------------------#2022-03-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><h2 id="fdcc" class="il im in bd b dl io ip iq ir is it dk iu translated" aria-label="kicker paragraph">插座。木卫一和库伯内特</h2><div class=""/><div class=""><h2 id="70a9" class="pw-subtitle-paragraph jt iw in bd b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk dk translated">解释聊天应用程序的工作原理和对原始教程的改进。</h2></div><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/d2b96431dd48c29518166301f2f72c9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*N9sOZJru_PITt95Q.png"/></div></div></figure><p id="4604" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">要阅读其他部分:</p><ul class=""><li id="d082" class="lt lu in kz b la lb ld le lg lv lk lw lo lx ls ly lz ma mb bi translated"><a class="ae mc" rel="noopener ugc nofollow" target="_blank" href="/deploy-socket-io-to-kubernetes-part-0-overview-f192428b48a4">第 0 部分:概述</a></li><li id="e68e" class="lt lu in kz b la md ld me lg mf lk mg lo mh ls ly lz ma mb bi translated"><a class="ae mc" rel="noopener ugc nofollow" target="_blank" href="/deploy-socket-io-to-kubernetes-part-2-infrastructure-7764fec252d0">第二部分:基础设施</a></li></ul><p id="6a7d" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">欢迎回到我在 Kubernetes 上部署 Socket.io 的旅程！在这一部分，我想解释一下这个聊天应用程序是如何工作的，以及这个应用程序的构建模块和我开发这个应用程序的经验。</p><h1 id="0c2f" class="mi mj in bd mk ml mm mn mo mp mq mr ms kc mt kd mu kf mv kg mw ki mx kj my mz bi translated">聊天应用程序的工作原理</h1><p id="0088" class="pw-post-body-paragraph kx ky in kz b la na jx lc ld nb ka lf lg nc li lj lk nd lm ln lo ne lq lr ls ig bi translated">聊天 app 基本上有两个部分，客户端/前端和服务器/后端。客户端和服务器通过 Socket.io 连接，socket . io 构建在 Websocket 之上。在这一节中，我将描述客户机如何与服务器通信。</p><h2 id="ad8e" class="nf mj in bd mk ng nh dn mo ni nj dp ms lg nk nl mu lk nm nn mw lo no np my it bi translated">客户</h2><p id="0f57" class="pw-post-body-paragraph kx ky in kz b la na jx lc ld nb ka lf lg nc li lj lk nd lm ln lo ne lq lr ls ig bi translated">这里的客户端/前端是指用户看到并与之交互的网站。这个项目中的客户端是用 Next.js 构建的，因为它是 React 的高级包装器。与 React 相比，它更容易与 CSS 库(如 Tailwind)集成。与我们必须放置自己布局的 React 相比，Next.js 一开始就有一个结构化的文件夹布局。但是，如果您认为 Next.js 太大或者根本没有必要，您可以使用 React。</p><p id="16a8" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">现在，我不会详细介绍 React 和/或 Next.js，但是我想首先指出客户端的一些关键部分，这些部分使得开发聊天应用程序成为可能:</p><ol class=""><li id="ff55" class="lt lu in kz b la lb ld le lg lv lk lw lo lx ls nq lz ma mb bi translated">钩子:这个钩子允许我们在内存中存储数据。不仅如此，存储在这个钩子中的数据成为组件的状态，这意味着它们影响组件的行为，从显示不同的数据到根据不同的状态进行后台处理。</li><li id="9fd0" class="lt lu in kz b la md ld me lg mf lk mg lo mh ls nq lz ma mb bi translated"><code class="fe nr ns nt nu b">useContext</code> hook:如果 useState 中的数据可以在组件内部使用，那么存储在 useContext hook 中的数据可以在整个应用程序中存储和使用。这对于聊天应用程序很有帮助，因为我们希望处理跨组件使用的数据，例如房间 ID 和我们当前的用户名。</li><li id="5c37" class="lt lu in kz b la md ld me lg mf lk mg lo mh ls nq lz ma mb bi translated"><code class="fe nr ns nt nu b">useEffect</code>钩子:<code class="fe nr ns nt nu b">useEffect</code>允许我们根据某些依赖关系做一些逻辑。这在某些情况下很有用，例如，每当客户端收到新消息时就重新呈现页面。此外，在这个聊天应用程序中，我使用<code class="fe nr ns nt nu b">useEffect</code>为每个事件创建 Socket.io 监听器，这样我就不用为每个页面渲染创建监听器了(在最后一部分有更多关于这个 bug 的信息)。</li></ol><p id="f0dd" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">至于我是怎么学会这个的，你可以看看，还有我从原教程中做的改进。</p><div class="nv nw gp gr nx ny"><a href="https://github.com/iamdejan/socketio-chat-app/tree/master/client" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ix gy z fp od fr fs oe fu fw iw bi translated">socket io-chat-app/master iam dejan 上的客户端/socketio-chat-app</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">这是一个用 create-next-app 引导的 Next.js 项目。首先，运行开发服务器:打开…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">github.com</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om kv ny"/></div></div></a></div><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi on"><img src="../Images/c6c8e56dab8b607d7a870484e7eb43f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2T6no15SsMG90kVham4Crg.png"/></div></div><figcaption class="oo op gj gh gi oq or bd b be z dk translated">聊天应用程序的客户端或前端。</figcaption></figure><h2 id="b51c" class="nf mj in bd mk ng nh dn mo ni nj dp ms lg nk nl mu lk nm nn mw lo no np my it bi translated">计算机网络服务器</h2><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi os"><img src="../Images/7c3fd93cb256aad56f5ec4599de697e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OuWjZY8iT2OjWtyEHwL8QQ.png"/></div></div><figcaption class="oo op gj gh gi oq or bd b be z dk translated">聊天服务器的健康检查端点。</figcaption></figure><p id="64b9" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">服务器没有什么特别的，除了用来:</p><ol class=""><li id="d868" class="lt lu in kz b la lb ld le lg lv lk lw lo lx ls nq lz ma mb bi translated">接收消息；</li><li id="e837" class="lt lu in kz b la md ld me lg mf lk mg lo mh ls nq lz ma mb bi translated">在数据库上存储消息；和</li><li id="f330" class="lt lu in kz b la md ld me lg mf lk mg lo mh ls nq lz ma mb bi translated">将消息广播给同一房间的其他客户。</li></ol><p id="da2e" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">服务器使用 Socket.io 与客户端通信，确保来自一个客户端的每个更新都可以转发到其他客户端。</p><p id="6300" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">服务器是建立在 Express.js 之上的，因为 Socket.io 是为了配合 Express.js 使用而设计的，Socket.io 团队建议程序员在 Express.js 服务器上附加 Socket.io 库，这样当 Express.js 启动时，Socket.io 连接也会启动。</p><div class="nv nw gp gr nx ny"><a href="https://github.com/iamdejan/socketio-chat-app/tree/master/server" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ix gy z fp od fr fs oe fu fw iw bi translated">socket io-chat-app/主 iamdejan 上的服务器/socketio-chat-app</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">使用 Next.js 和 Socket.io 制作的简单聊天应用程序。通过创建一个…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">github.com</p></div></div><div class="oh l"><div class="ot l oj ok ol oh om kv ny"/></div></div></a></div><h2 id="393d" class="nf mj in bd mk ng nh dn mo ni nj dp ms lg nk nl mu lk nm nn mw lo no np my it bi translated">用于通信的 Socket.io</h2><p id="1223" class="pw-post-body-paragraph kx ky in kz b la na jx lc ld nb ka lf lg nc li lj lk nd lm ln lo ne lq lr ls ig bi translated"><a class="ae mc" href="https://socket.io/" rel="noopener ugc nofollow" target="_blank"> Socket.io </a>是一个双向网络通信库，构建在 Websocket 之上。它使用 Websocket 协议来发送和接收来自客户端和服务器的消息。在 Websocket 不可用的情况下，Socket.io 可以回退到<a class="ae mc" href="https://www.pubnub.com/blog/http-long-polling/" rel="noopener ugc nofollow" target="_blank"> HTTP 轮询</a>(虽然我个人禁用了这个，因为 HTTP 轮询是资源密集型的)。</p><p id="b12d" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">Socket.io 有很多有用的特性，但是在创建聊天应用程序时非常有用的一个特性叫做<a class="ae mc" href="https://socket.io/docs/v4/rooms/" rel="noopener ugc nofollow" target="_blank">房间</a>。Socket.io 可以为您创建一个“房间”，然后您可以将您的消息广播仅限于该房间内的其他用户，就像真实世界的通信一样。用户可以加入和离开房间，就像真实世界一样。这是 Websocket 没有的功能(而且要自己实现)。</p><p id="bcf5" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">我使用 Socket.io 的原因是 Socket.io 被设计成 Websocket 的高级包装器。换句话说，Socket.io 的设计比 Websocket 更容易使用。另外，Socket.io 有一个<a class="ae mc" href="https://socket.io/docs/v4/emit-cheatsheet/" rel="noopener ugc nofollow" target="_blank">有用的备忘单</a>在开发过程中帮助程序员。</p><p id="a4e7" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">注意:Socket.io 不是一个专用的服务，而是一个依附于服务器和客户端的库。</p><h2 id="e23c" class="nf mj in bd mk ng nh dn mo ni nj dp ms lg nk nl mu lk nm nn mw lo no np my it bi translated">雷迪斯</h2><p id="e196" class="pw-post-body-paragraph kx ky in kz b la na jx lc ld nb ka lf lg nc li lj lk nd lm ln lo ne lq lr ls ig bi translated">您可能认为我使用 Redis 进行缓存。然而，不，我不使用 Redis 进行缓存。相反，我使用<a class="ae mc" href="https://redis.io/topics/pubsub" rel="noopener ugc nofollow" target="_blank"> Redis 发布/订阅</a>进行 pod 间通信。我的计划是，当我将这个应用程序部署到 Kubernetes 时，我将创建不止 1 个<a class="ae mc" href="https://kubernetes.io/docs/concepts/workloads/pods/" rel="noopener ugc nofollow" target="_blank"> pod </a>(可能是 3 个)，仅仅是为了可伸缩性。但这意味着，每个 pod 都需要与其他 pod 通信，这就是为什么我们需要发布-订阅系统。</p><p id="ec15" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">现在，在所有的发布-订阅系统中，为什么是 Redis？原因是 Redis Pub/Sub 是 Socket.io 支持的<a class="ae mc" href="https://socket.io/docs/v4/redis-adapter/" rel="noopener ugc nofollow" target="_blank">。Socket.io 有一个名为“adapters”的特性，我们可以将几个发布-订阅系统连接到 Socket.io，这样每当我们创建一个 Socket.io 服务器集群时，这些服务器就可以进行通信和协调，以完成它们的任务。</a></p><h2 id="bbf1" class="nf mj in bd mk ng nh dn mo ni nj dp ms lg nk nl mu lk nm nn mw lo no np my it bi translated">MongoDB</h2><p id="d470" class="pw-post-body-paragraph kx ky in kz b la na jx lc ld nb ka lf lg nc li lj lk nd lm ln lo ne lq lr ls ig bi translated">在这个应用程序中，我使用 MongoDB 持久化消息。对于那些不知道的人来说，MongoDB 是一个很受欢迎的 NoSQL 持久性数据库，尤其是在 JavaScript 和 TypeScript 开发人员中。它的灵活性让程序员爱不释手。至于我为什么用 MongoDB，你可以在下面的<code class="fe nr ns nt nu b">Improvement #2: Persistent Messages</code>一节阅读。</p><h1 id="79aa" class="mi mj in bd mk ml mm mn mo mp mq mr ms kc mt kd mu kf mv kg mw ki mx kj my mz bi translated">我从哪里学的这个？</h1><p id="4ec4" class="pw-post-body-paragraph kx ky in kz b la na jx lc ld nb ka lf lg nc li lj lk nd lm ln lo ne lq lr ls ig bi translated">我从 TomDoesTech 制作的 YouTube 上的一个视频中了解到这一切。他在 Next.js 上讲解了如何使用 Socket.io，视频很长(1 小时左右)，但值得一看。然而，我可以从视频中做出一些改进。</p><h2 id="7d11" class="nf mj in bd mk ng nh dn mo ni nj dp ms lg nk nl mu lk nm nn mw lo no np my it bi translated">改进#1:内存泄漏错误</h2><div class="nv nw gp gr nx ny"><a href="https://github.com/TomDoesTech/Realtime-Chat-Application/blob/main/client/context/socket.context.tsx#L38-L46" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ix gy z fp od fr fs oe fu fw iw bi translated">主 TomDoesTech/real time-Chat-Application/socket . context . tsx</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">此文件包含双向 Unicode 文本，其解释或编译可能与下面显示的不同…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">github.com</p></div></div><div class="oh l"><div class="ou l oj ok ol oh om kv ny"/></div></div></a></div><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ov"><img src="../Images/cb055688bdd850efbb011495fea684c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PIPMLnNDix44aQhusJVaYQ.png"/></div></div><figcaption class="oo op gj gh gi oq or bd b be z dk translated">原始代码，其中 bug 用深橙色代码块标记。</figcaption></figure><p id="815a" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">如果你打开代码或者看到上面的截图，你会看到原来的代码并没有把<code class="fe nr ns nt nu b">socket.on(...)</code>放在<code class="fe nr ns nt nu b">useEffect</code>钩子里面。效果是 Socket.io 将注册(读取:创建)每个页面呈现的每个侦听器。我在测试中艰难地学会了这一点。我不知道为什么页面没有反应。我问过我的朋友，他们也不知道为什么。最终，我在的 dev.to 上找到了<a class="ae mc" href="https://dev.to/bravemaster619/how-to-prevent-multiple-socket-connections-and-events-in-react-531d" rel="noopener ugc nofollow" target="_blank">这篇文章，解释了如何在 React 中使用 Socket.io。当阅读那篇文章时，我突然记起所有放在<code class="fe nr ns nt nu b">useEffect</code>之外的东西都会在每一页渲染时被执行。</a></p><h2 id="412e" class="nf mj in bd mk ng nh dn mo ni nj dp ms lg nk nl mu lk nm nn mw lo no np my it bi translated">改进 2:持久消息</h2><p id="c200" class="pw-post-body-paragraph kx ky in kz b la na jx lc ld nb ka lf lg nc li lj lk nd lm ln lo ne lq lr ls ig bi translated">我对聊天应用程序做的第二个改进是将这些消息存储在数据库中。我选择 MongoDB 有两个原因:</p><ol class=""><li id="d703" class="lt lu in kz b la lb ld le lg lv lk lw lo lx ls nq lz ma mb bi translated">在 Kubernetes 中，使用数据库的最佳实践是使用<a class="ae mc" href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/" rel="noopener ugc nofollow" target="_blank"> StatefulSet </a>。然而，对于像我这样的 Kubernetes 初学者来说，管理 StatefulSet 可能是一件痛苦的事情。因此，我尝试将 MongoDB 管理外包给第三方。甚至 Bret Fisher 和 Nana Janashia(来自 Techworld with Nana)(两人都是知名的 Docker 船长)都建议，除非我们有专门的数据库管理员(来管理数据库)，否则最好将数据库管理外包出去。</li><li id="9233" class="lt lu in kz b la md ld me lg mf lk mg lo mh ls nq lz ma mb bi translated">我有一个来自 MongoDB Atlas 的免费计划。虽然不多(只有 5 GB)，但对于学习来说，绰绰有余。</li></ol><p id="6d21" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">如果想坚持，不一定要用 MongoDB。您可以使用任何可用的持久数据库，无论是 MySQL、PostgreSQL 还是其他数据库。碰巧我有一个免费计划，我懒得为数据库和表的创建编写 SQL 脚本:-)</p></div><div class="ab cl ow ox hr oy" role="separator"><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb"/></div><div class="ig ih ii ij ik"><p id="6371" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">我希望上面的文章解释了应用程序部分，以及它们如何作为一个聊天应用程序一起工作。在下一部分中，我将讨论允许 Socket.io 部署到 Kubernetes 的基础设施和配置。敬请期待！</p></div></div>    
</body>
</html>