<html>
<head>
<title>Empirical Developer - real life experiences that tamed my programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">经验性开发者——驯服我的编程的真实生活经历</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/empirical-developer-fc04e9547cfa?source=collection_archive---------37-----------------------#2020-07-08">https://blog.devgenius.io/empirical-developer-fc04e9547cfa?source=collection_archive---------37-----------------------#2020-07-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="c11f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每当我阅读那些关于干净的架构、完美的代码或良好实践的文章时，我总是想起我花了很多时间才自然地使用它们。这并不是因为我不知道如何使用它。因为我不太相信那些建议。对我来说，重要的知识不是如何做？而是<strong class="jm io">为什么要这么做？</strong>，或者更准确地说<strong class="jm io">为什么会有回报？我相信这并不明显，尤其是当我们唯一的理由是在未来它会节省我们的时间。我读过的大多数文章都有在一些虚拟项目中完成的例子，这并没有什么帮助。我认为这些只是用来炫耀的花哨、奢侈的图案，而实际上只有汗水和灰尘的地方。因为我想成长为一名开发人员，所以我试着使用它们，但是我真的感觉不到。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/3ce6c952a9248648b5b3791a2de6490f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*DS2z8eltmf-aFap9.jpg"/></div></figure><p id="b91a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正因为如此，这是一些随机的启发时刻，这些年来，使我成为一个更好的程序员。这就是为什么我想与那些需要接触才能理解的反叛者分享那些时刻。</p></div><div class="ab cl kq kr hr ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="ig ih ii ij ik"><h2 id="6483" class="kx ky in bd kz la lb dn lc ld le dp lf jv lg lh li jz lj lk ll kd lm ln lo lp bi translated">单元测试——如何加速你的任务</h2><p id="477e" class="pw-post-body-paragraph jk jl in jm b jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd lu kf kg kh ig bi translated">优点的清单是无穷无尽的，像“没有测试的代码是遗留代码”这样的短语让它变得更加清晰。所以为什么未经测试的项目不是城市传说。事实上，我们都知道没有他们的项目。我认为这可能是因为我们倾向于寻求即时的满足，而不是未来的利润。但是如果我告诉你写测试可能会让你更快呢？</p><ul class=""><li id="c6b1" class="lv lw in jm b jn jo jr js jv lx jz ly kd lz kh ma mb mc md bi translated">我开发了一个银行应用。那里的虫子很难繁殖。对我的朋友来说，这不是问题。他检查日志，用给定的值创建新的测试用例，工作就完成了。对一个开发者来说需要几天的事情，对他来说只需要几个小时。有时项目是如此健壮，以至于很难手工重现 bug，但是通过测试，你可以模拟任何情况，并且它是 100%确定的。</li><li id="6f62" class="lv lw in jm b jn me jr mf jv mg jz mh kd mi kh ma mb mc md bi translated">另一个类似的例子是当我必须在同一个银行项目中创建一个输入格式化程序时。想象一下手工测试解决方案。安装和运行一个应用程序，手动输入文本来检查新的格式规则，看看它是否有效。然后检查我之前制定的所有规则。然后添加一个新的并重复。这就是 TTD 派上用场的地方。我刚刚创建了测试来检查我所有的格式规则。然后我连 app 都没运行过一次。创建规则，运行测试，重复。<strong class="jm io">你可以编写测试来检查你的逻辑，而不用浪费时间在一个真正的应用程序中安装、运行和导航。</strong></li></ul><p id="cba5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这清楚地解释了你可以通过简单地使用测试立即节省大量时间。别忘了未来的利润。这听起来很棒，但是当你的架构很差的时候，编写测试并不容易。幸运的是，有很多方法，但人们必须理解他为什么使用其中的一种。</p></div><div class="ab cl kq kr hr ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="ig ih ii ij ik"><h2 id="137a" class="kx ky in bd kz la lb dn lc ld le dp lf jv lg lh li jz lj lk ll kd lm ln lo lp bi translated">从逻辑中分离观点- 不要试图煮沸海洋</h2><p id="ed45" class="pw-post-body-paragraph jk jl in jm b jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd lu kf kg kh ig bi translated">遵循架构模式对我来说更自然，因为我想开发专业的代码。然而，我记得我对所有这些样板代码、接口和回调犹豫不决，只是为了在视图和逻辑之间建立一堵想象的墙。</p><ul class=""><li id="b2a3" class="lv lw in jm b jn jo jr js jv lx jz ly kd lz kh ma mb mc md bi translated">当你最终理解了测试的力量，将它融入到你的工作流程中会很棒。但是模仿用户输入、上下文和其他视图相关的类对于单元测试来说几乎是不可能的。那么，是否为视图相关的类添加测试非常困难，而为其他类添加测试很容易，<strong class="jm io">为什么我们不尽可能地减少测试呢</strong>？就这么简单。</li><li id="cc4f" class="lv lw in jm b jn me jr mf jv mg jz mh kd mi kh ma mb mc md bi translated">我已经创建了一个在多个地方使用的组件。自豪的是我只写了一次，用了几次就完成了工作。不幸的是，后来我不得不添加额外的标签和改变风格，但只是在一个页面上。过了一段时间，我的组件有了一个业务逻辑，但是被负责管理不同视图情况的代码所膨胀。但是我一直这样做，因为添加视图行比巨大的重构更容易。混合观点和逻辑总是会导致同样的问题，因为它们代表了两个截然不同的世界。</li></ul><p id="404a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以把这个想法更进一步，我们可以把每一个类分开，只处理一个责任。这直接把我们带到了下一点。</p></div><div class="ab cl kq kr hr ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="ig ih ii ij ik"><h2 id="0652" class="kx ky in bd kz la lb dn lc ld le dp lf jv lg lh li jz lj lk ll kd lm ln lo lp bi translated"><strong class="ak">固若金汤——意想不到的分而治之中尉</strong></h2><p id="c791" class="pw-post-body-paragraph jk jl in jm b jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd lu kf kg kh ig bi translated">这是编程界的一个热门词汇。但是和以前的案例一样，本能地遵循这些规则并不容易。就像其他人一样，一个特殊的情况改变了我的整个看法。</p><p id="80d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我不得不完全从头开始创建下一个功能。许多不同的状态、多个数据源和不同的入口点。甚至很难决定从哪里开始。但后来我意识到，你不必一开始就知道所有的事情。</p><p id="454b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你知道把问题分成小问题的策略吗？我发现通过跟随固体你可以毫不费力地做到这一点。我首先创建一个简单的类，只负责一件事。我注入其他组件，而不担心如何提供它们。<strong class="jm io">一次做一件事</strong>。</p><p id="8ff5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不要被你未来的问题分心。突然，从人为的，不舒服的规则，他们成为陡峭的楼梯上有益的栏杆。我可以抓住它来克服一个不可能的障碍。</p><p id="93f2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我不需要知道一切，我也不害怕。组件很容易重构，甚至，我可以完全替换它们。更重要的是，可以注入临时类，继续运行并在以后返回。</p></div><div class="ab cl kq kr hr ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="ig ih ii ij ik"><h2 id="4ef1" class="kx ky in bd kz la lb dn lc ld le dp lf jv lg lh li jz lj lk ll kd lm ln lo lp bi translated"><strong class="ak">复合超越继承——如何让</strong>事情<strong class="ak">变得复杂</strong></h2><p id="55ab" class="pw-post-body-paragraph jk jl in jm b jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd lu kf kg kh ig bi translated">当我第一次接触面向对象编程时，我着迷于继承，并将世界理解为或多或少相互关联的抽象类。我获得了一种新的超能力，就像神话中的第三只眼睛可以看到遗产。然后他们告诉我应该用不同的东西？</p><p id="b62a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我参与了这个项目，它几乎完全建立在非常复杂的继承之上。嗯，有时候在最抽象的层次上添加一些空值检查，看看它是如何应用到其他孩子身上的，这是很酷的。在几个案例中，当我想更换一个单独的部件时，情况变得复杂了。因此，我没有只在必要的地方改变它，而是不得不为我的班级和所有孩子的后果而斗争。我不得不覆盖我的类并修复多个其他文件。不幸的是，我被某个建筑师 5 年前的愿景束缚住了。这是非常有限的，并造成了很多麻烦。</p></div><div class="ab cl kq kr hr ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="ig ih ii ij ik"><h2 id="b6b7" class="kx ky in bd kz la lb dn lc ld le dp lf jv lg lh li jz lj lk ll kd lm ln lo lp bi translated">结论</h2><p id="cb80" class="pw-post-body-paragraph jk jl in jm b jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd lu kf kg kh ig bi translated">对我们许多人来说，现实生活中的例子在学习过程中起着至关重要的作用。不幸的是，收集所有这些深刻的瞬间可能需要太长的时间。通过分享我们日常基础项目的经验，我们可以加快这一过程。因为我总是无法接触到这样的文章，所以我写了我的第一篇。但是还有很多要分享，我希望你能加入我。</p></div></div>    
</body>
</html>