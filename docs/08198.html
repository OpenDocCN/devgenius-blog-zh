<html>
<head>
<title>React router V6:</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React 路由器 V6:</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/react-router-v6-d95b6ac438a4?source=collection_archive---------2-----------------------#2022-05-25">https://blog.devgenius.io/react-router-v6-d95b6ac438a4?source=collection_archive---------2-----------------------#2022-05-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="16dc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">大家好，在这篇文章中，我们将讨论 react-router 和 react-router-dom v6。</p><h2 id="7094" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">一些基本组件:</h2><h2 id="75cd" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">1.浏览器路由器:</h2><p id="32ce" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">浏览器路由器使用<strong class="jm io"> HTML5 历史 API </strong>来保持 UI 与 URL 同步。要使用它，我们必须将整个应用程序包装在<strong class="jm io">浏览器路由器</strong>组件中。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/af37b7c0885eefb9a65f798df411c1dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fPVh1yNGJNrjXlj0QWo9eg.png"/></div></div></figure><p id="e1a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">BrowserRouter 为整个<code class="fe ls lt lu lv b">&lt;App&gt;</code>组件创建一个历史实例。该实例提供了对一些非常有用的 API 的访问，如<em class="lw"> history.location、history.push、history.replace、history.goBack 等。</em></p><h2 id="cce7" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">2.路线:</h2><p id="e6e7" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">在 v6 中，您可以将 Routes 组件视为 Switch 组件的替代品。将它命名为路线更有意义。使用 Route 创建的所有路径都将被 Routes 包装。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lx"><img src="../Images/3ac04e312501c6c0dbaf3819d481bef5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8tPIUB8y6jw7mpOCV_fXvA.png"/></div></div></figure><h2 id="5d56" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">3.路线:</h2><p id="ffbc" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">在 v6 中，我们可以像在 v5 中一样定义路由。只有一些语法上的变化，比如现在你使用<strong class="jm io"> element </strong> prop 而不是 component，现在你必须在 element prop 中传递 jsx 来使它工作，而不只是像我们之前那样传递组件。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi ly"><img src="../Images/2de97a90fe357b0cd9e734cfdca03193.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z-FmELR5vp9mfi3XQ7Y5Aw.png"/></div></div></figure><p id="c5b3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你使用 v5，你肯定会在上面的例子中找到<strong class="jm io">确切的</strong>关键字，但是我们不需要它，它将完美地开箱即用。<br/>在上面的例子中，我们定义了两条路线，即<em class="lw"> '/about' </em>和<em class="lw"> '/about/company' </em>，这非常好。但有趣的部分来了。在 v6 中，我们可以用一种非常容易理解和阅读的方式定义嵌套路径。我们可以在父路由和反应路由器之间包装嵌套路由，反应路由器将知道我们想要组合它们两者。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lz"><img src="../Images/396fed90a6399fd136c93e828f2f4d7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p9RaB6VcCN1pz8g2ePr8xw.png"/></div></div></figure><p id="b64a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">看，就这么简单。还有一点，在定义这些嵌套路由时，我们不需要在路由路径前加斜杠，否则路由器会抛出一个错误。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi ma"><img src="../Images/74c407b932fb76c0c3e8a029efbc6204.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HwuH0rEh5tVdq676G0ADxg.png"/></div></div></figure><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi mb"><img src="../Images/0a801bb7d4c8d4ee43e5e001831572ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*beiavjIxjBXR--lHjuVgfA.png"/></div></div></figure><h2 id="8cc3" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">4.出口:</h2><p id="d8b4" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">我们添加了嵌套路由，但是现在我们需要告诉 react-router 在哪里呈现嵌套组件。为此，<strong class="jm io">出口</strong>组件开始发挥作用。我们需要在父 Route 元素中使用这个组件。</p><p id="3f25" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们的示例中，<em class="lw">' company '</em>route<em class="lw"/>是<em class="lw"> '/about' </em> route 的子元素，并且正在为<em class="lw"> '/about' </em> route 呈现&lt; About/ &gt;元素。所以我们只需要在我们的 About 组件中添加 outlet 组件就可以让它工作了。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi mc"><img src="../Images/bbb34a69ef996cab53e645f0fd75152c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZcV8lr8Bfms8wGFHrMpYyQ.png"/></div></div></figure><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi md"><img src="../Images/71ed0f54ecae936e7257344daf9dc77e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IF6oxjz4co7tlCc2wSGNdw.png"/></div></div></figure><p id="741c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要将“about/company”显示为一个单独的页面，我们可以像处理其他路线一样，只声明路线而不嵌套。</p><p id="9df8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以定义多个嵌套路线，如下所示:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi me"><img src="../Images/93a9d793746232b03bdc461a163e2239.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7y8dPZKPywQxFOha12PcJA.png"/></div></div></figure><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi md"><img src="../Images/509447252d961f1b15e0675a4ec17548.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7GTbUeDi5sYeWYVOU2xgaw.png"/></div></div></figure><h2 id="fb21" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">5.链接:</h2><p id="7bd4" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">现在，在完成所有这些设置之后，我们需要一些用户可以用来在组件之间导航的东西，比如导航条。但现在问题来了，我们如何在 react app 中添加链接。如果我们使用像普通 HTML5 这样的超链接，那么每次我们点击那个链接，我们的整个页面都会刷新，这不是我们在 react 应用中想要的。这里我们可以使用 react-router-dom 提供的链接组件。版本 6 中的链接组件与版本 5 中的相同。我们可以使用<em class="lw">到</em>属性来定义链接将用户重定向到的路径。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi mf"><img src="../Images/ffae031d4a4988927bb9d98c0831cb87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S31OYCMPP2QebuU0mh1sCw.png"/></div></div></figure><h2 id="7d85" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">6.导航链接:</h2><p id="afa1" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">现在，NavLink 组件在 v6 和 v5 中的用法有点不同。在 v5 中，我们使用<em class="lw">‘active class name’</em>来定义一个活动链接的类，但是现在在 v6 中，我们可以使用由 style prop 中的回调函数提供的 isActive 变量。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi mg"><img src="../Images/549e2eb62fe01a52788cc40cc34306a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-GKivYQ-wCXAoAWcr5P_ng.png"/></div></div></figure><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi md"><img src="../Images/117a9d909356fd30f0322cb2cf46a8d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I3stNG6IrVF33_2NWo_DYA.png"/></div></div></figure><p id="a52b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是在 v6 中，如果转到任何既是父链接又是子链接的嵌套链接'<em class="lw"> navLinks </em>'被显示为活动的，我们仍然会面临这个问题。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi ma"><img src="../Images/95815e7cb5246161896a9efe00ac2977.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M8_VBzGbC-fcg1UCc8lGWw.png"/></div></div></figure><p id="286c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 v5 中，我们在'<em class="lw"> navLink </em>'组件中使用了 exact 关键字来解决这个问题，但在 v6 中，我们只需在父 navLink 中使用<em class="lw"> 'end' </em>关键字。它将确保该组件在其后代路径匹配时不会匹配为“活动的”。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi mh"><img src="../Images/26b2e7f4d75352e7cf1521f36f27cd7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wKaGj2jQDK24mLHSb0SANg.png"/></div></div></figure><h2 id="ae10" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">奖金:</h2><p id="4d27" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">这篇文章是写给所有还在阅读这篇文章的人的😅。</p><p id="fcbd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">v6 中引入了许多钩子，如 useNavigate、useLocation、useParams 等。</p><p id="68d4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我将解释<strong class="jm io">使用参数</strong>。如果我们在应用程序中使用动态路由，这个钩子就派上用场了，动态路由可以这样定义:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi mi"><img src="../Images/4b25464f240323a0d76be57809f11c7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fxFuGKsPbEpb3W_tfzfniQ.png"/></div></div></figure><p id="ea40" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在在 IdComp 组件中，我们可以使用<strong class="jm io"> useParams </strong>钩子从 URL 中提取 id。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi mj"><img src="../Images/f7de8a80abf10db3f2d82fa11b46d2dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s9oQLLiuvz8-UrGBsJa9cA.png"/></div></div></figure><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi md"><img src="../Images/cc90faf42dc899b9def43b9623111d55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9S9Q6s1KLAHo1UkGQP1ujg.png"/></div></div></figure><h1 id="8bb9" class="mk kj in bd kk ml mm mn kn mo mp mq kq mr ms mt kt mu mv mw kw mx my mz kz na bi translated">总结:</h1><p id="9eeb" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">这就是我们开始使用 react-router V6 所需要知道的全部内容。V6 中引入了更多的特性，你可以在他们的官方<a class="ae nb" href="https://reactrouterdotcom.fly.dev/docs/en/v6" rel="noopener ugc nofollow" target="_blank">文档</a>中查看。</p><p id="44d4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">谢谢你的时间😊….</p></div></div>    
</body>
</html>