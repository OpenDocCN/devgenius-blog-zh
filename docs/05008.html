<html>
<head>
<title>Swift Leetcode Series: Max Area of Island</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift Leetcode系列:岛屿最大面积</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/swift-leetcode-series-max-area-of-island-d3a5f1095547?source=collection_archive---------3-----------------------#2021-06-02">https://blog.devgenius.io/swift-leetcode-series-max-area-of-island-d3a5f1095547?source=collection_archive---------3-----------------------#2021-06-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="c2d5" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">Swift + DFS +递归✅ ✅ ✅</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/bb0066dd47a78a87c0d9da160564f070.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7jPEkfFaB7Eb1PyESOzCpQ.png"/></div></div></figure><div class="ko kp gp gr kq kr"><a href="https://theswiftnerd.com/max-area-of-island-leetcode/" rel="noopener  ugc nofollow" target="_blank"><div class="ks ab fo"><div class="kt ab ku cl cj kv"><h2 class="bd io gy z fp kw fr fs kx fu fw im bi translated">岛的最大面积(Leetcode 695)</h2><div class="ky l"><h3 class="bd b gy z fp kw fr fs kx fu fw dk translated">难度:链接:第一天:June LeetCode挑战给你一个m×n的二进制矩阵网格。一个岛是一组1…</h3></div><div class="kz l"><p class="bd b dl z fp kw fr fs kx fu fw dk translated">theswiftnerd.com</p></div></div><div class="la l"><div class="lb l lc ld le la lf km kr"/></div></div></a></div><p id="3849" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">你可以通过上面的链接在Swift Nerd博客上阅读完整的故事。</p><h1 id="1c3f" class="mc md in bd me mf mg mh mi mj mk ml mm jt mn ju mo jw mp jx mq jz mr ka ms mt bi translated">问题描述</h1><p id="7b3f" class="pw-post-body-paragraph lg lh in li b lj mu jo ll lm mv jr lo lp mw lr ls lt mx lv lw lx my lz ma mb ig bi translated">给你一个<code class="fe mz na nb nc b">m x n</code>二进制矩阵<code class="fe mz na nb nc b">grid</code>。岛屿是一组<code class="fe mz na nb nc b">1</code>(代表陆地)四向<strong class="li io">(水平或垂直)相连的岛屿。)你可以假设网格的四个边都被水包围着。</strong></p><p id="7779" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">岛的<strong class="li io">区域</strong>是岛中具有值<code class="fe mz na nb nc b">1</code>的单元的数量。</p><p id="7e82" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">返回<em class="nd">最大</em> <strong class="li io"> <em class="nd">面积</em> </strong> <em class="nd">中的一个岛屿</em> <code class="fe mz na nb nc b">grid</code>。如果没有岛，返回<code class="fe mz na nb nc b">0</code>。</p><p id="3ed9" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated"><strong class="li io">例1: </strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ne"><img src="../Images/abb4130d1b9c3f966eade8397d149c01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mPHWpiaZleAikuDq.jpg"/></div></div></figure><pre class="kd ke kf kg gt nf nc ng nh aw ni bi"><span id="0033" class="nj md in nc b gy nk nl l nm nn"><strong class="nc io">Input:</strong> grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]<br/><strong class="nc io">Output:</strong> 6<br/><strong class="nc io">Explanation:</strong> The answer is not 11, because the island must be connected 4-directionally.</span><span id="b5bd" class="nj md in nc b gy no nl l nm nn"><strong class="nc io">Input:</strong> grid = [[0,0,0,0,0,0,0,0]]<br/><strong class="nc io">Output:</strong> 0</span></pre><h1 id="1d0f" class="mc md in bd me mf mg mh mi mj mk ml mm jt mn ju mo jw mp jx mq jz mr ka ms mt bi translated">限制</h1><ul class=""><li id="04f5" class="np nq in li b lj mu lm mv lp nr lt ns lx nt mb nu nv nw nx bi translated"><code class="fe mz na nb nc b">m == grid.length</code></li><li id="d6c7" class="np nq in li b lj ny lm nz lp oa lt ob lx oc mb nu nv nw nx bi translated"><code class="fe mz na nb nc b">n == grid[i].length</code></li><li id="e6b6" class="np nq in li b lj ny lm nz lp oa lt ob lx oc mb nu nv nw nx bi translated"><code class="fe mz na nb nc b">1 &lt;= m, n &lt;= 50</code></li><li id="27cf" class="np nq in li b lj ny lm nz lp oa lt ob lx oc mb nu nv nw nx bi translated"><code class="fe mz na nb nc b">grid[i][j]</code>不是<code class="fe mz na nb nc b">0</code>就是<code class="fe mz na nb nc b">1</code>。</li></ul><h1 id="4b32" class="mc md in bd me mf mg mh mi mj mk ml mm jt mn ju mo jw mp jx mq jz mr ka ms mt bi translated">解决办法</h1><p id="9496" class="pw-post-body-paragraph lg lh in li b lj mu jo ll lm mv jr lo lp mw lr ls lt mx lv lw lx my lz ma mb ig bi translated">我们想找出网格中的最大面积。一个单元如果是<strong class="li io"> <em class="nd">地</em> </strong> ( <strong class="li io">网格【I】【j】= 1</strong>)就会贡献面积，否则就是<strong class="li io"> <em class="nd">水</em> </strong>。每当我们来到陆地上，我们可以探索所有4个方向来找到相连的细胞。总面积将是所有这种相连单元的总和。</p><h1 id="8390" class="mc md in bd me mf mg mh mi mj mk ml mm jt mn ju mo jw mp jx mq jz mr ka ms mt bi translated">深度优先搜索</h1><p id="ccba" class="pw-post-body-paragraph lg lh in li b lj mu jo ll lm mv jr lo lp mw lr ls lt mx lv lw lx my lz ma mb ig bi translated">如果我们想要最大化任何数量的现存量(在这种情况下是连续单元的数量)，这是遍历任何2D网格的最佳技术。我们可以使用嵌套循环处理输入网格，并在陆地上递归调用<strong class="li io"> dfs </strong>。<strong class="li io"> dfs </strong>过程将依次递归检查所有4个方向，并返回陆地单元的总数。</p><h1 id="04ee" class="mc md in bd me mf mg mh mi mj mk ml mm jt mn ju mo jw mp jx mq jz mr ka ms mt bi translated">诡计案件</h1><p id="dfb8" class="pw-post-body-paragraph lg lh in li b lj mu jo ll lm mv jr lo lp mw lr ls lt mx lv lw lx my lz ma mb ig bi translated">有无限循环的机会，因为我们盲目地遍历所有4个方向，我们会再次访问一些单元，这又会再次触发递归。举个例子，两个1连在一起。他们会不停地呼唤他们的邻居。为了处理这种情况，每当递归地探索4个方向之前，我们将在该单元设置输入网格= 0，这样它就不会被再次计数。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="od oe l"/></div></figure><h2 id="731a" class="nj md in bd me of og dn mi oh oi dp mm lp oj ok mo lt ol om mq lx on oo ms op bi translated"><strong class="ak">复杂性分析</strong></h2><p id="ccf9" class="pw-post-body-paragraph lg lh in li b lj mu jo ll lm mv jr lo lp mw lr ls lt mx lv lw lx my lz ma mb ig bi translated"><strong class="li io">时间</strong>=<em class="nd">O</em>(<em class="nd">R</em>∫<em class="nd">C</em>)，其中R是给定<code class="fe mz na nb nc b">grid</code>中的行数，C是列数。我们每个广场都参观一次。</p><p id="2343" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated"><strong class="li io">Space</strong>=<em class="nd">O(R∫C)</em>，我们递归时调用栈使用的空间。</p></div><div class="ab cl oq or hr os" role="separator"><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov"/></div><div class="ig ih ii ij ik"><p id="e4b7" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">感谢您的阅读。如果你喜欢这篇文章，并发现它很有用，请分享并像野火一样传播它！</p><p id="b7cd" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">你可以在<a class="ae ox" href="https://theswiftnerd.com/" rel="noopener ugc nofollow" target="_blank">swift网站</a>|<a class="ae ox" href="https://www.linkedin.com/in/varunrathi28/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae ox" href="https://github.com/varunrathi28" rel="noopener ugc nofollow" target="_blank">Github</a>上找到我</p></div></div>    
</body>
</html>