<html>
<head>
<title>All About Lambda Function in C++(From C++11 to C++20)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于C++中Lambda函数的所有内容(从C++11到C++20)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/all-about-lambda-function-in-c-e3addcc93fa7?source=collection_archive---------0-----------------------#2019-10-13">https://blog.devgenius.io/all-about-lambda-function-in-c-e3addcc93fa7?source=collection_archive---------0-----------------------#2019-10-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/9933bfe701635bec1bcbe58ff6f94c6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NcAw_DfVUMVmYtzlqsSzgA.png"/></div></div></figure><p id="dfbe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Lambda函数是<a class="ae kt" href="http://www.vishalchovatiya.com/21-new-features-of-modern-cpp-to-use-in-your-project/" rel="noopener ugc nofollow" target="_blank">现代C++ </a>在C++11中引入的一个相当直观的概念。在这里，我们不仅会看到C++中的Lambda函数的例子，还会看到它在内部是如何工作的。这篇文章的标题有点误导，因为Lambda并不总是被合成以精确地发挥其表达式的功能。但为了简单起见，我一直保持这种方式。所以从现在开始，我将交替使用Lambda函数&amp;表达式。</p><p id="2a29" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我还创建了一个Lambda表达式的思维导图，你可以在上面看到(如果你看不到，可以在新标签页打开)。</p><p id="2e98" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是我的<a class="ae kt" href="http://www.vishalchovatiya.com/learn-lambda-function-in-cpp-with-example/" rel="noopener ugc nofollow" target="_blank">博客</a>的交叉帖子。</p><h1 id="32a0" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">什么是Lambda函数？</h1><p id="0e3d" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">Lambda函数是一小段代码，它</p><ul class=""><li id="6630" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">不值得命名(未命名、匿名、一次性等。无论你怎么称呼它)，</li><li id="acd4" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">并且通常不被重复使用。</li></ul><p id="90a3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">换句话说，就是句法糖而已。Lambda函数语法定义为:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="f7f1" class="mu kv in mq b gy mv mw l mx my">[ capture list ] (parameters) -&gt; return-type  <br/>{   <br/>    method definition<br/>}</span></pre><ul class=""><li id="a48f" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">通常，Lambda函数的返回类型是由编译器自己评估的，我们不需要明确指定尾部返回类型，即<code class="fe mz na nb mq b">-&gt; return-type</code>。</li><li id="676f" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">但是在一些复杂的情况下，编译器无法推导出返回类型，我们需要指定。</li></ul><h1 id="b016" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">为什么我们应该使用Lambda函数？</h1><p id="515c" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">C++包括许多有用的通用函数，如<code class="fe mz na nb mq b">std::for_each</code>，非常方便。不幸的是，它们使用起来也很麻烦，尤其是当你想要应用的函子是特定函数所独有的时候。以下面的代码为例:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="8e0b" class="mu kv in mq b gy mv mw l mx my">struct print<br/>{<br/>    void operator()(int element)<br/>    {<br/>        cout &lt;&lt; element &lt;&lt; endl;<br/>    }<br/>};</span><span id="8607" class="mu kv in mq b gy nc mw l mx my">int main(void)<br/>{<br/>    std::vector&lt;int&gt; v = {1, 2, 3, 4, 5};<br/>    std::for_each(v.begin(), v.end(), print());<br/>    return 0;<br/>}</span></pre><ul class=""><li id="4700" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">如果你只在特定的地方使用一次<code class="fe mz na nb mq b">print</code>,那么仅仅为了做一些琐碎的一次性的事情而写一整个类似乎有些矫枉过正。</li><li id="9111" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">然而，对于这种情况，内联代码会更合适&amp;这可以通过如下Lambda函数来实现:</li></ul><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="da1f" class="mu kv in mq b gy mv mw l mx my">std::for_each(v.begin(), v.end(), [](int element) { cout &lt;&lt; element &lt;&lt; endl; });</span></pre><h1 id="cff0" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">Lambda函数内部是如何工作的？</h1><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="484f" class="mu kv in mq b gy mv mw l mx my">[&amp;i] ( ) { std::cout &lt;&lt; i; }</span><span id="0565" class="mu kv in mq b gy nc mw l mx my">// is equivalent to</span><span id="dc53" class="mu kv in mq b gy nc mw l mx my">struct anonymous<br/>{<br/>    int &amp;m_i;<br/>    anonymous(int &amp;i) : m_i(i) {}<br/>    inline auto operator()() const<br/>    {<br/>        std::cout &lt;&lt; m_i;<br/>    }<br/>};</span></pre><ul class=""><li id="5dfa" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">编译器为每个Lambda函数生成唯一的闭包。秘密泄露了。</li><li id="e5d4" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">捕获列表将成为闭包中的构造函数参数。如果您将参数捕获为值，那么在闭包内会创建相应的类型数据成员。</li><li id="19cf" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">你甚至可以在Lambda函数参数中声明变量/对象，这将成为<code class="fe mz na nb mq b">operator()</code>的参数。</li></ul><h1 id="7533" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">使用Lambda函数的好处</h1><ul class=""><li id="dc4a" class="lx ly in jx b jy ls kc lt kg nd kk ne ko nf ks mc md me mf bi translated">零成本抽象。是啊！你没看错。它不会影响你的性能&amp;和正常功能一样快。</li><li id="457e" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">代码变得紧凑、结构化和有表现力。</li></ul><h1 id="2767" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">C++中的Lambda函数及实例</h1><h2 id="4c3e" class="mu kv in bd kw ng nh dn la ni nj dp le kg nk nl li kk nm nn lm ko no np lq nq bi translated">捕捉对象</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="c294" class="mu kv in mq b gy mv mw l mx my">int main()<br/>{<br/>    int x = 100, y = 200;</span><span id="1460" class="mu kv in mq b gy nc mw l mx my">    auto print = [&amp;]() { // Capturing object by reference<br/>        std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; " : " &lt;&lt; x &lt;&lt; " , " &lt;&lt; y &lt;&lt; std::endl;<br/>    };</span><span id="5a43" class="mu kv in mq b gy nc mw l mx my">    print();<br/>    return 0;<br/>}</span></pre><p id="9375" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">输出:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="b062" class="mu kv in mq b gy mv mw l mx my">main()::&lt;lambda()&gt; : 100 , 200</span></pre><ul class=""><li id="bdd7" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">如上所述，我们在捕获列表中提到了<code class="fe mz na nb mq b">&amp;</code>，它捕获变量<code class="fe mz na nb mq b">x</code> &amp; <code class="fe mz na nb mq b">y</code>作为参考。类似地，<code class="fe mz na nb mq b">=</code>表示通过值捕获，这将在闭包内创建相同类型的数据成员&amp;复制赋值发生。</li><li id="25a7" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">下表显示了同一的不同使用情形:</li></ul><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nr"><img src="../Images/db2f1f373436226ed9afd33cbbe70f5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vynsu59V6QIlPO0C4LBkHQ.png"/></div></div></figure><h2 id="535a" class="mu kv in bd kw ng nh dn la ni nj dp le kg nk nl li kk nm nn lm ko no np lq nq bi translated">λ作为参数</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="284a" class="mu kv in mq b gy mv mw l mx my">template &lt;typename Functor&gt;<br/>void f(Functor functor)<br/>{<br/>    std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl;<br/>}</span><span id="b27f" class="mu kv in mq b gy nc mw l mx my">/* Or alternatively you can use this<br/>void f(std::function&lt;int(int)&gt; functor)<br/>{<br/>    std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl;<br/>} <br/>*/</span><span id="1155" class="mu kv in mq b gy nc mw l mx my">int g() { static int i = 0; return i++; }</span><span id="3dc6" class="mu kv in mq b gy nc mw l mx my">int main()<br/>{<br/>    auto lambda_func = [i = 0]() mutable { return i++; };<br/>    f(lambda_func); // Pass lambda<br/>    f(g);           // Pass function<br/>}</span></pre><p id="deca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">输出:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="eac9" class="mu kv in mq b gy mv mw l mx my">Function Type : void f(Functor) [with Functor = main()::&lt;lambda(int)&gt;]<br/>Function Type : void f(Functor) [with Functor = int (*)(int)]</span></pre><ul class=""><li id="4754" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">你也可以将Lambda函数作为一个参数传递给其他函数，就像上面我编写的普通函数一样。</li><li id="2fc2" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">如果你注意到了，这里我在捕获列表中声明了变量<code class="fe mz na nb mq b">i</code>，它将成为数据成员。而且每次调用<code class="fe mz na nb mq b">lambda_func</code>，都会返回&amp;递增。</li></ul><h2 id="c17e" class="mu kv in bd kw ng nh dn la ni nj dp le kg nk nl li kk nm nn lm ko no np lq nq bi translated">捕捉<code class="fe mz na nb mq b">this</code>指针</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="ec1d" class="mu kv in mq b gy mv mw l mx my">class Example<br/>{<br/>public:<br/>    Example() : m_var(10) {}</span><span id="9683" class="mu kv in mq b gy nc mw l mx my">    void func()<br/>    {<br/>        [=]() { std::cout &lt;&lt; m_var &lt;&lt; std::endl; }();<br/>    }</span><span id="0d9f" class="mu kv in mq b gy nc mw l mx my">private:<br/>    int m_var;<br/>};</span><span id="493c" class="mu kv in mq b gy nc mw l mx my">int main()<br/>{<br/>    Example e;<br/>    e.func();<br/>}</span></pre><ul class=""><li id="fb49" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated"><code class="fe mz na nb mq b"><em class="ns">this</em></code>也可以使用<code class="fe mz na nb mq b">[this]</code>、<code class="fe mz na nb mq b">[=]</code>或<code class="fe mz na nb mq b">[&amp;]</code>捕捉指针。在任何一种情况下，类数据成员(包括<em class="ns">私有</em>)都可以像在普通方法中一样被访问。</li><li id="8b83" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">如果你看到Lambda表达式行，我在Lambda函数声明的末尾使用了额外的<code class="fe mz na nb mq b">()</code>,用于在其后调用它。</li></ul><h1 id="8b2c" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">不同类型的Lambda表达式</h1><h2 id="8974" class="mu kv in bd kw ng nh dn la ni nj dp le kg nk nl li kk nm nn lm ko no np lq nq bi translated">通用Lambdas</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="a7aa" class="mu kv in mq b gy mv mw l mx my">const auto l = [](auto a, auto b, auto c) {};</span><span id="9245" class="mu kv in mq b gy nc mw l mx my">// is equivalent to</span><span id="d1fd" class="mu kv in mq b gy nc mw l mx my">struct anonymous<br/>{<br/>    template &lt;class T0, class T1, class T2&gt;<br/>    constexpr auto operator()(T0 a, T1 b, T2 c) const<br/>    {<br/>    }<br/>};</span></pre><ul class=""><li id="2e74" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">C++14中引入的通用Lambda可以用<code class="fe mz na nb mq b">auto</code>说明符捕获参数。</li><li id="8c21" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">从C++14开始，Lambda也可以在编译时计算。如果你不知道<code class="fe mz na nb mq b">constexpr</code>关键字，那么我已经为这里的写了一篇单独的文章。</li></ul><h2 id="a774" class="mu kv in bd kw ng nh dn la ni nj dp le kg nk nl li kk nm nn lm ko no np lq nq bi translated">可变通用λ</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="7c83" class="mu kv in mq b gy mv mw l mx my">void print() {}</span><span id="78c8" class="mu kv in mq b gy nc mw l mx my">template &lt;typename First, typename... Rest&gt;<br/>void print(const First &amp;first, Rest &amp;&amp;... args)<br/>{<br/>    std::cout &lt;&lt; first &lt;&lt; std::endl;<br/>    print(args...);<br/>}</span><span id="28ee" class="mu kv in mq b gy nc mw l mx my">int main()<br/>{<br/>    auto variadic_generic_lambda = [](auto... param) {<br/>        print(param...);<br/>    };<br/>    variadic_generic_lambda(1, "lol", 1.1);<br/>}</span></pre><ul class=""><li id="aaed" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">具有可变参数包的Lambda将在许多场景中有用，如调试、不同数据输入的重复操作等。</li></ul><h2 id="b7e4" class="mu kv in bd kw ng nh dn la ni nj dp le kg nk nl li kk nm nn lm ko no np lq nq bi translated"><code class="fe mz na nb mq b">mutable</code>λ</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="675e" class="mu kv in mq b gy mv mw l mx my">[]() mutable {}</span><span id="877b" class="mu kv in mq b gy nc mw l mx my">// is equivalent to</span><span id="c669" class="mu kv in mq b gy nc mw l mx my">struct anonymous<br/>{<br/>    auto operator()()<br/>    {<br/>    }<br/>};</span></pre><ul class=""><li id="f92c" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">允许捕获的对象在Lambda函数中变异。我们已经在上面看到了一个这样的例子。我希望你注意到了。如果您还没有，请查看“Lambda作为参数”中的示例。</li></ul><h2 id="c09e" class="mu kv in bd kw ng nh dn la ni nj dp le kg nk nl li kk nm nn lm ko no np lq nq bi translated">Lambda作为函数指针</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="2b5f" class="mu kv in mq b gy mv mw l mx my">#include &lt;iostream&gt;<br/>#include &lt;type_traits&gt;</span><span id="6707" class="mu kv in mq b gy nc mw l mx my">int main()<br/>{<br/>    auto funcPtr = +[] {};<br/>    static_assert(std::is_same&lt;decltype(funcPtr), void (*)()&gt;::value);<br/>}</span></pre><ul class=""><li id="2f09" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">你可以通过在lambda前面添加<code class="fe mz na nb mq b">+</code>来强制编译器生成lambda作为函数指针，而不是闭包。</li></ul><h2 id="4140" class="mu kv in bd kw ng nh dn la ni nj dp le kg nk nl li kk nm nn lm ko no np lq nq bi translated">高阶返回Lambda函数</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="2997" class="mu kv in mq b gy mv mw l mx my">const auto less_than = [](auto x) {<br/>    return [x](auto y) {<br/>        return y &lt; x;<br/>    };<br/>};</span><span id="a45f" class="mu kv in mq b gy nc mw l mx my">int main(void)<br/>{<br/>    auto less_than_five = less_than(5);<br/>    std::cout &lt;&lt; less_than_five(3) &lt;&lt; std::endl;<br/>    std::cout &lt;&lt; less_than_five(10) &lt;&lt; std::endl;<br/>    return 0;<br/>}</span></pre><ul class=""><li id="838b" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">再进一步，Lambda函数也可以返回另一个Lambda函数。这将为代码的定制、代码表达性和紧凑性(顺便说一句，没有这样的词)打开无限可能的大门。</li></ul><h1 id="58ac" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">constexpr Lambda表达式</h1><p id="9d7d" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">从C++17开始，lambda表达式可以声明为<a class="ae kt" href="http://www.vishalchovatiya.com/when-to-use-const-vs-constexpr-in-cpp/" rel="noopener ugc nofollow" target="_blank"> constexpr </a>。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="b7fa" class="mu kv in mq b gy mv mw l mx my">constexpr auto sum = [](const auto &amp;a, const auto &amp;b) { return a + b; };<br/>/*<br/>    is equivalent to<br/><br/>    constexpr struct anonymous<br/>    {<br/>        template &lt;class T1, class T2&gt;<br/>        constexpr auto operator()(T1 a, T2 b) const<br/>        {<br/>            return a + b;<br/>        }<br/>    };<br/>*/<br/>static_assert(sum(10, 10) == 20);</span></pre><ul class=""><li id="fdbe" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">即使不指定<code class="fe mz na nb mq b">constexpr</code>，如果恰好满足所有<a class="ae kt" href="https://en.cppreference.com/w/cpp/language/constexpr" rel="noopener ugc nofollow" target="_blank"> constexpr函数要求</a>，函数调用操作符无论如何都会是<code class="fe mz na nb mq b">constexpr</code>。</li></ul><h1 id="087c" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">模板Lambda表达式</h1><ul class=""><li id="e111" class="lx ly in jx b jy ls kc lt kg nd kk ne ko nf ks mc md me mf bi translated">正如我们在上面的通用lambda函数中看到的，我们可以将参数声明为<code class="fe mz na nb mq b">auto</code>。然后由编译器&amp;进行模板化，推导出合适的模板类型。但是没有办法改变这个模板参数并使用真正的模板参数。例如:</li></ul><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="3f56" class="mu kv in mq b gy mv mw l mx my">template &lt;typename T&gt;<br/>void f(std::vector&lt;T&gt;&amp;    vec){<br/>    //. . .<br/>}</span></pre><ul class=""><li id="ff7e" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">你如何为上面的函数写lambda，这个函数采用<code class="fe mz na nb mq b">T</code>类型的<code class="fe mz na nb mq b">std::vector</code>？在C++17之前，这是一个限制，但在C++20中，这是可能的，如下所示:</li></ul><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="cb01" class="mu kv in mq b gy mv mw l mx my">auto f = []&lt;typename T&gt;(std::vector&lt;T&gt;&amp;  vec){<br/>    // . . .<br/>};<br/><br/>std::vector&lt;int&gt; v;<br/>f(v);</span></pre><ul class=""><li id="da28" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">还有其他小的变化，你可以在这里阅读<a class="ae kt" href="https://en.cppreference.com/w/cpp/language/lambda" rel="noopener ugc nofollow" target="_blank"/>。</li></ul><h1 id="a0ed" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结束语</h1><p id="849f" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">我希望你喜欢这篇文章。我试图用几个简单的小例子来涵盖Lambda的大部分复杂性。考虑到代码的可表达性和易维护性，你应该在你想到的任何地方使用Lambda，就像你可以在智能指针的自定义删除器中使用它一样&amp;与大多数STL算法一起使用。</p></div></div>    
</body>
</html>