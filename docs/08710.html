<html>
<head>
<title>Assembly by example: Compute string hash. Part 3: CLI args and external functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">按示例汇编:计算字符串哈希。第 3 部分:CLI 参数和外部函数</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/assembly-by-example-compute-string-hash-part-3-cli-args-and-external-functions-c3b533e99cdd?source=collection_archive---------20-----------------------#2022-07-04">https://blog.devgenius.io/assembly-by-example-compute-string-hash-part-3-cli-args-and-external-functions-c3b533e99cdd?source=collection_archive---------20-----------------------#2022-07-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="7008" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是“通过示例组装:计算字符串散列”系列的最后一部分，所以我建议您阅读<a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/assembly-by-example-compute-string-hash-part-1-functions-a575240cbc5b">第 1 部分</a>和<a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/assembly-by-example-compute-string-hash-part-2-loops-ba39de0ff6d6">第 2 部分</a>，以防您没有阅读过。</p><p id="1054" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，我们将看到如何使用 CLI 参数和外部函数，以及这如何帮助我们最终编写程序来计算字符串哈希。所以，继续读下去。</p></div><div class="ab cl kj kk hr kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ig ih ii ij ik"><h1 id="1d09" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">CLI 参数</h1><p id="fd9e" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">读取 CLI 参数非常类似于读取函数参数，因为内核会自动将它们存储在堆栈内存中。让我们检查一个程序的堆栈内存来更好地理解这一点。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lt"><img src="../Images/4d1d784c28d8007d7441300fd97499e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HZEYPHcPy7h3vj479dQtaQ.png"/></div></div></figure><p id="4e9d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如您所见，前 4 个字节对应于收到的参数数量。在 C 语言中，这通常存储在一个名为<code class="fe mf mg mh mi b">argc</code>(参数计数)的变量中，从现在开始，我将使用这个名称来表示接收到的参数的数量。</p><p id="a28a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">与前 4 个字节相邻的是指向参数的<code class="fe mf mg mh mi b">argc</code>指针，以可执行文件的名称或路径开始。在 C 语言中，这些通常存储在一个名为<code class="fe mf mg mh mi b">argv</code>(参数值)的变量中。</p><p id="3ffe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">很好。我觉得这里没什么新鲜的。</p><p id="8006" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了得到一些实践和增强理解，下面你会发现一个非常基础的 GNU <a class="ae ki" href="https://www.gnu.org/software/coreutils/manual/html_node/echo-invocation.html" rel="noopener ugc nofollow" target="_blank"> echo </a>程序版本。它利用了我们到目前为止所看到的东西，所以我希望你在理解它时没有任何困难。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="ec95" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以下是一些有助于理解代码的有用注释:</p><ul class=""><li id="1663" class="ml mm in jm b jn jo jr js jv mn jz mo kd mp kh mq mr ms mt bi translated">仅当<code class="fe mf mg mh mi b">argc &gt; 2</code>时，代码首先将由空格分隔的<code class="fe mf mg mh mi b">argc — 1</code>参数写入 stdout(这是在<code class="fe mf mg mh mi b">loop</code>标签内完成的)，然后仅当<code class="fe mf mg mh mi b">argc &gt; 1</code>时，将最后一个参数后跟一个换行符写入 stdout(这是在<code class="fe mf mg mh mi b">end</code>标签后完成的)。</li><li id="60ac" class="ml mm in jm b jn mu jr mv jv mw jz mx kd my kh mq mr ms mt bi translated">该代码大量使用了 syscall 代码为 4 的<a class="ae ki" href="https://man7.org/linux/man-pages/man2/write.2.html" rel="noopener ugc nofollow" target="_blank"> write </a> syscall。</li><li id="0d0b" class="ml mm in jm b jn mu jr mv jv mw jz mx kd my kh mq mr ms mt bi translated">有时在调用一个函数来恢复一个状态之前，可能会使用两次<code class="fe mf mg mh mi b">PUSH</code>(第 34 和 35 行)。<code class="fe mf mg mh mi b"><a class="ae ki" href="https://en.m.wikibooks.org/wiki/X86_Assembly/Other_Instructions" rel="noopener ugc nofollow" target="_blank">PUSHAD</a></code>和<code class="fe mf mg mh mi b"><a class="ae ki" href="https://en.m.wikibooks.org/wiki/X86_Assembly/Other_Instructions" rel="noopener ugc nofollow" target="_blank">POPAD</a></code>通常用于保存和恢复寄存器值。</li><li id="77c7" class="ml mm in jm b jn mu jr mv jv mw jz mx kd my kh mq mr ms mt bi translated">为了访问第 I 个参数，我们使用了<code class="fe mf mg mh mi b">[ebp + 4 + eax]</code> ( <code class="fe mf mg mh mi b">eax</code>可以替换为其他数据注册表)，其中<code class="fe mf mg mh mi b">eax = 4 * i</code>是因为每个 arg 地址占用 4 个字节。需要偏移量 4，因为从<code class="fe mf mg mh mi b">ebp</code>开始的前 4 个字节对应于<code class="fe mf mg mh mi b">argc</code>，因此自变量列表从<code class="fe mf mg mh mi b">[ebp + 4]</code>开始。</li></ul><p id="f495" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果有帮助的话，下面是等价的 C 代码:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mj mk l"/></div></figure></div><div class="ab cl kj kk hr kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ig ih ii ij ik"><h1 id="b823" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">外部功能</h1><p id="26ca" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">在之前的文章中，我们提到如果我们可以使用 glibc 或其他 C 库的 strlen 这样的帮助函数，事情会变得更简单。我们现在来看看如何去做。</p><h2 id="e255" class="mz kr in bd ks na nb dn kw nc nd dp la jv ne nf le jz ng nh li kd ni nj lm nk bi translated">使用 libc 的 printf</h2><p id="92d2" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">为了使用外部函数，我们必须首先声明它是外部的，否则编译器会显示类似<code class="fe mf mg mh mi b">symbol 'printf' is not defined</code>的错误。这非常类似于在 C 源文件中包含某些头文件(例如<code class="fe mf mg mh mi b">stdio.h</code>)来访问其他目标代码文件中的函数。</p><p id="e64d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看看如何使用<code class="fe mf mg mh mi b">printf</code>函数在汇编中打印“Hello world”。代码如下:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="bd4d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">稍后我会解释为什么需要第 11 行(<code class="fe mf mg mh mi b">add esp, 4</code>)。现在让我们回顾一下 C 源文件的“编译”过程。它由四个基本步骤组成:预处理、编译、汇编和链接。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/450fd5eea97634b22ec416438429d753.png" data-original-src="https://miro.medium.com/v2/resize:fit:362/format:webp/1*OABOpblVTC1wWD-EDXqkxw.png"/></div></figure><p id="86ce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在链接步骤中，其地址在编译时未知的符号引用(例如<code class="fe mf mg mh mi b">printf</code>)被正确的替换。</p><p id="36a2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因为我们的源代码是一个汇编文件，所以我们已经在第三步了，我们在<a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/assembly-by-example-compute-string-hash-part-1-functions-a575240cbc5b">第 1 部分</a>中看到<code class="fe mf mg mh mi b">nasm -f elf32 source.asm</code>会将源代码编译成目标代码，而<code class="fe mf mg mh mi b">ld -m elf_i386 functions.o -o functions</code>会进行链接。</p><p id="4296" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如 may 猜测的那样，现在我们需要在链接阶段做一些额外的事情，以便访问<code class="fe mf mg mh mi b">printf</code>外部函数。如果我们使用<code class="fe mf mg mh mi b">ld</code>来进行链接，该命令将如下所示:</p><pre class="lu lv lw lx gt nm mi nn no aw np bi"><span id="b471" class="mz kr in mi b gy nq nr l ns nt">ld -m elf_i386 printf.o -dynamic-linker /lib/ld-linux.so.2 /usr/lib/crti.o -o printf -lc</span></pre><p id="9652" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">其中:</p><ul class=""><li id="c3ce" class="ml mm in jm b jn jo jr js jv mn jz mo kd mp kh mq mr ms mt bi translated"><code class="fe mf mg mh mi b">-lc</code>链接通常存储在<a class="ae ki" href="https://www.man7.org/linux/man-pages/man7/libc.7.html" rel="noopener ugc nofollow" target="_blank"> /lib/libc.so.6 </a>中的实际 libc</li><li id="1f5b" class="ml mm in jm b jn mu jr mv jv mw jz mx kd my kh mq mr ms mt bi translated"><code class="fe mf mg mh mi b">-dynamic-linker /lib/ld-linux.so.2 /usr/lib/crti.o</code>链接<a class="ae ki" href="https://www.programmerall.com/article/4550137629/" rel="noopener ugc nofollow" target="_blank"> ld-linux.so.2 </a>(用于搜索和加载库)和<a class="ae ki" href="https://blogs.oracle.com/solaris/post/new-crt-objects-or-what-are-crt-objects" rel="noopener ugc nofollow" target="_blank"> crti.o </a>(用于启动和运行程序)。详细解释为什么需要这些目标文件是一个高级话题，超出了本文的范围。</li></ul><p id="e6d3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你不想处理这些“罕见的”(高级的)目标文件，用 gcc 链接可能更容易:</p><pre class="lu lv lw lx gt nm mi nn no aw np bi"><span id="1e01" class="mz kr in mi b gy nq nr l ns nt">gcc -m32 -nostartfiles printf.o -o printf -lc</span></pre><p id="83b8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">其中:</p><ul class=""><li id="dbed" class="ml mm in jm b jn jo jr js jv mn jz mo kd mp kh mq mr ms mt bi translated"><code class="fe mf mg mh mi b"><a class="ae ki" href="https://gcc.gnu.org/onlinedocs/gcc/Link-Options.html" rel="noopener ugc nofollow" target="_blank">-lc</a></code>链接通常存储在<a class="ae ki" href="https://www.man7.org/linux/man-pages/man7/libc.7.html" rel="noopener ugc nofollow" target="_blank"> /lib/libc.so.6 </a>中的实际 libc</li><li id="4989" class="ml mm in jm b jn mu jr mv jv mw jz mx kd my kh mq mr ms mt bi translated"><code class="fe mf mg mh mi b">-m32</code>安排堆栈帧、可写数据和常量全部 32 位对齐。</li><li id="a0cb" class="ml mm in jm b jn mu jr mv jv mw jz mx kd my kh mq mr ms mt bi translated"><code class="fe mf mg mh mi b">-nostartfiles</code>告诉编译器不要链接包含<code class="fe mf mg mh mi b">_start</code>符号的<a class="ae ki" href="https://en.wikipedia.org/wiki/Crt0" rel="noopener ugc nofollow" target="_blank"> crt1.o </a>，它被用作 C 程序的入口点。在我们的例子中，如果包含了它，我们会有一个碰撞，因为我们已经定义了它。</li></ul><p id="c5e3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们现在用<code class="fe mf mg mh mi b">nasm -f elf32 -g printf.asm &amp;&amp; gcc -m32 -nostartfiles printf.o -o printf -lc &amp;&amp; ./printf</code>编译、链接和运行程序，我们应该看到“Hello world”被写到 stdout。</p><p id="c2a2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不错！现在让我解释一下为什么需要第 11 行(<code class="fe mf mg mh mi b">add esp, 4</code>):这仅仅是因为<code class="fe mf mg mh mi b">printf</code>和其他函数不从堆栈中弹出接收到的参数，也就是说，不使用指令<code class="fe mf mg mh mi b">ret n</code>，其中<code class="fe mf mg mh mi b">n</code>是函数参数占用的总字节数。通过执行下面的代码并检查堆栈内存，您可以看到这一点。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="25ff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">堆栈存储器的检查:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi nu"><img src="../Images/850a174151ad4c5562f598e41bd9d1c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LNw3nVzW7msaISQuyAhXvw.png"/></div></div></figure><p id="6b30" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如您所看到的，在第一次和第二次调用之后，被推入堆栈的参数仍然存在，然而由于<code class="fe mf mg mh mi b">ret 4</code>(第 30 行)，它在第三次调用之后被自动移除</p><p id="626c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，你可能已经注意到，<strong class="jm io">不从堆栈</strong>中弹出可能是危险的，而<strong class="jm io">可能导致堆栈溢出</strong>。试试下面的例子。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mj mk l"/></div></figure><h2 id="dab6" class="mz kr in bd ks na nb dn kw nc nd dp la jv ne nf le jz ng nh li kd ni nj lm nk bi translated">使用 libc 函数重写 echo 示例程序</h2><p id="02af" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">根据我们目前所学的知识，我们可以通过使用 libc 函数重写本文开头所示的 echo 示例程序。这很简单:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="9e18" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意，在这种情况下，在调用<code class="fe mf mg mh mi b">printf</code>之后使用<code class="fe mf mg mh mi b">add esp, 8</code>，因为我们正在推送两个大小为 DWORD 的参数，它们是字符串格式和 cli 参数。</p><h2 id="1e76" class="mz kr in bd ks na nb dn kw nc nd dp la jv ne nf le jz ng nh li kd ni nj lm nk bi translated">刷新缓冲区的需要</h2><p id="1a1e" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">让我们运行下面的 Java 代码来测试 GNU echo 程序，我们的 echo 程序使用 syscalls，我们的 echo 程序使用 libc 函数，我们的 echo 程序使用没有<code class="fe mf mg mh mi b">fflush</code>的 libc 函数(前面代码的第 60–62 行)。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">显示冲洗重要性的代码。忽略它可以被简化的事实</figcaption></figure><p id="768a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们期望执行的结果如下。</p><pre class="lu lv lw lx gt nm mi nn no aw np bi"><span id="847d" class="mz kr in mi b gy nq nr l ns nt">GNU echo<br/>asm echo with direct calls to kernel<br/>asm echo with libc functions (without fflush)<br/>asm echo with libc functions</span></pre><p id="b7f4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而这些都是实际结果。</p><pre class="lu lv lw lx gt nm mi nn no aw np bi"><span id="37a2" class="mz kr in mi b gy nq nr l ns nt">GNU echo<br/>asm echo with direct calls to kernel<br/>asm echo with glibc functions</span></pre><p id="325a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">😱<code class="fe mf mg mh mi b">asm echo with libc functions (without fflush)</code>不见了！这是因为文本保存在缓冲区中，只有当缓冲区被刷新时才被打印出来。因此，我们需要在退出之前<strong class="jm io">刷新缓冲区。</strong></p><p id="4f7c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">尽管看起来使用外部函数弊大于利，但这是不正确的，原因有几个。例如:</p><ul class=""><li id="0f08" class="ml mm in jm b jn jo jr js jv mn jz mo kd mp kh mq mr ms mt bi translated">这些功能(通常)都经过了良好的测试，可以投入生产</li><li id="e65d" class="ml mm in jm b jn mu jr mv jv mw jz mx kd my kh mq mr ms mt bi translated">在<code class="fe mf mg mh mi b">printf</code>的情况下，缓冲比直接写入设备更有效</li><li id="4932" class="ml mm in jm b jn mu jr mv jv mw jz mx kd my kh mq mr ms mt bi translated">他们做其他事情是为了确保性能、安全性、一致性…</li></ul><p id="94d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，人们肯定<strong class="jm io">更喜欢使用 libc 函数</strong>。在这一系列的文章中，我没有怎么使用它们，因为我想让我们对组装有更深入的了解。</p></div><div class="ab cl kj kk hr kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ig ih ii ij ik"><h1 id="521c" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">计算字符串哈希</h1><p id="e285" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">终于！我们现在准备写程序来计算一个字符串散列。</p><p id="6632" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">回想一下，哈希由以下等式给出。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/c3f8e917671616a87425095543f32a65.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/0*EjNPB8r9_X6DQgX8.png"/></div></figure><p id="3ba7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/assembly-by-example-compute-string-hash-part-2-loops-ba39de0ff6d6">第 2 部分</a>中，我们看到</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/f5fb621ad5bdf05671a52ebdc82ce450.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/0*JaRFpL3DzPdE-OVy.png"/></div></figure><p id="edaa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">其中 h sub j 是从索引 0 处的 char 到索引 j 处的 char(包括 0 和 j)的字符串的哈希。</p><p id="ab43" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，计算字符串哈希的伪代码是</p><pre class="lu lv lw lx gt nm mi nn no aw np bi"><span id="db8b" class="mz kr in mi b gy nq nr l ns nt">h := 0<br/>for i = 0; i &lt; |s|; i++ {<br/>  h = 31 * h + s[i]<br/>}</span></pre><p id="bcf7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为此，我们可以应用以下优化</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/d087a44eba0b69aae46b8dc3267da9a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HwnFso3d3ZFAjFoQ.png"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">左移和减法比简单乘法更有效(参见附录 A)</figcaption></figure><p id="0cb8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有了所有这些分析和我们目前对汇编的了解，编写代码应该是非常简单的。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mj mk l"/></div></figure><h2 id="da60" class="mz kr in bd ks na nb dn kw nc nd dp la jv ne nf le jz ng nh li kd ni nj lm nk bi translated">测试</h2><p id="55b9" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">现在，我们可以执行下面的代码来手动验证我们的汇编代码是否按预期工作。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="70bf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">或者我们可以进行压力测试。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mj mk l"/></div></figure><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/a6c8248b3e07f58ca1e36b2d1564b03e.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/1*DAMQ72P9lccWFbZtiyzKOA.gif"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">压力测试执行输出</figcaption></figure><h1 id="09ff" class="kq kr in bd ks kt od kv kw kx oe kz la lb of ld le lf og lh li lj oh ll lm ln bi translated">结论</h1><p id="e872" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">至此，我们结束了这一系列的职位。我希望你学到了新的有趣的东西。一如既往，如果你认为有什么地方错了或者有什么地方可以改进，请告诉我。我喜欢你的反馈。</p></div><div class="ab cl kj kk hr kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ig ih ii ij ik"><h1 id="90b8" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">附录 A: mul 与优化</h1><p id="9b48" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">让我们看看我们使用的优化是否在速度或性能上给了我们实际的改进。</p><h2 id="cd9b" class="mz kr in bd ks na nb dn kw nc nd dp la jv ne nf le jz ng nh li kd ni nj lm nk bi translated">使用<code class="fe mf mg mh mi b">mul</code></h2><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="acd2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当执行程序时，我们得到如下结果</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/9d28f47b00832ba4ea6266d8362ad397.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*V2p_2g2SUsZ9rltjLdRnYg.png"/></div></figure><h2 id="da84" class="mz kr in bd ks na nb dn kw nc nd dp la jv ne nf le jz ng nh li kd ni nj lm nk bi translated">使用优化</h2><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="b602" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当执行程序时，我们得到如下结果</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi oj"><img src="../Images/c034d3fc28f9ad16383e844337073414.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*f7f7VS86Fd8HVgTZozamrg.png"/></div></div></figure><p id="f913" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如您所看到的，通过逐位运算和减法执行乘法<code class="fe mf mg mh mi b">31 * a</code>比通过简单的乘法更有效。这是因为，一般来说，左移位和减法，按位来说，是线性或常数时间运算，而乘法是准二次运算。当然，也有高效的乘法算法，如<a class="ae ki" href="https://en.wikipedia.org/wiki/F%C3%BCrer%27s_algorithm" rel="noopener ugc nofollow" target="_blank">的</a>或<a class="ae ki" href="https://en.wikipedia.org/wiki/Karatsuba_algorithm" rel="noopener ugc nofollow" target="_blank">的</a>算法，但左移和减法在这种情况下仍然更有效。</p></div></div>    
</body>
</html>