# 一篇“C”静态库文章

> 原文：<https://blog.devgenius.io/how-to-create-and-use-a-c-static-library-fcf7b20e6302?source=collection_archive---------9----------------------->

![](img/3004cfce22702fdc1d727971d421519e.png)

当被程序调用时，静态库总是可用的

> 在本文中，我将解释什么是静态库，它们是如何工作的，如何创建一个静态库，以及计算机程序如何使用静态库。

**我们为什么需要库:**软件的代码是由很多函数组成的；函数有点像迷你程序，可以被另一个程序调用来执行输入的计算或修改。

为了用 C 代码解释以上内容，我将创建一个名为 **mult()** 的函数，将两个数字相乘，并将结果存储在一个名为“结果”的变量中:

```
int main(void)
{
int x = 4;
int y = 6;
int result;result = mult(x, y);
return (0);
}
```

所以这个程序只有在编译器知道函数 **mult()** 的情况下才会编译；通常，程序员可以在 main 函数之上定义并创建一个函数 **mult()** ，这样编译器就可以在程序本身中找到它。它可能看起来像这样:

```
int mult(int a, int b)
{
return (a * b);
}int main(void)
{
int x = 4;
int y = 6;
int result;result = mult(x, y);
return (0);
}
```

**mult()** 函数将两个变量(x，y)相乘并返回一个结果，还有更复杂的函数，它们甚至会变得很长，通常会使程序难以阅读，当 **main()** 函数之上有许多函数时，甚至会变得更复杂。

这就是静态库变得方便的地方，你可以把一个库想象成一个书籍的集合，每本书都是一个函数，比如 **mult()** ，任何可以访问这个库的人都可以阅读它，通常它们很容易阅读。

**静态库如何工作？**

静态库只是包含函数的目标文件的集合，这些函数通常用符号和地址来索引，就像一本书的目录表，这样更容易找到函数。

通常，在创建可执行文件之前，静态库在编译阶段的链接阶段被加入到程序的主模块中。在一个静态库成功链接到一个程序的主模块后，可执行文件将包含*主程序和库。*

**如何创建它们？**

静态库是使用一种类型的归档软件创建的，例如" **ar"** 命令，该命令使用**带一个或多个目标文件。o"** 文件扩展名，并将其压缩，生成一个文件扩展名为**的存档文件。一个"**这是我们的静态库。

我们必须考虑到，在我们使用 ar 命令之前，我们必须有一些对象文件给它，这样做的方法是使用一个我们希望包含在我们的库中的函数，并在 GNU 编译 **(gcc)** 时使用**-c "**命令来停止编译过程，这样该命令的输出将由**产生。c"** 文件扩展名为 **"o."** 文件扩展名，如下所示:

```
$ gcc -c mult.c   // resulting a mult.o object file! magic!!
```

现在我们有了带有**的目标文件。o "** 文件扩展名，我们可以继续将它们归档，并使用 **"ar"** 创建一个静态库，如下所示:

```
$ ar -rc libforme.a mult.o
```

现在我们已经创建了一个名为“libforme.a”的静态库。在它里面将是我们的 **mult()** 函数，这个函数已经在前面通过**“gcc”**命令被转换成一个目标文件。

> **-rc** comamnd 选项创建归档文件时不发出警告，并替换库中任何预先存在的同名目标文件。

存档自动组织库的索引，但是为了确保索引将组织库，我们使用命令 **"ranlib"** 在存档中创建并存储一个索引，如下所示:

```
$ ranlib libforme.a
```

在由可重定位目标文件的档案的成员定义的每个符号的索引列表中，这是命令**“nm”**变得方便的时候，因此我们可以看到目标文件**。o"** 文件扩展名，如下所示:

```
$ nm libforme.a// sample outputmult.o:000000000000002e T mult
```

既然我们已经创建了一个对象文件，将它们压缩到库中并建立索引，就可以在我们的库中使用了。

**如何使用它们？**

如果我们想在这篇文章中编译 C 程序，使用 **mult()** 来存储两个数字的值:

```
int main(void)
{
int x = 4;
int y = 6;
int result;result = mult(x, y);
return (0);
}
```

如果我们试图编译这个程序，我们会得到这样一个错误信息:

```
gcc my_function.c// oops something is wrong!! ///tmp/ccGLAk66.o: In function `main':my_function.c:(.text+0x27): **undefined reference to `mult'**collect2: error: ld returned 1 exit status
```

所以编译器不知道 **mult()** 函数是什么。我们需要解释程序来查看静态库中的 **mult()** 函数，如下所示:

```
gcc my_function.c -L. -lforme -o my_program
```

让我们来分解这个命令:

*   **-L** 表示“在目录中查找库文件”
*   **。**(‘L’后面的点)代表当前工作目录
*   **-l** 表示“与此库文件链接”
*   forme 是我们图书馆的名字。请注意，我们省略了“lib”前缀和“”。一个“分机。链接器将这些部分附加回库的名称，以创建要查找的文件名。
*   **-o my_function** 表示“命名可执行文件 **my_function**

> 如果一切顺利，结果将是一个名为 my_function 的可执行文件，它使用 libforme.a 静态库中包含的 **mut()** 函数。

如果您有任何问题、意见或建议，请随时通过 Twitter @MrTechi 联系我