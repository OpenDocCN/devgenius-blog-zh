<html>
<head>
<title>Why it is necessary to use Arrow functions with React Event handler</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么必须在 React 事件处理程序中使用箭头函数</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/why-it-is-necessary-to-use-arrow-functions-with-react-event-handler-e0b278710310?source=collection_archive---------0-----------------------#2022-04-20">https://blog.devgenius.io/why-it-is-necessary-to-use-arrow-functions-with-react-event-handler-e0b278710310?source=collection_archive---------0-----------------------#2022-04-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/92110b3b1afc33e48d219dd7ce6872f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3zu2c6hWZPjViOIqpSwB8g.png"/></div></div></figure><h1 id="c109" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">简介:</h1><p id="e4e0" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">在过去的几年里，我注意到许多初级 react 开发人员直接在事件处理程序中调用函数，如 onClick、onChange 等，然后他们会遇到一些奇怪的错误，浪费他们的时间。在本文中，我将分享和解释当我们不使用箭头函数而直接在事件处理程序中调用函数时的常见错误。</p><blockquote class="lr ls lt"><p id="0a46" class="kt ku lu kv b kw lv ky kz la lw lc ld lx ly lg lh lz ma lk ll mb mc lo lp lq ig bi translated">请通过媒体<strong class="kv io">跟随我</strong>，获取下一篇新文章的通知。我也活跃在推特<a class="ae md" href="https://twitter.com/IbraKirill" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> @IbraKirill </strong> </a>。</p></blockquote><h2 id="3798" class="me jw in bd jx mf mg dn kb mh mi dp kf le mj mk kj li ml mm kn lm mn mo kr mp bi translated">所以我们将在本文中解释:</h2><p id="9403" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">1-当我们在事件处理程序中直接调用函数时会发生什么</p><p id="09b9" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated">2-常见错误</p><h1 id="39d9" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">当我们在事件处理程序中直接调用函数时会发生什么:</h1><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="cbcc" class="me jw in mv b gy mz na l nb nc">&lt;button onClick={setIsOpen(true)}&gt;<!-- -->Open Modal<!-- -->&lt;/button&gt;</span></pre><p id="7166" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated">这里我们已经直接调用了<strong class="kv io"> setIsOpen() </strong>方法，该方法在组件挂载阶段后不久就被调用，无需用户点击按钮。我们只想在用户点击按钮时执行这个函数。</p><p id="05ac" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated"><strong class="kv io">再比如:</strong></p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="e9fa" class="me jw in mv b gy mz na l nb nc">&lt;button onClick={removeBill(index)}&gt;remove&lt;/button&gt;</span></pre><p id="2c34" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated">这里，onClick 内部的表达式将在挂载上执行。一旦应用程序启动，这将删除列表中的所有账单。</p><h1 id="b240" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">常见错误:</h1><h2 id="f4f6" class="me jw in bd jx mf mg dn kb mh mi dp kf le mj mk kj li ml mm kn lm mn mo kr mp bi translated">1-未捕获的错误:太多的重新渲染。React 限制渲染的数量以防止无限循环:</h2><p id="0b4c" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated"><strong class="kv io">示例:</strong></p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="db18" class="me jw in mv b gy mz na l nb nc">import React, {useState} from 'react';</span><span id="c26d" class="me jw in mv b gy nd na l nb nc">import Modal from '../components/Modal';</span><span id="b91e" class="me jw in mv b gy nd na l nb nc">export default function App() {</span><span id="2a77" class="me jw in mv b gy nd na l nb nc">const [modalIsOpen, setIsOpen] = React.useState(false);</span><span id="d517" class="me jw in mv b gy nd na l nb nc">return (</span><span id="12f4" class="me jw in mv b gy nd na l nb nc">&lt;div&gt;</span><span id="5a12" class="me jw in mv b gy nd na l nb nc">&lt;h1&gt;Hello World!&lt;/h1&gt;</span><span id="7684" class="me jw in mv b gy nd na l nb nc">&lt;Modal</span><span id="acbd" class="me jw in mv b gy nd na l nb nc">IsModalOpened={modalIsOpen}</span><span id="83e5" class="me jw in mv b gy nd na l nb nc">/&gt;</span><span id="cac6" class="me jw in mv b gy nd na l nb nc">&lt;button onClick={setIsOpen(true)}&gt;Open Modal&lt;/button&gt;</span><span id="814b" class="me jw in mv b gy nd na l nb nc">&lt;/div&gt;</span><span id="89d2" class="me jw in mv b gy nd na l nb nc">);</span><span id="11b9" class="me jw in mv b gy nd na l nb nc">}</span></pre><p id="46d1" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated">上面的代码导致:【未捕获的错误:重新渲染次数过多】，我们来理解一下这个错误实际上是什么意思，它意味着我们的组件在无限时间内被渲染。现在一个问题可能会浮现在脑海中，为什么我们的组件会在无限长的时间内被渲染。</p><p id="6061" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated"><strong class="kv io">原因是当我们的组件被渲染时，我们的状态会立即改变。我们知道当状态改变时，我们的组件将被再次呈现。所以它形成了一个无限循环。</strong></p><p id="a40f" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated">让我们看看下面的陈述:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="f521" class="me jw in mv b gy mz na l nb nc">&lt;button onClick={setIsOpen(true)}&gt;<!-- -->Open Modal<!-- -->&lt;/button&gt;</span></pre><p id="df0d" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated">我们用来处理状态的功能组件<a class="ae md" href="https://medium.com/swlh/react-hooks-from-scratch-a-z-bf8f7b404f7f" rel="noopener"> <strong class="kv io"> useState </strong> </a>，这里我们直接调用了<strong class="kv io"> setIsOpen() </strong>方法。它在组件挂载阶段后很快被调用，并不断重新呈现状态，陷入无限循环。</p><p id="df63" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated">所以我们需要重写上面的代码:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="4e31" class="me jw in mv b gy mz na l nb nc">&lt;button onClick=<!-- -->={() =&gt; setIsOpen(true)}<!-- -->&gt;<!-- -->Open Modal<!-- -->&lt;/button&gt;</span></pre><p id="d805" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated">现在<strong class="kv io"> setIsOpen() </strong>将只在点击时被触发，并且在组件挂载阶段之后不会被调用。</p><p id="8c2a" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated"><strong class="kv io">再比如:</strong></p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="efee" class="me jw in mv b gy mz na l nb nc">export default function App() {<br/>const [paymentComp, setPaymentComp] = React.useState(false);<br/>const goTo = (par) =&gt; {</span><span id="d50b" class="me jw in mv b gy nd na l nb nc">// ... some codes then</span><span id="9a7b" class="me jw in mv b gy nd na l nb nc">setPaymentComp(true);<br/>}</span><span id="f94a" class="me jw in mv b gy nd na l nb nc">return (</span><span id="5bfa" class="me jw in mv b gy nd na l nb nc">&lt;div&gt;</span><span id="5c83" class="me jw in mv b gy nd na l nb nc">&lt;h1&gt;Hello World!&lt;/h1&gt;</span><span id="b9ad" class="me jw in mv b gy nd na l nb nc">&lt;button onClick={goTo("next")}&gt;Complete&lt;/button&gt;</span><span id="9878" class="me jw in mv b gy nd na l nb nc">&lt;/div&gt;</span><span id="527d" class="me jw in mv b gy nd na l nb nc">);</span><span id="198a" class="me jw in mv b gy nd na l nb nc">}</span></pre><p id="bbb7" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated">甚至，如果我在事件处理程序中直接调用这个函数&amp;这个函数包含一些改变状态的代码，它也会导致这个错误，所以最好用一个箭头函数在事件处理程序中调用这个函数。：</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="fab7" class="me jw in mv b gy mz na l nb nc">&lt;button onClick={() =&gt;goTo("next")}&gt;Complete&lt;/button&gt;</span></pre><h2 id="d1a2" class="me jw in bd jx mf mg dn kb mh mi dp kf le mj mk kj li ml mm kn lm mn mo kr mp bi translated">React 事件处理程序中未定义的“this”或 setState 未定义:</h2><p id="4de8" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">这个错误发生在 React 类组件上，让我们看看下面的例子:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="06de" class="me jw in mv b gy mz na l nb nc">class App extends Component {</span><span id="814c" class="me jw in mv b gy nd na l nb nc">state = {</span><span id="c0dd" class="me jw in mv b gy nd na l nb nc">name: "Mark"</span><span id="023e" class="me jw in mv b gy nd na l nb nc">}</span><span id="a470" class="me jw in mv b gy nd na l nb nc">id = 20;</span><span id="eb5b" class="me jw in mv b gy nd na l nb nc">handleClick(){</span><span id="1916" class="me jw in mv b gy nd na l nb nc">//console.log('Clicked');</span><span id="ccb4" class="me jw in mv b gy nd na l nb nc">//here will produce undefined</span><span id="20d9" class="me jw in mv b gy nd na l nb nc">console.log(this);<br/>console.log(this.id);</span><span id="6e10" class="me jw in mv b gy nd na l nb nc">//here will produce error</span><span id="8225" class="me jw in mv b gy nd na l nb nc">console.log(this.state.name);</span><span id="bbad" class="me jw in mv b gy nd na l nb nc">}</span><span id="3068" class="me jw in mv b gy nd na l nb nc">render() {</span><span id="b1b4" class="me jw in mv b gy nd na l nb nc">return (&lt;&gt; &lt;button onClick={this.handleClick} &gt;click&lt;/button&gt; &lt;/&gt;);<br/>}<br/>}</span></pre><p id="2e1c" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated">在这个<strong class="kv io"> App </strong>组件中，我们从事件处理程序中访问类的成员&amp;状态。我们认为<code class="fe ne nf ng mv b">this</code>指向了<code class="fe ne nf ng mv b">App</code>类，但是我们得到了一个严重的错误。<strong class="kv io">类型错误:无法读取未定义的属性“id”。</strong></p><p id="6ddd" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated">我们在函数内部定义(this)的时候有一个问题，然后在 Event 内部调用，但是 React.js 不理解(this)指的是什么？？所以我们想让 React 明白(this)内部事件处理程序指的是当前类。</p><p id="143a" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated">另一个例子:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="6a7e" class="me jw in mv b gy mz na l nb nc">class App extends Component {</span><span id="0143" class="me jw in mv b gy nd na l nb nc">constructor(props) {</span><span id="3b74" class="me jw in mv b gy nd na l nb nc">super(props);</span><span id="c62d" class="me jw in mv b gy nd na l nb nc">this.state = {</span><span id="3838" class="me jw in mv b gy nd na l nb nc">msg: 'Hello World'</span><span id="5965" class="me jw in mv b gy nd na l nb nc">}</span><span id="14a7" class="me jw in mv b gy nd na l nb nc">}</span><span id="56c9" class="me jw in mv b gy nd na l nb nc">onSetDefaultMsg() {</span><span id="21e4" class="me jw in mv b gy nd na l nb nc">this.setState({</span><span id="f1f9" class="me jw in mv b gy nd na l nb nc">welcomeMsg: 'Hello User!'</span><span id="b5d4" class="me jw in mv b gy nd na l nb nc">});</span><span id="3da7" class="me jw in mv b gy nd na l nb nc">}</span><span id="63d6" class="me jw in mv b gy nd na l nb nc">render() {</span><span id="cf0d" class="me jw in mv b gy nd na l nb nc">return (</span><span id="c3df" class="me jw in mv b gy nd na l nb nc">&lt;div&gt;</span><span id="0263" class="me jw in mv b gy nd na l nb nc">&lt;h1&gt;{this.state.welcomeMsg}&lt;/h1&gt;</span><span id="87f1" class="me jw in mv b gy nd na l nb nc">&lt;button onClick={this.onSetDefaultMsg}&gt;Generate Message&lt;/button&gt;</span><span id="5fa4" class="me jw in mv b gy nd na l nb nc">&lt;/div&gt;</span><span id="e64e" class="me jw in mv b gy nd na l nb nc">);</span><span id="0e9c" class="me jw in mv b gy nd na l nb nc">}</span></pre><p id="b9e7" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated">上例的另一个错误:<strong class="kv io"> setState 未定义</strong>。但是我们知道 setState 方法之前是由 React 在类组件中定义的，那么为什么这个错误会出现在我们面前。</p><p id="f497" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated"><code class="fe ne nf ng mv b">this</code>关键字必然取决于它在哪里被定义。在这种情况下，<code class="fe ne nf ng mv b">this</code>恢复到其默认绑定。在我们以非严格模式运行的情况下，这是全局窗口对象，但在严格模式下，这是<code class="fe ne nf ng mv b">undefined</code>。</p><p id="e446" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated">我们需要将事件处理程序绑定到组件。绑定的方式有很多种。我将试着展示并描述其中的大部分:</p><p id="1034" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated"><strong class="kv io">1-使用显式绑定:</strong></p><p id="085a" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated">在这个选项中，我们将<code class="fe ne nf ng mv b">this</code>值显式绑定到我们希望它在函数中引用的对象，我们有两个选项:</p><p id="cd71" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated"><strong class="kv io">A-选项 1: </strong></p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="bdd6" class="me jw in mv b gy mz na l nb nc">&lt;button onClick={this.handleClick.bind(this)} &gt;click&lt;/button&gt;</span></pre><p id="9e82" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated"><strong class="kv io"> B 选项 2: </strong></p><p id="015d" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated">通过在组件的构造函数中添加这一行，这将引用事件处理函数中的组件:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="b004" class="me jw in mv b gy mz na l nb nc">constructor(props) {</span><span id="1f01" class="me jw in mv b gy nd na l nb nc">this.handleClick= this.handleClick.bind(this)  // Just Bind here</span><span id="21e1" class="me jw in mv b gy nd na l nb nc">}</span></pre><p id="f918" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated">虽然这种方法可行，但有两个问题:</p><p id="9e35" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated">让我们项目中的某个地方的代码修改我们项目中其他地方的代码不是一个好的做法。这是可行的，但这不是一个很好的实践。</p><p id="164f" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated">当我们将当前组件绑定到方法时，假设页面上有十个这样的按钮。这意味着我们将这个组件的 10 个实例绑定到函数上。虽然在这个简单的例子中不会产生很大的影响，但是一些复杂的组件可能会产生更大的影响。</p><p id="58e5" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated"><strong class="kv io">2-使用箭头功能:</strong></p><p id="2a4f" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated">第二个解决方案是箭头函数:当我们使用箭头函数时，事件处理程序自动绑定到组件实例，因此我们不需要在构造函数中绑定它。箭头函数将在函数内部绑定&amp;定义(this)引用类组件。<strong class="kv io">配合箭头功能更好。</strong></p><p id="ed9a" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated">我们有两个选择可以做到这一点:</p><p id="a9b1" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated"><strong class="kv io">A-选项 1: </strong></p><p id="1c13" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated">我们将用箭头语法重写处理函数:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="d273" class="me jw in mv b gy mz na l nb nc">onSetDefaultMsg = () =&gt; {</span><span id="0003" class="me jw in mv b gy nd na l nb nc">this.setState({</span><span id="f2bd" class="me jw in mv b gy nd na l nb nc">welcomeMsg: 'Hello User!'</span><span id="ab0d" class="me jw in mv b gy nd na l nb nc">});</span><span id="7f32" class="me jw in mv b gy nd na l nb nc">}</span></pre><p id="c9a6" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated"><strong class="kv io"> B 选项 2: </strong></p><p id="a8ce" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated">我们不会重写处理函数，但另一个选择是在回调中包含箭头函数:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="2b2b" class="me jw in mv b gy mz na l nb nc">&lt;button onClick={() =&gt; this.handleClick()} &gt;click&lt;/button&gt;</span></pre><blockquote class="lr ls lt"><p id="0a28" class="kt ku lu kv b kw lv ky kz la lw lc ld lx ly lg lh lz ma lk ll mb mc lo lp lq ig bi translated">如果您想在 React  中深入研究<a class="ae md" href="https://click.linksynergy.com/link?id=GGg4no0HUcA&amp;offerid=1060092.2815357&amp;type=2&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fcourse%2Fadvanced-react-render-performance-best-practices-patterns%2F" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io">最佳实践模式。我劝你用下面的<a class="ae md" href="https://click.linksynergy.com/link?id=GGg4no0HUcA&amp;offerid=1060092.2815357&amp;type=2&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fcourse%2Fadvanced-react-render-performance-best-practices-patterns%2F" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io">课程</strong> </a> <strong class="kv io">。</strong></strong></a></p><p id="bacb" class="kt ku lu kv b kw lv ky kz la lw lc ld lx ly lg lh lz ma lk ll mb mc lo lp lq ig bi translated">如果你喜欢看文章，想支持我当作家，你可以<a class="ae md" href="http://buymeacoffee.com/kirillibrahim" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io">请我喝杯咖啡！</strong>T13】</a></p><p id="3b3b" class="kt ku lu kv b kw lv ky kz la lw lc ld lx ly lg lh lz ma lk ll mb mc lo lp lq ig bi translated">如果你想一头扎进<strong class="kv io"> </strong> <a class="ae md" href="https://click.linksynergy.com/link?id=GGg4no0HUcA&amp;offerid=1060092.1411694&amp;type=2&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fcourse%2Fthe-complete-react-fullstack-course%2F" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io">反应 18 </strong> </a>用实际例子，我奉劝你用下面的<a class="ae md" href="https://click.linksynergy.com/link?id=GGg4no0HUcA&amp;offerid=1060092.1411694&amp;type=2&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fcourse%2Fthe-complete-react-fullstack-course%2F" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io">课程</strong> </a>。</p></blockquote></div></div>    
</body>
</html>