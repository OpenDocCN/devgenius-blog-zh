<html>
<head>
<title>Seasoned Java Developers Use These 3 Simple Java String Quirks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">经验丰富的 Java 开发人员使用这 3 个简单的 Java 字符串</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/seasoned-java-developers-use-these-3-simple-java-string-quirks-7c8dc4a60c3e?source=collection_archive---------4-----------------------#2022-03-27">https://blog.devgenius.io/seasoned-java-developers-use-these-3-simple-java-string-quirks-7c8dc4a60c3e?source=collection_archive---------4-----------------------#2022-03-27</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="bc93" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated"><em class="kg"> 3 种提高性能的 Java 字符串技巧</em></h2></div><figure class="ki kj kk kl gu km gi gj paragraph-image"><div class="gi gj kh"><img src="../Images/7c0db55382e3d2b26016f296e08061ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VjV17nGXVF3EMOm2.jpeg"/></div><figcaption class="kp kq gk gi gj kr ks bd b be z dk translated"><a class="ae kt" href="https://www.freepik.com/photos/business" rel="noopener ugc nofollow" target="_blank">亚娜拉·www.freepik.com 创作的商业照片</a></figcaption></figure><p id="0dbd" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated"><em class="lq">用</em> <code class="fe lr ls lt lu b"><em class="lq">String#format</em></code> <em class="lq">吗？您知道字符串重复数据删除的新功能吗？你想知道更多关于串联的知识吗？</em></p><p id="3d9f" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated">这些怪癖涵盖了以上所有。最有趣的是<code class="fe lr ls lt lu b">String#format</code>方法的变化。这样一个简单的改变获得了很大的性能提升。</p><p id="617d" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated"><em class="lq">下面是你应该知道的 Java </em> <code class="fe lr ls lt lu b"><em class="lq">String</em></code> <em class="lq">怪癖。</em></p><h1 id="b4f6" class="lv lw ir bd lx ly lz ma mb mc md me mf jx mg jy mh ka mi kb mj kd mk ke ml mm bi translated"><code class="fe lr ls lt lu b">String.format</code>变得更快了</h1><p id="989f" class="pw-post-body-paragraph ku kv ir kw b kx mn js kz la mo jv lc ld mp lf lg lh mq lj lk ll mr ln lo lp ik bi translated">字符串格式在所有潜在的连接方法中表现最差。</p><p id="5042" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated">下面是我对 JDK13 的测试。最差的表现来自<code class="fe lr ls lt lu b">String#format</code>这个方法。如果你使用循环来连接 100 个字符串，你最后的选择应该是<code class="fe lr ls lt lu b">String#format</code>。</p><figure class="ki kj kk kl gu km gi gj paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gi gj ms"><img src="../Images/ac5dc7c24f7152ce8122e67a764aa8c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HZ9LQ-yKnXzB-P1vc-VxrA.png"/></div></div></figure><p id="d4e4" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated">尽管最慢，最近对<code class="fe lr ls lt lu b">String#format</code>做了一些改进。<strong class="kw is"> <em class="lq">一个开发者，</em></strong><a class="ae kt" href="https://github.com/openjdk/jdk/pull/2830" rel="noopener ugc nofollow" target="_blank"><strong class="kw is"><em class="lq">cl4es</em></strong></a>，<strong class="kw is"> <em class="lq">设法在 JDK17 中提高了这种方法的性能。</em> </strong></p><p id="62e0" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated">由于大多数格式包含<code class="fe lr ls lt lu b">%s</code>或<code class="fe lr ls lt lu b">%d</code>，他设法为这些格式创建了一个简单的解析器。显然，最大的性能损失来自首先进行正则表达式匹配。所以他先做简单的检查。</p><p id="0371" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated">以下是他在 17 版本以下的 Java 中对<code class="fe lr ls lt lu b">String#format</code>的基准测试。</p><figure class="ki kj kk kl gu km"><div class="bz fq l di"><div class="mx my l"/></div></figure><p id="d090" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated">根据他的更新，我们得到了以下结果。</p><figure class="ki kj kk kl gu km"><div class="bz fq l di"><div class="mx my l"/></div></figure><p id="445b" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated"><strong class="kw is"> <em class="lq">依然，复杂的格式依然缓慢。但是让我们来看看简单的场景。平均而言，这一变化将时间缩短了 3 倍。</em></strong></p><p id="1c92" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated"><strong class="kw is"> <em class="lq">我们可以断定从 JDK17 开始</em> </strong> <code class="fe lr ls lt lu b"><strong class="kw is"><em class="lq">String#format</em></strong></code> <strong class="kw is"> <em class="lq">对于简单场景有更好的表现。不要为了简单的场景而回避。</em> </strong></p><p id="b284" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated">对于复杂的场景来说，还是差不多的。在我们得到<a class="ae kt" href="https://openjdk.java.net/jeps/8273943" rel="noopener ugc nofollow" target="_blank">模板化字符串</a>或字符串插值之前，我们会一直使用这个选项。</p><h1 id="7a44" class="lv lw ir bd lx ly lz ma mb mc md me mf jx mg jy mh ka mi kb mj kd mk ke ml mm bi translated">为什么默认情况下会关闭重复数据删除？</h1><p id="e739" class="pw-post-body-paragraph ku kv ir kw b kx mn js kz la mo jv lc ld mp lf lg lh mq lj lk ll mr ln lo lp ik bi translated">从 Java 8 开始，我们现在有了字符串的重复数据删除。</p><p id="11ab" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated"><strong class="kw is"><em class="lq"/></strong><a class="ae kt" href="https://openjdk.java.net/jeps/192" rel="noopener ugc nofollow" target="_blank"><strong class="kw is"><em class="lq">JEP</em></strong></a><strong class="kw is"><em class="lq">中有关于重复数据删除的详细信息。要点是大约四分之一的堆被字符串占据。其中一半是重复的字符串。</em></strong></p><p id="bccf" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated">可以删除其中一个中的重复项。所以我们可以只占用堆的 12.5%。</p><p id="1d02" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated">以前这只在 G1 GC 领导下的<a class="ae kt" href="https://dzone.com/articles/usestringdeduplication" rel="noopener ugc nofollow" target="_blank">有效。从 Java 17 开始，重复数据删除将适用于所有 GC。</a></p></div><div class="ab cl mz na hv nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ik il im in io"><p id="a47b" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated">尽管如此，这个功能在默认情况下是不打开的。要打开它，你需要传递下面的标志:<code class="fe lr ls lt lu b">-XX:+UseStringDeduplication</code>。对于低于 17 的 Java，你也需要添加<code class="fe lr ls lt lu b">-XX:+UseG1GC</code>。因为较低版本不支持其他 GC 算法。</p><p id="603c" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated">我会说默认关闭它的原因是让客户来决定。另一个原因是性能下降。尽管有很多字符串，但大多数都不是重复的。另一个原因<a class="ae kt" href="https://stackoverflow.com/questions/42080648/why-when-you-would-not-want-to-have-java-8-usestringdeduplication-enabled-in-jvm" rel="noopener ugc nofollow" target="_blank">是垃圾收集器会以任何方式清理这些副本</a>。在启用重复数据删除之前进行性能测试。</p></div><div class="ab cl mz na hv nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ik il im in io"><p id="8ba6" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated">有什么简单的重构方法可以去掉重复的字符串？用  <code class="fe lr ls lt lu b"><strong class="kw is"><em class="lq">EnumMap</em></strong></code> <strong class="kw is"> <em class="lq">。项目中可能有重复的常量。所以让他们聚在一起<code class="fe lr ls lt lu b">EnumMap</code>。</em></strong></p><p id="7656" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated">更快访问的优势<a class="ae kt" href="https://richardstartin.github.io/posts/5-java-mundane-performance-tricks#use-enums-instead-of-constant-strings" rel="noopener ugc nofollow" target="_blank">在这里</a>可见。此外，在 GC 中分配的对象会更少。</p><h1 id="f58d" class="lv lw ir bd lx ly lz ma mb mc md me mf jx mg jy mh ka mi kb mj kd mk ke ml mm bi translated">默认<code class="fe lr ls lt lu b">concat</code>变慢了？</h1><p id="f153" class="pw-post-body-paragraph ku kv ir kw b kx mn js kz la mo jv lc ld mp lf lg lh mq lj lk ll mr ln lo lp ik bi translated">在 Java 8 的早期版本中，默认的<code class="fe lr ls lt lu b">concat</code>运行速度确实慢了一些。在 Java 9 和更高版本中，我们得到了很多改进。</p><p id="4aba" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated">Java 9 中增加了新的运行时连接策略。但是从 Java 15 开始，所有这些都被删除了。由于性能问题，<a class="ae kt" href="https://hg.openjdk.java.net/jdk/jdk/rev/d52c2e540934" rel="noopener ugc nofollow" target="_blank">从 Java 15 开始，这些策略被删除</a>。现在唯一合适的策略是<code class="fe lr ls lt lu b">MH_INLINE_SIZED_EXACT</code>。</p></div><div class="ab cl mz na hv nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ik il im in io"><p id="9d4e" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated">一些用户<a class="ae kt" href="https://bugs.openjdk.java.net/browse/JDK-8278540" rel="noopener ugc nofollow" target="_blank">在 Java 17 和 18 </a>中面临初始引导性能冲击。以前你可以退回到 Java 8 策略(<code class="fe lr ls lt lu b">BC_SB</code>)，但是现在你不能了。</p><p id="a3e8" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated">这个 bug 还表明，Java 11 在这个优化上比 Java 15+做得更好。可能是这个用例特有的，但仍然很奇怪。奇怪是因为 Java 应该是向后兼容的。</p></div><div class="ab cl mz na hv nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ik il im in io"><p id="be39" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated"><em class="lq">那么，您能做些什么来禁用这些优化呢？现在你只能在编译时禁用它们。</em></p><p id="beb4" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated">Malt <a class="ae kt" href="https://stackoverflow.com/a/58681713/5999670" rel="noopener ugc nofollow" target="_blank">就如何完全禁用策略提出了这个解决方案</a>。</p><p id="6476" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated">在 Java 15 之前，您可以使用 JVM arg <code class="fe lr ls lt lu b">-Djava.lang.invoke.stringConcat=BC_SB</code>来启用某些策略。现在你只能在编译时用<code class="fe lr ls lt lu b">-XDstringConcat=inline</code>标志来做这件事。</p></div><div class="ab cl mz na hv nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ik il im in io"><p id="2704" class="pw-post-body-paragraph ku kv ir kw b kx ky js kz la lb jv lc ld le lf lg lh li lj lk ll lm ln lo lp ik bi translated">我用<a class="ae kt" href="https://medium.com/javarevisited/5-effective-string-practices-you-should-know-e9a75811b123#25a1" rel="noopener">在之前的测试</a>、<code class="fe lr ls lt lu b">String#concat</code>中发现，拼接数量越少，效果越好。使用这种方法，没有额外的<code class="fe lr ls lt lu b">StringBuilder</code>或<code class="fe lr ls lt lu b">StringBuffer</code>。尽管<code class="fe lr ls lt lu b">String.concat</code>不是最快的，但它在吞吐量方面胜过其他选项。</p><figure class="ki kj kk kl gu km gi gj paragraph-image"><div class="gi gj kh"><img src="../Images/603137ee2f92961d1693511e7c9902ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pSNjrY4ddYNmVHgq.png"/></div></figure></div></div>    
</body>
</html>