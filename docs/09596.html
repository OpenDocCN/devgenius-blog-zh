<html>
<head>
<title>Searching Algorithms in Python. #Python Series - 9</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的搜索算法。#Python 系列- 9</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/searching-algorithms-in-python-python-series-9-c58fbfe27cfd?source=collection_archive---------14-----------------------#2022-08-30">https://blog.devgenius.io/searching-algorithms-in-python-python-series-9-c58fbfe27cfd?source=collection_archive---------14-----------------------#2022-08-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/0ca40f29f53974d2b2f279df6b1af792.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KQ2C_b3auzew9Y4fvnngZg.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">搜索图像</figcaption></figure><p id="9eca" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi kx translated">到目前为止，我们已经学习了 python 的基础知识。但是，我们从未见过这些基本原理的应用。在这篇文章中，我们将看到两个简单的算法，处理搜索一个列表中的数字。如果你是一个初学者和算法新手，开始使用算法可能是相当棘手的，这篇文章为你减轻负担。让我们开始吧。</p><figure class="lh li lj lk gt jo gh gi paragraph-image"><div class="gh gi lg"><img src="../Images/c681ef5654a00d8829626a5186da95f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:470/format:webp/1*87rA7rBQh9t2Y3_3KjUAdw.png"/></div></figure><p id="01af" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">说到搜索算法，在编码界有两种算法是相当著名的(即线性搜索和二分搜索法)。</p><h1 id="9733" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">线性搜索</h1><p id="298a" class="pw-post-body-paragraph jz ka in kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ig bi translated">根据维基百科，线性搜索的定义是“<strong class="kb io">线性搜索</strong>或<strong class="kb io">顺序搜索</strong>是一种在列表中查找元素的方法。它会按顺序检查列表中的每个元素，直到找到匹配项或搜索完整个列表。</p><p id="8b54" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">简而言之，从列表(Index-0)开始，一个一个地搜索，直到找到要搜索的元素。例如，我需要在列表中找到 3[7，2，0，7，2，3，5，9，5]</p><figure class="lh li lj lk gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mo"><img src="../Images/40873d30d8f14d60ef0cb582f879dbf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VpGX7VveoTrMdHxjTh8e8g.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">列表-1</figcaption></figure><p id="e1d0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们从索引 0 开始，</p><p id="d013" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">3 是否存在于索引-0 中→否，</p><p id="5ff3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">3 是否存在于索引-1 中→否，</p><p id="f44d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">3 是否存在于索引-2 中→否，</p><p id="7487" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">3 是否存在于索引-3 中→否，</p><p id="ddc5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">3 是否存在于索引-4 中→否，</p><p id="394a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">3 是否出现在索引-5 中→ <strong class="kb io">是。</strong>停止返回索引号即 5</p><p id="2422" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在最坏的情况下，您需要查找的号码可能不在列表中。当您到达列表的末尾时，只需返回-1。</p><p id="11ac" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们用 python 代码做同样的尝试。</p><pre class="lh li lj lk gt mp mq mr ms aw mt bi"><span id="d043" class="mu lm in mq b gy mv mw l mx my">def binary_searching(my_list, element):<br/>    i = 0<br/>    while i &lt; len(my_list):<br/>        if my_list[i] == element:<br/>            return i<br/>        i = i + 1<br/>    else:<br/>        return -1<br/><br/><br/>if __name__ == "__main__":<br/>    my_list = [7, 2, 0, 7, 2, 3, 5, 9, 5]<br/>    element = 3<br/>    idx = binary_searching(my_list, element)<br/>    print(idx)</span></pre><p id="1ce4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">线性搜索的时间复杂度为<strong class="kb io"> O(n) </strong>，因为在最坏的情况下，它遍历整个列表。</p><p id="5fa8" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">同样的空间复杂度是 O(1) ，因为它不占用输入列表之外的任何空间。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h1 id="8815" class="ll lm in bd ln lo ng lq lr ls nh lu lv lw ni ly lz ma nj mc md me nk mg mh mi bi translated">二进位检索</h1><p id="d7f0" class="pw-post-body-paragraph jz ka in kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ig bi translated">与线性搜索相比，二分搜索法效率高且速度快，但主要缺点是为了执行二分搜索法，我们需要对列表进行排序。</p><p id="0470" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">二分搜索法在双指针方法中工作，我们需要两个指针在列表的两个极端索引上，比如说<strong class="kb io">开始</strong>和<strong class="kb io">结束</strong>。</p><p id="b66b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">基于开始和结束，我们找到 mid =(开始+结束)/ 2。现在，我们将 mid 索引值与要查找的元素进行比较。</p><p id="1e85" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">案例-1: </strong>如果 mid index 中的值等于 element，那么我们只返回 mid Index。</p><p id="8462" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">情况-2: </strong>如果 mid 索引中的值大于元素，则调整<strong class="kb io"> end = mid - 1 </strong>的值。原因是如果中间索引中的值大于元素，那么从中间索引到结尾索引的所有值都大于我们要搜索的元素。所以，我们可以忽略这些指数。</p><p id="12a7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">情况-3: </strong>如果 mid Index 中的值小于 element，那么我们需要调整<strong class="kb io"> start = mid + 1 </strong>的值。原因是显而易见的。如果中间指数的值较小，则中间指数以下的所有值也较小。</p><p id="3546" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们将继续这样，直到开始值小于结束值。如果它们相互交叉，那么我们就退出循环，然后说我们要搜索的元素没有通过返回-1 找到。</p><p id="47f0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">二分搜索法的 Python 代码</strong></p><pre class="lh li lj lk gt mp mq mr ms aw mt bi"><span id="f394" class="mu lm in mq b gy mv mw l mx my">def binary_searching(my_list, element):<br/>    start = 0<br/>    end = len(my_list) - 1<br/>    while start &lt;= end:<br/>        mid = (start + end) // 2  # Integer Division<br/>        if my_list[mid] &lt; element:<br/>            start = mid + 1<br/>        elif my_list[mid] &gt; element:<br/>            end = mid - 1<br/>        else:<br/>            return mid  # my_list[mid] == element<br/>    else:<br/>        return -1<br/><br/><br/>if __name__ == "__main__":<br/>    my_list = [1, 4, 6, 8, 9, 10, 14, 17, 18]<br/>    element = 19<br/>    ans = binary_searching(my_list, element)<br/>    print(ans)</span></pre><p id="8292" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">二分搜索法的时间复杂度是<strong class="kb io"> O(logn) </strong>对于列表中的 100 个元素，我们在循环中只迭代 6-8 个元素。这些时间复杂度有数学推导，我们将在以后的文章中介绍。</p><p id="b0ef" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">空间复杂度是 O(1)，除了变量，我们没有创建任何数据结构。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><p id="8bfc" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">分类算法后会有期…</p></div></div>    
</body>
</html>