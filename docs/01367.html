<html>
<head>
<title>MultiThreading in Java — Basics To Advance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 中的多线程——进阶基础</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/multithreading-in-java-basics-to-advance-e68f8e344df7?source=collection_archive---------14-----------------------#2020-07-01">https://blog.devgenius.io/multithreading-in-java-basics-to-advance-e68f8e344df7?source=collection_archive---------14-----------------------#2020-07-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="075e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">嗨，我是一名有 2 年多经验的软件开发人员，在我的职业生涯中，我曾多次使用 thread，在一次技术面试中被问到 50 多次，所以我想让我们在一个地方分享我所有的知识。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/80035b825817624176162a543db483c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ckEihMg7ZxrzQsL89JGGLA.jpeg"/></div></div></figure><p id="8cc1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本文的目标是将学习线程所需的所有主题与链接的资源放在一起。这也有助于在面试前快速回顾多线程的所有内容。当然，现在每个主题或关键词的详细解释都可以很容易地在互联网上找到。</p><p id="33db" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我想强调一下，为了学习与 JAVA 多线程相关的知识，您必须熟悉哪些主题。</p><p id="2145" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我将这篇文章分成三个部分</p><ul class=""><li id="c9cf" class="ku kv in jm b jn jo jr js jv kw jz kx kd ky kh kz la lb lc bi translated"><strong class="jm io">基础知识</strong>:或必须知道的概念</li><li id="dee8" class="ku kv in jm b jn ld jr le jv lf jz lg kd lh kh kz la lb lc bi translated"><strong class="jm io">高级</strong>:一些高级主题及其用例</li><li id="231d" class="ku kv in jm b jn ld jr le jv lf jz lg kd lh kh kz la lb lc bi translated"><strong class="jm io"> Industrial </strong>:线程在生产就绪型应用中的实际应用。</li></ul><p id="0694" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们从线程中的先决条件和<em class="li">必须知道的</em>事情开始。</p><p id="fcd9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">1: <strong class="jm io">进程 vs 线程</strong></p><p id="d874" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">进程意味着任何程序都在执行中。该进程需要更多的时间来终止，它是孤立的，意味着它不与任何其他进程共享内存。一个进程共享代码、数据、堆栈和寄存器。</p><p id="ba66" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">线程是进程的一部分，这意味着一个进程可以有多个线程，而这些多个线程包含在一个进程中。与进程相比，线程需要更少的时间来终止，并且类似的进程线程不会被隔离。</p><p id="9aa9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2: <strong class="jm io">上下文切换</strong></p><p id="2ee4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">线程或进程之间的切换是一种上下文切换。</p><p id="80e4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">线程切换非常有效，而且便宜得多，因为它只涉及切换出标识和资源，如程序计数器、寄存器和堆栈指针。</p><p id="bd60" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">而在进程的情况下，它包括用新进程所需的资源关闭所有进程资源。这意味着交换内存地址空间。这包括内存地址、页表、内核资源、处理器中的缓存。</p><p id="8a32" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3: <strong class="jm io">多处理 vs 多线程</strong></p><p id="ab02" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一台电脑同时运行多个程序(比如同时运行 Skype 和 Chrome)就是多重处理。</p><p id="5975" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">多线程是多任务的扩展。在这里，任务共享一个公共资源(比如 1 个 CPU)。</p><p id="43e8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">4: <strong class="jm io">线程的生命周期</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lj"><img src="../Images/55cdbfff8df246af83f976acdf02ba81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*ByCt7LibXucW967vP_kh3g.png"/></div></figure><p id="f7e6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">5: <strong class="jm io">守护线程(什么&amp;如何创建它们？)</strong></p><ul class=""><li id="5957" class="ku kv in jm b jn jo jr js jv kw jz kx kd ky kh kz la lb lc bi translated">守护线程是一个低优先级线程，在后台运行，执行垃圾收集(GC)等任务。JVM 不会等待这个线程结束，所以你的程序可以结束，守护线程仍然可以在后台运行。</li><li id="cc0c" class="ku kv in jm b jn ld jr le jv lf jz lg kd lh kh kz la lb lc bi translated">在线程启动之前，将线程设置为守护进程的唯一方法是 setDaemon(true)。</li></ul><p id="a451" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">6: <strong class="jm io">创建线程的不同方式</strong></p><ul class=""><li id="3d22" class="ku kv in jm b jn jo jr js jv kw jz kx kd ky kh kz la lb lc bi translated">通过实现<strong class="jm io">可运行的</strong>接口。</li><li id="b9f4" class="ku kv in jm b jn ld jr le jv lf jz lg kd lh kh kz la lb lc bi translated">通过扩展<strong class="jm io">线程</strong>类。</li><li id="8e4e" class="ku kv in jm b jn ld jr le jv lf jz lg kd lh kh kz la lb lc bi translated">使用线程池(在第 3 部分中讨论)</li><li id="b6bf" class="ku kv in jm b jn ld jr le jv lf jz lg kd lh kh kz la lb lc bi translated">使用匿名线程类</li></ul><pre class="kj kk kl km gt lk ll lm ln aw lo bi"><span id="2f7f" class="lp lq in ll b gy lr ls l lt lu">new Thread(new Runnable() {<br/>    @Override<br/>    public void run() {<br/>    }<br/>}).start();</span></pre></div><div class="ab cl lv lw hr lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ig ih ii ij ik"><p id="00ee" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第二部:</strong></p><p id="a17e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">线程的高级概念和实际用例场景。</p><p id="558e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">1: <strong class="jm io"> ThreadLocal </strong></p><p id="0abc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">借助 ThreadLocal，可以创建只能由同一个线程读写的变量。因此，即使两个线程正在执行相同的代码，并且该代码引用了相同的 ThreadLocal 变量，这两个线程也看不到彼此的 ThreadLocal 变量。</p><p id="5867" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="li">例如，</em>假设您正在开发一个电子商务应用程序。您需要为每个请求该控制器流程的客户生成一个唯一的事务 id，并且您需要将该事务 id 传递给 manager/DAO 类中的业务方法，以便进行日志记录。一种解决方案是将这个事务 id 作为参数传递给所有的业务方法。但是这不是一个好的解决方案，因为代码是多余的，不必要的。</p><p id="7310" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了解决这个问题，这里可以使用 ThreadLocal 变量。您可以在控制器或任何预处理器拦截器中生成事务 id；并在 ThreadLocal 中设置这个事务 id。此后，无论控制器调用什么方法，它们都可以从 threadlocal 访问这个事务 id。事务 id 对于每个线程都是唯一的，并且可以从线程的整个执行路径上进行访问。</p><p id="a5a8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Java 中的<strong class="jm io"> Volatile 关键字</strong></p><p id="4ee4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Java volatile 关键字用于将 Java 变量标记为“存储在主内存中”。这基本上意味着，对一个可变变量的每次读写，都是从计算机的主存中读取的。<br/>当线程同时处理变量时，当变量快速更新时，使变量变得不稳定。</p><p id="5fc1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3: <strong class="jm io"> Syn 块和 Syn 方法</strong></p><p id="8235" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">两个主要的<strong class="jm io">区别</strong></p><p id="78bf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">synchronized 方法和块之间的一个显著区别是 Synchronized 块通常会缩小锁的范围。它只锁定了方法的一部分。最好只锁定代码的关键部分，而不是锁定整个方法。</p><p id="17b2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在同步方法的情况下，线程在进入方法时获取锁，在离开方法时释放锁，通常是通过抛出异常。另一方面，在同步块的情况下，线程在进入同步块时获得锁，在离开同步块时释放锁。</p><p id="6ee8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">4: <strong class="jm io">所有</strong> <strong class="jm io">线程类方法</strong></p><p id="f92c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一些最常用的线程类方法有</p><p id="3796" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">run()、start()、Thread.slpeep( long millis)、join()、isDaemon()、interrupt()、getPriority()、getId()、getName()</p><p id="0b0b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="li">对象类方法</em> : wait()，notify()，notifyAll()</p><p id="0ec8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">5:<strong class="jm io">Java 中的 blocking q</strong></p><p id="1d21" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Java BlockingQueue 接口是 Java 集合框架的一部分，它主要用于实现<strong class="jm io">生产者消费者问题</strong>。Java 提供了几种 BlockingQueue 实现，如 ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue。</p><p id="9758" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">6: <strong class="jm io">用 n 根线打印序列…这是一个很常见的面试问题，通过两个线程在一个序列中打印奇偶数，所以我决定为什么不写逻辑并提前做好准备。下面是我的实现的链接。</strong></p><div class="mc md gp gr me mf"><a href="https://pastebin.com/TysMnyMp" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd io gy z fp mk fr fs ml fu fw im bi translated">使用线程按顺序打印偶数和奇数的程序</h2></div><div class="mm l"><div class="mn l mo mp mq mm mr ks mf"/></div></div></a></div></div><div class="ab cl lv lw hr lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ig ih ii ij ik"><p id="5ef6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第三部分:</p><p id="da0a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">螺纹的工业用例</strong></p><p id="3991" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这一部分详细介绍了线程是如何实现的，以及哪些类和接口用于软件行业的真实场景。</p><p id="99d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">1: <strong class="jm io">锁定 Java 中的接口</strong></p><p id="c0bb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Java 中的锁定与同步:</p><p id="417e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">锁和同步块之间的主要区别是:</p><p id="0c4f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">1)超时尝试访问同步块是不可能的。使用 Lock.tryLock(long timeout，TimeUnit timeUnit)，是有可能的。</p><p id="df27" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2)同步块必须完全包含在一个方法中。锁可以在不同的方法中调用 Lock()和 unlock()。</p><p id="5cd6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="li">Java 中锁实现的类型</em></p><ul class=""><li id="0127" class="ku kv in jm b jn jo jr js jv kw jz kx kd ky kh kz la lb lc bi translated">重入锁</li><li id="82d2" class="ku kv in jm b jn ld jr le jv lf jz lg kd lh kh kz la lb lc bi translated">reentrantreadwritellock</li></ul><p id="8a87" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2:<strong class="jm io">Java 中的 CountDownLatch</strong></p><p id="2f04" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">CountDownLatch 用于确保任务在启动前等待其他线程。为了理解它的应用，让我们考虑一个服务器，其中主任务只能在所有需要的服务都已启动时启动。</p><p id="47ba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">用计数器(整数类型)初始化 CountDownLatch 当从属线程完成执行时，此计数器递减。但是一旦计数器达到零，其他线程就会被释放。</p><p id="efcb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您自己处理线程，则只能使用 Thread.join。大多数人选择不直接处理令人头痛的线程处理，而是使用 ExecutorService 来为他们处理。ExecutorServices 不直接显示它们是如何执行任务的，所以您必须使用 CountDownLatch:(假设您不想只是关闭整个服务，也就是说。)</p><p id="7e86" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3:<strong class="jm io">Java 中的线程池</strong></p><ul class=""><li id="a227" class="ku kv in jm b jn jo jr js jv kw jz kx kd ky kh kz la lb lc bi translated"><strong class="jm io"><em class="li">fixed thread pool</em></strong>:一个队列，10 个 runnable 和一个 5 线程池，然后并行启动 5 个线程，等待 1 个线程完成，然后给队列中的第 6 个线程机会。</li><li id="5b47" class="ku kv in jm b jn ld jr le jv lf jz lg kd lh kh kz la lb lc bi translated"><strong class="jm io"><em class="li">CachedThreadPool</em></strong>:一个线程池，创建它需要的尽可能多的线程(MAX_INTEGER)来并行执行任务。旧的可用线程将被重新用于新的任务。如果一个线程在 60 秒内没有被使用，它将被终止并从池中删除</li><li id="c164" class="ku kv in jm b jn ld jr le jv lf jz lg kd lh kh kz la lb lc bi translated"><strong class="jm io">调度线程池</strong>:定期调度任务的线程池。</li></ul><p id="1f8a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">4: <strong class="jm io">执行器接口</strong></p><p id="5f75" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Java 中的并发 API 提供了一个被称为<strong class="jm io">执行器</strong>的特性，由<strong class="jm io">发起并控制线程</strong>的执行。因此，执行器提供了使用 thread 类管理线程的替代方法。在实际应用中，该接口主要用于将创建线程的逻辑与业务逻辑分离开来。</p><p id="d8dd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">前面提到的线程池实际上是使用 Executor 接口创建的。</p><pre class="kj kk kl km gt lk ll lm ln aw lo bi"><span id="d756" class="lp lq in ll b gy lr ls l lt lu">ExecutorService service = Executors.newFixedThreadPool(5);<br/>for(int x = 0; x &lt; numOfThreads; x++) {<br/>service.submit(new Runnable() {<br/>  public void run() {<br/>  // do something<br/> }<br/>});<br/>}</span></pre><p id="dd2f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">5:<strong class="jm io">Java 中的期货</strong></p><p id="ed23" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你需要从一个线程返回一些东西或者检查线程的进度，那么 Java Futures 就派上了用场。</p><p id="8353" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以你不用 runnable，而是使用一个 callable 对象，这个 Callable 对象返回一个 Future 对象，这个 Future 对象提供了监控一个线程正在执行的任务的进程的方法。future 对象可用于检查可调用对象的状态，然后在线程完成后从可调用对象中检索结果。它还提供超时功能。</p><pre class="kj kk kl km gt lk ll lm ln aw lo bi"><span id="048a" class="lp lq in ll b gy lr ls l lt lu">Future&lt;Long&gt; result10 = executor.submit(new CalculateService(10));  <br/><br/>//get the result using get method of the Future object<br/>//get method waits till the thread execution and then return the result of the execution.<br/>Long var10 = result10.get();</span></pre><p id="3557" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 6:停止线程的方法</strong></p><p id="cb82" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通常有三种方法可以做到这一点。</p><p id="f6af" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用 ExcecuterService 并将 Runnables 提交给它们，如果使用 Callable 和 Future，则使用 executors . shut down()<br/>或<br/>。然后就是 future.cancel(真)。<br/>或<br/>在简单线程类中有 kill()或 stop()方法，但它们已被弃用。</p><p id="9342" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是在这两种情况下，JVM 都不保证线程停止。</p><p id="483f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以你能做的是:</p><p id="63c4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用可变变量或原子变量</p><pre class="kj kk kl km gt lk ll lm ln aw lo bi"><span id="9b2f" class="lp lq in ll b gy lr ls l lt lu">public void run( ) {</span><span id="388f" class="lp lq in ll b gy ms ls l lt lu">while(keepRunning == true){</span><span id="7720" class="lp lq in ll b gy ms ls l lt lu">……..}</span><span id="9f73" class="lp lq in ll b gy ms ls l lt lu">}</span></pre><p id="d724" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是因为当 run 方法完成时，线程就会死亡。</p></div><div class="ab cl lv lw hr lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ig ih ii ij ik"><p id="73ba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这都是来自我这边的 JAVA 多线程。请随时纠正我或评论或建议我可能错过的任何新主题。</p><p id="cbb5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="li">和鼓掌欣赏我的作品</em> </strong>如果觉得有意思。<br/>你可以在:<a class="ae mt" href="https://www.linkedin.com/in/ankityadav1801/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>，<a class="ae mt" href="https://github.com/yadav-ankit" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到我。我们连线吧！🤝</p></div></div>    
</body>
</html>