<html>
<head>
<title>Problem Solving Patterns for Technical Interviews: the Frequency Counter Pattern Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">技术面试的问题解决模式:解释频率计数器模式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/problem-solving-patterns-for-technical-interviews-the-frequency-counter-pattern-explained-ac71f6a76621?source=collection_archive---------1-----------------------#2020-12-19">https://blog.devgenius.io/problem-solving-patterns-for-technical-interviews-the-frequency-counter-pattern-explained-ac71f6a76621?source=collection_archive---------1-----------------------#2020-12-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/be1bfa7a46711eb75fcce2cfd93dfd0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kq3BYOJaLWB8H3pVzNV_Lg.jpeg"/></div></div></figure><p id="cd95" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我的上一篇文章中，我分享了我对如何准备软件开发人员面试的想法。</p><p id="67d0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这篇文章中，我将稍微改变一下思路，谈谈你可以用来解决技术面试中的问题的常见模式。我们将深入讨论<em class="ku">频率计数器</em>模式，以帮助您有效地处理它。</p><h1 id="7b53" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">什么是“频率计数器”模式？</h1><p id="5a31" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">频率计数器模式使用一个对象或集合来收集值和这些值的频率。</p><p id="9393" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种模式通常与<code class="fe ly lz ma mb b">array</code>或<code class="fe ly lz ma mb b">string</code>一起使用，并允许您避免嵌套循环(二次时间复杂度<code class="fe ly lz ma mb b">O(n²)</code>)。</p><h1 id="dfbc" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">什么时候应该使用频率计数器模式？</h1><p id="cdbf" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">当您有多条数据需要相互比较时，频率计数器模式最有帮助。让我通过一个例子来看看频率计数器的作用。</p><h1 id="dafd" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">“相同平方”练习</h1><ul class=""><li id="283c" class="mc md in jx b jy lt kc lu kg me kk mf ko mg ks mh mi mj mk bi translated">编写一个名为<code class="fe ly lz ma mb b">sameSquared</code>的函数，它接受两个数组</li><li id="cb6a" class="mc md in jx b jy ml kc mm kg mn kk mo ko mp ks mh mi mj mk bi translated">如果第一个数组中的每个值在第二个数组中都有其对应的平方值，那么该函数应该返回<code class="fe ly lz ma mb b">true</code></li><li id="eeea" class="mc md in jx b jy ml kc mm kg mn kk mo ko mp ks mh mi mj mk bi translated">值的频率必须相同</li></ul><h1 id="e711" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">最佳结果是什么？</h1><p id="f09f" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">在我们的函数写好之后，我们应该期待我们的<code class="fe ly lz ma mb b">sameSquared</code>函数返回这些值。</p><p id="caf2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe ly lz ma mb b">sameSquared([1, 2, 3], [4, 1, 9]); <em class="ku">// true</em></code></p><p id="a055" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe ly lz ma mb b">sameSquared([1, 2, 3], [1, 9]); <em class="ku">// false</em></code></p><p id="cf96" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe ly lz ma mb b">sameSquared([1, 2, 1], [4, 4, 1]); <em class="ku">// false</em></code></p><p id="a67c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe ly lz ma mb b">sameSquared([2, 3, 6, 8, 8], [64, 36, 4, 9, 64]); <em class="ku">// true</em></code></p><h1 id="402f" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">入门指南</h1><p id="5080" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">首先，使用关键字<code class="fe ly lz ma mb b">function</code>，我们创建一个带有标识符<code class="fe ly lz ma mb b">sameSquared</code>的函数:</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="8490" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的函数<code class="fe ly lz ma mb b">sameSquared</code>需要两个参数，第一个数组和第二个数组。在这个例子中，我们传递这些值<code class="fe ly lz ma mb b">[1, 2, 3]</code>和<code class="fe ly lz ma mb b">[4, 1, 9]</code>。</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h1 id="370b" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">检查边缘案例</h1><p id="0f96" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">在我们的功能块内部，我们想要处理一些边缘情况。首先，我们需要检查两个参数都有真值，即<em class="ku">不是</em> <code class="fe ly lz ma mb b">null</code>、<code class="fe ly lz ma mb b">undefined</code>等等。</p><p id="b7f1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以通过使用<code class="fe ly lz ma mb b">!</code>操作符来检查错误值。如果<code class="fe ly lz ma mb b">firstArr</code>或<code class="fe ly lz ma mb b">secondArr</code>为假，我们返回<code class="fe ly lz ma mb b">false</code>。</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="0c34" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们要考虑的下一个边缘情况是确保两个数组的长度相同。如果它们不同，我们知道它们可以<em class="ku">而不是</em>包含等量的共享值。</p><p id="b27d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过检查两个参数的<code class="fe ly lz ma mb b">length</code>属性，我们可以确定它们是否相同。如果不是，我们返回<code class="fe ly lz ma mb b">false</code>。</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h1 id="4c6d" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">建立一个“字典”来避免嵌套循环</h1><p id="7b9d" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">我们需要跟踪至少一个数组中的所有值。为此，并且为了避免嵌套循环，我们可以将这些值存储在哈希表(对象)中。我就叫我的<code class="fe ly lz ma mb b">lookup</code>。</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="07e6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用一个<code class="fe ly lz ma mb b">for of</code>循环，我们遍历<code class="fe ly lz ma mb b">firstArr</code>。在<code class="fe ly lz ma mb b">for of</code>块内部，我们将密钥分配给<code class="fe ly lz ma mb b">value * value</code>的结果。</p><p id="78f0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该键/值对中的值将是一个<em class="ku">频率计数器</em>，它反映特定值在<code class="fe ly lz ma mb b">firstArr</code>中“出现”的次数。</p><p id="34f6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我们检查<code class="fe ly lz ma mb b">lookup</code>是否包含<code class="fe ly lz ma mb b">value * value</code>的条目，如果包含，我们将<code class="fe ly lz ma mb b">1</code>添加到其中。如果没有，我们将值赋给<code class="fe ly lz ma mb b">0</code>，然后加上<code class="fe ly lz ma mb b">1</code>。</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="bd8e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一旦<code class="fe ly lz ma mb b">firstArr</code>完成循环，<code class="fe ly lz ma mb b">lookup</code>应包含这些值:</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h1 id="b6dc" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">比较数组值</h1><p id="6bbc" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">既然我们已经遍历了<code class="fe ly lz ma mb b">firstArr</code>中的所有值，并将它们存储为各自的<em class="ku">平方</em>值，我们希望将这些值与<code class="fe ly lz ma mb b">secondArr</code>中的值进行比较。</p><p id="1bfb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们开始创建另一个<code class="fe ly lz ma mb b">for of</code>循环。在新的<code class="fe ly lz ma mb b">for of</code>块的第一行，我们写了一个条件语句来检查来自<code class="fe ly lz ma mb b">secondArr</code>的当前值是否是<em class="ku">而不是<code class="fe ly lz ma mb b">lookup</code>中的</em>。如果不是，我们停止循环并返回<code class="fe ly lz ma mb b">false</code>。</p><p id="6dbd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果来自<code class="fe ly lz ma mb b">secondArr</code>的值在我们的<code class="fe ly lz ma mb b">lookup</code>中，我们想要减少那个条目的值。我们可以通过使用<code class="fe ly lz ma mb b">-=</code>赋值操作符来实现。</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="0eda" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们循环完<code class="fe ly lz ma mb b">secondArr</code>之后，我们的<code class="fe ly lz ma mb b">lookup</code>应该有这些值:</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h1 id="bd48" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">结束我们的“相同平方”函数</h1><p id="a344" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">如果我们完成了对<code class="fe ly lz ma mb b">secondArr</code>的迭代而没有返回<code class="fe ly lz ma mb b">false</code>，这意味着我们的<code class="fe ly lz ma mb b">firstArr</code>包含了所有在<code class="fe ly lz ma mb b">secondArr</code>中处于平方状态的值。因此，我们在<code class="fe ly lz ma mb b">for of</code>循环之外返回<code class="fe ly lz ma mb b">true</code>。</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="edc2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我给你看另一个例子，这个例子在编码评估中非常常用(所以你可能以前见过这个问题)。</p><h1 id="bdd3" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">“伊桑格拉姆”演习</h1><ul class=""><li id="0ebf" class="mc md in jx b jy lt kc lu kg me kk mf ko mg ks mh mi mj mk bi translated">编写一个名为<code class="fe ly lz ma mb b">isAnagram</code>的函数，它接受两个字符串</li><li id="d9ca" class="mc md in jx b jy ml kc mm kg mn kk mo ko mp ks mh mi mj mk bi translated">如果两个字符串参数互为<a class="ae kt" href="https://en.wikipedia.org/wiki/Anagram" rel="noopener ugc nofollow" target="_blank">变位词</a>，则该函数应返回<code class="fe ly lz ma mb b">true</code></li></ul><h1 id="b24b" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">最佳结果是什么？</h1><p id="253f" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">在我们的函数编写完成后，我们应该期待我们的<code class="fe ly lz ma mb b">isAnagram</code>函数返回这些值。</p><p id="8e09" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe ly lz ma mb b">isAnagram(“silent”, “listen”); <em class="ku">// true</em></code></p><p id="568b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe ly lz ma mb b">isAnagram(“martin”, “nitram”); <em class="ku">// true</em></code></p><p id="9438" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe ly lz ma mb b">isAnagram(“cat”, “tag”); <em class="ku">// false</em></code></p><p id="d0df" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe ly lz ma mb b">isAnagram(“rat”, “tar”); <em class="ku">// true</em></code></p><h1 id="6779" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">入门指南</h1><p id="4ddc" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">首先，使用关键字<code class="fe ly lz ma mb b">function</code>，我们创建一个带有标识符<code class="fe ly lz ma mb b">isAnagram</code>的函数:</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="5e30" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的函数<code class="fe ly lz ma mb b">isAnagram</code>需要两个参数，第一个<code class="fe ly lz ma mb b">string</code>和第二个<code class="fe ly lz ma mb b">string</code>。在这个例子中，我们传递这些值<code class="fe ly lz ma mb b">silent</code>和<code class="fe ly lz ma mb b">listen</code>。</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h1 id="64c0" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">检查边缘案例</h1><p id="d8d7" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">在我们功能块的前几行，我们想处理一些边缘情况，就像第一个例子一样。</p><p id="9f59" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">与<code class="fe ly lz ma mb b">sameSquared</code>类似，我们需要检查两个参数都有真值，即<em class="ku">不是</em> <code class="fe ly lz ma mb b">null</code>、<code class="fe ly lz ma mb b">undefined</code>等等。我们可以使用<code class="fe ly lz ma mb b">!</code>操作符来检查错误值。如果<code class="fe ly lz ma mb b">firstStr</code>或<code class="fe ly lz ma mb b">secondStr</code>为假，我们返回<code class="fe ly lz ma mb b">false</code>。</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="528e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们要考虑的下一个边缘情况是确保两个数组的长度相同。如果它们不同，我们知道它们可以包含相同数量的共享值。</p><p id="949f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过检查两个参数的<code class="fe ly lz ma mb b">length</code>属性，我们可以确定它们是否相同。如果不是，我们返回<code class="fe ly lz ma mb b">false</code></p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h1 id="57db" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">建立一个“字典”来避免嵌套循环</h1><p id="6f4a" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">记住，我们使用的是频率计数器模式，我们需要跟踪至少一个数组中的所有值。现在我们知道处理这个问题的最好方法是将这些值存储在一个哈希表(对象)中。为了保持一致，我将再次调用我的<code class="fe ly lz ma mb b">lookup</code>。</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="771d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用一个<code class="fe ly lz ma mb b">for of</code>循环，我们遍历<code class="fe ly lz ma mb b">firstStr</code>。在<code class="fe ly lz ma mb b">for of</code>块内部，我们将密钥分配给表达式<code class="fe ly lz ma mb b">value * value</code>的结果。</p><p id="2ba6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该键/值对中的值将是一个<em class="ku">频率计数器</em>，它反映特定值在<code class="fe ly lz ma mb b">firstStr</code>中“出现”的次数。</p><p id="9a10" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用三元运算符，我们检查<code class="fe ly lz ma mb b">lookup</code>是否包含<code class="fe ly lz ma mb b">value * value</code>的条目，如果包含，我们使用<code class="fe ly lz ma mb b">+=</code>赋值运算符将值增加<code class="fe ly lz ma mb b">1</code>。如果没有，我们只需将值赋给<code class="fe ly lz ma mb b">1</code>。</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="92d2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一旦<code class="fe ly lz ma mb b">firstStr</code>完成循环，<code class="fe ly lz ma mb b">lookup</code>应包含这些值:</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h1 id="76ee" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">比较数组值</h1><p id="a607" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">既然我们已经遍历了<code class="fe ly lz ma mb b">firstStr</code>中的所有值并存储了它们的值，我们希望将这些值与<code class="fe ly lz ma mb b">secondStr</code>中的值进行比较。</p><p id="7fd3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们从创建另一个<code class="fe ly lz ma mb b">for of</code>循环开始。在我们新的<code class="fe ly lz ma mb b">for of</code>块中的第一行，我们写了一个条件语句来检查来自<code class="fe ly lz ma mb b">secondStr</code>的当前值是否是<em class="ku">而不是<code class="fe ly lz ma mb b">lookup</code>中的</em>。如果不是，我们要停止迭代，返回<code class="fe ly lz ma mb b">false</code>。</p><p id="ec5e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">否则，如果来自<code class="fe ly lz ma mb b">secondStr</code> <em class="ku">的值是我们的<code class="fe ly lz ma mb b">lookup</code>中的</em>，我们想要减少那个条目的值。我们可以通过使用<code class="fe ly lz ma mb b">-=</code>赋值操作符来实现。</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="55cf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们循环完<code class="fe ly lz ma mb b">secondStr</code>之后，我们的<code class="fe ly lz ma mb b">lookup</code>应该有这些值:</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h1 id="d63f" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">结束我们的“isAnagram”函数</h1><p id="0221" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">如果我们完成了对<code class="fe ly lz ma mb b">secondStr</code>的迭代而没有返回<code class="fe ly lz ma mb b">false</code>，这意味着我们的<code class="fe ly lz ma mb b">firstStr</code>包含了<code class="fe ly lz ma mb b">secondStr</code>中的所有值；因此，我们在<code class="fe ly lz ma mb b">for of</code>循环之外返回<code class="fe ly lz ma mb b">true</code>。</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h1 id="e423" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">概括起来</h1><p id="f1ec" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">我希望这个关于频率计数器模式的深入概述对您有所帮助。既然你已经知道了这种模式是如何运作的，我相信你能够通过在更高层次上展示你的技能来给你的面试官留下深刻印象。</p><p id="37a3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我的下一篇文章中，我将讨论另一种常见的问题解决模式，称为滑动窗口。感谢阅读，祝面试愉快！</p></div></div>    
</body>
</html>