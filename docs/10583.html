<html>
<head>
<title>Matching Parentheses v1.0</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">匹配括号 1.0 版</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/matching-parentheses-cb03bb3d7f8d?source=collection_archive---------6-----------------------#2022-11-13">https://blog.devgenius.io/matching-parentheses-cb03bb3d7f8d?source=collection_archive---------6-----------------------#2022-11-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="40e3" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">用通配符匹配左括号和右括号</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/3da964c591065632809b27cbd0082114.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x8XthL8CzwX_LZ2B8mxDyQ.png"/></div></div></figure><h1 id="d051" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">问题陈述</h1><p id="393c" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">给定一个只包含三种类型字符的字符串<code class="fe mc md me mf b">s</code>:<code class="fe mc md me mf b">'('</code>、<code class="fe mc md me mf b">')'</code>和<code class="fe mc md me mf b">'*'</code>，如果<code class="fe mc md me mf b">s</code>有效，则返回<code class="fe mc md me mf b">true</code>。</p><h2 id="d5ca" class="mg kp in bd kq mh mi dn ku mj mk dp ky lp ml mm la lt mn mo lc lx mp mq le mr bi translated">情况</h2><ol class=""><li id="7386" class="ms mt in li b lj lk lm ln lp mu lt mv lx mw mb mx my mz na bi translated">任何左括号<code class="fe mc md me mf b">'('</code>都必须有相应的右括号<code class="fe mc md me mf b">')'</code>。</li><li id="e4d7" class="ms mt in li b lj nb lm nc lp nd lt ne lx nf mb mx my mz na bi translated">任何右括号<code class="fe mc md me mf b">')'</code>都必须有相应的左括号<code class="fe mc md me mf b">'('</code>。</li><li id="7249" class="ms mt in li b lj nb lm nc lp nd lt ne lx nf mb mx my mz na bi translated">左括号<code class="fe mc md me mf b">'('</code>必须在相应的右括号<code class="fe mc md me mf b">')'</code>之前。</li><li id="06f3" class="ms mt in li b lj nb lm nc lp nd lt ne lx nf mb mx my mz na bi translated"><code class="fe mc md me mf b">'*'</code>可被视为单个右括号<code class="fe mc md me mf b">')'</code>或单个左括号<code class="fe mc md me mf b">'('</code>或空字符串<code class="fe mc md me mf b">""</code>。</li></ol><h1 id="8bec" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">解决办法</h1><p id="ceab" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">这里我们推导出了一个两相解。</p><h2 id="7eff" class="mg kp in bd kq mh mi dn ku mj mk dp ky lp ml mm la lt mn mo lc lx mp mq le mr bi translated">第一阶段</h2><p id="1158" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">我们将用所需的括号替换星号。</p><ul class=""><li id="6a11" class="ms mt in li b lj ng lm nh lp ni lt nj lx nk mb nl my mz na bi translated">为了实现这一点，如果<code class="fe mc md me mf b">)</code>括号的计数大于另一个，我们将用<code class="fe mc md me mf b">(</code>替换<code class="fe mc md me mf b">*</code>。</li><li id="1d96" class="ms mt in li b lj nb lm nc lp nd lt ne lx nf mb nl my mz na bi translated">否则我们就用<code class="fe mc md me mf b">(</code>代替。</li><li id="0955" class="ms mt in li b lj nb lm nc lp nd lt ne lx nf mb nl my mz na bi translated">如果左括号和右括号的数量相等，则用空字符串<code class="fe mc md me mf b">""</code>替换<code class="fe mc md me mf b">*</code>。</li></ul><h2 id="ad5e" class="mg kp in bd kq mh mi dn ku mj mk dp ky lp ml mm la lt mn mo lc lx mp mq le mr bi translated">第二期</h2><p id="1b25" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">更换星号<code class="fe mc md me mf b">*</code>后，我们将使用 stack 检查配对支架。如果在分析完字符串中的所有字符后，堆栈为空，则认为它是一个有效的字符串。</p><h1 id="72f3" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">密码</h1><blockquote class="nm nn no"><p id="93a5" class="lg lh np li b lj ng jo ll lm nh jr lo nq nr lr ls ns nt lv lw nu nv lz ma mb ig bi translated">注意:<em class="in">我们使用了堆栈数据结构，这超出了本文的范围。</em> <a class="ae nw" href="https://medium.com/@s.gaur/stack-in-golang-a4b4ee21c606" rel="noopener"> <em class="in">查看本文</em> </a> <em class="in">以了解 golang 中堆栈实现的概况。</em></p></blockquote><pre class="kd ke kf kg gt nx mf ny bn nz oa bi"><span id="43e2" class="ob kp in mf b be oc od l oe of">/*<br/> * Q.Given a string s containing only three types of characters: <br/> *   '(', ')' and '*', return true if s is valid.<br/> *   The following rules define a valid string:<br/> * - Any left parenthesis '(' must have a corresponding right parenthesis ')'.<br/> * - Any right parenthesis ')' must have a corresponding left parenthesis '('.<br/> * - Left parenthesis '(' must go before the corresponding right parenthesis ')'.<br/> * - '*' could be treated as a single right parenthesis ')' <br/> *   or a single left parenthesis '(' <br/> *   or an empty string "".<br/> */<br/><br/>package array<br/><br/>import (<br/>    ds "dsa/datastructures"<br/>    "fmt"<br/>)</span></pre><h2 id="39e5" class="mg kp in bd kq mh mi dn ku mj mk dp ky lp ml mm la lt mn mo lc lx mp mq le mr bi translated">递归函数</h2><p id="5b54" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">所提供的解决方案的两个阶段都适用于此功能</p><pre class="kd ke kf kg gt nx mf ny bn nz oa bi"><span id="5374" class="ob kp in mf b be oc od l oe of">func getStarReplacedString(closingBracketCount, openingBracketCount, countStar int, front, raw string) (int, int, string) {<br/>    if len(raw) == 0 {<br/>        return closingBracketCount, openingBracketCount, raw<br/>    }<br/>    head := string(raw[0])<br/>    // Phase-I<br/>    if head == "(" {<br/>        openingBracketCount++<br/>    } else if head == ")" {<br/>        closingBracketCount++<br/>    } else {<br/>        countStar++<br/>    }<br/>    // fmt.Printf("%2v %2v %2v %v %v\n", closingBracketCount, openingBracketCount, countStar, head, b)<br/>    // Recursive Call<br/>    closingBracketCount, openingBracketCount, processed := getStarReplacedString(closingBracketCount, openingBracketCount, countStar, head, raw[1:])<br/>    // Phase-II<br/>    if closingBracketCount &gt; openingBracketCount &amp;&amp; head == "*" &amp;&amp; countStar &gt; 0 {<br/>        processed = "(" + processed<br/>    } else if closingBracketCount &lt; openingBracketCount &amp;&amp; head == "*" &amp;&amp; countStar &gt; 0 {<br/>        processed = ")" + processed<br/>    } else if closingBracketCount == openingBracketCount &amp;&amp; head == "*" &amp;&amp; countStar &gt; 0 {<br/>        processed = "" + processed<br/>    } else {<br/>        processed = head + processed<br/>    }<br/>    // fmt.Printf("%2v %2v %2v %v %v\n", closingBracketCount, openingBracketCount, countStar, head, b)<br/>    return closingBracketCount, openingBracketCount, processed<br/>}</span></pre><h1 id="1d65" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">主要的</h1><p id="a61b" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">函数来验证所提供的解决方案</p><pre class="kd ke kf kg gt nx mf ny bn nz oa bi"><span id="895d" class="ob kp in mf b be oc od l oe of">func RunCheckMatchingBrackets() {<br/>    input := []string{<br/>        "()()()()()()()()()()(*))", // valid<br/>        "(*))()()()()()()()()()()", // valid<br/>        "(((*)))",                  // valid<br/>        "()())*",                   // invalid<br/>        "()*)",                     // valid<br/>        "(((*)",                    // invalid<br/>    }<br/>    <br/>    for index := 0; index &lt; len(input); index++ {<br/>        // Replace * with required (, ) or ""<br/>        _, _, final := getStarReplacedString(0, 0, 0, "", input[index])<br/>        // Received the final processed string<br/>        fmt.Println("Processed String:", final)<br/>        if len(final)%2 != 0 {<br/>            fmt.Println("Ans: Is odd and invalid")<br/>        } else {<br/>            stack := ds.InitStack("")<br/>            for i := 0; i &lt; len(final); i++ {<br/>                val := string(final[i])<br/>                // fmt.Println("stack: ", i, stack.Top())<br/>                if stack.Top() == "(" &amp;&amp; val == ")" {<br/>                    stack.Pop()<br/>                } else {<br/>                    stack.Push(val)<br/>                }<br/>            }<br/>            // fmt.Println(stack.GetStack())<br/>            if stack.IsEmpty() {<br/>                fmt.Println("Ans: Is even and valid")<br/>            } else {<br/>                fmt.Println("Ans: Is even and invalid")<br/>            }<br/>        }<br/>        fmt.Println()<br/>    }<br/>}<br/><br/>/* Output<br/>Processed String: ()()()()()()()()()()(())<br/>Ans: Is even and valid<br/><br/>Processed String: (())()()()()()()()()()()<br/>Ans: Is even and valid<br/><br/>Processed String: ((()))<br/>Ans: Is even and valid<br/><br/>Processed String: ()())(<br/>Ans: Is even and invalid<br/><br/>Processed String: ()()<br/>Ans: Is even and valid<br/><br/>Processed String: ((())<br/>Ans: Is odd and invalid<br/>*/</span></pre><p id="adb1" class="pw-post-body-paragraph lg lh in li b lj ng jo ll lm nh jr lo lp nr lr ls lt nt lv lw lx nv lz ma mb ig bi translated">我希望这篇文章能为 golang 的上述问题提供一个有效的解决方案。如有错误或进一步建议，请在下方评论。谢谢！</p><blockquote class="nm nn no"><p id="3bb9" class="lg lh np li b lj ng jo ll lm nh jr lo nq nr lr ls ns nt lv lw nu nv lz ma mb ig bi translated"><strong class="li io"> <em class="in">更新 1.0: </em> </strong> <em class="in">感谢@ </em> <a class="ae nw" href="https://medium.com/@esequiel?source=list-4210785b3218---------------f93998f8b1af---------------------" rel="noopener"> Esequiel 阿尔博诺兹</a> <em class="in">的投稿。</em> <em class="in">上述解决方案已经由@ </em> <a class="ae nw" href="https://medium.com/@esequiel?source=list-4210785b3218---------------f93998f8b1af---------------------" rel="noopener"> Esequiel 阿尔博诺兹</a> <em class="in">使用两栈方法进行了优化。<br/>旧代码可以在</em><a class="ae nw" href="https://github.com/shubham-gaur/DSA-Golang/blob/9363da81d1f84d78a81f704803a3c2ab603a7590/problems/array/matchingbrackets.go" rel="noopener ugc nofollow" target="_blank"><em class="in">github</em></a><em class="in">找到。<br/> </em> —当新博客准备好优化代码时，将更新此处的链接。</p></blockquote></div></div>    
</body>
</html>