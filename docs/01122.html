<html>
<head>
<title>Solving Common Vue Problems — Images, Calling Child Methods, and More</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解决常见的 Vue 问题——图像、调用子方法等等</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/solving-common-vue-problems-images-calling-child-methods-and-more-dc3044d9778d?source=collection_archive---------33-----------------------#2020-06-24">https://blog.devgenius.io/solving-common-vue-problems-images-calling-child-methods-and-more-dc3044d9778d?source=collection_archive---------33-----------------------#2020-06-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b4c6e3474fa67045db456f51182f0cfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bQ7GME3T-74YgSLR"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">约翰·托尔卡西奥在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="fc6b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Vue.js 让开发前端应用变得简单。然而，我们仍有可能遇到问题。</p><p id="0df2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将看看一些常见的问题，并看看如何解决它们。</p><h1 id="1bb8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">动态图像不起作用</h1><p id="ea51" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们添加一个带有<code class="fe me mf mg mh b">require</code>的图像，那么我们可以让它们用一种方法工作:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="027c" class="mq lc iq mh b gy mr ms l mt mu">getImgUrl(pic) {<br/>  return require(`../assets/${pic}`)<br/>}</span></pre><p id="593e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以通过编写以下内容在模板中使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6a39" class="mq lc iq mh b gy mr ms l mt mu">&lt;img :src="getImgUrl(pic)" :alt="pic"&gt;</span></pre><p id="5ea0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在<code class="fe me mf mg mh b">getImgUrl</code>方法中返回我们想要的图像，然后将返回的对象直接传递给<code class="fe me mf mg mh b">src</code>的值。</p><h1 id="3b5c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">避免直接变异道具</h1><p id="79ca" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们千万不要直接变异道具。</p><p id="2805" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一种反模式，因为属性是在对属性的本地更改被覆盖后呈现的。</p><p id="12e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，如果我们有道具，那么我们要么为它们设置一个默认值。</p><p id="3c75" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者我们可以使用一个计算的属性从 props 中创建新的值。</p><p id="08b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c083" class="mq lc iq mh b gy mr ms l mt mu">Vue.component('task', {<br/>  template: '#template',<br/>  props: ['list'],<br/>  data() {<br/>    return {<br/>        mutableList: Object.assign({}, this.list);<br/>    }<br/>  }<br/>});</span></pre><p id="5065" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="13d7" class="mq lc iq mh b gy mr ms l mt mu">Vue.component('task', {<br/>  template: '#template',<br/>  props: ['list'],<br/>  computed: {<br/>    newList(){<br/>      return this.list;<br/>    }<br/>  }<br/>});</span></pre><p id="2a9f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第一个例子中，我们用<code class="fe me mf mg mh b">Object.assign({}, this.list);</code>复制了一个<code class="fe me mf mg mh b">list</code>属性值。</p><p id="07fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第二个示例中，我们用以下内容创建了一个计算属性<code class="fe me mf mg mh b">newList</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2fb6" class="mq lc iq mh b gy mr ms l mt mu">computed: {<br/>  newList(){<br/>    return this.list;<br/>  }<br/>}</span></pre><h1 id="3ed9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">从异步 Vuex 操作返回承诺</h1><p id="9e66" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">动作是异步的。因此，我们可以在其中回报承诺。</p><p id="4489" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c47b" class="mq lc iq mh b gy mr ms l mt mu">actions: {<br/>  async getData(context, data) {<br/>    const res = await fetch("/api/something")<br/>    const json = await res.json();<br/>    return json;<br/>  }<br/>}</span></pre><p id="7231" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们返回了 Fetch API 返回的获取数据的承诺。</p><p id="bbb3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以通过编写下面的代码在组件中分派带有<code class="fe me mf mg mh b">this.store.$dispatch</code>的动作:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="25f1" class="mq lc iq mh b gy mr ms l mt mu">async mounted() {<br/>  try {<br/>    const data = await this.$store.dispatch("getData")<br/>  } catch (ex) {<br/>    console.log(ex);<br/>  }<br/>}</span></pre><h1 id="9b8a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">检测元素外部的单击</h1><p id="bfce" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过创建自己的指令来检测元素外部的点击。</p><p id="ebfb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="76c4" class="mq lc iq mh b gy mr ms l mt mu">Vue.directive('click-outside', {<br/>  bind () {<br/>    this.event = event =&gt; this.vm.$emit(this.expression, event)<br/>    this.el.addEventListener('click', this.stopProp)<br/>    document.body.addEventListener('click', this.event)<br/>  },   <br/>  unbind() {<br/>    this.el.removeEventListener('click', this.stopProp)<br/>    document.body.removeEventListener('click', this.event)<br/>  },</span><span id="71ef" class="mq lc iq mh b gy mv ms l mt mu">  stopProp(event) { event.stopPropagation() }<br/>})</span></pre><p id="a9ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当元素被点击时，我们调用<code class="fe me mf mg mh b">stopPropgation</code>来阻止点击事件传播到父元素。</p><p id="5a82" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是在<code class="fe me mf mg mh b">bind</code>方法中所做的。</p><p id="db51" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们解除指令的绑定时，我们删除所有的监听器来停止事件的比例。</p><p id="513a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过写来使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="77a9" class="mq lc iq mh b gy mr ms l mt mu">&lt;div v-click-outside="doSomething"&gt;<br/>  ...<br/>&lt;/div</span></pre><p id="e656" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们在元素外单击时，我们使用我们的指令来运行<code class="fe me mf mg mh b">doSomething</code>。</p><h1 id="0524" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用 Axios 设置数据</h1><p id="7bb2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">要用 Axios 设置数据，我们必须确保我们的<code class="fe me mf mg mh b">then</code>回调是一个箭头函数。</p><p id="6c55" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f96d" class="mq lc iq mh b gy mr ms l mt mu">mounted() {<br/>  axios.get('api/url')<br/>    .then((response) =&gt; {<br/>      this.data = response.data;<br/>    });<br/>}</span></pre><p id="c15b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们使用常规函数，那么<code class="fe me mf mg mh b">this</code>的值就是函数本身。</p><p id="2a04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以不能用常规函数做回调。</p><p id="761d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者，我们可以通过编写以下代码来使用 async/await 语法:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9f10" class="mq lc iq mh b gy mr ms l mt mu">async mounted() {<br/>  consr res = await axios.get('api/url')<br/>  this.data = res.data;<br/>}</span></pre><h1 id="054d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">观察嵌套数据</h1><p id="e937" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用几种方法来观察嵌套数据。</p><p id="350c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过编写以下代码来添加嵌套属性的观察器:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="dd2f" class="mq lc iq mh b gy mr ms l mt mu">watch:{<br/>  'item.prop1'(newVal){<br/>     //...<br/>  },<br/>  'item.prop2'(newVal){<br/>     //...<br/>  }<br/>}</span></pre><p id="4698" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用两个将属性路径作为键的观察器来观察<code class="fe me mf mg mh b">item.prop1</code>和<code class="fe me mf mg mh b">item.prop2</code>。</p><p id="4d53" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以将<code class="fe me mf mg mh b">deep</code>属性设置为<code class="fe me mf mg mh b">true</code>来观察它的值。</p><p id="807e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e8dc" class="mq lc iq mh b gy mr ms l mt mu">watch: {<br/>  item: {<br/>     handler(val){<br/>       // ...<br/>     },<br/>     deep: true<br/>  }<br/>}</span></pre><p id="d980" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，由于<code class="fe me mf mg mh b">deep</code>被设置为<code class="fe me mf mg mh b">true</code>，所有嵌套的属性被观察。</p><p id="5543" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当<code class="fe me mf mg mh b">item</code>的任何嵌套属性改变时<code class="fe me mf mg mh b">handler</code>将运行。</p><h1 id="17cb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在组件外部调用 Vue 组件方法</h1><p id="2474" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">要在组件外部调用 Vue 组件方法，我们可以在组件上设置一个 ref，然后通过访问 ref 来调用该方法。</p><p id="654f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有一个名为<code class="fe me mf mg mh b">Foo</code>的组件，我们可以这样写来设置它的引用:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="003b" class="mq lc iq mh b gy mr ms l mt mu">&lt;Foo ref="foo"&gt;&lt;/Foo&gt;</span></pre><p id="510f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="572f" class="mq lc iq mh b gy mr ms l mt mu">this.$refs.foo.doSomething(); </span></pre><p id="e7da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe me mf mg mh b">Foo</code>组件有<code class="fe me mf mg mh b">doSomething</code>方法。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/bc18d6d0b105b8268267c5da99e1e678.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aX6nzrqI8iyw4Enr"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">简·梅乌斯在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="9c1f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="3a00" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该避免直接改变属性值。</p><p id="c868" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们的值将在下次渲染时被覆盖。</p><p id="118a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以通过阻止点击事件向父节点的传播来检测来自外部的点击。</p><p id="6f80" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以从带有引用的组件中调用子组件的方法。</p></div></div>    
</body>
</html>