<html>
<head>
<title>Best of Modern JavaScript — Yield</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代JavaScript的精华— Yield</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/best-of-modern-javascript-yield-6c6886ebf84f?source=collection_archive---------2-----------------------#2020-11-04">https://blog.devgenius.io/best-of-modern-javascript-yield-6c6886ebf84f?source=collection_archive---------2-----------------------#2020-11-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3a148bda5289db0a9b5914ee15e56fcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_EDRGPznHycncrPI"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">马库斯·斯皮斯克在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="aba7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自2015年以来，JavaScript有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究JavaScript生成器。</p><h1 id="4f76" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">yield关键字</h1><p id="562d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">yield</code>关键字只能在生成器函数中使用。</p><p id="f6e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="25bc" class="mq lc iq mh b gy mr ms l mt mu">function* genFn() {<br/>  yield 'foo';<br/>  yield 'bar';<br/>  return 'baz';<br/>}</span></pre><p id="fba7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我们不能写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="512f" class="mq lc iq mh b gy mr ms l mt mu">function* genFn() {<br/>  ['foo', 'bar'].forEach(x =&gt; yield x);<br/>}</span></pre><p id="a3e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们会得到一个语法错误。</p><h1 id="84fa" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用<code class="fe me mf mg mh b">yield*</code>递归</h1><p id="7d9c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">yield*</code>关键字让我们在一个生成器函数中调用另一个生成器函数。</p><p id="3745" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="723e" class="mq lc iq mh b gy mr ms l mt mu">function* genFn() {<br/>  yield 'foo';<br/>  yield 'bar';<br/>  yield 'baz';<br/>}</span><span id="556e" class="mq lc iq mh b gy mv ms l mt mu">function* bar() {<br/>  yield 'x';<br/>  yield* genFn();<br/>  yield 'y';<br/>}</span><span id="a981" class="mq lc iq mh b gy mv ms l mt mu">const gen = bar()</span></pre><p id="d3ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe me mf mg mh b">bar</code>生成器函数中调用<code class="fe me mf mg mh b">genFn</code>生成器函数。</p><p id="d141" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以如果我们通过书写来使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f13a" class="mq lc iq mh b gy mr ms l mt mu">const arr = [...gen];</span></pre><p id="346a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe me mf mg mh b">arr</code>就是<code class="fe me mf mg mh b">[“x”, “foo”, “bar”, “baz”, “y”]</code>。</p><p id="e208" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">调用<code class="fe me mf mg mh b">genFn</code>返回一个对象，但是它不运行<code class="fe me mf mg mh b">genFn</code>。</p><p id="6f74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">yield*</code>关键字运行生成器函数，当它的项目被产出的时候。</p><h1 id="dc98" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe me mf mg mh b">yield*</code>考虑迭代结束值</h1><p id="1970" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">yield*</code>忽略<code class="fe me mf mg mh b">return</code>值。</p><p id="8985" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a30f" class="mq lc iq mh b gy mr ms l mt mu">function* genFn() {<br/>  yield 'foo';<br/>  yield 'bar';<br/>  return 'baz';<br/>}</span><span id="1334" class="mq lc iq mh b gy mv ms l mt mu">function* bar() {<br/>  yield 'x';<br/>  yield* genFn();<br/>  yield 'y';<br/>}</span><span id="cfe2" class="mq lc iq mh b gy mv ms l mt mu">const gen = bar()<br/>const arr = [...gen];</span></pre><p id="77a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe me mf mg mh b">arr</code>就是<code class="fe me mf mg mh b">[“x”, “foo”, “bar”, “y”]</code>，<code class="fe me mf mg mh b">yield*</code>被跳过<code class="fe me mf mg mh b">'baz'</code>，因为它被返回而不是产出。</p><p id="4990" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">yield*</code>递归调用生成器函数。</p><p id="7f67" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以很容易地用它从树结构中返回项目。</p><p id="39dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以创建一个具有不同分支节点的<code class="fe me mf mg mh b">Tree</code>类:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="de07" class="mq lc iq mh b gy mr ms l mt mu">class Tree {<br/>  constructor(value, left = null, center = null, right = null) {<br/>    this.value = value;<br/>    this.left = left;<br/>    this.center = center;<br/>    this.right = right;<br/>  }</span><span id="5d78" class="mq lc iq mh b gy mv ms l mt mu">  *[Symbol.iterator]() {<br/>    yield this.value;<br/>    if (this.left) {<br/>      yield* this.left;<br/>    }</span><span id="6e10" class="mq lc iq mh b gy mv ms l mt mu">    if (this.center) {<br/>      yield* this.center;<br/>    }</span><span id="be91" class="mq lc iq mh b gy mv ms l mt mu">    if (this.right) {<br/>      yield* this.right;<br/>    }<br/>  }<br/>}</span></pre><p id="b503" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">left</code>、<code class="fe me mf mg mh b">center</code>和<code class="fe me mf mg mh b">right</code>都是从<code class="fe me mf mg mh b">Tree</code>类创建的生成器函数。</p><p id="8031" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="91c3" class="mq lc iq mh b gy mr ms l mt mu">const tree = new Tree('a',<br/>  new Tree('b',<br/>    new Tree('c'),<br/>    new Tree('d'),<br/>    new Tree('e')),<br/>  new Tree('f'));</span><span id="fabb" class="mq lc iq mh b gy mv ms l mt mu">for (const x of tree) {<br/>  console.log(x);<br/>}</span></pre><p id="2117" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到了:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f1ec" class="mq lc iq mh b gy mr ms l mt mu">a<br/>b<br/>c<br/>d<br/>e<br/>f</span></pre><p id="4f59" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">value</code>是树节点本身的值。</p><p id="bade" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe me mf mg mh b">Tree</code>构造函数填充节点。</p><h1 id="5e78" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">发电机作为观察员</h1><p id="f20e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">生成器也可以是数据观察者。</p><p id="d085" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用它来通过<code class="fe me mf mg mh b">next</code>方法发送值。</p><p id="d9bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">next</code>方法保持从then生成器返回值，直到值用完。</p><p id="f8d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="bd34" class="mq lc iq mh b gy mr ms l mt mu">function* genFn() {<br/>  yield 'foo';<br/>  yield 'bar';<br/>  return 'baz';<br/>}</span><span id="9b32" class="mq lc iq mh b gy mv ms l mt mu">const gen = genFn();<br/>console.log(gen.next());</span></pre><p id="8095" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到了:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1578" class="mq lc iq mh b gy mr ms l mt mu">{value: "foo", done: false}</span></pre><p id="5582" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以使用一个参数调用<code class="fe me mf mg mh b">next</code>来返回生成器生成的内容的索引。</p><p id="ffd4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="91ff" class="mq lc iq mh b gy mr ms l mt mu">function* genFn() {<br/>  console.log(yield);<br/>  console.log(yield);<br/>  console.log(yield);  <br/>}</span><span id="fb7b" class="mq lc iq mh b gy mv ms l mt mu">const gen = genFn();<br/>console.log(gen.next('a'));<br/>console.log(gen.next('b'));<br/>console.log(gen.next('c'));</span></pre><p id="0e30" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<code class="fe me mf mg mh b">yield</code>关键字从传递给<code class="fe me mf mg mh b">next</code>的参数中获取值。</p><p id="40b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从<code class="fe me mf mg mh b">next</code>方法返回的值是:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7156" class="mq lc iq mh b gy mr ms l mt mu">{value: undefined, done: false}</span></pre><p id="ed8c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">value</code>是<code class="fe me mf mg mh b">undefined</code>而<code class="fe me mf mg mh b">done</code>是<code class="fe me mf mg mh b">false</code>。</p><p id="53ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">yield</code>没有操作数的关键字从<code class="fe me mf mg mh b">next</code>方法中获取值。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/29c371435b01f98e7187f38e824ea750.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*G5SW87argclQ5tzJ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">马库斯·斯皮斯克在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="b72a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="8f29" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">yield</code>和<code class="fe me mf mg mh b">yield*</code>关键字有很多用途。</p><p id="2333" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">yield</code>可以返回值，也可以从<code class="fe me mf mg mh b">next</code>方法中获取这些值。</p></div></div>    
</body>
</html>