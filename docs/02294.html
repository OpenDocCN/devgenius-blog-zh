<html>
<head>
<title>Kubernetes POD Concepts Simplified</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes POD 概念简化</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/kubernetes-pod-concepts-simplified-637f418835a7?source=collection_archive---------8-----------------------#2020-07-27">https://blog.devgenius.io/kubernetes-pod-concepts-simplified-637f418835a7?source=collection_archive---------8-----------------------#2020-07-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/30ae53fb6f941cfc7fd876083ce79dcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vwnOm2BDgwwrGkJ8"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@xps?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> XPS </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="c214" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看完这篇帖子，你会对使用 kubernetes PODS 的优势有一个清晰的认识。</p><p id="f8b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们开始了解 pod 之前，让我们假设已经设置了以下内容:</p><ul class=""><li id="7c05" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">该应用程序已经开发并内置到 Docker Images 中，可以在 Docker hub 等 Docker 存储库中获得，因此 kubernetes 可以将其下载。</li><li id="42f9" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">Kubernetes 集群已经设置好并正在运行，它可以是单节点设置或多节点设置，</li><li id="855b" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">所有服务都需要处于运行状态。</li></ul><p id="fb9a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如在<a class="ae kc" href="https://medium.com/dev-genius/the-kubernetes-cluster-architecture-simplified-3c4a5fb41449" rel="noopener"> kubernetes 架构文章</a>中所讨论的，我们的最终目标是在一组机器上以容器的形式部署我们的应用程序，这些机器被配置为集群中的工作节点。</p><p id="d8fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，kubernetes 并不直接在 worker 节点上部署容器。</p><p id="0456" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些容器被封装到一个名为<strong class="kf ir"> PODs </strong>的 Kubernetes 对象中。一个<strong class="kf ir"> POD </strong>是一个应用程序的单个实例。</p><blockquote class="lp lq lr"><p id="96ad" class="kd ke ls kf b kg kh ki kj kk kl km kn lt kp kq kr lu kt ku kv lv kx ky kz la ij bi translated"><strong class="kf ir">POD 是可以在 kubernetes 中创建的最小对象。</strong></p></blockquote><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lw"><img src="../Images/f404c9ac1dbf0418e11d807d67070685.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kuLjnCU_zoBZraq_kYo4wA.jpeg"/></div></div></figure><h1 id="c14a" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">例子</h1><p id="0743" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">举一个最简单的例子来说明，您有一个单节点 kubernetes 集群，您的应用程序的一个实例运行在一个封装在 POD 中的 docker 容器中:</p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/331470d9185566b30c84ea04ce319630.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HiomwKuQElx0OBuwd_zZsA.jpeg"/></div></div></figure><p id="a3e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">如果访问您的应用程序的用户数量增加，并且您需要扩展您的应用程序，该怎么办？</strong></p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/5de711ba7fb3871541ee5fff2f0de751.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*phBHY0xNwII3b96i7b7aaQ.jpeg"/></div></div></figure><p id="ae1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您需要添加额外的 web 应用程序实例来分担负载。</p><p id="974f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，您会在哪里增加额外的实例？</p><p id="a9a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们是否在同一个 POD 中启动一个新的容器实例？</p><p id="a3e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">号</strong></p><p id="7e72" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用同一个应用程序的新实例创建了一个新的 POD。</p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/3cdd655d1cfd65d0a9fa965e213ea039.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JClz8Ohlb9j92lhGb7qaww.jpeg"/></div></div></figure><p id="9b53" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们有两个 web 应用程序实例运行在同一个 kubernetes 系统或节点上的不同 pod 上。</p><p id="5b13" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">如果用户基数进一步增加，而你目前的节点没有足够的容量怎么办？</strong></p><p id="43a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，您可以在集群中的新节点上部署额外的 pod。</p><p id="d894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您将有一个新节点添加到集群中，以扩展集群的物理容量。</p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/6a5501266ff45a3af2f183ca38afb72f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZvmuavX5dG-95L88ZBOSgg.jpeg"/></div></div></figure><p id="66b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我想说明的是<strong class="kf ir"> PODs 通常与运行你的应用</strong>的容器有一对一的关系。</p><ul class=""><li id="8925" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">要扩大规模，您需要创建新的单元</li><li id="e51e" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">若要缩小，请删除现有的窗格。</li></ul><blockquote class="lp lq lr"><p id="d80c" class="kd ke ls kf b kg kh ki kj kk kl km kn lt kp kq kr lu kt ku kv lv kx ky kz la ij bi translated"><strong class="kf ir">您不需要向现有的 pod 添加额外的容器来扩展您的应用程序。</strong></p></blockquote><p id="0751" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将在以后的文章中讨论如何在容器之间实现负载平衡。目前，我们只是试图理解基本概念。</p><h2 id="a1a0" class="ni mc iq bd md nj nk dn mh nl nm dp ml ko nn no mp ks np nq mt kw nr ns mx nt bi translated">我们是否被限制在一个容器里有一个容器？</h2><p id="05dc" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">号码</p><p id="aa22" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个 pod 可以有多个容器，除非它们通常不是同一种类的多个容器。</p><p id="f662" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们之前讨论的，如果我们的目的是扩展我们的应用程序，那么我们需要创建额外的 pod。</p><p id="be56" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但有时您可能会有一个场景，您有一个助手容器，它可能为我们的 web 应用程序执行某种支持任务，例如:</p><ul class=""><li id="dfd3" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">处理用户输入的数据</li><li id="279d" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">处理用户上传的文件</li></ul><p id="5eb9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您还希望这些助手容器与您的应用程序容器共存。</p><p id="45da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，您可以让这两个容器成为同一个 pod 的一部分，以便在创建新的应用程序容器时。帮助者也被创造出来，当它死去的时候，帮助者也死了。</p><p id="364d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为它们是同一个 POD 的一部分。这两个容器还可以通过将彼此称为“本地主机”来直接相互通信，因为它们共享相同的网络名称空间。</p><p id="5c01" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，它们还可以轻松共享同一个储物空间。</p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/4374b1ade10ed4f388681cc339071514.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q1J4nOlbhvtA9_oX13RDnQ.jpeg"/></div></div></figure></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><p id="9621" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们暂时将 kubernetes 排除在我们的讨论之外，讨论一下简单的 docker 容器。</p><p id="62b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们假设我们正在开发一个流程或脚本来在 docker 主机上部署我们的应用程序。然后，我们将首先使用以下命令简单地部署我们的应用程序:</p><pre class="lx ly lz ma gt oc od oe of aw og bi"><span id="6876" class="ni mc iq od b gy oh oi l oj ok">docker run python-app</span></pre><p id="c2a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">应用程序运行，我们的用户能够访问它。</p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ol"><img src="../Images/871e0ef588c7e614269b7f4bb68dbd50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sseWtvqifPS7K-lIA3tguQ.jpeg"/></div></div></figure><p id="9c1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当负载增加时。我们通过运行 docker run 命令更多次来部署应用程序的更多实例。</p><pre class="lx ly lz ma gt oc od oe of aw og bi"><span id="f647" class="ni mc iq od b gy oh oi l oj ok">docker run python-app <br/>docker run python-app<br/>docker run python-app</span></pre><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi om"><img src="../Images/e231a1ab361362bc22f16526fb66598f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Q2E9nNpBE5x9TSpKFIf6A.jpeg"/></div></div></figure><p id="9f34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这很好，我们都很高兴。</p><p id="6a7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，在将来的某个时候，我们的应用程序会进一步开发，经历架构上的变化，增长并变得复杂。</p><p id="33d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在有了一个新的助手容器，它通过处理或拟合来自其他地方的数据来帮助我们的 web 应用程序。</p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi on"><img src="../Images/740d0cbd3cc47de5cf602ee057d569a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iL9_QNfTfhGYvDEexjVDBA.jpeg"/></div></div></figure><p id="6bbc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些助手容器必须与我们的应用程序容器保持一对一的关系。助手容器还需要直接与应用程序容器通信来访问数据。为此，我们<strong class="kf ir">将</strong>需要维护一个映射来跟踪哪个助手容器对应于哪个应用程序。</p><ul class=""><li id="69c5" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">我们需要自己使用链接和自定义网络在这些容器之间建立网络连接。</li><li id="2c58" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">我们需要创建可共享的卷，并在容器之间共享它</li><li id="61e7" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">我们还需要维护一张地图。最重要的是，我们需要监控应用程序容器的状态，当它终止时，手动终止助手容器，因为不再需要它了。</li><li id="7697" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">当部署新的容器时，我们也需要部署新的助手容器。</li></ul><p id="8068" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">有了 PODs，kubernetes 可以自动为我们完成所有这些工作。</strong></p><p id="8773" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只需要定义 POD 由哪些容器组成，默认情况下，POD 中的容器将访问相同的存储、相同的网络命名空间和相同的命运，因为它们将被一起创建和一起销毁。</p><p id="e561" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">即使我们的应用程序没有那么复杂，我们可以使用单个容器，kubernetes 仍然要求您创建 pod。</p><p id="350a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这从长远来看是好的，因为您的应用程序现在已经为将来的架构变化和扩展做好了准备。</p><p id="01c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">值得注意的是，多 pod 容器是一种罕见的用例。</p><p id="1e68" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">前面我们学习了 kubectl run 命令。</p><pre class="lx ly lz ma gt oc od oe of aw og bi"><span id="2828" class="ni mc iq od b gy oh oi l oj ok">kubectl run nginx</span></pre><p id="e333" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个命令真正做的是通过创建一个 POD 来部署 docker 容器。因此，它首先自动创建一个 POD，并部署 nginx docker 映像的一个实例。</p><p id="c597" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是它是从哪里获得应用程序映像的呢？</p><p id="9247" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，您需要使用-image 参数指定图像名称。</p><pre class="lx ly lz ma gt oc od oe of aw og bi"><span id="c514" class="ni mc iq od b gy oh oi l oj ok">kubectl run nginx --image nginx</span></pre><p id="8158" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">nginx 映像是从 docker hub 库下载的。Docker hub 是一个公共存储库，其中存储了各种应用程序的最新 Docker 映像。</p><p id="2560" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以配置 kubernetes 从公共 docker hub 或组织内的私有存储库中提取图像。</p><p id="1344" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们已经创建了一个 POD，我们如何查看可用的 POD 列表呢？</p><pre class="lx ly lz ma gt oc od oe of aw og bi"><span id="83ab" class="ni mc iq od b gy oh oi l oj ok">kubectl get pods</span></pre><p id="2912" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">kubectl get PODs 命令帮助我们查看集群中的 PODs 列表。</p><p id="e496" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还要记住，我们还没有真正讨论用户如何访问 nginx web 服务器的概念。</p><p id="4742" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以在目前的状态下，我们还没有让外部用户访问 web 服务器。</p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/b8186538ed9e47da2cd1e9152aaec276.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*YU6jpWkhupsZpWVGyD9dGA.jpeg"/></div></figure><p id="f161" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，您可以从节点内部访问它。</p><p id="b549" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们将只看到如何部署一个 POD，在一篇高级文章中，我们将了解如何让最终用户可以访问该服务。</p></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><p id="2b89" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ls">原载于</em> <a class="ae kc" href="https://luispreciado.blog/posts/kubernetes/core-concepts/pods" rel="noopener ugc nofollow" target="_blank"> <em class="ls">我的博客</em> </a> <em class="ls">。</em></p></div></div>    
</body>
</html>