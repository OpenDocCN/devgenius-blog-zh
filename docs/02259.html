<html>
<head>
<title>Micro Frontends — Not A Solution Fitting All</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微前端—不是适合所有人的解决方案</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/micro-frontends-not-a-solution-fitting-all-c1a603f6fbce?source=collection_archive---------14-----------------------#2020-07-25">https://blog.devgenius.io/micro-frontends-not-a-solution-fitting-all-c1a603f6fbce?source=collection_archive---------14-----------------------#2020-07-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/c76cc48700dceafc146eb5b265f558e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*71YlBtQOOBw6_JI9QGC-1Q.png"/></div></div></figure><p id="21ec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先让我们谈谈什么是微前端，以及它们在各种场景中的用处。</p><blockquote class="kt ku kv"><p id="5165" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">微前端基本上适用于后端到前端应用程序的微服务架构的概念。这意味着将一个web应用程序划分为独立的单元，这样不同的独立团队可以使用他们自己的一套规则和框架来处理这些单元，然后这些独立的单元可以放在一个外壳下，看起来像一个应用程序，并且可以作为用户的一个应用程序工作。例如，电子商务应用程序可以将购物车、产品、订购、发票作为一些微前端。</p></blockquote><p id="3e37" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你仔细阅读上面给出的解释，你可以列出微前端架构的如下优点，这些优点与微服务架构相同。</p><ol class=""><li id="fc76" class="la lb in jx b jy jz kc kd kg lc kk ld ko le ks lf lg lh li bi translated">孤立的单位和独立的团队。</li><li id="69bc" class="la lb in jx b jy lj kc lk kg ll kk lm ko ln ks lf lg lh li bi translated">每个独立单元可自由选择不同的技术。</li><li id="507d" class="la lb in jx b jy lj kc lk kg ll kk lm ko ln ks lf lg lh li bi translated">每个单位单独部署，所以不需要重新部署所有单位。</li><li id="1f64" class="la lb in jx b jy lj kc lk kg ll kk lm ko ln ks lf lg lh li bi translated">代码库的分离带来了更多的控制。</li></ol><p id="d531" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">可能有更多的好处，但这些似乎是使用微前端架构的核心好处。</p><blockquote class="kt ku kv"><p id="d2f0" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">虽然这些好处吸引了很多人，并可能使它看起来像是每种类型的应用程序的完美解决方案。事实并非如此，为此我们需要看看一些陷阱，或者你可以称之为微前端似乎不是完美解决方案的场景。</p></blockquote><p id="6038" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们一个一个地看看这些陷阱。</p><ol class=""><li id="bfd3" class="la lb in jx b jy jz kc kd kg lc kk ld ko le ks lf lg lh li bi translated"><strong class="jx io">所有微前端需要相似的UX</strong></li></ol><p id="ef9c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于这些孤立的单元在单个shell应用程序下工作，看起来像一个集成的应用程序，它们应该遵循类似的UX准则和模式。在不同应用程序根据其用途可能需要不同的外观和感觉的情况下。微前端似乎不是一个合适的解决方案。</p><p id="b866" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 2。不同技术堆栈的使用</strong></p><p id="e2d5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在后端应用程序中，这可能不是问题。但在客户端，主要关注点是应用程序的启动速度和性能。因为我们不希望用户等待页面加载的时间太长。使用不同的框架将需要客户端上的每个微前端下载它们自己的一组依赖项和客户端上的框架，这可能会降低应用程序的速度。</p><p id="5499" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">虽然微前端允许我们使用不同的技术堆栈，但我们在决定这样做时需要非常小心，因为这将直接影响性能。这个问题不仅仅是对于不同框架的选择，对于两个微前端中相同依赖的不同版本的选择也是一样的。这就是为什么在不同的微前端应用中使用相同的框架和相同版本的主要依赖项是明智的。</p><p id="09e6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 3。隔离单元</strong></p><p id="0e68" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你看上面的解释，微前端谈论的是孤立的单元。但在实际应用中，我们可能希望在这些隔离单元之间建立通信，从而在微前端之间产生某种耦合。如果需要这种沟通，我们的选择有限。但是我们应该避免这种通信，直到有可能在微前端之间产生任何类型的耦合。因为产生这种耦合将会剥夺一些独立性，而这正是我们所说的微前端的优势。</p><p id="11de" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 4。独立团队</strong></p><p id="d6b1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因为在理想情况下，每个微前端将由独立的团队管理。每个团队可能建立他们自己的设计原则和指导方针。他们可能会选择不同的技术和技巧来实现前端。这就是为什么这些独立团队需要共同的指导方针和设计原则，以避免为类似的任务重新发明轮子。这也有助于解决第二个陷阱。</p><blockquote class="kt ku kv"><p id="256b" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">虽然理解使用特定体系结构的优点很重要，但是理解它的缺陷也很重要，以便在选择特定体系结构时做出更好的决策。</p></blockquote><p id="fcf5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">虽然阅读微前端的优点可能会使人觉得monolithic不是构建web应用程序的正确架构。但是在理解了缺陷并分析了这些缺陷与您的应用程序需求的对比之后，您可能仍然想要使用单片架构。如果是关于性能，前端框架现在已经提供了各种策略的成熟支持，可以用来实现它。为了探索更多的微前端，你可以去<a class="ae lo" href="https://micro-frontends.org/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></div></div>    
</body>
</html>