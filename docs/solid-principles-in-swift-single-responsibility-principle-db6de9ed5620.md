# Swift 的坚实原则——单一责任原则

> 原文：<https://blog.devgenius.io/solid-principles-in-swift-single-responsibility-principle-db6de9ed5620?source=collection_archive---------0----------------------->

![](img/9c886b074be7afeedd13f10826701cb6.png)

[Zan](https://unsplash.com/@zanilic?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

# 背景

在这一系列的帖子中，我们将涉及软件开发的坚实原则。这些是一组原则/指导方针，当开发软件系统时遵循这些原则/指导方针，使得系统随着时间的推移更容易扩展和维护。让我们来看看他们寻求解决的问题:

*   脆弱性:一个变化可能会破坏意想不到的部分，如果你没有一个好的测试覆盖率，这是很难检测到的
*   不可移动性:一个组件很难在另一个项目或同一个项目的多个地方重用，因为它有太多耦合的依赖关系
*   刚性:变更需要大量的努力，因为它影响到项目的几个部分

那么坚实的原则是什么呢？

*   单一责任原则——一个类应该只有一个责任/只有一个改变的理由
*   开闭原则——软件应该对扩展开放，但对修改关闭
*   Liskov 替换原则——程序中的对象应该可以用其子类型的实例替换，而不会改变程序的正确性
*   接口分离原则——许多特定于客户端的接口比一个通用接口要好
*   依赖倒置原则——高级模块不应该依赖低级模块。两者都应该依赖于抽象

在本文中，我们将集中讨论单一责任原则。

# 问题

列表中的第一个原则是单一责任原则。这一原则定义如下:

> *一个类应该只有一个改变的理由*

这意味着一个类应该只负责一项任务，而不是多项。让我们来看一个例子，以及我们如何使用这个原则来重构它。

这看起来像一个相当简单的新闻数据源/服务，从 web 上获取一些新闻条目。然而，如果我们仔细观察，我们会发现它负责多项任务。

1.  创建用于获取新闻文章的 URLRequest
2.  使用 URLSession 获取数据
3.  解析数据

这个班已经有三个不同的职责了。在这个例子中，它们可能看起来相当简单，但是想象一下，在一个更大的代码库中，这可能会很快失控。让我们来看一些场景。

*   这个例子中的新闻请求很简单。然而，如果请求更复杂，如果我们需要在请求中添加标题等，那该怎么办呢？所有代码都在这个类中。
*   如果我们想改变获取新闻的请求会怎样？我们必须在这里修改代码。或者，如果我们可以从多个 API 获取新闻会怎么样？在当前的结构下，我们如何做到这一点？
*   一旦发出请求，我们就使用 JSONDecoder 来解码响应。如果响应以不同的格式返回呢？如果我们想使用不同的解码来响应呢？
*   新闻请求可以在多个地方使用怎么办？

正如我们从上面的列表中看到的，有几个场景需要修改这个类的代码。如果我们回想一下单一责任的含义:

> *一个类应该只有一个改变的理由*

还有一个不太明显的副作用，那就是可测试性。让我们看一些例子:

*   我们如何测试 URLRequest 的变化？如果确实更改了 URLRequest 或者它是以不同的方式生成的，我们将如何测试它？
*   我们如何测试我们的类如何处理来自服务器的响应？例如，如果我们得到一个错误，会发生什么？
*   我们如何测试我们的解码代码？我们如何确定它将正确处理不正确的数据？我们的新闻数据源如何处理解码错误？

如果我们看看例子中的代码，我们可以看到不可能编写涵盖上述任何场景的单元测试。让我们看看如何将这个类分解成单个组件，允许我们只在一个地方进行更改，同时提高可测试性。

# 分解它

# URL 生成器

让我们先把这个班分成几个独立的班，每个班负责一项任务。首先，让我们取出 URLRequest 的构建，并将其放在另一个类中。

很好，现在我们有了一个类，它唯一的职责就是构建并返回一个 URLRequest。在更复杂的系统中，这个类可能需要 id、用户令牌等来配置请求。在我们需要改变新闻检索方式的场景中，我们只需要修改这一个类就可以实现这种改变。我们还可以根据开发、测试和生产等环境来更改主机名。

这样做的另一个好处是，我们现在可以编写单元测试来确保 URLRequest 被正确构建。现在我们来做一个小例子:

我们的 URL 生成器不是特别复杂，所以不需要很多测试。但至少在这里，它在一个单独的组件中，我们可以测试构造，并确保它被正确地创建。如果需要，或者如果我们需要不同的参数来构建请求，我们可以扩展这个测试来测试请求的其他元素。

# 句法分析程序

接下来让我们把解析器放到它自己的类中。

这里我们可以看到，我们已经把解码代码放到了一个单独的类中。这个类有一个改变的理由，只有在解析需要改变的时候才需要改变！同样，像我们的 URL 构建器类一样，我们现在可以测试解码，以确保得到我们期望的结果:

我们在这里做了什么？我们已经为解析器创建了几个单元测试。

*   第一个为解析器提供一些正确的 JSON 数据，并检查我们接收到的新闻对象是否正确，是否有正确的数据。
*   第二个测试向解析器发送了一些不正确的数据，并测试我们收到了预期的空数组

***我知道我们在这个例子中没有处理错误，这样做是为了让事情尽可能简单***

# 把所有的放在一起

既然我们已经将这些组件分成了独立的部分，现在让我们看看我们的数据源是什么样子的。

现在，如果我们看这里，我们可以看到，我们已经换出了构建请求和解析单独类的数据的代码。现在我们的例子是遵循单一责任原则。我们现在有 3 个组件:

1.  构建我们的请求的组件
2.  执行请求的组件
3.  一个组件来解析我们从请求中得到的数据

那么我们得到了什么:

*   我们现在已经对我们的组件进行了测试覆盖(我们可以更新 NewsDatasource 来进行测试，但是这有点高级，超出了本文的范围)
*   如果需要，我们可以在应用程序的其他部分或其他应用程序中重用这些组件
*   如果我们需要进行更改，每个组件只负责一件事，因此我们可以依次更新和测试每个更改。而不是在一个地方做多个改变，却不能测试它们！

请随意[下载样本](https://github.com/pyartez/single-responsibility)并亲自体验测试！

*原载于 2021 年 4 月 10 日*[*https://pyartez . github . io*](https://pyartez.github.io/architecture/solid-principles-in-swift-single-responsibility-principle.html)*。*