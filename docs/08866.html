<html>
<head>
<title>Introduction to Docker and Container based development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker 和基于容器的开发简介</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/introduction-to-docker-and-container-based-development-b30945428b92?source=collection_archive---------10-----------------------#2022-07-15">https://blog.devgenius.io/introduction-to-docker-and-container-based-development-b30945428b92?source=collection_archive---------10-----------------------#2022-07-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/7dd6a897a77ea92cd95998bd90b291fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PoaEMqHwmQI5-Ms_.png"/></div></div></figure><ul class=""><li id="b3c5" class="jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">Docker 是一组平台即服务产品，使用操作系统级虚拟化来交付称为容器的软件包中的软件。Docker 并不是使用基于容器的应用程序容器的准确术语。</li></ul><h1 id="acc8" class="kn ko in bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">第一代</h1><ul class=""><li id="eaa8" class="jv jw in jx b jy ll ka lm kc ln ke lo kg lp ki kj kk kl km bi translated">当我们考虑更早的时候，我们的应用程序部署在物理服务器上。</li><li id="e6d9" class="jv jw in jx b jy lq ka lr kc ls ke lt kg lu ki kj kk kl km bi translated">是的。如今，我们的应用程序也部署在物理服务器上，但要正确理解这一点。</li></ul><blockquote class="lv lw lx"><p id="c7b3" class="ly lz ma jx b jy jz mb mc ka kb md me mf mg mh mi mj mk ml mm mn mo mp mq ki ig bi translated">假设我们有一个应用程序数据库，观察三台不同的服务器，那时我们使用三台不同的物理硬件设备。</p></blockquote><p id="90ab" class="pw-post-body-paragraph ly lz in jx b jy jz mb mc ka kb md me kc mg mh mi ke mk ml mm kg mo mp mq ki ig bi translated">那时最大的问题是维护那些服务器。我们需要考虑</p><blockquote class="lv lw lx"><p id="3fa1" class="ly lz ma jx b jy jz mb mc ka kb md me mf mg mh mi mj mk ml mm mn mo mp mq ki ig bi translated">空间</p><p id="fc5f" class="ly lz ma jx b jy jz mb mc ka kb md me mf mg mh mi mj mk ml mm mn mo mp mq ki ig bi translated">独立网络</p><p id="c18b" class="ly lz ma jx b jy jz mb mc ka kb md me mf mg mh mi mj mk ml mm mn mo mp mq ki ig bi translated">操作系统维护成本</p><p id="4bd6" class="ly lz ma jx b jy jz mb mc ka kb md me mf mg mh mi mj mk ml mm mn mo mp mq ki ig bi translated">浪费电力</p></blockquote><p id="3d5a" class="pw-post-body-paragraph ly lz in jx b jy jz mb mc ka kb md me kc mg mh mi ke mk ml mm kg mo mp mq ki ig bi translated">所以存在这样的问题，</p><ul class=""><li id="c5ba" class="jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">网络服务器可能不会使用 100%的处理能力。</li><li id="eae8" class="jv jw in jx b jy lq ka lr kc ls ke lt kg lu ki kj kk kl km bi translated">数据库服务器可能不会使用 100，000 的空间。</li></ul><p id="9ddf" class="pw-post-body-paragraph ly lz in jx b jy jz mb mc ka kb md me kc mg mh mi ke mk ml mm kg mo mp mq ki ig bi translated">在这一代之后，我们进入了第<strong class="jx io">代虚拟机管理程序</strong>。</p><h1 id="b5d5" class="kn ko in bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated"><strong class="ak">第一代虚拟机管理程序(第二代)</strong></h1><ul class=""><li id="bcbe" class="jv jw in jx b jy ll ka lm kc ln ke lo kg lp ki kj kk kl km bi translated">在虚拟机管理程序中，我们使用单一类型的处理硬件设备，然后在其上安装虚拟机管理程序。现在，我们在此虚拟机管理程序上创建多个虚拟机(VM)。</li><li id="6f94" class="jv jw in jx b jy lq ka lr kc ls ke lt kg lu ki kj kk kl km bi translated">假设虚拟机 1 占用了 20%的处理能力。虚拟机 2 占 10%。虚拟机 3 占用了 20%的处理能力。现在我们总共使用了 50%的处理能力。还有另外 50%的处理能力，因此我们可以使用这些处理能力来创建多个其他虚拟机。</li><li id="113f" class="jv jw in jx b jy lq ka lr kc ls ke lt kg lu ki kj kk kl km bi translated">所以现在我们解决了一个问题，那就是能量的浪费。</li><li id="ec49" class="jv jw in jx b jy lq ka lr kc ls ke lt kg lu ki kj kk kl km bi translated">现在，我们将在虚拟机上安装操作系统。我们可以在每个虚拟机上安装不同的操作系统。因此，我们有能力在每个操作系统中安装我们的应用程序。</li></ul><p id="a470" class="pw-post-body-paragraph ly lz in jx b jy jz mb mc ka kb md me kc mg mh mi ke mk ml mm kg mo mp mq ki ig bi translated">但是我们的问题仍然没有解决。</p><p id="acd6" class="pw-post-body-paragraph ly lz in jx b jy jz mb mc ka kb md me kc mg mh mi ke mk ml mm kg mo mp mq ki ig bi translated">为什么？</p><ul class=""><li id="4133" class="jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">有三个独立的不同的操作系统，这导致了大量的成本。不仅如此，我们还必须维护和更新这些系统。</li><li id="5c14" class="jv jw in jx b jy lq ka lr kc ls ke lt kg lu ki kj kk kl km bi translated">制作另一个服务器可能需要新的虚拟机，所以要花相当多的时间来做这些事情。(已经做了一些配置)</li><li id="3d5b" class="jv jw in jx b jy lq ka lr kc ls ke lt kg lu ki kj kk kl km bi translated">由于虚拟机的引导过程，这将消耗大量的时间。</li></ul><h1 id="684c" class="kn ko in bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">集装箱(<strong class="ak">第三代)</strong></h1><ul class=""><li id="6dd2" class="jv jw in jx b jy ll ka lm kc ln ke lo kg lp ki kj kk kl km bi translated">这里我们也有相同的硬件设备。我们不存储多个操作系统。但我们确实在硬件设备上安装了单一操作系统。因此，这解决了前几代产品中的补丁许可、维护和更新问题。</li><li id="2375" class="jv jw in jx b jy lq ka lr kc ls ke lt kg lu ki kj kk kl km bi translated">现在我们在这个容器的顶部创建 docker。</li><li id="efbc" class="jv jw in jx b jy lq ka lr kc ls ke lt kg lu ki kj kk kl km bi translated">docker 是由 Apache 2.0 许可支持的开源项目。</li><li id="5bad" class="jv jw in jx b jy lq ka lr kc ls ke lt kg lu ki kj kk kl km bi translated">我们位于主机操作系统之上，这意味着操作系统已经启动，因此启动应用程序将会比前几代更快。</li></ul><p id="a0a8" class="pw-post-body-paragraph ly lz in jx b jy jz mb mc ka kb md me kc mg mh mi ke mk ml mm kg mo mp mq ki ig bi translated"><strong class="jx io"> Docker 引擎</strong></p><ul class=""><li id="ef58" class="jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">首先，最好理解 docker 引擎不是 docker 项目。docker 引擎是一个非常小的部分。</li><li id="ccc3" class="jv jw in jx b jy lq ka lr kc ls ke lt kg lu ki kj kk kl km bi translated">Docker 引擎是一个核心，业务流程、注册、安全、服务都是围绕 docker 引擎构建的。</li></ul><p id="8de6" class="pw-post-body-paragraph ly lz in jx b jy jz mb mc ka kb md me kc mg mh mi ke mk ml mm kg mo mp mq ki ig bi translated">注册表:注册表是一个你可以存储 docker 图像的地方，我们可以在上面做我们自己的定制，并把这些 docker 图像推回到注册表中。</p><ul class=""><li id="174d" class="jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">所以有多个存储库。你可以下载任何你想要的存储库/docker 映像，你可以定制，然后你可以把它推回来。</li></ul><p id="e994" class="pw-post-body-paragraph ly lz in jx b jy jz mb mc ka kb md me kc mg mh mi ke mk ml mm kg mo mp mq ki ig bi translated"><strong class="jx io">流程编排:</strong>流程编排是将所有这些实例组合在一起并实现共同目标的过程。对于那些微观层次的各种流程，您可以为它们创建不同的容器。</p><ul class=""><li id="757c" class="jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">当您进行部署时，您不需要定义容器到主机的方向。编排流程将定义这些容器的去向、依赖关系以及流程的优先级。</li></ul><p id="0b82" class="pw-post-body-paragraph ly lz in jx b jy jz mb mc ka kb md me kc mg mh mi ke mk ml mm kg mo mp mq ki ig bi translated">关于 Docker 的神话:</p><ul class=""><li id="b2c9" class="jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">有人说 docker 是<strong class="jx io">而不是坚持</strong>(就像当你关闭 docker 时，你的一切都丢失了)。但那不是真的。Dockers 天生就是坚持不懈的，无论你做什么，无论你何时关机或开机，它都不会消失。</li><li id="db3b" class="jv jw in jx b jy lq ka lr kc ls ke lt kg lu ki kj kk kl km bi translated">docker 仅适用于新应用程序，不适用于传统应用程序:这种说法部分正确，但完全不正确。当您拥有传统的多机箱旧环境时，您可以将传统应用程序推回虚拟机。但是 docker 不是这样的。如果你使用的是基于容器的应用程序，最好使用微级服务架构。这就是我们需要 Docker 的地方，因为你可以有一个负责任的应用程序，并创建一个独立的容器，不仅如此，因为它使你的应用程序具有自我修复的能力。</li></ul><blockquote class="lv lw lx"><p id="e349" class="ly lz ma jx b jy jz mb mc ka kb md me mf mg mh mi mj mk ml mm mn mo mp mq ki ig bi translated">假设这个 HTTP 容器有大量负载，现在我们可以从这个 HTTP 模块中分离出新的容器并重定向您的流量。</p></blockquote><ul class=""><li id="5b6e" class="jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">开发人员的另一个著名观点是遗留应用程序不支持 Docker 容器。这也是部分正确的。</li></ul><p id="a21d" class="pw-post-body-paragraph ly lz in jx b jy jz mb mc ka kb md me kc mg mh mi ke mk ml mm kg mo mp mq ki ig bi translated">技术上没有限制，有状态/无状态并不重要，我们可以放入这个容器，但您可能无法获得全部功能/好处。</p></div></div>    
</body>
</html>