<html>
<head>
<title>Building a Telegram bot with Rust.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用铁锈制作电报机器人。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/building-a-telegram-bot-with-rust-db731b5a915f?source=collection_archive---------3-----------------------#2022-12-30">https://blog.devgenius.io/building-a-telegram-bot-with-rust-db731b5a915f?source=collection_archive---------3-----------------------#2022-12-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/fb3f426cb4953ef02bcf6f43b9a2f878.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*x9WCAHLtjntqjxzA"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">由<a class="ae jz" href="https://unsplash.com/@nobleshots?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯文·诺布尔</a>在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="b0ca" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于本文，我们将构建一个电报机器人，用 Teloxide 保存 URL 地址。这个想法有点傻，用起来可能会不舒服，但它对学习很有用。</p><p id="b069" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这不是一个全面的关于 Teloxide 的教程，我们只是构建一个从 Hashmap 中保存和检索 URL 的机器人。</p><p id="2796" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我有点喜欢 Telegram 机器人，因为它们帮助我构建一些后端项目的想法，而不需要考虑 UI。</p><p id="53c0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我想通过这篇文章来继续学习 Rust，并通过构建这个机器人来了解一点 Teloxide。</p><p id="852f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">先决条件:</p><ul class=""><li id="bea6" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">铁锈基础知识</li><li id="ddb5" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">Ngrok 已安装</li></ul><p id="e734" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将使用 ngrok 来从本地机器上使用 webhook。如果你没有 ngrok，可以从<a class="ae jz" href="https://ngrok.com/" rel="noopener ugc nofollow" target="_blank">这里</a>下载。</p><h1 id="de8d" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">Teloxide 是什么？</h1><p id="b988" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">根据其<a class="ae jz" href="https://docs.rs/crate/teloxide/latest" rel="noopener ugc nofollow" target="_blank">文档</a>:</p><blockquote class="mp mq mr"><p id="5b43" class="ka kb ms kc b kd ke kf kg kh ki kj kk mt km kn ko mu kq kr ks mv ku kv kw kx ig bi translated"><em class="in">一个全功能的框架，使您能够使用 Rust 轻松构建电报机器人。它处理所有困难的事情，所以你可以只关注你的业务逻辑。</em></p><p id="e2eb" class="ka kb ms kc b kd ke kf kg kh ki kj kk mt km kn ko mu kq kr ks mv ku kv kw kx ig bi translated"><strong class="kc io"> <em class="in">亮点:</em> </strong></p><p id="b76b" class="ka kb ms kc b kd ke kf kg kh ki kj kk mt km kn ko mu kq kr ks mv ku kv kw kx ig bi translated"><strong class="kc io">声明式设计。</strong> <code class="fe mw mx my mz b">teloxide</code>基于<code class="fe mw mx my mz b">dptree</code>，这是一个功能性的<a class="ae jz" href="https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern" rel="noopener ugc nofollow" target="_blank">责任链</a>模式，允许您以高度声明性和可扩展的方式表达消息处理的管道。</p><p id="19fa" class="ka kb ms kc b kd ke kf kg kh ki kj kk mt km kn ko mu kq kr ks mv ku kv kw kx ig bi translated"><strong class="kc io">功能丰富。</strong>你可以使用长轮询和 webhooks，配置一个底层的 HTTPS 客户端，设置一个电报 API 服务器的自定义 URL，进行正常关机，等等。</p><p id="6988" class="ka kb ms kc b kd ke kf kg kh ki kj kk mt km kn ko mu kq kr ks mv ku kv kw kx ig bi translated">简单的对话。我们的对话子系统简单易用，而且不知道对话是如何/在哪里存储的。例如，您可以只替换一行来实现<a class="ae jz" href="https://en.wikipedia.org/wiki/Persistence_(computer_science)" rel="noopener ugc nofollow" target="_blank">持久性</a>。开箱即用存储包括<a class="ae jz" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>、<a class="ae jz" href="https://rocksdb.org/" rel="noopener ugc nofollow" target="_blank"> RocksDB </a>和<a class="ae jz" href="https://www.sqlite.org" rel="noopener ugc nofollow" target="_blank"> Sqlite </a>。</p><p id="e76b" class="ka kb ms kc b kd ke kf kg kh ki kj kk mt km kn ko mu kq kr ks mv ku kv kw kx ig bi translated"><strong class="kc io">强类型命令。</strong>将 bot 命令定义为<code class="fe mw mx my mz b">enum</code>，teloxide 将自动解析它们——就像<code class="fe mw mx my mz b">serde-json</code>中的 JSON 结构和<code class="fe mw mx my mz b">structopt</code>中的命令行参数一样。</p></blockquote><h1 id="3ea0" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated"><strong class="ak">目录结构</strong></h1><pre class="na nb nc nd gt ne mz nf bn ng nh bi"><span id="b14e" class="ni ln in mz b be nj nk l nl nm">url_saver_bot/<br/>  src/<br/>    main.rs<br/>    data.rs<br/>  cargo.toml</span></pre><h1 id="6d7b" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated"><strong class="ak"> Cargo.toml </strong></h1><pre class="na nb nc nd gt ne mz nf bn ng nh bi"><span id="2cfd" class="ni ln in mz b be nj nk l nl nm">[dependencies] <br/>teloxide = { version = "0.11", features = ["macros", "webhooks-axum"] } <br/>log = "0.4" pretty_env_logger = "0.4" <br/>tokio = { version = "1.8", features = ["rt-multi-thread", "macros"] } <br/>nanoid = "0.4"</span></pre><h1 id="3e14" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">僵尸父亲</h1><p id="406a" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">要创建一个电报机器人，我们需要一个令牌。</p><p id="14c6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">进入电报 App，在搜索栏输入<a class="ae jz" href="https://hashnode.com/@BotFather" rel="noopener ugc nofollow" target="_blank"> @BotFather </a>。</p><figure class="na nb nc nd gt jo gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/facea406aff2b37ef12742e93f8ebcf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/0*08miicz5ykfiPyg-.png"/></div></figure><p id="bf88" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">选择<code class="fe mw mx my mz b">/start</code>激活机器人。然后我们选择<code class="fe mw mx my mz b">/newbot</code>,按照指示创建一个机器人。</p><figure class="na nb nc nd gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi no"><img src="../Images/3853643256a942ddd43c70e536e6e028.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WmFKoogICFl6A__-.png"/></div></div></figure><p id="451f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们必须选择一个用户将看到的名称和一个用户名。然后，机器人会给我们发送一条消息，其中包含我们的令牌。</p><h1 id="c55f" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated"><strong class="ak"> main.rs </strong></h1><figure class="na nb nc nd gt jo"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="1e40" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将使用 webhooks 并为这个机器人设置三个命令。</p><p id="340c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们创建了一个<code class="fe mw mx my mz b">Bot</code>实例，它允许向电报机器人 API 发送请求。我们使用<code class="fe mw mx my mz b">from_env()</code>函数从环境中读取电报令牌。</p><p id="150b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后我们为我们的服务器定义端口。变量<code class="fe mw mx my mz b">url</code>的值将是我们初始化 ngrok 时获得的地址，或者如果我们想要部署 bot，我们从云服务获得的地址。</p><p id="e915" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要初始化 ngrok，我们在 ngrok 所在的位置键入以下命令，或者如果它被添加到我们的路径中，它也将工作。</p><pre class="na nb nc nd gt ne mz nf bn ng nh bi"><span id="08d1" class="ni ln in mz b be nj nk l nl nm">ngrok http 8000</span></pre><figure class="na nb nc nd gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nr"><img src="../Images/c58cdbd418fdb68e136a31205ded2096.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uCEX6vCDBeW_hK2N"/></div></div></figure><p id="11f0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们去<code class="fe mw mx my mz b">localhost:4040</code>，我们将有我们的网络界面。</p><p id="19d8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">地址显示它，因为转发 HTTPS 地址是我们必须键入的变量<code class="fe mw mx my mz b">url</code>的值。</p><p id="332f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们创建一个 webhook 实例，并将<code class="fe mw mx my mz b">addr</code>和<code class="fe mw mx my mz b">url</code>作为参数传递。</p><p id="dc3d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们要用命令，所以用<code class="fe mw mx my mz b">repl_with_listener</code>，传<code class="fe mw mx my mz b">bot</code>、<code class="fe mw mx my mz b">answer</code>、<code class="fe mw mx my mz b">listener</code>作为参数；<code class="fe mw mx my mz b">answer</code>是一个我们将在后面定义的处理程序。</p><p id="f4f9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是<a class="ae jz" href="https://docs.rs/teloxide/0.11.0/teloxide/fn.commands_repl_with_listener.html" rel="noopener ugc nofollow" target="_blank">文档</a>对<code class="fe mw mx my mz b">commands_repl_with_listener</code>的描述:</p><blockquote class="mp mq mr"><p id="f3b3" class="ka kb ms kc b kd ke kf kg kh ki kj kk mt km kn ko mu kq kr ks mv ku kv kw kx ig bi translated"><em class="in">一个</em><a class="ae jz" href="https://en.wikipedia.org/wiki/Read-eval-print_loop" rel="noopener ugc nofollow" target="_blank"><em class="in">REPL</em></a><em class="in">为命令，一个自定义</em> <code class="fe mw mx my mz b"><a class="ae jz" href="https://docs.rs/teloxide/0.11.0/teloxide/dispatching/update_listeners/trait.UpdateListener.html" rel="noopener ugc nofollow" target="_blank"><em class="in">UpdateListener</em></a></code> <em class="in">。</em></p><p id="0b53" class="ka kb ms kc b kd ke kf kg kh ki kj kk mt km kn ko mu kq kr ks mv ku kv kw kx ig bi translated">复制只适用于简单的机器人和快速原型制作。如果需要提供依赖关系或描述更复杂的调度逻辑，请使用 <code class="fe mw mx my mz b"><a class="ae jz" href="https://docs.rs/teloxide/0.11.0/teloxide/dispatching/struct.Dispatcher.html" rel="noopener ugc nofollow" target="_blank"><em class="in">Dispatcher</em></a></code> <em class="in">。另见:</em> <a class="ae jz" href="https://docs.rs/teloxide/0.11.0/teloxide/dispatching/index.html#dispatching-or-repls" rel="noopener ugc nofollow" target="_blank"> <em class="in">“派工还是复工？”</em></a>T33】。</p><p id="5e49" class="ka kb ms kc b kd ke kf kg kh ki kj kk mt km kn ko mu kq kr ks mv ku kv kw kx ig bi translated"><em class="in">来自处理程序和更新监听器的所有错误都将被记录。</em></p><p id="592d" class="ka kb ms kc b kd ke kf kg kh ki kj kk mt km kn ko mu kq kr ks mv ku kv kw kx ig bi translated"><strong class="kc io">签名:</strong></p><p id="f137" class="ka kb ms kc b kd ke kf kg kh ki kj kk mt km kn ko mu kq kr ks mv ku kv kw kx ig bi translated"><em class="in">不要被签名中的许多特征界限吓到，本质上它们需要:</em></p><p id="f11d" class="ka kb ms kc b kd ke kf kg kh ki kj kk mt km kn ko mu kq kr ks mv ku kv kw kx ig bi translated"><code class="fe mw mx my mz b">bot</code>是一个 bot，Telegram bot API 的客户端。它是通过特质表现出来的。</p><p id="6afc" class="ka kb ms kc b kd ke kf kg kh ki kj kk mt km kn ko mu kq kr ks mv ku kv kw kx ig bi translated"><code class="fe mw mx my mz b">handler</code>是一个<code class="fe mw mx my mz b">async</code>函数，它从<code class="fe mw mx my mz b"><a class="ae jz" href="https://docs.rs/teloxide/0.11.0/teloxide/prelude/struct.DependencyMap.html" rel="noopener ugc nofollow" target="_blank">DependencyMap</a></code>(见下文)获取参数并返回<code class="fe mw mx my mz b"><a class="ae jz" href="https://docs.rs/teloxide/0.11.0/teloxide/requests/type.ResponseResult.html" rel="noopener ugc nofollow" target="_blank">ResponseResult</a></code>。</p><p id="21db" class="ka kb ms kc b kd ke kf kg kh ki kj kk mt km kn ko mu kq kr ks mv ku kv kw kx ig bi translated"><code class="fe mw mx my mz b">listener</code>是从电报服务器获取更新并实现<code class="fe mw mx my mz b"><a class="ae jz" href="https://docs.rs/teloxide/0.11.0/teloxide/dispatching/update_listeners/trait.UpdateListener.html" rel="noopener ugc nofollow" target="_blank">UpdateListener</a></code>的东西。</p><p id="be4b" class="ka kb ms kc b kd ke kf kg kh ki kj kk mt km kn ko mu kq kr ks mv ku kv kw kx ig bi translated"><code class="fe mw mx my mz b">cmd</code>是你的命令枚举<code class="fe mw mx my mz b">MyCommand</code>的类型提示:只写<code class="fe mw mx my mz b">MyCommand::ty()</code>。注意<code class="fe mw mx my mz b">MyCommand</code>必须实现<code class="fe mw mx my mz b"><a class="ae jz" href="https://docs.rs/teloxide/0.11.0/teloxide/utils/command/trait.BotCommands.html" rel="noopener ugc nofollow" target="_blank">BotCommands</a></code>特征，通常通过<code class="fe mw mx my mz b">#[derive(BotCommands)]</code>实现。</p><p id="606b" class="ka kb ms kc b kd ke kf kg kh ki kj kk mt km kn ko mu kq kr ks mv ku kv kw kx ig bi translated">所有其他需求都是关于线程安全和数据有效性的，大部分时间都可以忽略。</p></blockquote><figure class="na nb nc nd gt jo"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="866c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里我们定义了机器人的命令。<code class="fe mw mx my mz b">Help</code>命令将显示命令列表。<code class="fe mw mx my mz b">Save</code>命令将保存一个 URL，<code class="fe mw mx my mz b">ChatId</code>命令返回用户的聊天 ID。</p><figure class="na nb nc nd gt jo"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="b2f5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mw mx my mz b">answer</code>函数将处理每个命令的答案。如果收到<code class="fe mw mx my mz b">/help</code>命令，它将发送命令的描述。如果收到<code class="fe mw mx my mz b">/chatid</code>，它将发送消息:“您的聊天 Id 是{chat_id}”。如果收到<code class="fe mw mx my mz b">/url</code>，会发送消息:“您要保存的网址是:{url}”。</p><p id="671c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">引用官方文件:</p><blockquote class="mp mq mr"><p id="eb15" class="ka kb ms kc b kd ke kf kg kh ki kj kk mt km kn ko mu kq kr ks mv ku kv kw kx ig bi translated"><code class="fe mw mx my mz b"><em class="in">teloxide</em></code> <em class="in">向</em> <code class="fe mw mx my mz b"><em class="in">handler</em></code> <em class="in">提供了以下类型:</em></p><p id="d81a" class="ka kb ms kc b kd ke kf kg kh ki kj kk mt km kn ko mu kq kr ks mv ku kv kw kx ig bi translated"><code class="fe mw mx my mz b"><a class="ae jz" href="https://docs.rs/teloxide/0.11.0/teloxide/types/struct.Message.html" rel="noopener ugc nofollow" target="_blank"><em class="in">Message</em></a></code></p><p id="f089" class="ka kb ms kc b kd ke kf kg kh ki kj kk mt km kn ko mu kq kr ks mv ku kv kw kx ig bi translated"><code class="fe mw mx my mz b"><em class="in">R</em></code> <em class="in">(类型</em> <code class="fe mw mx my mz b"><em class="in">bot</em></code> <em class="in"> ) </em></p><p id="61bf" class="ka kb ms kc b kd ke kf kg kh ki kj kk mt km kn ko mu kq kr ks mv ku kv kw kx ig bi translated"><code class="fe mw mx my mz b"><em class="in">Cmd</em></code> <em class="in">(解析命令的类型)</em></p><p id="4741" class="ka kb ms kc b kd ke kf kg kh ki kj kk mt km kn ko mu kq kr ks mv ku kv kw kx ig bi translated"><code class="fe mw mx my mz b"><a class="ae jz" href="https://docs.rs/teloxide/0.11.0/teloxide/types/struct.Me.html" rel="noopener ugc nofollow" target="_blank"><em class="in">Me</em></a></code></p><p id="ad3e" class="ka kb ms kc b kd ke kf kg kh ki kj kk mt km kn ko mu kq kr ks mv ku kv kw kx ig bi translated"><em class="in">这些类型中的每一个都可以作为处理程序参数接受。请注意，它们并不是同时需要的:例如，您可以只使用 bot 和命令，而不使用</em> <code class="fe mw mx my mz b"><a class="ae jz" href="https://docs.rs/teloxide/0.11.0/teloxide/types/struct.Me.html" rel="noopener ugc nofollow" target="_blank"><em class="in">Me</em></a></code> <em class="in">和</em> <code class="fe mw mx my mz b"><a class="ae jz" href="https://docs.rs/teloxide/0.11.0/teloxide/types/struct.Message.html" rel="noopener ugc nofollow" target="_blank"><em class="in">Message</em></a></code> <em class="in">。</em></p></blockquote><p id="8b67" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们启动我们的机器人时，它看起来像这样:</p><figure class="na nb nc nd gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ns"><img src="../Images/74ecac37aa06a4aaff14fc0aa9747b59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*z3CCZhh5N7PIAd97"/></div></div></figure><p id="4827" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在启动 bot 之前，我们需要设置令牌:</p><pre class="na nb nc nd gt ne mz nf bn ng nh bi"><span id="bee7" class="ni ln in mz b be nj nk l nl nm"># Unix-like<br/> $ export TELOXIDE_TOKEN=&lt;Your token here&gt; <br/><br/>#Windows command line <br/>$ set TELOXIDE_TOKEN=&lt;Your token here&gt; <br/><br/># Windows PowerShell <br/>$ $env:TELOXIDE_TOKEN=&lt;Your token here&gt;</span></pre><p id="e3e0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，我们在命令行中键入:</p><pre class="na nb nc nd gt ne mz nf bn ng nh bi"><span id="0159" class="ni ln in mz b be nj nk l nl nm">cargo run</span></pre><p id="7f9f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们将实现处理程序来保存和检索 URL。</p><figure class="na nb nc nd gt jo"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="1f77" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里，该函数接收一个 URL 并生成一个<code class="fe mw mx my mz b">id</code>字符串。然后它返回<code class="fe mw mx my mz b">id</code>。</p><p id="9fb3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们需要将<code class="fe mw mx my mz b">save_url</code>处理程序添加到<code class="fe mw mx my mz b">answer</code>函数中。</p><figure class="na nb nc nd gt jo"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="a6b0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们使用<code class="fe mw mx my mz b">/save</code>命令并提供一个 URL 时，它将返回一个 ID。</p><figure class="na nb nc nd gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nt"><img src="../Images/963be4099c99b6683ad41e4180111776.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R5zgu3PGgiFHNKiX"/></div></div></figure><p id="d07a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但这还不够。我们需要一些东西来存储 URL，以便以后检索它们。</p><p id="32cc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了简单起见，我们将把 URL 存储在 HashMap 中。我们创建一个新文件来定义模型和散列表。</p><figure class="na nb nc nd gt jo"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="dce2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里我们用属性<code class="fe mw mx my mz b">id</code>和<code class="fe mw mx my mz b">https_addres</code>来定义 StoredURL。我们为 StoredURL 实现 Display 以使用<code class="fe mw mx my mz b">format!</code>宏。然后，我们创建一个 HashMap 来存储我们的 URL，并能够通过它们的 ID 来检索它们。</p><p id="cdc8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们修改了我们的<code class="fe mw mx my mz b">save_url</code>处理程序来存储 URL。</p><figure class="na nb nc nd gt jo"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="06ab" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们添加一个命令来检索存储的 URL，我们返回到<code class="fe mw mx my mz b">main.rs</code>文件。</p><pre class="na nb nc nd gt ne mz nf bn ng nh bi"><span id="695c" class="ni ln in mz b be nj nk l nl nm">#[derive(BotCommands, Clone)]<br/>#[command(rename_rule = "lowercase", description = "These commands are supported:")]<br/>enum Command {<br/>    #[command(description = "display this text.")]<br/>    Help,<br/>    #[command(description = "Use this command to save a URL")]<br/>    Save(String),<br/>    #[command(description = "Use this command to retrieve a URL with its ID")]<br/>    Get(String),<br/>    #[command(description = "handle user's chat ID")]<br/>    ChatId,<br/><br/>}</span></pre><p id="d687" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们想要检索一个 URL 时，我们将使用<code class="fe mw mx my mz b">/get</code>命令。现在我们需要一个处理程序来完成这项工作。</p><figure class="na nb nc nd gt jo"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="a96c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用<code class="fe mw mx my mz b">get_url</code>,我们将能够通过 ID 检索存储在<code class="fe mw mx my mz b">DATA</code>中的任何 URL。</p><p id="b1f5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后我们将<code class="fe mw mx my mz b">get_url</code>处理程序添加到<code class="fe mw mx my mz b">answer</code>函数中。</p><figure class="na nb nc nd gt jo"><div class="bz fp l di"><div class="np nq l"/></div></figure><figure class="na nb nc nd gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nu"><img src="../Images/dc3241607c708be85b4cc9dbad0956f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DA0nFBFnpDuQzyPM"/></div></div></figure><p id="3863" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们稍微修改一下代码，让处理程序只返回 URL 地址。</p><figure class="na nb nc nd gt jo"><div class="bz fp l di"><div class="np nq l"/></div></figure><figure class="na nb nc nd gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nv"><img src="../Images/993199b8d8749295a070d93d3de207b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xK8lNH5fsZa-GtaO"/></div></div></figure><h1 id="1b95" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">结论</h1><p id="6853" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">建造这个机器人对我来说很有趣。起初，当我试图使用 Teloxide 时，我感到不知所措，它有很多功能，但文档和 GitHub 页面上的例子真的很有帮助。</p><p id="dc3c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我试图让这个机器人尽可能简单。但是最好添加一个数据库，并在 bot 保存字符串之前验证它是否是 URL。一个检索所有保存的 URL 的命令和一个按 ID 删除 URL 的命令。</p><p id="5779" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">感谢您花时间阅读这篇文章。</p><p id="2631" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里的源代码是<a class="ae jz" href="https://github.com/carlosm27/url_saver_bot" rel="noopener ugc nofollow" target="_blank">这里的</a></p><p id="16a8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你有任何关于其他包，架构，如何提高我的代码，我的英语，或任何东西的建议；请留言或通过<a class="ae jz" href="https://twitter.com/Carlos_marcv" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> Twitter </strong> </a>，或<a class="ae jz" href="https://www.linkedin.com/in/carlos-marcano-a2135a134/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> LinkedIn </strong> </a>联系我。</p><h1 id="c56e" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">参考</h1><p id="f55f" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated"><a class="ae jz" href="https://github.com/teloxide/teloxide" rel="noopener ugc nofollow" target="_blank"> Teloxide 的 GitHub 页面</a></p><p id="174b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://docs.rs/crate/teloxide/latest" rel="noopener ugc nofollow" target="_blank">氧化锡文件</a></p><p id="542c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://ngrok.com/docs" rel="noopener ugc nofollow" target="_blank"> ngrok 文档</a></p><p id="e209" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://crates.io/crates/once_cell" rel="noopener ugc nofollow" target="_blank"> Once_cell 文档</a></p><p id="0259" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://www.freecodecamp.org/news/how-to-create-a-telegram-bot-using-python/" rel="noopener ugc nofollow" target="_blank">如何使用 Python 创建电报机器人</a></p></div><div class="ab cl nw nx hr ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ig ih ii ij ik"><p id="ec3f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ms">原发布于</em><a class="ae jz" href="https://carlosmv.hashnode.dev/building-a-telegram-bot-with-rust" rel="noopener ugc nofollow" target="_blank"><em class="ms">https://Carlos mv . hash node . dev</em></a><em class="ms">。</em></p></div></div>    
</body>
</html>