<html>
<head>
<title>Initial setup for a GTK4 app with libadwaita in Rust using VSCode</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 VSCode 在 Rust 中对带有 libadwaita 的 GTK4 应用程序进行初始设置</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/initial-setup-for-a-gtk4-app-with-libadwaita-in-rust-using-vscode-b6f8c127a75e?source=collection_archive---------0-----------------------#2022-03-18">https://blog.devgenius.io/initial-setup-for-a-gtk4-app-with-libadwaita-in-rust-using-vscode-b6f8c127a75e?source=collection_archive---------0-----------------------#2022-03-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1b7ea9da1ef6ded086923e1eec974df9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*M3z3OoTk4Ireob0W"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@afgprogrammer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">穆罕默德·拉赫马尼</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="0a17" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我读到 GTK4 对 Rust 的支持时，我知道我想尝试一下这个设置。为了更好，我想使用 VSCode。VSCode 只是我的一个偏好，如果你使用官方的 Gnome Builder，你可能会更容易编写代码，但是对于这篇文章，我将坚持使用 VSCode。此外，我们将使用 Fedora 35。我们将要开发的应用程序是一个简单的 RSS 阅读器，所以我们称它为 GTK RSS 阅读器。它将使用 Gnome 开发者所期望的<code class="fe lb lc ld le b">libadwaita</code> UI 框架。</p><p id="cc5b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文的项目在<a class="ae kc" href="https://github.com/raduzaharia-medium/gtk-rss-reader-initial" rel="noopener ugc nofollow" target="_blank"> github </a>上，但是如果你有一点 Rust 的经验，我强烈建议你自己写，而不要只是克隆它。这将是一个新的系列，在我撰写文章时，要点将变成链接:</p><ol class=""><li id="d963" class="lf lg iq kf b kg kh kk kl ko lh ks li kw lj la lk ll lm ln bi translated"><a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/using-template-files-in-rust-for-a-gtk4-libadwaita-ui-8322694cbc3c">初始设置(本文)</a></li><li id="5167" class="lf lg iq kf b kg lo kk lp ko lq ks lr kw ls la lk ll lm ln bi translated"><a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/using-template-files-in-rust-for-a-gtk4-libadwaita-ui-8322694cbc3c">将用户界面移动到模板文件</a></li><li id="3d34" class="lf lg iq kf b kg lo kk lp ko lq ks lr kw ls la lk ll lm ln bi translated"><a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/bundling-templates-into-resources-in-rust-for-the-gtk4-ui-eb387a7918bf">将模板与应用捆绑在一起</a></li><li id="4b6a" class="lf lg iq kf b kg lo kk lp ko lq ks lr kw ls la lk ll lm ln bi translated"><a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/using-the-libadwaita-leaflet-widget-for-a-responsive-gtk4-ui-in-rust-73bbc2f4025">应用程序 UI 框架</a></li><li id="5112" class="lf lg iq kf b kg lo kk lp ko lq ks lr kw ls la lk ll lm ln bi translated"><a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/refactoring-gtk4-ui-templates-in-rust-68cbef1a1778">重构 UI 模板</a></li><li id="d9fc" class="lf lg iq kf b kg lo kk lp ko lq ks lr kw ls la lk ll lm ln bi translated"><a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/adding-properties-to-custom-gtk4-widgets-in-rust-67d4bbed8b08">向我们的自定义小部件添加属性</a></li><li id="6616" class="lf lg iq kf b kg lo kk lp ko lq ks lr kw ls la lk ll lm ln bi translated"><a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/using-models-to-bind-data-to-gtk4-custom-widgets-in-rust-379dd9d1bf4d">使用模型进行 UI 数据绑定</a></li><li id="ded1" class="lf lg iq kf b kg lo kk lp ko lq ks lr kw ls la lk ll lm ln bi translated"><a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/event-handling-for-gtk4-widgets-in-rust-d3c3f89b092f">事件处理和自定义事件</a></li><li id="eeb3" class="lf lg iq kf b kg lo kk lp ko lq ks lr kw ls la lk ll lm ln bi translated"><a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/using-threads-and-messages-to-load-data-in-a-gtk4-widget-5e1da3b0621d">在不同的线程上读取 RSS 文件</a></li></ol><p id="9c15" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先我们需要 VSCode，cargo，rust 和 rustfmt。我们将把 VSCode 存储库添加到 dnf:</p><pre class="lt lu lv lw gt lx le ly lz aw ma bi"><span id="f558" class="mb mc iq le b gy md me l mf mg">#sudo rpm --import <a class="ae kc" href="https://packages.microsoft.com/keys/microsoft.asc" rel="noopener ugc nofollow" target="_blank">https://packages.microsoft.com/keys/microsoft.asc</a><br/>#sudo sh -c 'echo -e "[code]\nname=Visual Studio Code\nbaseurl=https://packages.microsoft.com/yumrepos/vscode\nenabled=1\ngpgcheck=1\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc" &gt; /etc/yum.repos.d/vscode.repo'</span></pre><p id="1177" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们将它与 Rust 包和 GTK4 开发包一起安装:</p><pre class="lt lu lv lw gt lx le ly lz aw ma bi"><span id="4a81" class="mb mc iq le b gy md me l mf mg">#sudo dnf install code <br/>#sudo dnf install cargo rust-src rustfmt <br/>#sudo dnf install gtk4-devel libadwaita-devel</span></pre><p id="731b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们需要创建一个新的空 Rust 项目:</p><pre class="lt lu lv lw gt lx le ly lz aw ma bi"><span id="d475" class="mb mc iq le b gy md me l mf mg">#mkdir Projects<br/>#cd Projects<br/>#mkdir gtk-rss-reader<br/>#cd gtk-rss-reader<br/>#cargo init</span></pre><p id="b2d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以在 VSCode 中打开新的 gtk-rss-reader 项目了。为了更好的开发体验，我使用了两个 VSCode 扩展:Better TOML 和 Rust Analyzer。您可以从“扩展”面板安装这两个组件。</p><h2 id="32f4" class="mb mc iq bd mh mi mj dn mk ml mm dp mn ko mo mp mq ks mr ms mt kw mu mv mw mx bi translated">Cargo.toml 文件</h2><figure class="lt lu lv lw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/3d6e9e689621526a72befffe80879ec8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wqz24N6SFqWNscKCRjYScw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">应用程序的初始 cargo.toml</figcaption></figure><p id="37ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Cargo.toml 需要知道要使用的应用程序名称、版本、Rust 版本，并且我们需要指定<code class="fe lb lc ld le b">libadwaita</code>依赖关系:</p><pre class="lt lu lv lw gt lx le ly lz aw ma bi"><span id="1228" class="mb mc iq le b gy md me l mf mg">[package]<br/>name = "gtk-rss-reader"<br/>version = "0.1.0"<br/>edition = "2021"</span><span id="8bf2" class="mb mc iq le b gy mz me l mf mg">[dependencies]<br/>libadwaita = "*"</span></pre><p id="918a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就目前而言，这已经足够了。当我们开始处理 RSS 文件时，我们将在这里填充更多的依赖项。</p><h2 id="93ad" class="mb mc iq bd mh mi mj dn mk ml mm dp mn ko mo mp mq ks mr ms mt kw mu mv mw mx bi translated">应用程序窗口</h2><figure class="lt lu lv lw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/1e3636304634367b8fdffce7d64a3811.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ThGQyekps_Nxjn9BD8i4bQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">添加代码以创建主应用程序窗口</figcaption></figure><p id="0b1c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe lb lc ld le b">main.rs</code>我们将开始构建我们的应用程序。在这篇文章中，我只想完成初始设置，所以我将展示如何构建一个空窗口。下一次我们将更多地讨论应用程序 UI。</p><p id="0599" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在有两个功能:应用程序入口点<code class="fe lb lc ld le b">main</code>和<code class="fe lb lc ld le b">build_ui</code>助手。让我们来看看<code class="fe lb lc ld le b">main</code>的功能:</p><pre class="lt lu lv lw gt lx le ly lz aw ma bi"><span id="7479" class="mb mc iq le b gy md me l mf mg">pub fn main() {<br/>    let application = Application::new(Some("com.example.gtk-rss-reader"), Default::default());<br/>    <br/>    application.connect_activate(build_ui);<br/>    application.run();<br/>}</span></pre><p id="1cf5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们正在使用<code class="fe lb lc ld le b">Application::new</code>创建一个 GTK4 <code class="fe lb lc ld le b">libadwaita</code>应用程序。我们在这里使用的字符串<code class="fe lb lc ld le b">com.example.gtk-rss-reader</code>是 Gnome 生态系统中使用的应用程序 ID。每个应用程序都需要有一个 ID，格式看起来像一个倒置的 URL。我们还使用<code class="fe lb lc ld le b">Default::default()</code>为应用程序提供默认标志。</p><p id="75d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们在创建的应用程序上调用两个函数:<code class="fe lb lc ld le b">connect_activate</code>和<code class="fe lb lc ld le b">run</code>。<code class="fe lb lc ld le b">run</code>函数只是启动应用程序，而<code class="fe lb lc ld le b">connect_activate</code>函数注册我们的<code class="fe lb lc ld le b">build_ui</code>函数，以便在应用程序启动时执行。再来看<code class="fe lb lc ld le b">build_ui</code>:</p><pre class="lt lu lv lw gt lx le ly lz aw ma bi"><span id="ccbc" class="mb mc iq le b gy md me l mf mg">fn build_ui(application: &amp;Application) {<br/>    let window = ApplicationWindow::builder()<br/>        .application(application)<br/>        .title("My GTK4 RSS Reader")<br/>        .default_height(250)<br/>        .default_width(400)<br/>        .build();</span><span id="7038" class="mb mc iq le b gy mz me l mf mg">    window.show();<br/>}</span></pre><p id="d35d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个函数是我们构建应用程序 UI 的地方。现在，我们简单地创建应用程序窗口，我们设置它的标题和大小，并在屏幕上显示它。我们稍后会在这里添加更多内容，但首先，让我们看看到目前为止我们做了什么。我们将使用码头中的货物构建并运行该应用程序。我一直用 VSCode 提供的便捷终端(<code class="fe lb lc ld le b">ctrl+shift+`</code>没看到的话):</p><pre class="lt lu lv lw gt lx le ly lz aw ma bi"><span id="a962" class="mb mc iq le b gy md me l mf mg">#cargo build<br/>#cargo run</span></pre><p id="0f87" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在一些构建步骤之后，我们应该会看到全新的 GTK4 <code class="fe lb lc ld le b">libadwaita</code> powered 应用程序窗口:</p><figure class="lt lu lv lw gt jr gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/4b8322ebae1eea79249c642d2f7868f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*DHrMrs8pgppiRX_TMrzHzw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">空的应用程序窗口</figcaption></figure><p id="d978" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有点失望？我们的窗口甚至没有标题栏。让我们将其添加到<code class="fe lb lc ld le b">build_ui</code>函数中:</p><pre class="lt lu lv lw gt lx le ly lz aw ma bi"><span id="22c8" class="mb mc iq le b gy md me l mf mg">fn build_ui(application: &amp;Application) {<br/>    let content = libadwaita::gtk::Box::new(Orientation::Vertical, 0);<br/>    content.append(&amp;HeaderBar::builder()<br/>        .title_widget(&amp;WindowTitle::new("My GTK4 RSS Reader", ""))<br/>        .build());</span><span id="e03c" class="mb mc iq le b gy mz me l mf mg">    let window = ApplicationWindow::builder()<br/>        .application(application)<br/>        .title("My GTK4 RSS Reader")<br/>        .default_height(250)<br/>        .default_width(400)<br/>        .content(&amp;content)<br/>        .build();</span><span id="ee63" class="mb mc iq le b gy mz me l mf mg">    window.show();<br/>}</span></pre><p id="a2ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不要忘记更新<code class="fe lb lc ld le b">use</code>语句:</p><pre class="lt lu lv lw gt lx le ly lz aw ma bi"><span id="32de" class="mb mc iq le b gy md me l mf mg">use libadwaita::{<br/>    gtk::Orientation,<br/>    prelude::{ApplicationExt, ApplicationExtManual, BoxExt, WidgetExt},<br/>    Application, ApplicationWindow, HeaderBar, WindowTitle,                             };</span></pre><p id="39dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，如果我们构建并运行应用程序，我们将看到预期的空应用程序窗口:</p><figure class="lt lu lv lw gt jr gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/2bb1e3b5faeaf7b7bd1e6a329701516b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*qhpOii-OLoPlyWJqutKdMQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">带有标题栏的最后一个空窗口</figcaption></figure></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><p id="29f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">初期工作到此结束，本文也是如此。我们将进一步探索<code class="fe lb lc ld le b">libadwaita</code>框架，我们将创建一个简单但可用的 RSS 阅读器应用程序。<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/using-template-files-in-rust-for-a-gtk4-libadwaita-ui-8322694cbc3c">下一次</a>我们将把我们的 UI 代码转移到一个模板文件中，以提高代码的可读性和复杂性。现在，你可以随意评论你跟随本教程的经历，这样我就可以改进它。下一篇文章再见！</p></div></div>    
</body>
</html>