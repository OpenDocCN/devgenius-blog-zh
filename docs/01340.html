<html>
<head>
<title>Learn to model objects and behaviors with Go series: An example with dish washing (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习用Go系列建模对象和行为:洗碗的例子(第2部分)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/learn-to-model-objects-and-behaviors-with-go-series-an-example-with-dish-washing-part-2-7b72060f6ad?source=collection_archive---------24-----------------------#2020-06-30">https://blog.devgenius.io/learn-to-model-objects-and-behaviors-with-go-series-an-example-with-dish-washing-part-2-7b72060f6ad?source=collection_archive---------24-----------------------#2020-06-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/1785eddcdc4eb2d2dac10cfc526e7d24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GYpPC1YDyRrPA-XH"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">由<a class="ae jz" href="https://unsplash.com/@brookelark?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布鲁克·拉克</a>在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure></div><div class="ab cl ka kb hr kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="ig ih ii ij ik"><p id="2acb" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated"><em class="lf">这是Go学习对象和行为建模系列的第2部分。将碗碟放入沥水器后，我们来讨论一下</em> <a class="ae jz" href="https://medium.com/swlh/learn-to-model-object-and-behavior-with-go-series-an-example-with-dish-washing-part-1-8468b72404e8" rel="noopener"> <em class="lf">第一部分</em> </a> <em class="lf">的洗碗模式。</em></p></div><div class="ab cl ka kb hr kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="ig ih ii ij ik"><h1 id="2e93" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated"><strong class="ak">先决条件</strong></h1><p id="9d90" class="pw-post-body-paragraph kh ki in kj b kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la mi lc ld le ig bi translated">像第1部分一样，我们需要一些基础知识来完成第2部分:</p><ul class=""><li id="b601" class="mj mk in kj b kk kl ko kp ks ml kw mm la mn le mo mp mq mr bi translated">导出的字段(<a class="ae jz" href="https://tour.golang.org/basics/3" rel="noopener ugc nofollow" target="_blank">https://tour.golang.org/basics/3</a>)</li><li id="969a" class="mj mk in kj b kk ms ko mt ks mu kw mv la mw le mo mp mq mr bi translated">面向对象编程，或称<strong class="kj io">OOP</strong>(<a class="ae jz" href="https://en.wikipedia.org/wiki/Object-oriented_programming" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Object-oriented_programming</a>)</li></ul><p id="0f93" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">如果您阅读了本系列的第1部分，您应该知道导出的字段。对于<strong class="kj io"> OOP </strong>，我建议你在开始任何对象和行为建模学习轨道之前，仔细阅读这个概念。</p></div><div class="ab cl ka kb hr kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="ig ih ii ij ik"><h1 id="1a49" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated"><strong class="ak">OOP评估</strong></h1><p id="53da" class="pw-post-body-paragraph kh ki in kj b kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la mi lc ld le ig bi translated">首先，我们将从面向对象的角度评估我们的模型。</p><p id="7ef6" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">在围棋中，没有<strong class="kj io">公、私、保的概念。不幸的是，也没有父类和子类的概念。但这也意味着你不会有属性继承的麻烦。</strong></p><p id="7881" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">只有<strong class="kj io">出口和不出口。</strong></p><blockquote class="mx my mz"><p id="e0ed" class="kh ki lf kj b kk kl km kn ko kp kq kr na kt ku kv nb kx ky kz nc lb lc ld le ig bi translated">你唯一能做的就是<strong class="kj io">允许</strong>或<strong class="kj io">拒绝</strong>通过<strong class="kj io">导出或不导出</strong>变量来访问它们。</p></blockquote><p id="50ab" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">让我们重温一下我们的<strong class="kj io">海绵</strong>模型。</p><figure class="nd ne nf ng gt jo"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="79e3" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">从<strong class="kj io"> OOP </strong>的角度来看，模型的<strong class="kj io">属性</strong>应该用<strong class="kj io">私有</strong>范围<strong class="kj io">封装</strong>在模型内部，或者<strong class="kj io">保护</strong>，如果它们可以被子类<strong class="kj io">继承</strong>。</p><p id="b2b1" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated"><code class="fe nj nk nl nm b">Color</code>似乎是我们不想在洗涤时间被设定的属性(当然也是不真实的)。因此，我们可能需要将<code class="fe nj nk nl nm b">Color</code>更改为<strong class="kj io">非导出的</strong>形式。</p><p id="bcfb" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">所以我们会问自己一个问题，我们应该把一个结构(<strong class="kj io">海绵</strong>)的所有字段(属性)作为非导出字段吗？我们是否应该保护它们免受我们无法预测或控制的外部访问？</p><p id="0016" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">事实上，Go团队认为我们不应该。</p><figure class="nd ne nf ng gt jo"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="d861" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">这是我从<a class="ae jz" href="https://golang.org/pkg/net/http/" rel="noopener ugc nofollow" target="_blank">https://golang.org/pkg/net/http/</a>复制的代码，作为我们如何用传输对象声明HTTP客户端的例子。而且很明显，<code class="fe nj nk nl nm b">Transport</code>是<strong class="kj io">导出字段</strong>！</p><p id="76be" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">我不会假设为什么Go团队选择导出<code class="fe nj nk nl nm b">Transport</code>字段，但是我会提出我的方法，允许或拒绝访问一个struct的字段。</p><p id="b2cb" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated"><strong class="kj io">何时导出结构的字段(如果条件不满足，转到列表中的下一个条件)。</strong></p><ul class=""><li id="89f1" class="mj mk in kj b kk kl ko kp ks ml kw mm la mn le mo mp mq mr bi translated">如果该字段没有出现在该结构的任何方法中。<br/>所以我在这里公开了<code class="fe nj nk nl nm b">Color</code>属性，因为直到现在它还没有出现在<code class="fe nj nk nl nm b">Sponge</code> <strong class="kj io">的任何方法中。</strong></li><li id="8973" class="mj mk in kj b kk ms ko mt ks mu kw mv la mw le mo mp mq mr bi translated">如果设置该字段不会影响struct的任何方法的<strong class="kj io">下一次计算</strong>。</li><li id="20eb" class="mj mk in kj b kk ms ko mt ks mu kw mv la mw le mo mp mq mr bi translated">如果设置字段不需要任何数据约束或验证。<br/>当您需要验证您想要设置的值时，该字段<strong class="kj io">永远不适用于</strong>公共访问</li></ul><p id="0ebb" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">否则，该字段应<strong class="kj io">不导出。</strong></p><p id="f186" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">对于方法，要简单得多:</p><ul class=""><li id="4368" class="mj mk in kj b kk kl ko kp ks ml kw mm la mn le mo mp mq mr bi translated">如果你需要调用包外的方法，让它<strong class="kj io">导出。</strong></li><li id="fb72" class="mj mk in kj b kk ms ko mt ks mu kw mv la mw le mo mp mq mr bi translated">否则保持<strong class="kj io">不出口。</strong></li></ul></div><div class="ab cl ka kb hr kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="ig ih ii ij ik"><h1 id="0f2e" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated"><strong class="ak">扩展模型</strong></h1><p id="8001" class="pw-post-body-paragraph kh ki in kj b kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la mi lc ld le ig bi translated">你们有些人可能会问，为什么我只洗碗？你吃饭时会用到很多东西。</p><p id="e1ee" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">作为一个越南人，并且生活在亚洲社区，我吃饭更多的是用碗而不是盘子。我还用<strong class="kj io">煎锅、烹饪锅</strong>做越南菜。</p><figure class="nd ne nf ng gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nn"><img src="../Images/d473b8776c60afce7d4e38ed0743038a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*P_s197huctJaOXlI"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">照片由<a class="ae jz" href="https://unsplash.com/@uconrad?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">乌韦·康拉德</a>在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="b17b" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">因此，洗碗问题将延伸到碗、煎锅、烹饪锅和你吃饭需要的任何东西。</p><p id="721c" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">让我们实现模型吧！</p><p id="2282" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated"><em class="lf">碗.去</em></p><figure class="nd ne nf ng gt jo"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="dcdf" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated"><em class="lf"> pan.go </em></p><figure class="nd ne nf ng gt jo"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="350f" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated"><em class="lf"> pot.go </em></p><figure class="nd ne nf ng gt jo"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="39c9" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">这些型号看起来一样。但是正如我之前提到的，我们没有父类和子类的概念。然而，Go强大的另一个概念是，<strong class="kj io">接口类型！</strong>而且你会很高兴地知道它类似于<strong class="kj io"> OOP </strong> <strong class="kj io">接口</strong>的概念。</p><pre class="nd ne nf ng gt no nm np nq aw nr bi"><span id="73c0" class="ns lh in nm b gy nt nu l nv nw">An <em class="lf">interface type</em> is defined as a set of method signatures.</span><span id="c95b" class="ns lh in nm b gy nx nu l nv nw">A value of interface type can hold any value that implements those methods.</span></pre><p id="9b5e" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">看围棋教程时，请不要混淆<strong class="kj io">接口类型</strong>和<strong class="kj io">空接口。</strong></p><pre class="nd ne nf ng gt no nm np nq aw nr bi"><span id="ec4b" class="ns lh in nm b gy nt nu l nv nw">An empty interface <!-- -->interface{} <!-- -->may hold values of any type.</span><span id="2bcf" class="ns lh in nm b gy nx nu l nv nw">(Every type implements at least zero methods.)</span></pre><p id="30cf" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated"><em class="lf">wash . go</em></p><figure class="nd ne nf ng gt jo"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="5948" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">现在我们可以生成一个<strong class="kj io">可洗列表</strong></p><p id="05e4" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated"><em class="lf">generate wasable . go</em></p><figure class="nd ne nf ng gt jo"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="97b0" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">并将主功能修改为使用<strong class="kj io">可洗</strong>型</p><figure class="nd ne nf ng gt jo"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="ed6c" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">使用与第1部分相同的构建和运行命令，我们将得到以下结果</p><pre class="nd ne nf ng gt no nm np nq aw nr bi"><span id="7a70" class="ns lh in nm b gy nt nu l nv nw">$ go build -o main<br/>$./main<br/>item at index 1 is type Dish<br/>Before wash, is Dish clean? = false<br/>After wash, is Dish clean? = true<br/>item at index 2 is type Bowl<br/>Before wash, is Bowl clean? = false<br/>After wash, is Bowl clean? = true<br/>item at index 3 is type Pan<br/>Before wash, is Pan clean? = false<br/>After wash, is Pan clean? = true<br/>item at index 4 is type Pot<br/>Before wash, is Pot clean? = false<br/>After wash, is Pot clean? = true<br/>item at index 5 is type Dish<br/>Before wash, is Dish clean? = false<br/>After wash, is Dish clean? = true<br/>item at index 6 is type Bowl<br/>Before wash, is Bowl clean? = false<br/>After wash, is Bowl clean? = true<br/>item at index 7 is type Pan<br/>Before wash, is Pan clean? = false<br/>After wash, is Pan clean? = true<br/>item at index 8 is type Pot<br/>Before wash, is Pot clean? = false<br/>After wash, is Pot clean? = true<br/>item at index 9 is type Dish<br/>Before wash, is Dish clean? = false<br/>After wash, is Dish clean? = true<br/>item at index 10 is type Bowl<br/>Before wash, is Bowl clean? = false<br/>After wash, is Bowl clean? = true</span></pre><p id="f7a0" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">如果您感兴趣，可以在以下网址找到代码<code class="fe nj nk nl nm b">diswashing_part2</code></p><div class="ny nz gp gr oa ob"><a href="https://github.com/Nhat002/dishwashing/tree/master/dishwashing_part2" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd io gy z fp og fr fs oh fu fw im bi translated">nhat 002/洗碗</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">github.com</p></div></div><div class="ok l"><div class="ol l om on oo ok op jt ob"/></div></div></a></div><p id="fded" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">2部分之后，你是否意识到我们总是生成10号要清洁的项目列表？也是一块海绵能拥有的最大可洗次数！</p><p id="4929" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">对于<strong class="kj io">海绵</strong>和<strong class="kj io">液体分配器，我们从来不碰<code class="fe nj nk nl nm b">Topup</code>的方法。</strong>让我们使用<strong class="kj io">第3部分中的模型来研究洗碗算法的具体实现。</strong></p><p id="3b95" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">感谢阅读！我希望你喜欢它。</p></div></div>    
</body>
</html>