<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-learn-python-in-30-minutes-5cc31a360088?source=collection_archive---------36-----------------------#2020-06-11">https://blog.devgenius.io/how-to-learn-python-in-30-minutes-5cc31a360088?source=collection_archive---------36-----------------------#2020-06-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/aea57b60011479ff4a6983b0ebed2fb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_NLJjjJAkuDX7hOC.jpeg"/></div></div></figure><p id="34db" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">许多人苦于学习Python，因为很难找到高质量的资源。各种各样的资源会让你感到困惑。对于一些书来说，它包含了太多从1+1到深度学习的内容，很难在一整本书中学习所有这些内容。</p><p id="0d76" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我遇到过一个优秀的Python学习者素材。它最初是一个纯Python文件，我用一些注释扩展了它，使它更容易理解。如果你想要原始版本，你可以访问这个链接:</p><div class="im in gp gr io jv"><a href="https://learnxinyminutes.com/docs/python/" rel="noopener  ugc nofollow" target="_blank"><div class="jw ab fo"><div class="jx ab jy cl cj jz"><h2 class="bd ka gy z fp kb fr fs kc fu fw kd bi translated">在Y分钟内学会X，其中X=Python</h2><div class="ke l"><h3 class="bd b gy z fp kb fr fs kc fu fw dk translated">Python是由吉多·范·罗苏姆在90年代早期创造的。它现在是现存的最流行的语言之一。我…</h3></div><div class="kf l"><p class="bd b dl z fp kb fr fs kc fu fw dk translated">learnxinyminutes.com</p></div></div></div></a></div><h2 id="d342" class="kg kh iy bd ki kj kk dn kl km kn dp ko ji kp kq kr jm ks kt ku jq kv kw kx ky bi translated">评论</h2><p id="5709" class="pw-post-body-paragraph iw ix iy iz b ja kz jc jd je la jg jh ji lb jk jl jm lc jo jp jq ld js jt ju ig bi translated">在Python中，我们用#来注释一行，所有在#之后的内容都会被注释。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="9c0b" class="kg kh iy lj b gy ln lo l lp lq"># In Python, we use # to comment one single line, all content after # will be commented.</span></pre><p id="5c51" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我们使用三个连续的双引号来注释多行。标记之间的所有内容都将被注释。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="2b0d" class="kg kh iy lj b gy ln lo l lp lq">""" <br/>    We use three continuous double quotation marks to comment multi lines. <br/>    All contents between the marks will be commented.<br/>"""</span></pre><h1 id="b074" class="lr kh iy bd ki ls lt lu kl lv lw lx ko ly lz ma kr mb mc md ku me mf mg kx mh bi translated">基本变量类型和运算符</h1><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="5a83" class="kg kh iy lj b gy ln lo l lp lq"># Get an integer<br/>3<br/># Get a float<br/>10.0</span></pre><p id="df3f" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我们用+、-、*、/做加减乘除。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="9c0e" class="kg kh iy lj b gy ln lo l lp lq">1 + 1   # =&gt; 2<br/>8 - 1   # =&gt; 7<br/>10 * 2  # =&gt; 20<br/>35 / 5  # =&gt; 7.0</span></pre><p id="4eb7" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我们需要注意的是，在Python2中，10/3会得到3而不是3.33333。那是因为被除数和除数都是int，所以答案也会是一个int。但是在Python3中我们将得到3.333，因为它修改了这里的逻辑。因为Python2已经过期了，所以你可以跳过这个细节。</p><p id="546b" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">如果想得到整数类型的结果，可以用//代替/。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="788c" class="kg kh iy lj b gy ln lo l lp lq">5 // 3       # =&gt; 1<br/>-5 // 3      # =&gt; -2<br/>5.0 // 3.0   # =&gt; 1.0 # works on floats too<br/>-5.0 // 3.0  # =&gt; -2.0</span></pre><p id="a61a" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">两个斜杠意味着楼层划分，Python将保留结果，没有任何余数。</p><p id="85a2" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">除了地板划分，我们也有模运算，以获得余数。在Python中，我们用%来做。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="aac1" class="kg kh iy lj b gy ln lo l lp lq"># Modulo operation<br/>7 % 3  # =&gt; 1</span></pre><p id="556c" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">Python也支持取幂运算，我们用**表示法。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="6a75" class="kg kh iy lj b gy ln lo l lp lq"># Exponentiation (x**y, x to the yth power)<br/>2**3  # =&gt; 8</span></pre><p id="d88a" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">当运算有点复杂时，我们可以用括号来改变顺序或计算。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="d7c5" class="kg kh iy lj b gy ln lo l lp lq"># Enforce precedence with parentheses<br/>1 + 3 * 2  # =&gt; 7<br/>(1 + 3) * 2  # =&gt; 8</span></pre><h2 id="1c14" class="kg kh iy bd ki kj kk dn kl km kn dp ko ji kp kq kr jm ks kt ku jq kv kw kx ky bi translated">布尔运算</h2><p id="e23a" class="pw-post-body-paragraph iw ix iy iz b ja kz jc jd je la jg jh ji lb jk jl jm lc jo jp jq ld js jt ju ig bi translated">在Python中，我们有True和False两个布尔常量。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="b2bb" class="kg kh iy lj b gy ln lo l lp lq">True  # =&gt; True<br/>False  # =&gt; False</span></pre><p id="ba6f" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我们用and来做and运算，或者用do or运算，用not来做not运算。这不同于C++中的&amp;&amp;，||和！来代表与，或，非。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="29f3" class="kg kh iy lj b gy ln lo l lp lq"># negate with not<br/>not True   # =&gt; False<br/>not False  # =&gt; True<br/><br/># Boolean Operators<br/># Note "and" and "or" are case-sensitive<br/>True and False  # =&gt; False<br/>False or True   # =&gt; True</span></pre><p id="a419" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">实际上真和假在底层逻辑中等于1和0。所以按如下操作是可以的，但是在逻辑上是没有意义的。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="52ac" class="kg kh iy lj b gy ln lo l lp lq"># True and False are actually 1 and 0 but with different keywords<br/>True + True # =&gt; 2<br/>True * 8    # =&gt; 8<br/>False - 5   # =&gt; -5</span></pre><p id="fd6f" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我们用==来判断两个变量是否相等。我们可以看到True == 1，False == 0。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="220e" class="kg kh iy lj b gy ln lo l lp lq"># Comparison operators look at the numerical value of True and False<br/>0 == False  # =&gt; True<br/>1 == True   # =&gt; True<br/>2 == True   # =&gt; False<br/>-5 != False # =&gt; True</span></pre><p id="3fbc" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我们需要小心使用称为bool的函数，它并不意味着将变量转换为bool。如果我们做运算，只有0是假的，其他值都是真的。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="79e5" class="kg kh iy lj b gy ln lo l lp lq">bool(0)     # =&gt; False<br/>bool(4)     # =&gt; True<br/>bool(-6)    # =&gt; True<br/>0 and 2     # =&gt; 0<br/>-5 or 0     # =&gt; -5</span></pre><p id="b6f8" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">&gt;表示大于，&gt; =表示大于或等于，&lt; means less than, &lt;= means less or equal, != means not equal. I think it’s easy to understand.</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="cce9" class="kg kh iy lj b gy ln lo l lp lq"># Equality is ==<br/>1 == 1  # =&gt; True<br/>2 == 1  # =&gt; False<br/><br/># Inequality is !=<br/>1 != 1  # =&gt; False<br/>2 != 1  # =&gt; True<br/><br/># More comparisons<br/>1 &lt; 10  # =&gt; True<br/>1 &gt; 10  # =&gt; False<br/>2 &lt;= 2  # =&gt; True<br/>2 &gt;= 2  # =&gt; True</span></pre><p id="1b7e" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">We can use ‘and’ and ‘or’ to combine each logic calculation.</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="edb0" class="kg kh iy lj b gy ln lo l lp lq"># Seeing whether a value is in a range<br/>1 &lt; 2 and 2 &lt; 3  # =&gt; True<br/>2 &lt; 3 and 3 &lt; 2  # =&gt; False<br/># Chaining makes this look nicer<br/>1 &lt; 2 &lt; 3  # =&gt; True<br/>2 &lt; 3 &lt; 2  # =&gt; False</span></pre><p id="f9c6" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">Noted the priority between ‘not’, ‘and’ and ‘or’, it’s not &gt;和&gt;或。如果你对此感到困惑，你可以用括号来解决。</p><h2 id="7cfb" class="kg kh iy bd ki kj kk dn kl km kn dp ko ji kp kq kr jm ks kt ku jq kv kw kx ky bi translated">列表和字符串</h2><p id="c353" class="pw-post-body-paragraph iw ix iy iz b ja kz jc jd je la jg jh ji lb jk jl jm lc jo jp jq ld js jt ju ig bi translated">我们有两个常用的操作来判断两个列表是否相等。一个是==一个是‘是’。两者有什么区别？让我们在这儿看样品。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="1e17" class="kg kh iy lj b gy ln lo l lp lq">a = [1, 2, 3, 4]  # Point a at a new list, [1, 2, 3, 4]<br/>b = a             # Point b at what a is pointing to<br/>b is a            # =&gt; True, a and b refer to the same object<br/>b == a            # =&gt; True, a's and b's objects are equal<br/>b = [1, 2, 3, 4]  # Point b at a new list, [1, 2, 3, 4]<br/>b is a            # =&gt; False, a and b do not refer to the same object<br/>b == a            # =&gt; True, a's and b's objects are equal</span></pre><p id="4574" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">Python是一种到处使用引用的语言，我们用引用来表示对象。“is”运算用于判断两个引用是否分配给同一个对象，而==则用于判断这两个引用是否具有相同的值。</p><p id="a966" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">比如，如果把reference比作address，‘is’是判断两个地址是否相同，而==则是用来判断address的两个房东是否同名。</p><p id="cca6" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">显然，我们可以在不同的地址有几个插孔，但如果两个家伙有相同的家庭地址，他们一定是同一个人。所以如果a是b是真的，我们也可以肯定a == b，但反之则不然。</p><h2 id="ae16" class="kg kh iy bd ki kj kk dn kl km kn dp ko ji kp kq kr jm ks kt ku jq kv kw kx ky bi translated">线</h2><p id="e01f" class="pw-post-body-paragraph iw ix iy iz b ja kz jc jd je la jg jh ji lb jk jl jm lc jo jp jq ld js jt ju ig bi translated">在Python中，我们可以用单引号和双引号来表示一个字符串。我更喜欢单引号，因为它很容易编码。</p><p id="d317" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">两个字符串可以用加法运算串联起来，另外如果我们把字符串写在一起Python也会串联起来。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="9b7b" class="kg kh iy lj b gy ln lo l lp lq"># Strings are created with " or '<br/>"This is a string."<br/>'This is also a string.'<br/><br/># Strings can be added too! But try not to do this.<br/>"Hello " + "world!"  # =&gt; "Hello world!"<br/># String literals (but not variables) can be concatenated without using '+'<br/>"Hello " "world!"    # =&gt; "Hello world!"</span></pre><p id="1a3f" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我们还可以用括号按位置查询字符，用len查询字符串的长度。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="9bda" class="kg kh iy lj b gy ln lo l lp lq"># A string can be treated like a list of characters<br/>"This is a string"[0]  # =&gt; 'T'<br/><br/># You can find the length of a string<br/>len("This is a string")  # =&gt; 16</span></pre><p id="db84" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我们可以使用f-strings或format函数来格式化一个字符串。你可以在这里看到代码以获得更多的细节。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="52be" class="kg kh iy lj b gy ln lo l lp lq"># You can also format using f-strings or formatted string literals (in Python 3.6+)<br/>name = "Reiko"<br/>f"She said her name is {name}." # =&gt; "She said her name is Reiko"<br/># You can basically put any Python statement inside the braces and it will be output in the string.<br/>f"{name} is {len(name)} characters long." # =&gt; "Reiko is 5 characters long."<br/>'{} is a good boy'.format(name) # use format function to format string.</span></pre><p id="7121" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">在Python中，None也是一个对象，所有的变量都等于None对该对象的引用。所以我们可以同时使用' is '或' == '运算来验证一个变量是否为None。通常我们用is。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="7f8d" class="kg kh iy lj b gy ln lo l lp lq"># None is an object<br/>None  # =&gt; None<br/><br/># Don't use the equality "==" symbol to compare objects to None<br/># Use "is" instead. This checks for equality of object identity.<br/>"etc" is None  # =&gt; False<br/>None is None   # =&gt; True</span></pre><p id="3f5f" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">让我们回顾一下bool()函数的用法，实际上它是用来判断变量是否为空的。所有默认的空值将导致False，否则将返回True。Python中默认的空值是0，“”、{}、[]、()、None等。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="d57a" class="kg kh iy lj b gy ln lo l lp lq"># None, 0, and empty strings/lists/dicts/tuples all evaluate to False.<br/># All other values are True<br/>bool(None)# =&gt; False<br/>bool(0)   # =&gt; False<br/>bool("")  # =&gt; False<br/>bool([])  # =&gt; False<br/>bool({})  # =&gt; False<br/>bool(())  # =&gt; False</span></pre><h1 id="f562" class="lr kh iy bd ki ls lt lu kl lv lw lx ko ly lz ma kr mb mc md ku me mf mg kx mh bi translated">变量和集合</h1><h2 id="6622" class="kg kh iy bd ki kj kk dn kl km kn dp ko ji kp kq kr jm ks kt ku jq kv kw kx ky bi translated">输入和输出</h2><p id="6d22" class="pw-post-body-paragraph iw ix iy iz b ja kz jc jd je la jg jh ji lb jk jl jm lc jo jp jq ld js jt ju ig bi translated">在Python中，标准的输入和输出方法是‘input’和‘print’。</p><p id="fd6e" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">当我们调用print时，Python会在终端上打印一个字符串。如果参数不是字符串，Python会调用它的<strong class="iz ka"> str </strong>函数来获取一个字符串。每一行将以一个换行符结束，你可以使用' end '参数来改变它。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="6ce1" class="kg kh iy lj b gy ln lo l lp lq"># Python has a print function<br/>print("I'm Python. Nice to meet you!")  # =&gt; I'm Python. Nice to meet you!<br/><br/># By default the print function also prints out a newline at the end.<br/># Use the optional argument end to change the end string.<br/>print("Hello, World", end="!")  # =&gt; Hello, World!</span></pre><p id="ef28" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">当调用' input '函数时，参数将作为提示打印在控制台上。' input '返回的结果是一个字符串。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="a9dc" class="kg kh iy lj b gy ln lo l lp lq"># Simple way to get input data from console<br/>input_string_var = input("Enter some data: ") # Returns the data as a string<br/># Note: In earlier versions of Python, input() method was named as raw_input()</span></pre><h2 id="7d83" class="kg kh iy bd ki kj kk dn kl km kn dp ko ji kp kq kr jm ks kt ku jq kv kw kx ky bi translated">可变的</h2><p id="8260" class="pw-post-body-paragraph iw ix iy iz b ja kz jc jd je la jg jh ji lb jk jl jm lc jo jp jq ld js jt ju ig bi translated">在Python中，我们可以直接做赋值，不需要声明它的类型。<br/>如果你使用一个未赋值的变量，会导致命名错误。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="d01e" class="kg kh iy lj b gy ln lo l lp lq"># There are no declarations, only assignments.<br/># Convention is to use lower_case_with_underscores<br/>some_var = 5<br/>some_var  # =&gt; 5<br/><br/># Accessing a previously unassigned variable is an exception.<br/># See Control Flow to learn more about exception handling.<br/>some_unknown_var  # Raises a NameError</span></pre><p id="efd1" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">Python支持三元运算符，但语法与C/C++不同。在C++中，我们使用C？a : b，但是在Python中，我们有一个if C else b。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="929f" class="kg kh iy lj b gy ln lo l lp lq"># if can be used as an expression<br/># Equivalent of C's '?:' ternary operator<br/>"yahoo!" if 3 &gt; 2 else 2  # =&gt; "yahoo!"</span></pre><p id="9b87" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">上面的代码相当于:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="d588" class="kg kh iy lj b gy ln lo l lp lq">if 3 &gt; 2:<br/>    return 'yahoo'<br/>else:<br/>    return 2</span></pre><h2 id="0e12" class="kg kh iy bd ki kj kk dn kl km kn dp ko ji kp kq kr jm ks kt ku jq kv kw kx ky bi translated">目录</h2><p id="143f" class="pw-post-body-paragraph iw ix iy iz b ja kz jc jd je la jg jh ji lb jk jl jm lc jo jp jq ld js jt ju ig bi translated">在Python中，[]表示一个空列表，我们也可以直接用值来初始化它。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="4c24" class="kg kh iy lj b gy ln lo l lp lq"># Lists store sequences<br/>li = []<br/># You can start with a prefilled list<br/>other_li = [4, 5, 6]</span></pre><p id="43d0" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">使用“append”方法将值添加到列表的末尾，或者使用“pop”方法将值删除到末尾。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="8616" class="kg kh iy lj b gy ln lo l lp lq"># Add stuff to the end of a list with append<br/>li.append(1)    # li is now [1]<br/>li.append(2)    # li is now [1, 2]<br/>li.append(4)    # li is now [1, 2, 4]<br/>li.append(3)    # li is now [1, 2, 4, 3]<br/># Remove from the end with pop<br/>li.pop()        # =&gt; 3 and li is now [1, 2, 4]<br/># Let's put it back<br/>li.append(3)    # li is now [1, 2, 4, 3] again.</span></pre><p id="37ff" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">就像其他数组一样，可以使用[]和index来访问元素。负索引也是合法的，意味着从逆序查询。</p><p id="76dc" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">如果索引超过了数组的长度，将会触发一个IndexError异常。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="7b55" class="kg kh iy lj b gy ln lo l lp lq"># Access a list like you would any array<br/>li[0]   # =&gt; 1<br/># Look at the last element<br/>li[-1]  # =&gt; 3<br/><br/># Looking out of bounds is an IndexError<br/>li[4]  # Raises an IndexError</span></pre><p id="27ff" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">列表支持切片操作，切片意味着复制数组的一段。我们使用start: end来获取切片，包含开始索引，不包含结束索引。</p><p id="10c1" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">您可以省略start或end，如果省略start，则表示从0开始，如果省略end，则表示一直到最后。如果start和end都被省略，则意味着包含所有元素。</p><p id="4425" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">Slice支持step，我们可以给一个步骤，Python会跳过步骤之间的元素。例如，[1:5:2]表示从索引1到索引5，使用步骤2，结果为[1，3]。如果step为-1，则意味着以相反的顺序获取元素。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="c71a" class="kg kh iy lj b gy ln lo l lp lq"># You can look at ranges with slice syntax.<br/># The start index is included, the end index is not<br/># (It's a closed/open range for you mathy types.)<br/>li[1:3]   # Return list from index 1 to 3 =&gt; [2, 4]<br/>li[2:]    # Return list starting from index 2 =&gt; [4, 3]<br/>li[:3]    # Return list from beginning until index 3  =&gt; [1, 2, 4]<br/>li[::2]   # Return list selecting every second entry =&gt; [1, 4]<br/>li[::-1]  # Return list in reverse order =&gt; [3, 4, 2, 1]<br/># Use any combination of these to make advanced slices<br/># li[start:end:step]</span></pre><p id="263d" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">如果我们想得到一个反向的元素段，而不是整个数组。我们需要颠倒起点和终点。例如，如果我们想逆序得到[3:6]，我们需要使用[6:3:-1]。</p><p id="3427" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">仅用冒号获取slice意味着获取所有元素或数组的深层副本。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="87a8" class="kg kh iy lj b gy ln lo l lp lq">a = [3, 5, 6]<br/>a[:] is a # False</span></pre><p id="4d96" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我们可以使用del或remove方法删除特定索引中的元素。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="315d" class="kg kh iy lj b gy ln lo l lp lq"># Make a one layer deep copy using slices<br/>li2 = li[:]  # =&gt; li2 = [1, 2, 4, 3] but (li2 is li) will result in false.<br/><br/># Remove arbitrary elements from a list with "del"<br/>del li[2]  # li is now [1, 2, 3]<br/><br/># Remove first occurrence of a value<br/>li.remove(2)  # li is now [1, 3]<br/>li.remove(2)  # Raises a ValueError as 2 is not in the list</span></pre><p id="fd1d" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">使用“insert”函数在特定索引中插入元素。而“index”函数可以获得匹配给定值的第一个项目的索引。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="1acb" class="kg kh iy lj b gy ln lo l lp lq"># Insert an element at a specific index<br/>li.insert(1, 2)  # li is now [1, 2, 3] again<br/><br/># Get the index of the first item found matching the argument<br/>li.index(2)  # =&gt; 1<br/>li.index(4)  # Raises a ValueError as 4 is not in the list</span></pre><p id="9d86" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我们可以使用加号或“扩展”函数将两个数组连接在一起。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="8c08" class="kg kh iy lj b gy ln lo l lp lq"># You can add lists<br/># Note: values for li and for other_li are not modified.<br/>li + other_li  # =&gt; [1, 2, 3, 4, 5, 6]<br/><br/># Concatenate lists with "extend()"<br/>li.extend(other_li)  # Now li is [1, 2, 3, 4, 5, 6]</span></pre><p id="3984" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我们可以使用' in '关键字来确定给定值的存在性，并使用' len '函数来获得长度。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="ce65" class="kg kh iy lj b gy ln lo l lp lq"># Check for existence in a list with "in"<br/>1 in li  # =&gt; True<br/><br/># Examine the length with "len()"<br/>len(li)  # =&gt; 6</span></pre><h2 id="9bd8" class="kg kh iy bd ki kj kk dn kl km kn dp ko ji kp kq kr jm ks kt ku jq kv kw kx ky bi translated">元组</h2><p id="5d39" class="pw-post-body-paragraph iw ix iy iz b ja kz jc jd je la jg jh ji lb jk jl jm lc jo jp jq ld js jt ju ig bi translated">Tuple与list非常相似，我们可以用()初始化tuple。与列表不同，元组是不可变的。我们不能在初始化后修改元组。如果我们这样做，它将触发一个TypeError异常。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="c8fb" class="kg kh iy lj b gy ln lo l lp lq"># Tuples are like lists but are immutable.<br/>tup = (1, 2, 3)<br/>tup[0]      # =&gt; 1<br/>tup[0] = 3  # Raises a TypeError</span></pre><p id="24cd" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">如果我们想建立一个只有单个元素的元组，我们必须在末尾加一个逗号，否则()将被视为简单的括号，你将得到一个简单的变量。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="aad1" class="kg kh iy lj b gy ln lo l lp lq"># Note that a tuple of length one has to have a comma after the last element but<br/># tuples of other lengths, even zero, do not.<br/>type((1))   # =&gt; &lt;class 'int'&gt;<br/>type((1,))  # =&gt; &lt;class 'tuple'&gt;<br/>type(())    # =&gt; &lt;class 'tuple'&gt;</span></pre><p id="2b85" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">元组支持列表的大部分操作。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="4088" class="kg kh iy lj b gy ln lo l lp lq"># You can do most of the list operations on tuples too<br/>len(tup)         # =&gt; 3<br/>tup + (4, 5, 6)  # =&gt; (1, 2, 3, 4, 5, 6)<br/>tup[:2]          # =&gt; (1, 2)<br/>2 in tup         # =&gt; True</span></pre><p id="f340" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我们也可以使用多变量来解包元组。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="1e1c" class="kg kh iy lj b gy ln lo l lp lq"># You can unpack tuples (or lists) into variables<br/>a, b, c = (1, 2, 3)  # a is now 1, b is now 2 and c is now 3<br/># You can also do extended unpacking<br/>a, *b, c = (1, 2, 3, 4)  # a is now 1, b is now [2, 3] and c is now 4<br/># Tuples are created by default if you leave out the parentheses<br/>d, e, f = 4, 5, 6  # tuple 4, 5, 6 is unpacked into variables d, e and f<br/># respectively such that d = 4, e = 5 and f = 6<br/># Now look how easy it is to swap two values<br/>e, d = d, e  # d is now 5 and e is now 4</span></pre><p id="0d83" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">对于这一行:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="fffb" class="kg kh iy lj b gy ln lo l lp lq">a, *b, c = (1, 2, 3, 4)  # a is now 1, b is now [2, 3] and c is now 4</span></pre><p id="fbdb" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我们在变量b前加了一个星号，表示这是一个列表。所以Python会先排列其他变量，把左边的值赋给b。</p><p id="64c8" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">此外，元组本身是不可变的，但其元素是可变的。例如，如果我们有一个这样的元组:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="104c" class="kg kh iy lj b gy ln lo l lp lq">a = (3, [4])</span></pre><p id="3ce0" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">虽然我们不能向它插入元素，但它有一个列表。我们可以修改列表元素的元素。没关系。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="73e9" class="kg kh iy lj b gy ln lo l lp lq">a[1].append(0) # This is legal</span></pre><h2 id="d7f7" class="kg kh iy bd ki kj kk dn kl km kn dp ko ji kp kq kr jm ks kt ku jq kv kw kx ky bi translated">词典</h2><p id="befd" class="pw-post-body-paragraph iw ix iy iz b ja kz jc jd je la jg jh ji lb jk jl jm lc jo jp jq ld js jt ju ig bi translated">Dict也是一个非常有用的Python集合，它类似于C++中的map，用来存储键值对。我们用一个大括号来定义一个字典和一个公共字典来分隔键和值。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="6038" class="kg kh iy lj b gy ln lo l lp lq"># Dictionaries store mappings from keys to values<br/>empty_dict = {}<br/># Here is a prefilled dictionary<br/>filled_dict = {"one": 1, "two": 2, "three": 3}</span></pre><p id="644f" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">字典的键必须是不可变的，所以一个列表，集合或者其他字典不能是字典的键。否则，会导致异常。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="9e3f" class="kg kh iy lj b gy ln lo l lp lq"># Note keys for dictionaries have to be immutable types. This is to ensure that<br/># the key can be converted to a constant hash value for quick look-ups.<br/># Immutable types include ints, floats, strings, tuples.<br/>invalid_dict = {[1,2,3]: "123"}  # =&gt; Raises a TypeError: unhashable type: 'list'<br/>valid_dict = {(1,2,3):[1,2,3]}   # Values can be of any type, however.</span></pre><p id="f1c3" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我们还使用括号来查询值，而不是使用索引，我们使用键。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="6300" class="kg kh iy lj b gy ln lo l lp lq"># Look up values with []<br/>filled_dict["one"]  # =&gt; 1<br/>filled_dict.get('one') #=&gt; 1</span></pre><p id="3c70" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我们可以调用“keys”和“values”函数来查询一个字典的所有键和值。它将返回一个iterable对象，我们可以把它转换成一个列表。</p><p id="8383" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">如果版本&lt; 3.7, dictionary key ordering is not guaranteed. If you iterate the objects in the dict, it may not match the order when inserted. But in Python version &gt; 3.7，它会修复这个问题，并确保迭代顺序与插入顺序匹配。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="7be8" class="kg kh iy lj b gy ln lo l lp lq"># Get all keys as an iterable with "keys()". We need to wrap the call in list()<br/># to turn it into a list. We'll talk about those later.  Note - for Python<br/># versions &lt;3.7, dictionary key ordering is not guaranteed. Your results might<br/># not match the example below exactly. However, as of Python 3.7, dictionary<br/># items maintain the order at which they are inserted into the dictionary.<br/>list(filled_dict.keys())  # =&gt; ["three", "two", "one"] in Python &lt;3.7<br/>list(filled_dict.keys())  # =&gt; ["one", "two", "three"] in Python 3.7+<br/><br/><br/># Get all values as an iterable with "values()". Once again we need to wrap it<br/># in list() to get it out of the iterable. Note - Same as above regarding key<br/># ordering.<br/>list(filled_dict.values())  # =&gt; [3, 2, 1]  in Python &lt;3.7<br/>list(filled_dict.values())  # =&gt; [1, 2, 3] in Python 3.7+</span></pre><p id="af5a" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我们也可以用in来检查一个键的存在。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="8de2" class="kg kh iy lj b gy ln lo l lp lq"># Check for existence of keys in a dictionary with "in"<br/>"one" in filled_dict  # =&gt; True<br/>1 in filled_dict      # =&gt; False</span></pre><p id="2b79" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">如果我们用括号来查询一个不存在的键，就会引发错误。但是如果我们使用get()函数，它只会返回None而没有任何异常。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="77f2" class="kg kh iy lj b gy ln lo l lp lq"># Looking up a non-existing key is a KeyError<br/>filled_dict["four"]  # KeyError<br/><br/># Use "get()" method to avoid the KeyError<br/>filled_dict.get("one")      # =&gt; 1<br/>filled_dict.get("four")     # =&gt; None<br/># The get method supports a default argument when the value is missing<br/>filled_dict.get("one", 4)   # =&gt; 1<br/>filled_dict.get("four", 4)  # =&gt; 4</span></pre><p id="aa1c" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我们可以使用setdefault函数为一个键插入一个备份值，如果这个键存在，它什么也不做。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="cc3f" class="kg kh iy lj b gy ln lo l lp lq"># "setdefault()" inserts into a dictionary only if the given key isn't present<br/>filled_dict.setdefault("five", 5)  # filled_dict["five"] is set to 5<br/>filled_dict.setdefault("five", 6)  # filled_dict["five"] is still 5</span></pre><p id="f2cb" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我们可以使用更新功能来使用另一个字典来更新当前的字典。例如，如果a和b都是字典，当我们运行a.update(b)时。对于那些既存在于a中又存在于b中的键，将被b覆盖。对于那些只出现在b中的键，将被插入到a中。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="12f2" class="kg kh iy lj b gy ln lo l lp lq"># Adding to a dictionary<br/>filled_dict.update({"four":4})  # =&gt; {"one": 1, "two": 2, "three": 3, "four": 4}<br/>filled_dict["four"] = 4         # another way to add to dict</span></pre><p id="73bd" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我们也可以使用' del '操作来删除dict中的键。在3.5版本中，我们可以使用**来解包一个字典。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="e747" class="kg kh iy lj b gy ln lo l lp lq">{'a': 1, **{'b': 2}}  # =&gt; {'a': 1, 'b': 2}<br/>{'a': 1, **{'a': 2}}  # =&gt; {'a': 2}</span></pre><h2 id="2ca1" class="kg kh iy bd ki kj kk dn kl km kn dp ko ji kp kq kr jm ks kt ku jq kv kw kx ky bi translated">设置</h2><p id="af3f" class="pw-post-body-paragraph iw ix iy iz b ja kz jc jd je la jg jh ji lb jk jl jm lc jo jp jq ld js jt ju ig bi translated">Set是存储唯一值的集合。重复的值将被删除。我们可以用' set()'或者{}来初始化它。请注意，当我们使用大括号来构建集合时，我们必须输入一些值，否则Python会将其与dict混淆。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="722d" class="kg kh iy lj b gy ln lo l lp lq"># Sets store ... well sets<br/>empty_set = set()<br/># Initialize a set with a bunch of values. Yeah, it looks a bit like a dict. Sorry.<br/>some_set = {1, 1, 2, 2, 3, 4}  # some_set is now {1, 2, 3, 4}</span></pre><p id="800e" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">set的元素也必须是不可变的，所以不能插入list。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="06a0" class="kg kh iy lj b gy ln lo l lp lq"># Similar to keys of a dictionary, elements of a set have to be immutable.<br/>invalid_set = {[1], 1}  # =&gt; Raises a TypeError: unhashable type: 'list'<br/>valid_set = {(1,), 1}</span></pre><p id="8e38" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我们可以调用' add '函数将一个元素插入到集合中。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="18a4" class="kg kh iy lj b gy ln lo l lp lq"># Add one more item to the set<br/>filled_set = some_set<br/>filled_set.add(5)  # filled_set is now {1, 2, 3, 4, 5}<br/># Sets do not have duplicate elements<br/>filled_set.add(5)  # it remains as before {1, 2, 3, 4, 5}</span></pre><p id="1a7c" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">集合也支持集合运算，所以我们可以做集合的交、并、差运算。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="142a" class="kg kh iy lj b gy ln lo l lp lq"># Do set intersection with &amp;<br/>other_set = {3, 4, 5, 6}<br/>filled_set &amp; other_set  # =&gt; {3, 4, 5}<br/><br/># Do set union with |<br/>filled_set | other_set  # =&gt; {1, 2, 3, 4, 5, 6}<br/><br/># Do set difference with -<br/>{1, 2, 3, 4} - {2, 3, 5}  # =&gt; {1, 4}<br/><br/># Do set symmetric difference with ^<br/>{1, 2, 3, 4} ^ {2, 3, 5}  # =&gt; {1, 4, 5}</span></pre><p id="1315" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">集合也支持验证超集和子集，我们可以用' &gt; = '和' &lt; = '来判断一个集合是另一个集合的超集还是子集。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="d269" class="kg kh iy lj b gy ln lo l lp lq"># Check if set on the left is a superset of set on the right<br/>{1, 2} &gt;= {1, 2, 3} # =&gt; False<br/><br/># Check if set on the left is a subset of set on the right<br/>{1, 2} &lt;= {1, 2, 3} # =&gt; True</span></pre><p id="56fe" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">和dict一样，我们可以用' in '来检查一个值的存在性，可以用' copy()'函数来复制一个集合。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="605a" class="kg kh iy lj b gy ln lo l lp lq"># Check for existence in a set with in<br/>2 in filled_set   # =&gt; True<br/>10 in filled_set  # =&gt; False<br/><br/># Make a one layer deep copy<br/>filled_set = some_set.copy()  # filled_set is {1, 2, 3, 4, 5}<br/>filled_set is some_set        # =&gt; False</span></pre><h1 id="b1ac" class="lr kh iy bd ki ls lt lu kl lv lw lx ko ly lz ma kr mb mc md ku me mf mg kx mh bi translated">条件和迭代</h1><h2 id="69b4" class="kg kh iy bd ki kj kk dn kl km kn dp ko ji kp kq kr jm ks kt ku jq kv kw kx ky bi translated">情况</h2><p id="800c" class="pw-post-body-paragraph iw ix iy iz b ja kz jc jd je la jg jh ji lb jk jl jm lc jo jp jq ld js jt ju ig bi translated">Python不支持‘switch’操作，所以即使我们有一个复杂的条件，我们也只能把几个if-else堆在一起。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="53fc" class="kg kh iy lj b gy ln lo l lp lq"># Let's just make a variable<br/>some_var = 5<br/><br/># Here is an if statement. Indentation is significant in Python!<br/># Convention is to use four spaces, not tabs.<br/># This prints "some_var is smaller than 10"<br/>if some_var &gt; 10:<br/>    print("some_var is totally bigger than 10.")<br/>elif some_var &lt; 10:    # This elif clause is optional.<br/>    print("some_var is smaller than 10.")<br/>else:                  # This is optional too.<br/>    print("some_var is indeed 10.")</span></pre><h2 id="4f6d" class="kg kh iy bd ki kj kk dn kl km kn dp ko ji kp kq kr jm ks kt ku jq kv kw kx ky bi translated">环</h2><p id="75d3" class="pw-post-body-paragraph iw ix iy iz b ja kz jc jd je la jg jh ji lb jk jl jm lc jo jp jq ld js jt ju ig bi translated">我们可以使用“in”关键字来迭代列表中的元素。这是loop的基本用法。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="2886" class="kg kh iy lj b gy ln lo l lp lq">"""<br/>For loops iterate over lists<br/>prints:<br/>    dog is a mammal<br/>    cat is a mammal<br/>    mouse is a mammal<br/>"""<br/>for animal in ["dog", "cat", "mouse"]:<br/>    # You can use format() to interpolate formatted strings<br/>    print("{} is a mammal".format(animal))</span></pre><p id="76e8" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">如果我们想要迭代一个范围，我们可以使用' range '关键字来构建一个列表。如果我们只传递一个参数，它将从0返回一个序列。例如，range(5)表示[0，5]中的所有整数。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="0e14" class="kg kh iy lj b gy ln lo l lp lq">"""<br/>"range(number)" returns an iterable of numbers<br/>from zero to the given number<br/>prints:<br/>    0<br/>    1<br/>    2<br/>    3<br/>"""<br/>for i in range(4):<br/>    print(i)</span></pre><p id="90b8" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">如果我们传递两个参数，这意味着序列的开始和结束。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="653e" class="kg kh iy lj b gy ln lo l lp lq">"""<br/>"range(lower, upper)" returns an iterable of numbers<br/>from the lower number to the upper number<br/>prints:<br/>    4<br/>    5<br/>    6<br/>    7<br/>"""<br/>for i in range(4, 8):<br/>    print(i)</span></pre><p id="6485" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">如果我们传递三个参数，第三个意味着序列的步骤。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="80da" class="kg kh iy lj b gy ln lo l lp lq">"""<br/>"range(lower, upper, step)" returns an iterable of numbers<br/>from the lower number to the upper number, while incrementing<br/>by step. If step is not indicated, the default value is 1.<br/>prints:<br/>    4<br/>    6<br/>"""<br/>for i in range(4, 8, 2):<br/>    print(i)</span></pre><p id="0c13" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我们可以使用“enumerate”关键字同时迭代索引和值。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="19b4" class="kg kh iy lj b gy ln lo l lp lq">"""<br/>To loop over a list, and retrieve both the index and the value of each item in the list<br/>prints:<br/>    0 dog<br/>    1 cat<br/>    2 mouse<br/>"""<br/>animals = ["dog", "cat", "mouse"]<br/>for i, value in enumerate(animals):<br/>    print(i, value)</span></pre><p id="3553" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">While循环与C++类似，当条件为假时将退出循环。在Python中，我们不需要在条件中添加括号。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="9e94" class="kg kh iy lj b gy ln lo l lp lq">"""<br/>While loops go until a condition is no longer met.<br/>prints:<br/>    0<br/>    1<br/>    2<br/>    3<br/>"""<br/>x = 0<br/>while x &lt; 4:<br/>    print(x)<br/>    x += 1  # Shorthand for x = x + 1</span></pre><h2 id="85e1" class="kg kh iy bd ki kj kk dn kl km kn dp ko ji kp kq kr jm ks kt ku jq kv kw kx ky bi translated">异常捕捉</h2><p id="c95b" class="pw-post-body-paragraph iw ix iy iz b ja kz jc jd je la jg jh ji lb jk jl jm lc jo jp jq ld js jt ju ig bi translated">在Python中，我们可以使用try-except来捕捉异常。我们可以在except之后指定异常的类型。如果需要，你也可以指定多个类型，并且可以使用‘else’操作来获取所有其他类型。“finally”后面的代码将在所有条件下运行。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="9737" class="kg kh iy lj b gy ln lo l lp lq"># Handle exceptions with a try/except block<br/>try:<br/>    # Use "raise" to raise an error<br/>    raise IndexError("This is an index error")<br/>except IndexError as e:<br/>    pass                 # Pass is just a no-op. Usually you would do recovery here.<br/>except (TypeError, NameError):<br/>    pass                 # Multiple exceptions can be handled together, if required.<br/>else:                    # Optional clause to the try/except block. Must follow all except blocks<br/>    print("All good!")   # Runs only if the code in try raises no exceptions<br/>finally:                 #  Execute under all circumstances<br/>    print("We can clean up resources here")</span></pre><h2 id="8602" class="kg kh iy bd ki kj kk dn kl km kn dp ko ji kp kq kr jm ks kt ku jq kv kw kx ky bi translated">带操作</h2><p id="1f25" class="pw-post-body-paragraph iw ix iy iz b ja kz jc jd je la jg jh ji lb jk jl jm lc jo jp jq ld js jt ju ig bi translated">在Python中，我们总是使用外部资源，最常见的情况是打开一个文件。当我们创建一个文件句柄时，我们必须在使用后关闭它。如果我们手动操作，很容易忘记。而且我们还需要使用try-catch来处理异常，所以最好使用with command来处理。</p><p id="5ca4" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我们可以使用with命令来处理资源，当遇到异常或溢出时，它会自动关闭资源。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="2d36" class="kg kh iy lj b gy ln lo l lp lq"># Instead of try/finally to cleanup resources you can use a with statement<br/>with open("myfile.txt") as f:<br/>    for line in f:<br/>        print(line)<br/><br/># Writing to a file<br/>contents = {"aa": 12, "bb": 21}<br/>with open("myfile1.txt", "w+") as file:<br/>    file.write(str(contents))        # writes a string to a file<br/><br/>with open("myfile2.txt", "w+") as file:<br/>    file.write(json.dumps(contents)) # writes an object to a file<br/><br/># Reading from a file<br/>with open('myfile1.txt', "r+") as file:<br/>    contents = file.read()           # reads a string from a file<br/>print(contents)<br/># print: {"aa": 12, "bb": 21}<br/><br/>with open('myfile2.txt', "r+") as file:<br/>    contents = json.load(file)       # reads a json object from a file<br/>print(contents)     <br/># print: {"aa": 12, "bb": 21}</span></pre><h2 id="fdeb" class="kg kh iy bd ki kj kk dn kl km kn dp ko ji kp kq kr jm ks kt ku jq kv kw kx ky bi translated">可迭代对象</h2><p id="2591" class="pw-post-body-paragraph iw ix iy iz b ja kz jc jd je la jg jh ji lb jk jl jm lc jo jp jq ld js jt ju ig bi translated">所有可以被' in '关键字迭代的对象都是可迭代对象。它不同于迭代器，如果你想知道更多关于迭代器的知识，你可以谷歌一下。文章没有涉及迭代器的内容。</p><p id="d390" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">当我们在dict中调用' keys '函数时，它返回一个iterable对象。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="da4c" class="kg kh iy lj b gy ln lo l lp lq"># Python offers a fundamental abstraction called the Iterable.<br/># An iterable is an object that can be treated as a sequence.<br/># The object returned by the range function, is an iterable.<br/><br/>filled_dict = {"one": 1, "two": 2, "three": 3}<br/>our_iterable = filled_dict.keys()<br/>print(our_iterable)  # =&gt; dict_keys(['one', 'two', 'three']). This is an object that implements our Iterable interface.<br/><br/># We can loop over it.<br/>for i in our_iterable:<br/>    print(i)  # Prints one, two, three</span></pre><p id="d603" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我们不能使用index查询iterable对象中的元素，但是可以使用iter将其转换为iterator，并使用' next '关键字获取下一个元素。我们也可以把它转移到一个链表中。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="b74b" class="kg kh iy lj b gy ln lo l lp lq"># However we cannot address elements by index.<br/>our_iterable[1]  # Raises a TypeError<br/><br/># An iterable is an object that knows how to create an iterator.<br/>our_iterator = iter(our_iterable)<br/><br/># Our iterator is an object that can remember the state as we traverse through it.<br/># We get the next object with "next()".<br/>next(our_iterator)  # =&gt; "one"<br/><br/># It maintains state as we iterate.<br/>next(our_iterator)  # =&gt; "two"<br/>next(our_iterator)  # =&gt; "three"<br/><br/># After the iterator has returned all of its data, it raises a StopIteration exception<br/>next(our_iterator)  # Raises StopIteration<br/><br/># We can also loop over it, in fact, "for" does this implicitly!<br/>our_iterator = iter(our_iterable)<br/>for i in our_iterator:<br/>    print(i)  # Prints one, two, three<br/><br/># You can grab all the elements of an iterable or iterator by calling list() on it.<br/>list(our_iterable)  # =&gt; Returns ["one", "two", "three"]<br/>list(our_iterator)  # =&gt; Returns [] because state is saved</span></pre><h2 id="eb6e" class="kg kh iy bd ki kj kk dn kl km kn dp ko ji kp kq kr jm ks kt ku jq kv kw kx ky bi translated">功能</h2><p id="da9b" class="pw-post-body-paragraph iw ix iy iz b ja kz jc jd je la jg jh ji lb jk jl jm lc jo jp jq ld js jt ju ig bi translated">使用' def '关键字定义一个函数，如果我们清除参数的名称，我们可以按任意顺序传递参数。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="5ff8" class="kg kh iy lj b gy ln lo l lp lq"># Use "def" to create new functions<br/>def add(x, y):<br/>    print("x is {} and y is {}".format(x, y))<br/>    return x + y  # Return values with a return statement<br/><br/># Calling functions with parameters<br/>add(5, 6)  # =&gt; prints out "x is 5 and y is 6" and returns 11<br/><br/># Another way to call functions is with keyword arguments<br/>add(y=6, x=5)  # Keyword arguments can arrive in any order.</span></pre><p id="963f" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi">可以在参数名之前加上*表示任意长度的参数，参数会被转化成list：</p><p id="605e" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我们还可以在argument前添加' * '符号，它代表一个长度不限的数组，而arguments将被视为一个列表。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="0cec" class="kg kh iy lj b gy ln lo l lp lq"># You can define functions that take a variable number of<br/># positional arguments<br/>def varargs(*args):<br/>    return args<br/><br/>varargs(1, 2, 3)  # =&gt; (1, 2, 3)</span></pre><p id="bc93" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我们也可以用' ** '符号来接收字典。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="15fc" class="kg kh iy lj b gy ln lo l lp lq"># You can define functions that take a variable number of<br/># keyword arguments, as well<br/>def keyword_args(**kwargs):<br/>    return kwargs<br/><br/># Let's call it to see what happens<br/>keyword_args(big="foot", loch="ness")  # =&gt; {"big": "foot", "loch": "ness"}</span></pre><p id="f2d6" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我们可以一起使用这两种符号，它会让函数接收任何情况下的参数。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="39c5" class="kg kh iy lj b gy ln lo l lp lq"># You can do both at once, if you like<br/>def all_the_args(*args, **kwargs):<br/>    print(args)<br/>    print(kwargs)<br/>"""<br/>all_the_args(1, 2, a=3, b=4) prints:<br/>    (1, 2)<br/>    {"a": 3, "b": 4}<br/>"""</span></pre><p id="4eb0" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">当传递参数时，我们还可以使用'<em class="mi">'和'</em> * '来解包列表或字典。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="a844" class="kg kh iy lj b gy ln lo l lp lq"># When calling functions, you can do the opposite of args/kwargs!<br/># Use * to expand tuples and use ** to expand kwargs.<br/>args = (1, 2, 3, 4)<br/>kwargs = {"a": 3, "b": 4}<br/>all_the_args(*args)            # equivalent to all_the_args(1, 2, 3, 4)<br/>all_the_args(**kwargs)         # equivalent to all_the_args(a=3, b=4)<br/>all_the_args(*args, **kwargs)  # equivalent to all_the_args(1, 2, 3, 4, a=3, b=4)</span></pre><p id="772a" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">在Python中，我们可以同时返回多个结果。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="61af" class="kg kh iy lj b gy ln lo l lp lq"># Returning multiple values (with tuple assignments)<br/>def swap(x, y):<br/>    return y, x  # Return multiple values as a tuple without the parenthesis.<br/>                 # (Note: parenthesis have been excluded but can be included)<br/><br/>x = 1<br/>y = 2<br/>x, y = swap(x, y)     # =&gt; x = 2, y = 1<br/># (x, y) = swap(x,y)  # Again parenthesis have been excluded but can be included.</span></pre><p id="d450" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">每个功能本身都有一个范围，它与外部环境是分离的。所以我们在函数内外定义了同名的变量。如果我们想在函数之外使用一个变量，我们还需要使用' global '关键字。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="6d5e" class="kg kh iy lj b gy ln lo l lp lq"># Function Scope<br/>x = 5<br/><br/>def set_x(num):<br/>    # Local var x not the same as global variable x<br/>    x = num    # =&gt; 43<br/>    print(x)   # =&gt; 43<br/><br/>def set_global_x(num):<br/>    global x<br/>    print(x)   # =&gt; 5<br/>    x = num    # global var x is now set to 6<br/>    print(x)   # =&gt; 6<br/><br/>set_x(43)<br/>set_global_x(6)</span></pre><p id="ad08" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">Python支持函数式编程，函数也可以在函数中返回或传递。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="e2f2" class="kg kh iy lj b gy ln lo l lp lq"># Python has first class functions<br/>def create_adder(x):<br/>    def adder(y):<br/>        return x + y<br/>    return adder<br/><br/>add_10 = create_adder(10)<br/>add_10(3)   # =&gt; 13</span></pre><p id="00a9" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">Lambda '关键字定义了未命名的函数，我们使用common作为单独的标记。common之前的部分作为函数的参数，common之后的部分表示将返回结果。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="e877" class="kg kh iy lj b gy ln lo l lp lq"># There are also anonymous functions<br/>(lambda x: x &gt; 2)(3)                  # =&gt; True<br/>(lambda x, y: x ** 2 + y ** 2)(2, 1)  # =&gt; 5</span></pre><p id="fec5" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">map '，' filter '关键字接收函数作为批处理数据的参数。</p><p id="2c81" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">map '，' filter '，' reduce '是Python的高级用法，如果你对它感兴趣，可以谷歌一下了解更多细节。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="e009" class="kg kh iy lj b gy ln lo l lp lq"># There are built-in higher order functions<br/>list(map(add_10, [1, 2, 3]))          # =&gt; [11, 12, 13]<br/>list(map(max, [1, 2, 3], [4, 2, 1]))  # =&gt; [4, 2, 3]<br/><br/>list(filter(lambda x: x &gt; 5, [3, 4, 5, 6, 7]))  # =&gt; [6, 7]</span></pre><p id="74e7" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我们可以使用for-loop来初始化一个字典。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="5780" class="kg kh iy lj b gy ln lo l lp lq"># We can use list comprehensions for nice maps and filters<br/># List comprehension stores the output as a list which can itself be a nested list<br/>[add_10(i) for i in [1, 2, 3]]         # =&gt; [11, 12, 13]<br/>[x for x in [3, 4, 5, 6, 7] if x &gt; 5]  # =&gt; [6, 7]<br/><br/># You can construct set and dict comprehensions as well.<br/>{x for x in 'abcddeef' if x not in 'abc'}  # =&gt; {'d', 'e', 'f'}<br/>{x: x**2 for x in range(5)}  # =&gt; {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}</span></pre><h1 id="6a8c" class="lr kh iy bd ki ls lt lu kl lv lw lx ko ly lz ma kr mb mc md ku me mf mg kx mh bi translated">组件</h1><p id="9976" class="pw-post-body-paragraph iw ix iy iz b ja kz jc jd je la jg jh ji lb jk jl jm lc jo jp jq ld js jt ju ig bi translated">使用' import '命令导入一个Python模块，我们可以使用'.'访问模块中的类或函数。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="a250" class="kg kh iy lj b gy ln lo l lp lq"># You can import modules<br/>import math<br/>print(math.sqrt(16))  # =&gt; 4.0</span></pre><p id="0795" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我们也可以使用“从导入”来导入模块中的类或函数。你可以使用“从xxx导入*”从一个模块中导入所有的函数或类，但不推荐这样做，因为这会导致延迟和内存开销。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="c637" class="kg kh iy lj b gy ln lo l lp lq"># You can get specific functions from a module<br/>from math import ceil, floor<br/>print(ceil(3.7))   # =&gt; 4.0<br/>print(floor(3.7))  # =&gt; 3.0<br/><br/># You can import all functions from a module.<br/># Warning: this is not recommended<br/>from math import *</span></pre><p id="53cd" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">您可以使用“as”关键字为模块指定别名。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="1ceb" class="kg kh iy lj b gy ln lo l lp lq"># You can shorten module names<br/>import math as m<br/>math.sqrt(16) == m.sqrt(16)  # =&gt; True</span></pre><p id="193e" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我们可以通过使用“dir”关键字找到模块的路径。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="d30e" class="kg kh iy lj b gy ln lo l lp lq"># You can find out which functions and attributes<br/># are defined in a module.<br/>import math<br/>dir(math)</span></pre><p id="83ca" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">这个关键字帮助检查模块的路径，如果我们在当前的director下有一个math.py，它将覆盖系统的math。这很容易导致bug，所以一定要注意。</p><h1 id="7ec0" class="lr kh iy bd ki ls lt lu kl lv lw lx ko ly lz ma kr mb mc md ku me mf mg kx mh bi translated">班级</h1><p id="dd54" class="pw-post-body-paragraph iw ix iy iz b ja kz jc jd je la jg jh ji lb jk jl jm lc jo jp jq ld js jt ju ig bi translated">让我们来看一个完整的类，相关信息都列在评论里。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="d2a7" class="kg kh iy lj b gy ln lo l lp lq"># We use the "class" statement to create a class<br/>class Human:<br/><br/>    # A class attribute. It is shared by all instances of this class<br/>    species = "H. sapiens"<br/><br/>    # Basic initializer, this is called when this class is instantiated.<br/>    # Note that the double leading and trailing underscores denote objects<br/>    # or attributes that are used by Python but that live in user-controlled<br/>    # namespaces. Methods(or objects or attributes) like: __init__, __str__,<br/>    # __repr__ etc. are called special methods (or sometimes called dunder methods)<br/>    # You should not invent such names on your own.<br/>    def __init__(self, name):<br/>        # Assign the argument to the instance's name attribute<br/>        self.name = name<br/><br/>        # Initialize property<br/>        self._age = 0<br/><br/>    # An instance method. All methods take "self" as the first argument<br/>    # self表示实例的引用<br/>    def say(self, msg):<br/>        print("{name}: {message}".format(name=self.name, message=msg))<br/><br/>    # Another instance method<br/>    def sing(self):<br/>        return 'yo... yo... microphone check... one two... one two...'<br/><br/>    # A class method is shared among all instances<br/>    # They are called with the calling class as the first argument<br/>    @classmethod<br/>    def get_species(cls):<br/>        return cls.species<br/><br/>    # A static method is called without a class or instance reference<br/>    @staticmethod<br/>    def grunt():<br/>        return "*grunt*"<br/><br/>    # A property is just like a getter.<br/>    # It turns the method age() into an read-only attribute of the same name.<br/>    # There's no need to write trivial getters and setters in Python, though.<br/>    @property<br/>    def age(self):<br/>        return self._age<br/><br/>    # This allows the property to be set<br/>    @age.setter<br/>    def age(self, age):<br/>        self._age = age<br/><br/>    # This allows the property to be deleted<br/>    @age.deleter<br/>    def age(self):<br/>        del self._age</span></pre><p id="4fb9" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">让我们看看如何初始化和使用一个类。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="db1f" class="kg kh iy lj b gy ln lo l lp lq"># When a Python interpreter reads a source file it executes all its code.<br/># This __name__ check makes sure this code block is only executed when this<br/># module is the main program.<br/>if __name__ == '__main__':<br/>    # Instantiate a class<br/>    i = Human(name="Ian")<br/>    i.say("hi")                     # "Ian: hi"<br/>    j = Human("Joel")<br/>    j.say("hello")                  # "Joel: hello"<br/>    # i and j are instances of type Human, or in other words: they are Human objects<br/><br/>    # Call our class method<br/>    i.say(i.get_species())          # "Ian: H. sapiens"<br/>    # Change the shared attribute<br/>    Human.species = "H. neanderthalensis"<br/>    i.say(i.get_species())          # =&gt; "Ian: H. neanderthalensis"<br/>    j.say(j.get_species())          # =&gt; "Joel: H. neanderthalensis"<br/><br/>    # Call the static method<br/>    print(Human.grunt())            # =&gt; "*grunt*"<br/><br/>    # Cannot call static method with instance of object <br/>    # because i.grunt() will automatically put "self" (the object i) as an argument<br/>    print(i.grunt())                # =&gt; TypeError: grunt() takes 0 positional arguments but 1 was given<br/><br/>    # Update the property for this instance<br/>    i.age = 42<br/>    # Get the property<br/>    i.say(i.age)                    # =&gt; "Ian: 42"<br/>    j.say(j.age)                    # =&gt; "Joel: 0"<br/>    # Delete the property<br/>    del i.age<br/>    # i.age                         # =&gt; this would raise an AttributeError</span></pre><h1 id="675b" class="lr kh iy bd ki ls lt lu kl lv lw lx ko ly lz ma kr mb mc md ku me mf mg kx mh bi translated">继承</h1><p id="9c0d" class="pw-post-body-paragraph iw ix iy iz b ja kz jc jd je la jg jh ji lb jk jl jm lc jo jp jq ld js jt ju ig bi translated">继承可以让子类继承公共函数和属性，此外，我们还可以实现或覆盖子类的新函数或属性。</p><p id="c032" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">通常，我们会将不同的类存储在不同的文件夹中，并使用“导入”操作来导入。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="aa6a" class="kg kh iy lj b gy ln lo l lp lq">from human import Human<br/><br/><br/># Specify the parent class(es) as parameters to the class definition<br/>class Superhero(Human):<br/><br/>    # If the child class should inherit all of the parent's definitions without<br/>    # any modifications, you can just use the "pass" keyword (and nothing else)<br/>    # but in this case it is commented out to allow for a unique child class:<br/>    # pass<br/><br/>    # Child classes can override their parents' attributes<br/>    species = 'Superhuman'<br/><br/>    # Children automatically inherit their parent class's constructor including<br/>    # its arguments, but can also define additional arguments or definitions<br/>    # and override its methods such as the class constructor.<br/>    # This constructor inherits the "name" argument from the "Human" class and<br/>    # adds the "superpower" and "movie" arguments:<br/>    def __init__(self, name, movie=False,<br/>                 superpowers=["super strength", "bulletproofing"]):<br/><br/>        # add additional class attributes:<br/>        self.fictional = True<br/>        self.movie = movie<br/>        # be aware of mutable default values, since defaults are shared<br/>        self.superpowers = superpowers<br/><br/>        # The "super" function lets you access the parent class's methods<br/>        # that are overridden by the child, in this case, the __init__ method.<br/>        # This calls the parent class constructor:<br/>        super().__init__(name)<br/><br/>    # override the sing method<br/>    def sing(self):<br/>        return 'Dun, dun, DUN!'<br/><br/>    # add an additional instance method<br/>    def boast(self):<br/>        for power in self.superpowers:<br/>            print("I wield the power of {pow}!".format(pow=power))</span><span id="32f2" class="kg kh iy lj b gy mj lo l lp lq">if __name__ == '__main__':<br/>    sup = Superhero(name="Tick")<br/><br/>    # Instance type checks<br/>    if isinstance(sup, Human):<br/>        print('I am human')<br/>    # 检查类型<br/>    if type(sup) is Superhero:<br/>        print('I am a superhero')<br/><br/>    # Get the Method Resolution search Order used by both getattr() and super()<br/>    # This attribute is dynamic and can be updated<br/>    print(Superhero.__mro__)    # =&gt; (&lt;class '__main__.Superhero'&gt;,<br/>                                # =&gt; &lt;class 'human.Human'&gt;, &lt;class 'object'&gt;)<br/><br/>    # Calls parent method but uses its own class attribute<br/>    print(sup.get_species())    # =&gt; Superhuman<br/><br/>    # Calls overridden method<br/>    print(sup.sing())           # =&gt; Dun, dun, DUN!<br/><br/>    # Calls method from Human<br/>    sup.say('Spoon')            # =&gt; Tick: Spoon<br/><br/>    # Call method that exists only in Superhero<br/>    sup.boast()                 # =&gt; I wield the power of super strength!<br/>                                # =&gt; I wield the power of bulletproofing!<br/><br/>    # Inherited class attribute<br/>    sup.age = 31<br/>    print(sup.age)              # =&gt; 31<br/><br/>    # Attribute that only exists within Superhero<br/>    print('Am I Oscar eligible? ' + str(sup.movie))</span></pre><h2 id="9654" class="kg kh iy bd ki kj kk dn kl km kn dp ko ji kp kq kr jm ks kt ku jq kv kw kx ky bi translated">多重继承</h2><p id="f7cf" class="pw-post-body-paragraph iw ix iy iz b ja kz jc jd je la jg jh ji lb jk jl jm lc jo jp jq ld js jt ju ig bi translated">首先，我们构建一个Bat类。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="4056" class="kg kh iy lj b gy ln lo l lp lq"># Another class definition<br/># bat.py<br/>class Bat:<br/><br/>    species = 'Baty'<br/><br/>    def __init__(self, can_fly=True):<br/>        self.fly = can_fly<br/><br/>    # This class also has a say method<br/>    def say(self, msg):<br/>        msg = '... ... ...'<br/>        return msg<br/><br/>    # And its own method as well<br/>    def sonar(self):<br/>        return '))) ... ((('<br/><br/>if __name__ == '__main__':<br/>    b = Bat()<br/>    print(b.say('hello'))<br/>    print(b.fly)</span></pre><p id="5eee" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">然后我们为蝙蝠侠建立一个类，它继承了蝙蝠和超级英雄。它将拥有蝙蝠和超级英雄的所有属性。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="817a" class="kg kh iy lj b gy ln lo l lp lq"># And yet another class definition that inherits from Superhero and Bat<br/># superhero.py<br/>from superhero import Superhero<br/>from bat import Bat<br/><br/># Define Batman as a child that inherits from both Superhero and Bat<br/>class Batman(Superhero, Bat):<br/><br/>    def __init__(self, *args, **kwargs):<br/>        # Typically to inherit attributes you have to call super:<br/>        # super(Batman, self).__init__(*args, **kwargs)      <br/>        # However we are dealing with multiple inheritance here, and super()<br/>        # only works with the next base class in the MRO list.<br/>        # So instead we explicitly call __init__ for all ancestors.<br/>        # The use of *args and **kwargs allows for a clean way to pass arguments,<br/>        # with each parent "peeling a layer of the onion".<br/>        Superhero.__init__(self, 'anonymous', movie=True, <br/>                           superpowers=['Wealthy'], *args, **kwargs)<br/>        Bat.__init__(self, *args, can_fly=False, **kwargs)<br/>        # override the value for the name attribute<br/>        self.name = 'Sad Affleck'<br/><br/>    # overwrite the sing function of parent class<br/>    def sing(self):<br/>        return 'nan nan nan nan nan batman!'</span><span id="e0b6" class="kg kh iy lj b gy mj lo l lp lq">if __name__ == '__main__':<br/>    sup = Batman()<br/><br/>    # Get the Method Resolution search Order used by both getattr() and super().<br/>    # This attribute is dynamic and can be updated<br/>    print(Batman.__mro__)       # =&gt; (&lt;class '__main__.Batman'&gt;, <br/>                                # =&gt; &lt;class 'superhero.Superhero'&gt;, <br/>                                # =&gt; &lt;class 'human.Human'&gt;, <br/>                                # =&gt; &lt;class 'bat.Bat'&gt;, &lt;class 'object'&gt;)<br/><br/>    # Calls parent method but uses its own class attribute<br/>    print(sup.get_species())    # =&gt; Superhuman<br/><br/>    # Calls overridden method<br/>    print(sup.sing())           # =&gt; nan nan nan nan nan batman!<br/><br/>    # Calls method from Human, because inheritance order matters<br/>    sup.say('I agree')          # =&gt; Sad Affleck: I agree<br/><br/>    # Call method that exists only in 2nd ancestor<br/>    print(sup.sonar())          # =&gt; ))) ... (((<br/><br/>    # Inherited class attribute<br/>    sup.age = 100<br/>    print(sup.age)              # =&gt; 100<br/><br/>    # Inherited attribute from 2nd ancestor whose default value was overridden.<br/>    print('Can I fly? ' + str(sup.fly)) # =&gt; Can I fly? False</span></pre><h1 id="c570" class="lr kh iy bd ki ls lt lu kl lv lw lx ko ly lz ma kr mb mc md ku me mf mg kx mh bi translated">先进的</h1><h2 id="83d3" class="kg kh iy bd ki kj kk dn kl km kn dp ko ji kp kq kr jm ks kt ku jq kv kw kx ky bi translated">发电机</h2><p id="555c" class="pw-post-body-paragraph iw ix iy iz b ja kz jc jd je la jg jh ji lb jk jl jm lc jo jp jq ld js jt ju ig bi translated">我们可以通过使用“yield”关键字来构建一个生成器。每次当我们调用一个生成器时，它会在“yield”处停止，并在再次被调用时从同一位置恢复。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="fd00" class="kg kh iy lj b gy ln lo l lp lq"># Generators help you make lazy code.<br/>def double_numbers(iterable):<br/>    for i in iterable:<br/>        yield i + i<br/><br/># Generators are memory-efficient because they only load the data needed to<br/># process the next value in the iterable. This allows them to perform<br/># operations on otherwise prohibitively large value ranges.<br/># NOTE: `range` replaces `xrange` in Python 3.<br/>for i in double_numbers(range(1, 900000000)):  # `range` is a generator.<br/>    print(i)<br/>    if i &gt;= 30:<br/>        break</span></pre><p id="a125" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">除了使用yield，我们还可以使用括号来生成生成器。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="711e" class="kg kh iy lj b gy ln lo l lp lq"># Just as you can create a list comprehension, you can create generator<br/># comprehensions as well.<br/>values = (-x for x in [1,2,3,4,5])<br/>for x in values:<br/>    print(x)  # prints -1 -2 -3 -4 -5 to console/terminal<br/><br/># You can also cast a generator comprehension directly to a list.<br/>values = (-x for x in [1,2,3,4,5])<br/>gen_to_list = list(values)<br/>print(gen_to_list)  # =&gt; [-1, -2, -3, -4, -5]</span></pre><h2 id="9a51" class="kg kh iy bd ki kj kk dn kl km kn dp ko ji kp kq kr jm ks kt ku jq kv kw kx ky bi translated">装饰者</h2><p id="069e" class="pw-post-body-paragraph iw ix iy iz b ja kz jc jd je la jg jh ji lb jk jl jm lc jo jp jq ld js jt ju ig bi translated">从functools导入包装后，我们可以构建一个装饰器。装饰者可以在不修改代码的情况下扩展功能。就像为一个‘功能’做一些装饰一样。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="f7eb" class="kg kh iy lj b gy ln lo l lp lq"># Decorators<br/># In this example `beg` wraps `say`. If say_please is True then it<br/># will change the returned message.<br/>from functools import wraps<br/><br/><br/>def beg(target_function):<br/>    @wraps(target_function)<br/>    # if please is True，Print Please! I am poor :(<br/>    def wrapper(*args, **kwargs):<br/>        msg, say_please = target_function(*args, **kwargs)<br/>        if say_please:<br/>            return "{} {}".format(msg, "Please! I am poor :(")<br/>        return msg<br/><br/>    return wrapper<br/><br/><br/>@beg<br/>def say(say_please=False):<br/>    msg = "Can you buy me a beer?"<br/>    return msg, say_please<br/><br/><br/>print(say())                 # Can you buy me a beer?<br/>print(say(say_please=True))  # Can you buy me a beer? Please! I am poor :(</span></pre><h2 id="0c3d" class="kg kh iy bd ki kj kk dn kl km kn dp ko ji kp kq kr jm ks kt ku jq kv kw kx ky bi translated">结论</h2><p id="8923" class="pw-post-body-paragraph iw ix iy iz b ja kz jc jd je la jg jh ji lb jk jl jm lc jo jp jq ld js jt ju ig bi translated">我不知道你们中有多少人会读这篇文章，把Python的大部分用法压缩成一篇文章真的很酷。如果你能理解所有这些，你将被认为是一个好的Python用户。</p><p id="f057" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">如果你有其他语言的经验，我想这对你来说并不难。而且我认为你可能会付出超过30分钟的时间，当然，在30分钟内学会一门编程语言是可能的，不推荐。但至少你可以对Python熟悉一点。</p><p id="c07d" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">祝你Python和编程之旅一路顺风，好运！</p></div></div>    
</body>
</html>