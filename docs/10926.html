<html>
<head>
<title>In that Programming Rut…</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在这种编程模式下…</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/in-that-programming-rut-65600125e010?source=collection_archive---------9-----------------------#2022-12-07">https://blog.devgenius.io/in-that-programming-rut-65600125e010?source=collection_archive---------9-----------------------#2022-12-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/97d9aaebcf3224c0875aa1a6abc72b57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*q2-XaHr3TTjMt6KX"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@dearjamie?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杰米·哈根</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="597d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你是否曾经陷入编程的窠臼，发现自己为每个项目都以同样的方式编写代码；作为一名工程师，你觉得自己没有学习，甚至没有拓展自己的能力？</p><p id="f1d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我确实有。</p><p id="2aa1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">事实上，我觉得我现在很单调。这就像我的实验风格的个性已经消失了，每天都可以在我的代码中看到。我承认，经过 20 多年的经验和试验，我已经对软件设计和架构(尤其是商业应用程序)有了一个相当坚实的方法。然而，它确实开始让你怀疑你是否已经达到了极限，或者你只是在你的能力中找到了一个舒适的确定水平。</p><p id="80dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不久前我写了一篇名为<a class="ae kc" href="https://medium.com/dev-genius/the-true-way-to-software-mastery-64dc0bf8a2f8" rel="noopener">掌握软件的真正方法</a>的文章，其中我谈到了成为软件大师的想法。虽然，我觉得我已经赢得了我在软件设计和架构领域的同事们的尊重，但是你永远也不能确定。事实上，我们不应该拿今天的自己和其他人比较，而应该拿今天的自己和昨天的自己比较。所以当我把今天的自己和昨天的自己比较时，没有太大的变化…这就是惯例。</p><h1 id="e8b1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">我现在的车辙(。NET C#)</h1><p id="e7f8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我发现自己为每个项目一遍又一遍地做着同样的事情。以下是我似乎反复重复的一些项目。</p><h2 id="ed5f" class="me lc iq bd ld mf mg dn lh mh mi dp ll ko mj mk lp ks ml mm lt kw mn mo lx mp bi translated">接口设计</h2><p id="1f86" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我构建了我所能构建的最简单的接口，并使它们总是局限于 singleton(从阿迪的角度来看)。我甚至会不遗余力地去做这件事。举个例子，</p><pre class="mq mr ms mt gt mu mv mw bn mx my bi"><span id="02a9" class="mz lc iq mv b be na nb l nc nd">public interface IWorkflowContextAccessor<br/>{<br/>    IWorkflowContext Current { get; }<br/>}</span></pre><p id="76cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个接口类似于<code class="fe ne nf ng mv b">IHttpContextAccessor</code>，允许我从任何其他类中获取这个上下文。然而，对于一个 ASP.NET 应用程序，我可以像注入一个作用域依赖一样简单地注入<code class="fe ne nf ng mv b">IWorkflowContext</code>,然后动态地确定它。</p><p id="177b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">我的推理</strong>:单例范围的依赖可以注入到所有的 DI 依赖范围(瞬态、范围和单例)。但是反过来就不对了。对我来说，这降低了记忆哪些服务可以被注入到哪些类中的认知负荷。</p><p id="db78" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，函数需要的所有东西都必须通过方法参数传递，并限制有状态类的使用，这很有用。</p><h2 id="2179" class="me lc iq bd ld mf mg dn lh mh mi dp ll ko mj mk lp ks ml mm lt kw mn mo lx mp bi translated">扩展一切</h2><p id="ae49" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我有一个习惯，用 C#为所有东西创建扩展方法。我使用最小的接口设计使新的实现更容易，同时允许更复杂的逻辑存在于其他地方。</p><p id="180c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是我可能创建的一个示例存储库接口:</p><pre class="mq mr ms mt gt mu mv mw bn mx my bi"><span id="655d" class="mz lc iq mv b be na nb l nc nd">public interface IRepository&lt;T&gt; where T : Model<br/>{<br/>   Task UpsertAsync(T model);<br/>   Task DeleteAsync(Identifier id, Identifier? scopeId = null);<br/>   Task&lt;T[]&gt; FindAsync(ExactMatchQuery query);<br/>}<br/><br/>public abstract class Model<br/>{<br/>   public Identifier Id { get; set; } = Identifier.Empty;<br/>   public Identifier ScopeId { get; set; } = Identifier.Empty;<br/>   public string Name { get; set; } = string.Empty;<br/>   public string Description { get; set; } = string.Empty;<br/>   public DateTime CreatedTimestamp { get; set; } = DateTime.UtcNow;<br/><br/>   public Dictionary&lt;string, string&gt; Properties { get; set; } = new Dictionary&lt;string, string&gt;();<br/>}<br/><br/>public class ExactMatchQuery<br/>{<br/>    public Identifier? Id { get; set; }<br/>    public Identifier? ScopeId { get; set; }<br/>    public string? Name { get; set; }<br/>    public string? Description { get; set; }<br/><br/>    public DateTime? MinimumCreatedTimestamp { get; set; }<br/>    public DateTime? MaximumCreatedTimestamp { get; set; }<br/>    <br/>    public int Offset { get; set; } = 0;<br/>    public int Limit { get; set; } = 10;<br/>}</span></pre><p id="4d48" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我会到处使用扩展来做非常具体的工作:</p><pre class="mq mr ms mt gt mu mv mw bn mx my bi"><span id="f67c" class="mz lc iq mv b be na nb l nc nd">public static class RepositoryFindExtensions<br/>{<br/>    Task&lt;T?&gt; FindByIdAsync&lt;T&gt;(this IRepository&lt;T&gt; repository, Identifier id, Identifier? scopeId = null) where T : Model<br/>    {<br/>        var found = await repository.FindAsync(new ExactMatchQuery<br/>        {<br/>            Id = id,<br/>            ScopeId = scopeId<br/>        };<br/><br/>        return found.FirstOrDefault();<br/>    }<br/>}</span></pre><p id="1b83" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">我的理由</strong>:如果你适当地抽象，你可以用简单的接口做很多事情，而不必将它们直接嵌入接口本身。这使得未来的实现具有更少的需求，从而允许这些扩展在任何实现中重用。</p><p id="429f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是现在逻辑在主存储库类之外。如果没有像 Visual Studio 或 VSCode 这样的好的 IDE，那么祝你好运。这种分离可能会让初级开发人员感到困惑。</p><h2 id="6764" class="me lc iq bd ld mf mg dn lh mh mi dp ll ko mj mk lp ks ml mm lt kw mn mo lx mp bi translated">装饰大厅的装饰物</h2><p id="85ab" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">还有一种叫做装饰者的设计模式，我发现自己一直在使用它。我喜欢动态添加功能的能力，所以我创建了接口层，以允许添加新代码，而不是更改旧代码。</p><pre class="mq mr ms mt gt mu mv mw bn mx my bi"><span id="995a" class="mz lc iq mv b be na nb l nc nd">public interface ISqlExecutor<br/>{<br/>    Task&lt;T&gt; ExecuteAsync&lt;T&gt;(Func&lt;ISqlConnection, ISqlTransaction, T&gt; execute);<br/>}</span></pre><p id="9303" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我至少有两个实现。一个用于我的主执行者，一个用于性能监控。当然，在一个典型的场景中，我通常会有更多。</p><pre class="mq mr ms mt gt mu mv mw bn mx my bi"><span id="7965" class="mz lc iq mv b be na nb l nc nd">public sealed class SqlServerExecutor : ISqlExecutor<br/>{<br/>    public SqlServerExecutor(...) { }<br/><br/>    public async Task&lt;T&gt; ExecuteAsync&lt;T&gt;(Func&lt;ISqlConnection, ISqlTransaction, T&gt; execute)<br/>    {<br/>        using (var sqlConnection = new SqlConnection(...))<br/>        {<br/>            await sqlConnection.OpenAsync();<br/>            using (var sqlTransaction = sqlConnection.BeginTransaction())<br/>            {<br/>                var results = await execute(sqlConnection, sqlTransaction);<br/>                sqlTransaction.Commit();<br/>                return results;<br/>            }<br/>        }<br/>    }<br/>}<br/><br/>public sealed class PerformanceMonitoringSqlExecutor : ISqlExecutor<br/>{<br/>    private readonly ISqlExecutor _innerExecutor;<br/>    <br/>    public PerformanceMonitoringSqlExecutor(ISqlExecutor inner)<br/>    {<br/>        _innerExecutor = inner ?? throw new ArgumentNullException(nameof(inner));<br/>    }<br/><br/>    public async Task&lt;T&gt; ExecuteAsync&lt;T&gt;(Func&lt;ISqlConnection, ISqlTransaction, T&gt; execute)<br/>    {<br/>        var watch = StopWatch.StartNew();<br/>        var results = await _innerExecutor(execute);<br/>        watch.Stop();<br/>        <br/>        // TODO: Log these results somewhere<br/>        <br/>        return results;<br/>    }<br/>}</span></pre><p id="e4e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">我的理由</strong>:这允许我根据配置或其他方法(即 A/B 测试)动态地建立我的需求。这样，我可以避免每个实现中的直接特性标志和臃肿的代码，如日志语句。此外，当新的实现出现时，我不一定需要将这些代码复制到每个实现中。</p><p id="add2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是现在代码更加复杂，很难推理，尤其是如果你看到的只是核心业务逻辑中的接口。你怎么知道有东西被记录了呢？有很多样板文件可以让年轻的开发人员容易阅读。</p><h1 id="9a0a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">解药？</h1><p id="f300" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">据我所知，我上面所做的一切都不一定是坏的或糟糕的实践。这真的取决于你工作的环境。然而，我这么做已经很多年了；所有新项目都是如此。我来到这里是因为那些年的实验。我尝试了各种技术，去掉了那些让事情变得更糟的技术。但是“更糟”是什么意思呢？</p><h2 id="b4d0" class="me lc iq bd ld mf mg dn lh mh mi dp ll ko mj mk lp ks ml mm lt kw mn mo lx mp bi translated">爆发</h2><p id="85fb" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">要打破常规，你首先需要知道你作为程序员的价值观是什么。你看重的是什么？以及你如何判断你自己的代码(你的度量标准是什么；无论主观还是客观)？</p><p id="ea2d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我有自己的一套衡量标准来评估这些情况:</p><ul class=""><li id="429b" class="nh ni iq kf b kg kh kk kl ko nj ks nk kw nl la nm nn no np bi translated"><strong class="kf ir">可读性</strong>:现在和将来负责编写这段代码的团队是否理解这段代码，在哪里找到它，以及它是如何工作的？如果没有，还需要做更多的工作。</li><li id="9249" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated"><strong class="kf ir">可维护性</strong>:我能最大限度地减少这段代码被触碰的次数吗？例如，通过使用 decorators，我可以消除更改实现代码的需要。相反，我可以用一种附加的方式为新功能创建新的实现。</li><li id="9f4a" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated"><strong class="kf ir">可重用性</strong>:这段代码被抽象了多少？我可以用我生成的代码最小化我未来的样板代码吗？是不是在一个库中，我可以用于未来的项目，在未来的开发中节省时间。</li><li id="449e" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated"><strong class="kf ir">灵活性</strong>:当需求改变时，如果有的话，需要改变多少代码？可以使用特征标志(或者装饰符)吗？或者我可以创建一个简单的实现来替换当前的实现吗？通过创建扩展点，当不可避免地添加或更改特性时，我提供了灵活性。</li></ul><p id="26f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，还有更多，但这些是我的首要目标。我相信在最近几个月，我已经停止问自己这些问题，并导致这种车辙形成。</p><p id="fbba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现实情况是，软件永远不会在所有这些方面同时完美。在平衡这些软件质量时，需要进行权衡。因此，我对这些品质的优先级的衡量会影响我的代码的发展方向。接下来的问题是，我赋予这些品质的优先级或权重是什么？</p><p id="d78b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我真的没有这个问题的答案，但是我相信对于任何一个有身份的开发者来说，他们必须首先定义他们想要达到的软件质量。然后，他们必须优先考虑这些品质，以优化他们的标准。这就是我所说的你的<strong class="kf ir">程序员身份</strong>。这种身份被用来衡量你和你自己，以及潜在的雇主。我认为，这是程序员被雇主拒绝的时候。如果组织和开发人员的身份没有明显的重叠，那么程序员注定会在他/她的职位上失败。不是因为任何技巧上的原因，而是因为他对软件固有的个性。</p></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><p id="c880" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我会继续寻找，找到摆脱这种困境的方法。谢谢你倾听我的咆哮。如果你有什么建议，尽管提出来。</p><p id="fb12" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下次见！</p></div></div>    
</body>
</html>