<html>
<head>
<title>3 Effective Java Features You Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你应该知道的3个有效的Java特性</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/3-effective-java-features-to-tune-your-java-app-performance-c85c3f77f15c?source=collection_archive---------3-----------------------#2021-05-26">https://blog.devgenius.io/3-effective-java-features-to-tune-your-java-app-performance-c85c3f77f15c?source=collection_archive---------3-----------------------#2021-05-26</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="ae10" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated"><strong class="ak">冥想者应该知道的3个有效的Java 9特性</strong></h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/c86ad1b47b06329350f7d7a8cd9fe920.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KL-zy41WRWh0PvNWIcDJRA.jpeg"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated">由<a class="ae kw" href="https://unsplash.com/@waddasmagalhaes?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">瓦达什·马加良斯</a>在<a class="ae kw" href="https://unsplash.com/s/photos/developer-working?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="3cfc" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">您缺少关于HTTP请求的文档。你在接口中有许多复制粘贴的但是通用的代码。你创建列表，但不知道哪一个是最好的。</p><p id="24df" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我写了很多Java 8代码。这些是我的主要障碍。升级到Java 11后，这些问题消失了<em class="lt">。</em></p><p id="9af0" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这里是你应该知道的解决常见Java 8问题的三个有效特性。</p><pre class="kh ki kj kk gu lu lv lw lx aw ly bi"><span id="e217" class="lz ma ir lv b gz mb mc l md me">· 1. <a class="ae kw" href="#9f80" rel="noopener ugc nofollow">Convenience factory methods for collections (JEP-269)</a><br/>  ∘ <a class="ae kw" href="#0f3d" rel="noopener ugc nofollow">Problem</a><br/>  ∘ <a class="ae kw" href="#47b6" rel="noopener ugc nofollow">Research</a><br/>  ∘ <a class="ae kw" href="#8386" rel="noopener ugc nofollow">Findings</a><br/>· 2. <a class="ae kw" href="#011d" rel="noopener ugc nofollow">Private interface methods (JEP-213)</a><br/>  ∘ <a class="ae kw" href="#ab6b" rel="noopener ugc nofollow">Problem</a><br/>  ∘ <a class="ae kw" href="#8d9a" rel="noopener ugc nofollow">Research</a><br/>  ∘ <a class="ae kw" href="#966a" rel="noopener ugc nofollow">Findings</a><br/>· 3. <a class="ae kw" href="#bb73" rel="noopener ugc nofollow">Carving way for newer HTTP clients (JEP-110)</a><br/>  ∘ <a class="ae kw" href="#b10d" rel="noopener ugc nofollow">Problem</a><br/>  ∘ <a class="ae kw" href="#7c6e" rel="noopener ugc nofollow">Research</a><br/>  ∘ <a class="ae kw" href="#ad6d" rel="noopener ugc nofollow">Findings</a><br/>· <a class="ae kw" href="#e2ca" rel="noopener ugc nofollow">Takeaway</a><br/>· <a class="ae kw" href="#eca9" rel="noopener ugc nofollow">References</a></span></pre></div><div class="ab cl mf mg hv mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ik il im in io"><h1 id="9f80" class="mm ma ir bd mn mo mp mq mr ms mt mu mv jx mw jy mx ka my kb mz kd na ke nb nc bi translated">1.集合的便利工厂方法<a class="ae kw" href="https://openjdk.java.net/jeps/269" rel="noopener ugc nofollow" target="_blank"> (JEP-269) </a></h1><h2 id="0f3d" class="lz ma ir bd mn nd ne dn mr nf ng dp mv lg nh ni mx lk nj nk mz lo nl nm nb nn bi translated">问题</h2><p id="eb64" class="pw-post-body-paragraph kx ky ir kz b la no js lc ld np jv lf lg nq li lj lk nr lm ln lo ns lq lr ls ik bi translated"><em class="lt">定义库API，以便用少量元素创建集合和映射的实例。减轻Java编程语言中没有集合文字的痛苦。— </em> <a class="ae kw" href="https://openjdk.java.net/jeps/269" rel="noopener ugc nofollow" target="_blank"> <em class="lt">来源</em> </a></p><p id="2d29" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在Java 8中，没有方便的方法来创建小集合。尽管有很多带有帮助方法的库。当你有很多选择时会发生什么？许多选项被随意挑选，导致不一致的代码实践。较新的Java版本如何解决这个问题？它们增加了一种简单、方便、高效的创建集合的方式。</p><pre class="kh ki kj kk gu lu lv lw lx aw ly bi"><span id="c547" class="lz ma ir lv b gz mb mc l md me">// new way to create collections<br/>Set&lt;String&gt; set = Set.of("a", "b", "c");</span></pre><p id="a5cb" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">另一个问题。<em class="lt">冗长</em>。向集合中添加元素伴随着高冗长级别。更多的冗长——更多的样板代码。<em class="lt">Java 9如何减少冗长？Java 9提供了简单的集合创建方法。在Java 9之前，许多样板文件创建了一个简单的集合。</em></p><p id="b07d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这是研究和性能测试的结果。</p></div><div class="ab cl mf mg hv mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ik il im in io"><h2 id="47b6" class="lz ma ir bd mn nd ne dn mr nf ng dp mv lg nh ni mx lk nj nk mz lo nl nm nb nn bi translated">研究</h2><p id="3f42" class="pw-post-body-paragraph kx ky ir kz b la no js lc ld np jv lf lg nq li lj lk nr lm ln lo ns lq lr ls ik bi translated">这是我对JEP-269的补充。我们将使用基准测试,并看到JEP-269加速小型集合处理。</p><p id="69e3" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><em class="lt">基准</em> <a class="ae kw" href="https://gist.githubusercontent.com/zivce/8f2a3d3be193eac2a00118640407b016/raw/a87761365cca16fc3294938f4817a6d031239cbd/jep-269-benchmark.java" rel="noopener ugc nofollow" target="_blank"> <em class="lt">要旨</em> </a> <em class="lt">是什么？</em>创建收藏的方式不多。当您有一个简单的模型<code class="fe nt nu nv lv b">Cat</code>时，您需要将它们添加到一个<code class="fe nt nu nv lv b">catsNonJava9Way</code>中。实例化每一个并在循环中添加它们。当模型很简单，只有一个字符串时，可以删除实例。这就是<code class="fe nt nu nv lv b">catsJava8Way</code>。<code class="fe nt nu nv lv b">catsJava9Way</code>展示了一种更新的Java方式。</p><p id="9842" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><em class="lt">下面是较新的Java如何改进小型集合。</em></p></div><div class="ab cl mf mg hv mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ik il im in io"><p id="efae" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">Java 9方法的吞吐量更好。没有临时对象的创建。平均时间也是如此。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj nw"><img src="../Images/72004a0d75f8fa6d1f99237a47ef76aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qo1kARyaAD58fljp6W-D7g.png"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated">Java 9方法的吞吐量要好几百倍</figcaption></figure><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj nw"><img src="../Images/5bbee12abd9facf2633454921bca19fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UQEAwy7O8PnbqCjo903zPA.png"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated">Java 9方法的平均时间也要好几百倍</figcaption></figure></div><div class="ab cl mf mg hv mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ik il im in io"><p id="c645" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><em class="lt">是什么减缓了以前的Java方法？临时对象分配。</em>三分之二的时间花在创造物体上。移除<code class="fe nt nu nv lv b">new Cat</code>变量可以加快执行速度。避免使用临时变量。分配、垃圾收集和分配它们需要时间。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj nx"><img src="../Images/d18b5df07270f32ddada3fd29289f29c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wq7WMfqJoHhQEWbpCpNTVQ.png"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated">删除不必要的变量后</figcaption></figure></div><div class="ab cl mf mg hv mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ik il im in io"><p id="0521" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">Brian Goetz认为Java 8方法弊大于利。会损害代码的可读性和吞吐量，但不会影响平均时间。</p><p id="45c4" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我们来做个对比。经过基准测试，Java 9的平均时间并没有超过Java 8。<em class="lt">平均时间可以忽略不计，因为它要慢几倍。</em></p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj ny"><img src="../Images/2b080aad201a347369c80148f5f572d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QXWdOn_H3d34m2OmhMRuDQ.png"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated">Java 8在平均时间上优于Java 9</figcaption></figure><p id="9f81" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">Java 9比Java 8有更好的吞吐量。这意味着Java 9比Java 8每秒处理更多的运算。吞吐量显示的差异可以忽略不计。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj ny"><img src="../Images/5144523ad4b451d3ab740282f8294e06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zv6RYwpOpUUHhTu0DKi2Lw.png"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated">Java 9的吞吐量胜过Java 8</figcaption></figure><p id="c879" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><em class="lt">结论是什么？</em>根据性能挑选Java 9或者Java 8没有意义。他们都表现得很好。你应该选择让代码更干净的东西。选择权在你。</p><pre class="kh ki kj kk gu lu lv lw lx aw ly bi"><span id="ad65" class="lz ma ir lv b gz mb mc l md me">cats8 = Collections.unmodifiableList(Stream.of("George", "John", "Mack", "Other", "Lorem").collect(Collectors.toList()));<br/>// or this one<br/>cats9 = List.of("George", "John", "Mack", "Other", "Lorem");</span></pre><p id="87fb" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">默认情况下，IntelliJ建议一种更干净的方式。创建收藏的更简洁方式。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj nz"><img src="../Images/70075b7842320b6a01594da22a58e53a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LU96HpWjwv0GWQpbBO_VgA.png"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated">IntelliJ通知使用Java 9方法</figcaption></figure></div><div class="ab cl mf mg hv mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ik il im in io"><p id="3738" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><em class="lt">在更大的集合上提供高性能不是我们的目标。重点是小集合。— </em> <a class="ae kw" href="https://openjdk.java.net/jeps/269" rel="noopener ugc nofollow" target="_blank"> <em class="lt">来源</em> </a></p><p id="e601" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">JEP-269并不关注大型收藏。这不是目标。下面是我用来证明这一点的基准。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="oa ob l"/></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated">JEP-269的非目标—基准</figcaption></figure><p id="0e70" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><em class="lt">对于更大的集合，Java 8的性能优于Java 9。</em></p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj oc"><img src="../Images/ef83b980e7873a9ec50d34364c08a603.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5CiC7cKG17Cq1C8xZ5OcJw.png"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated">Java 8甚至比Java 9+方法表现得更好</figcaption></figure><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj od"><img src="../Images/bd215d260d0889a589f60baf237048f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*KEgkk04ELTv_4NwFp5bw5w.png"/></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated"><a class="ae kw" href="https://www.manypixels.co/gallery" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure></div><div class="ab cl mf mg hv mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ik il im in io"><h2 id="8386" class="lz ma ir bd mn nd ne dn mr nf ng dp mv lg nh ni mx lk nj nk mz lo nl nm nb nn bi translated">调查的结果</h2><p id="f36a" class="pw-post-body-paragraph kx ky ir kz b la no js lc ld np jv lf lg nq li lj lk nr lm ln lo ns lq lr ls ik bi translated">Java 9给出了一种清晰、简洁、高效的方法来创建集合。所有都遵循相同的API，例如<code class="fe nt nu nv lv b">List.of</code>，这使得它更容易使用。根据我的基准，<em class="lt">这将集合的创建速度提高了几百倍。</em></p><p id="8d40" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在Java 8中，更大的集合性能更好。这一变化的目标并不是为了改进大型集合的处理。在基准测试之后，我们看到非目标已经完成。<em class="lt">处理更大的集合没有任何改进。</em></p></div><div class="ab cl mf mg hv mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ik il im in io"><h1 id="011d" class="mm ma ir bd mn mo mp mq mr ms mt mu mv jx mw jy mx ka my kb mz kd na ke nb nc bi translated">2.私有接口方法<a class="ae kw" href="https://openjdk.java.net/jeps/213" rel="noopener ugc nofollow" target="_blank"> (JEP-213) </a></h1><h2 id="ab6b" class="lz ma ir bd mn nd ne dn mr nf ng dp mv lg nh ni mx lk nj nk mz lo nl nm nb nn bi translated">问题</h2><p id="22b5" class="pw-post-body-paragraph kx ky ir kz b la no js lc ld np jv lf lg nq li lj lk nr lm ln lo ns lq lr ls ik bi translated">在界面中使用复制粘贴技术。一遍又一遍地复制相似的代码。使用私有方法，您可以将共享代码放在私有方法中。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="oa ob l"/></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated">当你没有私有方法时复制粘贴</figcaption></figure><p id="fccf" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">Project Coin在Java 7中增加了一些小的增强。现在它被包括在爪哇的LTS中。检查<a class="ae kw" href="https://openjdk.java.net/jeps/213" rel="noopener ugc nofollow" target="_blank"> JEP-213 </a>以获得关于项目硬币的更多细节。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="oa ob l"/></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated">Java 9中的私有接口方法</figcaption></figure></div><div class="ab cl mf mg hv mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ik il im in io"><h2 id="8d9a" class="lz ma ir bd mn nd ne dn mr nf ng dp mv lg nh ni mx lk nj nk mz lo nl nm nb nn bi translated">研究</h2><p id="f01a" class="pw-post-body-paragraph kx ky ir kz b la no js lc ld np jv lf lg nq li lj lk nr lm ln lo ns lq lr ls ik bi translated">Java 9表现更好。我们现在有两个理由使用私有方法:</p><ul class=""><li id="f216" class="oe of ir kz b la lb ld le lg og lk oh lo oi ls oj ok ol om bi translated">表演</li><li id="e131" class="oe of ir kz b la on ld oo lg op lk oq lo or ls oj ok ol om bi translated">代码可读性</li></ul><p id="58e8" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">你可以查看这篇关于内联的文章。在频繁点击相同的方法后，相同的方法会变得<em class="lt">‘热’。</em>这使得编译器内联该方法，并且之后执行得更好。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj od"><img src="../Images/9ded8ae5b9f4985ca198234eb0a6d6db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*hSQah4Oo2UFpsFHy53u4ZQ.png"/></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated"><a class="ae kw" href="https://www.manypixels.co/gallery" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="dd85" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><em class="lt">为什么会导致性能提升？</em>拙见私有方法得到<em class="lt">‘热’</em>。这里是<a class="ae kw" href="https://gist.github.com/zivce/daedb06e70f1f85cd8f3a25c6dce55c5" rel="noopener ugc nofollow" target="_blank">的基准</a>结果。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj oc"><img src="../Images/a4d3e79740b83f1d41952c6f1bf1cfc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PZdHEAfvOPgQjqagWz3otg.png"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated">Java 9中的猫喵喵叫得更好</figcaption></figure><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj oc"><img src="../Images/ad53769674e982dcde80ab95ff8e3a34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uDbuH2jp8s2ZSVBWv4a_JA.png"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated">Java 9中的猫跑得更快一点</figcaption></figure></div><div class="ab cl mf mg hv mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ik il im in io"><h2 id="966a" class="lz ma ir bd mn nd ne dn mr nf ng dp mv lg nh ni mx lk nj nk mz lo nl nm nb nn bi translated">调查的结果</h2><p id="8297" class="pw-post-body-paragraph kx ky ir kz b la no js lc ld np jv lf lg nq li lj lk nr lm ln lo ns lq lr ls ik bi translated">使用私有接口方法可以创建简洁的接口。不存在相同代码的复制。<em class="lt">私有方法，持有共享代码，减少代码行数。</em></p><p id="8301" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">私有方法的另一个好处是性能。Java 9方法的吞吐量和平均时间更好。<em class="lt">私有方法变得“热门”,平均表现更好。</em></p></div><div class="ab cl mf mg hv mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ik il im in io"><h1 id="bb73" class="mm ma ir bd mn mo mp mq mr ms mt mu mv jx mw jy mx ka my kb mz kd na ke nb nc bi translated">3.新HTTP客户端的雕刻之路<a class="ae kw" href="https://openjdk.java.net/jeps/110" rel="noopener ugc nofollow" target="_blank"> (JEP-110) </a></h1><h2 id="b10d" class="lz ma ir bd mn nd ne dn mr nf ng dp mv lg nh ni mx lk nj nk mz lo nl nm nb nn bi translated">问题</h2><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj od"><img src="../Images/858d2272f2f63c9cb0636ee0d59df138.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*jnmkldm5lJvlB_zyxubCCQ.png"/></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated"><a class="ae kw" href="https://www.manypixels.co/gallery" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="8a58" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">Brian Goetz认为旧的HTTP请求已经过时了。JDK 1.1首先增加了对HTTP请求的支持。直到JDK 9，你可以使用弃用的Gopher和FTP。没有Java 9，HTTP客户端的效率会很低，因为它包含了很多不推荐使用的特性。</p><p id="42c0" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在Java 9之前，HTTP请求不支持HTTP/2。在未来的Java版本中，<a class="ae kw" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.net.http/java/net/http/HttpClient.html#newBuilder()" rel="noopener ugc nofollow" target="_blank"><em class="lt">HTTP Client</em></a><em class="lt">成为Java中事实上的HTTP客户端。</em></p><p id="adf6" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">旧的本地客户端速度慢，难以使用，并且缺乏文档。您仍然可以找到关于HTTP请求的<a class="ae kw" href="https://medium.com/r?url=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F2793150%2Fhow-to-use-java-net-urlconnection-to-fire-and-handle-http-requests" rel="noopener">活动堆栈溢出问题</a>。JEP-110为更好的<code class="fe nt nu nv lv b">HTTPClient</code>铺平了道路。</p></div><div class="ab cl mf mg hv mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ik il im in io"><h2 id="7c6e" class="lz ma ir bd mn nd ne dn mr nf ng dp mv lg nh ni mx lk nj nk mz lo nl nm nb nn bi translated">研究</h2><p id="7ff9" class="pw-post-body-paragraph kx ky ir kz b la no js lc ld np jv lf lg nq li lj lk nr lm ln lo ns lq lr ls ik bi translated">下面是如何使用新的<code class="fe nt nu nv lv b">HTTPUrlConnection</code>类。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="oa ob l"/></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated">旧方法——源自对Java 9的掌握，稍加修改</figcaption></figure><p id="1ac7" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这里是<em class="lt">孵化器</em>T2的新方法。如今，孵化中的<code class="fe nt nu nv lv b">HTTPClient</code>是<code class="fe nt nu nv lv b"><a class="ae kw" href="https://docs.oracle.com/en/java/javase/13/docs/api/java.net.http/java/net/http/package-summary.html" rel="noopener ugc nofollow" target="_blank">java.net.http</a></code>的一部分。</p><p id="f57c" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我们可以再查一下<a class="ae kw" href="https://stackoverflow.com/questions/2793150/how-to-use-java-net-urlconnection-to-fire-and-handle-http-requests" rel="noopener ugc nofollow" target="_blank">这个问题</a>。<a class="ae kw" href="https://stackoverflow.com/a/36932953/5999670" rel="noopener ugc nofollow" target="_blank">一个答案</a>脱颖而出。这是Java 9处理HTTP的方式。让我们比较一下公认的答案和这个答案。Java 9方法用更少的代码做更多的事情。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="oa ob l"/></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated"><a class="ae kw" href="https://stackoverflow.com/questions/2793150/how-to-use-java-net-urlconnection-to-fire-and-handle-http-requests/36932953#36932953" rel="noopener ugc nofollow" target="_blank">Java 9的答案</a></figcaption></figure></div><div class="ab cl mf mg hv mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ik il im in io"><p id="d0e6" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><code class="fe nt nu nv lv b">HTTPUrlConnection</code>没有异步。你需要<a class="ae kw" href="https://stackoverflow.com/questions/11790324/how-to-add-asynctask-in-an-httpurlconnection" rel="noopener ugc nofollow" target="_blank">绕过</a>让异步到位。随着新的<code class="fe nt nu nv lv b">HTTPClient</code>，这是内置的。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="oa ob l"/></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated"><a class="ae kw" href="https://docs.oracle.com/en/java/javase/13/docs/api/java.net.http/java/net/http/HttpClient.html" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure></div><div class="ab cl mf mg hv mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ik il im in io"><h2 id="ad6d" class="lz ma ir bd mn nd ne dn mr nf ng dp mv lg nh ni mx lk nj nk mz lo nl nm nb nn bi translated">调查的结果</h2><p id="a841" class="pw-post-body-paragraph kx ky ir kz b la no js lc ld np jv lf lg nq li lj lk nr lm ln lo ns lq lr ls ik bi translated"><code class="fe nt nu nv lv b"><a class="ae kw" href="https://docs.oracle.com/en/java/javase/13/docs/api/java.net.http/java/net/http/HttpClient.html" rel="noopener ugc nofollow" target="_blank">HTTPClient</a></code>是发出HTTP请求的新方式。支持更新的HTTP，创建简洁的代码，并且是最新的。</p><p id="e48d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><code class="fe nt nu nv lv b">HTTPClient</code>增加了对异步请求的本地支持。在以前的Java版本中，没有异步支持。<em class="lt">当没有本地支持时，开发人员会破解并创建不稳定的解决方案。</em></p></div><div class="ab cl mf mg hv mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ik il im in io"><h1 id="e2ca" class="mm ma ir bd mn mo mp mq mr ms mt mu mv jx mw jy mx ka my kb mz kd na ke nb nc bi translated">外卖食品</h1><p id="29d3" class="pw-post-body-paragraph kx ky ir kz b la no js lc ld np jv lf lg nq li lj lk nr lm ln lo ns lq lr ls ik bi translated">较新的Java带来了新的方便的方法来创建集合。重点是较小的集合，正如您在我们的性能测试中看到的。<em class="lt">使用Java 9静态工厂方法减少了冗长，并且性能更好。</em></p><p id="e35e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">私有接口方法对我们的接口有积极的影响。现在，您可以提取共享代码并重用它。随之而来的是<em class="lt">性能提升</em>，因为编译器更喜欢小的共享方法。</p><p id="f4cc" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">布莱恩·戈茨支持更新的<code class="fe nt nu nv lv b">HTTPClient</code>。这为异步请求铺平了道路。支持较新的HTTP版本。最终获得更好的开发者体验。</p><p id="61e0" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">即使在这些变化之后，<em class="lt">大多数人还是使用Java 8 </em>。你应该升级到Java 11，因为它也提供LTS。不仅仅是LTS，还有你在这篇文章中看到的所有特性。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj os"><img src="../Images/96beea9c22a87a6b0bc6bf786a3c2855.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tF0mJPVewKOf1A64.png"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated"><a class="ae kw" href="https://snyk.io/blog/developers-dont-want-to-leave-java-8-as-64-hold-firm-on-their-preferred-release/" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure></div><div class="ab cl mf mg hv mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ik il im in io"><h1 id="eca9" class="mm ma ir bd mn mo mp mq mr ms mt mu mv jx mw jy mx ka my kb mz kd na ke nb nc bi translated">参考</h1><p id="2768" class="pw-post-body-paragraph kx ky ir kz b la no js lc ld np jv lf lg nq li lj lk nr lm ln lo ns lq lr ls ik bi translated"><em class="lt">精通Java 9—Edward Lavieri博士，Peter Verhas </em></p></div></div>    
</body>
</html>