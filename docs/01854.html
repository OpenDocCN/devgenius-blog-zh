<html>
<head>
<title>Writing an XML Parser from Scratch in Julia</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Julia 中从头开始编写 XML 解析器</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-easily-write-an-xml-parser-in-julia-7cd02f19d8c6?source=collection_archive---------5-----------------------#2020-07-13">https://blog.devgenius.io/how-to-easily-write-an-xml-parser-in-julia-7cd02f19d8c6?source=collection_archive---------5-----------------------#2020-07-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/41033470b6b2765f6a8828a76741d0e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DzWPvoBIKk55y8A1"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">沙哈达特·拉赫曼在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="64aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将以一个激励性的咆哮开始，如果你只是想要一个实现的解释，你可以跳过它😄。</p><h2 id="758b" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">抱怨复杂的库和不必要的依赖</h2><p id="33ad" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">几年前，我不得不在 Julia 中使用 XML 解析器，我相信我最终使用了<a class="ae kc" href="https://github.com/JuliaIO/LightXML.jl" rel="noopener ugc nofollow" target="_blank"> LightXML </a>，它是用 c 编写的<a class="ae kc" href="http://www.xmlsoft.org" rel="noopener ugc nofollow" target="_blank"> libxml2 </a>的包装器</p><p id="96e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当时，这并不是一次愉快的经历。这个包会崩溃，处理外部依赖(比如 C 库)在当时并不容易。对一个有很多功能都是黑匣子的库进行故障排除并不容易。</p><p id="7fb2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是后来我想:“我只需要阅读非常简单明了的 XML 文档，这能有多难解析呢？”</p><p id="8990" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">特别是作为一名前 iOS 开发人员和顾问，人们会用那么多臃肿的框架和库来做最简单的事情，这让我抓狂。我浪费了太多时间调试多线程中的竞争条件，用来检查一个简单的文本字段是否包含电子邮件地址。</p><p id="ed0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最终我意识到这款应用的前开发者一定是个白痴，因为这项工作可以通过单线程运行的正则表达式轻松完成。</p><p id="d03e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在另一点上，我努力解决一个复杂的持久对象图系统的问题。才意识到只有少得可怜的 1 千字节的数据曾经使用这个系统读取或写入。一个简单的带有文件打开和文件关闭的标准 IO API 解决了这个问题。</p><p id="af39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将简单的问题过度复杂化是现代软件业的通病。在挑选功能最丰富臃肿的软件包来解决你的小问题之前。看看有没有更小图书馆。或者更好。也许，只是也许你可以用最少的代码自己写一个解决方案。</p><p id="baa0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不幸的是，我们对重新发明轮子变得如此过敏，以至于我们为了避免写 100 行代码而导入 100 000 行代码。</p><p id="d67c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">事实上，具有讽刺意味的是，在我上面提到的例子中，在我扔掉大框架后，代码变短了。戈多发动机的创造者在更大范围内也有类似的经历。他们发现，将 Lua 或 Python 等现有编程语言嵌入到他们的引擎中的粘合代码最终比仅仅实现他们自己的语言<a class="ae kc" href="https://docs.godotengine.org/en/stable/getting_started/scripting/gdscript/gdscript_basics.html" rel="noopener ugc nofollow" target="_blank"> GDScript </a>更长<a class="ae kc" href="https://docs.godotengine.org/en/stable/about/faq.html#what-were-the-motivations-behind-creating-gdscript" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="4b7b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我最终在包<a class="ae kc" href="https://github.com/ordovician/PLists.jl" rel="noopener ugc nofollow" target="_blank"> PList.jl </a>中制作的 XML 解析器没有太大的不同。在大约 1000 行代码中，它可以读写旧的 NeXSTSTEP 属性列表格式以及更现代的基于 XML 的 Apple 属性列表格式。</p><p id="0166" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这两种格式可以用代码解析，不依赖于 Julia 标准库。</p><p id="fd11" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相比之下，作为包装器的 LightXML 需要 400 行代码。事实上，PList.jl 库的 XML 部分只有 500 行。换句话说，本质上只是粘合代码，所用代码量几乎与我的 XML 库代码量相同。</p><h2 id="77ba" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">越糟越好的哲学</h2><p id="712d" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">支撑我的 PList 库的实际上是 Unix <a class="ae kc" href="https://en.wikipedia.org/wiki/Worse_is_better" rel="noopener ugc nofollow" target="_blank">越差越好的哲学</a>。这是一种强调简单而不是完整和正确的哲学。</p><p id="bb22" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基本上，如果你的解决方案很简单，那么没有被覆盖的情况或不正确的事情通常会很容易解决。然而，如果您的解决方案过于复杂，添加一个新的解决方案来解决某个特定的问题可能会变得几乎不可克服。</p><p id="a644" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，解决方案遵循一种务实的方法。只正确解析我将处理的 XML 文件的种类，例如，在苹果财产列表格式中使用的那些。</p><p id="4386" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不要添加一堆你不需要的东西，那会使解决方案复杂化。</p><h2 id="0e8b" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">XML 和文档对象模型(DOM)</h2><p id="aab4" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">在讨论实现之前，我们必须看看什么是 XML 文档以及 XML 解析器实际上应该做什么。</p><p id="3fee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有许多方法可以做到这一点，但我们选择遵循一种常见的方法，即将 XML 文档转换成一种数据结构，称为<a class="ae kc" href="https://www.w3schools.com/Xml/xml_dom.asp" rel="noopener ugc nofollow" target="_blank">文档对象模型</a>或简称为<em class="lz"> DOM </em>。</p><p id="5e23" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们从这个 XML 文档开始，表示我最喜欢的一家餐馆的菜单的一个子部分<a class="ae kc" href="https://tacorepublica.no" rel="noopener ugc nofollow" target="_blank">“Taco Republica”</a>:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="c7fe" class="lb lc iq mf b gy mj mk l ml mm">&lt;menu&gt;<br/>    &lt;snacks&gt;<br/>        &lt;food&gt;<br/>            &lt;name&gt;Guacamole and Totopos&lt;/name&gt;<br/>            &lt;price&gt;95&lt;/price&gt;<br/>        &lt;/food&gt;<br/>        &lt;food&gt;<br/>            &lt;name&gt;Quesadillas&lt;/name&gt;<br/>            &lt;price&gt;65&lt;/price&gt;<br/>        &lt;/food&gt;<br/>    &lt;/snacks&gt;<br/>    &lt;tacos&gt;<br/>        &lt;food&gt;<br/>            &lt;name&gt;Bistec&lt;/name&gt;<br/>            &lt;price&gt;80&lt;/price&gt;<br/>        &lt;/food&gt;<br/>        &lt;food&gt;<br/>            &lt;name&gt;Barbacoa&lt;/name&gt;<br/>            &lt;price&gt;65&lt;/price&gt;<br/>        &lt;/food&gt;        <br/>    &lt;/tacos&gt;<br/>&lt;/menu&gt;</span></pre><p id="d678" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们最终想要的是一个内存中的数据结构，我们可以很容易地操纵它，如下图所示。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="ab gu cl mn"><img src="../Images/5c0f311cd21586ab112a8dcbecb1d6a4.png" data-original-src="https://miro.medium.com/v2/format:webp/1*LHtdGq7Cdg0KBOoaV5Btlw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">先前 XML 文档的 XML DOM 树。</figcaption></figure><p id="99a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是一个例子，说明我们在解析这个结构后如何处理它。我们首先获取树顶端的文档对象。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="d0fb" class="lb lc iq mf b gy mj mk l ml mm">julia&gt; doc = parsexml(read("examples/food.xml", String));<br/><br/>julia&gt; typeof(doc)<br/>Document</span></pre><p id="5f83" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以用各种 API 函数遍历这个树结构:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="803e" class="lb lc iq mf b gy mj mk l ml mm">julia&gt; categories = nodes(root(doc));<br/><br/>julia&gt; nodename(categories[1])<br/>"snacks"<br/><br/>julia&gt; snacks = nodes(categories[1]);</span></pre><p id="59f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了更容易看到发生了什么，我实现了一个<code class="fe mo mp mq mf b">xml</code>函数来显示一个子树的 XML。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="8f6c" class="lb lc iq mf b gy mj mk l ml mm">julia&gt; xml(snacks[1])<br/>&lt;food&gt;<br/>  &lt;name&gt;Guacamole and Totopos&lt;/name&gt;<br/>  &lt;price&gt;95&lt;/price&gt;<br/>&lt;/food&gt;</span></pre><p id="7272" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在你已经知道我们实际上想要达到的目标了。期望的最终结果是什么。让我们看看如何到达那里。</p><p id="0199" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将看看如何将 XML 文件中的一串字符转换成层次树结构。</p><h2 id="b7d9" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">XML 解析器的实现</h2><p id="3489" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">在编程中，当我们将文本转化为结构时，我们倾向于将问题分成两个逻辑部分:</p><ul class=""><li id="cff7" class="mr ms iq kf b kg kh kk kl ko mt ks mu kw mv la mw mx my mz bi translated"><strong class="kf ir"> Lexer </strong>获取文本并将其转换成一串标记。这些标记被提供给解析器。</li><li id="f2b1" class="mr ms iq kf b kg na kk nb ko nc ks nd kw ne la mw mx my mz bi translated"><strong class="kf ir">解析器</strong>将一串标记作为输入，并尝试识别语法结构。这用于产生更高级别的对象。</li></ul><p id="da7a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">词元是一种由词元和词元类型组成的生成性词元。以下是一些例子:</p><p id="c320" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">词位标记类型描述 42 号码号码“hello”字符串文本字符串 foobar IDENT 标识符</p><p id="7779" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以基本上，词位是构成一个标记的字符的集合。我们解释这些字符并给它一个类型，比如一个数字或一个标识符。<em class="lz">标识符</em>可以是变量或函数的名字。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="ab gu cl mn"><img src="../Images/b6d1f9e6ac132b0a4f23730db959c6cf.png" data-original-src="https://miro.medium.com/v2/format:webp/1*wHE5vaNU-ln49VpWlFMFig.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">lexer 从 XML 文件中获取字符，将令牌传递给创建 DOM 树的解析器。</figcaption></figure><p id="a16a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的数据流图概述了它是如何工作的。</p><p id="f074" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">构造词法分析器和解析器的常见问题是，您需要在词法分析器和解析器中维护一组状态。</p><p id="2c3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">lexer 需要跟踪它正在处理哪种类型的字符。与此同时，解析器试图将标记组合成 XML 节点。</p><p id="eea9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常这个问题是通过在词法分析器和语法分析器中存储一个状态作为枚举来解决的。然后我们有一个大的 switch-case 或 if-else 循环，它检查当前状态并做一些相关的处理。</p><p id="6c79" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是这篇文章实际上是关于一种更简单、更优雅的方法来解决这个问题。</p><h2 id="866d" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">救援协管员</h2><p id="ca11" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">有了协程，我们可以独立运行词法分析器和语法分析器。</p><p id="3341" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 Julia 中，协程由两种数据类型<code class="fe mo mp mq mf b">Task</code>和<code class="fe mo mp mq mf b">Channel</code>管理。要创建一个协程，你需要向一个<code class="fe mo mp mq mf b">Task</code>构造函数提供一个函数。</p><p id="40ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以安排这个协程运行。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="60c9" class="lb lc iq mf b gy mj mk l ml mm">task = Task(func)<br/>schedule(task)</span></pre><p id="7008" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">协程调度器将跟踪所有活动的协程。它在任何给定时间只运行其中一个。一旦一个协程阻塞(或让步)，调度程序将找到另一个协程继续运行。</p><p id="1bd3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Julia 中协调协程运行的一个很好的工具是<code class="fe mo mp mq mf b">Channel</code>数据类型。这是一个 FIFO 队列。你把数据放进去。如果当你推数据时队列是满的，或者当你拉数据时队列是空的，那么活动的协程将被挂起。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="ab gu cl mn"><img src="../Images/ae985e924f8cd098fdcc8ad0efdfd4f4.png" data-original-src="https://miro.medium.com/v2/format:webp/1*1Rc4PYw2oPo2UswvJTbwoA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">两个协同程序通过持有令牌的通道进行通信。</figcaption></figure><p id="5ede" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以想象 Lexer 和 Parser 各自运行一个协程，由一个<code class="fe mo mp mq mf b">Task</code>对象管理。我们为代币做了一个队列，或者说是一个<code class="fe mo mp mq mf b">Channel</code>。</p><p id="62f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Lexer 将继续把它发现的令牌推入通道。当通道被填满时，控制权将被传递给解析器，解析器将继续从通道中提取令牌。</p><p id="9e03" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦通道为空，解析器协程将被挂起，控制权再次传递给词法分析器。这被重复了一遍。</p><p id="122d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了开始这个，我们需要一个 Lexer:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="cf52" class="lb lc iq mf b gy mj mk l ml mm">mutable struct Lexer<br/>    input   :: String # scanned string<br/>    start   :: Int    # start of lexeme<br/>    pos     :: Int    # end of lexeme?<br/>    tokens  :: Channel{Token}<br/>end</span></pre><p id="e875" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里的<code class="fe mo mp mq mf b">input</code>是一个包含我们的 XML 文档的字符串。<code class="fe mo mp mq mf b">start</code>是我们当前试图确定结束的词位在字符串中的位置。<code class="fe mo mp mq mf b">pos</code>是我们目前正在探索的字符位置，看它是否代表词位的结束。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="86ed" class="lb lc iq mf b gy mj mk l ml mm">function Lexer(input::String)<br/>    l = new(input, 1, 0, Channel{Token}(32))<br/>    return l<br/>end</span></pre><p id="2fed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们构造了一个<code class="fe mo mp mq mf b">Lexer</code>对象，其通道容量为 32 个令牌。这有些武断。可能更多或更少。</p><p id="d4f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用这个函数来解释 lexing:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="1ca8" class="lb lc iq mf b gy mj mk l ml mm">function lex(input::AbstractString, start::Function)<br/>    l = Lexer(input)<br/>    @async run(l, start)<br/>    return l<br/>end</span></pre><p id="caa1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这使用了<code class="fe mo mp mq mf b">@async</code>宏，它基本上将<code class="fe mo mp mq mf b">run</code>函数包装在一个<code class="fe mo mp mq mf b">Task</code>对象中，并调度创建的任务对象。</p><p id="0354" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此我们把<code class="fe mo mp mq mf b">run</code>函数变成了一个协程。</p><h2 id="6c72" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">主循环</h2><p id="52c4" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">驱动 lexer 的主循环是这个<code class="fe mo mp mq mf b">run</code>功能。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="0dd5" class="lb lc iq mf b gy mj mk l ml mm">function run(l::Lexer, start::Function)<br/>    state = start<br/>    while state != lex_end<br/>        state = state(l)<br/>    end<br/>    close(l.tokens)<br/>end</span></pre><p id="ff1c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个状态都由一个 function 对象表示，该对象将 lexer 作为唯一的参数。</p><p id="0fbc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对文本节点内的文本进行词法分析可以是一种状态:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="c8f0" class="lb lc iq mf b gy mj mk l ml mm">function lex_text(l::Lexer)<br/>    ch = peek_char(l)<br/>    while ch ∉ ['&lt;', '&gt;', EOFChar]<br/>        next_char(l)<br/>        ch = peek_char(l)<br/>    end<br/>    emit_token(l, TEXT)<br/>    return lex_xml<br/>end</span></pre><p id="7e39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，当我们完成了对文本的词法分析后，我们通过返回代表下一个状态的函数对象来切换到下一个状态。</p><p id="7af3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那就是这个函数:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="0b87" class="lb lc iq mf b gy mj mk l ml mm">function lex_xml(l::Lexer)<br/>    while true<br/>        ignore_whitespace(l)<br/>        ch = peek_char(l)<br/><br/>        if ch == EOFChar<br/>            emit_token(l, EOF)<br/>            return lex_end<br/>        elseif ch == '&lt;'<br/>            return lex_begin_tag<br/>        else<br/>           return lex_text <br/>        end<br/>    end<br/>end</span></pre><p id="f97a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，在这两种情况下，我们在找到令牌时都会发出一个令牌。然而，我们不必归还这个代币。相反，<code class="fe mo mp mq mf b">emit_token</code>所做的是将令牌推入 lexer 的<code class="fe mo mp mq mf b">tokens</code>通道。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="5795" class="lb lc iq mf b gy mj mk l ml mm">function emit_token(l::Lexer, t::TokenType, s::String)<br/>    token = Token(t, s)<br/>    put!(l.tokens, token)<br/>    l.start = l.pos + 1<br/>end</span></pre><p id="18e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe mo mp mq mf b">tokens</code>通道已满，那么这将导致 lexer 协程阻塞，控制权将移交给解析器协程(任务)。</p><h2 id="7adc" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">分析器任务</h2><p id="21db" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">开始解析 XML 文件的 API 就是这个函数。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="9ccd" class="lb lc iq mf b gy mj mk l ml mm">function parsexml(xmlstring::AbstractString)<br/>    l = lex_xml(s)<br/>    p = Parser(l)<br/>    Document(parse_node(p))<br/>end</span></pre><p id="1c97" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以看到我们创建了一个 lexer，然后将它传递给我们创建的<code class="fe mo mp mq mf b">Parser</code>对象。</p><p id="14d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mo mp mq mf b">parse_node</code>开始从频道中抽取代币。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="ccc2" class="lb lc iq mf b gy mj mk l ml mm">function parse_node(parser::Parser)<br/>    t = peek_token(parser)<br/>    if t.kind == BEGIN_TAG<br/>        parse_element(parser)::Node<br/>    elseif t.kind == TEXT<br/>        parse_text(parser)::Node<br/>    else<br/>        error("Had not expected token '$t' while looking for start of new XML node")<br/>    end<br/>end</span></pre><p id="e27b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以看到它调用了<code class="fe mo mp mq mf b">peek_token</code>，它将尝试获取更多令牌，因为它还没有一个先行令牌。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="4c56" class="lb lc iq mf b gy mj mk l ml mm">function peek_token(p::Parser)<br/>    t = @get(p.ahead_token, next_token(p.lexer))<br/>    p.ahead_token = t<br/>    t<br/>end<br/><br/>next_token(l::Lexer) = take!(l.tokens)</span></pre><p id="2470" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这使用了在通道上调用<code class="fe mo mp mq mf b">take!</code>的<code class="fe mo mp mq mf b">next_token</code>。如果协程为空，则<code class="fe mo mp mq mf b">take!</code>将导致协程挂起。</p><p id="c4a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，当通道变满或变空时，我们将在词法分析器和语法分析器之间来回切换。每次词法分析器和解析器都会从之前被阻塞的<code class="fe mo mp mq mf b">put!</code>或<code class="fe mo mp mq mf b">take!</code>调用中恢复。</p></div></div>    
</body>
</html>