<html>
<head>
<title>Scaffolding A gRPC service with Go (Golang) For Production</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Go (Golang)为生产搭建 gRPC 服务</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/scaffolding-a-grpc-service-with-go-golang-for-production-9de91f6198b0?source=collection_archive---------2-----------------------#2022-09-26">https://blog.devgenius.io/scaffolding-a-grpc-service-with-go-golang-for-production-9de91f6198b0?source=collection_archive---------2-----------------------#2022-09-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/7fe2528848a2a40b4f0be3e5ff2bfef7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lpZOFKC32_fkGfG3oj4MTw.jpeg"/></div></div></figure><p id="cd4d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">gRPC 是 google 的高性能 RPC 框架。在 gRPC 出现之前，使用远程过程调用(RPC)一直是一个令人头疼的问题。Google 为开发者和工程师提供了多语言代码生成支持。今天，我们将了解微服务和服务对服务通信协议的现代事实标准——gRPC。</p><p id="8b38" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">本文不打算介绍 protobuf 和 go 包的安装。它们非常简单，您可以在— <a class="ae kt" href="https://grpc.io/docs/languages/go/quickstart/" rel="noopener ugc nofollow" target="_blank">快速入门</a>中轻松找到。</p><h1 id="d82f" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">入门指南</h1><p id="1c31" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">在这篇文章中，我们将创建一个基本的几何服务，它将返回给我们一个形状的几何属性，例如，圆形，矩形等。我非常喜欢项目结构。这有助于我了解我要做什么，以及在解决任何 bug/问题时，我应该去哪里寻找。所以，我将从我们项目的文件夹结构开始-</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="6015" class="mg kv in mc b gy mh mi l mj mk"><strong class="mc io">.</strong><br/>├── <strong class="mc io">cmd</strong><br/>│   ├── <strong class="mc io">client</strong><br/>│   └── <strong class="mc io">server</strong><br/>├── <strong class="mc io">internal</strong><br/>├── <strong class="mc io">proto</strong><br/>└── go.mod</span></pre><p id="e0eb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">获取源代码并跟随…</p><div class="ml mm gp gr mn mo"><a href="https://github.com/by-sabbir/grpc-service-example" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd io gy z fp mt fr fs mu fu fw im bi translated">GitHub-by-sab Bir/grpc-service-示例</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">github.com</p></div></div><div class="mx l"><div class="my l mz na nb mx nc jt mo"/></div></div></a></div></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><h1 id="9cc5" class="ku kv in bd kw kx nk kz la lb nl ld le lf nm lh li lj nn ll lm ln no lp lq lr bi translated">原型文件</h1><p id="2eb6" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">几乎每个 go 项目都会有一个<code class="fe np nq nr mc b">cmd</code>文件夹。根据项目要求，可包含<code class="fe np nq nr mc b">cli</code>、<code class="fe np nq nr mc b">server</code>、<code class="fe np nq nr mc b">client</code>。内部将包含工厂、存储库和服务。现在我们准备定义服务器和客户机之间的契约，也就是原型。在名为 geometry.proto 的 proto 目录下创建一个新文件，并粘贴以下内容</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="749f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这三行代码是设置。第一行表示我们用来定义原型的版本。第二行是包名，我们可以在这里发挥创意。第三行是特定于 go 的选项，这是 go.mod 中的模块名和 proto 目录的相对路径的组合。</p><h1 id="0083" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">在 Proto 中定义服务</h1><p id="f416" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">现在，我们准备声明服务和请求/响应契约——gRPC 通过建立一个预定义的消息结构来确保通信，这样服务器和客户机就不会混淆消息结构。对于初学者来说，这可能听起来没有必要，但是在我的软件开发经验中，这是最令人沮丧的一点。gRPC 从一开始就解决了这个问题。RPC 服务有三个部分，</p><ol class=""><li id="6fc3" class="nu nv in jx b jy jz kc kd kg nw kk nx ko ny ks nz oa ob oc bi translated">服务</li><li id="f1bc" class="nu nv in jx b jy od kc oe kg of kk og ko oh ks nz oa ob oc bi translated">请求消息</li><li id="2b00" class="nu nv in jx b jy od kc oe kg of kk og ko oh ks nz oa ob oc bi translated">响应信息</li></ol><p id="b444" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在 Proto point 中，2 和 3 是消息结构的一部分，服务是服务结构，非常简单。让我们编写代码—扩展 geometry.proto 文件并添加以下代码行</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="8ed3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">原型本身是自我描述的，我们有一个具有两个功能的 GeometryService 面积和周长。这两个 RPC 函数都接受一个请求对象并发出一个响应。通常，请求和响应消息使用相同的前缀命名，例如，如果我们有一个名为 Greet 的服务，我们将有一个 GreetRequest 和一个 GreetResponse (Greet as prefix)。但是我们的服务是一个破例的完美例子。</p><h1 id="fbb1" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">使用协议生成代码</h1><p id="13e7" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">一开始，我们吹嘘 gRPC 是多语言的，在这一节中，我们将看到它的实际应用。我们将使用 protocol 生成一些 go 代码。请注意，我们必须为它需要 go 插件，检查您是否已经在<a class="ae kt" href="https://grpc.io/docs/languages/go/quickstart/" rel="noopener ugc nofollow" target="_blank"> Go 快速入门</a>安装了它们。</p><p id="5e56" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">基本命令如下-</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="54dd" class="mg kv in mc b gy mh mi l mj mk">❯ protoc --go_out=. --go-grpc_out=. proto/*.proto</span></pre><p id="d193" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将生成如下的 go 接口代码。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="a3a0" class="mg kv in mc b gy mh mi l mj mk">├── <strong class="mc io">github.com</strong><br/>    └── <strong class="mc io">by-sabbir</strong><br/>        └── <strong class="mc io">grpc-service-example</strong><br/>            └── <strong class="mc io">proto</strong><br/>                ├── geometry_grpc.pb.go<br/>                └── geometry.pb.go</span></pre><p id="2a8e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">哦！现在我们看到了模式，对吗？这是我们在 geometry.proto 文件的第三行中分配给 go_package 的文件夹结构…相似之处是不可思议的(双关语)。但是我们在这里不需要它们，我们在 proto 目录中需要它们。如果你在考虑换 go_package，你没有错。但是有一个更好的方法。protoc CLI 工具允许我们为生成的代码分配模块和导入路径。让我们更新命令</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="f02f" class="mg kv in mc b gy mh mi l mj mk">❯ protoc -Iproto/ --go_out=. --go_opt=module=github.com/by-sabbir/grpc-service-example --go-grpc_out=. --go-grpc_opt=module=github.com/by-sabbir/grpc-service-example proto/*.proto</span></pre><p id="22b3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我没有错的话，你一定在想谁还记得那个巨大的命令！让我来给你解释一下。但在实践中，您总是会使用 Makefile 或等效文件来为您生成代码。所以简洁的命令应该是这样的</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="c535" class="mg kv in mc b gy mh mi l mj mk">❯ protoc -I&lt;proto path&gt; --go_out=. --go_opt=module=&lt;go module&gt; --go-grpc_out=. --go-grpc_opt=module=&lt;go module&gt; proto/*.proto</span></pre><p id="6da1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于每个 _out，我们将拥有 _opt=module=和来自 go.mod 文件的模块名。我们可以删除 github.com 文件夹，因为我们在 proto 目录中有生成的代码。</p><h1 id="05f8" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">实施 gRPC 服务器</h1><p id="b988" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">我们已经走了很长一段路，让我们在 cmd/server 目录下创建一个新文件，并将其命名为 main。并运行以下命令来获取依赖项-</p><p id="1fd7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe np nq nr mc b">❯ go mod tidy</code></p><p id="3fd6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">先从<a class="ae kt" href="https://github.com/by-sabbir/grpc-service-example/blob/101e32aa9dafe5b8ab1f87f981180a2ce9b554ce/cmd/server/main.go" rel="noopener ugc nofollow" target="_blank"> GitHub </a>的 cmd/server/main.go 和<a class="ae kt" href="https://github.com/by-sabbir/grpc-service-example/blob/2db6ce263ca164dac31162d869585b774aeeb4e9/cmd/client/main.go" rel="noopener ugc nofollow" target="_blank"> GitHub </a>的 cmd/client/main.go 中复制以下代码。</p><p id="81f9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此时，我们已经准备好测试我们的应用程序，</p><p id="2c34" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe np nq nr mc b">❯ go run cmd/server/main.go</code></p><p id="e5d7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">输出应该如下所示-</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="f5cf" class="mg kv in mc b gy mh mi l mj mk">2022/09/26 16:18:17 tcp listener started at port:  5000<br/>2022/09/26 16:18:21 invoked Area:  height:10.1  width:20.5<br/>2022/09/26 16:18:21 invoked Perimeter:  height:10.1  width:20.5</span></pre><p id="36ad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果存在状态代码为 1 的代码，您应该在 server/main.go 的第 16 行更改端口，否则运行客户端:</p><p id="4a90" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe np nq nr mc b">❯ go run cmd/client/main.go</code></p><p id="9ab5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果输出如下所示，我们就可以进入下一步了</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="644b" class="mg kv in mc b gy mh mi l mj mk">Area:  207.05<br/>Perimeter:  61.2</span></pre><p id="dbcc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用客户端代码中的一些值进行测试。</p><h1 id="6afb" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">为生产重构服务器</h1><p id="db14" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">在 Go 中，通常的做法是从单个文件开始，然后重构为最佳实践。目前，我们有一个没有分离问题的整体服务器。我们开始这个项目时考虑到了增长因素，我们有一个名为 internal 的未动过的文件夹。让我们创建一个文件夹 geometry 和一个文件 geometry.go，因此路径看起来像 internal/geometry/geometry.go。这将是我们的几何服务工厂。让我们看看 geometry.go 文件</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="d7f7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">商店接口将充当存储库。如果我们需要扩展项目并将其与数据库集成，我们可以在内部目录中创建一个新的文件夹 db，只需实现 Store 接口。现在我们的 cmd/server/main.go 文件应该如下所示，</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="7aee" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如我们现在看到的，服务器不再承担区域和外围功能。这只是一个简单的 gRPC 服务器实现，关注点是分离的。</p><h1 id="484c" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">丰富</h1><ul class=""><li id="80b8" class="nu nv in jx b jy ls kc lt kg oi kk oj ko ok ks ol oa ob oc bi translated">为原型目录维护一个单独的存储库</li><li id="89ce" class="nu nv in jx b jy od kc oe kg of kk og ko oh ks ol oa ob oc bi translated">版本的原型文件，即，原型/v1</li></ul></div></div>    
</body>
</html>