<html>
<head>
<title>React Tips — External URLs, Timers, and Hover Effect</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应提示—外部URL、计时器和悬停效果</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/react-tips-external-urls-timers-and-hover-effect-9148c1a384a9?source=collection_archive---------3-----------------------#2020-07-28">https://blog.devgenius.io/react-tips-external-urls-timers-and-hover-effect-9148c1a384a9?source=collection_archive---------3-----------------------#2020-07-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6a7ee8498a8bf2e9f8ad8ff53c6dc536.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_E_SXSMzNarET1Mr"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Giuseppe Martini 在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="b1a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React是一个用于创建web应用程序和移动应用程序的流行库。</p><p id="f2a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解一些编写更好的React应用程序的技巧。</p><h1 id="e0a4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在触发函数之前，请等待setState完成</h1><p id="fa63" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以等待<code class="fe me mf mg mh b">setState</code>结束，然后通过将函数作为<code class="fe me mf mg mh b">setState</code>的第二个参数传入来触发函数。</p><p id="45cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b3cc" class="mq lc iq mh b gy mr ms l mt mu">this.setState({<br/>  firstName,<br/>  lastName,<br/>  age<br/>}, () =&gt; { <br/>  console.log(this.state) ;<br/>})</span></pre><p id="15c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们称<code class="fe me mf mg mh b">setState</code>为先有对象的州。</p><p id="9fd6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们运行回调函数来获取<code class="fe me mf mg mh b">this.state</code>的最新值。</p><h1 id="586f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">带反应路由器的外部链路</h1><p id="58fb" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过传入一个组件重定向到一个外部链接来添加一个外部链接。</p><p id="0d1c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9a34" class="mq lc iq mh b gy mr ms l mt mu">&lt;Route path='/external-site' &gt;<br/>  {() =&gt; { <br/>     useEffect(() =&gt; {<br/>       window.location.href = 'https://example.com'; <br/>     }, [])<br/>     return null;<br/>  }}<br/>&lt;/Route&gt;</span></pre><p id="21cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<code class="fe me mf mg mh b">Router</code>组件和<code class="fe me mf mg mh b">path</code>道具来设置路径。</p><p id="0cd5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在我们的组件中，我们通过将URL设置为<code class="fe me mf mg mh b">window.location.href</code>的值来重定向到一个外部URL。</p><p id="dedb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们返回<code class="fe me mf mg mh b">null</code>不渲染任何东西。</p><p id="9c03" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以在<code class="fe me mf mg mh b">componentDidMount</code>中直接重定向:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6496" class="mq lc iq mh b gy mr ms l mt mu">class RedirectPage extends React.Component {<br/>  componentDidMount(){<br/>    window.location.replace('http://www.example.com')<br/>  }</span><span id="9d92" class="mq lc iq mh b gy mv ms l mt mu">  render(){<br/>    return null;<br/>  }<br/>}</span></pre><h1 id="8aea" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在React中访问悬停状态</h1><p id="d745" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过监听<code class="fe me mf mg mh b">mouseenter </code>和<code class="fe me mf mg mh b">mouseleave </code>事件来设置hove状态。</p><p id="6a5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2514" class="mq lc iq mh b gy mr ms l mt mu">&lt;div<br/>  onMouseEnter={this.onMouseEnter}<br/>  onMouseLeave={this.onMouseLeave}<br/>&gt;<br/>  foo<br/>&lt;/div&gt;</span></pre><p id="7a27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以将事件处理程序传递给<code class="fe me mf mg mh b">onMouseEnter</code>和<code class="fe me mf mg mh b">onMouseLeave</code>道具。</p><p id="287f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以在这些方法中运行代码来设置悬停状态。</p><h1 id="20c3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">功能性无状态组件中的属性类型</h1><p id="da1e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以在功能性的无状态组件中设置适当的类型。</p><p id="1ba6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="25eb" class="mq lc iq mh b gy mr ms l mt mu">import React from "react";<br/>import PropTypes from "prop-types";</span><span id="bb8c" class="mq lc iq mh b gy mv ms l mt mu">const Name = ({ name }) =&gt; &lt;div&gt;hi {name}&lt;/div&gt;;</span><span id="8673" class="mq lc iq mh b gy mv ms l mt mu">Name.propTypes = {<br/>  name: PropTypes.string<br/>};</span><span id="5c35" class="mq lc iq mh b gy mv ms l mt mu">Name.defaultProps = {<br/>  name: "james"<br/>};</span></pre><p id="9450" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe me mf mg mh b">propTypes</code>属性创建了<code class="fe me mf mg mh b">Name</code>组件。</p><p id="87f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用它设置<code class="fe me mf mg mh b">name</code>道具的数据类型。</p><p id="dc9a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以为<code class="fe me mf mg mh b">name</code>道具设置默认值。</p><p id="05d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们必须安装<code class="fe me mf mg mh b">propt-types</code>包来设置道具的类型。</p><h1 id="c143" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">React组件中的setTimeout()</h1><p id="69ac" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以在React组件中使用<code class="fe me mf mg mh b">setTimeout</code>,方法是调用<code class="fe me mf mg mh b">componentDidMount</code>中的<code class="fe me mf mg mh b">setTimeout</code>,然后清除<code class="fe me mf mg mh b">componentWillMount</code>方法中的计时器。</p><p id="ab8c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b3ee" class="mq lc iq mh b gy mr ms l mt mu">class App extends React.Component {<br/>  constructor() {<br/>    this.state = { position: 0, timer: undefined };    <br/>  }</span><span id="f7eb" class="mq lc iq mh b gy mv ms l mt mu">  componentDidMount() {<br/>    const timer = setTimeout(() =&gt; this.setState({ position: 1 }), 3000)<br/>    this.setState({ timer });<br/>  }</span><span id="982d" class="mq lc iq mh b gy mv ms l mt mu">  componentWillUnmount(){<br/>    clearTimeout(this.state.timer);<br/>  };<br/>  <br/>  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        {this.state.position}<br/>      &lt;/div&gt;<br/>    ); <br/>  }<br/>}</span></pre><p id="6571" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用一个回调函数调用了<code class="fe me mf mg mh b">setTimeout</code>,超时时间跨度在<code class="fe me mf mg mh b">componentDidMount</code>中，以在组件加载时获取计时器。</p><p id="cb60" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它返回一个定时器对象，当组件卸载时，我们可以用它调用<code class="fe me mf mg mh b">clearTimeout</code>来清除定时器的资源。/</p><p id="0d30" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe me mf mg mh b">timer</code>状态来设置从<code class="fe me mf mg mh b">setTimeout</code>返回的定时器的状态。</p><p id="3d8f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们在<code class="fe me mf mg mh b">componentWillUnmount</code>，我们调用<code class="fe me mf mg mh b">clearTimeout</code>来清零定时器。</p><h1 id="796d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">React组件中的setInterval</h1><p id="f300" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">像使用<code class="fe me mf mg mh b">setTimeout</code>一样，我们可以在React组件中调用<code class="fe me mf mg mh b">setInterval</code>。</p><p id="7f92" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了我们可以<code class="fe me mf mg mh b">setInterval</code>和<code class="fe me mf mg mh b">clerInterval</code>之外，它和<code class="fe me mf mg mh b">setTimeout</code>几乎一样。</p><p id="e6af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0973" class="mq lc iq mh b gy mr ms l mt mu">class App extends React.Component {<br/>  constructor() {<br/>    this.state = { position: 0, timer: undefined };    <br/>  }</span><span id="23ad" class="mq lc iq mh b gy mv ms l mt mu">  componentDidMount() {<br/>    const timer = setInterval(() =&gt; this.setState(state =&gt; ({ position: state.position + 1 })), 3000)<br/>    this.setState({ timer });<br/>  }</span><span id="7975" class="mq lc iq mh b gy mv ms l mt mu">  componentWillUnmount(){<br/>    clearInterval(this.state.timer);<br/>  };<br/>  <br/>  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        {this.state.position}<br/>      &lt;/div&gt;<br/>    ); <br/>  }<br/>}</span></pre><p id="d622" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在<code class="fe me mf mg mh b">componentDidMount</code>中调用了<code class="fe me mf mg mh b">setInterval</code>来创建一个定时器来定期运行代码。</p><p id="c3f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe me mf mg mh b">setInterval</code>回调中，我们每3秒更新一次<code class="fe me mf mg mh b">position</code>状态。</p><p id="3647" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在<code class="fe me mf mg mh b">componentWillUnmount</code>中，我们调用<code class="fe me mf mg mh b">clearInterval</code>来清除定时器。</p><p id="15b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了功能组件，我们可以做同样的事情。</p><p id="fdb8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a0cb" class="mq lc iq mh b gy mr ms l mt mu">import React, { useState, useEffect } from 'react';</span><span id="8260" class="mq lc iq mh b gy mv ms l mt mu">const App = () =&gt; {<br/>  const [position, setPosition] = useState(0);<br/>  const timer = () =&gt; setPosition(position =&gt; position + 1);</span><span id="f05f" class="mq lc iq mh b gy mv ms l mt mu">  useEffect(() =&gt; {<br/>    const timer = setInterval(timer, 1000);<br/>    return () =&gt; clearInterval(timer);<br/>  }, []);</span><span id="ba0d" class="mq lc iq mh b gy mv ms l mt mu">  return &lt;div&gt;{position}&lt;/div&gt;;<br/>};</span></pre><p id="d3ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe me mf mg mh b">useState</code>钩子用<code class="fe me mf mg mh b">setPosiitin</code>更新<code class="fe me mf mg mh b">position</code>状态。</p><p id="afce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用<code class="fe me mf mg mh b">useEffect</code>钩子在组件加载时创建一个计时器。</p><p id="bc7b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们在<code class="fe me mf mg mh b">useEffect</code>回调中返回的函数用<code class="fe me mf mg mh b">clearInterval</code>删除计时器。</p><p id="35e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个参数中的空数组确保了<code class="fe me mf mg mh b">useEffect</code>回调只在<code class="fe me mf mg mh b">App</code>第一次加载时运行。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/be19ac045d18b676cf55054a77c6430d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aJ1WK7OCHtauh5Gp"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">瑞安·斯通在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="928e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="b7d1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以创建一个组件来重定向到外部URL。</p><p id="8876" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以在组件中使用<code class="fe me mf mg mh b">setTimeout</code>和<code class="fe me mf mg mh b">setInterval</code>。</p><p id="9bce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要设置道具类型，我们可以使用<code class="fe me mf mg mh b">prop-types</code>包。</p></div></div>    
</body>
</html>