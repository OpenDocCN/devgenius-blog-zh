<html>
<head>
<title>Array Coding Pattern — Prefix Sum</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">阵列编码模式—前缀和</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/array-coding-pattern-prefix-sum-a83d313c7e5a?source=collection_archive---------4-----------------------#2022-11-12">https://blog.devgenius.io/array-coding-pattern-prefix-sum-a83d313c7e5a?source=collection_archive---------4-----------------------#2022-11-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div class="gh gi il"><img src="../Images/83173cecf548f38c3de531cfe356ccdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*qpayhZsLF4tjSKJ46CNfFw.png"/></div><figcaption class="is it gj gh gi iu iv bd b be z dk translated">图片来源 google.com</figcaption></figure><div class=""/><p id="62d1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">也称为累积和或包含扫描</p><p id="1921" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于给定的数组 A，前缀和数组 P 是与 A 大小相同的数组，其中每个索引<code class="fe kt ku kv kw b">0 &lt;= i &lt; n</code> P[i]表示<code class="fe kt ku kv kw b">A[0] + A[1] …. + A[i]</code>。</p><figure class="ky kz la lb gt ip gh gi paragraph-image"><div class="gh gi kx"><img src="../Images/6375527ce33ba9d2fae525b09ed8daeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*cCqVRsZM4sFoWXkzEIzpWA.png"/></div></figure><p id="0519" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如上图所述，要生成前缀总和数组，我们只需获取前一个值(到该索引为止的元素总和)并添加数组的当前值。上述逻辑的代码实现如下:</p><pre class="ky kz la lb gt lc kw ld bn le lf bi"><span id="6a3f" class="lg lh iy kw b be li lj l lk ll">def get_prefix_sum(array):<br/>    prev_sum = 0<br/>    prefix_sum_array = []<br/>    for num in array:<br/>        curr_sum = prev_sum + num<br/>        prefix_sum_array.append(cur_sum)<br/>        prev_sum = curr_sum <br/>    return prefixSum<br/><br/>print(get_prefix_sum([1, 2, 3, 4, -2, 1, 8]))<br/>&gt;&gt;&gt; [1, 3, 6, 10, 8, 9, 17]</span></pre><p id="e0f2" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因为我们只遍历数组一次，这需要 O(n)步。因此，生成前缀和数组的时间复杂度为 O(n)。此外，由于生成的数组大小为 n，并且我们没有任何其他额外的内存需求，因此空间复杂度为 O(n)。</p><h2 id="b80e" class="lm lh iy bd ln lo lp dn lq lr ls dp lt kg lu lv lw kk lx ly lz ko ma mb mc md bi translated">范围和查询</h2><p id="e44a" class="pw-post-body-paragraph jv jw iy jx b jy me ka kb kc mf ke kf kg mg ki kj kk mh km kn ko mi kq kr ks ig bi translated">我们需要回答要求给定索引范围内元素总和的查询。如果我们遍历数组来查找每个查询的总和，我们将对数组元素进行多次扫描，导致时间复杂度为 O(n*q)。为了改进这一点，我们预先计算从 0 到给定索引的范围的总和(基本上是前缀总和数组),然后在常数时间内返回查询的答案。下图解释了直觉。</p><figure class="ky kz la lb gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mj"><img src="../Images/0dae546776a2cd23619327df4b4fa53d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4R1ZrfmzHCaWjBOybrtzLA.png"/></div></div></figure><p id="e958" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上述逻辑的代码实现如下:</p><pre class="ky kz la lb gt lc kw ld bn le lf bi"><span id="7c23" class="lg lh iy kw b be li lj l lk ll">def range_sum_query(prefix_sum_array, l, r):<br/>    if (l == 0):<br/>        return prefix_sum_array[r]<br/>    return prefix_sum_array[r] - prefix_sum_array[l - 1]</span></pre><p id="ab7b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">时间&amp;空间复杂度</strong> —如果数组的大小为 n，要回答的查询数为 q，那么时间复杂度为 O(n + q)。其中，构造前缀和数组需要 O(n ),回答每个查询需要 O(1)时间。因为前缀和数组的大小为 n，所以解的空间复杂度为 O(n)。</p><h2 id="32f4" class="lm lh iy bd ln lo lp dn lq lr ls dp lt kg lu lv lw kk lx ly lz ko ma mb mc md bi translated">范围和查询 2D</h2><p id="1583" class="pw-post-body-paragraph jv jw iy jx b jy me ka kb kc mf ke kf kg mg ki kj kk mh km kn ko mi kq kr ks ig bi translated">给定一个 2D 矩阵<code class="fe kt ku kv kw b">matrix</code>，处理以下类型的多个查询:</p><ul class=""><li id="a413" class="mo mp iy jx b jy jz kc kd kg mq kk mr ko ms ks mt mu mv mw bi translated">计算其左上角<strong class="jx iz"/><code class="fe kt ku kv kw b">(row1, col1)</code>和右下角<strong class="jx iz"/><code class="fe kt ku kv kw b">(row2, col2)</code>定义的矩形内<code class="fe kt ku kv kw b">matrix</code>元素的<strong class="jx iz">和</strong>。</li></ul><p id="2167" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">实现<code class="fe kt ku kv kw b">NumMatrix</code>类:</p><ul class=""><li id="c1e6" class="mo mp iy jx b jy jz kc kd kg mq kk mr ko ms ks mt mu mv mw bi translated"><code class="fe kt ku kv kw b">NumMatrix(int[][] matrix)</code>用整数矩阵<code class="fe kt ku kv kw b">matrix</code>初始化对象。</li><li id="daf9" class="mo mp iy jx b jy mx kc my kg mz kk na ko nb ks mt mu mv mw bi translated"><code class="fe kt ku kv kw b">int sumRegion(int row1, int col1, int row2, int col2)</code>返回其左上角<strong class="jx iz"/><code class="fe kt ku kv kw b">(row1, col1)</code>和右下角<strong class="jx iz"/><code class="fe kt ku kv kw b">(row2, col2)</code>定义的矩形内<code class="fe kt ku kv kw b">matrix</code>元素的<strong class="jx iz">和</strong>。</li></ul><p id="229d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你必须设计一个算法，让<code class="fe kt ku kv kw b">sumRegion</code>对<code class="fe kt ku kv kw b">O(1)</code>的时间复杂度起作用。</p><p id="4d93" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">方法:这是一个与前一个例子类似的问题。不同之处在于，这里用矩阵代替了数组。所以我们可以计算水平和垂直前缀和。</p><figure class="ky kz la lb gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nc"><img src="../Images/4b2c4f0f21f9fe4c13eab9e03a83d93a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9rY_kEH785igY0lmWUcLRw.png"/></div></div></figure><p id="7ce7" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在第三个矩阵中，在上面的 pic 中，我们看到每个单元值表示在该单元结束并从(0，0)开始的矩阵的总和。</p><figure class="ky kz la lb gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nd"><img src="../Images/55c1961aa6bebfe4cfa76c6335e7a222.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Cg6VNrqQL7IODV61evbGg.png"/></div></div></figure><p id="729c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的图片中，我们试图找到(2，2)和(4，4)之间形成的子矩阵的元素之和。这个矩阵包含元素(0，1，5，0，1，7，3，0，5)。这些元素的和是 22。前缀矩阵中(4，4)处的值表示在(0，0)和(4，4)之间形成的子矩阵的和。类似地，(1，4)处的值表示(0，0)和(1，4)之间的子矩阵的元素之和。此外,( 4，1)处的值表示在(0，0)和(4，1)之间形成的子矩阵的元素之和。</p><p id="421e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">子矩阵[(2，2) → (4，4) ] =子矩阵(4，4) —子矩阵(1，4) —子矩阵(4，1) +子矩阵(1，1)。最后一次相加是由于(0，0)和(1，1)之间的元素在(1，4)和(4，1)子矩阵中是公共的，并且它们被减去两次。所以我们加了一次。</p><p id="0d2d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上述逻辑的代码实现:</p><pre class="ky kz la lb gt lc kw ld bn le lf bi"><span id="741e" class="lg lh iy kw b be li lj l lk ll">class NumMatrix:<br/>    def __init__(self, matrix: List[List[int]]):<br/>        m, n = len(matrix), len(matrix[0])<br/>        for row in range(m):<br/>            for col in range(1, n):<br/>                matrix[row][col] += matrix[row][col - 1]<br/><br/>        for row in range(1, m):<br/>            for col in range(n):<br/>                matrix[row][col] += matrix[row-1][col]<br/><br/>        self.matrix = matrix<br/><br/>    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -&gt; int:<br/>        answer = self.matrix[row2][col2]<br/>        if col1 - 1 &gt;= 0: <br/>            answer -= self.matrix[row2][col1 - 1]<br/>        if row1 - 1 &gt;= 0:<br/>            answer -= self.matrix[row1 - 1][col2]<br/>        if row1 - 1 &gt;= 0 and col1 - 1 &gt;= 0:<br/>            answer += self.matrix[row1 - 1][col1 - 1]<br/>        return answer</span></pre><p id="6980" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的例子中，我们在固定的时间内回答每个查询。我们取 O(n*n)来生成前缀矩阵。所以时间复杂度是 O(n*n + q)。</p><h2 id="69aa" class="lm lh iy bd ln lo lp dn lq lr ls dp lt kg lu lv lw kk lx ly lz ko ma mb mc md bi translated">除自身以外的数组乘积</h2><p id="4e5b" class="pw-post-body-paragraph jv jw iy jx b jy me ka kb kc mf ke kf kg mg ki kj kk mh km kn ko mi kq kr ks ig bi translated">给定一个整数数组<code class="fe kt ku kv kw b">nums</code>，返回<em class="ne">一个数组</em> <code class="fe kt ku kv kw b">answer</code> <em class="ne">使得</em> <code class="fe kt ku kv kw b">answer[i]</code> <em class="ne">等于</em> <code class="fe kt ku kv kw b">nums</code> <em class="ne">除</em> <code class="fe kt ku kv kw b">nums[i]</code>之外的所有元素的乘积。</p><p id="fefa" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kt ku kv kw b">nums</code>的任何前缀或后缀的乘积是<strong class="jx iz">保证</strong>适合一个<strong class="jx iz"> 32 位</strong>整数。你必须写一个在<code class="fe kt ku kv kw b">O(n)</code>时间内运行并且不使用除法运算的算法。</p><h2 id="9475" class="lm lh iy bd ln lo lp dn lq lr ls dp lt kg lu lv lw kk lx ly lz ko ma mb mc md bi translated">方法</h2><p id="7f44" class="pw-post-body-paragraph jv jw iy jx b jy me ka kb kc mf ke kf kg mg ki kj kk mh km kn ko mi kq kr ks ig bi translated">这个问题可以用前缀和的思想来解决。我们创建两个数组:</p><ul class=""><li id="5894" class="mo mp iy jx b jy jz kc kd kg mq kk mr ko ms ks mt mu mv mw bi translated">计算前缀乘法</li><li id="b362" class="mo mp iy jx b jy mx kc my kg mz kk na ko nb ks mt mu mv mw bi translated">计算后缀乘法(前缀从右到左)</li></ul><figure class="ky kz la lb gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nf"><img src="../Images/0ea746e5321bb0632b64530d12a73017.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gys9GGCZdllcL9XozooZsQ.png"/></div></div></figure><h2 id="49ea" class="lm lh iy bd ln lo lp dn lq lr ls dp lt kg lu lv lw kk lx ly lz ko ma mb mc md bi translated">代码实现</h2><pre class="ky kz la lb gt lc kw ld bn le lf bi"><span id="218d" class="lg lh iy kw b be li lj l lk ll">class Solution:<br/>    def productExceptSelf(self, nums: List[int]) -&gt; List[int]:<br/>        left_products = []<br/>        right_products = []<br/>        result = []<br/>        <br/>        left_prod = 1<br/>        for num in nums:<br/>            left_products.append(left_prod)<br/>            left_prod *= num<br/>        <br/>        right_prod = 1<br/>        for num in nums[::-1]:<br/>            right_products.append(right_prod)<br/>            right_prod *= num<br/>        right_products = right_products[::-1]<br/>        <br/>        return [left * right for left, right in zip(left_products, right_products)]</span></pre><h2 id="78d3" class="lm lh iy bd ln lo lp dn lq lr ls dp lt kg lu lv lw kk lx ly lz ko ma mb mc md bi translated">最大子阵列和等于 k</h2><p id="18f0" class="pw-post-body-paragraph jv jw iy jx b jy me ka kb kc mf ke kf kg mg ki kj kk mh km kn ko mi kq kr ks ig bi translated">给定一个整数数组<code class="fe kt ku kv kw b">nums</code>和一个整数<code class="fe kt ku kv kw b">k</code>，返回<em class="ne">总计为</em> <code class="fe kt ku kv kw b">k</code>的子数组的最大长度。如果没有，则返回<code class="fe kt ku kv kw b">0</code>。</p><h2 id="f35a" class="lm lh iy bd ln lo lp dn lq lr ls dp lt kg lu lv lw kk lx ly lz ko ma mb mc md bi translated">方法</h2><p id="fe3b" class="pw-post-body-paragraph jv jw iy jx b jy me ka kb kc mf ke kf kg mg ki kj kk mh km kn ko mi kq kr ks ig bi translated">我们使用前缀 sum 和 two sum 以及字典方法来解决这个问题。我们继续计算前缀总和，然后检查 target-curr 前缀总和是否在 sum_index_map 中。</p><h2 id="e4ca" class="lm lh iy bd ln lo lp dn lq lr ls dp lt kg lu lv lw kk lx ly lz ko ma mb mc md bi translated">代码实现</h2><pre class="ky kz la lb gt lc kw ld bn le lf bi"><span id="7a89" class="lg lh iy kw b be li lj l lk ll">class Solution:<br/>    def maxSubArrayLen(self, nums: List[int], k: int) -&gt; int:<br/>        sum_idx_map = defaultdict(list)<br/>        prev = 0<br/>        max_len = -math.inf<br/>        for idx, num in enumerate(nums):<br/>            curr_sum = prev + num<br/>            prev = curr_sum<br/>            sum_idx_map[curr_sum].append(idx)<br/>            if curr_sum == k:<br/>                max_len = max(max_len, idx+1)<br/>            if (curr_sum - k) in sum_idx_map:<br/>                max_len = max(max_len, idx - sum_idx_map[curr_sum - k][0])<br/>                <br/>        return max_len if max_len != -math.inf else 0</span></pre><h2 id="0d8e" class="lm lh iy bd ln lo lp dn lq lr ls dp lt kg lu lv lw kk lx ly lz ko ma mb mc md bi translated">范围和的计数</h2><p id="23de" class="pw-post-body-paragraph jv jw iy jx b jy me ka kb kc mf ke kf kg mg ki kj kk mh km kn ko mi kq kr ks ig bi translated">给定一个整数数组<code class="fe kt ku kv kw b">nums</code>和两个整数<code class="fe kt ku kv kw b">lower</code>和<code class="fe kt ku kv kw b">upper</code>，返回<em class="ne">位于</em><code class="fe kt ku kv kw b">[lower, upper]</code><em class="ne"/>中的范围和的个数。范围和<code class="fe kt ku kv kw b">S(i, j)</code>被定义为索引<code class="fe kt ku kv kw b">i</code>和<code class="fe kt ku kv kw b">j</code>之间的<code class="fe kt ku kv kw b">nums</code>中元素的和，其中<code class="fe kt ku kv kw b">i &lt;= j</code>。</p><h2 id="a2e9" class="lm lh iy bd ln lo lp dn lq lr ls dp lt kg lu lv lw kk lx ly lz ko ma mb mc md bi translated">方法</h2><p id="d871" class="pw-post-body-paragraph jv jw iy jx b jy me ka kb kc mf ke kf kg mg ki kj kk mh km kn ko mi kq kr ks ig bi translated">我们预先计算前缀总和，然后使用二分搜索法来查找范围内的总和数。</p><h2 id="65f1" class="lm lh iy bd ln lo lp dn lq lr ls dp lt kg lu lv lw kk lx ly lz ko ma mb mc md bi translated">代码实现</h2><pre class="ky kz la lb gt lc kw ld bn le lf bi"><span id="3d76" class="lg lh iy kw b be li lj l lk ll">class Solution:<br/>    def countRangeSum(self, nums: List[int], lower: int, upper: int) -&gt; int:<br/>        prefix_sum = list(accumulate(nums))<br/>        prefix_sum_sorted = sorted(prefix_sum)<br/><br/>        ans = n = 0<br/>     <br/>        for i in range(0, len(nums)):<br/><br/>            l = bisect_left(prefix_sum_sorted, lower)<br/>            r = bisect_right(prefix_sum_sorted, upper)<br/><br/>            ans += r - l<br/>            lower += nums[n]<br/>            upper += nums[n]<br/>            prefix_sum_sorted.pop(bisect_left(prefix_sum_sorted, prefix_sum[n]))<br/>            n += 1<br/><br/>        return ans</span></pre><p id="f3aa" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">编码快乐！！</p></div></div>    
</body>
</html>