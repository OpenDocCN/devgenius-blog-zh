<html>
<head>
<title>10 Daily Practice Problems ~ Day 8</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">10 个日常练习题~第 8 天</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/10-daily-practice-problems-day-8-c303db2bd1ef?source=collection_archive---------19-----------------------#2022-10-08">https://blog.devgenius.io/10-daily-practice-problems-day-8-c303db2bd1ef?source=collection_archive---------19-----------------------#2022-10-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/852c4fb7ec099007609c9af851efa461.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*txcoGepAcbqkDE8h.png"/></div></div></figure><h1 id="ea47" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated"><a class="ae kt" href="https://leetcode.com/problems/same-tree/" rel="noopener ugc nofollow" target="_blank"> 1。同一棵树</a></h1><p id="44ca" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">给定两个二叉树<code class="fe ls lt lu lv b">p</code>和<code class="fe ls lt lu lv b">q</code>的根，写一个函数检查它们是否相同。</p><p id="a76c" class="pw-post-body-paragraph ku kv in kw b kx lw kz la lb lx ld le lf ly lh li lj lz ll lm ln ma lp lq lr ig bi translated">如果两个二叉树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/bd0cc849717702bc0341cba83ad0b3fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/0*uZEJES1hJS8K3RrB.jpg"/></div></figure><pre class="mc md me mf gt mg lv mh mi aw mj bi"><span id="3344" class="mk jw in lv b gy ml mm l mn mo"><strong class="lv io">Input:</strong> p = [1,2,3], q = [1,2,3]<br/><strong class="lv io">Output:</strong> true</span></pre><p id="bd58" class="pw-post-body-paragraph ku kv in kw b kx lw kz la lb lx ld le lf ly lh li lj lz ll lm ln ma lp lq lr ig bi translated">解决方案:</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mp"><img src="../Images/7fc544fa26f5c9a80e4dd5b391d59362.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S4KOpiZsVsTujUv8kIUk_A.png"/></div></div></figure><h1 id="f4cc" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated"><a class="ae kt" href="https://leetcode.com/problems/symmetric-tree/" rel="noopener ugc nofollow" target="_blank"> 2。对称树</a></h1><p id="2481" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">给定二叉树的<code class="fe ls lt lu lv b">root</code>，<em class="mq">检查它是否是自身的镜像</em>(即围绕其中心对称)。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/ad6ae87cfd84bdd915373f95ac63da06.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/0*ZAPtvJsDhBFf-rWO.jpg"/></div></figure><pre class="mc md me mf gt mg lv mh mi aw mj bi"><span id="4c7d" class="mk jw in lv b gy ml mm l mn mo"><strong class="lv io">Input:</strong> root = [1,2,2,3,4,4,3]<br/><strong class="lv io">Output:</strong> true</span></pre><p id="36a0" class="pw-post-body-paragraph ku kv in kw b kx lw kz la lb lx ld le lf ly lh li lj lz ll lm ln ma lp lq lr ig bi translated">解决方案:</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ms"><img src="../Images/ebf42be2df7f7557d5f84400bedfc406.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GWBuS0UBl73__gsYiAUkIg.png"/></div></div></figure><h1 id="9e15" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated"><a class="ae kt" href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/" rel="noopener ugc nofollow" target="_blank"> 3。将二叉树展平为链表</a></h1><p id="6fe1" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">给定一棵二叉树的<code class="fe ls lt lu lv b">root</code>，将该树展平成一个“链表”:</p><ul class=""><li id="fb00" class="mt mu in kw b kx lw lb lx lf mv lj mw ln mx lr my mz na nb bi translated">“链表”应该使用相同的<code class="fe ls lt lu lv b">TreeNode</code>类，其中<code class="fe ls lt lu lv b">right</code>子指针指向列表中的下一个节点，而<code class="fe ls lt lu lv b">left</code>子指针总是<code class="fe ls lt lu lv b">null</code>。</li><li id="37a7" class="mt mu in kw b kx nc lb nd lf ne lj nf ln ng lr my mz na nb bi translated">“链表”的顺序应该与二叉树的<a class="ae kt" href="https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR" rel="noopener ugc nofollow" target="_blank"> <strong class="kw io">前序遍历</strong> </a>相同。</li></ul><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nh"><img src="../Images/3da44d674bef4de04d5a1a64b74edbc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fIi82MsEdsC6j0cB.jpg"/></div></div></figure><pre class="mc md me mf gt mg lv mh mi aw mj bi"><span id="bd9e" class="mk jw in lv b gy ml mm l mn mo"><strong class="lv io">Input:</strong> root = [1,2,5,3,4,null,6]<br/><strong class="lv io">Output:</strong> [1,null,2,null,3,null,4,null,5,null,6]</span></pre><p id="2ee4" class="pw-post-body-paragraph ku kv in kw b kx lw kz la lb lx ld le lf ly lh li lj lz ll lm ln ma lp lq lr ig bi translated">解决方案:</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/3548af0251e5137bc10873588018fc83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sfP9d2LBBQTZ2TrYAUZThQ.png"/></div></div></figure><h1 id="c989" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated"><a class="ae kt" href="https://practice.geeksforgeeks.org/problems/mirror-tree/1" rel="noopener ugc nofollow" target="_blank"> 4。<strong class="ak">镜像树</strong>镜像树</a></h1><p id="eb50" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">给定一棵二叉树，把它转换成它的镜像。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/ec8f63537315f2bac0931d17441c62dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*Fdj_3P5GucD6WZVT.jpg"/></div></figure><pre class="mc md me mf gt mg lv mh mi aw mj bi"><span id="f029" class="mk jw in lv b gy ml mm l mn mo"><strong class="lv io">Input:<br/></strong>      1<br/>    /  \<br/>   2    3<br/><strong class="lv io">Output: </strong>3 1 2<strong class="lv io"><br/>Explanation: </strong>The tree is<br/>   1    (mirror)  1<br/> /  \    =&gt;      /  \<br/>2    3          3    2<br/>The inorder of mirror is 3 1 2</span></pre><p id="e52d" class="pw-post-body-paragraph ku kv in kw b kx lw kz la lb lx ld le lf ly lh li lj lz ll lm ln ma lp lq lr ig bi translated">解决方案:</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/98e9bc4d8bbd9438e4514a963da13fb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WoD8bl8Hc5xDno-QREzwpQ.png"/></div></div></figure><h1 id="e074" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated"><a class="ae kt" href="https://leetcode.com/problems/binary-tree-maximum-path-sum/" rel="noopener ugc nofollow" target="_blank"> 5。二叉树最大路径和</a></h1><p id="7142" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">二叉树中的<strong class="kw io">路径</strong>是节点序列，其中序列中的每对相邻节点都有连接它们的边。一个节点在序列<strong class="kw io">中最多只能出现一次</strong>。请注意，路径不需要通过根。路径的<strong class="kw io">路径和</strong>是路径中节点值的和。</p><p id="7c8f" class="pw-post-body-paragraph ku kv in kw b kx lw kz la lb lx ld le lf ly lh li lj lz ll lm ln ma lp lq lr ig bi translated">给定二叉树的<code class="fe ls lt lu lv b">root</code>，返回<em class="mq">最大</em> <strong class="kw io"> <em class="mq">路径和</em> </strong> <em class="mq">任意</em> <strong class="kw io"> <em class="mq">非空</em> </strong> <em class="mq">路径</em>。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/6d27f6dc31c10d5dd4180b58b49fb36a.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/0*fNlxuWjLtfBaYEfo.jpg"/></div></figure><pre class="mc md me mf gt mg lv mh mi aw mj bi"><span id="3383" class="mk jw in lv b gy ml mm l mn mo"><strong class="lv io">Input:</strong> root = [-10,9,20,null,null,15,7]<br/><strong class="lv io">Output:</strong> 42<br/><strong class="lv io">Explanation:</strong> The optimal path is 15 -&gt; 20 -&gt; 7 with a path sum of 15 + 20 + 7 = 42.</span></pre><p id="2bef" class="pw-post-body-paragraph ku kv in kw b kx lw kz la lb lx ld le lf ly lh li lj lz ll lm ln ma lp lq lr ig bi translated">解决方案:</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nm"><img src="../Images/56735ea8d77e2eec1daaf2591fda5d76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HsyQEltwG1qsLFzEaD_7iw.png"/></div></div></figure><h1 id="9ac7" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated"><a class="ae kt" href="https://leetcode.com/problems/path-sum/" rel="noopener ugc nofollow" target="_blank"> 6。路径总和</a></h1><p id="8b4a" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">给定一棵二叉树的<code class="fe ls lt lu lv b">root</code>和一个整数<code class="fe ls lt lu lv b">targetSum</code>，如果该树有一条<strong class="kw io">根到叶的</strong>路径，使得沿着该路径的所有值相加等于<code class="fe ls lt lu lv b">targetSum</code>，则返回<code class="fe ls lt lu lv b">true</code>。<em class="mq">一个</em> <strong class="kw io"> <em class="mq">叶</em> </strong> <em class="mq">是一个没有子节点的节点。</em></p><figure class="mc md me mf gt jo gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/f858f91ed3d0a156b37dcc9cc278b8d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/0*KkTuiyJcmzwJMQ2t.jpg"/></div></figure><pre class="mc md me mf gt mg lv mh mi aw mj bi"><span id="a0a1" class="mk jw in lv b gy ml mm l mn mo"><strong class="lv io">Input:</strong> root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22<br/><strong class="lv io">Output:</strong> true<br/><strong class="lv io">Explanation:</strong> The root-to-leaf path with the target sum is shown.</span></pre><p id="e16a" class="pw-post-body-paragraph ku kv in kw b kx lw kz la lb lx ld le lf ly lh li lj lz ll lm ln ma lp lq lr ig bi translated">解决方案:</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi no"><img src="../Images/7990cfb0184ba92613a040c59491c5c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rhIKsGmO5BbOl3MfS47s9A.png"/></div></div></figure><h1 id="e55b" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated"><a class="ae kt" href="https://practice.geeksforgeeks.org/problems/print-a-binary-tree-in-vertical-order/1" rel="noopener ugc nofollow" target="_blank"> 7。二叉树的垂直顺序遍历</a></h1><p id="94ea" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">给定一棵二叉树，求它从最左到最右的垂直遍历。<br/>如果有多个节点穿过一条垂直线，那么它们应该按照<strong class="kw io">层级顺序</strong>遍历树的顺序打印。</p><pre class="mc md me mf gt mg lv mh mi aw mj bi"><span id="a323" class="mk jw in lv b gy ml mm l mn mo"><strong class="lv io">Input:</strong><br/>           1<br/>         /   \<br/>       2       3<br/>     /   \   /   \<br/>   4      5 6      7<br/>              \      \<br/>               8      9           <br/><strong class="lv io">Output: </strong><br/>4 2 1 5 6 3 8 7 9 <br/><strong class="lv io">Explanation:</strong></span></pre><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi np"><img src="../Images/746780336d7290598286d92a1e10c5ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/0*xZMiRGLVP3D0Fv7m.png"/></div></div></figure><p id="d6be" class="pw-post-body-paragraph ku kv in kw b kx lw kz la lb lx ld le lf ly lh li lj lz ll lm ln ma lp lq lr ig bi translated">解决方案:</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nq"><img src="../Images/7a7bbf0b394ef5a5d0a402a5b53476a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vlkoNnT9DIqD4UE-O4kQ6w.png"/></div></div></figure><h1 id="1d19" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">8。<strong class="ak">二叉树</strong>仰视图</h1><p id="7c5c" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">给定一棵二叉树，从左到右打印底部视图。<br/>如果当我们从底部看树时，一个节点可以被看到，则该节点被包括在底部视图中。</p><pre class="mc md me mf gt mg lv mh mi aw mj bi"><span id="59a4" class="mk jw in lv b gy ml mm l mn mo"><strong class="lv io">Input:<br/></strong>       1<br/>     /   \<br/>    3     2<br/><strong class="lv io">Output: </strong>3 1 2<strong class="lv io"><br/>Explanation:</strong><br/>First case represents a tree with 3 nodes<br/>and 2 edges where root is 1, left child of<br/>1 is 3 and right child of 1 is 2.</span></pre><figure class="mc md me mf gt jo gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/e83ddb9e731c273bb021522c43be4540.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/0*DqV59NRKw3-fJSbb.jpg"/></div></figure><pre class="mc md me mf gt mg lv mh mi aw mj bi"><span id="36b6" class="mk jw in lv b gy ml mm l mn mo">Thus nodes of the binary tree will be<br/>printed as such 3 1 2.</span></pre><p id="cda4" class="pw-post-body-paragraph ku kv in kw b kx lw kz la lb lx ld le lf ly lh li lj lz ll lm ln ma lp lq lr ig bi translated">解决方案:</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ns"><img src="../Images/c39b49df97d0b6f849374b21d9b30c3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B4VlqqHp66Wp-tEv1tBmrg.png"/></div></div></figure><h1 id="220d" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">9。<strong class="ak">二叉树</strong>顶视图</h1><p id="d910" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">下面给出的是一棵二叉树。任务是打印二叉树的顶视图。二叉树的顶视图是当从顶部查看该树时可见的节点集。对于下面给定的树</p><pre class="mc md me mf gt mg lv mh mi aw mj bi"><span id="4ee4" class="mk jw in lv b gy ml mm l mn mo"><strong class="lv io">Input:<br/></strong>       10<br/>    /      \<br/>  20        30<br/> /   \    /    \<br/>40   60  90    100</span><span id="8de8" class="mk jw in lv b gy nt mm l mn mo"><strong class="lv io">Output: </strong>40 20 10 30 100</span></pre><p id="1b37" class="pw-post-body-paragraph ku kv in kw b kx lw kz la lb lx ld le lf ly lh li lj lz ll lm ln ma lp lq lr ig bi translated">解决方案:</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nu"><img src="../Images/c21758545eedca595a1db8c45a71910b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0VGyOijkMWiy2eokZKm83g.png"/></div></div></figure><h1 id="3dc9" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">10。<strong class="ak">反转二叉树</strong> </h1><p id="f0c5" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">给定二叉树的<code class="fe ls lt lu lv b">root</code>，反转该树，并返回其根<em class="mq">。</em></p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nv"><img src="../Images/77fa9f5ed0b15b4eafc5c2649d5bc59f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CAKpzHL6OKp_INIR.jpg"/></div></div></figure><pre class="mc md me mf gt mg lv mh mi aw mj bi"><span id="9a79" class="mk jw in lv b gy ml mm l mn mo"><strong class="lv io">Input:</strong> root = [4,2,7,1,3,6,9]<br/><strong class="lv io">Output:</strong> [4,7,2,9,6,3,1]</span></pre><p id="72ec" class="pw-post-body-paragraph ku kv in kw b kx lw kz la lb lx ld le lf ly lh li lj lz ll lm ln ma lp lq lr ig bi translated">解决方案:</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nw"><img src="../Images/e42baa61cbd03acf193964d616a718f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*smIkiY0KYHUSo4NcZ3ZCeg.png"/></div></div></figure></div></div>    
</body>
</html>