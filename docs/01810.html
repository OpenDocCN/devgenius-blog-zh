<html>
<head>
<title>Data Binding with MVVM on iOS part 2: KeyPath and Type Erasure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS上MVVM的数据绑定第2部分:关键路径和类型擦除</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/data-binding-in-ios-part-2-keypath-and-type-erasure-8f5a5d2d1571?source=collection_archive---------17-----------------------#2020-07-12">https://blog.devgenius.io/data-binding-in-ios-part-2-keypath-and-type-erasure-8f5a5d2d1571?source=collection_archive---------17-----------------------#2020-07-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="7196" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个故事是关于我如何用Swift KeyPath实现单向和双向数据绑定的。在阅读这个故事之前，您可能需要查看第1部分，以了解我采用的是哪种数据流策略。</p><div class="ki kj gp gr kk kl"><a href="https://medium.com/dev-genius/data-binding-in-ios-part-1-data-flows-in-mvc-3d182c065e4" rel="noopener follow" target="_blank"><div class="km ab fo"><div class="kn ab ko cl cj kp"><h2 class="bd io gy z fp kq fr fs kr fu fw im bi translated">iOS中的数据绑定第1部分:MVC中的数据流</h2><div class="ks l"><h3 class="bd b gy z fp kq fr fs kr fu fw dk translated">Android提供数据绑定来监听模型的变化和更新绑定视图。但是如何在…</h3></div><div class="kt l"><p class="bd b dl z fp kq fr fs kr fu fw dk translated">medium.com</p></div></div><div class="ku l"><div class="kv l kw kx ky ku kz la kl"/></div></div></a></div><h1 id="2010" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">为什么选择KeyPath？</h1><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="e6be" class="mi lc in me b gy mj mk l ml mm">\TypeName.path</span></pre><h2 id="47f8" class="mi lc in bd ld mn mo dn lh mp mq dp ll jv mr ms lp jz mt mu lt kd mv mw lx mx bi translated"><strong class="ak"> 1。动态和一致性</strong></h2><p id="8ab5" class="pw-post-body-paragraph jk jl in jm b jn my jp jq jr mz jt ju jv na jx jy jz nb kb kc kd nc kf kg kh ig bi translated">键路径表达式提供了一种动态和一致的方法来访问和更新数据。类型可以是任何具体类型或泛型类型，包括普通的<strong class="jm io">结构</strong>和<strong class="jm io"> UI组件</strong>，这是数据绑定的两个重要端点。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="a753" class="mi lc in me b gy mj mk l ml mm">var model = User()<br/>var view = UITextField()</span><span id="d258" class="mi lc in me b gy nd mk l ml mm">model[keyPath: \User.name] = “Tonny”<br/>view[keyPath: \UITextField.text] = “Tonny”</span><span id="da06" class="mi lc in me b gy nd mk l ml mm">view[keyPath: \UITextField.text] = model[keyPath: \User.name]<br/>model[keyPath: \User.name] = view[keyPath: \UITextField.text]</span></pre><p id="0427" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它还能够访问或更新<strong class="jm io">嵌入的</strong>属性。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="9b53" class="mi lc in me b gy mj mk l ml mm">model[keyPath: \User.address.country] = “NZ”</span><span id="9af5" class="mi lc in me b gy nd mk l ml mm">view[keyPath: \UITextField.text] = model[keyPath: \User.address.country]</span></pre><h2 id="f5d8" class="mi lc in bd ld mn mo dn lh mp mq dp ll jv mr ms lp jz mt mu lt kd mv mw lx mx bi translated"><strong class="ak"> 2。摘要如何作为什么</strong></h2><p id="31cb" class="pw-post-body-paragraph jk jl in jm b jn my jp jq jr mz jt ju jv na jx jy jz nb kb kc kd nc kf kg kh ig bi translated">当实现一个表单UI时，有大量的代码来监听视图的变化并更新相关的模型。这个任务仅仅是关于如何从视图中更新模型和从模型中更新视图。关键路径表达式是将那些<strong class="jm io">如何</strong>视为<strong class="jm io">什么</strong>的抽象方式，减少了重复监听和更新代码。</p><ul class=""><li id="d992" class="ne nf in jm b jn jo jr js jv ng jz nh kd ni kh nj nk nl nm bi translated"><strong class="jm io">如何更新属性？</strong></li></ul><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="e1f2" class="mi lc in me b gy mj mk l ml mm">func textChanged(field: UITextFeild) {<br/>    let tag = field.tag<br/>    let text = field.text<br/>    <br/>    if tag == 1 {<br/>        user.name = text<br/>    }else if tag == 2 {<br/>        user.email = text<br/>    }else if tag == 3 {<br/>        user.phone = text<br/>    }<br/>}</span></pre><ul class=""><li id="5526" class="ne nf in jm b jn jo jr js jv ng jz nh kd ni kh nj nk nl nm bi translated"><strong class="jm io">要更新的属性是什么？</strong></li></ul><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="2324" class="mi lc in me b gy mj mk l ml mm">func textChanged(field: UITextFeild) {<br/>    let propertyKeyPath = keyPathMapping[field.tag]<br/> <br/>    user[keyPath: propertyKeyPath] = value<br/>}</span></pre></div><div class="ab cl nn no hr np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ig ih ii ij ik"><h1 id="96e7" class="lb lc in bd ld le nu lg lh li nv lk ll lm nw lo lp lq nx ls lt lu ny lw lx ly bi translated">单向数据绑定</h1><p id="1e9a" class="pw-post-body-paragraph jk jl in jm b jn my jp jq jr mz jt ju jv na jx jy jz nb kb kc kd nc kf kg kh ig bi translated">单向数据绑定首先启动视图的呈现，然后帮助视图不断地跟随模型的变化。有几种方法可以监听和通知更改，如didSet、KVO或RxSwift。我只是将所有更新逻辑放在一个viewModel中，这是唯一负责模型更新的地方。当ViewModel更新模型时，它会随后更新视图。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="7726" class="mi lc in me b gy mj mk l ml mm">//initial views<br/>lbl[keyPath: \UILabel.text] = user[keyPath: \User.info]<br/>imgView[keyPath: \UIImageView.image] = user[keyPath: \User.image]<br/>textField[keyPath: \UITextField.text] = user[keyPath: \User.name]</span><span id="1b62" class="mi lc in me b gy nd mk l ml mm">//help view to follow model's change<br/>func update&lt;V&gt;(_ modelKeyPath: WritableKeyPath&lt;User, V&gt;, _ value: V){<br/>    <br/>    model[keyPath: modelKeyPath] = value<br/> <br/>    let viewKeyPath = mapping[modelKeyPath]<br/>    view[keyPath: viewKeyPath] = value<br/>}</span></pre><p id="4b80" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">单向绑定中的所有视图组件都有自己唯一的keyPath来初始化和更新视图。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="d7dd" class="mi lc in me b gy mj mk l ml mm">let viewKeyPathes = [<br/>    UILabel: \UILabel.text,<br/>    UIImageView: \UIImageView.image,<br/>]</span></pre><h1 id="906e" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">双向数据绑定</h1><p id="cb22" class="pw-post-body-paragraph jk jl in jm b jn my jp jq jr mz jt ju jv na jx jy jz nb kb kc kd nc kf kg kh ig bi translated">双向数据绑定比单向数据绑定更进一步。它不仅监听模型的变化，还监听视图的变化并相应地更新模型。UI组件双向数据绑定最常见的用法是UITextField。并且<strong class="jm io">add target(_:action:for:)</strong>方法准备好监听视图的变化。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="306b" class="mi lc in me b gy mj mk l ml mm">//initial views, same as above one way binding<br/></span><span id="5747" class="mi lc in me b gy nd mk l ml mm">//help view to follow model’s change, same as above one way binding</span><span id="43d3" class="mi lc in me b gy nd mk l ml mm"><br/>//help model to follow view’s change<br/>field.addTarget(self, #selector(textChanged), for: .editingChanged)</span><span id="803d" class="mi lc in me b gy nd mk l ml mm">func textChanged() {</span><span id="7dea" class="mi lc in me b gy nd mk l ml mm">    user[keyPath: \User.name] = field[keyPath: \UITextField.text]<br/>}</span></pre><p id="8dce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了支持其他UIControls，如UIButton、UISteper、UISwitch、UISlide，侦听器应该是泛型的。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="79dc" class="mi lc in me b gy mj mk l ml mm">let event = type(of: view).bindingEvent<br/>view.addTarget(self, #selector(viewChanged), for: event)</span><span id="c37e" class="mi lc in me b gy nd mk l ml mm">func viewChanged(view: UIControl) {</span><span id="3ee3" class="mi lc in me b gy nd mk l ml mm">    let modelKeyPath = mapping[view.tag]<br/>    let viewKeyPath = type(of: view).bindingKeyPath<br/> <br/>    model[keyPath: modelKeyPath] = view[keyPath: viewKeyPath]<br/>}</span></pre><p id="70a8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所有双向绑定的视图组件不仅有自己的关键路径，而且有相关的事件触发器。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="d81c" class="mi lc in me b gy mj mk l ml mm">let viewKeyPathes = [<br/>    UITextField: \UITextField.text,<br/>    UISteper: \UIStepper.value,<br/>    UISlider: \UISlider.value,<br/>    UISwitch: \UISwitch.isOn,<br/>    UIButton: \UIButton.isSelected,<br/>]</span><span id="fb2e" class="mi lc in me b gy nd mk l ml mm">let viewEvents = [<br/>    UITextField: UIControl.Event.editingChanged,<br/>    UISteper: UIControl.Event.valueChanged,<br/>    UISlider: UIControl.Event.valueChanged,<br/>    UISwitch: UIControl.Event.valueChanged,<br/>    UIButton: UIControl.Event.touchUpInside,<br/>]</span></pre><h2 id="3d5c" class="mi lc in bd ld mn mo dn lh mp mq dp ll jv mr ms lp jz mt mu lt kd mv mw lx mx bi translated">视图和模型的关键路径映射</h2><p id="7033" class="pw-post-body-paragraph jk jl in jm b jn my jp jq jr mz jt ju jv na jx jy jz nb kb kc kd nc kf kg kh ig bi translated">数据绑定描述了视图外观和模型属性之间的关系。对于Swift关键路径，它本质上是关于视图的关键路径和模型的关键路径。我们需要的只是记录视图和模型的关键路径的映射，这样当视图的事件触发或模型改变时，绑定可以自动发生。考虑到不要强烈引用视图，不要用继承定制视图，视图的<strong class="jm io">标签</strong>将是记录映射的最好主意。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="f0c0" class="mi lc in me b gy mj mk l ml mm">let mapping = [<br/>    txtFieldTag: \User.name,<br/>    labelTag:    \User.email,<br/>    buttonTag:   \User.isAdmin,<br/>    switchTag:   \User.isTermsSelected,<br/>    stepperTag:  \User.degree<br/>]</span></pre><p id="5a0b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请注意，视图的标签在映射中应该是唯一的<strong class="jm io"/>。</p><h2 id="68e3" class="mi lc in bd ld mn mo dn lh mp mq dp ll jv mr ms lp jz mt mu lt kd mv mw lx mx bi translated">数据流</h2><p id="d43a" class="pw-post-body-paragraph jk jl in jm b jn my jp jq jr mz jt ju jv na jx jy jz nb kb kc kd nc kf kg kh ig bi translated">关键路径在数据流中的作用如下图所示:</p><figure class="lz ma mb mc gt oa gh gi paragraph-image"><div role="button" tabindex="0" class="ob oc di od bf oe"><div class="gh gi nz"><img src="../Images/0cd7fddfea4cbe065ca69ee0cbaa2054.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YTBVSAo3zzjXJRkbf6zpbw.png"/></div></div><figcaption class="og oh gj gh gi oi oj bd b be z dk translated">数据流</figcaption></figure></div><div class="ab cl nn no hr np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ig ih ii ij ik"><h1 id="a5e7" class="lb lc in bd ld le nu lg lh li nv lk ll lm nw lo lp lq nx ls lt lu ny lw lx ly bi translated">关键路径的问题</h1><p id="039d" class="pw-post-body-paragraph jk jl in jm b jn my jp jq jr mz jt ju jv na jx jy jz nb kb kc kd nc kf kg kh ig bi translated">当我用KeyPath实现数据绑定时，我遇到了两个问题。</p><p id="6047" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第一期。在给定模型的<strong class="jm io"> Int </strong>属性和由<strong class="jm io">\ u stepper . value</strong>检索的值(是<strong class="jm io"> Double </strong>)的情况下，无法使用不匹配</strong> <br/>类型的值更新模型，更新失败是因为类型不匹配。</p><figure class="lz ma mb mc gt oa gh gi paragraph-image"><div role="button" tabindex="0" class="ob oc di od bf oe"><div class="gh gi ok"><img src="../Images/6ada34d5b6342892ddf8baecf531c26f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iXJ2bjxgM2n3D4J-93YGuQ.png"/></div></div><figcaption class="og oh gj gh gi oi oj bd b be z dk translated">类型不匹配</figcaption></figure><figure class="lz ma mb mc gt oa gh gi paragraph-image"><div role="button" tabindex="0" class="ob oc di od bf oe"><div class="gh gi ol"><img src="../Images/aa393afe02f44211e921492048dbbe69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eC5qhw6m16ZDOffLJacIBQ.png"/></div></div><figcaption class="og oh gj gh gi oi oj bd b be z dk translated">类型不匹配</figcaption></figure><p id="76e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">问题#2。集合中KeyPath &lt; Root的泛型值类型，Value &gt;被擦除。</strong> <br/>如果将所有模型的keypath放入一个字典或数组中，keypath的值类型被擦除。当WritableKeyPath &lt;用户，字符串？&gt;和WritableKeyPath &lt;用户，Bool &gt;放入字典，类型将作为PartialKeyPath &lt;用户&gt;丢失，PartialKeyPath不再支持更新模型。由于值类型未知，更新失败。</p><figure class="lz ma mb mc gt oa gh gi paragraph-image"><div role="button" tabindex="0" class="ob oc di od bf oe"><div class="gh gi om"><img src="../Images/93f66e465eff3b5924f14aafac769b59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5wvo7hCAbeASfOiMcaDicw.png"/></div></div></figure></div><div class="ab cl nn no hr np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ig ih ii ij ik"><h1 id="b4db" class="lb lc in bd ld le nu lg lh li nv lk ll lm nw lo lp lq nx ls lt lu ny lw lx ly bi translated">类型擦除</h1><p id="9891" class="pw-post-body-paragraph jk jl in jm b jn my jp jq jr mz jt ju jv na jx jy jz nb kb kc kd nc kf kg kh ig bi translated">类型擦除是具有闭包或块特性的语言中的一种编程范式。这是一种主动擦除类型，但存储起来以备后用的机制，尤其适用于集合。看似丢失了类型，实际上保存了类型的信息。以下是一些例子:</p><ul class=""><li id="d66a" class="ne nf in jm b jn jo jr js jv ng jz nh kd ni kh nj nk nl nm bi translated">当两个WritableKeyPath放入一个数组时，该类型将作为PartialKeyPath <user>丢失，并且PartialKeyPath不再支持更新模型。但使用类型擦除技术，它成功地欺骗了编译器，可以接受任何类型，但只有在类型匹配时才更新模型。</user></li></ul><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="c1fb" class="mi lc in me b gy mj mk l ml mm">struct AnyWritableKeyPath&lt;Root&gt; {</span><span id="2988" class="mi lc in me b gy nd mk l ml mm">    let update: (inout Root, Any) -&gt; ()</span><span id="7151" class="mi lc in me b gy nd mk l ml mm">    init&lt;Value&gt;(_ kp: WritableKeyPath&lt;Root, Value&gt;) {<br/>        update = {<br/>            guard let value = $1 as? Value else {<br/>                return<br/>            }<br/>            <br/>            $0[keyPath: kp] = value<br/>        }<br/>    }<br/>}</span><span id="5b40" class="mi lc in me b gy nd mk l ml mm">let array = [AnyWritableKeyPath(\User.name), AnyWritableKeyPath(\User.likeKiwi)]</span><span id="68f6" class="mi lc in me b gy nd mk l ml mm">array[0].update(&amp;user, dataWithUnknowType)</span></pre><ul class=""><li id="e07a" class="ne nf in jm b jn jo jr js jv ng jz nh kd ni kh nj nk nl nm bi translated">当闭包存储在集合中时，类型的信息会丢失。我们必须主动抹去它，但把它留到以后。</li></ul><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="4bcc" class="mi lc in me b gy mj mk l ml mm">let stringClosure: (String) -&gt; () = {<br/>    //...<br/>}</span><span id="5140" class="mi lc in me b gy nd mk l ml mm">let intClosure: (Int) -&gt; () = {<br/>    //...<br/>}</span><span id="97b8" class="mi lc in me b gy nd mk l ml mm">struct AnyClosure {<br/>    let invoke: (Any)-&gt;()</span><span id="3356" class="mi lc in me b gy nd mk l ml mm">    init&lt;T&gt;(_ closure: <a class="ae on" href="http://twitter.com/escaping" rel="noopener ugc nofollow" target="_blank">@escaping</a> (T) -&gt; ()) {<br/>        invoke = { v in<br/>            if let v = v as? T {<br/>                closure(v)<br/>            }<br/>        }<br/>    }<br/>}</span><span id="b4a8" class="mi lc in me b gy nd mk l ml mm">[AnyClosure(stringClosure), AnyClosure(intClosure)].forEach {<br/>    $0.invoke("a")<br/>}</span></pre><ul class=""><li id="3406" class="ne nf in jm b jn jo jr js jv ng jz nh kd ni kh nj nk nl nm bi translated">AnyView引用了包装视图的属性、函数和类型信息。</li></ul><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="e97b" class="mi lc in me b gy mj mk l ml mm">class AnyView {<br/>    let referToTag: Int<br/>    weak var weakReference: UIView?</span><span id="fb6f" class="mi lc in me b gy nd mk l ml mm">    let referToFunction: (Any, Selector, UIControl.Event)-&gt;()</span><span id="0352" class="mi lc in me b gy nd mk l ml mm">    init&lt;V: UIView&gt;(_ view: V) {<br/>        referToTag = view.tag<br/>        weakReference = view        </span><span id="7cb4" class="mi lc in me b gy nd mk l ml mm">        referToFunction = {<br/>            if let v = view as? UIControl {<br/>                v.addTarget($0, action: $1, for: $2)<br/>            }<br/>        }<br/>    }<br/>}</span><span id="4395" class="mi lc in me b gy nd mk l ml mm">[AnyView(UIView()), AnyView(UIButton())].forEach {<br/>    $0.referToFunction(viewModel, action, event)<br/>}</span></pre><p id="1164" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意，类型擦除是对抗强类型特性的一个技巧，有时没有类型约束是不安全的。不要滥用它。</p></div><div class="ab cl nn no hr np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ig ih ii ij ik"><h1 id="b79d" class="lb lc in bd ld le nu lg lh li nv lk ll lm nw lo lp lq nx ls lt lu ny lw lx ly bi translated">数据绑定在起作用</h1><p id="f91a" class="pw-post-body-paragraph jk jl in jm b jn my jp jq jr mz jt ju jv na jx jy jz nb kb kc kd nc kf kg kh ig bi translated">首先，定义双向可绑定视图，它有keypath呈现外观和事件来更新模型。</p><figure class="lz ma mb mc gt oa gh gi paragraph-image"><div role="button" tabindex="0" class="ob oc di od bf oe"><div class="gh gi ok"><img src="../Images/b410d5ff8667a0c24b884fa5496c2736.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Czc48nFPaVMYj7Gq7mcjw.png"/></div></div></figure><p id="83ce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">TwoWayBinding描述了视图和模型属性的绑定，它使用一个闭包来存储模型的属性类型。通过Swift KeyPath，它支持从视图更新模型，从模型更新视图，并更新两者。</p><figure class="lz ma mb mc gt oa gh gi paragraph-image"><div role="button" tabindex="0" class="ob oc di od bf oe"><div class="gh gi oo"><img src="../Images/a6ca764d68796892d501d7f37b14b555.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AEFcZoXiJ8QVD27JL5MDZA.png"/></div></div><figcaption class="og oh gj gh gi oi oj bd b be z dk translated">双向数据绑定</figcaption></figure><p id="f1fd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">视图和模型属性的映射现在和平地存储在一个集合中，不会丢失类型。</p><figure class="lz ma mb mc gt oa gh gi paragraph-image"><div role="button" tabindex="0" class="ob oc di od bf oe"><div class="gh gi op"><img src="../Images/5193f7afa2bc6c6d0690b40e4d70bfb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gxQmKlsZtvcZvIi-S_yumQ.png"/></div></div></figure><p id="a84e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">定义绑定后，ViewModel承担剩余的工作，它作为<strong class="jm io">控制器</strong>工作，如上图所示。它负责通知视图对模型的更改，并随后更新模型和视图。</p><figure class="lz ma mb mc gt oa gh gi paragraph-image"><div role="button" tabindex="0" class="ob oc di od bf oe"><div class="gh gi op"><img src="../Images/ddae1563338b917d808a03684801e1c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FBZl3eXIimRY79-LAT-Qcw.png"/></div></div><figcaption class="og oh gj gh gi oi oj bd b be z dk translated">数据绑定视图模型</figcaption></figure><p id="5eb7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在中缀操作符的帮助下，绑定变得简单明了。</p><figure class="lz ma mb mc gt oa gh gi paragraph-image"><div role="button" tabindex="0" class="ob oc di od bf oe"><div class="gh gi oq"><img src="../Images/48cfea395e86df10231aab369f15052d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bW05Rpm3RqibDh8eUMArAg.png"/></div></div></figure><p id="386f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">到目前为止还不错，但是在某些情况下，当在视图中显示时，您可能需要格式化数据，或者需要转换类型，因为视图的keyPath类型与模型的属性类型不匹配。所以运营商需要这样改进。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="0dde" class="mi lc in me b gy mj mk l ml mm">uiLabel  &lt;- \.text + { "This is $0"}<br/>uiSteper &lt;~ \.age  + { Double($0) } + { Int($0) }</span></pre></div><div class="ab cl nn no hr np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ig ih ii ij ik"><p id="d980" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在玩了几天KeyPath之后，我创建了一个演示表单应用程序。它侧重于单向和双向数据绑定，包括以下特性:</p><div class="ki kj gp gr kk kl"><a href="https://github.com/tonnylitao/AwesomeKeyPath" rel="noopener  ugc nofollow" target="_blank"><div class="km ab fo"><div class="kn ab ko cl cj kp"><h2 class="bd io gy z fp kq fr fs kr fu fw im bi translated">tonnylitao/AwesomeKeyPath</h2><div class="ks l"><h3 class="bd b gy z fp kq fr fs kr fu fw dk translated">Swift KeyPath非常棒，它可以用于数据绑定、预测和测试。</h3></div><div class="kt l"><p class="bd b dl z fp kq fr fs kr fu fw dk translated">github.com</p></div></div><div class="ku l"><div class="or l kw kx ky ku kz la kl"/></div></div></a></div><ul class=""><li id="ecfb" class="ne nf in jm b jn jo jr js jv ng jz nh kd ni kh nj nk nl nm bi translated">中缀运算符绑定视图和模型的关键路径</li></ul><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="00ce" class="mi lc in me b gy mj mk l ml mm">label &lt;- model's keyPath  //one way<br/>field &lt;-&gt; model's keyPath  //two way</span></pre><ul class=""><li id="b864" class="ne nf in jm b jn jo jr js jv ng jz nh kd ni kh nj nk nl nm bi translated">与UILabel、UIImageView、UITextField、UISwitch、UIButton、UISlider、UIStepper的<strong class="jm io"> KeyPath </strong>的数据绑定。</li></ul><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="3438" class="mi lc in me b gy mj mk l ml mm">uiLabel     &lt;-  \.name<br/>uiTextField &lt;-&gt; \.email</span></pre><ul class=""><li id="fce0" class="ne nf in jm b jn jo jr js jv ng jz nh kd ni kh nj nk nl nm bi translated">使用<strong class="jm io">闭包</strong>的数据绑定对于任何视图，它支持从视图到模型的数据格式，反之亦然。</li></ul><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="95b4" class="mi lc in me b gy mj mk l ml mm">uiLabel  &lt;~  (\.text, {<br/>    $0.text = "A prefix $1"<br/>})</span><span id="ec72" class="mi lc in me b gy nd mk l ml mm">uiActivityIndicatorView  &lt;~  (\.isLoading, { view, aBool in<br/>    if aBool {<br/>        view.startAnimating()<br/>    }else {<br/>        view.stopAnimating()<br/>    }<br/>})</span><span id="c46a" class="mi lc in me b gy nd mk l ml mm">uiSteper &lt;~&gt; (\.aInt, { view, aInt in<br/>    view.value = Double(aInt)<br/>}, { view, _ in<br/>    return Int(view.value)<br/>})</span></pre><ul class=""><li id="f9df" class="ne nf in jm b jn jo jr js jv ng jz nh kd ni kh nj nk nl nm bi translated">绑定到一个模型属性的多个视图</li></ul><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="2623" class="mi lc in me b gy mj mk l ml mm">uiTextField &lt;-&gt; \email<br/>uiLable     &lt;~  (\.email, { $0.text = "Your email: $1" })</span></pre><ul class=""><li id="6dcb" class="ne nf in jm b jn jo jr js jv ng jz nh kd ni kh nj nk nl nm bi translated">解除视图与模型的绑定</li></ul><p id="60bf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你对iOS中的标准表单有什么想法？在iOS中如何实现类似的数据绑定呢？欢迎评论，在Swift玩得开心。</p></div></div>    
</body>
</html>