<html>
<head>
<title>Time Complexity, Space Complexity, and Big O Notation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">时间复杂性、空间复杂性和大O符号</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/time-complexity-space-complexity-and-big-o-notation-500d6104f727?source=collection_archive---------4-----------------------#2020-08-19">https://blog.devgenius.io/time-complexity-space-complexity-and-big-o-notation-500d6104f727?source=collection_archive---------4-----------------------#2020-08-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/28a553aa6c5fb6e3665ac42062ca9123.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dT1sRmrgn7oH9n7-xzeEuA.jpeg"/></div></div></figure><p id="8f02" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我的数据结构和算法系列的第一篇文章。作为一名新兵训练营的毕业生，我发现一旦我开始了软件开发的职业生涯，我的基础知识就会出现缺口。虽然我不是日复一日地颠倒二叉树，但我确实认为学习这些基础知识很重要，因为知道它们的存在，你将成为更好的开发人员。本周，我首先讨论时间和空间的复杂性，以及如何使用大O符号来确定这些度量。</p><h1 id="9f5c" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">时间复杂度</h1><blockquote class="lu lv lw"><p id="f6d9" class="jy jz lx ka b kb kc kd ke kf kg kh ki ly kk kl km lz ko kp kq ma ks kt ku kv ij bi translated">算法完成所需的计算时间的度量单位</p></blockquote><p id="2d67" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">是什么导致了时间复杂性？</p><ul class=""><li id="c62e" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated">操作(<code class="fe mk ml mm mn b">+</code>、<code class="fe mk ml mm mn b">-</code>、<code class="fe mk ml mm mn b">*</code>、<code class="fe mk ml mm mn b">/</code>)</li><li id="3298" class="mb mc iq ka b kb mo kf mp kj mq kn mr kr ms kv mg mh mi mj bi translated">比较(<code class="fe mk ml mm mn b">&gt;</code>、<code class="fe mk ml mm mn b">&lt;</code>、<code class="fe mk ml mm mn b">==</code>)</li><li id="2e65" class="mb mc iq ka b kb mo kf mp kj mq kn mr kr ms kv mg mh mi mj bi translated">循环(<code class="fe mk ml mm mn b">for</code>，<code class="fe mk ml mm mn b">while</code>)</li><li id="b65d" class="mb mc iq ka b kb mo kf mp kj mq kn mr kr ms kv mg mh mi mj bi translated">外部函数调用(<code class="fe mk ml mm mn b">function()</code>)</li></ul><h1 id="9df8" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">大O符号</h1><blockquote class="lu lv lw"><p id="1605" class="jy jz lx ka b kb kc kd ke kf kg kh ki ly kk kl km lz ko kp kq ma ks kt ku kv ij bi translated">我们用来谈论算法运行所需时间的语言和度量</p></blockquote><h2 id="e0ac" class="mt kx iq bd ky mu mv dn lc mw mx dp lg kj my mz lk kn na nb lo kr nc nd ls ne bi translated">O(1)常数时间</h2><blockquote class="lu lv lw"><p id="6234" class="jy jz lx ka b kb kc kd ke kf kg kh ki ly kk kl km lz ko kp kq ma ks kt ku kv ij bi translated">不受输入大小的限制，只执行一次操作</p></blockquote><ul class=""><li id="6a10" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated">直接查询您正在寻找的数据</li><li id="45e5" class="mb mc iq ka b kb mo kf mp kj mq kn mr kr ms kv mg mh mi mj bi translated">不涉及迭代(循环)</li></ul><p id="27ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您知道想要从对象<code class="fe mk ml mm mn b">{}</code>或数组<code class="fe mk ml mm mn b">[]</code>中提取的数据的精确位置，您可以查询该项，而不必迭代或执行任何额外的计算。</p><p id="cfbb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">大多数时候，如果你使用<em class="lx">常数时间</em>，从性能的角度来看，你处于良好的状态。</p><p id="2575" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我给你看一个例子，在这个例子中，我执行的任务评估为<em class="lx">常数时间</em>:</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="747e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我使用<code class="fe mk ml mm mn b">const</code>关键字声明一个带有标识符<code class="fe mk ml mm mn b">jedi</code>的新变量，并给这个变量一个<code class="fe mk ml mm mn b">string</code>值的集合</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="0133" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我使用关键字<code class="fe mk ml mm mn b">function</code>创建一个新函数，并给它一个标识符<code class="fe mk ml mm mn b">findAJedi</code>。该函数将有一个标识符为<code class="fe mk ml mm mn b">jediList</code>的参数</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="1bca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用括号符号<code class="fe mk ml mm mn b">[]</code>我取出索引位置<code class="fe mk ml mm mn b">1</code>中的条目</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="9591" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我们已经知道我们想要的数据在哪里，并且我们不必循环到达那里，这个操作是<code class="fe mk ml mm mn b">O(1)</code>或<em class="lx">常数时间</em></p><p id="3a68" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们用变量<code class="fe mk ml mm mn b">jediList</code>作为单个参数调用<code class="fe mk ml mm mn b">findAJedi</code>函数，我们的<code class="fe mk ml mm mn b">findAJedi</code>函数打印<code class="fe mk ml mm mn b">anakin</code>。他是被选中的人，对吗？</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="ca02" class="mt kx iq bd ky mu mv dn lc mw mx dp lg kj my mz lk kn na nb lo kr nc nd ls ne bi translated">O(n)线性时间</h2><blockquote class="lu lv lw"><p id="994d" class="jy jz lx ka b kb kc kd ke kf kg kh ki ly kk kl km lz ko kp kq ma ks kt ku kv ij bi translated">受输入的约束，时间随着输入的增加而线性增加</p></blockquote><ul class=""><li id="03fe" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated">涉及到寻找一个值的迭代(<code class="fe mk ml mm mn b">for</code>或<code class="fe mk ml mm mn b">while</code>循环)</li></ul><p id="03b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我给你看一个运算结果为<code class="fe mk ml mm mn b">O(n)</code>或<em class="lx">线性时间</em>的例子:</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="f148" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们使用<code class="fe mk ml mm mn b">const</code>关键字创建一个标识符为<code class="fe mk ml mm mn b">jedi</code>的新变量，该变量被赋予一个<code class="fe mk ml mm mn b">Array</code>的值。我们使用<code class="fe mk ml mm mn b">fill()</code>方法用类型为<code class="fe mk ml mm mn b">string</code>的五个<code class="fe mk ml mm mn b">luke</code>值填充这个<code class="fe mk ml mm mn b">Array</code></p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="f6b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们使用关键字<code class="fe mk ml mm mn b">function</code>创建一个带有标识符<code class="fe mk ml mm mn b">findLuke</code>的新函数。该函数将有一个标识符为<code class="fe mk ml mm mn b">jediList</code>的参数</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="205b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的<code class="fe mk ml mm mn b">findLuke</code>函数中，使用<code class="fe mk ml mm mn b">for</code>关键字创建一个<code class="fe mk ml mm mn b">for</code>循环。我们遍历我们的<code class="fe mk ml mm mn b">jediList</code>并使用括号符号<code class="fe mk ml mm mn b">[]</code>来比较每个条目和<code class="fe mk ml mm mn b">luke</code>，当我们找到一个匹配时，我们<code class="fe mk ml mm mn b">console.log</code>它</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="edf6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我们正在遍历整个<code class="fe mk ml mm mn b">Array</code>，所以我们的大O应该是<code class="fe mk ml mm mn b">O(n)</code>。现在我们的<code class="fe mk ml mm mn b">jediList</code>只有五个条目，但是如果我们有10，000个，或者10亿个条目呢？当您编写代码时，这些都是很好的考虑因素。</p><p id="5a48" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们调用带有单个参数的函数<code class="fe mk ml mm mn b">findLuke</code><code class="fe mk ml mm mn b">jedi</code>,因为我们所有的条目都是<code class="fe mk ml mm mn b">luke</code>,所以我们调用了<code class="fe mk ml mm mn b">console.log</code> <code class="fe mk ml mm mn b">luke</code>五次</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="d189" class="mt kx iq bd ky mu mv dn lc mw mx dp lg kj my mz lk kn na nb lo kr nc nd ls ne bi translated">O(n)次时间</h2><blockquote class="lu lv lw"><p id="572c" class="jy jz lx ka b kb kc kd ke kf kg kh ki ly kk kl km lz ko kp kq ma ks kt ku kv ij bi translated">经常被认为是“最坏的情况”,会发生多次嵌套迭代</p></blockquote><ul class=""><li id="8c2a" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated">涉及两个嵌套循环</li><li id="6ed2" class="mb mc iq ka b kb mo kf mp kj mq kn mr kr ms kv mg mh mi mj bi translated">两个集合中的每一项都需要相互比较</li></ul><p id="2f81" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我肯定你以前来过这里，我知道我肯定来过。嵌套循环从来都不是一个好主意，这是有充分理由的。就大O而言，当你迭代一个集合，然后在第一次迭代中再次迭代，这将产生一个大O的<code class="fe mk ml mm mn b">O(n²)</code></p><p id="36a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我给你看一个产生一个大O的函数的例子:</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="4ad0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们使用<code class="fe mk ml mm mn b">const</code>关键字创建一个新变量，它的标识符<code class="fe mk ml mm mn b">jedi</code>被分配给一个包含三个<code class="fe mk ml mm mn b">string</code>值的<code class="fe mk ml mm mn b">Array</code></p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="2808" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们使用<code class="fe mk ml mm mn b">function</code>关键字创建一个标识符为<code class="fe mk ml mm mn b">logJediDuos</code>的新函数。该功能只有一个参数<code class="fe mk ml mm mn b">jediList</code></p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="b4b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe mk ml mm mn b">logJediDuos</code>内部，我们使用<code class="fe mk ml mm mn b">for</code>关键字来创建我们的第一个<code class="fe mk ml mm mn b">for</code>循环。在我们的<code class="fe mk ml mm mn b">for statement</code>中，我们声明我们想要遍历<code class="fe mk ml mm mn b">jediList</code>的长度，直到该长度大于<code class="fe mk ml mm mn b">i</code>的值。我们在每次迭代后增加<code class="fe mk ml mm mn b">i</code>的值</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="7bf0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在前一个<code class="fe mk ml mm mn b">for</code>循环中，我们创建了另一个<code class="fe mk ml mm mn b">for</code>循环。在我们的<code class="fe mk ml mm mn b">for</code>语句中，我们确保给索引变量一个标识符<code class="fe mk ml mm mn b">j</code>，以确保我们不会改变<code class="fe mk ml mm mn b">i</code>变量的状态。</p><p id="32b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用括号符号<code class="fe mk ml mm mn b">[]</code>我们使用索引变量<code class="fe mk ml mm mn b">i</code>和<code class="fe mk ml mm mn b">j</code>到<code class="fe mk ml mm mn b">console.log</code>中的每一对</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="9ea4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们调用我们的<code class="fe mk ml mm mn b">logJediDuos</code>函数时，我们得到这个结果:</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="e494" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我只涉及了少数常见的大O时代。如果您想了解更多关于高级Big O times的信息，您可以通过下面提供的链接进行了解:</p><h2 id="8e68" class="mt kx iq bd ky mu mv dn lc mw mx dp lg kj my mz lk kn na nb lo kr nc nd ls ne bi translated">O(n！)阶乘时间</h2><blockquote class="lu lv lw"><p id="aa54" class="jy jz lx ka b kb kc kd ke kf kg kh ki ly kk kl km lz ko kp kq ma ks kt ku kv ij bi translated">为每个循环添加一个嵌套循环</p></blockquote><p id="d706" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae nl" href="https://en.wikipedia.org/wiki/Time_complexity#Factorial_time" rel="noopener ugc nofollow" target="_blank">在这里阅读更多内容</a></p><h2 id="75bd" class="mt kx iq bd ky mu mv dn lc mw mx dp lg kj my mz lk kn na nb lo kr nc nd ls ne bi translated">O(log N)对数</h2><blockquote class="lu lv lw"><p id="e3ec" class="jy jz lx ka b kb kc kd ke kf kg kh ki ly kk kl km lz ko kp kq ma ks kt ku kv ij bi translated">涉及搜索算法(如果已排序)</p></blockquote><p id="8a46" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae nl" href="https://en.wikipedia.org/wiki/Time_complexity#Logarithmic_time" rel="noopener ugc nofollow" target="_blank">在这里阅读更多内容</a></p><h2 id="285b" class="mt kx iq bd ky mu mv dn lc mw mx dp lg kj my mz lk kn na nb lo kr nc nd ls ne bi translated">O(2^N)指数</h2><blockquote class="lu lv lw"><p id="00a5" class="jy jz lx ka b kb kc kd ke kf kg kh ki ly kk kl km lz ko kp kq ma ks kt ku kv ij bi translated">解决大小为N的问题的递归算法</p></blockquote><p id="8abd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae nl" href="https://en.wikipedia.org/wiki/Time_complexity#Exponential_time" rel="noopener ugc nofollow" target="_blank">在这里阅读更多</a></p><h1 id="4e24" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">简化大O</h1><ul class=""><li id="ecae" class="mb mc iq ka b kb nm kf nn kj no kn np kr nq kv mg mh mi mj bi translated">总是假设最坏的情况</li><li id="5e77" class="mb mc iq ka b kb mo kf mp kj mq kn mr kr ms kv mg mh mi mj bi translated">移除常数</li><li id="6f31" class="mb mc iq ka b kb mo kf mp kj mq kn mr kr ms kv mg mh mi mj bi translated">输入的不同术语</li><li id="edc3" class="mb mc iq ka b kb mo kf mp kj mq kn mr kr ms kv mg mh mi mj bi translated">丢弃非支配者</li></ul><h2 id="2ab5" class="mt kx iq bd ky mu mv dn lc mw mx dp lg kj my mz lk kn na nb lo kr nc nd ls ne bi translated">总是假设最坏的情况</h2><p id="2a9e" class="pw-post-body-paragraph jy jz iq ka b kb nm kd ke kf nn kh ki kj nr kl km kn ns kp kq kr nt kt ku kv ij bi translated">在程序中迭代数据列表是一种非常常见的做法，列表的大小可能会有很大的不同。当我对<em class="lx">说总是假设最坏的情况</em>时，我指的是在几个不同的方面。</p><ul class=""><li id="dee7" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated">如果查询数据，假设它是列表中的最后一项</li><li id="c089" class="mb mc iq ka b kb mo kf mp kj mq kn mr kr ms kv mg mh mi mj bi translated">假设你迭代的列表会变大</li><li id="a2ff" class="mb mc iq ka b kb mo kf mp kj mq kn mr kr ms kv mg mh mi mj bi translated">假设一些机器运行你的算法比你的机器慢</li></ul><h2 id="495c" class="mt kx iq bd ky mu mv dn lc mw mx dp lg kj my mz lk kn na nb lo kr nc nd ls ne bi translated">移除常数</h2><p id="30ad" class="pw-post-body-paragraph jy jz iq ka b kb nm kd ke kf nn kh ki kj nr kl km kn ns kp kq kr nt kt ku kv ij bi translated">当我们确定一个算法的大O时，它有助于去除重复的测量(常数)。这允许我们通过移除不必要的计算来更清楚地读取算法的速度。</p><p id="7c86" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我给你看一个移除常数的例子:</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="5e5c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们用标识符<code class="fe mk ml mm mn b">printJedi</code>创建一个新的<code class="fe mk ml mm mn b">function</code>，这个函数只有一个参数(<code class="fe mk ml mm mn b">jediList</code></p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="2bd4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的<code class="fe mk ml mm mn b">printJedi</code>函数中，我们在<code class="fe mk ml mm mn b">jediList</code>调用了两次<code class="fe mk ml mm mn b">forEach()</code>方法</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="a7ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我们正在遍历整个<code class="fe mk ml mm mn b">jediList</code>数组，所以每个操作都是<code class="fe mk ml mm mn b">O(n)</code>。在函数的最后，我们将大O ( <code class="fe mk ml mm mn b">O(n) + O(n)</code>)相加，得到<code class="fe mk ml mm mn b">O(2n)</code>。我们可以通过<em class="lx">移除常量</em>来简化这一点，在本例中常量为<code class="fe mk ml mm mn b">2</code>。这之后就剩下<code class="fe mk ml mm mn b">O(n)</code>的大O了。</p><h2 id="af00" class="mt kx iq bd ky mu mv dn lc mw mx dp lg kj my mz lk kn na nb lo kr nc nd ls ne bi translated">输入的不同术语</h2><p id="f399" class="pw-post-body-paragraph jy jz iq ka b kb nm kd ke kf nn kh ki kj nr kl km kn ns kp kq kr nt kt ku kv ij bi translated">在迭代不同数据的情况下，大O计算将反映这一点。由于每个数据集合很可能大小不同，因此需要考虑其时间复杂性。</p><p id="8a1f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我向您展示一个在使用多个数据集合时计算大O的示例:</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="9d3d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面，我们用标识符<code class="fe mk ml mm mn b">printJediAndSith</code>创建了一个新的<code class="fe mk ml mm mn b">function</code>，这个函数有两个参数:<code class="fe mk ml mm mn b">jediList</code>和<code class="fe mk ml mm mn b">sithList</code></p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="e596" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe mk ml mm mn b">printJediAndSith</code>内部，我们在<code class="fe mk ml mm mn b">jediList</code>数组和<code class="fe mk ml mm mn b">sithList</code>数组上调用<code class="fe mk ml mm mn b">forEach()</code>方法</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="37d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，你认为大O的功能是什么？因为我们迭代一个数据集合，它应该是<code class="fe mk ml mm mn b">O(n)</code>，对吗？在这种情况下不行。</p><p id="b78d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请记住，这些参数可能有不同的长度。正因为如此，我们将【T2大O】确定为<code class="fe mk ml mm mn b">O(a + b)</code>。</p><h2 id="46fc" class="mt kx iq bd ky mu mv dn lc mw mx dp lg kj my mz lk kn na nb lo kr nc nd ls ne bi translated">丢弃非支配者</h2><p id="a262" class="pw-post-body-paragraph jy jz iq ka b kb nm kd ke kf nn kh ki kj nr kl km kn ns kp kq kr nt kt ku kv ij bi translated">在函数内部，会发生很多不同的事情。这也包括时间复杂度的范围。在确定算法的大O时，为了简化起见，通常的做法是<em class="lx">丢弃非支配</em>。简而言之，这意味着从您的大O计算中移除或<em class="lx">删除</em>任何更小的时间复杂度项目。</p><p id="ac9c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我给你看一个<em class="lx">丢弃非支配者</em>的例子:</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="23ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们用标识符<code class="fe mk ml mm mn b">printAndSumJediAttendance</code>创建一个新的<code class="fe mk ml mm mn b">function</code>，这个函数有一个参数<code class="fe mk ml mm mn b">jediList</code></p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="54cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe mk ml mm mn b">printAndSumJediAttendance</code>内部，我们对<code class="fe mk ml mm mn b">jediList</code>参数调用<code class="fe mk ml mm mn b">forEach()</code>方法。因为我们正在迭代一个数据集合，这个大O评估为<code class="fe mk ml mm mn b">O(n)</code>。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="6be3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下一行，我们在<code class="fe mk ml mm mn b">jediList</code>参数上调用<code class="fe mk ml mm mn b">forEach()</code>方法。在这个<code class="fe mk ml mm mn b">forEach</code>块里面，我们又在<code class="fe mk ml mm mn b">jediList</code>上调用<code class="fe mk ml mm mn b">forEach</code>。因为我们是在嵌套循环中迭代，所以我们的大O评估为<code class="fe mk ml mm mn b">O(n²)</code></p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="ea92" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我把这个大O的计算分解一下:</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="b138" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，如果我们将该函数的大O计算相加，得到的结果为<code class="fe mk ml mm mn b">O(n + n²)</code>。</p><p id="7c88" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们对此进行分析，我们会发现我们计算中最大大O的部分是<code class="fe mk ml mm mn b">n²</code>——正因为如此，我们放弃了<code class="fe mk ml mm mn b">n</code>。我们这样做是因为<code class="fe mk ml mm mn b">n²</code>比<code class="fe mk ml mm mn b">n</code>更<em class="lx">_优势_ </em>。一旦我们重构了我们的计算，我们会得到这个结果:<code class="fe mk ml mm mn b">O(n²)</code>。</p><h1 id="a990" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">空间复杂性</h1><blockquote class="lu lv lw"><p id="95c4" class="jy jz lx ka b kb kc kd ke kf kg kh ki ly kk kl km lz ko kp kq ma ks kt ku kv ij bi translated">与时间复杂度平行，空间复杂度是对算法所需内存(空间)的度量</p></blockquote><h2 id="04f1" class="mt kx iq bd ky mu mv dn lc mw mx dp lg kj my mz lk kn na nb lo kr nc nd ls ne bi translated">什么导致了空间的复杂性？</h2><ul class=""><li id="a3df" class="mb mc iq ka b kb nm kf nn kj no kn np kr nq kv mg mh mi mj bi translated">变量</li><li id="7adb" class="mb mc iq ka b kb mo kf mp kj mq kn mr kr ms kv mg mh mi mj bi translated">数据结构</li><li id="42fc" class="mb mc iq ka b kb mo kf mp kj mq kn mr kr ms kv mg mh mi mj bi translated">函数调用</li><li id="5dcb" class="mb mc iq ka b kb mo kf mp kj mq kn mr kr ms kv mg mh mi mj bi translated">分配</li></ul><p id="919d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我向您展示一个计算空间复杂性的示例:</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="2646" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们用标识符<code class="fe mk ml mm mn b">buildALightsaber</code>创建一个新的<code class="fe mk ml mm mn b">function</code>，它只有一个参数<code class="fe mk ml mm mn b">pieces</code></p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="bf3d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe mk ml mm mn b">buildALightsaber</code>内部，我们使用<code class="fe mk ml mm mn b">let</code>关键字创建一个新变量，它的标识符<code class="fe mk ml mm mn b">totalPieces</code>被赋给值<code class="fe mk ml mm mn b">0</code>。在下面一行，我们将变量<code class="fe mk ml mm mn b">totalPieces</code>重新赋值给<code class="fe mk ml mm mn b">4</code>的值</p><p id="b750" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建并赋值给变量是<code class="fe mk ml mm mn b">O(n)</code>(常数时间)；因此，这两步都是<code class="fe mk ml mm mn b">O(1)</code></p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="a9cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们创建一个<code class="fe mk ml mm mn b">for</code>循环并遍历<code class="fe mk ml mm mn b">pieces</code></p><p id="c905" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我们将遍历一个数据集合，所以这个操作的大O将计算为<code class="fe mk ml mm mn b">O(n)</code></p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="664f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的<code class="fe mk ml mm mn b">for</code>循环内部，我们调用一个带有标识符<code class="fe mk ml mm mn b">addCrystals()</code>的函数。接下来，我们使用<code class="fe mk ml mm mn b">const</code>关键字创建一个标识符为<code class="fe mk ml mm mn b">hasTheForce</code>的变量，并给它赋值<code class="fe mk ml mm mn b">true</code>。最后，我们将<code class="fe mk ml mm mn b">totalPieces</code>加1。</p><p id="55e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当在一次迭代(<code class="fe mk ml mm mn b">for</code>或<code class="fe mk ml mm mn b">while</code>循环)中调用函数、创建变量和更新变量值时，就评估空间复杂性而言，您必须注意这些操作将在每次迭代中发生。正因为如此，<em class="lx">提到的所有</em>动作都将是<code class="fe mk ml mm mn b">O(n)</code></p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="76f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们完成对<code class="fe mk ml mm mn b">pieces</code>的迭代后，我们返回<code class="fe mk ml mm mn b">totalPieces</code>的值</p><p id="653b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于这是单个动作，大O被评估为<code class="fe mk ml mm mn b">O(1)</code>或<em class="lx">常量时间</em></p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="f771" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们计算这个函数的大O，我们最初得到<code class="fe mk ml mm mn b">(3 + 4n)</code>。在我们应用简化大O的原则后，我们知道我们可以<em class="lx">移除常数</em>，这将得到我们的最终结果<code class="fe mk ml mm mn b">O(n)</code></p><h1 id="66f3" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">概括起来</h1><p id="e2c5" class="pw-post-body-paragraph jy jz iq ka b kb nm kd ke kf nn kh ki kj nr kl km kn ns kp kq kr nt kt ku kv ij bi translated">我希望读完这篇文章后，你对时间和空间的复杂性是如何工作的，它们在我们编写的函数/算法中的重要性，以及我们如何使用大O符号计算这些复杂性有一个固定的想法。</p><p id="a4c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下周，我将开始深入探讨JavaScript开发人员使用的最流行的数据结构——数组。到时候见！</p></div></div>    
</body>
</html>