<html>
<head>
<title>Best of Modern JavaScript — Sets and WeakSets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代 JavaScript 精华—集合和弱集合</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/best-of-modern-javascript-sets-and-weaksets-287923725ff1?source=collection_archive---------10-----------------------#2020-10-27">https://blog.devgenius.io/best-of-modern-javascript-sets-and-weaksets-287923725ff1?source=collection_archive---------10-----------------------#2020-10-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ea0a523a6b509e5643bff9a2e101fae8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SOGKG5GRZ8TwDMbQ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@igorstarkoff?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">伊戈尔·斯塔尔科夫</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="1620" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自 2015 年以来，JavaScript 有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究集合和弱集合。</p><h1 id="c5d1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">设置 API</h1><p id="383d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">API 有各种方法可以让我们操作它。</p><p id="da82" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">构造函数让我们传入一个 iterable 对象并从中创建一个集合。</p><p id="991a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8b6b" class="mq lc iq mh b gy mr ms l mt mu">const set = new Set([1, 2, 3]);</span></pre><p id="3998" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从数组创建集合。</p><p id="b536" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Set.prototype.add</code>方法获取一个值并将其附加到集合中。</p><p id="1eb9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它返回包含新条目的集合。</p><p id="b429" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Set.prototype.has</code>取一个值，如果它在集合中就返回<code class="fe me mf mg mh b">true</code>，否则返回<code class="fe me mf mg mh b">false</code>。</p><p id="219c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Set.prototype.delete</code>方法获取一个值并让我们移除它。</p><p id="ca88" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果被删除，它返回<code class="fe me mf mg mh b">true</code>，否则返回<code class="fe me mf mg mh b">false</code>。</p><p id="de18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Set.prototype.size</code> getter 返回集合中的项目数。</p><p id="bab7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">方法让我们从集合中移除所有的项目。</p><p id="e572" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Set.prototype.values</code>是一个方法，将一个集合的所有值作为迭代器返回。</p><p id="a88a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Set.prototype[Symbol.iterator]</code>返回一个 iterable 对象，让我们迭代一个集合。</p><p id="9a2d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Set.prototype.forEach</code> let 接受一个带有签名的回调，<code class="fe me mf mg mh b">(value, key, collection)</code>作为签名，并为集合中的每个项目运行它，</p><p id="8e47" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">value</code>有设定值。</p><p id="f5c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">key</code>与<code class="fe me mf mg mh b">value</code>的值相同。</p><p id="6ab2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">collection</code>是器械包本身。</p><p id="2faa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个参数是我们在回调中使用的<code class="fe me mf mg mh b">this</code>的值。</p><p id="6cd5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">集合也有<code class="fe me mf mg mh b">Set.prototype.entries</code>方法来返回一个 iterable 对象，每个条目都是一个键值数组。</p><p id="676a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">键和值是相同的。</p><p id="3f73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Set.prototype.keys</code>方法返回给我们一个带有键的 iterable 对象，键与值相同。</p><h1 id="110e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">WeakSet</h1><p id="27f1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">WeakSet 是一个不阻止其元素被垃圾收集的集合。</p><p id="a10e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它像 WeakMaps 一样工作，不允许迭代、循环或清除。</p><p id="a547" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">WeakSets 没有太多的用例。</p><p id="5aae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以向它们添加对象，然后通过引用获取它们。</p><p id="a608" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="00a2" class="mq lc iq mh b gy mr ms l mt mu">const weakSet = new WeakSet();</span><span id="9e49" class="mq lc iq mh b gy mv ms l mt mu">const obj = {};<br/>weakSet.add(obj);<br/>const hasObj = weakSet.has(obj);</span></pre><p id="bc35" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们传入一个地图，然后用<code class="fe me mf mg mh b">has</code>检查它的值。</p><p id="42a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只能将对象传递到 WeakSet 中。</p><p id="a3b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们试图传入一个原始值，我们将得到一个 TypeError。</p><p id="2b91" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以使用 WeakSets 来允许我们在给定的类实例上运行方法。</p><p id="f297" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7393" class="mq lc iq mh b gy mr ms l mt mu">const bars = new WeakSet();</span><span id="0c20" class="mq lc iq mh b gy mv ms l mt mu">class Bar {<br/>  constructor() {<br/>    bars.add(this);<br/>  }</span><span id="e1b9" class="mq lc iq mh b gy mv ms l mt mu">  method() {<br/>    if (!bars.has(this)) {<br/>      throw new TypeError('not a bar instance');<br/>    }<br/>  }<br/>}</span></pre><p id="c850" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将<code class="fe me mf mg mh b">Bar</code>实例添加到构造函数中的<code class="fe me mf mg mh b">bars</code> WeakSet。</p><p id="291a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在<code class="fe me mf mg mh b">method</code>方法中，我们检查<code class="fe me mf mg mh b">Bar</code>实例是否是带有<code class="fe me mf mg mh b">has</code>的 WeakSet 的一部分。</p><p id="9c02" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果不是，那么我们抛出一个错误。</p><p id="68a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这防止该方法在除了<code class="fe me mf mg mh b">Bar</code>实例之外的任何实例上运行。</p><h1 id="003e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">WeakSet API</h1><p id="96d1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">WeakSets 有一个简单的 API，包含 3 个方法，工作方式类似于它们的<code class="fe me mf mg mh b">Set</code>对等物。</p><p id="0b05" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">WeakSet.prototype.add</code>接受一个<code class="fe me mf mg mh b">value</code>作为参数，让我们向它添加一个条目。</p><p id="5d5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">WeakSet.prototype.has</code>获取一个<code class="fe me mf mg mh b">value</code>，如果条目存在则返回<code class="fe me mf mg mh b">true</code>，否则返回<code class="fe me mf mg mh b">false</code>。</p><p id="6dac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">WeakSet.prototype.delete</code>取一个<code class="fe me mf mg mh b">value</code>并从 WeakSet 中移除元素。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/68f9d3089180510e0b7a2d1fd6120350.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yVY64KDovEVO_IJI"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Adolfo Félix 在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="a8c9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="fe49" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">集合让我们无需重复就能添加项目。</p><p id="27d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">WeakSets 让我们保存不用时可以作为垃圾回收的物品。</p></div></div>    
</body>
</html>