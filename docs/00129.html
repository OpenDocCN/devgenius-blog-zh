<html>
<head>
<title>Data types and memory management in C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C#中的数据类型和内存管理</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/data-types-and-memory-management-in-c-db95f728153?source=collection_archive---------1-----------------------#2020-03-09">https://blog.devgenius.io/data-types-and-memory-management-in-c-db95f728153?source=collection_archive---------1-----------------------#2020-03-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/a66c60f2208351464769227a9b1cb758.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1BzgAQpMZRR27Y8haG_GCQ.jpeg"/></div></div></figure><div class=""/><p id="125b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在解释C#中可用的不同数据类型之前，有必要提一下C#是一种强类型语言。这意味着每个变量、常量、输入参数、返回类型以及通常每个计算结果为值的表达式都有一个类型。</p><p id="1ee0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每种类型都包含一些信息，这些信息将由编译器作为元数据嵌入到可执行文件中，公共语言运行时(CLR)将使用这些元数据来保证分配和回收内存时的类型安全。</p><p id="dc62" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想知道一个特定类型分配了多少内存，你可以使用如下的<strong class="ka jc"> sizeof </strong>操作符:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="4353" class="lf lg jb lb b gy lh li l lj lk">static void Main()<br/>{<br/>    var size = sizeof(int);<br/>    Console.WriteLine($"int size:{size}");<br/>    size = sizeof(bool);<br/>    Console.WriteLine($"bool size:{size}");<br/>    size = sizeof(double);<br/>    Console.WriteLine($"double size:{size}");<br/>    size = sizeof(char);<br/>    Console.WriteLine($"char size:{size}");<br/>}</span></pre><p id="e801" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">输出将显示每个变量分配的字节数。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="8124" class="lf lg jb lb b gy lh li l lj lk">int size:4<br/>bool size:1<br/>double size:8<br/>char size:2</span></pre><p id="328b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与每种类型相关的信息有:</p><ul class=""><li id="1a8a" class="ll lm jb ka b kb kc kf kg kj ln kn lo kr lp kv lq lr ls lt bi translated">所需的存储空间。</li><li id="83b6" class="ll lm jb ka b kb lu kf lv kj lw kn lx kr ly kv lq lr ls lt bi translated">最大值和最小值。例如，Int32类型接受-2147483648和2147483647之间的值。</li><li id="c843" class="ll lm jb ka b kb lu kf lv kj lw kn lx kr ly kv lq lr ls lt bi translated">成员(方法、字段、事件等。)包含在该类型中。例如，如果我们检查int类型的定义，我们会发现下面的结构和成员:</li></ul><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="cbda" class="lf lg jb lb b gy lh li l lj lk">...<br/>namespace System<br/>{<br/>    [ComVisible(true)]<br/>    public struct Int32 : IComparable, IFormattable, IConvertible, IComparable&lt;Int32&gt;, IEquatable&lt;Int32&gt;<br/>    {      <br/>        public const Int32 MaxValue = 2147483647;     <br/>        public const Int32 MinValue = -2147483648;<br/>        public static Int32 Parse(string s, NumberStyles style, IFormatProvider provider);    <br/>        ... <br/>    }  <br/>}</span></pre><ul class=""><li id="bef4" class="ll lm jb ka b kb kc kf kg kj ln kn lo kr lp kv lq lr ls lt bi translated">它继承的基类型。</li><li id="2352" class="ll lm jb ka b kb lu kf lv kj lw kn lx kr ly kv lq lr ls lt bi translated">运行时为变量分配内存的位置。</li><li id="eb42" class="ll lm jb ka b kb lu kf lv kj lw kn lx kr ly kv lq lr ls lt bi translated">允许的操作种类。</li></ul><h1 id="3e87" class="lz lg jb bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">内存管理</h1><p id="979e" class="pw-post-body-paragraph jy jz jb ka b kb mw kd ke kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv ij bi translated">当一个操作系统上运行多个进程，而RAM的容量不足以容纳所有进程时，操作系统会将硬盘的一部分与RAM进行映射，并开始在硬盘中存储数据。操作系统将使用特定的表来执行请求，其中虚拟地址被映射到它们对应的物理地址。这种管理内存的能力被称为<strong class="ka jc">虚拟内存</strong>。</p><p id="7d2b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在每个进程中，可用的虚拟内存分为以下6个部分，但是为了与本主题相关，我们将只关注<strong class="ka jc">堆栈</strong>和<strong class="ka jc">堆</strong>。</p><figure class="kw kx ky kz gt is gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/db409b7a8afbdc91d5796751ebd24126.png" data-original-src="https://miro.medium.com/v2/resize:fit:586/0*kwMDPciE34blgYAU"/></div></figure><h1 id="b3a8" class="lz lg jb bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">堆</h1><p id="af3c" class="pw-post-body-paragraph jy jz jb ka b kb mw kd ke kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv ij bi translated">堆栈是LIFO(后进先出)数据结构，大小取决于操作系统(默认情况下，对于ARM、x86和x64机器，Windows保留1MB，而Linux保留2MB到8MB，具体取决于版本)。</p><p id="dcb5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这段内存由CPU 自动管理<strong class="ka jc">。每当一个函数声明一个新变量时，编译器就在堆栈上分配一个与其大小一样大的新内存块，当函数结束时，该变量的内存块就会被释放。</strong></p><h1 id="e718" class="lz lg jb bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">许多</h1><p id="14f9" class="pw-post-body-paragraph jy jz jb ka b kb mw kd ke kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv ij bi translated">这个内存区域不是由CPU自动管理的，它的大小比堆栈大。当<strong class="ka jc"> <em class="nc"> new </em> </strong>关键字被调用时，编译器开始寻找符合请求大小的第一个空闲内存块。当它找到它时，通过使用内置的C函数<strong class="ka jc"> malloc() </strong>将它标记为保留，并返回指向该位置的指针。还可以通过使用内置的C函数<strong class="ka jc"> free() </strong>来释放一块内存。这种机制会导致内存碎片，并且必须使用指针来访问正确的内存块，<strong class="ka jc">它比堆栈</strong>执行读/写操作要慢。</p><h1 id="f414" class="lz lg jb bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">自定义和内置类型</h1><p id="0b2e" class="pw-post-body-paragraph jy jz jb ka b kb mw kd ke kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv ij bi translated">虽然C#提供了一组标准的内置类型来表示整数、布尔值、文本字符等，但您可以使用struct、class、interface和enum等构造来创建自己的类型。</p><p id="2417" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用struct构造的自定义类型的一个示例是:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="e760" class="lf lg jb lb b gy lh li l lj lk">struct Point<br/>{<br/>    public int X;<br/>    public int Y;</span><span id="23fd" class="lf lg jb lb b gy nd li l lj lk">};</span></pre><h1 id="612b" class="lz lg jb bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">值类型和引用类型</h1><p id="1e83" class="pw-post-body-paragraph jy jz jb ka b kb mw kd ke kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv ij bi translated">我们可以将C#类型分为以下几类:</p><ul class=""><li id="1855" class="ll lm jb ka b kb kc kf kg kj ln kn lo kr lp kv lq lr ls lt bi translated">值类型</li><li id="3d63" class="ll lm jb ka b kb lu kf lv kj lw kn lx kr ly kv lq lr ls lt bi translated">参考类型</li></ul><p id="8388" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面的方案显示了两种引用类型(字符串、数组等)的层次结构。)和值类型。正如您所看到的，这两种数据类型都来自于类<strong class="ka jc">系统。对象</strong>。</p><figure class="kw kx ky kz gt is gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/60d8a451c511c1dee71316193a080f8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:792/0*tc46Y7YTAEZ7i7wF"/></div></figure><h1 id="4c85" class="lz lg jb bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">值类型</h1><p id="d437" class="pw-post-body-paragraph jy jz jb ka b kb mw kd ke kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv ij bi translated">值类型源自<strong class="ka jc">系统。ValueType </strong>这种类型的类和变量在堆栈中的内存分配中包含它们的值。值类型的两个类别是<strong class="ka jc">结构</strong>和<strong class="ka jc">枚举</strong>。</p><p id="bde0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下示例显示了boolean类型的成员。如您所见，没有明确引用System。ValueType类，发生这种情况是因为该类由结构继承。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="11dd" class="lf lg jb lb b gy lh li l lj lk">...<br/>namespace System<br/>{<br/>    [ComVisible(true)]<br/>    public struct Boolean : IComparable, IConvertible, IComparable&lt;Boolean&gt;, IEquatable&lt;Boolean&gt;<br/>    {<br/>        public static readonly string TrueString;<br/>        public static readonly string FalseString;<br/>        public static Boolean Parse(string value);<br/>        ...<br/>    }<br/>}</span></pre><h1 id="307a" class="lz lg jb bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">参考类型</h1><p id="a824" class="pw-post-body-paragraph jy jz jb ka b kb mw kd ke kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv ij bi translated">另一方面，引用类型不包含存储在变量中的实际数据，而是包含存储值的堆的<strong class="ka jc">内存地址。引用类型的类别有<strong class="ka jc">类</strong>、<strong class="ka jc">委托</strong>、<strong class="ka jc">数组</strong>和<strong class="ka jc">接口</strong>。</strong></p><figure class="kw kx ky kz gt is gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/467b6e88ae68c983125d1398db23b0b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:468/0*2YJWXqGTUurTAhiF"/></div></figure><p id="bc45" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在运行时，当引用类型变量被声明时，<strong class="ka jc">它包含空值</strong>，直到一个使用关键字<strong class="ka jc"> <em class="nc"> new </em> </strong>创建的对象被分配给它。</p><p id="cd8d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下示例显示了泛型类型列表<t>的成员。</t></p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="eed5" class="lf lg jb lb b gy lh li l lj lk">...<br/>namespace System.Collections.Generic<br/>{<br/>    [DebuggerDisplay("Count = {Count}")]<br/>    [DebuggerTypeProxy(typeof(Generic.Mscorlib_CollectionDebugView&lt;&gt;))]<br/>    [DefaultMember("Item")]<br/>    public class List&lt;T&gt; : IList&lt;T&gt;, ICollection&lt;T&gt;, IEnumerable&lt;T&gt;, IEnumerable, IList, ICollection, IReadOnlyList&lt;T&gt;, IReadOnlyCollection&lt;T&gt;<br/>    {<br/>        ...<br/>        public T this[int index] { get; set; }<br/>        public int Count { get; }<br/>        public int Capacity { get; set; }<br/>        public void Add(T item);<br/>        public void AddRange(IEnumerable&lt;T&gt; collection);<br/>        ...<br/>    }<br/>}</span></pre><p id="32e9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想找出一个特定对象的内存地址，类<strong class="ka jc"> System。InteropServices </strong>提供了一种从非托管内存访问托管对象的方法。在下面的例子中，我们将使用静态方法<strong class="ka jc"> GCHandle。Alloc() </strong>分配一个句柄给一个字符串，然后方法<strong class="ka jc"> AddrOfPinnedObject </strong>检索它的地址。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="175b" class="lf lg jb lb b gy lh li l lj lk">string s1 = "Hello World";<br/>GCHandle gch = GCHandle.Alloc(s1, GCHandleType.Pinned);<br/>IntPtr pObj = gch.AddrOfPinnedObject();<br/>Console.WriteLine($"Memory address:{pObj.ToString()}");</span></pre><p id="9b94" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">输出将是</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="e468" class="lf lg jb lb b gy lh li l lj lk">Memory address:39723832</span></pre><h1 id="f7b2" class="lz lg jb bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">录像</h1><p id="24f4" class="pw-post-body-paragraph jy jz jb ka b kb mw kd ke kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv ij bi translated"><a class="ae ng" href="https://www.youtube.com/watch?v=_7AL8wDl5Tc" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=_7AL8wDl5Tc</a></p></div></div>    
</body>
</html>