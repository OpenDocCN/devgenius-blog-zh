<html>
<head>
<title>What is #define in C?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C 中的#define 是什么？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/what-is-define-in-c-dcad8e17615b?source=collection_archive---------6-----------------------#2022-09-09">https://blog.devgenius.io/what-is-define-in-c-dcad8e17615b?source=collection_archive---------6-----------------------#2022-09-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/7f69b4de1cc4f186b9f300a3ae10976a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Lk59oRoDgVJjkO--"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">照片由<a class="ae ja" href="https://unsplash.com/@cdr6934?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯里德</a>在<a class="ae ja" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><div class=""/><p id="8d54" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你能看出特色图片中的代码不是 C，那么恭喜你，因为你知道不止一种语言。这是一个你应该庆祝并为自己感到骄傲的成就。</p><p id="2046" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">尽管如此，让我们回到主题。在 C 语言中，你肯定见过类似这样的东西</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="e1bb" class="lh li jd ld b gy lj lk l ll lm">#include &lt;stdio.h&gt;<br/>#ifndef __MAIN__<br/>#define __MAIN__<br/>int main(){<br/>   printf("helllo world");<br/>   return 0;<br/>}<br/>#endif</span></pre><p id="8849" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">开始时，您可能会被要求忽略以<code class="fe ln lo lp ld b">#</code>字符开头的<code class="fe ln lo lp ld b">#define</code>或其他关键字。当然，在你开始学习 C 语言的时候，可以忽略它们，直接关注<code class="fe ln lo lp ld b">main</code>函数内部的内容。但是你是一个好奇的生物，你想知道那些是什么，为什么我们需要写它们？</p><p id="c964" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好吧，我会帮你回答这些问题。但首先，让我们了解一下 C 编程语言中的一些上下文。</p><h1 id="1f73" class="lq li jd bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">c 是关于优化的</h1><p id="f8cc" class="pw-post-body-paragraph ka kb jd kc b kd mn kf kg kh mo kj kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">c 语言是一种专为控制硬件而设计的语言。这就是为什么大多数操作系统、硬件驱动程序和微控制器软件都是用 C 编写的。当你编写代码硬件时，你需要考虑的一件事是你需要考虑优化，而 C 就是关于优化的。</p><p id="6363" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以为了优化软件的最终二进制，C 有了<strong class="kc je"> C 预处理器</strong>。C 预处理器，或者我们称之为<strong class="kc je">预处理器，</strong>本质上是一个工具，它将分析 C 源代码，并在编译器编译代码之前执行头文件包含、宏扩展、条件编译和行控制。预处理器本身是整个编译器工具的一部分。</p><p id="cc17" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">特别是条件编译，对于代码优化非常重要。我们将在后面看到细节，但一般来说，它允许我们编译某些代码行，或者排除最终二进制代码不需要的代码行。这种情况的主要用例是如果您有硬件相关的代码。例如，在处理数据时，如果目标硬件是小端或大端的，您会有不同的做法。如果为小端硬件编译源代码，预处理器可以在编译代码之前完全删除所有使用大端处理的代码。</p><h1 id="99d3" class="lq li jd bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">预处理命令</h1><p id="c09a" class="pw-post-body-paragraph ka kb jd kc b kd mn kf kg kh mo kj kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">简单来说，预处理命令就是以<code class="fe ln lo lp ld b">#</code>开头的关键字。它们有时也被称为指令。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="970f" class="lh li jd ld b gy lj lk l ll lm">+-----------+---------------------------------------------+<br/>|   Macro   |                    description              |<br/>+-----------+---------------------------------------------+<br/>| #include  | for file inclusion                          |<br/>| #define   | define a macro (the heck what is macro?)    |<br/>| #undef    | opposite of #define                         |<br/>| #ifdef    | conditional if macro has been defined       |<br/>| #ifndef   | conditional if macro has not been defined   |<br/>| #if       | conditional if with argument                |<br/>| #else     | just else part                              |<br/>| #elif     | it is 'else if'                             | <br/>| #endif    | closure of if                               |<br/>| #error    | to print error message                      |<br/>| #pragma   | special command to computer                 |<br/>+-----------+---------------------------------------------+</span></pre><p id="7271" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不是很多，对吧？让我们根据他们正在做的事情来讨论他们</p><h2 id="d959" class="lh li jd bd lr ms mt dn lv mu mv dp lz kl mw mx md kp my mz mh kt na nb ml nc bi translated">文件包含</h2><p id="b282" class="pw-post-body-paragraph ka kb jd kc b kd mn kf kg kh mo kj kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">这个我们就不细说了。它本质上只是一种在源代码中导入另一个文件的方法，因为您想要使用该文件中的函数、常量或变量。通常，您会包含一个头文件，其中包含由该头文件导出的函数、常数或变量的声明。</p><p id="eb98" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您将使用<code class="fe ln lo lp ld b">#include</code>指令，后跟尖括号中头文件的名称。例如，你写<code class="fe ln lo lp ld b">#include &lt;stdio.h&gt;</code>是为了使用函数<code class="fe ln lo lp ld b">printf</code>，因为<code class="fe ln lo lp ld b">printf</code>是在<code class="fe ln lo lp ld b">stdio.h</code>内部定义的。有时头文件包含在双引号内，如<code class="fe ln lo lp ld b">#include "someapi.h"</code>。如果你的头文件是你的源代码的一部分，你就使用<code class="fe ln lo lp ld b">"</code>,而如果你包含了标准库，就使用尖括号。</p><h2 id="56c2" class="lh li jd bd lr ms mt dn lv mu mv dp lz kl mw mx md kp my mz mh kt na nb ml nc bi translated">宏定义和扩展</h2><p id="6d9e" class="pw-post-body-paragraph ka kb jd kc b kd mn kf kg kh mo kj kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">指令<code class="fe ln lo lp ld b">#define</code>和<code class="fe ln lo lp ld b">#undef</code>用于宏展开。我总是把它想成文本替换。<code class="fe ln lo lp ld b">#define</code>指令将创建一个宏和可选的替换标记。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="24be" class="lh li jd ld b gy lj lk l ll lm">#define &lt;identifier&gt; &lt;replacement_token&gt;<br/>//example<br/>#define PI 3.14</span></pre><p id="d3a8" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的例子中，我们用替换标记<code class="fe ln lo lp ld b">3.14</code>声明宏<code class="fe ln lo lp ld b">PI</code>。然后，预处理器将在源代码中搜索宏<code class="fe ln lo lp ld b">PI</code>，并用<code class="fe ln lo lp ld b">3.14</code>替换它</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="80a1" class="lh li jd ld b gy lj lk l ll lm">int area(int radius){<br/>   return PI*r*r;<br/>}<br/>========== after pre processing ========<br/>int area(int radius){<br/>   return 3.14*r*r<br/>}</span></pre><p id="7ded" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的例子中，你可以看到在预处理之后，预处理器本质上只是用<code class="fe ln lo lp ld b">3.14</code>替换任何<code class="fe ln lo lp ld b">PI</code>，基本上就是这样。</p><p id="a08e" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，神奇的是，你还可以用宏展开来定义一个函数。我们上面用<code class="fe ln lo lp ld b">PI</code>的例子是所谓的类对象宏，而另一个，类函数宏，是你可以像函数一样声明宏的地方。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="5b5a" class="lh li jd ld b gy lj lk l ll lm">#define &lt;identifier&gt;(parameters list) &lt;replacement_token&gt;</span></pre><p id="7215" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们以函数<code class="fe ln lo lp ld b">area</code>为例来声明一个类似函数的宏</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="212a" class="lh li jd ld b gy lj lk l ll lm">#define PI 3.14<br/>#define area(r) (PI*r*r)<br/>int main(){<br/>  int area1 = area(2);<br/>  return 0;<br/>}<br/>========== after preprocessing ========<br/>int main(){<br/>   int area = 3.14*2*2;<br/>   return 0;<br/>}</span></pre><p id="9506" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如您在上面的例子中看到的，整个<code class="fe ln lo lp ld b">area</code>宏将被替换为我们在宏的替换标记中声明的操作。所以最后真的只是文字替换。</p><p id="9ed4" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如我之前所说，替换令牌是可选的。因此，在本文开头的 hello world 程序的例子中，我们使用<code class="fe ln lo lp ld b">#define</code>声明宏<code class="fe ln lo lp ld b">__MAIN__</code>，但是没有替换标记。</p><p id="ed07" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当你声明一个没有替换标记的宏时，预处理器会记住它，并在你每次使用<code class="fe ln lo lp ld b">#if</code>指令时使用它。我们将在下一节讨论它。</p><h2 id="5e5a" class="lh li jd bd lr ms mt dn lv mu mv dp lz kl mw mx md kp my mz mh kt na nb ml nc bi translated">条件编译</h2><p id="1251" class="pw-post-body-paragraph ka kb jd kc b kd mn kf kg kh mo kj kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">条件编译允许您编译或排除编译中的某些代码。当你想优化代码的时候，这真的很方便。我们可以使用<code class="fe ln lo lp ld b">#ifdef</code>、<code class="fe ln lo lp ld b">#ifndef</code>、<code class="fe ln lo lp ld b">#if</code>、<code class="fe ln lo lp ld b">#elif</code>、<code class="fe ln lo lp ld b">#else</code>和<code class="fe ln lo lp ld b">#endif</code>指令。让我们看看下面这个我从维基百科上摘下来的例子:P</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="ce92" class="lh li jd ld b gy lj lk l ll lm">#if !(defined __LP64__ || defined __LLP64__) || defined _WIN32 &amp;&amp; !defined _WIN64<br/>	<em class="nd">// we are compiling for a 32-bit system</em><br/>#else<br/>	<em class="nd">// we are compiling for a 64-bit system</em><br/>#endif</span></pre><p id="8ec2" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可能会问，我们可以分别为 32 位和 64 位创建函数，然后根据系统调用它们吗？嗯，上面的例子可能显示了条件编译是多么的无关紧要。但是请记住，C 是为硬件编写的，您可能有数百种不同的硬件配置。如果某些代码是为 ARM 架构编译的，而在 x86 架构中运行得非常好，那么这些代码可能会抛出编译错误。</p><p id="67b0" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果<code class="fe ln lo lp ld b">#if</code>参数为假，预处理器将删除 32 位的所有代码，反之亦然。它不仅优化了代码，而且还消除了编译中的任何错误，因为一些变量或函数在其他体系结构中是不可用的。</p><h2 id="3d8d" class="lh li jd bd lr ms mt dn lv mu mv dp lz kl mw mx md kp my mz mh kt na nb ml nc bi translated">令牌字符串化</h2><p id="b419" class="pw-post-body-paragraph ka kb jd kc b kd mn kf kg kh mo kj kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">我觉得这个很少用。我在工作中开发了一个智能卡操作系统，我从未见过令牌字符串化。不过好吧，我们稍微谈一下。根据维基百科，它只会从一个宏创建一个字符串。就是这样。</p><h2 id="eb66" class="lh li jd bd lr ms mt dn lv mu mv dp lz kl mw mx md kp my mz mh kt na nb ml nc bi translated">特殊指令和宏</h2><p id="9a5d" class="pw-post-body-paragraph ka kb jd kc b kd mn kf kg kh mo kj kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated"><code class="fe ln lo lp ld b">#error</code>只是向标准 IO 输出一条错误消息，而<code class="fe ln lo lp ld b">#pragma</code>应该得到一整篇关于它的文章。<code class="fe ln lo lp ld b">#pragma</code>是特定于编译器的，但我们通常在 GPU 的并行化中发现它，以允许特定代码由 GPU 的多个内核并行执行。</p><p id="8f96" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">大多数编译器也支持几个预定义的宏。分别是<code class="fe ln lo lp ld b">__FILE__</code>、<code class="fe ln lo lp ld b">__LINE__</code>、<code class="fe ln lo lp ld b">__DATE__</code>、<code class="fe ln lo lp ld b">__TIME__</code>、<code class="fe ln lo lp ld b">__TIMESTAMP__</code>。</p><h1 id="3462" class="lq li jd bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">预处理器如何工作</h1><p id="df36" class="pw-post-body-paragraph ka kb jd kc b kd mn kf kg kh mo kj kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">现在我们已经知道了预处理和宏，我们将通过后面的例子来了解它是如何工作的。所以准备好你的代码编辑器，准备写一些代码吧。</p><figure class="ky kz la lb gt ip gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/e3564ab36cbb09a315493269bea8a283.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*QXkUklGPZt1tGyGjNjPsng.png"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">编译过程</figcaption></figure><p id="6289" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如上图所示，预处理实际上是编译的第一步。事实上，这是有意义的，因为预处理器将首先分析代码，以便在编译和进一步处理源代码之前对其进行优化。让我们试着写一些代码，看看预处理的结果。</p><p id="d736" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这个演示中，我将使用 gcc 编译器。我用的是 Ubuntu 18.04 的 7.5.0 版本。考虑下面的例子</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="f0df" class="lh li jd ld b gy lj lk l ll lm">#define THREE_COMMA_PI<br/>#ifdef THREE_COMMA_PI<br/>#define PI 3.142<br/>#else<br/>#define PI 3.14<br/>#endif</span><span id="0274" class="lh li jd ld b gy nf lk l ll lm">#define area(r) (PI*r*r)</span><span id="3d3e" class="lh li jd ld b gy nf lk l ll lm">int main(){<br/>   int a = area(3);<br/>   return 0;<br/>}</span></pre><p id="4b79" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">之后，我们将这个文件保存到<code class="fe ln lo lp ld b">helloworld.c</code>的任意文件夹中。之后，我们可以调用这个命令来生成预处理文件</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="23ff" class="lh li jd ld b gy lj lk l ll lm">gcc -c -save-temps <!-- -->helloworld<!-- -->.c</span></pre><p id="a666" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该命令将生成三个文件，分别是<code class="fe ln lo lp ld b">helloworld.i</code>、<code class="fe ln lo lp ld b">helloworld.o</code>和<code class="fe ln lo lp ld b">helloworld.s</code>。如果你打开<code class="fe ln lo lp ld b">helloworld.i</code>，你会看到这样的东西</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="de3e" class="lh li jd ld b gy lj lk l ll lm"># 1 "helloworld.c"<br/># 1 "&lt;built-in&gt;"<br/># 1 "&lt;command-line&gt;"<br/># 31 "&lt;command-line&gt;"<br/># 1 "/usr/include/stdc-predef.h" 1 3 4<br/># 32 "&lt;command-line&gt;" 2<br/># 1 "helloworld.c"<br/># 10 "helloworld.c"<br/>int main(){<br/>   int a = (3.142*3*3);<br/>   return 0;<br/>}</span></pre><p id="4612" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以忽略前面有<code class="fe ln lo lp ld b">#</code>的行，但不能忽略，你可以看这篇<a class="ae ja" href="https://gcc.gnu.org/onlinedocs/gcc-9.1.0/cpp/Preprocessor-Output.html#Preprocessor-Output" rel="noopener ugc nofollow" target="_blank">文章</a>。如果您关注<code class="fe ln lo lp ld b">main</code>函数，您将会看到<code class="fe ln lo lp ld b">area</code>已经被替换令牌替换，同样的还有<code class="fe ln lo lp ld b">PI</code></p><h1 id="102a" class="lq li jd bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">结论</h1><p id="3c79" class="pw-post-body-paragraph ka kb jd kc b kd mn kf kg kh mo kj kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">我上面描述的只是 C 代码预处理的表面。但至少，我希望它能帮助你的旅程了解更多。</p><p id="6ae6" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我认为更有趣的讨论是为什么你会使用一个类似函数的宏，而不是仅仅写一个简单的函数。如果你想让我写这个，请告诉我</p><p id="b1ab" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你觉得这篇文章有帮助，可以考虑在 Medium 上或者在<a class="ae ja" href="https://twitter.com/asyarif_" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我，当然，别忘了 clap。</p></div></div>    
</body>
</html>