<html>
<head>
<title>Node.js Best Practices — Security</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js最佳实践—安全性</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/node-js-best-practices-security-e5df4ba59d20?source=collection_archive---------13-----------------------#2020-08-09">https://blog.devgenius.io/node-js-best-practices-security-e5df4ba59d20?source=collection_archive---------13-----------------------#2020-08-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/52b79c287ecc2b14534fb5a0af23ec29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Odq68QcN7AIGlGqF"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Todd Quackenbush 在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="211d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，JavaScript应用程序也必须写得很好。</p><p id="9a1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们以后会遇到各种各样的问题。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看在编写节点应用程序时应该遵循的一些最佳实践。</p><h1 id="ec74" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用中间件限制并发请求</h1><p id="ef8b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">攻击者很容易进行DOS攻击。</p><p id="1d94" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们只需要用请求淹没我们的应用程序。</p><p id="0aa8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了避免这种情况，我们可以使用负载平衡、防火墙、反向代理和速率限制器包来限制一次可以完成的请求。</p><p id="aa4c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有<a class="ae kc" href="https://www.npmjs.com/package/rate-limiter-flexible" rel="noopener ugc nofollow" target="_blank">灵活限速</a>和<a class="ae kc" href="https://www.npmjs.com/package/express-rate-limit" rel="noopener ugc nofollow" target="_blank">快速限速</a>包来帮助我们。</p><p id="4d22" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过以下方式限制请求:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0ae2" class="mn lc iq mj b gy mo mp l mq mr">const http = require('http');<br/>const redis = require('redis');<br/>const { RateLimiterRedis } = require('rate-limiter-flexible');</span><span id="831f" class="mn lc iq mj b gy ms mp l mq mr">const redisClient = redis.createClient({<br/> enable_offline_queue: false,<br/>});</span><span id="52d9" class="mn lc iq mj b gy ms mp l mq mr">const rateLimiter = new RateLimiterRedis({<br/> storeClient: redisClient,<br/> points: 50,<br/> duration: 1,<br/> blockDuration: 5<br/>});</span><span id="93f8" class="mn lc iq mj b gy ms mp l mq mr">http.createServer(async (req, res) =&gt; {<br/>  try {<br/>    const rateLimiterRes = await rateLimiter.consume(req.socket.remoteAddress);</span><span id="d6f7" class="mn lc iq mj b gy ms mp l mq mr">    res.writeHead(200);<br/>    res.end();<br/>  } catch {<br/>    res.writeHead(429);<br/>    res.end('Too Many Requests');<br/>  }<br/>})<br/> .listen(3000);</span></pre><p id="1153" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用<code class="fe mt mu mv mj b">rate-limiterr-flexible</code>。</p><p id="89a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它将检查请求的数量，如果有太多的请求来自一个源，它将返回一个429状态代码。</p><p id="6290" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了快速限速器，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e6bc" class="mn lc iq mj b gy mo mp l mq mr">const RateLimit = require('express-rate-limit');<br/>app.enable('trust proxy'); <br/> <br/>const apiLimiter = new RateLimit({<br/>  windowMs: 10*60*1000, <br/>  max: 100,<br/>});<br/> <br/>app.use('/profile/', apiLimiter);</span></pre><p id="fe84" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有<code class="fe mt mu mv mj b">app.enable(‘trust proxy’);</code>来确保客户端IP被设置为<code class="fe mt mu mv mj b">req.ip</code>的值。</p><p id="deec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用express-rate-limit将请求窗口限制为每10分钟100个。</p><p id="8e7a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们将中间件应用于<code class="fe mt mu mv mj b">profile</code>路线。</p><h1 id="2a59" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">从配置文件中提取机密或使用包来加密它们</h1><p id="34e5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">不要在配置文件或源代码中存储秘密。</p><p id="dc3d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用秘密管理系统来存储密钥。</p><p id="26ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们也可以被管理和加密。</p><p id="5d87" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还应该检查预提交钩子，这样我们就不会意外地提交秘密。</p><p id="0f58" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以用<code class="fe mt mu mv mj b">cryptr </code>库解密:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1b78" class="mn lc iq mj b gy mo mp l mq mr">const Cryptr = require('cryptr');<br/>const cryptr = new Cryptr(process.env.SECRET);<br/> <br/>const accessToken = cryptr.decrypt('...');</span></pre><h1 id="bcce" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用ORM/ODM库防止查询注入漏洞</h1><p id="5d3a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该防止SQL或NoSQL注入和其他恶意攻击，使用一个数据库库来逃避我们用于查询的数据。</p><p id="54ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们应该验证用户输入，这样恶意代码就不会被注入其中。</p><p id="e14e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大多数ORM或ODM都有这个基本特性。</p><h1 id="4dad" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用SSL/TLS加密客户端-服务器连接</h1><p id="5c3d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">SSL/TLS几乎无处不在，因为它在我们的通信通道中提供了基本的安全性。</p><p id="70ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这可以防止中间人攻击。</p><p id="ad5b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此攻击者无法通过接入通信信道来监视用户。</p><h1 id="bcd8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">安全地比较秘密值和散列值</h1><p id="1a45" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">秘密值和散列不应该与纯文本进行比较。</p><p id="ad31" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用<code class="fe mt mu mv mj b">crypto.timingSafeEqual(a, b)</code>来比较哈希值。</p><p id="f796" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它有两个对象，如果数据不匹配，它会一直比较。</p><p id="106c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">默认的相等比较方法只在字符不匹配后返回，这允许计时攻击，因为我们可以检查比较的持续时间，以获得关于两个事物有多少匹配的线索。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/aa5b3668f3ae13eab48cb1c2bb7059af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Th46p64qaTNJrqqy"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">斯雷科·斯克罗比奇在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="99cf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="ac97" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">应该考虑一些基本的安全问题，包括存储机密、使用SSL和防止DOS攻击。</p></div></div>    
</body>
</html>