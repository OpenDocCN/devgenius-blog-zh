# 为什么是软件设计？

> 原文：<https://blog.devgenius.io/why-software-design-3a147f37f18b?source=collection_archive---------5----------------------->

在过去的几周里，我在不同的对话中，人们基本上都在说软件设计是一种浪费时间的行为。

![](img/0c65238f78d090908916da0a24ba4dfc.png)

> “让它工作，让它正确，让它快。”
> [肯特·贝克](https://quotefancy.com/quote/1663435/Kent-Beck-Make-it-work-make-it-right-make-it-fast)

这句话中有一个顺序，这个顺序非常重要，但是除了顺序，我们必须做三件事。

## 使其工作

这意味着创建一个软件来解决我们想要解决的问题，不多也不少。在这段时间里，我们只需要专注于解决这个问题。

## 做正确的事

这就是设计，所以应用所有我们知道的原则会对我们有帮助。试图检测我们代码中的问题，这些问题会降低我们修改和维护代码的能力。不是添加更多的功能，不是添加我们不需要的东西，而是使用我们已经创建的代码并对其进行改进。

## 动作快点

在解决问题之后，优化是最后一件要做的事情，而不是第一件，因为当你知道什么样的优化能更好地改善你的系统时，就必须进行优化。

所以在我看来，我们正在努力做这样的事情:

*   在问题中思考
*   密码
*   设计
*   使最优化
*   回去想想

这是一个或长或短的反馈循环，取决于要解决的问题有多大。因此，提高这种循环频率的一个好策略是试图解决一个小问题，而不是大问题。 [TDD](/inverted-scientist-method-aka-tdd-e7848c3fd982?sk=b6234b6d1a4170a8939d9aebcea25157) 可以帮助你更好地理解如何按照这个方法做[小步骤](/a-lot-of-tiny-steps-16eaac27acb4?sk=3aaec6e2fd13f9710ecce4935c2189bc)。

如果我们能够从一个小问题开始，解决我们大问题的一些场景，我们可以迭代它，增加复杂性，我们将能够以迭代的方式解决整个问题。
这和:
[**“大处着眼，小处着手，学得快**”](https://www.forbes.com/sites/chunkamui/2019/01/02/6-words-to-remember-in-2019-think-big-start-small-learn-fast/?sh=6f298bf05f17)

我们的设计将随着我们试图解决的每一个更困难的问题而成长。我们将针对我们正在解决的小问题进行优化，不多也不少。

但是如何将这些问题以及如何从简单到复杂地排序来做。更简单的问题是我们的问题的一个非常简单的场景，其中要求不太严格。
如果我想创建一个书店，我不需要开始思考我将拥有每秒成千上万的用户。很可能一开始很少有人会使用我的书店，即使你可以使用这个策略来获得反馈。利用你的朋友来测试，并从你的书店得到反馈。
那为什么一开始要在意用什么数据库呢，让我们用任何能帮我解决问题的人。
在这种情况下，我的代码需要允许我在学到更多知识时更改 DB，并且我对不久的将来的性能需求有了更好的了解。
所有这些都将缩短投入生产的时间，缩短从用户那里获得反馈并向他们学习的时间。

但是，如果一切都与我的数据库相结合，我将不能轻易改变它。如果我的所有代码都直接使用与我的数据库类型相关的代码，我将被我的数据库绑架。这就是耦合。

## 连接

[耦合是模块之间相互依赖程度的度量。](https://www.geeksforgeeks.org/software-engineering-coupling-and-cohesion/)

*   **数据耦合**:如果模块之间的依赖关系是基于它们只通过传递数据来进行通信，那么这些模块就被称为是数据耦合的。在数据耦合中，组件相互独立，并通过数据进行通信。模块通信不包含 tramp 数据。示例-客户计费系统。
*   印记耦合:在印记耦合中，完整的数据结构从一个模块传递到另一个模块。因此，它涉及到不定期数据。由于效率因素，这可能是必要的，这个选择是由有洞察力的设计者做出的，而不是懒惰的程序员。
*   控制耦合:如果模块通过传递控制信息进行通信，那么它们被称为是控制耦合的。如果参数指示完全不同的行为，这可能是不好的；如果参数允许分解和重用功能，这可能是好的。将比较函数作为参数的示例排序函数。
*   **外部耦合:在外部耦合中，模块依赖于正在开发的软件或特定类型硬件外部的其他模块。Ex 协议、外部文件、设备格式等。**
*   公共耦合:模块共享数据，比如全局数据结构。全局数据的变化意味着追溯到访问该数据的所有模块，以评估变化的影响。因此，它有很多缺点，如模块重用困难，控制数据访问的能力降低，可维护性降低。
*   内容耦合:在内容耦合中，一个模块可以修改另一个模块的数据，或者控制流从一个模块传递到另一个模块。这是最糟糕的耦合形式，应该避免。

耦合就像重力一样，是一种对抗变化的巨大力量。

这不是针对您的数据库，而是针对您的任何基础设施(考虑您无法控制的基础设施、库、框架、外部服务等)。如果你的业务代码完全被你的基础设施所感染，你的代码会和很多东西联系在一起，这意味着很难改变。

[为了改进我的设计，改进我的架构，我需要在我的设计中牢记这一点。](/evolutionary-design-an-example-d9889a262e3d?sk=8cfb8b20335ca39f6f0ce84b8cbc73e6)
我需要减少我的外部耦合，或者至少命名我的代码中耦合到外部模块的部分，以了解我改变 DB(或任何其他基础设施的东西)的工作量。
这不仅仅是创建一些接口，你还需要考虑数据耦合。如果在那些外部模块和你的内部模块之间，你的代码使用相同的数据结构(数据耦合)，那么你的代码就是高度耦合的。
有人为此使用[六边形架构](/the-whys-of-hexagonal-architecture-1ccca8476c86?sk=8d8e99e381ae473c001fd80c348fa5f8)。

## 设计，我不在乎

还有一种倾向，认为设计是死的，我们只是专注于使事情工作。就算你不在乎设计，你也在设计。如果你有一个类或者一个模块有大量的依赖项，你就把这个类和所有的依赖项耦合起来。如果依赖关系发生变化，你的类也必须改变，如果你没有创建正确的接收器，你的类中耦合的任何东西都会改变。旨在阻止滚雪球效应，以避免重写整个应用程序。

你不需要通过创建对你现在的问题无用的结构来预测未来，但是你必须创建一些东西来减少你的代码的读者的认知负荷。

软件设计应该考虑到未来开发人员对代码的可维护性。并非所有的设计都是一样的，你必须为简单而设计，但这并不容易，而且这通常不是你对一个问题的第一反应。

简单设计的四个规则可以帮助你:

*   通过测试
*   揭示意图(应该容易理解)
*   无重复(干)
*   最少的元素(删除任何不符合前面三个规则的元素)

这是我不喜欢 [Builder](/why-i-dont-like-the-builder-pattern-e05423698a9a?sk=ab3e214029e33109be6c2157f66b5dfa) 模式的原因之一，因为它违背了“低耦合” [GRASP](https://en.wikipedia.org/wiki/GRASP_(object-oriented_design)#Low_coupling) 原则。
抱歉，我会更好地解释我自己，我并不反对构建器模式，它有空间，但我不喜欢人们如何使用它。构建器模式不是为了隐藏一个在构造器中有太多参数的类。这是为了解决一个有可选和非可选参数的类的问题，你不能为所有情况创建大量的构造函数。

## 我不知道如何设计

答案是努力学习，软件设计是巨大和困难的，因为你必须理解你的问题的权衡和软件设计原则的权衡。

在这篇文章中，我解释了我在日常工作中尝试使用的软件设计原则:
[https://blog . dev genius . io/software-design-principles-CCC 3913 bfd 56？sk = 072 F3 a4 d 996 bfd 3106 e 1583 f8f 667 fa 8](/software-design-principles-ccc3913bfd56?sk=072f3a4d996bfd3106e1583f8f667fa8)