<html>
<head>
<title>Spring Boot with PostgreSQL and Hibernate — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 PostgreSQL 和 Hibernate 的 Spring Boot—第 1 部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/spring-boot-with-postgresql-and-hibernate-26dc00de27e?source=collection_archive---------4-----------------------#2022-02-09">https://blog.devgenius.io/spring-boot-with-postgresql-and-hibernate-26dc00de27e?source=collection_archive---------4-----------------------#2022-02-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/7c0ce089d7552684761c5f375ad79451.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X0Up2Pdq1ZDskAe51Uac4g.png"/></div></div></figure><p id="65dc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本教程中，我们将介绍如何使用 PostgreSQL 关系数据库和 Hibernate 来设置 Spring Boot 应用程序，以处理数据库事务，而不是编写自己的 SQL 查询。我们还将使用 Gradle 作为构建工具。</p><p id="7572" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将构建的是一个 REST API，它将能够存储博客文章、类别和标签。</p><p id="a529" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我们需要使用 Spring Initializr 获得一个. zip 文件，其中包含我们需要的所有必要文件，我们在这里找到页面<a class="ae kt" href="https://start.spring.io/" rel="noopener ugc nofollow" target="_blank">https://start.spring.io/</a>。我们将选择以下内容:</p><div class="ku kv kw kx gt ab cb"><figure class="ky jo kz la lb lc ld paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><img src="../Images/33dfdc6aa54f5d7f4d2244f05d1f7a50.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*A2EdP87wTfZ8J8WSkTcRyw.png"/></div></figure><figure class="ky jo le la lb lc ld paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><img src="../Images/006fa4499e3bb97d7a99bd415ebdef6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/1*j4V_lepCJvSAExJ74HJ7iA.png"/></div></figure></div><p id="9dc4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些设置是我们将在这个项目中使用的，但是用 Maven 或另一个 Java 版本来设置这个项目不是问题。</p><p id="4b0e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们按页面底部的<strong class="jx io">生成</strong>来获得。zip 文件，并将该文件解压缩到我们计算机上的一个所需位置。然后我们最好在<strong class="jx io"> IntelliJ </strong>开放它，因为它得到了很多对 Spring Boot 的支持。当打开我们在 Intellij 中获得的目录<strong class="jx io"> blog </strong>时，它开始将我们运行应用程序所需的依赖项下载到我们的计算机上。</p><p id="f9ef" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们需要在我们的电脑上安装 PostgreSQL，如果我们还没有安装，我们可以从:<a class="ae kt" href="https://www.postgresql.org/download/" rel="noopener ugc nofollow" target="_blank">https://www.postgresql.org/download/</a>下载并安装最新版本。当我们安装 PostgreSQL 时，我们将有一个名为<strong class="jx io"> postgres </strong>的默认用户名，它没有密码，因此我们需要打开我们的 shell 并进行查询来设置密码。这个帐户不应该在生产中使用，但是因为我们只在本地使用它，所以完全可以使用。要设置密码，我们打开终端并运行(我使用的是 Ubuntu，因此可能会因操作系统而异):</p><pre class="ku kv kw kx gt lf lg lh li aw lj bi"><span id="b647" class="lk ll in lg b gy lm ln l lo lp">sudo -u postgres psql</span></pre><p id="ab92" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是用<strong class="jx io"> postgres </strong>用户登录到<strong class="jx io"> psql </strong> CLI，这样我们就可以与数据库交互并进行查询。<strong class="jx io"> postgres </strong>用户拥有全部权限。系统会提示我们使用操作系统上当前用户的密码。因此，当我们登录后，我们运行 SQL 查询来设置新密码:</p><pre class="ku kv kw kx gt lf lg lh li aw lj bi"><span id="7557" class="lk ll in lg b gy lm ln l lo lp">ALTER USER postgres WITH PASSWORD 'new_password';</span></pre><p id="eda6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，我们需要添加一个新的数据库，因此我们运行以下命令:</p><pre class="ku kv kw kx gt lf lg lh li aw lj bi"><span id="96d5" class="lk ll in lg b gy lm ln l lo lp">CREATE DATABASE blog;</span></pre><p id="1bde" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们完成了数据库部分。我们可以使用 GUI 客户机，这样当我们要在新创建的数据库中设置新表时，可以更容易地浏览。我个人使用的是<strong class="jx io"> pgAdmin 4 </strong>，但是你可以下载任何 PostgreSQL GUI 客户端。</p><p id="8f8e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在是时候从我们项目中的 Java 代码开始了。首先，我们需要定义我们的项目需要什么模型(实体)。在这个项目中，我们将这样做:</p><p id="3e76" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">BlogPost (id，title，text，created，updated) <br/> BlogCategory (id，name) <br/> BlogTag (id，name)</p><p id="5d2f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">关系还没有定义，但是我们需要添加它，我们将在第二个教程中讨论，我将在 Medium 上发布。</p><p id="8467" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，我们将首先在路径<strong class="jx io"> com.mjovanc.blog </strong>下创建一个名为<strong class="jx io"> model </strong>的新包，然后我们将创建一个名为<strong class="jx io">BlogPost.java</strong>的新 Java 类，并添加以下内容:</p><pre class="ku kv kw kx gt lf lg lh li aw lj bi"><span id="e1bb" class="lk ll in lg b gy lm ln l lo lp">package com.mjovanc.blog.model;<br/><br/>import javax.persistence.Entity;<br/>import javax.persistence.GeneratedValue;<br/>import javax.persistence.GenerationType;<br/>import javax.persistence.Id;<br/><br/>@Entity<br/>public class BlogPost {<br/><br/>    @Id<br/>    @GeneratedValue(strategy = GenerationType.AUTO)<br/>    private Long id;<br/>    private String title;<br/>    private String text;<br/>    private String created;<br/>    private String updated;</span><span id="057a" class="lk ll in lg b gy lq ln l lo lp">    public BlogPost() {<br/>    <br/>    }</span><span id="5ab7" class="lk ll in lg b gy lq ln l lo lp">    public BlogPost(String title, String text, String created, String updated) {<br/>        this.title = title;<br/>        this.text = text;<br/>        this.created = created;<br/>        this.updated = updated;<br/>    }<br/><br/>    public String getTitle() {<br/>        return title;<br/>    }<br/><br/>    public void setTitle(String title) {<br/>        this.title = title;<br/>    }<br/><br/>    public String getText() {<br/>        return text;<br/>    }<br/><br/>    public void setText(String text) {<br/>        this.text = text;<br/>    }<br/><br/>    public String getCreated() {<br/>        return created;<br/>    }<br/><br/>    public void setCreated(String created) {<br/>        this.created = created;<br/>    }<br/><br/>    public String getUpdated() {<br/>        return updated;<br/>    }<br/><br/>    public void setUpdated(String updated) {<br/>        this.updated = updated;<br/>    }<br/>}</span></pre><p id="e5ea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，我们在 BlogPost 类上添加注释<strong class="jx io">实体</strong>，然后添加我们之前定义的必要字段。id 不是我们将手动添加的东西，所以我们需要添加两个注释<strong class="jx io"> Id </strong>和<strong class="jx io"> GeneratedValue </strong>，并选择 Id 生成的策略为 AUTO 类型。除了 id，我们需要所有字段的 getters 和 setters。我们可以使用<a class="ae kt" href="https://projectlombok.org/" rel="noopener ugc nofollow" target="_blank"> lombok </a>来避免这种情况，但是在这个例子中我们将使用 getters 和 setters。</p><p id="d362" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，接下来我们将添加其他模型(实体)。</p><p id="90d0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> BlogCategory.java: </strong></p><pre class="ku kv kw kx gt lf lg lh li aw lj bi"><span id="1f69" class="lk ll in lg b gy lm ln l lo lp">package com.mjovanc.blog.model;<br/><br/>import javax.persistence.Entity;<br/>import javax.persistence.GeneratedValue;<br/>import javax.persistence.GenerationType;<br/>import javax.persistence.Id;<br/><br/>@Entity<br/>public class BlogCategory {<br/>    <br/>    @Id<br/>    @GeneratedValue(strategy = GenerationType.AUTO)<br/>    private Long id;<br/>    private String name;</span><span id="837d" class="lk ll in lg b gy lq ln l lo lp">    public BlogCategory() {<br/>    <br/>    }</span><span id="2fe1" class="lk ll in lg b gy lq ln l lo lp">    public BlogCategory(String name) {<br/>        this.name = name;<br/>    }<br/><br/>    public String getName() {<br/>        return name;<br/>    }<br/><br/>    public void setName(String name) {<br/>        this.name = name;<br/>    }<br/>}</span></pre><p id="0e65" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> BlogTag.java: </strong></p><pre class="ku kv kw kx gt lf lg lh li aw lj bi"><span id="0287" class="lk ll in lg b gy lm ln l lo lp">package com.mjovanc.blog.model;<br/><br/>import javax.persistence.Entity;<br/>import javax.persistence.GeneratedValue;<br/>import javax.persistence.GenerationType;<br/>import javax.persistence.Id;<br/><br/>@Entity<br/>public class BlogTag {<br/><br/>    @Id<br/>    @GeneratedValue(strategy = GenerationType.AUTO)<br/>    private Long id;<br/>    private String name;</span><span id="d701" class="lk ll in lg b gy lq ln l lo lp">    public BlogTag() {<br/>    <br/>    }</span><span id="afdd" class="lk ll in lg b gy lq ln l lo lp">    public BlogTag(String name) {<br/>        this.name = name;<br/>    }<br/><br/>    public String getName() {<br/>        return name;<br/>    }<br/><br/>    public void setName(String name) {<br/>        this.name = name;<br/>    }<br/>}</span></pre><p id="89ec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，当我们创建了所有的模型(实体)后，我们将继续创建存储库。我们首先在<strong class="jx io"> com.mjovanc.blog </strong>路径中创建一个名为<strong class="jx io"> repository </strong>的新包，就像我们之前创建<strong class="jx io"> model </strong>包一样。然后我们开始创建一个名为<strong class="jx io">BlogPostRepository.java</strong>的存储库文件，但这次是作为一个接口:</p><pre class="ku kv kw kx gt lf lg lh li aw lj bi"><span id="d945" class="lk ll in lg b gy lm ln l lo lp">package com.mjovanc.blog.repository;<br/><br/>import com.mjovanc.blog.model.BlogPost;<br/>import org.springframework.data.jpa.repository.JpaRepository;<br/>import org.springframework.stereotype.Repository;<br/><br/>@Repository<br/>public interface BlogPostRepository extends JpaRepository&lt;BlogPost, Long&gt; {<br/>}</span></pre><p id="46d7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们添加了另一个名为<strong class="jx io"> Repository </strong>的注释，并且我们扩展了<strong class="jx io"> JpaRepository </strong>，这样我们就可以使用内置的处理常见查询的功能，Hibernate 会为我们处理这些查询。正如我们所见，这非常容易设置！所以基本上我们会为 BlogCategory 和 BlogTask 做同样的事情。所以我不会在这里为它们粘贴代码(你可以在我的 GitHub 账户上看到完整的代码)。</p><p id="3403" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们有了两个包模型和存储库，所以我们暂时完成了我们的业务逻辑。现在我们需要像以前一样创建另一个包，但我们将把它命名为<strong class="jx io">控制器</strong>。因此，在控制器包中创建一个名为<strong class="jx io">BlogPostController.java</strong>的文件，并将以下内容放入其中:</p><pre class="ku kv kw kx gt lf lg lh li aw lj bi"><span id="d1dc" class="lk ll in lg b gy lm ln l lo lp">package com.mjovanc.blog.controller;<br/><br/>import com.mjovanc.blog.model.BlogPost;<br/>import com.mjovanc.blog.repository.BlogPostRepository;<br/>import org.springframework.beans.factory.annotation.Autowired;<br/>import org.springframework.http.HttpStatus;<br/>import org.springframework.http.ResponseEntity;<br/>import org.springframework.web.bind.annotation.*;<br/><br/>import java.util.List;<br/>import java.util.Optional;<br/><br/>@RestController<br/>@RequestMapping("v1/posts")<br/>public class BlogPostController {<br/><br/>    @Autowired<br/>    private BlogPostRepository blogPostRepository;<br/><br/>    @GetMapping<br/>    public ResponseEntity&lt;List&lt;BlogPost&gt;&gt; getAllBlogPosts() {<br/>        List&lt;BlogPost&gt; returnBlogPosts = blogPostRepository.findAll();<br/>        return new ResponseEntity&lt;&gt;(returnBlogPosts, HttpStatus.OK);<br/>    }<br/><br/>    @GetMapping("{id}")<br/>    public ResponseEntity&lt;BlogPost&gt; getBlogPostById(@PathVariable Long id) {<br/>        if (blogPostRepository.existsById(id)) {<br/>            BlogPost blogPost = blogPostRepository.findById(id).get();<br/>            return new ResponseEntity&lt;&gt;(blogPost, HttpStatus.OK);<br/>        }<br/><br/>        return new ResponseEntity&lt;&gt;(HttpStatus.BAD_REQUEST);<br/>    }<br/><br/>    @PostMapping<br/>    public ResponseEntity&lt;BlogPost&gt; createBlogPost(@RequestBody BlogPost blogPost) {<br/>        blogPostRepository.save(blogPost);<br/>        return new ResponseEntity&lt;&gt;(HttpStatus.CREATED);<br/>    }<br/><br/>    @PutMapping("{id}")<br/>    public ResponseEntity&lt;BlogPost&gt; updateBlogPostById(@PathVariable Long id, @RequestBody BlogPost blogPost) {<br/>        Optional&lt;BlogPost&gt; blogPostToFind = blogPostRepository.findById(id);<br/><br/>        if (blogPostToFind.isPresent()) {<br/>            BlogPost blogPostToUpdate = blogPostToFind.get();<br/>            blogPostToUpdate.setTitle(blogPost.getTitle());<br/>            blogPostToUpdate.setText(blogPost.getText());<br/>            blogPostToUpdate.setCreated(blogPost.getCreated());<br/>            blogPostToUpdate.setUpdated(blogPost.getUpdated());<br/><br/>            blogPostRepository.save(blogPostToUpdate);<br/>            return new ResponseEntity&lt;&gt;(HttpStatus.OK);<br/>        } else {<br/>            blogPostRepository.save(blogPost);<br/>            return new ResponseEntity&lt;&gt;(HttpStatus.CREATED);<br/>        }<br/>    }<br/><br/>    @DeleteMapping("{id}")<br/>    public ResponseEntity&lt;BlogPost&gt; deleteBlogPostById(@PathVariable Long id) {<br/>        if (blogPostRepository.existsById(id)) {<br/>            blogPostRepository.deleteById(id);<br/>            return new ResponseEntity&lt;&gt;(HttpStatus.OK);<br/>        } else {<br/>            return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND);<br/>        }<br/>    }<br/>}</span></pre><p id="5297" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">和以前一样，我不会发布其他文件，它们可以在我的 GitHub 存储库中看到。但是它们基本上是相同的，只是使用了不同的模型和存储库。我们需要稍微分解一下，因为这里有很多东西。</p><pre class="ku kv kw kx gt lf lg lh li aw lj bi"><span id="cf61" class="lk ll in lg b gy lm ln l lo lp">@RestController<br/>@RequestMapping("v1/posts")</span></pre><p id="a6a9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第一个注释<strong class="jx io"> RestController </strong>用于将该类标记为 REST 控制器，这样我们可以定义将要使用的端点，而<strong class="jx io"> RequestMapping </strong>定义所有端点应该从哪个相对 URI 路径开始。</p><pre class="ku kv kw kx gt lf lg lh li aw lj bi"><span id="64c6" class="lk ll in lg b gy lm ln l lo lp">@Autowired<br/>private BlogPostRepository blogPostRepository;</span></pre><p id="fc82" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个注释自动连接存储库，因此我们可以通过我们创建的接口调用方法。</p><pre class="ku kv kw kx gt lf lg lh li aw lj bi"><span id="8135" class="lk ll in lg b gy lm ln l lo lp">@GetMapping</span></pre><p id="0ccc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这定义了我们应该如何处理对我们定义的 URI 路径的 GET 请求，比如 GET <em class="lr"> /v1/posts </em></p><pre class="ku kv kw kx gt lf lg lh li aw lj bi"><span id="3e65" class="lk ll in lg b gy lm ln l lo lp">@GetMapping("{id}")</span></pre><p id="dd93" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们改为这样指定，我们将追加字符串<em class="lr"> /v1/posts/1 </em>作为参数，这样我们就可以获取具有特定 ID 的所需对象。</p><pre class="ku kv kw kx gt lf lg lh li aw lj bi"><span id="d202" class="lk ll in lg b gy lm ln l lo lp">public ResponseEntity&lt;List&lt;BlogPost&gt;&gt; getAllBlogPosts()</span></pre><p id="7215" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们定义了实际的端点。我们将返回一个带有博客帖子列表的 ResponseEntity。然后我们返回一个带有列表的 ResponseEntity 和一个 HTTP 状态代码 OK (200 ),让用户知道它成功了。</p><p id="f2f4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个文件中的其他端点是类似的，我们有一个 POST、PUT 和 DELETE 端点，因此我们可以通过 REST API 操作存储的数据。PUT 端点的工作原理是，如果您发送一个已经存在于数据库中的对象，它将完全覆盖它，如果它不存在，它将创建一个新行。</p><p id="901a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以现在我们已经为它的使用编写了所有必要的代码。但是我们还有一个重要的部分需要定义。让我们打开我们的<strong class="jx io">资源</strong>目录中的文件<strong class="jx io"> application.properties </strong>，并将代码放入:</p><pre class="ku kv kw kx gt lf lg lh li aw lj bi"><span id="8c84" class="lk ll in lg b gy lm ln l lo lp">spring.datasource.url=jdbc:postgresql://localhost:5432/blog<br/>spring.datasource.username=postgres<br/>spring.datasource.password=&lt;your postgres user password&gt;<br/>spring.jpa.hibernate.ddl-auto=update</span></pre><p id="3296" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些属性定义了该应用程序如何通过 url(包括数据库主机、端口和数据库名称)、用户名和密码与我们的 PostgreSQL 数据库进行通信。它还定义 Hibernate 自动创建表(如果它们不存在),并在模型(实体)发生变化时更新。</p><p id="8000" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以是时候让我们测试这个应用程序来处理所有的 HTTP 请求了。所以运行<strong class="jx io">BlogApplication.java</strong>(右击并选择在 Intellij 中运行)。</p><p id="6284" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后我们打开 Postman (cURL 也是一个不错的工具),我们首先尝试创建一个带有 HTTP POST 请求的博客帖子:</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ls"><img src="../Images/20aa778b3e65975763ecfcee50ee18e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*54lhzeNbvtCNTUC7S2u0Fw.png"/></div></div></figure><p id="16fc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，我们尝试通过获取所有博客文章来执行 HTTP GET 请求:</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ls"><img src="../Images/7628359a7c1447aab375f89b3aa948de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WLUdohFd673LySXVeHiWKA.png"/></div></div></figure><p id="cf99" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">HTTP GET 请求一篇博文的特定 ID:</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ls"><img src="../Images/e71de85f10a81451a7a07ddf6842ad30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cL6DnMuSg2TLwQgNnPSNYQ.png"/></div></div></figure><p id="9789" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，我们用一个特定的 ID 做一个 HTTP 删除请求:</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lt"><img src="../Images/384fa33b2ed71975e30d0d9254dd99d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fuE_Had_YL33GTvOB_zTyA.png"/></div></div></figure><p id="b558" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一切都很完美。这就是你如何用 Hibernate 和 PostgreSQL 设置 Spring Boot 的一切。在我的下一个教程中，我将重复我们之前的代码，但是这次我将引入关系，这样我们就可以将一篇博客文章与类别和标签联系起来。请在 Medium 或 Twitter 上关注我:<a class="ae kt" href="https://twitter.com/mjovanc" rel="noopener ugc nofollow" target="_blank">https://twitter.com/mjovanc</a></p><p id="0e78" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">GitHub 对该部分的存储库提交:<a class="ae kt" href="https://github.com/mjovanc/spring-boot-postgresql-hibernate/tree/f8ae8e0cdccaef9a5a0ff92b7896fae558c1af71" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/mjovanc/spring-boot-PostgreSQL-hibernate/tree/F8 AE 8 E0 cdccaef 9 a5 A0 ff 92 b 7896 FAE 558 C1 af 71</a></p></div></div>    
</body>
</html>