<html>
<head>
<title>Auditing Your C# Models with Entity Framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用实体框架审计你的C#模型</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/auditing-your-c-models-with-entity-framework-9ab05d6c81e9?source=collection_archive---------5-----------------------#2020-07-01">https://blog.devgenius.io/auditing-your-c-models-with-entity-framework-9ab05d6c81e9?source=collection_archive---------5-----------------------#2020-07-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/13c2060fa1eb30b88be279c89b5f17d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NODRtTm5rabTUmo-0_h9qQ.png"/></div></div></figure><p id="dc3d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当处理数据时，我的客户或顾客经常问我，“谁修改了那个记录？”。我总是向我的所有实体(模型/表)添加一些审计信息，以了解谁添加或更改了一条数据以及最后一次更改是什么时候。</p><p id="66bf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们首先创建一个名为IEntity的接口，它要求我的可审计实体需要有以下字段:</p><ul class=""><li id="9f2c" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">Id —这是我的主键。我倾向于将主键放在基本实体中，因为所有的实体都会有一个主键(即使是多对多的关系对象，但是一定要在DbContext中定义您的组合键)。按照惯例，实体框架将名为Id或<type name=""> Id的属性识别为实体的主键。</type></li><li id="412d" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">created by——一个类型为<em class="lh"> string </em>的属性，它定义了谁创建了这个记录。</li><li id="b8d8" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">CreatedOnUtc —一个类型为<em class="lh"> DateTime </em>的属性，它定义了该记录的创建时间。</li><li id="f7d4" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">LastModifiedBy —一个类型为<em class="lh"> string </em>的属性，它定义了谁最后更新了这个记录。</li><li id="2c8b" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">LastModifiedOnUtc —可空类型的属性<em class="lh"> DateTime？</em>定义该记录上次更新的时间。</li><li id="669a" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">IP Address——一个类型为<em class="lh"> string </em>的属性，存储当前用户的IP地址，尽管对我来说这处于道德灰色地带。我只想在这里展示这在技术上是如何实现的。</li><li id="d7c0" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">IsDeleted —类型为<em class="lh"> bool </em>的属性，用于在您的实体上启用软删除。如果您的业务案例不需要此属性，您可以省略它。</li></ul><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="d10f" class="lr ls in ln b gy lt lu l lv lw">public interface IEntity<br/>{<br/>    object Id { get; set; }<br/>    public string CreatedBy { get; set; }<br/>    public DateTime CreatedOnUtc { get; set; }<br/>    public string LastModifiedBy { get; set; }<br/>    public DateTime? LastModifiedOnUtc { get; set; }<br/>    public string IPAddress { get; set; }<br/>    public bool IsDeleted { get; set; }<br/>}</span></pre><p id="0d13" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后创建一个实现IEntity的BaseEntity类。基本实体被标记为抽象类，因为您永远不需要实例化它。它只是作为实际实体的基类。</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="b5aa" class="lr ls in ln b gy lt lu l lv lw">public abstract class BaseEntity&lt;T&gt; : IEntity<br/>{<br/>    [Required]<br/>    public T Id { get; set; }<br/><br/>    object IEntity.Id<br/>    {<br/>        get { return Id; }<br/>        set { }<br/>    }<br/><br/>    [Required]<br/>    public string CreatedBy { get; set; }<br/><br/>    [Required]<br/>    public DateTime CreatedOnUtc { get; set; }<br/><br/>    public string LastModifiedBy { get; set; }<br/><br/>    public DateTime? LastModifiedOnUtc { get; set; }<br/><br/>    public string IPAddress { get; set; }<br/><br/>    public bool IsDeleted { get; set; }<br/>}</span></pre><p id="6617" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意这里的泛型类型T。想法是让每个实体定义它需要什么类型的主键，即GUID、int等。为简单起见，您可以跳过泛型类型，使用您选择的任何类型。</p><p id="20b9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不用说，所有日期都使用UTC。</p><p id="c4bd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在实现IEntity时，让您的实体(或需要审计信息的实体)从BaseEntity <t>继承。这确保了您的实体总是需要您的审计信息属性。</t></p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="f9d0" class="lr ls in ln b gy lt lu l lv lw">public class Book : BaseEntity&lt;int&gt;, IEntity<br/>{<br/>    [Required]<br/>    public string Title { get; set; }<br/><br/>    [Required]<br/>    public string ISBN { get; set; }<br/><br/>    public int Pages { get; set; }<br/>}</span></pre><p id="4670" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你就快到了。到目前为止，您已经建立了包含审计属性的模型。现在让我们使用实体框架的ChangeTracker在每次保存时设置这些属性。为此，我们在应用程序的DbContext中覆盖SaveChangesAsync方法。</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="8a4e" class="lr ls in ln b gy lt lu l lv lw">public class ApplicationDbContext : DbContext<br/>{<br/>    private const string appUser = "SampleApplication";<br/>    private readonly IHttpContextAccessor _httpContextAccessor;<br/><br/>    public ApplicationDbContext(DbContextOptions&lt;ApplicationDbContext&gt; options, IHttpContextAccessor httpContextAccessor = null) : base(options)<br/>    {<br/>        if (httpContextAccessor != null)<br/>        {<br/>            _httpContextAccessor = httpContextAccessor;<br/>        }<br/>    }<br/><br/>    public DbSet&lt;Book&gt; Books { get; set; }<br/><br/>    public override async Task&lt;int&gt; SaveChangesAsync(CancellationToken cancellationToken = default)<br/>    {<br/>        AddAuditInfo();<br/><br/>        return await base.SaveChangesAsync(cancellationToken);<br/>    }<br/><br/>    private void AddAuditInfo()<br/>    {<br/>        var entities = ChangeTracker.Entries&lt;IEntity&gt;().Where(e =&gt; e.State == EntityState.Added || e.State == EntityState.Modified);<br/><br/>        var utcNow = DateTime.UtcNow;<br/>        var user = _httpContextAccessor?.HttpContext?.User?.Identity?.Name ?? appUser;<br/>        var ipAddress = _httpContextAccessor?.HttpContext?.Connection?.RemoteIpAddress?.ToString();<br/><br/>        foreach (var entity in entities)<br/>        {<br/>            if (entity.State == EntityState.Added)<br/>            {<br/>                entity.Entity.CreatedOnUtc = utcNow;<br/>                entity.Entity.CreatedBy = user;<br/>            }<br/><br/>            if (entity.State == EntityState.Modified)<br/>            {<br/>                entity.Entity.LastModifiedOnUtc = utcNow;<br/>                entity.Entity.LastModifiedBy = user;<br/>            }<br/><br/>            entity.Entity.IPAddress = ipAddress;<br/>        }<br/>    }<br/>}</span></pre><p id="f082" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里，我们为那些被添加/创建的实体设置CreatedOnUtc和CreatedBy的值，并且为那些被更新的实体设置LastModifiedOnUtc和LastModifiedBy的值。</p><p id="d7e5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，确保在Startup.cs中配置HttpContextAccessor，以便该服务可以作为依赖项注入到DbContext中。</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="bc32" class="lr ls in ln b gy lt lu l lv lw">public void ConfigureServices(IServiceCollection services)<br/>{<br/>    services.AddHttpContextAccessor();<br/>}</span></pre><p id="d330" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这样你就有希望有一个简单而优雅的解决方案来审计你的模型。当您创建或更新实体时，审计信息将被添加并保存到数据库中。</p><p id="1813" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">完整的源代码可以在我的Github上找到。</p></div></div>    
</body>
</html>