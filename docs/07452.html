<html>
<head>
<title>Reflection: Breadth First vs Depth First Traversal of Binary Trees</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反射:二叉树的广度优先与深度优先遍历</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/reflection-breadth-first-vs-depth-first-traversal-of-binary-trees-e0a92b9589f9?source=collection_archive---------5-----------------------#2022-03-26">https://blog.devgenius.io/reflection-breadth-first-vs-depth-first-traversal-of-binary-trees-e0a92b9589f9?source=collection_archive---------5-----------------------#2022-03-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b750a907ccee024ebdf35b7aa33388c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2NtneVnZ5rdx2FH4vayd2g.png"/></div></div></figure><p id="4d6e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了准备技术面试，我每天都和丹·卡尔文一起学习数据科学和算法，学习熨斗学校的课程。我们已经学习了各种排序和搜索算法，并且使用了像单链表、双向链表和二叉树这样的数据类型。</p><p id="2076" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最近，我们开始学习<a class="ae kt" href="https://en.wikipedia.org/wiki/Binary_tree#:~:text=In%20computer%20science%2C%20a%20binary,child%20and%20the%20right%20child." rel="noopener ugc nofollow" target="_blank">二叉树</a>并订购二叉树，称为<a class="ae kt" href="https://en.wikipedia.org/wiki/Binary_search_tree" rel="noopener ugc nofollow" target="_blank">二分搜索法树</a>或 BST。虽然一开始理解二叉树的模式是有挑战性的，但是使用它们变得非常有趣。在这里，我将展示一个我创建的递归方法来按层次顺序遍历一棵二叉树…至少我是这样认为的！</p><h1 id="94ef" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">二叉树是什么？</h1><figure class="lt lu lv lw gt jo gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/de7a46836c75cd1317bf33f90f8e46b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/0*LWpyMcjRaVQVj6oH.jpg"/></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated"><a class="ae kt" href="https://www.upgrad.com/blog/5-types-of-binary-tree/" rel="noopener ugc nofollow" target="_blank">https://www.upgrad.com/blog/5-types-of-binary-tree/</a></figcaption></figure><p id="7512" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">二叉树是一种树形数据结构，其中:</p><ul class=""><li id="889b" class="mb mc in jx b jy jz kc kd kg md kk me ko mf ks mg mh mi mj bi translated">有一个根节点</li><li id="75b7" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated">每个节点最多有两个子节点:左子节点和右子节点</li><li id="cb74" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated">这些值不必按顺序排列(有序的树称为二分搜索法树)</li><li id="48d1" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated">没有子节点的节点称为叶节点</li><li id="9f42" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated">高度用从根部到最远叶子的边数来衡量。在上面的例子中，高度是 3。</li></ul><p id="b0d0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">关于二叉树的详细描述，请阅读这个<a class="ae kt" href="https://www.upgrad.com/blog/5-types-of-binary-tree/" rel="noopener ugc nofollow" target="_blank">博客</a>。</p><h1 id="bd37" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">什么是深度优先树遍历？</h1><figure class="lt lu lv lw gt jo gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/c12836b46e4c8f8c98a96c1be9243246.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/0*Td4eiiiOBCTVfIiy.png"/></div></figure><p id="028c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">深度优先树遍历下降到树中最左边的叶子，并沿该分支向上向右移动，直到碰到根，并下降到右分支中最左边的叶子。在上面的例子中，它将按照 1、2、4、8、9、5、10、11 的顺序访问节点，并像这样打印结果<code class="fe mq mr ms mt b">[8,9,4,2,10,5,11...]</code>。当树被排序时，它使得搜索非常有效。</p><h1 id="814f" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">深度优先遍历什么时候有用？</h1><p id="3742" class="pw-post-body-paragraph jv jw in jx b jy mu ka kb kc mv ke kf kg mw ki kj kk mx km kn ko my kq kr ks ig bi translated">这个方法非常适合在 BST 中查找值。如果我们预期我们正在寻找的价值更接近树叶，它也是一个很好的工具。如果树更平衡，深度优先遍历将具有空间复杂度优势。</p><h1 id="66a9" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">什么是广度优先(层次顺序)树遍历？</h1><figure class="lt lu lv lw gt jo gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/c12836b46e4c8f8c98a96c1be9243246.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/0*Td4eiiiOBCTVfIiy.png"/></div></figure><p id="de96" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">级别顺序遍历是指一次遍历树的一个级别。在本例中，节点按照层级顺序遍历的路径进行排序。所以你会从 1 到 2，2 到 3，等等。</p><h1 id="4d38" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">层次顺序树遍历什么时候有用？</h1><p id="4767" class="pw-post-body-paragraph jv jw in jx b jy mu ka kb kc mv ke kf kg mw ki kj kk mx km kn ko my kq kr ks ig bi translated">在无序的二叉树中搜索值时，这很有用，特别是当树有相当大的深度或无限大时。在这些情况下，深度优先搜索可能永远不会到达所需的节点，即使它存在。这是因为它们会在查看其他分支之前继续沿着一条边向下遍历。如果树不太平衡，则宽度优先遍历将具有空间复杂度优势，因为队列会更短。</p><p id="35a4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如需更详细的解释，请阅读此<a class="ae kt" href="https://www.geeksforgeeks.org/bfs-vs-dfs-binary-tree/" rel="noopener ugc nofollow" target="_blank">文章</a>。</p><h1 id="30a5" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">我第一次尝试广度优先遍历</h1><p id="0327" class="pw-post-body-paragraph jv jw in jx b jy mu ka kb kc mv ke kf kg mw ki kj kk mx km kn ko my kq kr ks ig bi translated">每当我遇到一个新的场景，我都试图在找到最有效的解决方案之前自己解决它。我发现这有助于磨练我的批判性思维能力和创造力。在这种情况下，我太专注于创建想要的输出，以至于没有足够的注意如何去做。看看你能否发现我逻辑中的错误。</p><p id="6af0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是我的解决方案:</p><pre class="lt lu lv lw gt mz mt na nb aw nc bi"><span id="82b6" class="nd kv in mt b gy ne nf l ng nh">class Node {<br/>  constructor(value, left = null, right = null) {<br/>    this.value = value;<br/>    this.left = left;<br/>    this.right = right;<br/>  }<br/>}</span><span id="594b" class="nd kv in mt b gy ni nf l ng nh">function levelOrderTraversal(root) {<br/>  if(!root){<br/>    return []<br/>  }</span><span id="38c2" class="nd kv in mt b gy ni nf l ng nh">  const result = [[root.value]]</span><span id="6dc5" class="nd kv in mt b gy ni nf l ng nh">  const assignValues = (value, depth) =&gt; result[depth] ?  <br/>    result[depth].push(value) : result[depth] = [value]<br/>  <br/>  const traversal = (node, depth=1) =&gt; {<br/>    if(node.left){<br/>      assignValues(node.left.value, depth)<br/>      if(node.left.left || node.left.right){<br/>        traversal(node.left, depth + 1)<br/>      }<br/>    }<br/>    if(node.right){<br/>      assignValues(node.right.value, depth)<br/>      if(node.right.left || node.right.right){<br/>        traversal(node.right, depth + 1)<br/>      }<br/>    }<br/>  }<br/>  <br/>  traversal(root)<br/>  return result.flat()<br/>}</span></pre><p id="2309" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我创建了一个<code class="fe mq mr ms mt b">Node</code>类，并为 left 和 right 属性分配了默认值。</p><pre class="lt lu lv lw gt mz mt na nb aw nc bi"><span id="b9c6" class="nd kv in mt b gy ne nf l ng nh">class Node {<br/>  constructor(value, left = null, right = null) {<br/>    this.value = value;<br/>    this.left = left;<br/>    this.right = right;<br/>  }<br/>}</span></pre><p id="17ff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，我开始写<code class="fe mq mr ms mt b">levelOrderTraversal</code>函数。</p><p id="2ab5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果没有根值，我就返回一个空数组。</p><pre class="lt lu lv lw gt mz mt na nb aw nc bi"><span id="1bf8" class="nd kv in mt b gy ne nf l ng nh">if(!root){<br/>    return []<br/>  }</span></pre><p id="512c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我没有想过创建队列，所以我决定创建一个数组的数组，其中内部数组的索引与节点所在的级别相匹配。</p><p id="8cce" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以，我开始声明一个根值为 0 的<code class="fe mq mr ms mt b">result</code>变量。</p><pre class="lt lu lv lw gt mz mt na nb aw nc bi"><span id="63fc" class="nd kv in mt b gy ne nf l ng nh">const result = [[root.value]]</span></pre><p id="67f0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我编写了一个助手函数来分配一个节点的值:</p><pre class="lt lu lv lw gt mz mt na nb aw nc bi"><span id="3eb6" class="nd kv in mt b gy ne nf l ng nh">const assignValues = (value, depth) =&gt; result[depth] ?  <br/>    result[depth].push(value) : result[depth] = [value]</span></pre><p id="0feb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果这个深度有一个数组，那么我就把这个值放到这个数组里。如果没有该深度的数组，它会用该值创建一个数组。</p><p id="5372" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后我写了一个助手函数<code class="fe mq mr ms mt b">traversal</code>来递归遍历树的节点。</p><pre class="lt lu lv lw gt mz mt na nb aw nc bi"><span id="01f1" class="nd kv in mt b gy ne nf l ng nh">const traversal = (node, depth=1) =&gt; {<br/>    if(node.left){<br/>      assignValues(node.left.value, depth)<br/>      if(node.left.left || node.left.right){<br/>        traversal(node.left, depth + 1)<br/>      }<br/>    }<br/>    if(node.right){<br/>      assignValues(node.right.value, depth)<br/>      if(node.right.left || node.right.right){<br/>        traversal(node.right, depth + 1)<br/>      }<br/>    }<br/>  }</span></pre><p id="4e94" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果有<code class="fe mq mr ms mt b">node.left</code>，那么我把值赋给结果数组。然后，如果该节点有一个左或右节点，我在该节点上调用遍历，并将深度增加 1。我对<code class="fe mq mr ms mt b">node.right</code>也执行了同样的逻辑。我先检查了<code class="fe mq mr ms mt b">node.left</code>,因为它可以从左到右保持值的顺序。</p><p id="4aea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，我调用<code class="fe mq mr ms mt b">traverse(root)</code>来遍历整个树。在这一点上<code class="fe mq mr ms mt b">result=[[1],[2,3],[4,5,6,7],[8,9,10,11,12,13,14]]</code>，所以我在返回数组的时候把它展平了<code class="fe mq mr ms mt b">return result.flat()</code>。</p><h1 id="4506" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">解决方案</h1><p id="63bf" class="pw-post-body-paragraph jv jw in jx b jy mu ka kb kc mv ke kf kg mw ki kj kk mx km kn ko my kq kr ks ig bi translated">解决之后，我将我的解决方案与使用 Flatiron 提供的队列的标准迭代解决方案进行了比较。</p><pre class="lt lu lv lw gt mz mt na nb aw nc bi"><span id="ac7e" class="nd kv in mt b gy ne nf l ng nh">function levelOrderTraversal(root) {<br/>  let queue = root !== null ? [root] : [];<br/>  let result = [];<br/>  while (queue.length) {<br/>    const node = queue.shift();<br/>    result.push(node);</span><span id="7986" class="nd kv in mt b gy ni nf l ng nh">    if (node.left) {<br/>      queue.push(node.left);<br/>    }</span><span id="fa07" class="nd kv in mt b gy ni nf l ng nh">    if (node.right) {<br/>      queue.push(node.right);<br/>    }<br/>  }<br/>  return result.map(node =&gt; node.value);<br/>}</span></pre><p id="7d35" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里的逻辑是有一个从根节点开始的<code class="fe mq mr ms mt b">queue</code>数组。</p><p id="ee0c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当队列中有节点时:</p><ol class=""><li id="ae82" class="mb mc in jx b jy jz kc kd kg md kk me ko mf ks nj mh mi mj bi translated">从队列中删除第一个节点，并将其存储在变量<code class="fe mq mr ms mt b">node</code>中。</li><li id="b075" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks nj mh mi mj bi translated">将节点的值推入结果数组。</li><li id="7213" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks nj mh mi mj bi translated">如果<code class="fe mq mr ms mt b">node</code>有左节点，将其推入队列。</li><li id="4bd3" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks nj mh mi mj bi translated">如果<code class="fe mq mr ms mt b">node</code>有一个正确的节点，将其推入队列。</li><li id="0f74" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks nj mh mi mj bi translated">重复步骤 1–4</li></ol><p id="f2aa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，通过 result 映射来获取值并返回结果。</p><h1 id="bb52" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">我最初的想法</h1><p id="82e1" class="pw-post-body-paragraph jv jw in jx b jy mu ka kb kc mv ke kf kg mw ki kj kk mx km kn ko my kq kr ks ig bi translated">乍一看，我对自己的解决方案非常满意。在本练习中:</p><ul class=""><li id="5cf8" class="mb mc in jx b jy jz kc kd kg md kk me ko mf ks mg mh mi mj bi translated">两种解决方案都会访问每个节点一次</li><li id="e546" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated">他们的解决方案通过创建一个额外的<code class="fe mq mr ms mt b">queue</code>数组来使用更多的内存，而我的没有</li><li id="0c47" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated">我的解决方案使结果变平，他们通过它进行映射，这在时间和空间复杂性上是可比较的。</li></ul><p id="d01d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这一点上我感觉棒极了！我认为我的解决方案更好，因为我没有分配额外的空间。但是…</p><h1 id="462c" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">我错过了一些重要的东西</h1><p id="a449" class="pw-post-body-paragraph jv jw in jx b jy mu ka kb kc mv ke kf kg mw ki kj kk mx km kn ko my kq kr ks ig bi translated">首先，他们的解决方案可以被重构，通过将<code class="fe mq mr ms mt b">result.push(node)</code>改为<code class="fe mq mr ms mt b">result.push(node.value)</code>来消除映射结果的需要。但最重要的是，我的解决方案错过了广度优先遍历的意图。我返回了预期的结果，但是我没有按照程序操作。</p><p id="7693" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">其中队列实际上首先遍历二叉树的宽度，<strong class="jx io">我的过程实际上进行深度优先遍历，但是返回该遍历的结果，就好像它已经首先遍历了宽度。</strong></p><p id="0915" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我得出的结论是，我没有编写广度优先遍历解决方案。</p><h1 id="3184" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">最终反射</h1><p id="97af" class="pw-post-body-paragraph jv jw in jx b jy mu ka kb kc mv ke kf kg mw ki kj kk mx km kn ko my kq kr ks ig bi translated">出于几个原因，我非常感谢我犯的那个错误。创建它提醒我，在解决这样的场景时，我需要小心地遵循预期的过程模式。通过简单的测试，仅查看输出是否与预期输出匹配，我的逻辑中的缺陷不会很明显。所以，我需要努力批判性地分析所呈现的信息。</p><p id="5481" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">同样，犯这个错误促使我进一步研究遍历和搜索方法的用例。现在，当我在野外遇到树时，我将能够根据二叉树的预期特征更好地决定使用哪种方法。</p></div></div>    
</body>
</html>