<html>
<head>
<title>Knowing numpy Through The Really Tough Questions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过真正困难的问题了解 numpy</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/knowing-numpy-through-the-really-tough-questions-609fa83ba5df?source=collection_archive---------2-----------------------#2020-08-06">https://blog.devgenius.io/knowing-numpy-through-the-really-tough-questions-609fa83ba5df?source=collection_archive---------2-----------------------#2020-08-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/3ef7bd6f819d24e1a19b38a3d8783eab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SC0LFDp2kSkrV5KY"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">艾米丽·莫特在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="5345" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">numpy 可以说是最通用的 Python 库，高效、快速且可互操作。在本帖中，我们将通过用例展示 numpy 的强大功能。</p><blockquote class="ky kz la"><p id="a937" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><strong class="kc io"> 1。导入名为 np </strong>的 numpy 包</p></blockquote><figure class="lg lh li lj gt jo gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/4a084dea7543ebe6e3ea8babc041ac63.png" data-original-src="https://miro.medium.com/v2/resize:fit:510/format:webp/1*ORDz7WkRndT59DOBslMRuQ.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><strong class="bd lk"> as </strong>关键字将 numpy 重命名为 np</figcaption></figure><blockquote class="ky kz la"><p id="626e" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><strong class="kc io"> 2。打印 numpy 版本和配置</strong></p></blockquote><figure class="lg lh li lj gt jo gh gi paragraph-image"><div class="gh gi ll"><img src="../Images/6a96be1e910a4b279c7963ac6d71022f.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/format:webp/1*wi3zA2iBgWolsByW8dILkQ.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">不是每个人都使用相同版本的 numpy</figcaption></figure><blockquote class="ky kz la"><p id="f023" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><strong class="kc io"> 3。创建一个大小为 10 的空向量</strong></p></blockquote><figure class="lg lh li lj gt jo gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/4bfd94271f69168844fc6e10d52b49d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*CtnCCKdtrp7bcSfIpMP--g.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">来自 numpy 的<strong class="bd lk"> zeros( ) </strong>创建空向量(仅包含 0)</figcaption></figure><blockquote class="ky kz la"><p id="461b" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><strong class="kc io"> 4。查找数组的内存大小</strong></p></blockquote><figure class="lg lh li lj gt jo gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/1dcbfa0b5e341ee9fd49acb11332ea91.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*K1nTMHAUwaE6pDokX_Z9xw.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><strong class="bd lk"> arange( ) </strong>以 1 为间隔(由第三个参数指定)生成从 1 到 6(不包括)的元素</figcaption></figure><blockquote class="ky kz la"><p id="139b" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><strong class="kc io"> 5。获取 numpy 添加函数</strong>的文档</p></blockquote><figure class="lg lh li lj gt jo gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/deb64ea4e4f65d38d3017849fecf35b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:454/format:webp/1*kt7iIAYa62cJjTPT4gauGA.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">向 numpy 的<strong class="bd lk"> info( ) </strong>方法传递函数名(本例中为<strong class="bd lk">加</strong></figcaption></figure><blockquote class="ky kz la"><p id="07aa" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><strong class="kc io"> 6。创建一个大小为 10 的空向量，第五个值为 1 </strong></p></blockquote><figure class="lg lh li lj gt jo gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/cf109e0ea336bc69c1c392bce52b71ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*iCvsK3B5Q8M76uEAu50WzQ.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">将级联列表传递给 numpy 的<strong class="bd lk"> array( ) </strong>方法，其中*用于重复元素</figcaption></figure><blockquote class="ky kz la"><p id="ecbe" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">7。创建一个取值范围为 10 到 49 的向量</p></blockquote><figure class="lg lh li lj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lq"><img src="../Images/302412e2c576cc679c9845e3200e0472.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6p1IPeZVvlNipTbdDLGLXA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">numpy 的 arange( ) 创建一个从 10 到 50(不包括)的数组，步长为 1</figcaption></figure><blockquote class="ky kz la"><p id="0993" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><strong class="kc io"> 8。反转一个矢量</strong></p></blockquote><figure class="lg lh li lj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lr"><img src="../Images/2e4f7f63d8434f2e9a2a5f5c6b593e2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WUmHOcKpF_BpRjsqyU3d7w.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">使用切片和负索引</figcaption></figure><blockquote class="ky kz la"><p id="acde" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><strong class="kc io"> 9。创建一个 3 x 3 的矩阵，矩阵值的范围从 0 到 8 </strong></p></blockquote><figure class="lg lh li lj gt jo gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/284dbac47b91cd5065f29ab42d5ae444.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/format:webp/1*gGtssqN_MFNihuzHJdRyAw.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><strong class="bd lk"> reshape( ) </strong>将来自<strong class="bd lk"> arange( ) </strong>的向量重新排列成 3×3 矩阵</figcaption></figure><blockquote class="ky kz la"><p id="3d4d" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><strong class="kc io"> 10。从[1，2，0，0，4，0]中寻找非零元素的索引</strong></p></blockquote><figure class="lg lh li lj gt jo gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/6cba24281d5942da81f694d986e1f4d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*f86NvYPOPHHvDp9LWU-jvg.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><strong class="bd lk">非零()</strong>numpy 方法返回 numpy 数组中非零元素的索引列表</figcaption></figure><blockquote class="ky kz la"><p id="1de4" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><strong class="kc io"> 11。创建一个 3×3 的单位矩阵</strong></p></blockquote><figure class="lg lh li lj gt jo gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/b549f33304ef2c2f70618900cd1f0a48.png" data-original-src="https://miro.medium.com/v2/resize:fit:510/format:webp/1*F8U1Zv5ikEnNfTlkBL9png.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><strong class="bd lk"> eye(m) </strong>方法创建一个<strong class="bd lk"> m x m </strong>单位矩阵</figcaption></figure><blockquote class="ky kz la"><p id="0fc8" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><strong class="kc io"> 12。用随机值创建一个 3 x 3 x 3 的数组</strong></p></blockquote><figure class="lg lh li lj gt jo gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/7414c73f12361f30c06fade82dfdf745.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*1up7ERLIXJb0FmsfQtyhcA.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><strong class="bd lk"> random_array </strong>是一个 3×3×3 的矩阵，包含 27 个从 1 到 100(不含)的随机整数</figcaption></figure><blockquote class="ky kz la"><p id="0bbd" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><strong class="kc io"> 13。用随机值创建一个 10 x 10 的数组，并找到最小和最大值</strong></p></blockquote><p id="9faa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> min( ) </strong>和<strong class="kc io"> max( ) </strong> from numpy 分别从 numpy 数组中找出最小值和最大值:</p><figure class="lg lh li lj gt jo gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/8492e61f6c8b82c541eabf6cf38ee66d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/1*RT58vMOtjRM8EI1WjmQJXw.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">从范围从-100 到 100(不含)的随机整数矩阵中寻找最小值和最大值</figcaption></figure><blockquote class="ky kz la"><p id="dfdb" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><strong class="kc io"> 14。创建一个大小为 30 的随机向量，并找出平均值</strong></p></blockquote><p id="84ca" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> mean( ) </strong> from numpy 查找 numpy 数组中所有值的平均值:</p><figure class="lg lh li lj gt jo gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/c90adcf8612ed1a9c9271606dd788a2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/1*dLNryMkPLcr5OWTM3Xfxvw.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><strong class="bd lk"> rand_vec_mean </strong>是一个 numpy 向量，包含 30 个从-30 到 30(不含)的随机整数</figcaption></figure><blockquote class="ky kz la"><p id="85ab" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">15。创建一个边界为 1，内部为 0 的二维数组</p></blockquote><p id="82eb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从一个只有 1 的矩阵开始，我们填充从索引 1 开始的所有行和列，直到但包括最后一个索引:</p><figure class="lg lh li lj gt jo gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/c5e8da55ef24bc40e15b406872f68abb.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*p4X3hAAzw_JG8Cn2vZdjaw.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><strong class="bd lk">_ array</strong>是一个具有所需值的 5×5 矩阵</figcaption></figure><blockquote class="ky kz la"><p id="9e00" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><strong class="kc io"> 16。如何在现有数组周围添加边框(用 0 填充)？</strong></p></blockquote><p id="6b31" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在一个随机整数的矩阵周围，我们使用 numpy 的<strong class="kc io"> pad( ) </strong>方法添加一个 0 的填充。将生成的矩阵重新分配给原始数组:</p><figure class="lg lh li lj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ly"><img src="../Images/165e2221b1963d7e6294a23fac981d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LFZS7Ii6XzSGxx3wtEYlfQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">我们想要一个常量<strong class="bd lk"> (mode，constant_values) </strong>两行两列 0 的宽度<strong class="bd lk"> (pad_width) </strong></figcaption></figure><blockquote class="ky kz la"><p id="29d9" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><strong class="kc io"> 17。找出下列表达式的结果</strong></p></blockquote><pre class="lg lh li lj gt lz ma mb mc aw md bi"><span id="c077" class="me mf in ma b gy mg mh l mi mj">0 * np.nan</span></pre><figure class="lg lh li lj gt jo gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/146e222042b0ff769992905dab77c3b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:328/format:webp/1*ucnQ-h63E12Yu0nMFpCgeg.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">对<strong class="bd lk"> nan </strong>值的任何数学计算都会返回<strong class="bd lk"> nan </strong>本身</figcaption></figure><pre class="lg lh li lj gt lz ma mb mc aw md bi"><span id="4dfc" class="me mf in ma b gy mg mh l mi mj">np.nan == np.nan</span></pre><figure class="lg lh li lj gt jo gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/6db187b72bc86134dae9b6dc931db42a.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/format:webp/1*qNKY6HuPIDR4qc-XC5V3qw.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><strong class="bd lk"> nan </strong>值未定义，比较结果为假</figcaption></figure><pre class="lg lh li lj gt lz ma mb mc aw md bi"><span id="783f" class="me mf in ma b gy mg mh l mi mj">np.inf &gt; np.nan</span></pre><figure class="lg lh li lj gt jo gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/1d2616118e668a186bf21bce1f3ad3fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:406/format:webp/1*TsEbqEWiWwQ7O_vSXYZHDA.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">由于<strong class="bd lk"> nan </strong>未定义，所以不清楚它是否小于无穷大(<strong class="bd lk"> np.inf </strong>)</figcaption></figure><pre class="lg lh li lj gt lz ma mb mc aw md bi"><span id="bae0" class="me mf in ma b gy mg mh l mi mj">np.nan - np.nan</span></pre><figure class="lg lh li lj gt jo gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/b413efa9dca48b4af0ded3c99c8a529a.png" data-original-src="https://miro.medium.com/v2/resize:fit:434/format:webp/1*5XB7ruc0Rkt86pdAHU3LQw.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">从<strong class="bd lk"> nan </strong>中减去<strong class="bd lk"> nan </strong>得到<strong class="bd lk"> nan </strong>！</figcaption></figure><pre class="lg lh li lj gt lz ma mb mc aw md bi"><span id="255e" class="me mf in ma b gy mg mh l mi mj">0.3 == 3 * 0.1</span></pre><figure class="lg lh li lj gt jo gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/d6c0a0e82b8b8f850d08ae966211507d.png" data-original-src="https://miro.medium.com/v2/resize:fit:416/format:webp/1*QhEP5eP6FA7kWneIxvq1dQ.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">Float 不是按原样存储，而是以更高的精度存储。因此，3 * 0.1 不会产生精确的 0.3</figcaption></figure><blockquote class="ky kz la"><p id="9685" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">18。在对角线下方创建一个值为 1、2、3、4 的 5 x 5 矩阵</p></blockquote><p id="ac3f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">numpy 中的<strong class="kc io"> diag( ) </strong>函数根据对角线的大小创建一个矩阵。对角线正下方有 4 个值，对角线本身正好由 5 个元素组成。参数<strong class="kc io"> k </strong>(默认值为 0)设置为-1，表示对角线正下方的元素，这些元素是使用<strong class="kc io"> arange( ) </strong>方法生成的:</p><figure class="lg lh li lj gt jo gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/1ef77dbf517ad5515589a6033fa67113.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*W_bi1fjuVDFkDEiA2PBDeQ.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><strong class="bd lk"> diag( ) </strong>方法创建一个 5 x 5 的矩阵，其元素位于从<strong class="bd lk"> arange( ) </strong>生成的对角线下方</figcaption></figure><blockquote class="ky kz la"><p id="0851" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><strong class="kc io"> 19。创建 8×8 的矩阵并用棋盘图案填充它</strong></p></blockquote><p id="5969" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">棋盘图案是指在行和列上交替出现 0 和 1。我们创建一个 0 的矩阵，并开始在所需的位置填充 1:</p><figure class="lg lh li lj gt jo gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/d1f68dfc817a271f93956b92c4ec756e.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*LO03JZt0HpbAW_8v0iePug.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">我们只需要整数值，因此<strong class="bd lk"> dtype </strong>参数被设置为<strong class="bd lk"> int </strong></figcaption></figure><p id="7b53" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们用交替的 1 填充每一个交替的行:</p><figure class="lg lh li lj gt jo gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/a858bfa64530c615f7de8780b123aa83.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/format:webp/1*29n9GG5L0sILPqan3QZ6BA.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">具有交替 1 的交替行</figcaption></figure><p id="482b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们用备选项 1 填充备选项列(与上述步骤相反):</p><figure class="lg lh li lj gt jo gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/7b27a21fec7a1c2cfae04e317d593311.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/format:webp/1*bwoFr6SOnYEiN6VOrEo4gg.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">棋盘矩阵！</figcaption></figure><blockquote class="ky kz la"><p id="53bb" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">20。考虑一个(6，7，8)形状的数组，找到第 100 个元素的索引(x，y，z)</p></blockquote><p id="a963" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">numpy 的<strong class="kc io">unallow _ index()</strong>函数查找以行优先顺序或列优先顺序表示的矩阵的任意元素的位置值:</p><figure class="lg lh li lj gt jo gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/24b6a18a186bce720a617c47be7e3de3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*F8sCj_CwD72IgQn6vqY4pg.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">order = "C "考虑以行优先顺序存储的给定形状的矩阵(由元组表示)</figcaption></figure><figure class="lg lh li lj gt jo gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/e4c97fce7599920f0f23ef67f9c1ce94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1110/format:webp/1*b8NISSwYgRsqeHiDE3VqFw.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">order = "F "考虑以列优先顺序存储的给定形状的矩阵(由元组表示)</figcaption></figure><blockquote class="ky kz la"><p id="bf2d" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><strong class="kc io"> 21。使用平铺功能</strong>创建一个 8×8 的棋盘矩阵</p></blockquote><p id="7f3b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们从交替的 0 和 1 的 2 x 2 矩阵开始:</p><figure class="lg lh li lj gt jo gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/1cc81f32a9bcdd6cb6a2da4b3e7ec56b.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*WJ8_Ej-LFVOl9Pq3VG26xA.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">需要使用 tile()来扩展它</figcaption></figure><p id="f6df" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">numpy 的<strong class="kc io"> tile( ) </strong>方法获取上面的矩阵，并跨行和列一次复制四个矩阵(由 tuple 参数表示):</p><figure class="lg lh li lj gt jo gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/ca1bd89d7863055363496be03cb4e326.png" data-original-src="https://miro.medium.com/v2/resize:fit:792/format:webp/1*Md5aFYNkuxP_XpjiMk-r6A.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">0 和 1 的棋盘矩阵</figcaption></figure><blockquote class="ky kz la"><p id="ee22" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><strong class="kc io"> 22。标准化一个 5 x 5 的随机矩阵</strong></p></blockquote><p id="65c4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一个数的归一化是两项的比值。分子是通过从我们正在归一化的数字中减去整个集合的<strong class="kc io">最小值得到的。从整组</strong>的<strong class="kc io">最大值中减去整组</strong>的<strong class="kc io">最小值得到分母</strong></p><figure class="lg lh li lj gt jo gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/9c87302e6e8671248e53d2f86d7de55e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*jh_B9lkR66cqa5Z6ZFprVQ.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><strong class="bd lk"> random_matrix </strong>是介于-20 到 20(不含)之间的随机整数的 5×5 矩阵</figcaption></figure><p id="ae33" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">分别使用<strong class="kc io"> np.min( ) </strong>和<strong class="kc io"> np.max( ) </strong>计算<strong class="kc io">最小值</strong>和<strong class="kc io">最大值</strong>值:</p><figure class="lg lh li lj gt jo gh gi paragraph-image"><div class="gh gi my"><img src="../Images/0e23ac32abc712b2e29ee148e7c28c2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*umkcmPck8nXzIeP43akstQ.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">寻找<strong class="bd lk"> random_matrix </strong>的最小值和最大值</figcaption></figure><p id="4d9e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">标准化后，所有值都在 0 和 1 之间:</p><figure class="lg lh li lj gt jo gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/b5d548c23dca6f92b9e9ae3678b50014.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*YtjkKWMckSCFsdrNGFXe6g.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><strong class="bd lk"> random_matrix </strong>已经归一化</figcaption></figure><blockquote class="ky kz la"><p id="6e48" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><strong class="kc io"> 23。将一个 5×3 矩阵乘以一个 3×2 矩阵(实矩阵乘积)</strong></p></blockquote><figure class="lg lh li lj gt jo gh gi paragraph-image"><div class="gh gi na"><img src="../Images/b916128edb76ed1b76a0104769f23e9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*j60Zk9eb5QpGgOf-VnPtXw.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">矩阵乘法是可能的，因为<strong class="bd lk">第一个矩阵的列数=第二个矩阵的行数</strong></figcaption></figure><blockquote class="ky kz la"><p id="bdbc" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><strong class="kc io"> 24。给定一个 1D 数组，取 3 到 8 之间的元素的反，就位</strong></p></blockquote><p id="2e34" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们首先构建一个条件语句，它将过滤掉 3 到 8 之间的元素。随后根据条件索引随机向量。满足给定范围的元素乘以<strong class="kc io"> -1 </strong>得到负数:</p><figure class="lg lh li lj gt jo gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/d7d24f924dd6ad0bc00c9b642618f3d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*-WAJ39zB8noo3ZNfwwLwaw.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">生成介于 1 和 10(不含 1 和 10)之间的随机数，并对介于 3 和 8 之间的随机数求反</figcaption></figure><blockquote class="ky kz la"><p id="7c58" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">25。如何找到两个 numpy 数组之间的公共值？</p></blockquote><p id="f6fb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> intersect1d( ) </strong>函数返回两个 numpy 数组的交集:</p><figure class="lg lh li lj gt jo gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/d9e4fd26f6b38b7545da3efb27bdb9b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/1*L3MQcEa2eHpzxRqPSsCfbg.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><strong class="bd lk"> arr1 </strong>和<strong class="bd lk"> arr2 </strong>是两个随机整数数组；它们的公共元素存储在<strong class="bd lk">交集</strong>中</figcaption></figure><blockquote class="ky kz la"><p id="c820" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><strong class="kc io"> 26。创建一个大小为 10 的向量，取值范围从 0 到 1，两者都不包括</strong></p></blockquote><p id="b9e8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> numpy </strong>中的<strong class="kc io"> linspace( ) </strong>函数返回指定区间内间隔相等的数字，从范围下限开始，到范围上限结束。因为我们需要 10 个值，不包括起点和终点，所以我们传递 12 作为元素计数(由参数<strong class="kc io"> num </strong>表示)并使用切片排除限制:</p><figure class="lg lh li lj gt jo gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/4f72037d87584ddf3b32fe94a3fe2d1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*3qYryQIh1kjm98EZcQrwSg.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">排除 0 和 1，使用<strong class="bd lk">【1:-1】</strong>，我们将剩余的 10 个元素存储在<strong class="bd lk"> x </strong>中</figcaption></figure><blockquote class="ky kz la"><p id="7ef4" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><strong class="kc io"> 27。创建一个大小为 10 的随机向量并排序</strong></p></blockquote><p id="0fad" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">将<strong class="kc io"> numpy </strong>的内置<strong class="kc io"> sort( ) </strong>方法应用到从范围<strong class="kc io"> -10 到 20 </strong>(任何其他间隔也可以)内的<strong class="kc io"> 10 </strong>个随机整数创建的数组上:</p><figure class="lg lh li lj gt jo gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/f242be45225e1a5398470a126da1c29e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*_7LYYKgVYqPuXAEU5hXV7A.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><strong class="bd lk"> sort( ) </strong>方法返回排序后的随机整数序列</figcaption></figure><blockquote class="ky kz la"><p id="2d84" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">28。考虑两个随机数组 A 和 b。检查它们是否相等</p></blockquote><p id="c65d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当且仅当所有对应的元素都匹配时，称两个数组相等。<strong class="kc io"> all( ) </strong>函数和等式条件一起产生期望的结果:</p><figure class="lg lh li lj gt jo gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/30741de525befc4297019b374972bbc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*6gESV6xXR1wTvgMKHp8yWQ.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><strong class="bd lk"> all( ) </strong>仅当<strong class="bd lk"> A </strong>和<strong class="bd lk"> B </strong>中的所有对应元素相等时，返回<strong class="bd lk"> True </strong></figcaption></figure><blockquote class="ky kz la"><p id="fa78" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><strong class="kc io"> 29。创建一个大小为 10 的随机向量，并将最大值替换为-1 </strong></p></blockquote><p id="3bcc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们首先使用 numpy 的<strong class="kc io"> random( ) </strong>函数创建一个介于 0 和 1(不含)之间的浮点向量。<strong class="kc io"> argmax( ) </strong>函数返回最大浮点的位置值。我们通过插入-1:</p><figure class="lg lh li lj gt jo gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/cff6d7f00cdde7982d2740a43eb8221e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*htjFl5wmLyOi8jMtS71mbw.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">插入-1 前后显示<strong class="bd lk"> rand_vec </strong></figcaption></figure><p id="3380" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我希望这篇文章对你有所帮助。请随时留下您的评论、反馈、批评、想法和其他一切。回头见！</p></div></div>    
</body>
</html>