<html>
<head>
<title>Threads in Operating System</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">操作系统中的线程</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/threads-in-operating-system-f27d0c5470c7?source=collection_archive---------2-----------------------#2021-11-27">https://blog.devgenius.io/threads-in-operating-system-f27d0c5470c7?source=collection_archive---------2-----------------------#2021-11-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="02c0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">内核级和用户级线程</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ee350c36e75de374a210ccb5f0ca84fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2VZCHcaC4TraSaxU"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/photos/XJXWbfSo2f0" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/XJXWbfSo2f0</a></figcaption></figure><p id="3988" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">线程也称为轻量级进程，它是通过进程代码执行的流程。<br/>线程通过并行运行来提高应用程序的性能。线程切换不需要与操作系统交互，不像进程需要与操作系统交互。一个线程有自己的程序计数器、系统寄存器和堆栈，但是它们共享公共的代码、数据和文件，如下图所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi kz"><img src="../Images/f75a06117359093bb3cd391e0f4c0ba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*eAP4hzgxfrmvTb9Udlz9ng.jpeg"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/4_Threads.html" rel="noopener ugc nofollow" target="_blank">https://www . cs . UIC . edu/~ jbell/course notes/operating systems/4 _ threads . html</a></figcaption></figure><p id="6cc4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果一个线程被阻塞或者正在等待某个 I/O 操作，同一任务中的另一个线程可以不受任何干扰地运行。</p><p id="ef05" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">线程有两种实现方式，<br/> 1。<strong class="jm io">用户级线程:</strong>在用户级线程中，线程由应用程序管理，内核不知道线程。应用程序从单个线程开始，然后开始在该线程中运行。这些线程可以在任何应用程序上运行，并且创建和管理速度很快。</p><p id="c0e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.<strong class="jm io">内核级线程:</strong>这些线程由内核管理，这些线程由操作系统直接支持。内核能够在多个进程上同时调度来自同一进程的多个线程。内核线程的创建和管理速度比用户线程慢。</p><p id="ea8a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当多个线程同时执行时，我们称之为多线程。同一应用程序中的多个线程可以在多个处理器上并行运行，当有阻塞系统调用时，它不需要阻塞整个进程。<br/>有三种不同类型的多线程模型，</p><ol class=""><li id="4b22" class="la lb in jm b jn jo jr js jv lc jz ld kd le kh lf lg lh li bi translated"><strong class="jm io">多对多模型:</strong>在这个模型中，用户级线程复用到数量更少或相等的内核级线程。如果一个用户线程被阻塞，我们可以将其他用户线程调度到另一个内核线程。</li><li id="4590" class="la lb in jm b jn lj jr lk jv ll jz lm kd ln kh lf lg lh li bi translated"><strong class="jm io">多对一模型:</strong>在这里，许多用户级线程映射到一个内核级线程，线程管理在用户空间完成。当一个线程进行阻塞系统调用时，整个进程被阻塞。在这个模型中，多线程不能在多处理器上并行运行。</li><li id="3b29" class="la lb in jm b jn lj jr lk jv ll jz lm kd ln kh lf lg lh li bi translated"><strong class="jm io">一对一模型:</strong>这里，一个用户级线程一次只能使用一个内核级线程。这种模式比多对一模式有更多的并发性。在这个模型中，创建一个用户线程需要一个相应的内核线程。</li></ol><p id="4e2d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有关操作系统中线程的更多信息，请参考此<a class="ae ky" href="https://www.tutorialspoint.com/operating_system/os_multi_threading.htm" rel="noopener ugc nofollow" target="_blank">站点</a>。</p></div></div>    
</body>
</html>