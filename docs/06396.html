<html>
<head>
<title>How Did I Contribute to Open Source? — A Guide to Contribute KEDA through Adding a New ActiveMQ Scaler</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何为开源做出贡献？—通过添加新的活动MQ缩放器来贡献KEDA的指南</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-did-i-contribute-to-open-source-46a7bad88d99?source=collection_archive---------14-----------------------#2022-01-04">https://blog.devgenius.io/how-did-i-contribute-to-open-source-46a7bad88d99?source=collection_archive---------14-----------------------#2022-01-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/7083867c14c55fbd7e82e88cf28e9dc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OCn0u3JL3othmcH07HihIw.png"/></div></div></figure><p id="2437" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有很多种方式可以为KEDA做出贡献。在本文中，我将通过创建一个新的KEDA缩放器来解释我的贡献之旅。我添加了一个新的缩放器，它可以基于ActiveMQ代理进行缩放。它联系ActiveMQ的管理端点来确定队列的消息计数，并相应地进行扩展。</p><p id="ade6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">增加一个新的定标器基本上包括3个部分:</p><p id="161e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">1.创建新的缩放器</p><p id="52b1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">2.提供其单位和e2e测试</p><p id="6f34" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">3.为<a class="ae kt" href="https://keda.sh/" rel="noopener ugc nofollow" target="_blank"> keda.sh </a>页面提供文档和示例</p><p id="4f43" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">定标器和单元测试用Go编写，E2E测试用TypeScript编写，使用的是<a class="ae kt" href="https://github.com/avajs/ava" rel="noopener ugc nofollow" target="_blank"> ava </a>框架。</p><p id="15a5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">点击<a class="ae kt" href="https://github.com/kedacore/keda/blob/main/pkg/scalers/activemq_scaler.go" rel="noopener ugc nofollow" target="_blank"> ActiveMQ定标器</a>、<a class="ae kt" href="https://github.com/kedacore/keda/blob/main/pkg/scalers/activemq_scaler_test.go" rel="noopener ugc nofollow" target="_blank">单元测试</a>、<a class="ae kt" href="https://github.com/kedacore/keda/blob/main/tests/scalers/activemq.test.ts" rel="noopener ugc nofollow" target="_blank"> e2e测试</a>和<a class="ae kt" href="https://github.com/kedacore/keda-docs/blob/main/content/docs/2.6/scalers/activemq.md" rel="noopener ugc nofollow" target="_blank"> ActiveMQ keda.sh文档</a>可以访问Github代码。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h2 id="3136" class="lb lc in bd ld le lf dn lg lh li dp lj kg lk ll lm kk ln lo lp ko lq lr ls lt bi translated">什么是KEDA？</h2><p id="fd43" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks ig bi translated">KEDA(基于Kubernetes的事件驱动自动缩放器)是一个单一用途、轻量级和开放源代码的组件，可以添加到任何Kubernetes集群中。</p><p id="6d8d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">KEDA的目的是提供更好的扩展选项，以便使用针对Kubernetes上的事件驱动应用程序的最佳指标进行更有效的扩展。有了KEDA，Kubernetes集群能够根据事件源(例如MongoDB、Kafka)进行扩展，而不是像Kubernetes那样消耗内存和CPU等基于资源的指标。</p><h2 id="1be9" class="lb lc in bd ld le lf dn lg lh li dp lj kg lk ll lm kk ln lo lp ko lq lr ls lt bi translated">KEDA如何使用ActiveMQ？</h2><p id="e73d" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks ig bi translated">扩展事件驱动的微服务时，队列中的消息数实质上就是需要处理的事件数。ActiveMQ定标器的目的是监视队列积压。使用积压作为需求的衡量标准，KEDA和水平Pod Autoscaler (HPA)将每个微服务扩展到所需的副本数量。</p><p id="1a5f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果消息计数较低(低于定义的阈值)，则表明需求较低，应扩展微服务。在相反的情况下，如果队列中有大量的消息，这表明需求很高，应该向外扩展微服务。</p><p id="7c6a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从版本5.8开始，ActiveMQ为代理提供了REST管理API。使用<a class="ae kt" href="https://jolokia.org/" rel="noopener ugc nofollow" target="_blank"> Jolokia </a> JMX-HTTP桥，可以访问所有代理指标(如内存使用、消息计数)并使用REST API执行管理操作。</p><h2 id="8db3" class="lb lc in bd ld le lf dn lg lh li dp lj kg lk ll lm kk ln lo lp ko lq lr ls lt bi translated">如何编写一个新的KEDA缩放器？</h2><h2 id="1f5d" class="lb lc in bd ld le lf dn lg lh li dp lj kg lk ll lm kk ln lo lp ko lq lr ls lt bi translated">1.创建新的缩放器</h2><p id="eb41" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks ig bi translated">我们从结构变量开始。ActiveMQ scaler由元数据和HTTP客户端组成。</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="334f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在ActiveMQMetadata结构中，我们应该定义希望用户提供的主要数据，或者是scaler正常运行所必需的数据。</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="md me l"/></div></figure><ul class=""><li id="d1b0" class="mf mg in jx b jy jz kc kd kg mh kk mi ko mj ks mk ml mm mn bi translated">ActiveMQ Scaler轮询ActiveMQ REST API来监控目标队列的消息计数。Scaler应该支持基本认证。因此需要<strong class="jx io"> <em class="mo">用户名</em> </strong>和<strong class="jx io"> <em class="mo">密码</em> </strong>。</li><li id="e111" class="mf mg in jx b jy mp kc mq kg mr kk ms ko mt ks mk ml mm mn bi translated"><strong class="jx io"><em class="mo">restapi Template</em></strong>是用于访问代理的消息计数指标的REST API模板。</li><li id="57e4" class="mf mg in jx b jy mp kc mq kg mr kk ms ko mt ks mk ml mm mn bi translated">在不使用restAPITemplate的情况下，scaler使用三个参数来解析REST API模板:<strong class="jx io"><em class="mo">management endpoint</em></strong>，<strong class="jx io"><em class="mo">destination name</em></strong>，<strong class="jx io"> <em class="mo"> brokerName。</em> </strong></li><li id="16bd" class="mf mg in jx b jy mp kc mq kg mr kk ms ko mt ks mk ml mm mn bi translated"><strong class="jx io"><em class="mo">targetQueueSize</em></strong>是阈值。缩放器内部还有<strong class="jx io"><em class="mo">defaultTargetQueueSize</em></strong>。缩放器比较这两个值以相应地缩放吊舱。</li><li id="1230" class="mf mg in jx b jy mp kc mq kg mr kk ms ko mt ks mk ml mm mn bi translated"><strong class="jx io"> <em class="mo"> metricName </em> </strong>是我们在此缩放器中返回的指标的名称。有一个命名助手函数<code class="fe mu mv mw mx b">GenerateMetricNameWithIndex(scalerIndex int, metricName string)</code>，它接收当前索引和原始指标名称，并使用约定返回连接的字符串。</li><li id="7c34" class="mf mg in jx b jy mp kc mq kg mr kk ms ko mt ks mk ml mm mn bi translated">所有定标器都接收一个名为<strong class="jx io"> <em class="mo">的参数scalerIndex </em> </strong>作为<code class="fe mu mv mw mx b">ScalerConfig</code>的一部分。该值是ScaledObject中当前scaler的索引。</li></ul><p id="0763" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后一个结构是activeMQMonitoring。它用于通过解码json来获得消息计数。</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="9f68" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有两个常数。如果没有提供targetQueueSize变量，则使用<strong class="jx io"><em class="mo">defaultTargetQueueSize</em></strong>。<br/>如果未提供restAPITemplate变量，<strong class="jx io"><em class="mo">defaultActiveMQRestAPITemplate</em></strong>用于使用managementEndpoint、destinationName、brokerName变量解析REST API模板。</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="4082" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"><em class="mo">【parseActiveMQMetadata()</em></strong><em class="mo"/>函数解析YAML文件。MetricName和scalerIndex也在这里生成。</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="ce43" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"><em class="mo">new scaler()</em></strong><em class="mo"/>函数是初始化缩放器的基本函数。它创建HTTP客户端。然后，使用parseActiveMQMetadata函数解析元数据，并将这些值赋给元数据结构变量。</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="3366" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> getRestAPIParameters() </strong>函数解析REST API模板，以在提供restAPITemplate变量的情况下提供管理端点、代理名称和目的地名称。</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="5155" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">getmonitoringedpoint()</strong>函数将managementEndpoint、brokerName和destinationName这三个参数组合起来，生成一个REST API模板，以防不提供restAPITemplate变量。</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="f125" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> getQueueMessageCount() </strong>函数连接到ActiveMQ监控端点，通过HTTP GET方法监控队列的消息数。</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="6ca7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们应该实现<a class="ae kt" href="https://github.com/kedacore/keda/blob/main/CREATE-NEW-SCALER.md#scaler-interface" rel="noopener ugc nofollow" target="_blank"> scaler接口</a>部分中定义的方法。所有的定标器都应该包含这些方法。</p><p id="c282" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"><em class="mo">【get metrics()</em></strong>—是定标器的关键功能；它返回一个表示外部指标当前状态的值(在我们的例子中是队列长度)。</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="f682" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"><em class="mo">GetMetricSpecForScaling()—</em></strong>KEDA配合Kubernetes水平Pod自动缩放器(HPA)工作。当KEDA注意到一个新的ScaledObject时，它会创建一个HPA对象，该对象包含轮询和扩展pod所需的度量的基本信息。为了创建这个HPA对象，KEDA调用了<code class="fe mu mv mw mx b">GetMetricSpecForScaling</code>。</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="8635" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"><em class="mo">is active()</em></strong>—KEDA根据ScaledObject中配置的<code class="fe mu mv mw mx b">pollingInterval</code>轮询ScaledObject对象；它检查上次轮询的时间，检查副本的数量是否大于0，以及缩放器本身是否处于活动状态。因此，如果缩放器为<code class="fe mu mv mw mx b">IsActive</code>返回false，并且如果副本的当前数量大于0，并且没有配置的最小pod，那么KEDA将向下缩放到0。</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="b0f6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"><em class="mo">【Close()</em></strong>—每次在定标器上轮询检索指标后，KEDA为每个定标器调用此函数，以便定标器有机会关闭任何资源。</p><h2 id="50f9" class="lb lc in bd ld le lf dn lg lh li dp lj kg lk ll lm kk ln lo lp ko lq lr ls lt bi translated">2.提供单元测试</h2><p id="13db" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks ig bi translated">单元测试只是验证单个代码单元(主要是函数)是否按预期工作。它主要有一个或几个输入，产生一个输出。</p><p id="0673" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">同样，我们从结构变量开始。</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="md me l"/></div></figure><ul class=""><li id="b6d0" class="mf mg in jx b jy jz kc kd kg mh kk mi ko mj ks mk ml mm mn bi translated"><strong class="jx io"> <em class="mo">名称</em> </strong>对所提供测试数据中错误信息的说明。</li><li id="2924" class="mf mg in jx b jy mp kc mq kg mr kk ms ko mt ks mk ml mm mn bi translated"><strong class="jx io"> <em class="mo">元数据</em> </strong>存储所有用于测试的元数据变量。</li><li id="d7c9" class="mf mg in jx b jy mp kc mq kg mr kk ms ko mt ks mk ml mm mn bi translated"><strong class="jx io"> <em class="mo"> authParams </em> </strong>存储用户名和密码。</li><li id="2561" class="mf mg in jx b jy mp kc mq kg mr kk ms ko mt ks mk ml mm mn bi translated"><strong class="jx io"> <em class="mo"> isError </em> </strong>表示提供的测试数据是否会导致错误。</li></ul><p id="a9c7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">用于创建metricName的activeMQMetricIdentifier结构。它将用于检查生成的metricName是否与提供的metric name匹配。</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="09db" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">activeMQMetricIdentifiers变量是设置的度量标识符。<code class="fe mu mv mw mx b">scalerIndex</code> value是ScaledObject中当前scaler的索引。所有指标名称都必须以sX-(其中X是scalerIndex)开头。这种约定使得度量名称在ScaledObject中是唯一的，并提供了在ScaledObject中定义多个“相似度量名称”的选项。</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="e626" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">testInvalidRestAPITemplate是提供的无效REST API模板。</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="d0e9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将缺少的元数据和格式正确的测试数据组合输入到单元测试中，以确认具有特定输入的ParseActiveMQMetadata函数按预期执行。示例数据的一个片段:</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="d40e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">TestParseActiveMQMetadata函数用于解析提供的测试数据。</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="3580" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">提供不包括targetQueueSize的测试数据，以检查代码内部的defaultTargetQueueSize变量是否正常工作。</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="md me l"/></div></figure><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="49d2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">TestActiveMQGetMetricSpecForScaling函数使用parseActiveMQMetadata函数解析元数据。创建一个模拟ActiveMQ scaler，并检查activeMQMetricIdentifiers变量中定义的metricName是否与生成的metricName匹配。</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="e311" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">如何运行单元测试？</strong></p><p id="e733" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">若要运行单元测试，请导航单元测试的路径，并按以下格式运行它:</p><pre class="lz ma mb mc gt my mx mz na aw nb bi"><span id="6f70" class="lb lc in mx b gy nc nd l ne nf">go test test_name scaler_name scaler.go azure_queue_scaler.go</span></pre><p id="8e36" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用scaler.go，因为scaler代码使用包scaler，并使用azure_queue_scaler.go，因为externaMetricType在那里定义。</p><figure class="lz ma mb mc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ng"><img src="../Images/4f34c7d4450ddb9983cea8b2f8c483f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oVFUz1SVvdqon19OQ9tkeA.png"/></div></div></figure><h2 id="e532" class="lb lc in bd ld le lf dn lg lh li dp lj kg lk ll lm kk ln lo lp ko lq lr ls lt bi translated">3.提供E2E测试</h2><p id="f4c8" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks ig bi translated">端到端(E2E)测试从头到尾测试应用程序流，以确保应用程序按预期工作。</p><p id="baf8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">E2E测试是使用<a class="ae kt" href="https://github.com/avajs/ava" rel="noopener ugc nofollow" target="_blank"> ava </a>框架以类型脚本编写的。</p><p id="c4d2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">测试脚本主要有3个阶段:</p><ul class=""><li id="b8ee" class="mf mg in jx b jy jz kc kd kg mh kk mi ko mj ks mk ml mm mn bi translated">设置</li><li id="22a1" class="mf mg in jx b jy mp kc mq kg mr kk ms ko mt ks mk ml mm mn bi translated">试验</li><li id="a908" class="mf mg in jx b jy mp kc mq kg mr kk ms ko mt ks mk ml mm mn bi translated">打扫</li></ul><p id="70ea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">设置阶段</strong></p><p id="1a83" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们从常数开始。我们应该将测试中经常使用的值定义为常量。</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="473a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个阶段的目的是创建ActiveMQ名称空间，并应用ActiveMQ的YAML文件来安装ActiveMQ。我们应该等到ActiveMQ加载。</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="5767" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">即使加载了ActiveMQ，我们也应该等到它准备好。为此，我们将连接它的健康状态端点，并等待它返回200。</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="f843" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们应该部署我们想要扩展的内容。我更喜欢像其他缩放器一样部署Nginx。我们将应用Nginx的YAML文件，并等待它被加载。</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="1b00" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">测试阶段</strong></p><p id="27c4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">部署开始时应该有0个副本。我们正在检查副本数量以确保这一点。</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="9505" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将为ActiveMQ队列生成1000条消息。我们将副本计数设置为0，将maxReplicaCount设置为5。</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="cbbf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们应该等待一段时间，之后，我们期望副本计数应该等于我们声明为maxReplicaCount的最大副本计数。</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="efe4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将使用所有消息，然后再次等待。之后，由于所有消息都被消耗，我们期望我们的副本计数应该是0。</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="3ed8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">清理阶段</strong></p><p id="693d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这一步清理创建的资源。因此，我们应该删除名称空间。</p><figure class="lz ma mb mc gt jo"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="7193" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">如何运行E2E测试？</strong></p><p id="ae9d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要运行e2e测试，请导航到e2e测试的路径，并按以下格式运行它:</p><pre class="lz ma mb mc gt my mx mz na aw nb bi"><span id="11fe" class="lb lc in mx b gy nc nd l ne nf">cd tests/<br/>npx ava scalers/activemq.test.ts -v</span></pre><figure class="lz ma mb mc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nh"><img src="../Images/0bf7963fd26494e6c96c8060b9ced6fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iEkBO5FkkkKf71eHYORhPg.png"/></div></div></figure></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="1c2e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">瞧啊。🎉感谢阅读。我希望这篇文章对你有所帮助，并且和我一样喜欢！</p></div></div>    
</body>
</html>