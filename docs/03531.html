<html>
<head>
<title>Quick guide on Combine essentials</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">联合收割机基本要素快速指南</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/quick-guide-on-combine-essentials-3b5f8065865e?source=collection_archive---------3-----------------------#2020-11-15">https://blog.devgenius.io/quick-guide-on-combine-essentials-3b5f8065865e?source=collection_archive---------3-----------------------#2020-11-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7db1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">阅读本指南，了解联合收割机的基本概念和术语，开始使用联合收割机。</h2></div><p id="ebe1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在2019年WWDC展会上听到苹果公司名为Combine的新框架真是令人兴奋。最后，我们有了一种本地方式来编写功能性反应代码，并以声明的方式构建应用程序。</p><p id="038c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇文章概述了联合收割机的概念和术语。</p><h1 id="8e69" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">概观</h1><p id="bc0d" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">联合收割机的主要部件有<code class="fe ly lz ma mb b">Publisher</code>、<code class="fe ly lz ma mb b">Subject</code>、<code class="fe ly lz ma mb b">Subscriber</code>和<code class="fe ly lz ma mb b">Operator</code>。以下是他们工作的简要总结:</p><p id="876e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">发布者</strong></p><ul class=""><li id="22f1" class="mc md iq kh b ki kj kl km ko me ks mf kw mg la mh mi mj mk bi translated">随着时间的推移公开某种类型的值</li><li id="0acd" class="mc md iq kh b ki ml kl mm ko mn ks mo kw mp la mh mi mj mk bi translated">可以完成，也可以因出错而失败</li></ul><p id="5252" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">主题</strong></p><ul class=""><li id="d68d" class="mc md iq kh b ki kj kl km ko me ks mf kw mg la mh mi mj mk bi translated">一个可变的发布者(能够在初始化后发送新值)</li><li id="dba5" class="mc md iq kh b ki ml kl mm ko mn ks mo kw mp la mh mi mj mk bi translated">有两种主题类型可用:</li><li id="f5be" class="mc md iq kh b ki ml kl mm ko mn ks mo kw mp la mh mi mj mk bi translated"><code class="fe ly lz ma mb b">CurrentValueSubject</code> -顾名思义，这个主题类型可以访问当前值</li><li id="7d44" class="mc md iq kh b ki ml kl mm ko mn ks mo kw mp la mh mi mj mk bi translated"><code class="fe ly lz ma mb b">PassthroughSubject</code> -顾名思义，这个subject传递当前值，也就是说它不能访问当前值</li></ul><p id="525e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">订户</strong></p><ul class=""><li id="4e62" class="mc md iq kh b ki kj kl km ko me ks mf kw mg la mh mi mj mk bi translated">从发布者/主题接收值</li></ul><p id="c133" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">操作员</strong></p><ul class=""><li id="6a43" class="mc md iq kh b ki kj kl km ko me ks mf kw mg la mh mi mj mk bi translated">修改从发布者/主题发送的值</li></ul><p id="4c3d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下图中，我们可以看到这些组件的作用。我们将一步一步地看这个例子，下面会更详细地介绍。</p><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi mq"><img src="../Images/5f5486b0fad7447c3ac8139cc8abfd46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*N6U5FoBSJ4Vie2NL.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">组合备忘单</figcaption></figure><p id="7aeb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">想象一下，我们有一个向用户展示文章的应用程序。文章可以收到喜欢。作为一项要求，我们希望能够改变每篇文章的点赞数，并通知订阅者这一变化。</p><h1 id="7249" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">出版商和主题</h1><p id="f14e" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">作为第一步，我们使用Combine的发布者和主题的组合来实现我们的目标。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">合并出版商和主题</figcaption></figure><p id="a536" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们一步一步地检查这段代码。</p><ol class=""><li id="5eac" class="mc md iq kh b ki kj kl km ko me ks mf kw mg la ni mi mj mk bi translated">我们将名为<code class="fe ly lz ma mb b">likesCountSubject</code>的<strong class="kh ir">主题</strong>定义为<code class="fe ly lz ma mb b">CurrentValueSubject&lt;Int, Never&gt;</code>类型的私有变量。我们将使用该主题向订户发送新值。因为主题是一个泛型类型，我们指定它是<code class="fe ly lz ma mb b">Output</code>和<code class="fe ly lz ma mb b">Failure</code>类型。输出类型定义了主题将发送什么类型的值，在我们的例子中是<code class="fe ly lz ma mb b">Int</code>值。因为在我们的例子中in不能失败，所以我们使用<code class="fe ly lz ma mb b">Never</code>作为错误类型。</li><li id="9594" class="mc md iq kh b ki ml kl mm ko mn ks mo kw mp la ni mi mj mk bi translated">我们用一个<code class="fe ly lz ma mb b">likesCount</code>参数定义init方法，给<code class="fe ly lz ma mb b">likesCountSubject</code>一个初始值。</li><li id="a370" class="mc md iq kh b ki ml kl mm ko mn ks mo kw mp la ni mi mj mk bi translated">我们定义了一个类型为<code class="fe ly lz ma mb b">AnyPublisher&lt;Int, Never&gt;</code>的名为<code class="fe ly lz ma mb b">likesCountPublisher</code>的<strong class="kh ir">发布者</strong>。它的<code class="fe ly lz ma mb b">Output</code>和<code class="fe ly lz ma mb b">Failure</code>类型与我们的主题相同。订阅者可以使用发布者。我们不一定需要出版商，我们可以简单地将我们的主题公开。但是由于我们不希望article struct之外的任何人发送新值，所以我们使用了一个publisher，只让订阅部分对外部世界可用。</li><li id="4a6c" class="mc md iq kh b ki ml kl mm ko mn ks mo kw mp la ni mi mj mk bi translated">我们定义了增加点赞数的<code class="fe ly lz ma mb b">addLike</code>方法。在这里，我们使用我们的主题来发送新的值。为了能够添加一个赞，我们访问subject的<code class="fe ly lz ma mb b">value</code>属性来获得赞的当前值。这就是我们在这种情况下使用<code class="fe ly lz ma mb b">CurrentValueSubject</code>而不是<code class="fe ly lz ma mb b">PassthroughSubject</code>的原因，因为只有<code class="fe ly lz ma mb b">CurrentValueSubject</code>可以访问它的当前值。</li></ol><h1 id="6e0b" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">订阅者</h1><p id="14e4" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">现在，我们可以如下使用<code class="fe ly lz ma mb b">Article</code>结构:</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">合并用户</figcaption></figure><p id="6746" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们一步一步地检查这段代码。</p><ol class=""><li id="6ee3" class="mc md iq kh b ki kj kl km ko me ks mf kw mg la ni mi mj mk bi translated">我们创建了一篇文章，并给它一个初始赞数5。</li><li id="6df6" class="mc md iq kh b ki ml kl mm ko mn ks mo kw mp la ni mi mj mk bi translated">我们创建了一个名为<code class="fe ly lz ma mb b">likesCountSubscriber</code>的<strong class="kh ir">用户</strong>，他对赞数的任何更新都感兴趣。订阅者使用发布者及其<code class="fe ly lz ma mb b">sink(receiveValue:)</code>方法来订阅更新。现在，每次赞数改变时，调用打印新值的闭包。</li><li id="cf21" class="mc md iq kh b ki ml kl mm ko mn ks mo kw mp la ni mi mj mk bi translated">我们通过调用两次<code class="fe ly lz ma mb b">addLike()</code>来增加赞数。</li></ol><p id="304e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，代码会产生以下输出:</p><pre class="mr ms mt mu gt nj mb nk nl aw nm bi"><span id="5d32" class="nn lc iq mb b gy no np l nq nr">5<br/>6<br/>7</span></pre><p id="e464" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们创建一个新的订阅者时，发布者总是返回一个符合<code class="fe ly lz ma mb b">Cancellable</code>协议的对象。因此，如果我们想取消接收新值，我们可以在订阅服务器上调用<code class="fe ly lz ma mb b">cancel()</code>方法。</p><p id="b159" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们在增加的赞之间添加取消呼叫，</p><pre class="mr ms mt mu gt nj mb nk nl aw nm bi"><span id="969f" class="nn lc iq mb b gy no np l nq nr">article.addLike()<br/>likesCountSubscriber.cancel()<br/>article.addLike()</span></pre><p id="386e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不会打印最后一个值。</p><h1 id="d7f3" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">经营者</h1><p id="0c22" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">现在，我们可以在执行打印闭包之前使用操作符来修改接收到的值。例如，如果我们想打印一些更具描述性的东西，我们可以使用<code class="fe ly lz ma mb b">map</code>操作符将<code class="fe ly lz ma mb b">Int</code>值映射到<code class="fe ly lz ma mb b">String</code>值:</p><pre class="mr ms mt mu gt nj mb nk nl aw nm bi"><span id="6618" class="nn lc iq mb b gy no np l nq nr">let likesCountSubscriber = article.likesCountPublisher<br/>    .map { "\($0) likes" }<br/>    .sink { print($0) }</span></pre><p id="2919" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们的输出看起来像这样:</p><pre class="mr ms mt mu gt nj mb nk nl aw nm bi"><span id="9c59" class="nn lc iq mb b gy no np l nq nr">5 likes<br/>6 likes<br/>7 likes</span></pre><p id="d81e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Combine提供了许多有用的操作符，我们可以链接任意多的操作符。</p><p id="9340" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了更深入地研究操作符，让我们看下面的例子。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="5039" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个例子没有做什么有用的事情，但是它有望给操作符和它们的组合一个很好的理解。</p><p id="4e9d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在查看下面的解决方案之前，尝试自己找出每个操作符产生的输出。</p><ol class=""><li id="7179" class="mc md iq kh b ki kj kl km ko me ks mf kw mg la ni mi mj mk bi translated">产生<code class="fe ly lz ma mb b">[1, 3] [6, 10] [4, 19, 8, 6]</code>，因为我们用<code class="fe ly lz ma mb b">merge</code>操作符将来自<code class="fe ly lz ma mb b">publisher1</code>的元素和来自<code class="fe ly lz ma mb b">publisher2</code>的元素组合在一起</li><li id="7afc" class="mc md iq kh b ki ml kl mm ko mn ks mo kw mp la ni mi mj mk bi translated">产生<code class="fe ly lz ma mb b">1, 3, 6, 10, 4, 19, 8</code>，因为我们用<code class="fe ly lz ma mb b">flatMap</code>将<code class="fe ly lz ma mb b">Int</code>数组展平成一系列<code class="fe ly lz ma mb b">Int</code>值</li><li id="7591" class="mc md iq kh b ki ml kl mm ko mn ks mo kw mp la ni mi mj mk bi translated">产生<code class="fe ly lz ma mb b">6, 10, 4, 8</code>，因为我们用<code class="fe ly lz ma mb b">filter</code>运算符过滤掉了所有不均匀的值</li><li id="dd8a" class="mc md iq kh b ki ml kl mm ko mn ks mo kw mp la ni mi mj mk bi translated">产生<code class="fe ly lz ma mb b">10, 4, 8</code>，因为我们用<code class="fe ly lz ma mb b">dropFirst</code>操作符删除了第一个元素</li><li id="cf36" class="mc md iq kh b ki ml kl mm ko mn ks mo kw mp la ni mi mj mk bi translated">产生<code class="fe ly lz ma mb b">[10, 4, 8]</code>，因为我们用<code class="fe ly lz ma mb b">collect</code>操作符收集所有接收到的项目，并将它们作为数组返回</li><li id="7dac" class="mc md iq kh b ki ml kl mm ko mn ks mo kw mp la ni mi mj mk bi translated">产生<code class="fe ly lz ma mb b">[4, 8, 10]</code>，因为我们用<code class="fe ly lz ma mb b">map</code>操作符将数组映射到一个排序的数组中</li></ol><p id="5697" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，还有更多运营商有待发现。运营商的完整列表可在官方发布文档中获得。</p><h1 id="7c40" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">联合收割机中的内存管理</h1><p id="58e0" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">订户的生命周期与保留对象的生命周期相关联。每当释放该对象时，都会自动在subscriber属性上调用cancel方法，它也将被释放。</p><p id="6c09" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，就像Swift中的“传统”内存管理一样，您需要注意不要创建保留周期，例如在<code class="fe ly lz ma mb b">sink</code>闭包中使用强selfs时。</p><h1 id="a33d" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">进一步阅读</h1><p id="4edf" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">既然您已经了解了Combine的基础知识，我的下一步建议是研究属性包装器。在这种情况下，特别有趣的是将变量转换成组合发布器的<a class="ae ns" href="https://developer.apple.com/documentation/combine/published" rel="noopener ugc nofollow" target="_blank"> @Publish属性包装器</a>。</p></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><p id="63a9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">【https://tanaschita.com】原载于<a class="ae ns" href="https://tanaschita.com/posts/20201115-quick-guide-on-combine-essentials/" rel="noopener ugc nofollow" target="_blank"><em class="oa"/></a><em class="oa">。</em></p></div></div>    
</body>
</html>