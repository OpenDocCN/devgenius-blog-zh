<html>
<head>
<title>Save over 25% memory using struct realignment in a memory hungry cache.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在内存密集型高速缓存中使用结构重新调整，节省 25%以上的内存。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/save-over-25-memory-using-struct-realignment-in-a-memory-hungry-cache-a24fc20106bb?source=collection_archive---------7-----------------------#2022-12-03">https://blog.devgenius.io/save-over-25-memory-using-struct-realignment-in-a-memory-hungry-cache-a24fc20106bb?source=collection_archive---------7-----------------------#2022-12-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="df37" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用正确的结构重排和指针来节省内存。</p><h1 id="b2a7" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">介绍</h1><p id="5342" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">在这篇文章中，我们将研究如何优化结构，以便在应用程序运行时使用更少的内存来存储数据(struct)。此外，我们将测量软件结构优化后内存使用量的变化。对齐是实现这一目标的一种方式。</p><p id="1dea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对齐减少了读写内存区域所需的指令数量，从而加快了内存访问速度。如果没有对齐，处理器可能必须执行两条或多条指令来访问分布在多个机器字长的地址上的数据。</p><h2 id="a975" class="lm kk in bd kl ln lo dn kp lp lq dp kt jv lr ls kx jz lt lu lb kd lv lw lf lx bi translated">Golang 内存中的对齐和填充</h2><p id="8c7f" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">Golang 确实有填料。32 位系统架构的字长分别为 4 字节，64 位系统架构的字长分别为 8 字节。“字长”描述了计算机的 CPU 一次可以处理多少位。字长通常是数据总线大小、指令大小和地址大小的倍数。</p><p id="100c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">截至目前，Go 使用的是“所需对齐”。所需的对齐等于结构中最大字段所需的内存大小。如果该结构包含 int32 字段,“所需对齐”将是 4 个字节。如果同时有 int32 和 int64，则需要 8 个字节。</p><h2 id="61f1" class="lm kk in bd kl ln lo dn kp lp lq dp kt jv lr ls kx jz lt lu lb kd lv lw lf lx bi translated">Golang 中的默认大小</h2><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="5d1f" class="mh kk in md b be mi mj l mk ml">Data Type        Size<br/>bool            1 byte<br/>int16           2 bytes<br/>int32           4 bytes<br/>int64           8 bytes<br/>int             8 bytes<br/>string          16 bytes<br/>float32         4 bytes<br/>float64         8 bytes<br/>uint32          4 bytes<br/>uint64          8 bytes<br/></span></pre><p id="efe1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">案例一——字长差异:</strong>我们用一个例子来了解一下字长的差异。一个结构的最大内存大小为 int32，而另一个结构的最大内存大小为 int64。</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="d25b" class="mh kk in md b be mi mj l mk ml">package main<br/><br/>import (<br/> "fmt"<br/> "unsafe"<br/>)<br/><br/>type Cache1 struct {<br/> a int32 <br/> b bool<br/> c int32<br/>}<br/><br/>type Cache2 struct {<br/> a int32<br/> b bool<br/> c int64<br/>}<br/><br/>var student1 [1]Cache1<br/>var student2 [1]Cache2<br/><br/>func main() {<br/> fmt.Printf("struct: %d bytes\n", (unsafe.Sizeof(student1)))<br/> fmt.Printf("struct: %d bytes\n", (unsafe.Sizeof(student2)))<br/>}</span></pre><pre class="mm mc md me bn mf mg bi"><span id="edcb" class="mh kk in md b be mi mj l mk ml">struct: 12 bytes<br/>struct: 16 bytes</span></pre><p id="1667" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">关于 Student1:它有一个缓存 1。Cache1 的字长为 4 字节，因为 int32 是结构 Cache1 中最大的内存大小。“a”完全占据了第一个字的 4 个字节。“b”从第二个字开始占用 1 个字节，剩下 3 个字节。“c”需要 4 个字节，但是因为第二个字还有 3 个字节。所以，“c”不能和第二个单词中的“b”放在一起。所以它需要 3 个大小为 4 的单词。大小是 4*3=12 字节。<br/>学生 2 也可以得到类似的解释。</p><p id="4b61" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">案例 2—结构对齐差异:</strong>让我们尝试使用更大的数据类型。在下面的例子中，两个结构的字长都是 8 字节，但由于对齐的原因，它们的大小还是不同。大小是 8 个字节，而不是 16 个字节，因为字符串本身是由 16 个字节组成的，有两个 8 字节的对齐。</p><h2 id="e84e" class="lm kk in bd kl ln lo dn kp lp lq dp kt jv lr ls kx jz lt lu lb kd lv lw lf lx bi translated">例子</h2><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="57da" class="mh kk in md b be mi mj l mk ml">package main<br/><br/>import (<br/> "fmt"<br/> "unsafe"<br/>)<br/><br/>type Cache1 struct {<br/>                    // Data Size  -&gt;  Total Size till now<br/> Age        int64   //    08      -&gt;  8  (1st word)<br/> IsOrphan   bool    //    01      -&gt;  16 (2nd word)<br/> Name       string  //    16      -&gt;  32 (3rd &amp; 4th word)<br/> weight     int32   //    04      -&gt;  40 (5th word)<br/> height     int16   //    02      -&gt;  40 (5th word)<br/> IDcardLen  float64 //    08      -&gt;  48 (6th word)<br/> IDcardWid  float32 //    04      -&gt;  56 (7th word)<br/> class      int     //    08      -&gt;  64 (8th word)<br/> rollNumber int8    //    01      -&gt;  72 (9th word)<br/>}<br/><br/>type Cache2 struct {<br/> Name       string  //    16      -&gt;  16 (1st &amp; 2nd word)<br/> Age        int64   //    08      -&gt;  24 (3rd word)<br/> class      int     //    08      -&gt;  32 (4th word)<br/> IDcardLen  float64 //    08      -&gt;  40 (5th word)<br/> IDcardWid  float32 //    04      -&gt;  48 (6th word)<br/> weight     int32   //    04      -&gt;  48 (6th word)<br/> height     int16   //    02      -&gt;  56 (7th word)<br/> rollNumber int8    //    01      -&gt;  56 (7th word)<br/> IsOrphan   bool    //    01      -&gt;  56 (7th word)<br/>}<br/><br/>var student1 [10000]Cache1<br/>var student2 [10000]Cache2<br/><br/>func main() {<br/> fmt.Printf("Size of array %d ; struct: %d bytes\n", unsafe.Sizeof(student1), (unsafe.Sizeof(student1)))<br/> fmt.Printf("Size of array %d ; struct: %d bytes\n", unsafe.Sizeof(student2), (unsafe.Sizeof(student2)))<br/> fmt.Printf("Space Optimisation by %f %% \n", float64(unsafe.Sizeof(student1)-unsafe.Sizeof(student2))*100/float64(unsafe.Sizeof(student1)))<br/>}</span></pre><p id="d226" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">输出:</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="afbe" class="mh kk in md b be mi mj l mk ml">Size of array 720000 ; struct: 720000 bytes<br/>Size of array 560000 ; struct: 560000 bytes<br/>Space Optimisation by 22.222222 % </span></pre><p id="6569" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">原因:</p><figure class="ly lz ma mb gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mn"><img src="../Images/366a74ada88ce5aa1bb2681f36d11606.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RYTYKi7tTUDZo-OdvO0oMg.jpeg"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">图 1:解释空间占用和填充</figcaption></figure><p id="9b22" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">经验法则:</strong></p><p id="6032" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了最小化填充字节的数量，我们必须从最高分配到最低分配来布置字段。一个例外是空结构。空的大小为零。首先保留空结构，然后对于其余的，从最高分配到最低分配。</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="afb5" class="mh kk in md b be mi mj l mk ml">package main<br/><br/>import (<br/> "fmt"<br/> "unsafe"<br/>)<br/><br/>type emptyOne struct {<br/> a struct{}<br/>}<br/><br/>type A struct {<br/> b struct{}<br/> a int64<br/> c int64<br/>}<br/><br/>type B struct {<br/> a int64<br/> b int64<br/> c struct{}<br/>}<br/><br/>func main() {<br/> fmt.Printf("Size of emptyOne is %d byte(s) \n", unsafe.Sizeof(emptyOne{}))<br/> fmt.Printf("Size of A is %d in byte(s) \n", unsafe.Sizeof(A{}))<br/> fmt.Printf("Size of B is %d in byte(s) \n", unsafe.Sizeof(B{}))<br/>}</span></pre><p id="4ae4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">输出:</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="4918" class="mh kk in md b be mi mj l mk ml">Size of emptyOne is 0 byte(s) <br/>Size of A is 16 in byte(s) <br/>Size of B is 24 in byte(s)</span></pre><p id="42b2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">A 的大小是 24 字节，而 B 的大小只有 16 字节。</p><p id="f6cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">案例 3——大数组使用指针避免堆栈溢出:</strong>我们可以使用指针对大切片进行操作<strong class="jm io">。</strong>我们有一个大小为 100，000，000*8 字节的一维数组。</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="ab92" class="mh kk in md b be mi mj l mk ml">package main<br/><br/>import (<br/> "fmt"<br/> "unsafe"<br/>)<br/><br/><br/>func main() {<br/> var student1 [1e8]int<br/> fmt.Println("PRINT--DIRECTLY")<br/> fmt.Println(student1)<br/>}</span></pre><p id="68b7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">输出:</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="feeb" class="mh kk in md b be mi mj l mk ml">runtime: goroutine stack exceeds 1000000000-byte limit<br/>runtime: sp=0x14000070f70 stack=[0x14000070000, 0x14000071000]<br/>fatal error: stack overflow</span></pre><p id="cfbb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">程序崩溃。问题是为什么会发生这种情况，如何解决？<br/>每个 go 例程都有预定义的堆栈大小限制。对于上述情况(64 位 arch)，它是 1，000，000，000 字节(1GB)。我们有大小为 0.1*8 GB 的可变学生 1。现在 main goroutine 调用 Println 函数，我们通过值传递，这意味着 Println 函数的形参在堆栈中复制了 student1。所以现在 go 例程需要 2*0.1*8=1.6GB &gt; 1GB。</p><p id="4f94" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这可以通过使用指针将数据传递给 Println 函数来解决。指针基本上是指这个数组的起始点的内存地址。所以它只有 8 字节，而不是 800MB。使用指针可以节省复制大数据的时间，还可以防止堆栈溢出。</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="e1b2" class="mh kk in md b be mi mj l mk ml">package main<br/><br/>import (<br/> "fmt"<br/> "unsafe"<br/>)<br/><br/>func main() {<br/> var student1 [1e8]int<br/> fmt.Println("PRINT--WITH--POINTERS")<br/> fmt.Println(&amp;student1)<br/> fmt.Printf("struct array: %d bytes\n", unsafe.Sizeof(student1))<br/> fmt.Printf("struct array's pointer: %d bytes\n", unsafe.Sizeof(&amp;student1))<br/>}</span></pre><p id="bdaf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">输出</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="a6d5" class="mh kk in md b be mi mj l mk ml">PRINT--WITH--POINTERS<br/>&amp;[0.....0] //10^8 times 0 are there <br/>struct array: 800000000 bytes<br/>struct array's pointer: 8 bytes</span></pre><h1 id="79b3" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">简而言之…</h1><p id="3a4d" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">在结构中仔细选择数据结构。使用正确的结构对齐方式来节省内存。首先保留空结构，然后对于其余的，从最高分配到最低分配。如果您希望将数据传递到其他地方，但希望那里发生的更改对您在这里的代码可见，或者如果您的数据太大而无法复制，请使用指针。</p><p id="1147" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你从中学到了什么，请鼓掌，如果你想提出一些建议或下一个话题，也请在评论中告诉我。</p></div></div>    
</body>
</html>