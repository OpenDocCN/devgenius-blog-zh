<html>
<head>
<title>What HTTP Request Body Looks Like before Middleware in NodeJS &amp; Express</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NodeJS &amp; Express 中中间件出现之前的 HTTP 请求体是什么样子的</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/what-http-request-body-looks-like-before-middleware-in-nodejs-express-117ab9c63701?source=collection_archive---------6-----------------------#2022-06-04">https://blog.devgenius.io/what-http-request-body-looks-like-before-middleware-in-nodejs-express-117ab9c63701?source=collection_archive---------6-----------------------#2022-06-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="3bd9" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">查看我在<a class="ae kc" href="https://yumingchang1991.medium.com/technical-article-structure-on-medium-954850e1ef4d" rel="noopener">我的技术文章</a>中的所有其他帖子</h2></div><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi kd"><img src="../Images/52d4e1172c21dc21214cf29b8200c981.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0YsYZU8H_cQpGoBI"/></div></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@shanerounce?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Shane Rounce </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="8887" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">背景</h1><p id="9b41" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">如果你没有注意到，我在台湾参加一个编码训练营，目标是作为一名 JavaScript 开发人员赚钱。</p><p id="43e4" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">我的一个同学这周在我们的不和谐频道上发了一个问题。我不知道为什么，但我是如此着迷。</p><blockquote class="mm mn mo"><p id="d38f" class="ll lm mp ln b lo mh jo lq lr mi jr lt mq mj lw lx mr mk ma mb ms ml me mf mg ig bi translated">她问，如何检查请求体的原始数据格式？它看起来像什么？</p></blockquote><p id="df92" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">嗯，这很有趣。</p><p id="17c8" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">在 Node.js 和 Express framework 的帮助下，很多繁琐的任务可能在我们不知不觉中就被自动化了。我想这可能是找出答案的好时机，所以接受挑战！</p></div><div class="ab cl mt mu hr mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ig ih ii ij ik"><h1 id="4dda" class="kt ku in bd kv kw na ky kz la nb lc ld jt nc ju lf jw nd jx lh jz ne ka lj lk bi translated">行动</h1><p id="b839" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">我对自己说，我不可能是人类历史上第一个问这个问题的人。答案一定在某个地方。</p><h2 id="b4db" class="nf ku in bd kv ng nh dn kz ni nj dp ld lu nk nl lf ly nm nn lh mc no np lj nq bi translated">步骤 1 —开放研究</h2><p id="41a3" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">我从开放搜索开始，寻找一些可能有助于缩小范围的关键词。我非常幸运地找到了这篇关于如何在 NodeJS 和 Express 中工作的文章。它提到了流和包的概念。关于流有<a class="ae kc" href="https://nodejs.dev/learn/nodejs-streams" rel="noopener ugc nofollow" target="_blank">官方 Node JS 文档</a>。</p><p id="53fc" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">在继续之前，一定要让自己熟悉流和包的概念。</p><h2 id="5de0" class="nf ku in bd kv ng nh dn kz ni nj dp ld lu nk nl lf ly nm nn lh mc no np lj nq bi translated">步骤 2 —验证信息</h2><p id="6daa" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">现在我知道 HTTP 请求是基于从客户端到服务器的流和包的概念。</p><p id="72f2" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">下一个问题是，<strong class="ln io">如何检索刚刚到达我们服务器的原始数据</strong>，但是还没有被处理？</p><p id="98bf" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">我的第一个想法是在服务器的第一个位置添加一个定制的中间件。我的意思是这个定制的中间件应该是第一个接收请求的。(如果您不熟悉中间件，请查看我的文章<a class="ae kc" href="https://yumingchang1991.medium.com/express-middleware-explained-in-one-minute-671af8d5a3b9" rel="noopener"> <em class="mp">一分钟解释快速中间件</em> </a></p><p id="741c" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">事实证明，我们可以将事件监听器添加到节点 JS 中的请求对象，以将数据包组织成完整的数据。我们只需要监听<code class="fe nr ns nt nu b">req.on('data', handler(dataChunk))</code>来获取到达服务器的单个数据包。然后，监听<code class="fe nr ns nt nu b">req.on('end', handler)</code>，这样我们就可以知道所有的数据包何时全部到达。</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk translated">接收数据块的自定义中间件</figcaption></figure><h2 id="c868" class="nf ku in bd kv ng nh dn kz ni nj dp ld lu nk nl lf ly nm nn lh mc no np lj nq bi translated">步骤 3 —使用 POST 请求进行测试</h2><p id="40f6" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">太好了，我们已经准备好中间件了。我们只需要为我们的服务器创建一个 POST 请求，这样我们就可以在被<code class="fe nr ns nt nu b">bodyParser</code>处理之前查看请求体的原始数据格式</p><p id="bc6e" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">发送 POST 请求的方法是使用一个接收数据的表单。这样，用户输入将通过请求体传输。我制作了一个表单，用邮件和密码发送 POST 请求，以测试我们的定制中间件。</p><h1 id="26b2" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">结果</h1><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi nx"><img src="../Images/f13395a39e7acf4467edb96b0962587b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nyDd02O0v5RxGrmPOO1dvg.png"/></div></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk translated">我们的定制中间件记录数据块和 rawBodyContent 的结果</figcaption></figure><ul class=""><li id="d56c" class="ny nz in ln b lo mh lr mi lu oa ly ob mc oc mg od oe of og bi translated">Buffer 是存储二进制数据的节点 JS 中的一种数据类型。看到二进制很可怕，但这是一个好迹象，表明我们正在接近底层</li><li id="a6e0" class="ny nz in ln b lo oh lr oi lu oj ly ok mc ol mg od oe of og bi translated">当所有数据块到达服务器时，这些数据将从分离的二进制数据包转换成完整的数据，如上面的<code class="fe nr ns nt nu b">rawBodyContent</code>所示</li></ul><p id="2fff" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">因此，原始正文格式的编码与查询字符串相同。难怪我们需要使用<code class="fe nr ns nt nu b">bodyParser()</code>或<code class="fe nr ns nt nu b">express.urlencoded()</code>作为中间件来生成可以在 Node JS 中轻松访问的内容。</p></div><div class="ab cl mt mu hr mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ig ih ii ij ik"><h1 id="76a1" class="kt ku in bd kv kw na ky kz la nb lc ld jt nc ju lf jw nd jx lh jz ne ka lj lk bi translated">挑战不止于此</h1><p id="0b64" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">好吧，好吧，我承认。我们发现了数据格式是什么，但似乎我们关注的是森林中的一棵树。那么我们的森林是什么？这里的大局是什么？</p><h2 id="b355" class="nf ku in bd kv ng nh dn kz ni nj dp ld lu nk nl lf ly nm nn lh mc no np lj nq bi translated">我们再深入一点，好吗？</h2><p id="9122" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">我在挑战结束时发现了这一点。原来的问题可以简单地通过了解 HTTP 请求头中的内容来回答。在我们的例子中，让我们关注内容类型。</p><p id="3761" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">指定了内容类型的请求标头意味着此请求带有正文。主体中的数据是按照指定的内容类型的格式构造的。</p><p id="9391" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">在互联网通信的世界里，我们需要使用请求体来携带数据的时候往往是我们需要提交表单的时候。此类请求的内容类型是<code class="fe nr ns nt nu b">application/x-www-form-urlencoded</code></p><p id="7551" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">你看到答案了吗？说明正文中的数据是<code class="fe nr ns nt nu b">urlencoded</code>。答对了。</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi om"><img src="../Images/754816da3cc0e7be4e2c44ea4562253e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ctXKMlcVB_YzCHjWl89aag.png"/></div></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk translated">这是我提交表单时开发工具中的网络选项卡。注意内容类型</figcaption></figure></div><div class="ab cl mt mu hr mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ig ih ii ij ik"><h1 id="aa9f" class="kt ku in bd kv kw na ky kz la nb lc ld jt nc ju lf jw nd jx lh jz ne ka lj lk bi translated">奖励—从开发人员工具复制完整请求</h1><p id="c4bf" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">当我们导航到开发工具-&gt;网络选项卡时，我们可以右键单击一个文件并将完整的请求复制到文本中。</p><p id="a7dd" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">下面是一个复制为 cURL (cmd)的例子。你会在底部找到携带编码信息的<code class="fe nr ns nt nu b">data-raw</code>。</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi on"><img src="../Images/55de0463f1caed2fe06b341d8a60c37b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cJJo3MBMWchVa7GfGUJ8PA.png"/></div></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk translated">cURL (cmd)中的完整请求</figcaption></figure></div><div class="ab cl mt mu hr mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ig ih ii ij ik"><h1 id="647b" class="kt ku in bd kv kw na ky kz la nb lc ld jt nc ju lf jw nd jx lh jz ne ka lj lk bi translated">参考</h1><ul class=""><li id="222e" class="ny nz in ln b lo lp lr ls lu oo ly op mc oq mg od oe of og bi translated"><strong class="ln io">文章</strong>:<a class="ae kc" href="https://medium.com/@adamzerner/how-bodyparser-works-247897a93b90" rel="noopener"><em class="mp">body parser 如何工作？</em> </a>作者亚当·泽纳，2015 年 7 月 2 日</li><li id="bb19" class="ny nz in ln b lo oh lr oi lu oj ly ok mc ol mg od oe of og bi translated"><strong class="ln io">条</strong> : <a class="ae kc" href="https://nodejs.dev/learn/nodejs-streams" rel="noopener ugc nofollow" target="_blank">条<em class="mp">条</em>条</a>条通过节点 JS</li><li id="3675" class="ny nz in ln b lo oh lr oi lu oj ly ok mc ol mg od oe of og bi translated"><strong class="ln io">条</strong> : <a class="ae kc" href="https://blittle.github.io/chrome-dev-tools/network/request-data.html" rel="noopener ugc nofollow" target="_blank"> <em class="mp">复制请求数据</em> </a>由 Bret 小</li></ul></div></div>    
</body>
</html>