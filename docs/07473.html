<html>
<head>
<title>Adding properties to custom GTK4 widgets in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Rust 中向自定义 GTK4 小部件添加属性</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/adding-properties-to-custom-gtk4-widgets-in-rust-67d4bbed8b08?source=collection_archive---------5-----------------------#2022-03-28">https://blog.devgenius.io/adding-properties-to-custom-gtk4-widgets-in-rust-67d4bbed8b08?source=collection_archive---------5-----------------------#2022-03-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/de55f39efb0d624c7db5f1f9c33de1c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Q-A_JnT5xfXvcOo4"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@miracleday?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">埃琳娜·莫日维洛</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="d7ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到目前为止，我们在 GTK4 Rust <a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/initial-setup-for-a-gtk4-app-with-libadwaita-in-rust-using-vscode-b6f8c127a75e">教程</a>上取得了不错的进展。我们学习了<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/using-template-files-in-rust-for-a-gtk4-libadwaita-ui-8322694cbc3c">模板文件</a>、<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/bundling-templates-into-resources-in-rust-for-the-gtk4-ui-eb387a7918bf">资源</a>和<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/refactoring-gtk4-ui-templates-in-rust-68cbef1a1778">属性绑定</a>。但是上一次当我们将代码重构为定制的小部件时，我们发现在我们的<code class="fe lb lc ld le b">main-window.ui</code>模板文件中有轻微的表现力损失。我们必须将漂亮的声明性 XML 属性绑定转移到代码中。在本文中，我们将通过向小部件添加自定义属性来解决这个问题。</p><p id="ae71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">和往常一样，你可以在<a class="ae kc" href="https://github.com/raduzaharia-medium/gtk-rss-reader-properties" rel="noopener ugc nofollow" target="_blank"> github </a>找到最终代码。当然，我总是建议遵循教程并尝试编写自己的代码，但如果您想快速启动您的项目，请随意使用可用的存储库。我们走吧。</p><h2 id="75a1" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">什么是小部件属性？</h2><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ly"><img src="../Images/6c5931ad7d1e0fe309afc15c38add0e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NoAFgi9WRE1hqitT"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@edhoradic?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Edho Pratama </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="c570" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">GTK 微件属性是允许微件和另一个数据源之间进行数据绑定的基本工具。另一个数据源可以是项目变量、来自另一个小部件的函数或属性的结果。每个小部件都有一个属性数组，以及每个属性的 getters 和 setters。属性也可能有默认值、取值范围或可用值等等。</p><p id="2562" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数据绑定是一种自动机制，它从一个地方(例如一个小部件)读取一个变化的值，并将其分配给另一个地方(另一个小部件)。它可以是单向的，意味着值只从源小部件传递到目的地，也可以是双向的，意味着每次值在任何小部件中改变时，它也会传递到另一个小部件。</p><p id="0e96" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种机制为用户界面提供了一种 MVC 模式。您将 UI 工程的各个方面在模型、视图和控制器之间进行了分离，从而使您的代码更加清晰，职责更加明确。由于您不再手动地在代码中将值从一个小部件复制到下一个小部件，而是“绑定”它以使这个过程自动化，这不仅分离了关注点，还简化了您的代码。如果能在 UI XML 定义中实现，那就更好了。</p><h2 id="1762" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">声明小部件属性</h2><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi md"><img src="../Images/634b7dd25109f60f57dc20ed522903c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lk0zxWdnlE8GAz0qTAQLsQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">小部件中的典型属性声明</figcaption></figure><p id="a955" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是定义已经足够了。让我们看看如何为我们的<code class="fe lb lc ld le b">FeedList</code>小部件声明属性。属性声明是在小部件的内部部分完成的，所以我们转到<code class="fe lb lc ld le b">template.rs</code>来编辑<code class="fe lb lc ld le b">FeedListTemplate</code>。就像描绘一本好小说一样，故事发生在<code class="fe lb lc ld le b">ObjectImpl</code>:</p><pre class="lz ma mb mc gt me le mf mg aw mh bi"><span id="6d4c" class="lf lg iq le b gy mi mj l mk ml">impl ObjectImpl for FeedListTemplate {<br/>  fn properties() -&gt; &amp;'static [ParamSpec] {<br/>    static PROPERTIES: Lazy&lt;Vec&lt;ParamSpec&gt;&gt; = Lazy::new(|| {<br/>      vec![ParamSpecBoolean::new(<br/>        "show-end-title-buttons",<br/>        "show-end-title-buttons",<br/>        "Shows the title buttons in the header bar",<br/>        true,<br/>        ParamFlags::READWRITE)]<br/>    });</span><span id="3925" class="lf lg iq le b gy mm mj l mk ml">    PROPERTIES.as_ref()<br/>  }<br/>  <br/>  fn set_property(&amp;self, _obj: &amp;Self::Type, _id: usize, value: &amp;Value, pspec: &amp;ParamSpec) {<br/>    match pspec.name() {<br/>      "show-end-title-buttons" =&gt; {<br/>        let bool_value = value.get().expect("The value needs to be of type `bool`.");<br/>        <br/>        self.header_bar.set_show_end_title_buttons(bool_value);<br/>      }<br/>      _ =&gt; unimplemented!(),<br/>    }<br/>  }</span><span id="d535" class="lf lg iq le b gy mm mj l mk ml">  fn property(&amp;self, _obj: &amp;Self::Type, _id: usize, pspec: &amp;ParamSpec) -&gt; Value {<br/>    match pspec.name() {<br/>      "show-end-title-buttons" =&gt;<br/>        self.header_bar.shows_end_title_buttons().to_value(),<br/>      _ =&gt; unimplemented!(),<br/>    }<br/>  }</span><span id="1994" class="lf lg iq le b gy mm mj l mk ml">  fn constructed(&amp;self, obj: &amp;Self::Type) {<br/>    self.parent_constructed(obj);<br/>  }<br/>}</span></pre><p id="3be9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在这里看到三个新东西:定义属性数组的<code class="fe lb lc ld le b">properties</code>函数、<code class="fe lb lc ld le b">set_property</code> setter 和属性 getter。属性数组包含我们希望在小部件中包含的所有属性的描述。我们用<code class="fe lb lc ld le b">ParamSpecBoolean</code>或<code class="fe lb lc ld le b">ParamSpecInt</code>或任何我们想要的类型来声明它们。根据这种类型，一些声明将具有范围定义或可用值等等。</p><p id="b71b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个定义都以字符串形式的属性名开始，在我们的例子中是<code class="fe lb lc ld le b">show-end-title-buttons</code>，一个我通常设置为名称的昵称、一个描述、一个默认值和一些标志:在我们的例子中是<code class="fe lb lc ld le b">ParamFlags::READWRITE</code>。这些标志为只读模式或其他机制配置属性。</p><p id="aed5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我不会展示<code class="fe lb lc ld le b">ArticleList</code>的代码，因为它看起来完全一样，但我要提醒这一点:<code class="fe lb lc ld le b">ArticleList</code>有两个属性需要绑定:<code class="fe lb lc ld le b">show-end-title-buttons</code>和<code class="fe lb lc ld le b">visible</code>来自标题中的 back 按钮。两者都是布尔值，就像这里一样。getter 和 setter 将属性链接到实际值。在我们的例子中，我们想要的是让<code class="fe lb lc ld le b">Leaflet</code>小部件控制内部的<code class="fe lb lc ld le b">HeaderBar</code>小部件，所以我们简单地给它一个<code class="fe lb lc ld le b">show-end-title-buttons</code>值。</p><p id="f173" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基本上，我们想要能够将<code class="fe lb lc ld le b">Leaflet.folded</code>绑定到<code class="fe lb lc ld le b">FeedList.HeaderBar.show-end-title-buttons</code>的东西，但是因为我们不能从<code class="fe lb lc ld le b">Leaflet</code>进入<code class="fe lb lc ld le b">HeaderBar</code>，所以我们将它绑定到我们的新房产<code class="fe lb lc ld le b">FeedList.show-end-title-buttons instead</code>。这个名字可能是别的什么，但我选择复制它，因为它有同样的含义。我们的<code class="fe lb lc ld le b">FeedList</code>小部件将显示结束标题按钮。没人在乎<code class="fe lb lc ld le b">FeedList</code>内部是否有<code class="fe lb lc ld le b">HeaderBar</code>而实际上它本身也有<code class="fe lb lc ld le b">show-end-title-buttons</code>。这是我们不需要公布的内部知识。</p><h2 id="49cd" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated"><code class="fe lb lc ld le b">Restoring the binding in main-window.ui</code></h2><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi md"><img src="../Images/38dbffb4030dca3e018a4eb236652ab9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A_WUxulHHcB8ByfQCEzrDQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">更新的主窗口. ui</figcaption></figure><p id="9415" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上次我们担心会丢失 XML UI 声明中的优秀属性绑定语法，但现在既然我们为自定义小部件定义了属性，我们就可以重新得到它:</p><pre class="lz ma mb mc gt me le mf mg aw mh bi"><span id="3960" class="lf lg iq le b gy mi mj l mk ml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;interface&gt;<br/>  &lt;template class="MainWindow" parent="AdwApplicationWindow"<br/>    &lt;property name="width-request"&gt;800&lt;/property&gt;<br/>    &lt;property name="height-request"&gt;500&lt;/property&gt;<br/>    &lt;property name="title" translatable="yes"&gt;<br/>      My GTK4 RSS Reader<br/>    &lt;/property&gt;</span><span id="52eb" class="lf lg iq le b gy mm mj l mk ml">    &lt;child&gt;<br/>      &lt;object class="AdwLeaflet" id="leaflet"&gt;<br/>        &lt;property name="can-swipe-back"&gt;True&lt;/property&gt;<br/>        <br/>        &lt;child&gt;<br/>          &lt;object class="FeedList" id="feed_list"&gt;<br/>            &lt;binding name="show-end-title-buttons"&gt;<br/>              &lt;lookup name="folded"&gt;leaflet&lt;/lookup&gt;<br/>            &lt;/binding&gt;<br/>          &lt;/object&gt;<br/>        &lt;/child&gt;</span><span id="7817" class="lf lg iq le b gy mm mj l mk ml">        &lt;child&gt;<br/>          &lt;object class="AdwLeafletPage"&gt;<br/>            &lt;property name="navigatable"&gt;False&lt;/property&gt;<br/>            &lt;property name="child"&gt;<br/>              &lt;object class="GtkSeparator"/&gt;<br/>            &lt;/property&gt;<br/>          &lt;/object&gt;<br/>        &lt;/child&gt;<br/>  <br/>        &lt;child&gt;<br/>          &lt;object class="ArticleList" id="article_list"&gt;<br/>            &lt;binding name="show-start-title-buttons"&gt;<br/>              &lt;lookup name="folded"&gt;leaflet&lt;/lookup&gt;<br/>            &lt;/binding&gt;<br/>            &lt;binding name="show-back-button"&gt;<br/>              &lt;lookup name="folded"&gt;leaflet&lt;/lookup&gt;<br/>            &lt;/binding&gt;<br/>          &lt;/object&gt;<br/>        &lt;/child&gt;<br/>      &lt;/object&gt;<br/>    &lt;/child&gt;<br/>  &lt;/template&gt;<br/>&lt;/interface&gt;</span></pre><p id="0ec4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那里。XML 绑定再次有效。只是这一次，我们将绑定直接添加到我们的定制小部件中。我们以前见过这个语法，所以我不再详述了。</p><p id="6cf0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，现在属性绑定在模板 UI 文件中再次完成，我们可以将它们从<code class="fe lb lc ld le b">MainWindowTemplate</code>实现中移除，将<code class="fe lb lc ld le b">ObjectImpl</code>返回到其默认变体:</p><pre class="lz ma mb mc gt me le mf mg aw mh bi"><span id="ffbc" class="lf lg iq le b gy mi mj l mk ml">impl ObjectImpl for MainWindowTemplate {<br/>  fn constructed(&amp;self, obj: &amp;Self::Type) {<br/>    self.parent_constructed(obj);<br/>  }<br/>}</span></pre></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><p id="36a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这都是关于财产的。这与科幻小说无关，但它确实需要一些关于小部件的数据绑定和数据封装的知识。我希望你在整个教程中玩得开心，也希望下次能见到你，届时我们将讨论<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/using-models-to-bind-data-to-gtk4-custom-widgets-in-rust-379dd9d1bf4d">数据绑定</a>和<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/event-handling-for-gtk4-widgets-in-rust-d3c3f89b092f">点击事件</a>。</p><p id="3b89" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不要介意使用评论部分获取您需要的额外知识。它帮助我将本文构建成一个更好的工具，供任何人使用。下次见！</p></div></div>    
</body>
</html>