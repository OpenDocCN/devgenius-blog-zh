<html>
<head>
<title>Export zip of multiple CSV files in Django</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Django导出多个CSV文件的zip文件</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/export-zip-of-multiple-csv-files-in-django-50d853143db3?source=collection_archive---------1-----------------------#2021-11-08">https://blog.devgenius.io/export-zip-of-multiple-csv-files-in-django-50d853143db3?source=collection_archive---------1-----------------------#2021-11-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/baabdade5f2f9e4cf44739798a74c01c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y1XmGDGIrhDdlovwZ8daWQ.jpeg"/></div></div></figure><div class=""/><p id="e6df" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">导出文件是一种经常发生的功能，用户可以在其中取出他们的数据。</p><p id="6841" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">今天，我将尝试将数据导出到多个CSV文件中的zip文件中。</p><p id="59d9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">(来自<a class="ae kt" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3037639" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae kt" href="https://pixabay.com/users/tayebmezahdia-4194100/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3037639" rel="noopener ugc nofollow" target="_blank"> Tayeb MEZAHDIA </a>拍摄的图像)</p><h1 id="9dfc" class="ku kv iy bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">应用模型</h1><p id="0d1f" class="pw-post-body-paragraph jv jw iy jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">假设我们有最简单的图书馆系统，一本书可以属于许多图书馆。</p><p id="61eb" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">像这样的模型:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="788a" class="mg kv iy mc b gy mh mi l mj mk"><strong class="mc iz">class</strong> Library(models.Model):<br/>    name = models.TextField()<br/><br/><br/><strong class="mc iz">class</strong> Book(models.Model):<br/>    title = models.TextField()<br/>    libraries = models.ManyToManyField(<br/>        null=True,<br/>        blank=True,<br/>        to='Library',<br/>        related_name='books'<br/>    )</span></pre><p id="2487" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们在这里尝试做的是导出一个zip文件，其中包括许多CSV文件，其中一个库的每个演示文稿都显示该库中的图书列表。</p><h1 id="67bd" class="ku kv iy bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">制作视图以获取导出zip文件</h1><p id="fc5f" class="pw-post-body-paragraph jv jw iy jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">像往常一样，为了创建一个用于下载的API，我们编写了一个只允许GET方法的视图。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="5198" class="mg kv iy mc b gy mh mi l mj mk"><strong class="mc iz">import</strong> csv<br/><strong class="mc iz">import</strong> io<br/><strong class="mc iz">import</strong> zipfile<br/><strong class="mc iz">from</strong> wsgiref.util <strong class="mc iz">import</strong> FileWrapper<br/><strong class="mc iz">from</strong> django.http <strong class="mc iz">import</strong> StreamingHttpResponse<br/><strong class="mc iz">from</strong> rest_framework.views <strong class="mc iz">import</strong> APIView<br/><br/><strong class="mc iz">class</strong> ExportZip(APIView):<br/>    <strong class="mc iz">def</strong> get(self):<br/>        csv_datas = self.build_multiple_csv_files()<br/>        <br/>        temp_file = io.BytesIO()<br/>        <strong class="mc iz">with</strong> zipfile.ZipFile(<br/>             temp_file, "w", zipfile.ZIP_DEFLATED<br/>        ) <strong class="mc iz">as</strong> temp_file_opened:<br/>            # add csv files each library<br/>            <strong class="mc iz">for</strong> data <strong class="mc iz">in</strong> csv_datas:<br/>                data["csv_file"].seek(0)<br/>                temp_file_opened.writestr(<br/>                    f"library_{data['library_name']}.csv",<br/>                    data["csv_file"].getvalue()<br/>                )<br/><br/>        temp_file.seek(0)<br/>        <br/>        # put them to streaming content response <br/>        # within zip content_type<br/>        response = StreamingHttpResponse(<br/>            FileWrapper(temp_file),<br/>            content_type="application/zip",<br/>        )<br/><br/>        response['Content-Disposition'] = 'attachment;filename=Libraries.zip'<br/>        <strong class="mc iz">return</strong> response<br/><br/>    <strong class="mc iz">def</strong> build_multiple_csv_files(self):<br/>        csv_files = []<br/>        <strong class="mc iz">return</strong> csv_files</span></pre><p id="06f8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上图中，我们使用了<a class="ae kt" href="https://docs.python.org/3/library/zipfile.html" rel="noopener ugc nofollow" target="_blank"> <em class="ml"> zipfile模块</em> </a>，这是一个用于数据压缩和归档的Python标准库。</p><p id="0c22" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://docs.python.org/3/library/zipfile.html#zipfile.ZipFile" rel="noopener ugc nofollow" target="_blank">T9】zip file。ZipFile</a>允许我们打开一个ZIPFIle文件进行写入，其中<strong class="jx iz"> <em class="ml">文件</em> </strong>可以是一个<a class="ae kt" href="https://docs.python.org/3/library/io.html#module-io" rel="noopener ugc nofollow" target="_blank"> <em class="ml">文件样的对象</em> </a>，具体在这种情况下是<strong class="jx iz"> temp_file </strong>是一个二进制I/O as<strong class="jx iz">temp _ FIle _ open</strong>。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="18bc" class="mg kv iy mc b gy mh mi l mj mk"><strong class="mc iz">class</strong> zipfile.ZipFile(<br/>    file, mode='r', compression=ZIP_STORED, <br/>    allowZip64=True, compresslevel=None, <br/>    *, strict_timestamps=True<br/>)</span></pre><p id="c849" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们在上下文管理器中通过“<strong class="jx iz"> with </strong>”语句打开它，然后可以确保我们的zip在with语句的套件完成后关闭——即使发生了异常。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="73c6" class="mg kv iy mc b gy mh mi l mj mk">temp_file = io.BytesIO()<br/><strong class="mc iz">with</strong> zipfile.ZipFile(<br/>    temp_file, "w", zipfile.ZIP_DEFLATED<br/>) <strong class="mc iz">as</strong> temp_file_opened:<br/>    # write to zip file</span></pre><p id="0b0e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上下文管理器中，我们通过方法<a class="ae kt" href="https://docs.python.org/3/library/zipfile.html#zipfile.ZipFile.writestr" rel="noopener ugc nofollow" target="_blank">writer str</a>将CSV内容文件写入zip<strong class="jx iz">temp _ file _ open、</strong>。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="b85f" class="mg kv iy mc b gy mh mi l mj mk">ZipFile.writestr(<br/>    zinfo_or_arcname, data, <br/>    compress_type=None, compresslevel=None<br/>)</span></pre><p id="abb5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里我们放入两个需要的参数是<em class="ml"> zinfo_or_arcname </em>和<em class="ml">数据</em></p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="8e35" class="mg kv iy mc b gy mh mi l mj mk">temp_file_opened.writestr(<br/>    f"File_library_{file['lib']}.csv",<br/>    file["csv_file"].getvalue()<br/>)</span></pre><p id="8661" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">写完多个CSV文件后，我们通过<a class="ae kt" href="https://docs.python.org/3/library/io.html#io.IOBase.seek" rel="noopener ugc nofollow" target="_blank"> <em class="ml">查找</em> </a>来查找zip文件，然后使用<a class="ae kt" href="http://filewrapper/" rel="noopener ugc nofollow" target="_blank"> <em class="ml">文件包装器</em> </a>将类似文件的对象转换为迭代器，然后将它们返回到<em class="ml"> StreamingHttpResponse </em>。</p><p id="16b8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此时，我们可以下载一个空的“Libraries.zip”文件。</p><h1 id="f49c" class="ku kv iy bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">构建CSV文件列表</h1><p id="05be" class="pw-post-body-paragraph jv jw iy jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">如你所见，我们准备了一个名为“<strong class="jx iz"><em class="ml">build _ multiple _ CSV _ files</em></strong>”的方法，它返回上面的空列表。在这一步，我们将把代码放到这个函数中来构建一个CSV文件列表。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="c682" class="mg kv iy mc b gy mh mi l mj mk"><strong class="mc iz">class</strong> ExportLibraries(APIView):<br/>    header_data = {<br/>        "name": "Name",<br/>        "library": "Library Name"<br/>    }<br/>    <br/>    <strong class="mc iz">def</strong> get(self):<br/>        ...<br/>        <strong class="mc iz">return</strong> response<br/><br/>    <strong class="mc iz">def</strong> build_multiple_csv_files(self, libraries, books):<br/>        csv_files = []<br/>        <br/>        <strong class="mc iz">for</strong> library <strong class="mc iz">in</strong> libraries.iterator():<br/>            mem_file = io.StringIO()<br/>            writer = csv.DictWriter(<br/>                mem_file, fieldnames=self.header_data.keys()<br/>            )<br/>            writer.writerow(self.header_data)<br/>            <br/>            books_in_library = books.filter(libraries__in=[library.id])<br/>            <strong class="mc iz">for</strong> book <strong class="mc iz">in</strong> books_in_library:<br/>                book_row = self.build_book_row(book, library)<br/>                writer.writerow(book_row)<br/>            <br/>            mem_file.seek(0)<br/>            <br/>            csv_files.append({<br/>                "library_name": library.name,<br/>                "csv_file": mem_file<br/>            })<br/>            <br/>        <strong class="mc iz">return</strong> csv_files<br/>    <br/>    <strong class="mc iz">def</strong> build_book_row(self, book, library):<br/>        row = self.header_data.copy()<br/>        <br/>        row["name"] = book.name<br/>        row["library"] = library.name<br/>        <br/>        <strong class="mc iz">return</strong> row</span></pre><p id="5c10" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">看看上面的代码，我们访问所有的库，然后通过init从<em class="ml"> csv编写器构建每个CSV文件。dict writer</em>er()使用header_data的键，<em class="ml"> header_data </em>可能是这样的:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="3072" class="mg kv iy mc b gy mh mi l mj mk">header_data = {<br/>    "name": "Book Name",<br/>    "library": "Library Name"<br/>}</span></pre><p id="f11f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">之后，将标题添加到writer中，然后使用一个循环通过call方法将所有书籍逐行添加到writer中。write_row()</p><p id="b059" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">完成写入后，在库的名称中添加一个对象，以帮助设置CSV文件名和CSV文件内容。</p><p id="727f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以通过将该视图添加到URLs文件来进行导出。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="1aaf" class="mg kv iy mc b gy mh mi l mj mk">urlpatterns = [<br/>    path(<br/>        'export_libraries/',<br/>        ExportLibraries.as_view(),<br/>        name="export_libraries"<br/>    )<br/>]</span></pre><h1 id="26f9" class="ku kv iy bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">单元测试</h1><p id="1e71" class="pw-post-body-paragraph jv jw iy jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">下一个问题是，如何测试结果？</p><p id="b7b2" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这一部分应该在处理逻辑之前完成，就像通过TDD(测试驱动开发)一样，但是我想先展示一下逻辑是如何工作的，这样可能会更容易理解哪些应该被测试。</p><p id="b02f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我计划为此进行两次单元测试:</p><p id="0a2e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">–<strong class="jx iz">一个API: </strong>调用API应该导出一个zip文件</p><p id="748b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">–<strong class="jx iz">一个用于CSV文件和内容:</strong>视图上调用<em class="ml">build _ multiple _ CSV _ files</em>应该会返回每个库数据的列表。在这里，还可以逐行检查每个CSV文件上的内容。</p><p id="73f5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">注意:</strong>请注意，我下面的UTs只是对它看起来像什么的一个提示，你应该根据你的特点来做。</p><h2 id="97af" class="mg kv iy bd kw mm mn dn la mo mp dp le kg mq mr li kk ms mt lm ko mu mv lq mw bi translated">单元测试:调用API导出zip文件</h2><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="9001" class="mg kv iy mc b gy mh mi l mj mk"><strong class="mc iz">def</strong> test_export_libraries(self):<br/>    response = self.client.get(reverse('export_libraries'))<br/>    <strong class="mc iz">assert</strong> response.status_code <strong class="mc iz">is</strong> status.HTTP_200_OK<br/>    <strong class="mc iz">assert</strong> response.get('Content-Disposition') == "Libraries.zip"</span></pre><p id="5794" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个UT非常简单，我们只需要检查以确保API调用200和导出的文件是名称中的zip文件。</p><h2 id="33e5" class="mg kv iy bd kw mm mn dn la mo mp dp le kg mq mr li kk ms mt lm ko mu mv lq mw bi translated">单元测试:调用视图函数获取CSV文件</h2><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="d57d" class="mg kv iy mc b gy mh mi l mj mk"><strong class="mc iz">def</strong> test_build_csvs_files(self):<br/>    # assume we mock 2 libraries<br/>    # library_1, library_2<br/>    # queryset is books and libraries<br/>    view = ExportRecipesCost()<br/>    view.request = drf_request_for_context(self.user)<br/>    csv_files = view.build_multiple_csv_files(<br/>        libraries, books<br/>    )<br/>    # check number of csv files<br/>    <strong class="mc iz">assert</strong> len(csv_files) == 2<br/>    # first csv file<br/>    <strong class="mc iz">assert</strong> csv_files[0]["library_name"] == library_1.name<br/>    <strong class="mc iz">assert</strong> csv_files[0]["csv_file"]<br/>    # go check csv content in first file here<br/><br/>    # second csv file<br/>    <strong class="mc iz">assert</strong> csv_files[0]["library_name"] == library_2.name<br/>    <strong class="mc iz">assert</strong> csv_files[0]["csv_file"]<br/>    # go check csv content in first file here</span></pre><p id="90b9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我在代码上留下了一些注释，让我们知道有一些测试数据，我们计划做的是在模拟DRF请求中调用视图函数(由util函数<em class="ml"> drf_request_for_context创建)。</em></p><p id="29ba" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">除了返回的CSV文件的数量之外，我们还可以根据文件头检查CSV内容文件。</p><h1 id="1ef5" class="ku kv iy bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">提高性能</h1><p id="150e" class="pw-post-body-paragraph jv jw iy jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">在我的解决方案中，我们使用了两个循环，一个用于图书馆，嵌套在其中的是每个图书馆的图书。更好的解决方案是准备所有的图书数据，不管它属于哪个图书馆，在图书馆的循环中使用这组数据。这可能会降低性能。</p><p id="14ff" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另一个可以改进的地方是出口流程。我们可以将逻辑导出作为后台任务(例如celery任务)运行，而不是将响应数据发送到<em class="ml"> StreamingHttpResponse </em>以从浏览器下载。完成后，将zip文件上传到s3，然后给用户一个下载的方法(URL或连接到第三方)。这个流程可以让用户体验更好，并避免数据太多时出现超时错误。</p><p id="d649" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们尝试使用提示，如果你有更好的解决方案，请与我分享。</p></div><div class="ab cl mx my hr mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ig ih ii ij ik"><p id="d0bd" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">总之，今天，我们来看看在Django应用程序中导出多个CSV文件中的zip文件的方法(我称之为使用Django查询)。</p><p id="d59d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有一个用熊猫从Django应用程序导出数据的迷人方法，我希望将来有机会和你分享。</p></div><div class="ab cl mx my hr mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ig ih ii ij ik"><p id="381a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://beautyoncode.com/export-zip-of-multiple-csv-files-in-django/" rel="noopener ugc nofollow" target="_blank">本内容的原始版本</a>属于我的个人博客【beautyoncode.com<a class="ae kt" href="https://beautyoncode.com/" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="295f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">感谢您的阅读。</p><p id="3582" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">BeautyOnCode。</p></div></div>    
</body>
</html>