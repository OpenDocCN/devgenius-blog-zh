<html>
<head>
<title>Top useful SQL queries for PostgreSQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PostgreSQL 最有用的 SQL 查询</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/top-useful-sql-queries-for-postgresql-35ff3355d265?source=collection_archive---------3-----------------------#2022-10-30">https://blog.devgenius.io/top-useful-sql-queries-for-postgresql-35ff3355d265?source=collection_archive---------3-----------------------#2022-10-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="672e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有很多关于使用 PostgreSQL 及其优点的文章，但是并不总是清楚如何监控数据库的状态和影响其最佳工作的指标。在本文中，我们将详细研究 SQL 查询，这将帮助您跟踪这些指标，并对普通用户有用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e45c648422246bc4e41e46fab80e983c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KyKVBnKIqC-6ebQHf_5QdA.png"/></div></div></figure><h1 id="2b6b" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">为什么需要监控 PostgreSQL 的状态？</h1><p id="316f" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">数据库监控与监控应用程序一样重要。有必要对流程进行比系统级更详细的监控。为此，您可以跟踪以下指标:</p><ol class=""><li id="728f" class="lx ly in jm b jn jo jr js jv lz jz ma kd mb kh mc md me mf bi translated">数据库缓存的效率如何？</li><li id="2363" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">您的数据库中的表有多大？</li><li id="769c" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">你的索引被使用了吗？</li><li id="a9b1" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">等等。</li></ol><h1 id="4d42" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">监控数据库及其元素的大小</h1><h2 id="06f5" class="ml kv in bd kw mm mn dn la mo mp dp le jv mq mr li jz ms mt lm kd mu mv lq mw bi translated">1.表空间的大小</h2><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="702d" class="ml kv in my b gy nc nd l ne nf">SELECT spcname, pg_size_pretty(pg_tablespace_size(spcname)) <br/>FROM pg_tablespace<br/>WHERE spcname&lt;&gt;'pg_global';</span></pre><p id="234f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">运行查询后，您将收到关于在数据库中创建的所有表空间的大小的信息。pg_tablespace_size 函数提供了有关表空间大小的信息(以字节为单位),因此我们也使用 pg_size_pretty 函数使其可读。pg_global 空间被排除在外，因为它用于共享系统目录。</p><h2 id="4a3e" class="ml kv in bd kw mm mn dn la mo mp dp le jv mq mr li jz ms mt lm kd mu mv lq mw bi translated">2.数据库的大小</h2><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="d676" class="ml kv in my b gy nc nd l ne nf">SELECT pg_database.datname,<br/>       pg_size_pretty(pg_database_size(pg_database.datname)) AS size<br/>FROM pg_database<br/>ORDER BY pg_database_size(pg_database.datname) DESC;</span></pre><p id="22fe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">运行查询后，您将收到在 PostgreSQL 实例中创建的每个数据库的大小信息。</p><h2 id="5011" class="ml kv in bd kw mm mn dn la mo mp dp le jv mq mr li jz ms mt lm kd mu mv lq mw bi translated">3.数据库中模式的大小</h2><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="a6cd" class="ml kv in my b gy nc nd l ne nf">SELECT A.schemaname,<br/>       pg_size_pretty (SUM(pg_relation_size(C.oid))) as table, <br/>       pg_size_pretty (SUM(pg_total_relation_size(C.oid)-pg_relation_size(C.oid))) as index, <br/>       pg_size_pretty (SUM(pg_total_relation_size(C.oid))) as table_index,<br/>       SUM(n_live_tup)<br/>FROM pg_class C<br/>LEFT JOIN pg_namespace N ON (N.oid = C .relnamespace)<br/>INNER JOIN pg_stat_user_tables A ON C.relname = A.relname<br/>WHERE nspname NOT IN ('pg_catalog', 'information_schema')<br/>AND C .relkind &lt;&gt; 'i'<br/>AND nspname !~ '^pg_toast'<br/>GROUP BY A.schemaname;</span></pre><p id="9c02" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">运行查询后，您将收到有关数据库中每个模式的详细信息:所有表的总大小、所有索引的总大小、模式的总大小以及所有模式表中的总行数。</p><h2 id="70dc" class="ml kv in bd kw mm mn dn la mo mp dp le jv mq mr li jz ms mt lm kd mu mv lq mw bi translated">4.桌子的大小</h2><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="7885" class="ml kv in my b gy nc nd l ne nf">SELECT schemaname,<br/>       C.relname AS "relation",<br/>       pg_size_pretty (pg_relation_size(C.oid)) as table,<br/>       pg_size_pretty (pg_total_relation_size (C.oid)-pg_relation_size(C.oid)) as index,<br/>       pg_size_pretty (pg_total_relation_size (C.oid)) as table_index,<br/>       n_live_tup<br/>FROM pg_class C<br/>LEFT JOIN pg_namespace N ON (N.oid = C .relnamespace)<br/>LEFT JOIN pg_stat_user_tables A ON C.relname = A.relname<br/>WHERE nspname NOT IN ('pg_catalog', 'information_schema')<br/>AND C.relkind &lt;&gt; 'i'<br/>AND nspname !~ '^pg_toast'<br/>ORDER BY pg_total_relation_size (C.oid) DESC</span></pre><p id="1661" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">运行查询后，您将收到关于每个表的详细信息，指示其模式、无索引的大小、索引的大小、表和索引的总大小，以及表中的行数。</p><h1 id="231e" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><code class="fe ng nh ni my b">deadlocks</code>的控制</h1><p id="6f35" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">如果不止一个用户使用您的数据库，那么总是存在查询死锁的风险，并且会出现一个队列，其中有大量的查询将被挂起。通常，当使用相同的表处理多个查询时，会出现这种情况。它们会阻止对方完成查询，并阻止其他查询开始。你可以在<a class="ae nj" href="https://www.postgresql.org/docs/current/explicit-locking.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>中读到更多相关内容。我们将考虑找到锁并移除它们的方法。</p><h2 id="02fd" class="ml kv in bd kw mm mn dn la mo mp dp le jv mq mr li jz ms mt lm kd mu mv lq mw bi translated">1.死锁的监控</h2><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="7a33" class="ml kv in my b gy nc nd l ne nf">SELECT COALESCE(blockingl.relation::regclass::text, blockingl.locktype) AS locked_item,<br/>       now() - blockeda.query_start                                     AS waiting_duration,<br/>       blockeda.pid                                                     AS blocked_pid,<br/>       blockeda.query                                                   AS blocked_query,<br/>       blockedl.mode                                                    AS blocked_mode,<br/>       blockinga.pid                                                    AS blocking_pid,<br/>       blockinga.query                                                  AS blocking_query,<br/>       blockingl.mode                                                   AS blocking_mode<br/>FROM pg_locks blockedl<br/>JOIN pg_stat_activity blockeda ON blockedl.pid = blockeda.pid<br/>JOIN pg_locks blockingl ON (blockingl.transactionid = blockedl.transactionid OR<br/>                            blockingl.relation = blockedl.relation AND<br/>                            blockingl.locktype = blockedl.locktype) AND blockedl.pid &lt;&gt; blockingl.pid<br/>JOIN pg_stat_activity blockinga ON blockingl.pid = blockinga.pid AND blockinga.datid = blockeda.datid<br/>WHERE NOT blockedl.granted AND blockinga.datname = current_database();</span></pre><p id="fa3c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该查询显示被阻止的查询的所有信息，以及谁阻止了它们的信息。</p><h2 id="7f45" class="ml kv in bd kw mm mn dn la mo mp dp le jv mq mr li jz ms mt lm kd mu mv lq mw bi translated">2.死锁的消除</h2><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="0a7c" class="ml kv in my b gy nc nd l ne nf">SELECT pg_cancel_backend(PID_ID);<br/>OR<br/>SELECT pg_terminate_backend(PID_ID);</span></pre><p id="e5dc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">PID_ID 是阻止其他查询的查询的 ID。大多数情况下，取消一个阻塞查询就足以消除死锁并启动整个累积队列。pg_cancel_backend 和 pg_terminate_backend 的区别在于，pg_cancel_backend 取消查询，pg_terminate_backend 结束会话并关闭数据库连接。pg_cancel_backend 命令更加温和，在大多数情况下对您来说已经足够了。如果没有，使用 pg_terminate_backend。</p><h1 id="772f" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">数据库最佳性能的指标</h1><h2 id="46ec" class="ml kv in bd kw mm mn dn la mo mp dp le jv mq mr li jz ms mt lm kd mu mv lq mw bi translated">1.缓存命中率</h2><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="85fc" class="ml kv in my b gy nc nd l ne nf">SELECT sum(heap_blks_read) as heap_read,<br/>       sum(heap_blks_hit)  as heap_hit,<br/>       sum(heap_blks_hit) / (sum(heap_blks_hit) + sum(heap_blks_read)) as ratio<br/>FROM <br/>  pg_statio_user_tables;</span></pre><p id="689c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">缓存系数是对读取效率的一种衡量，通过缓存读取占磁盘和缓存读取总数的比例来衡量。除了使用数据存储时，理想的缓存比率是 99%或更高，这意味着至少 99%的读取是从缓存执行的，不超过 1%是从磁盘执行的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/23183d822c1710835c021b8d052f0d99.png" data-original-src="https://miro.medium.com/v2/resize:fit:250/format:webp/1*v066iXAR4OmzyR7gKlzoWQ.png"/></div></figure><h2 id="3866" class="ml kv in bd kw mm mn dn la mo mp dp le jv mq mr li jz ms mt lm kd mu mv lq mw bi translated">2.索引的使用</h2><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="93c3" class="ml kv in my b gy nc nd l ne nf">SELECT relname,   <br/>       100 * idx_scan / (seq_scan + idx_scan) percent_of_times_index_used,   <br/>       n_live_tup rows_in_table <br/>FROM pg_stat_user_tables <br/>WHERE seq_scan + idx_scan &gt; 0 <br/>ORDER BY n_live_tup DESC;</span></pre><p id="f9dd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">向数据库中添加索引对查询性能有很大的影响。索引对于大型表尤其重要。该查询显示了表中的行数，以及与没有索引的读取相比，索引使用时间所占的百分比。添加索引的理想候选对象是大于 10，000 行且索引使用率为零或很低的表。</p><h2 id="0742" class="ml kv in bd kw mm mn dn la mo mp dp le jv mq mr li jz ms mt lm kd mu mv lq mw bi translated">3.索引缓存命中率</h2><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="c20a" class="ml kv in my b gy nc nd l ne nf">SELECT sum(idx_blks_read) as idx_read,<br/>       sum(idx_blks_hit)  as idx_hit,<br/>       (sum(idx_blks_hit) - sum(idx_blks_read)) / sum(idx_blks_hit) as ratio<br/>FROM pg_statio_user_indexes;</span></pre><p id="074c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个系数类似于通常的缓存系数，但是是根据索引使用数据计算的。</p><h2 id="7b9c" class="ml kv in bd kw mm mn dn la mo mp dp le jv mq mr li jz ms mt lm kd mu mv lq mw bi translated">4.未使用的索引</h2><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="0209" class="ml kv in my b gy nc nd l ne nf">SELECT schemaname, relname, indexrelname<br/>FROM pg_stat_all_indexes<br/>WHERE idx_scan = 0 and schemaname &lt;&gt; 'pg_toast' and schemaname &lt;&gt; 'pg_catalog'</span></pre><p id="2598" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该查询查找已创建但未在 SQL 查询中使用的索引。</p><h2 id="f52d" class="ml kv in bd kw mm mn dn la mo mp dp le jv mq mr li jz ms mt lm kd mu mv lq mw bi translated">5.数据库膨胀</h2><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="5c56" class="ml kv in my b gy nc nd l ne nf">SELECT<br/>  current_database(), schemaname, tablename, /*reltuples::bigint, relpages::bigint, otta,*/<br/>  ROUND((CASE WHEN otta=0 THEN 0.0 ELSE sml.relpages::float/otta END)::numeric,1) AS tbloat,<br/>  CASE WHEN relpages &lt; otta THEN 0 ELSE bs*(sml.relpages-otta)::BIGINT END AS wastedbytes,<br/>  iname, /*ituples::bigint, ipages::bigint, iotta,*/<br/>  ROUND((CASE WHEN iotta=0 OR ipages=0 THEN 0.0 ELSE ipages::float/iotta END)::numeric,1) AS ibloat,<br/>  CASE WHEN ipages &lt; iotta THEN 0 ELSE bs*(ipages-iotta) END AS wastedibytes<br/>FROM (<br/>  SELECT<br/>    schemaname, tablename, cc.reltuples, cc.relpages, bs,<br/>    CEIL((cc.reltuples*((datahdr+ma-<br/>      (CASE WHEN datahdr%ma=0 THEN ma ELSE datahdr%ma END))+nullhdr2+4))/(bs-20::float)) AS otta,<br/>    COALESCE(c2.relname,'?') AS iname, COALESCE(c2.reltuples,0) AS ituples, COALESCE(c2.relpages,0) AS ipages,<br/>    COALESCE(CEIL((c2.reltuples*(datahdr-12))/(bs-20::float)),0) AS iotta /* very rough approximation, assumes all cols */<br/>  FROM (<br/>    SELECT<br/>      ma,bs,schemaname,tablename,<br/>      (datawidth+(hdr+ma-(case when hdr%ma=0 THEN ma ELSE hdr%ma END)))::numeric AS datahdr,<br/>      (maxfracsum*(nullhdr+ma-(case when nullhdr%ma=0 THEN ma ELSE nullhdr%ma END))) AS nullhdr2<br/>    FROM (<br/>      SELECT<br/>        schemaname, tablename, hdr, ma, bs,<br/>        SUM((1-null_frac)*avg_width) AS datawidth,<br/>        MAX(null_frac) AS maxfracsum,<br/>        hdr+(<br/>          SELECT 1+count(*)/8<br/>          FROM pg_stats s2<br/>          WHERE null_frac&lt;&gt;0 AND s2.schemaname = s.schemaname AND s2.tablename = s.tablename<br/>        ) AS nullhdr<br/>      FROM pg_stats s, (<br/>        SELECT<br/>          (SELECT current_setting('block_size')::numeric) AS bs,<br/>          CASE WHEN substring(v,12,3) IN ('8.0','8.1','8.2') THEN 27 ELSE 23 END AS hdr,<br/>          CASE WHEN v ~ 'mingw32' THEN 8 ELSE 4 END AS ma<br/>        FROM (SELECT version() AS v) AS foo<br/>      ) AS constants<br/>      GROUP BY 1,2,3,4,5<br/>    ) AS foo<br/>  ) AS rs<br/>  JOIN pg_class cc ON cc.relname = rs.tablename<br/>  JOIN pg_namespace nn ON cc.relnamespace = nn.oid AND nn.nspname = rs.schemaname AND nn.nspname &lt;&gt; 'information_schema'<br/>  LEFT JOIN pg_index i ON indrelid = cc.oid<br/>  LEFT JOIN pg_class c2 ON c2.oid = i.indexrelid<br/>) AS sml<br/>ORDER BY wastedbytes DESC;</span></pre><p id="7b78" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">数据库膨胀是表或索引已经使用的磁盘空间，可供数据库重用，但尚未释放。当表或索引被更新时，就会发生膨胀。如果您有一个加载了大量删除操作的数据库，膨胀会在数据库中留下大量未使用的空间，如果不将其删除，会影响性能。如果您有任何严重的膨胀问题，表的 wastedbytes 和索引的 wasted bytes 指标将会显示出来。为了对付膨胀，有一个真空的命令。</p><h2 id="366d" class="ml kv in bd kw mm mn dn la mo mp dp le jv mq mr li jz ms mt lm kd mu mv lq mw bi translated">6.检查真空启动</h2><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="9b49" class="ml kv in my b gy nc nd l ne nf">SELECT relname, <br/>       last_vacuum, <br/>       last_autovacuum <br/>FROM pg_stat_user_tables;</span></pre><p id="e36b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用 VACUUM 命令可以减少膨胀，但是 PostgreSQL 也支持 AUTOVACUUM。你可以在这里阅读它的设置<a class="ae nj" href="https://www.postgresql.org/docs/13/runtime-config-autovacuum.html" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="4eca" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">还有几个可能对你有用的问题</h1><h2 id="d4b3" class="ml kv in bd kw mm mn dn la mo mp dp le jv mq mr li jz ms mt lm kd mu mv lq mw bi translated">1.显示打开的连接数</h2><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="6e4b" class="ml kv in my b gy nc nd l ne nf">SELECT COUNT(*) as connections,<br/>       backend_type<br/>FROM pg_stat_activity<br/>where state = 'active' OR state = 'idle'<br/>GROUP BY backend_type<br/>ORDER BY connections DESC;</span></pre><p id="6bf4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">显示 PostgreSQL 实例中所有数据库的打开连接。如果在一个 PostgreSQL 中有多个数据库，则将 datname = 'Your Database '添加到 WHERE 条件中。</p><h2 id="892d" class="ml kv in bd kw mm mn dn la mo mp dp le jv mq mr li jz ms mt lm kd mu mv lq mw bi translated">2.显示正在运行的查询</h2><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="e9cd" class="ml kv in my b gy nc nd l ne nf">SELECT pid, age(clock_timestamp(), query_start), usename, query, state<br/>FROM pg_stat_activity<br/>WHERE state != 'idle' AND query NOT ILIKE '%pg_stat_activity%'<br/>ORDER BY query_start desc;</span></pre><p id="995d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">显示正在运行的查询及其持续时间。</p><h1 id="2265" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结论</h1><p id="0bb3" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">当我的数据库中出现任何问题时，以上所有的问题都是我从网上收集的。如果还有其他对 PostgreSQL 用户有用的问题，我会很高兴你能在评论中分享。希望文章能帮到你，节省你的时间。</p></div></div>    
</body>
</html>