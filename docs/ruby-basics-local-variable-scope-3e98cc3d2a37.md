# Ruby 基础:局部变量范围

> 原文：<https://blog.devgenius.io/ruby-basics-local-variable-scope-3e98cc3d2a37?source=collection_archive---------18----------------------->

![](img/ddd0a9e4095ad2bc3b4a5b26c9294be6.png)

照片由[克莱门特·H](https://unsplash.com/@clemhlrdt?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

今天我想谈谈 Ruby 中的局部变量作用域。这是一个经常让初学者(包括我自己)感到困惑的话题，但是对于能够编写和调试 Ruby 程序来说却是至关重要的。首先，我们来定义一下什么是局部变量作用域。变量的作用域定义了该变量在程序中的可访问位置。所以当我们谈论局部变量作用域时，我们谈论的是定义局部变量在程序中何处可访问的规则。其他变量，如全局变量、类变量和实例变量，有不同的作用域规则。在这篇文章中，我只会提到变量；要知道这意味着局部变量。但是说够了，让我们看一些例子！你认为这段代码会输出什么？

```
Output: **undefined local variable or method `a’ for main:Object (NameError)**
```

乍一看，它似乎会输出 1，但我们得到的是 NameError。这是为什么呢？因为循环方法(是的，它是一个[方法](https://docs.ruby-lang.org/en/2.6.0/Kernel.html#method-i-loop))接受了一个块，并且这个块创建了自己的作用域。变量是在块内初始化的，所以我们不能在块外访问它。我们如何修正我们的代码？像这样！

```
Output: 1
```

现在，我们在初始化变量**的块中调用了变量**的 puts，所以我们可以访问它。这个也行。

```
Output: 1
```

这是因为内部循环可以访问外部循环的范围，但反之则不行。另一种方法是这样的。

```
Output: 1
```

在这个例子中，我们在循环外初始化 **a** ，在循环内将其重新赋值给 **a + 1** ，在循环外输出 **a** 。这表明当一个块创建一个新的作用域时，它仍然可以访问在外部作用域中初始化的变量，但是在块内部初始化的变量在块外部是不可访问的。迭代数组和哈希方法也是如此。例如:

```
Output: **undefined local variable or method `a’ for main:Object (NameError)**
```

就像在循环例子中一样，我们得到一个错误，因为我们在一个块中初始化了一个变量，并试图在它定义的范围之外调用它。修复这段代码的方法类似于我们处理循环的方法。如果你好奇，可以在 IRB 或文本编辑器中尝试一下。在这一点上，你可能会像我一样认为，每当我们使用一个块时，就会创建一个新的作用域，就像这样。

```
do. . .end or { #code }
```

这是真的，但有时外表可能具有欺骗性。例如，下面的代码可以工作。

```
Output: 1
```

这是因为**而**被归类为[控制表达式](https://docs.ruby-lang.org/en/2.6.0/syntax/control_expressions_rdoc.html)，而不是方法。 **do…end** 部分看起来仍然可疑地像一个块，但是如果你检查文档，你会发现 **do** 关键字是可选的。这意味着当您使用 while 循环时，您实际上并没有创建新的作用域，因为从技术上讲，您并没有使用块。这同样适用于其他控制表达式，如 if 语句的**和 for** 循环的**。语法使它变得混乱，因为看起来你在创建一个新的作用域，但你没有。如果您不确定是否正在创建一个新的作用域，请在 IRB 中尝试一下，或者查看文档，看看您是否正在使用一个方法或一个控制表达式。我们已经讨论了很多，但是还有一件事要讨论，就是使用方法时的局部变量范围。**

```
Output: **undefined method `+’ for nil:NilClass (NoMethodError)**
```

这里发生了什么事？首先，我们将变量 **a** 初始化为 0。然后我们定义一个方法， **add_two** ，给 **a 加二**之后我们调用方法 **add_two** ，最后我们输出 **a** 。然而，在我们能够输出 **a** 之前，出现了一个错误。这是因为方法有自己的作用域规则。在方法内部不能访问在方法外部初始化的变量，在方法外部也不能访问在方法内部初始化的变量。一个例外是，如果您将变量作为参数传递给方法。例如，我们可以通过这样做来修复我们的代码。

```
Output: 2
```

这里，我们在我们的方法中使用了一个名为 **num** 的参数，并给它加了 2。因为 **num += 2** 是该方法的最后一行，所以该表达式的值被自动返回。然后，我们将 **a** 设置为等于 **add_two(a)** 的返回值，该返回值具有作为参数传入的 **a** 。最后，我们输出**一个**，它现在等于 2。

我希望您喜欢这篇关于可变作用域的介绍。这可能是一个棘手的概念，但学习它有助于编写更好的程序，并在我出错时更快地调试。感谢您的阅读，祝您编码愉快！