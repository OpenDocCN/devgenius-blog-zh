<html>
<head>
<title>Repository Pattern in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift 中的存储库模式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/repository-pattern-in-swift-a8eda25b515d?source=collection_archive---------3-----------------------#2020-07-19">https://blog.devgenius.io/repository-pattern-in-swift-a8eda25b515d?source=collection_archive---------3-----------------------#2020-07-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6529222701219c479048c96c135ecb49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cw6Gql7-97AnSCll0z9cMw.jpeg"/></div></div></figure><h1 id="9a9f" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">背景</h1><p id="1329" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">所有开发的应用程序都需要某种描述的数据。这些数据存储在某个地方，可能在设备本身、远程数据库/服务或两者的组合中。让我们看看最常见的数据来源:</p><p id="6d17" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这些方法中的每一种都以不同的格式保存数据。现在，我敢肯定，在你的应用程序中，至少有一种方法是你用来检索/保存数据的。</p><p id="96d7" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">当不使用存储库模式时，直接访问和使用这些元素是很常见的，要么在 ViewController 中，要么在应用程序的其他部分，这取决于它的结构。</p><h1 id="cbdc" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">问题是</h1><p id="53ea" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这种做法有什么问题？你的应用变得难以维护。现在，如果你只有一个只有几个屏幕的小应用程序，那么这不是一个大问题，因为只有几个元素需要改变。</p><p id="f752" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">然而，如果你和几个开发人员一起开发一个大型应用程序，并且有很多代码，那该怎么办呢？例如，你可以让<a class="ae lz" href="https://developer.apple.com/documentation/coredata/nsmanagedobject" rel="noopener ugc nofollow" target="_blank"> NSManagedObjects </a>或<a class="ae lz" href="https://developer.apple.com/documentation/swift/codable" rel="noopener ugc nofollow" target="_blank"> Codable </a>对象散布在整个代码库中。如果您希望删除核心数据，会发生什么情况？或许搬到王国去？您需要修改代码库中使用核心数据对象的所有类。</p><p id="7809" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">类似地，如果您直接从 JSON 响应中使用可编码对象。当您的后端团队更改 API 或者您切换到不同的 API 提供商时会发生什么？数据的结构可能会改变，这意味着您的可编码对象可能会改变。同样，如果你在一个大的应用上工作，你将需要修改大量的类。</p><p id="4ecd" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们还可以将此应用于其他选项，例如从第三方框架访问数据。如果我们直接使用从框架返回的对象，如果我们改变提供者或者 SDK 改变，它们都需要改变。</p><p id="b175" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">还有查询语言的问题。Web 服务使用头和<a class="ae lz" href="https://developer.apple.com/documentation/foundation/urlqueryitem" rel="noopener ugc nofollow" target="_blank"> URLQueryItem </a>，核心数据使用<a class="ae lz" href="https://developer.apple.com/documentation/foundation/nspredicate" rel="noopener ugc nofollow" target="_blank">谓词</a>等等。每一个查询数据的入口点都必须知道并理解底层的查询语言，以便一次就获得信息。同样，如果这种变化，我们需要改变每个查询点的新格式。</p><p id="1d57" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">让我们看看下图:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ma"><img src="../Images/9a23688b5bf992fb94f151641a54d7a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pq1vpqZBke6bvewj.png"/></div></div></figure><p id="5728" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这里我们有一个利用核心数据的应用程序结构。有一个对象正被用来访问返回一些数据的堆栈。假设这个例子是新闻文章。这些新项目必须从 NSManagedObject 继承，才能在核心数据中使用。现在，如果我们的数据层将 NSManagedObjects 返回到我们应用程序结构的其余部分，我们现在就有了核心数据和应用程序中其余文件之间的依赖关系。例如，如果我们希望移动到 Realm，或者切换到使用其他形式的数据存储，我们需要修改应用程序中所有的文件。这个例子中的应用程序很小，想象一下一个大得多的应用程序必须这样做！</p><h1 id="3486" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">域对象和存储库</h1><p id="b8e9" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这就是域对象的用武之地。域对象是由应用程序定义的值对象。我们不是使用应用程序外部定义的对象和结构，而是定义我们希望对象看起来是什么样子。然后由存储库将数据存储对象/结构映射到这些值对象。</p><p id="2ae8" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">当我们这样做时，这意味着对数据访问层的任何更改，正如我们前面讨论的那样，如数据结构的更改或提供者的更改不会影响应用程序的其余部分。应用程序中唯一需要更新的部分是存储库及其到域对象的映射。</p><p id="7977" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">下面的引文总结了该模式的思想:</p><blockquote class="mf mg mh"><p id="285c" class="kw kx mi ky b kz lu lb lc ld lv lf lg mj lw lj lk mk lx ln lo ml ly lr ls lt ij bi translated">储存库是封装了访问数据源所需的逻辑的类或组件。它们集中了常见的数据访问功能，提供了更好的可维护性，并将用于访问数据库的基础设施或技术从域模型层中分离出来。</p></blockquote><p id="d893" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">让我们看看前面的例子，但是修改后使用了存储库和域对象:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mm"><img src="../Images/d0a88f32185eaf7120ac95e678a2a851.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*njtpy4r01I9TxiId.png"/></div></div></figure><p id="e992" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">那么这里的区别是什么呢？如您所见，核心数据堆栈仍在返回 NSManagedObjects，但是存储库正在将其转换为域对象。此对象不从 NSManagedObject 继承，它的结构和属性也是由应用程序定义的，而不是由数据存储中的内容定义的。</p><p id="cf76" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在，如果我们想从核心数据转移到其他东西，唯一需要改变的类是核心数据堆栈和存储库。应用程序的其余部分不需要更改，因为我们可以使用存储库将新的数据存储类型映射到我们的域对象。</p><h1 id="0761" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">例子</h1><p id="1a88" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">为了展示一个小的工作示例，我们将使用几个<a class="ae lz" href="https://github.com/public-apis/public-apis" rel="noopener ugc nofollow" target="_blank">免费公共 API</a>(如果你想构建一个演示应用或实验，强烈推荐这个资源)。我们将使用 2 个返回用户的 API。但是他们以不同的格式返回它们。</p><p id="1f23" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">【https://jsonplaceholder.typicode.com/users/1 T4】</p><p id="b739" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><a class="ae lz" href="https://randomuser.me/api/" rel="noopener ugc nofollow" target="_blank">https://randomuser.me/api/</a></p><p id="27d7" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">正如我们在<a class="ae lz" href="https://pyartez.github.io/networking/simple-json-decoder-in-swift-and-combine.html" rel="noopener ugc nofollow" target="_blank">之前的博文</a>中所做的，我们将使用<a class="ae lz" href="https://app.quicktype.io" rel="noopener ugc nofollow" target="_blank"> QuickType </a>从我们的 JSON 响应中生成我们的可编码对象。我们将从第一个请求开始。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="ae34" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这个结构将允许我们解码第一个请求的响应。让我们做一个简单的例子，它接受响应并输出一些数据。我们将使用来自我们的简单 JSON 解码器的代码来处理输出，所以如果你看到的代码没有意义，请随意阅读。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="530e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">让我们来看看这里发生了什么:</p><ol class=""><li id="7443" class="mp mq iq ky b kz lu ld lv lh mr ll ms lp mt lt mu mv mw mx bi translated">首先，我们使用简单的 JSON 解码器发出请求，返回新的用户类型。</li><li id="f53a" class="mp mq iq ky b kz my ld mz lh na ll nb lp nc lt mu mv mw mx bi translated">输出任何错误</li><li id="c65c" class="mp mq iq ky b kz my ld mz lh na ll nb lp nc lt mu mv mw mx bi translated">因此，我们在这里输出我们得到的用户的姓名、地址和位置。现在超级简单。</li></ol><h1 id="c60f" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">管理变革</h1><p id="c048" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">现在假设我们改变了供应商。也许我们的后端团队改变了 API，或者我们转换了数据提供者，或者从 2 个不同的数据提供者 SDK。在我们的例子中，我们将从第一个 URL(<a class="ae lz" href="https://jsonplaceholder.typicode.com/users/1" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/users/1</a>)切换到第二个(<a class="ae lz" href="https://randomuser.me/api/" rel="noopener ugc nofollow" target="_blank">https://randomuser.me/api/</a>)。</p><p id="1bd0" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们需要做的第一件事是改变所有的可编码对象，因为响应的结构是不同的。让我们再次使用 QuickType 来给出新的结构:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="4270" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">对于我们的例子来说，这要复杂得多，但我把它留在这里，作为一个极端的例子，说明事情可以有多么不同。正如您可能已经知道的，从我们的第一个例子开始，结构和类型已经发生了巨大的变化。因此，让我们尝试输出与上一个示例相同的数据。我们可以忽略请求部分，只关注数据输出，这样我们就可以看到不同之处:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="79c2" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">从这个简单的例子就可以看出。我们将不得不更改 7 行代码，只是为了产生相同的输出。现在想象这种变化发生在一个更大的项目中！可能有数百行代码需要更新，这都是因为 API 响应发生了变化。</p><h1 id="d3ea" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">知识库模式</h1><p id="306b" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这就是存储库模式的用武之地。我们可以创建一个用户存储库，获取用户并将其转换为我们的域对象。这样我们就不需要更新输出。</p><p id="9018" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">首先要做的是设计我们的域对象，它将在我们的系统中代表一个用户。现在我们在这个简单的例子中所做的就是输出一些属性，所以让我们只使用这些属性来设计我们的对象，因为我们不需要其他的属性。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="d745" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这里我们有一个用户对象的简单表示。不需要考虑从 API 返回的任何其他可能的属性。我们不会在应用程序中使用它们，它们只会占用宝贵的内存。您还会注意到，该对象不符合 Codable 或 NSManagedObject 子类。这是因为 DomainObject 不应该包含任何关于它们如何存储的知识。这是存储库的责任。</p><p id="ac4b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">为了设计我们的存储库，我们可以利用泛型和协议来设计一个可以用于任何事情的存储库，而不仅仅是我们的域用户。让我们看一看:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="3a1e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在这里，我们有不同的功能来完成我们能做的所有操作。您会注意到，这些函数都没有指定数据存储在哪里或者如何存储。还记得我们一开始谈到的不同储物选项吗？我们可以实现一个与 API 对话的 repo(就像我们的例子一样)，一个在核心数据中存储内容的 repo，或者一个向用户默认值写入内容的 repo。由实现协议的存储库来决定这些细节，我们所关心的是我们可以从某个地方加载和保存数据。</p><h1 id="e5aa" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">看它行动</h1><p id="cd57" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">现在我们已经定义了什么是存储库模式，让我们创建 2 个实现。一个用于我们的第一个请求，一个用于第二个请求。两者都应该返回域对象，而不是从请求中返回的类型。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="be82" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这里有相当多的代码，所以让我们一步一步来。</p><ol class=""><li id="0344" class="mp mq iq ky b kz lu ld lv lh mr ll ms lp mt lt mu mv mw mx bi translated">首先，我们已经定义了一个新的错误，如果我们没有从 API 接收到任何用户信息，就返回这个错误。</li><li id="b897" class="mp mq iq ky b kz my ld mz lh na ll nb lp nc lt mu mv mw mx bi translated">这与我们在之前的示例中进行的调用相同。</li><li id="7b5e" class="mp mq iq ky b kz my ld mz lh na ll nb lp nc lt mu mv mw mx bi translated">现在，我们获取返回的可编码用户，并将其转换为新的 DomainUser 类。</li><li id="2989" class="mp mq iq ky b kz my ld mz lh na ll nb lp nc lt mu mv mw mx bi translated">在这个例子中，我们没有实现其他函数，所以暂时将它们留空以消除错误。</li><li id="cced" class="mp mq iq ky b kz my ld mz lh na ll nb lp nc lt mu mv mw mx bi translated">这个结构是我们发出的第二个请求，这里我们再次将用户的可编码类型从第二个请求映射到我们的 DomainUser。</li></ol><p id="42e4" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在我们已经创建了两个存储库，让我们展示如何在不破坏/改变代码的情况下在它们之间快速切换。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="d892" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这是本文前面的例子，但是更新后使用了新的存储库。在这里，我们获取用户并打印他们的详细信息，和以前一样。现在下面我们可以切换到我们的第二个请求，看看这将如何工作。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="9147" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在注意我们唯一改变的部分是实现类。代码的其余部分保持不变，即使数据的来源发生了变化，并以完全不同的结构返回。现在想象一下，我们在许多地方使用这个回购来获取用户详细信息。我们可以在不同的数据源之间快速切换，而无需更改使用它的代码。我们必须做的唯一更改是对 repo 和数据映射代码进行更改。所以只有一个变化，而不是每个使用这些对象的类都有变化。</p><h1 id="31c7" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论</h1><p id="6af0" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">让我们回顾一下我们在这里讨论的内容:</p><ul class=""><li id="d54e" class="mp mq iq ky b kz lu ld lv lh mr ll ms lp mt lt nd mv mw mx bi translated">首先，我们讨论了在整个代码库中使用数据存储类的问题。尤其是在需要切换数据源/结构的大型项目中。</li><li id="3fd4" class="mp mq iq ky b kz my ld mz lh na ll nb lp nc lt nd mv mw mx bi translated">然后，我们讨论了使用存储库模式和映射到域对象，而不是使用数据存储类，如何使您的代码在将来更容易更改。</li><li id="b9e2" class="mp mq iq ky b kz my ld mz lh na ll nb lp nc lt nd mv mw mx bi translated">我们研究了一些改变 API 结构如何影响代码的例子。</li><li id="b5ed" class="mp mq iq ky b kz my ld mz lh na ll nb lp nc lt nd mv mw mx bi translated">然后，我们实现了一个映射到域对象的基本存储库模式，以展示这样做如何使更新项目变得更容易。</li></ul><p id="ce77" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">最后，让我们讨论一下这种方法的利弊:</p><h1 id="05c7" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">优势</h1><ul class=""><li id="b401" class="mp mq iq ky b kz la ld le lh ne ll nf lp ng lt nd mv mw mx bi translated">如果需要切换数据源或结构，代码更容易更改</li><li id="87f0" class="mp mq iq ky b kz my ld mz lh na ll nb lp nc lt nd mv mw mx bi translated">将数据存储在何处/如何的问题与应用程序的其他部分分开</li></ul><h1 id="d899" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">不足之处</h1><ul class=""><li id="b195" class="mp mq iq ky b kz la ld le lh ne ll nf lp ng lt nd mv mw mx bi translated">增加了更多代码和复杂性</li><li id="2ad3" class="mp mq iq ky b kz my ld mz lh na ll nb lp nc lt nd mv mw mx bi translated">需要为每个对象编写到域对象的映射器</li><li id="1363" class="mp mq iq ky b kz my ld mz lh na ll nb lp nc lt nd mv mw mx bi translated">在较小的个人项目中不需要</li></ul><p id="1899" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">请随意<a class="ae lz" href="https://github.com/pyartez/blog-samples" rel="noopener ugc nofollow" target="_blank">下载操场</a>并自己玩这些例子</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><p id="0882" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><em class="mi">原载于 2020 年 7 月 19 日</em><a class="ae lz" href="https://pyartez.github.io/architecture/repository-pattern-in-swift-and-combine.html" rel="noopener ugc nofollow" target="_blank"><em class="mi">https://pyartez . github . io</em></a><em class="mi">。</em></p></div></div>    
</body>
</html>