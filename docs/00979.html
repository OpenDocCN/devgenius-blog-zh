<html>
<head>
<title>A comprehensive look at Object-Oriented Programming(OOP)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">全面了解面向对象编程(OOP)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/a-comprehensive-look-at-object-oriented-programming-oop-91d6423dde9a?source=collection_archive---------11-----------------------#2020-06-21">https://blog.devgenius.io/a-comprehensive-look-at-object-oriented-programming-oop-91d6423dde9a?source=collection_archive---------11-----------------------#2020-06-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="9773" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">编程范例</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/5e59e3f8dfd396b2c34bedeebbc9f8f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WR2SzZLe1QHRTbTLRDfLZA.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">侯赛因·巴德沙阿在<a class="ae ks" href="/s/photos/chains?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="93e0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">下面是这篇文章的内容:<br/> 1。<strong class="kv io">这个</strong>关键字<br/> 2。<strong class="kv io">新增</strong>关键词<br/> 3。关于<strong class="kv io">原型</strong>的一切<br/> 4。<strong class="kv io"> ES6类</strong>5<br/>类。基于类的语言，比如Java、C++、T21。<strong class="kv io">传承</strong>传承<br/> 7。<strong class="kv io">object . create</strong>T27】8。<strong class="kv io">私有</strong> vs <strong class="kv io">公有</strong>T32】9。面向对象的四个原则</p><p id="b469" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">编程范式允许我们以一种易于推理的方式组织代码。</p><p id="f202" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这就是我们希望从理解这种编程范式中得到的东西:</p><ol class=""><li id="b9ae" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo lu lv lw lx bi translated">我们会让代码更清晰，更容易理解。</li><li id="735d" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">我们将使我们的代码易于扩展。请记住，随着我们的应用程序的增长，随着我们的程序的增长，随着团队中的开发人员的增长，我们的代码更容易使用这些编程范例进行扩展。</li><li id="3321" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">让多个程序员更容易维护代码。</li><li id="1053" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">让我们的代码记忆高效。</li><li id="e38b" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">它将保持我们的代码干燥。我们就不重复了。我们的代码将是干净和高效的。</li></ol><p id="abd1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以很明显，编程范式允许我们使复杂的代码更有组织性。但是在OOP和函数式编程之前，有机器码；最初，程序员使用的都是1和0。</p><blockquote class="md"><p id="a83d" class="me mf in bd mg mh mi mj mk ml mm lo dk translated">编程范式允许我们以一种易于推理的方式组织代码。</p></blockquote><p id="3e74" class="pw-post-body-paragraph kt ku in kv b kw mn jo ky kz mo jr lb lc mp le lf lg mq li lj lk mr lm ln lo ig bi translated">随着时间的推移，我们进入了<a class="ae ks" href="https://en.wikipedia.org/wiki/Procedural_programming#:~:text=The%20focus%20of%20procedural%20programming,members%20or%20attributes)%20using%20interfaces." rel="noopener ugc nofollow" target="_blank">程序风格的编程</a>。通过这种方式，我们做了计算机希望我们做的事情——也就是说，我们存储数据，然后使用某种功能处理这些数据。但是没有结构或组织。</p><p id="9c0a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们有一步一步的指令:<em class="ms">电脑，把内存放在这里，电脑把内存移到这里，电脑把内存换到这里，然后给我这个。一切都是程序性的。</em></p><div class="mt mu gp gr mv mw"><a href="https://en.wikipedia.org/wiki/History_of_programming_languages" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd io gy z fp nb fr fs nc fu fw im bi translated">编程语言的历史</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">编程语言的历史跨越了从早期机械计算机的文档到现代工具…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">en.wikipedia.org</p></div></div><div class="nf l"><div class="ng l nh ni nj nf nk km mw"/></div></div></a></div><p id="d6f4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最初，我们从基本编程语言开始——真正的低级语言。<strong class="kv io">基本</strong>，<strong class="kv io">汇编语言</strong>，<strong class="kv io"> COBOL </strong>，但是在整个六七十年代，发生了一个很大的变化。我们开始建立这些基本范式。</p><h2 id="31df" class="nl nm in bd nn no np dn nq nr ns dp nt lc nu nv nw lg nx ny nz lk oa ob oc od bi translated">如何以更有条理的方式编写代码？</h2><p id="5591" class="pw-post-body-paragraph kt ku in kv b kw oe jo ky kz of jr lb lc og le lf lg oh li lj lk oi lm ln lo ig bi translated">非过程化的代码。这时候<strong class="kv io"> OOP </strong>和<strong class="kv io"> FP </strong>开始生效。我们有像<a class="ae ks" href="https://en.wikipedia.org/wiki/Scheme_(programming_language)#:~:text=Scheme%20is%20a%20minimalist%20dialect,by%20its%20developers%2C%20Guy%20L." rel="noopener ugc nofollow" target="_blank"> Scheme </a>这样的语言，这是Javascript的灵感之一。我们有像<a class="ae ks" href="https://en.wikipedia.org/wiki/Smalltalk" rel="noopener ugc nofollow" target="_blank"> Smalltalk </a>这样的语言，它将<strong class="kv io"> OOP </strong>的思想作为一种组织代码的方式推广开来。</p><p id="e410" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后，在80年代，随着越来越多的最佳实践开始出现，我们开始进行更多的整合—人们就一些好的模式和最佳实践达成一致。模块之类的东西。</p><p id="6948" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这里，<strong class="kv io"> OOP </strong>真正开始腾飞了。我们有了像c++(T19)这样的语言。C++是最初的带类的C语言——这些类允许我们进行面向对象的编程。我们有<a class="ae ks" href="https://en.wikipedia.org/wiki/Objective-C" rel="noopener ugc nofollow" target="_blank"> Objective C </a>，顾名思义，它是一种基于C的语言，灵感来自于对象和<strong class="kv io"> OOP </strong>。那是事情真正开始起飞的时候。</p><p id="3250" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">同时在后台，我们也有函数式编程。在90年代，随着互联网时代的到来，我们开始有更多的语言。Java因其面向对象的范例而大受欢迎。</p><p id="c252" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">1995年，我们有了作为网络语言的Javascript和许多我们熟悉的其他语言。OOP跟上了潮流，并且随着诸如Java之类的语言而真正流行起来。</p><p id="29c4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">今天，我们看到了函数式编程语言的趋势。它们变得越来越流行，主要是因为这种范式与<a class="ae ks" href="https://en.wikipedia.org/wiki/Concurrent_computing" rel="noopener ugc nofollow" target="_blank">并发</a>和<a class="ae ks" href="https://en.wikipedia.org/wiki/Distributed_computing#:~:text=A%20computer%20program%20that%20runs,like%20connectors%20and%20message%20queues." rel="noopener ugc nofollow" target="_blank">分布式编程</a>配合得很好。</p><blockquote class="md"><p id="849a" class="me mf in bd mg mh mi mj mk ml mm lo dk translated">这一切都表明，随着时间的推移，程序员们越来越多地使用代码，我们开始形成我们认为是好的实践的想法。</p></blockquote><p id="478b" class="pw-post-body-paragraph kt ku in kv b kw mn jo ky kz mo jr lb lc mp le lf lg mq li lj lk mr lm ln lo ig bi translated">这一切都表明，随着时间的推移，程序员们越来越多地使用代码，我们开始形成我们认为是好的实践的想法。<br/>所以当时人们在问自己我们应该做什么？<br/>OOP和FP是进化而来的两大范式。所以通过学习这两件事，我们可以站在巨人的肩膀上。</p><p id="e403" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们开始了解所有这些之前的程序员学到了什么好的实践，他们犯了什么错误，这样做，我们就能写出更好的代码。</p><h1 id="faf8" class="oj nm in bd nn ok ol om nq on oo op nt jt oq ju nw jw or jx nz jz os ka oc ot bi translated">面向对象编程与函数式编程</h1><p id="d94f" class="pw-post-body-paragraph kt ku in kv b kw oe jo ky kz of jr lb lc og le lf lg oh li lj lk oi lm ln lo ig bi translated">在所有的程序中，有两个主要成分:<br/> 1。数据——我们保存在记忆中的东西。<br/> 2。行为——程序能做的事情。</p><p id="9132" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了让我们处理这两件事，我们最初有像Java和Scheme这样的语言，它们对我们能做什么有不同的想法(Java和Scheme是Javascript的灵感)。</p><p id="d2b5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们之前了解到Javascript中有像函数和对象这样的东西，它们非常重要。我们学习了所有关于<strong class="kv io">原型继承、</strong>函数及其有用的工具，如<strong class="kv io">闭包</strong>以及函数是Javascript中的一等公民的概念。</p><div class="mt mu gp gr mv mw"><a href="https://medium.com/swlh/all-you-need-to-know-about-closures-the-first-pillar-of-javascript-5e7ed96f241c" rel="noopener follow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd io gy z fp nb fr fs nc fu fw im bi translated">关于闭包Javascript的第一支柱，您需要知道的一切。</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">强大的Javascript支柱</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">medium.com</p></div></div><div class="nf l"><div class="ou l nh ni nj nf nk km mw"/></div></div></a></div><div class="mt mu gp gr mv mw"><a href="https://medium.com/swlh/all-you-need-to-know-about-prototypal-inheritance-the-second-pillar-of-javascript-d8d851cd4509" rel="noopener follow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd io gy z fp nb fr fs nc fu fw im bi translated">关于原型继承Javascript的第二个支柱，您需要知道的就是</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">我们在这里学到的东西将帮助我们理解面向对象编程(OOP)。</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">medium.com</p></div></div><div class="nf l"><div class="ov l nh ni nj nf nk km mw"/></div></div></a></div><p id="8b9c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">从这两个想法，我们有了函数式编程和面向对象编程。</p><p id="df8a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">OOP说把数据和它的行为放在一个叫做对象的位置；把所有这些放在一个盒子里会更容易理解我们的程序是如何工作的。</p><p id="93b3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">函数式编程认为数据和行为是截然不同的东西，为了清晰起见应该分开保存。因此，也许不是用一个大盒子来描述一切，而是用多个盒子。</p><p id="3c16" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">OOP就像制造一个机器人，我们有一个头部组件，一个手部组件，可能还有胸部组件，腿部组件，触角组件，然后我们一起组装。</p><p id="ce0c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">函数式编程说，只要给我数据，我就会通过函数对数据进行操作，然后我会从你给我的数据中返回一些新的东西。</p><p id="2d2c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里的目标不是向你展示这是<strong class="kv io"> FP </strong> Vs <strong class="kv io"> OOP </strong>，而是这些实际上是互补的。这不是一个凌驾于另一个之上。相反，它是关于联合使用两种范例来制作好的程序。Javascript的美妙之处在于它是多范例的。</p><p id="d9e1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们可以使用这两种技术使我们的代码更容易推理，更清晰，更容易理解，更容易扩展，更高效。此外，我们可以根据手头的问题使用这些范例中的每一个，并使用每一个中的技术为特定的问题选择一个范例。</p><p id="8d18" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><a class="ae ks" href="https://medium.com/swlh/all-you-need-to-know-about-prototypal-inheritance-the-second-pillar-of-javascript-d8d851cd4509" rel="noopener">的两大支柱</a>终于让我们了解了这些话题。</p><p id="5f97" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">闭包是FP<strong class="kv io">的重要组成部分，没有它们，我们就无法用函数式编程来完成我将要向你展示的事情。没有原型，我们将无法做我们将在<strong class="kv io"> OOP </strong>中要做的事情。</strong></p><h1 id="c3f3" class="oj nm in bd nn ok ol om nq on oo op nt jt oq ju nw jw or jx nz jz os ka oc ot bi translated">OOP简介</h1><p id="eafe" class="pw-post-body-paragraph kt ku in kv b kw oe jo ky kz of jr lb lc og le lf lg oh li lj lk oi lm ln lo ig bi translated">这里的大部分东西，我们已经看过了。<br/><a class="ae ks" href="https://medium.com/@allansendagi/javascript-fundamentals-this-keyword-481722806d20" rel="noopener"><strong class="kv io">本</strong> </a> <strong class="kv io"> </strong>关键字，<a class="ae ks" href="https://medium.com/swlh/all-you-need-to-know-about-prototypal-inheritance-the-second-pillar-of-javascript-d8d851cd4509" rel="noopener">原型继承</a>，<strong class="kv io">新</strong>关键字，新<strong class="kv io"> ES6类</strong>，<strong class="kv io">继承</strong>，<strong class="kv io"> Object.create </strong>。我们还将看到私有和公共字段Java等语言中基于类的继承思想。最后，我们将讨论OOP的四个原则。</p><h2 id="8aca" class="nl nm in bd nn no np dn nq nr ns dp nt lc nu nv nw lg nx ny nz lk oa ob oc od bi translated">OOP从70年代就已经存在了。</h2><p id="8af5" class="pw-post-body-paragraph kt ku in kv b kw oe jo ky kz of jr lb lc og le lf lg oh li lj lk oi lm ln lo ig bi translated">这是一种编程风格，在诸如<a class="ae ks" href="https://en.wikipedia.org/wiki/C_Sharp_(programming_language)" rel="noopener ugc nofollow" target="_blank"> C# </a>、Python、Ruby和Java等语言中非常常见。在面向对象的程序设计中，对象是一个包含信息和操作的盒子，这些信息和操作应该指向同一个概念。</p><p id="b844" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这就像我们在模拟现实生活中的物体。我们以前在龙的物体上看到过这种情况。我们有一些面向对象的原则。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ow"><img src="../Images/f0e08eef017c6c02d27440a914aaab82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*04kh3-ziwyHRQCkf.png"/></div></div></figure><p id="0b20" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们有关于龙的数据，比如名字和喷火的能力。我们也有龙可以采取的行动。在OOP中，这些数据也可以称为状态。<br/>我们已经将这条龙包装在一个对象中，以模拟真实生活中的龙，其中包含关于龙的一些数据，以及龙可以采取的行动。</p><blockquote class="md"><p id="fc63" class="me mf in bd mg mh mi mj mk ml mm lo dk translated">属性或特性允许我们跟踪对象的状态，方法允许我们操纵对象的状态，以便我们模拟真实世界。</p></blockquote><p id="c47a" class="pw-post-body-paragraph kt ku in kv b kw mn jo ky kz mo jr lb lc mp le lf lg mq li lj lk mr lm ln lo ig bi translated">属性或特性允许我们跟踪对象的状态，方法允许我们操纵对象的状态，以便我们模拟真实世界。</p><p id="cbbe" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这就是我们想要对<strong class="kv io"> OOP </strong>做的事情。</p><p id="c7ff" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们想看看这个世界，并把我们想做的事情组织到这些相互作用的小物件盒里。这样我们就能把所有东西都分门别类，井井有条。</p><p id="37cb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">说到OOP，主要有两种:<br/> 1。有基于类的编程语言。<br/> 2。基于原型的编程语言。</p><p id="f45f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">正如我们知道的Javascript，我们有原型继承。因此，让我们来看看从过程代码开始的整个旅程——我们不断重复的代码变成了一直通向<strong class="kv io"> OOP </strong>的代码。</p><p id="dbfa" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们从一个有角色互动的游戏开始。使用让我们创建一个程序，在头脑中有<strong class="kv io"> OOP </strong>原则来组织我们的代码。</p><p id="9adb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">创建elf对象</strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ox"><img src="../Images/506dcff49957a1b884b91b17e41b48b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4J7dyA5Cx5IVh-cxoQWb4w.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">精灵角色。资料来源:ZTM</figcaption></figure><p id="4e28" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">和任何游戏一样，我们不会只有一个精灵。我们将会有不同的精灵，不同的名字，不同的武器，甚至不同的方法。<br/>那么如果想再加一个小精灵该怎么做呢？</p><p id="761f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们可以复制并粘贴这段代码，也许可以创建elf2。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oy"><img src="../Images/7093f3ff20d5382409d6657f42252f31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KVa_qR4vtsjs1cL_6yvEcQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">我们游戏中的第二个精灵角色</figcaption></figure><p id="cb00" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">那么，我们刚刚所做的让我们走向OOP的工作有什么好处呢？</p><p id="8c40" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们这里有一个叫做<a class="ae ks" href="https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)" rel="noopener ugc nofollow" target="_blank">封装</a>的东西。我们将功能组合在一起。我们有状态，即对象中的数据和作用于该状态的函数。<br/>以便这些功能可以与此状态交互。他们可以阅读甚至修改它。我们可以有一种方法，可以把武器从弓变成剑。</p><h1 id="0584" class="oj nm in bd nn ok ol om nq on oo op nt jt oq ju nw jw or jx nz jz os ka oc ot bi translated">这是我们迈向OOP的第一步。</h1><p id="c1f4" class="pw-post-body-paragraph kt ku in kv b kw oe jo ky kz of jr lb lc og le lf lg oh li lj lk oi lm ln lo ig bi translated">我们已经将可以用来模拟真实世界精灵的功能封装到这些容器中。但是这有什么问题呢？</p><p id="b440" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">很明显的问题是，当我们需要更多的精灵时——在这个游戏中我们会需要大量的精灵，我们不得不一遍又一遍地复制相同的代码，即使精灵们有相同的攻击方法。我们不得不一直重复复制和粘贴代码。</p><p id="65c4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最有可能的是，我们的精灵拥有比这更多的功能，这意味着更多的属性，更多的方法。我们并没有让我们的代码非常枯燥。我们只是不断地重复自己。</p><h1 id="f6ac" class="oj nm in bd nn ok ol om nq on oo op nt jt oq ju nw jw or jx nz jz os ka oc ot bi translated">所以让我们进入面向对象程序设计的第二步。</h1><h2 id="8c96" class="nl nm in bd nn no np dn nq nr ns dp nt lc nu nv nw lg nx ny nz lk oa ob oc od bi translated">工厂功能</h2><p id="d524" class="pw-post-body-paragraph kt ku in kv b kw oe jo ky kz of jr lb lc og le lf lg oh li lj lk oi lm ln lo ig bi translated">工厂函数是行为类似工厂的函数——它们为我们创建对象。</p><p id="4bda" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们通过编程来创建精灵。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oz"><img src="../Images/3baf83b8dd888b6a1a4595c891bfe45f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p10avhTLf318fosVvsEQWQ.png"/></div></div></figure><p id="3380" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里我们创建了一个工厂函数——一个为我们创建对象的函数。我们甚至可以使用ES6语法来简化这一点，如果属性和值相同，我们可以将它保存在对象内部。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pa"><img src="../Images/61002402fa71960e7957ac66a5d0f2a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*956jcuQVXxWOnf55BAZXqA.png"/></div></div></figure><p id="1a34" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">工厂函数的美妙之处在于，现在如果我想创建另一个精灵，我只需:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pb"><img src="../Images/98e6e856d3ada1644e41a5ee15454e3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NIc5d0064RHEo7lMcctO0w.png"/></div></div></figure><p id="d8d4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以我们现在不只是复制代码，而是有了这个为我们创造精灵的功能。</p><p id="3556" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们已经朝着面向目标的方向前进了一步。</p><p id="d717" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们避免了重复的代码。但是这里还有一个问题。工厂功能很棒，但是这里有什么问题呢？<br/>如果我们有1000个精灵呢？这意味着所有1000个精灵都需要内存空间来存储相同的数据！</p><p id="895d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以像<strong class="kv io">名字</strong>和<strong class="kv io">武器</strong>将会不同，我们将不得不为每个精灵在内存中存储这些数据。此外，像<strong class="kv io"> attack() </strong>这样非常通用的方法必须被复制到每个精灵的不同内存位置。因此，如果我们有1000个精灵，那么每个精灵在内存的不同位置有1000个攻击函数。</p><p id="6f74" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">幸运的是，Javascript有一个叫做<strong class="kv io">原型继承</strong>的东西。我们可以利用这一点来改进它，这样我们就可以在不同的对象之间共享功能。</p><div class="mt mu gp gr mv mw"><a href="https://medium.com/swlh/all-you-need-to-know-about-prototypal-inheritance-the-second-pillar-of-javascript-d8d851cd4509" rel="noopener follow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd io gy z fp nb fr fs nc fu fw im bi translated">关于原型继承Javascript的第二个支柱，您需要知道的就是</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">我们在这里学到的东西将帮助我们理解面向对象编程(OOP)。</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">medium.com</p></div></div><div class="nf l"><div class="ov l nh ni nj nf nk km mw"/></div></div></a></div><h1 id="865c" class="oj nm in bd nn ok ol om nq on oo op nt jt oq ju nw jw or jx nz jz os ka oc ot bi translated">所以让我们进入面向对象的第三步。</h1><p id="020f" class="pw-post-body-paragraph kt ku in kv b kw oe jo ky kz of jr lb lc og le lf lg oh li lj lk oi lm ln lo ig bi translated">我们希望解决在多个对象上拥有相同功能的问题。我们如何做到这一点？</p><p id="3698" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在我们开始原型继承之前，有一种手动的方法。</p><p id="7685" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们可以取出<strong class="kv io">攻击</strong>功能，并把它放在某种我们有共同功能的商店里。例如，我可以做</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pc"><img src="../Images/c08b1cf8cb259e5bcc1d020dc84eb556.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d-TfOYiBGPXE-5WpB0TylA.png"/></div></div></figure><p id="e46f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，我有了一个简单的对象，上面有攻击方法，我现在需要做的就是添加一行代码来赋予Peter和Sam攻击能力:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pd"><img src="../Images/55de32882c58385173fd94205e19dbe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7noTz08XMA43QoDTxDgyKw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">彼得.攻击()</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pe"><img src="../Images/7f7e253edbab55ebed003bcb2f31dc28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*klQkSxp9kGJSzS1cMnsPJw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">Sam.attack()</figcaption></figure><h1 id="52c7" class="oj nm in bd nn ok ol om nq on oo op nt jt oq ju nw jw or jx nz jz os ka oc ot bi translated">Object.create()</h1><p id="cc8b" class="pw-post-body-paragraph kt ku in kv b kw oe jo ky kz of jr lb lc og le lf lg oh li lj lk oi lm ln lo ig bi translated">这是可行的，但是仍然需要大量的手工工作。Javascript给了我们一个工具，让我们自己更容易做到这一点。我们可以使用<strong class="kv io"> Object.create() </strong>。</p><p id="6273" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">使用Object.create()，我可以稍微清理一下。我们将删除代码行，并使用Object.create()来创建链接——这两部分代码之间的原型链，而不是手动将方法附加到每个elf。</p><p id="b7a3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们可以很简单地做到这一点。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pf"><img src="../Images/73d116647f9807d1d9aee0781b89d0c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*euLs3y_j69Qk6XMyl7nWag.png"/></div></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pg"><img src="../Images/42a24e2212536bd18ed577259d4a96bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WBA2CUf0Py149JR0N9CgDA.png"/></div></div></figure><blockquote class="md"><p id="f834" class="me mf in bd mg mh ph pi pj pk pl lo dk translated">Object.create所做的是在我们刚刚创建的<strong class="ak"> elf函数</strong>和<strong class="ak"> newElf </strong>之间创建一个链接。我们在这里做原型继承。</p></blockquote><p id="3821" class="pw-post-body-paragraph kt ku in kv b kw mn jo ky kz mo jr lb lc mp le lf lg mq li lj lk mr lm ln lo ig bi translated">Object.create所做的是在我们刚刚创建的<strong class="kv io"> elf函数</strong>和<strong class="kv io"> newElf </strong>之间创建一个链接。我们在这里做原型继承。</p><p id="871c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Object.create为我们一路创建了这个原型链，以便我们可以使用攻击方法。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pm"><img src="../Images/33c14802c109eec32d43392a30024f7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*30zr3Zm0tBjIRI75Ue68Pg.png"/></div></div></figure><p id="3f91" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里有一个问题。即使我们用<strong class="kv io"> Object.create() </strong>做的是真正的原型继承，你也不会在大多数代码库中看到这一点。它应该这样使用。</p><p id="8220" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">诚然，我们的代码更简洁了一些，但这并没有被整个Javascript社区所接受。</p><p id="2875" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们的目标是更接近面向对象编程。但是我们现在做的还不一定是面向对象的。</p><p id="d729" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">那么在Object.create()之前程序员用的是什么？</p><h1 id="f24a" class="oj nm in bd nn ok ol om nq on oo op nt jt oq ju nw jw or jx nz jz os ka oc ot bi translated">面向对象的第四步。</h1><p id="ca30" class="pw-post-body-paragraph kt ku in kv b kw oe jo ky kz of jr lb lc og le lf lg oh li lj lk oi lm ln lo ig bi translated">没有Object.create，我们做了一些更接近OOP的东西。我们没有使用Object.create()，而是使用了<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor#:~:text=The%20constructor%20property%20returns%20a,true%20%2C%20and%20%22test%22%20." rel="noopener ugc nofollow" target="_blank"> <strong class="kv io">构造函数</strong>。</a></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ox"><img src="../Images/1a194a44443684e7304351f2b00e62ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1nHzC6mqZnAH3CkI125yxQ.png"/></div></div></figure><p id="0951" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有趣的部分来了。我不会在这里退任何东西。我用的是<a class="ae ks" href="https://medium.com/@allansendagi/javascript-fundamentals-this-keyword-481722806d20" rel="noopener"> <strong class="kv io">这个</strong> </a>就是这样。</p><h2 id="dec4" class="nl nm in bd nn no np dn nq nr ns dp nt lc nu nv nw lg nx ny nz lk oa ob oc od bi translated">我们正在建造一个精灵。</h2><p id="a50e" class="pw-post-body-paragraph kt ku in kv b kw oe jo ky kz of jr lb lc og le lf lg oh li lj lk oi lm ln lo ig bi translated">那么这是如何工作的呢？</p><p id="8a66" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我这么做了:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pn"><img src="../Images/e355e41204206d07430e7b7f25108413.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SFEqKUzPauGLSo6RIzUepg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">如果我运行这个，我会得到一个类型错误— <em class="po">无法读取undefined的属性‘name’。</em></figcaption></figure><p id="0895" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我运行这个，我会得到一个类型错误— <em class="ms">无法读取undefined的属性‘name’。</em></p><p id="f610" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">而这是因为构造函数是这样构建的:为了使用构造函数，你需要在Javascript中使用<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> new </strong> </a>关键字。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pp"><img src="../Images/5dcc370d5adb6900c05dc70a1363ce30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*elIY_krvy__7s_XN0WTl0A.png"/></div></div></figure><p id="6c00" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们看到这神奇地起作用了。但这是为什么呢？<br/>那是因为Javascript中的new关键字自动为我们返回对象，并创建了elf构造函数。</p><blockquote class="md"><p id="051c" class="me mf in bd mg mh mi mj mk ml mm lo dk translated">任何使用<strong class="ak"> new </strong>关键字调用的函数都被称为构造函数。</p></blockquote><p id="bc86" class="pw-post-body-paragraph kt ku in kv b kw mn jo ky kz mo jr lb lc mp le lf lg mq li lj lk mr lm ln lo ig bi translated">任何使用<strong class="kv io"> new </strong>关键字调用的函数都被称为构造函数。</p><p id="6a5f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们以前也见过构造函数。类似于<strong class="kv io">数字()</strong>、<strong class="kv io">对象()</strong>或<strong class="kv io">函数()</strong>——大写字母，但它们是函数。</p><p id="989e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这些都是构造函数。您可以通过使用<strong class="kv io"> new </strong>关键字来调用它们。所以作为一个规则，所有的构造函数都应该以大写字母开头，让其他程序员知道你需要使用new关键字来调用这个函数。</p><p id="8ce5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们看看如何使用Javascript自带的构造函数创建一个elf。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pq"><img src="../Images/80ba3467927fe863f1552c498646c078.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WVfMDuLwlrqWDXEBpgbjrQ.png"/></div></div></figure><p id="f4ce" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">函数构造函数简单地允许我们使用<strong class="kv io"> new </strong>关键字并为我们创建这些对象。</p><p id="58bf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是现在让我们在这里实现攻击函数。</p><p id="879d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因为我们使用了<strong class="kv io"> new </strong>关键字，它自动为我们返回一个Elf对象并创建了我们的Elf构造函数，所以我们创建了一个新对象。因为调用了这个函数，所以创建了一个新的执行上下文。</p><p id="699d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">由于这是一个我们正在运行的函数— <strong class="kv io"> Elf </strong>，并且创建了一个新的执行上下文，这意味着我们自动获得了附加到它上面的<strong class="kv io"> this </strong>变量。请记住，我们调用的每个函数都会得到<strong class="kv io">和</strong>参数。</p><div class="mt mu gp gr mv mw"><a href="https://medium.com/@allansendagi/javascript-foundation-function-invocation-arguments-keyword-variable-environment-scope-chain-97d4888cf319" rel="noopener follow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd io gy z fp nb fr fs nc fu fw im bi translated">Javascript基础——函数调用、参数关键字、可变环境、作用域链。</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">程序只是简单的分配内存，比如，给一个变量赋值，然后运行一个函数做一些事情…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">medium.com</p></div></div><div class="nf l"><div class="pr l nh ni nj nf nk km mw"/></div></div></a></div><p id="c1d1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有趣的是，当我们使用<strong class="kv io"> new </strong>关键字时，而不是像通常那样<strong class="kv io"> this </strong>指向窗口对象，当一个新的执行上下文被创建时，<strong class="kv io"> new </strong>关键字改变了this 所指向的<strong class="kv io">。相反，<strong class="kv io">新的</strong>关键字会说，我要你把这个</strong>指向我们刚刚创建的对象。所以这就成了<strong class="kv io">彼得。</strong></p><p id="0d4f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们看看当我们删除<strong class="kv io">新的</strong>关键字时会发生什么。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ps"><img src="../Images/9d37935da56ccd4bc41c98cbfa0706ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FiRYSdTw76pGKAVf3IxZeQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">移除新关键字</figcaption></figure><p id="d822" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是因为如果没有<strong class="kv io"> new </strong>关键字，我们就不会返回那个对象，也不会将<strong class="kv io"> this </strong>赋值给调用我们的对象。</p><p id="7cfb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以<strong class="kv io">新的</strong>关键字在幕后为我们做了很多工作，以便让它工作。<br/>所以我们使用<strong class="kv io"> new </strong>关键字是非常重要的，这就是为什么我们要用大写字母向其他程序员表示我们需要使用<strong class="kv io"> new </strong>关键字，否则它将无法工作。</p><blockquote class="md"><p id="7a61" class="me mf in bd mg mh mi mj mk ml mm lo dk translated">这个功能如此强大的原因是Javascript中的每个函数都有一个原型属性。</p></blockquote><p id="67bd" class="pw-post-body-paragraph kt ku in kv b kw mn jo ky kz mo jr lb lc mp le lf lg mq li lj lk mr lm ln lo ig bi translated">这个功能如此强大的原因是Javascript中的每个函数都有一个原型属性。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pt"><img src="../Images/20566dc7187dea2085b49b1c2cd5537c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*w7tBjCPJrytmVX92.png"/></div></div></figure><p id="c73e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">函数是一种特殊类型的对象。它是一个可调用的对象，有可以调用的代码，一个可选的名字，属性，如果我们想给它，我们可以访问。</p><p id="5f2f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是我们也获得了用每个新函数创建的原型{}。这个原型属性对于任何常规函数都是毫无用处的，但是当我们有构造函数时，这个原型最终会变得有用。像<strong class="kv io"> Function </strong>这样的本地构造函数附带了调用、应用和绑定等功能。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi pu"><img src="../Images/f6befa14d585147f67e79e5869996bf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/0*JZ1Zfb8VFjP2IKy0.png"/></div></figure><p id="b3d1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">数组带有<strong class="kv io"> reduce </strong>，<strong class="kv io"> map </strong>，<strong class="kv io"> forEach </strong>，因为它们是在数组构造函数之外构建的。</p><h2 id="274b" class="nl nm in bd nn no np dn nq nr ns dp nt lc nu nv nw lg nx ny nz lk oa ob oc od bi translated">在我们的例子中，我们可以将我们自己的添加到原型中。</h2><p id="003d" class="pw-post-body-paragraph kt ku in kv b kw oe jo ky kz of jr lb lc og le lf lg oh li lj lk oi lm ln lo ig bi translated">所以现在我们可以做:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pv"><img src="../Images/11214e8bfee16f4595ef1dc5178e5363.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1hSMivnqiQbIgOPucoUnsA.png"/></div></div></figure><p id="a869" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们能够使用<strong class="kv io">原型</strong>为我们的Elf添加功能。</p><p id="e470" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">回顾一下，</p><p id="137e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们能够使用构造函数而不是像<strong class="kv io"> Object.create() </strong>这样的东西来创建这个神奇的函数。我们神奇的函数返回一个新函数，并修改这个对任何对象调用我们的意义。因此，代替全局对象，<strong class="kv io">这个</strong>现在将指向调用对象；<strong class="kv io">彼得</strong>和<strong class="kv io">山姆</strong>。</p><p id="ec46" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">此外，因为这是一个构造函数，我们有原型函数，我们可以附加东西。</p><p id="3a84" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这样当彼得.攻击()被调用时，它就工作了。请记住，Peter没有将<strong class="kv io"> attack() </strong>作为自己的方法，但是它将沿着原型链向上，在那里它将找到攻击。</p><p id="c8aa" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在<strong class="kv io">彼得</strong>和<strong class="kv io">山姆</strong>都能够从内存的同一个位置使用<strong class="kv io">攻击()</strong>。我们不需要在内存中的多个位置复制<strong class="kv io"> attack() </strong>，我们只需要写一次，这两个小精灵就会指向同一个内存空间。</p><p id="bc62" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">美妙之处在于，随着游戏的发展，我可以不断添加功能或方法。</p><p id="2358" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">注:</strong>如果我们把这个改成箭头函数会怎么样？</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pw"><img src="../Images/542d0b5917238b4b0edf2dceba7bbb2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TRZWQW0tG1nArZClOUmXHg.png"/></div></div></figure><p id="7c1e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们变得不明确。</p><p id="426e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">记住，箭头函数是词汇范围的。它们根据它们被写入的位置来定义这个。而<strong class="kv io">这个</strong>在这种情况下是全局对象，因为谁在调用<strong class="kv io">这个</strong>，除了全局对象之外，周围没有其他对象。</p><p id="fc91" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是通过使用动态限定作用域的常规函数，<strong class="kv io">这个</strong>将根据调用它的人而改变。这是一个你不想使用箭头函数的地方，因为你不想要一个词汇范围的<strong class="kv io"> this </strong>。</p><h2 id="ae6f" class="nl nm in bd nn no np dn nq nr ns dp nt lc nu nv nw lg nx ny nz lk oa ob oc od bi translated">让我们更深入地研究构造函数</h2><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi px"><img src="../Images/840d405ddf6191969adb5befd514221f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dLQmdx7b_ke3IcgKQ7FsIw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">console.log( <strong class="bd nn"> this </strong>)给我们的Elf是一个空对象</figcaption></figure><p id="82d1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因为我们没有添加任何东西，所以这里没有属性，我们只是创建一个空对象。</p><p id="ed85" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是如果我将<strong class="kv io"><em class="ms">console . log(this)</em></strong>下移，我们会看到在添加了<strong class="kv io">名称</strong>和<strong class="kv io">武器</strong>属性之后，我们就可以访问它们了。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi py"><img src="../Images/8c87395bcafe22fbb4418718b086a33c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fu0_0klcHjHEKfZ3fVIGSg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">演示<strong class="bd nn">这个</strong></figcaption></figure><p id="7e3f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有意思的是，现在如果我给我们的构造函数添加一个<strong class="kv io"> var q=6 </strong>，我们将无法把它添加到我们的elf对象中。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pz"><img src="../Images/23660654757f5b5b4e04c4d7d2614bb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PACnngmU-EhTsTFEUrNBCg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">我们只能使用<strong class="bd nn">这个</strong>关键字向Elf添加属性</figcaption></figure><p id="1296" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">使用构造函数，我们可以向对象添加属性的唯一方法是使用<strong class="kv io"> this </strong>关键字。</p><p id="38fe" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们还讨论了构造函数如何自动为我们创建原型链。让我们来测试一下。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi qa"><img src="../Images/b09051eef026f6490aef4dd01b238389.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q0XrZg1aidPQ-6JK8wOChQ.png"/></div></div></figure><p id="b809" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们看到Elf是我们的原型，因为<strong class="kv io"> __proto__ </strong>指向了Elf的原型。记住，<strong class="kv io"> Elf.prototype </strong>是因为<strong class="kv io">新的</strong>关键字而为我们创建的。</p><p id="5d37" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，当我们最终在原型上添加类似于<strong class="kv io"> attack() </strong>的项目时，我们现在有了指向<strong class="kv io"> Elf.prototype </strong>的<strong class="kv io"> __Proto__ </strong>，其中包含了<strong class="kv io"> attack() </strong>方法。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi qb"><img src="../Images/f387225d9c3b403d1f1282e04502b61d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hceq3FikqfuZJYP1Xdhksw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">彼得__proto__指向精灵原型</figcaption></figure><p id="50d3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在如果我做<strong class="kv io"> Elf.prototype </strong>，我们看到的是同样的事情。我们在这个原型中有<strong class="kv io"> attack() </strong>函数。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi qc"><img src="../Images/ba7a797043f0a692ca647f0170721a5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WzhT7OhDoHyj5lA3yNl5TQ.png"/></div></div></figure><p id="5508" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我们在添加原型之前使用console.log:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi qd"><img src="../Images/c36710e568a81f6d8b715b73803af135.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3nQnof4mCMUq4B_UG974Yw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">这是一个空的物体</figcaption></figure><p id="8dd0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">记住，我们创建的每个函数都有这个原型属性。但是只有<strong class="kv io">构造函数</strong>对这个原型对象有用。</p><p id="1c2d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是现在如果我做<strong class="kv io"> Peter.prototype </strong>会怎么样？</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi qe"><img src="../Images/709f0b55bb8fb8b26eaf24d4876e1fc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G8NUFBdCns5b0TRGNWmVUw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">彼得。原型给了我们未定义的</figcaption></figure><p id="474e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我不确定。这是因为<strong class="kv io">彼得</strong>不是一个函数。彼得是一个物体。只有函数可以访问原型。</p><p id="f65a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">注意:</strong><br/>OOP中的一个陷阱是这样的:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi qf"><img src="../Images/ac19a19b2eb562a0777c3f54e13dab8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t2JBGouo3yAW4fo1GFWQ-Q.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">方法内部的函数仍然是函数内部的函数</figcaption></figure><p id="7c46" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这里，如果我单击运行，我得到未定义的<strong class="kv io"/>。</p><p id="b312" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为什么会这样？<br/>方法内部的函数是函数内部的函数。这意味着<strong class="kv io">这个</strong>不是分配给对象本身，而是这次分配给窗口对象。有几种方法可以解决这个问题:</p><h1 id="15d7" class="oj nm in bd nn ok ol om nq on oo op nt jt oq ju nw jw or jx nz jz os ka oc ot bi translated">绑定()</h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi qg"><img src="../Images/8cb171013bf741b998226dd7e9f94faa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AaavU5lkzM1eVI30Ikgx4Q.png"/></div></div></figure><p id="7f07" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">或者我们可以参考一下<strong class="kv io">这个</strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi qh"><img src="../Images/54838036e739d272f57d958f2b096b37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Xd59KT2rpofrALW2mKYGA.png"/></div></div></figure><h1 id="66e4" class="oj nm in bd nn ok ol om nq on oo op nt jt oq ju nw jw or jx nz jz os ka oc ot bi translated">我们到了吗？或者这个代码有什么问题？</h1><p id="8478" class="pw-post-body-paragraph kt ku in kv b kw oe jo ky kz of jr lb lc og le lf lg oh li lj lk oi lm ln lo ig bi translated">这段代码的问题是<strong class="kv io">原型</strong>有点奇怪。有点难以理解吧？</p><p id="7be6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">除非你真正了解你的原型继承和Javascript如何工作，否则这段代码不容易理解，而大多数人都不了解。这很快就会变得非常混乱。没有多少人喜欢这种编码风格。</p><p id="a6d0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在旧的代码库中，你可能会发现这种风格的编程，尤其是当他们在做OOP的时候。问题是OOP完全是关于类的概念。在这段代码中，这里没有类，没有大写字母，这就是为什么在语言中添加了<strong class="kv io"> Object.create() </strong>来避免这种麻烦，只使用纯原型继承。<br/>但是<strong class="kv io">这个</strong>和<strong class="kv io">新的</strong>关键字的想法很大程度上受到了OOP的启发，尤其是对于像Java这样的语言。</p><h1 id="3d47" class="oj nm in bd nn ok ol om nq on oo op nt jt oq ju nw jw or jx nz jz os ka oc ot bi translated">用Javascript面向对象的最后一步。</h1><p id="6dea" class="pw-post-body-paragraph kt ku in kv b kw oe jo ky kz of jr lb lc og le lf lg oh li lj lk oi lm ln lo ig bi translated">那么我们该如何改善这一点呢？让我们添加类，尽可能地接近Javascript的OOP。</p><h2 id="5ef9" class="nl nm in bd nn no np dn nq nr ns dp nt lc nu nv nw lg nx ny nz lk oa ob oc od bi translated">Javascript中的一切都是对象。</h2><p id="920d" class="pw-post-body-paragraph kt ku in kv b kw oe jo ky kz of jr lb lc og le lf lg oh li lj lk oi lm ln lo ig bi translated">让我们尝试一些东西。我们现在理解了构造函数。所以如果我做了:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi qi"><img src="../Images/14001217c7e1d8da3511f6e0263f0b76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vUragQGQxLBDkCwatVSZHQ.png"/></div></div></figure><p id="b540" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Javascript为我们创建了第5个<strong class="kv io"/>。</p><p id="f473" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">它是一种对象。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi qj"><img src="../Images/2a8f5d60ee24e76999247aa9beb16b87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pXIC35_9adKz0BdmXAgh0A.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">a是对象的类型，因为我们使用了构造函数</figcaption></figure><p id="de1b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这不同于简单地说:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi qk"><img src="../Images/5e384e5a8ba68e7433beb954af915e6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ls_tBU-DW6MTUkSgi18byg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">b的类型是一个数字</figcaption></figure><p id="6100" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ql"><img src="../Images/63b4e52649bee67e881b32b907084235.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zeaad4PfU2l-rFnzYiXxwg.png"/></div></div></figure><p id="6851" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们看到的是，在Javascript中有两种不同的方式来构造这些东西。</p><p id="98a1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然而，如果我只做两个等号，我会因为类型强制而得到true。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi qm"><img src="../Images/f723272ba63fdd77cb15bc32d19fe7a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qy6oZOIPjXWNk7KWPpbhxg.png"/></div></div></figure><p id="b439" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有趣的是，现在如果我做了<strong class="kv io"> b.toString </strong>，我就可以在<strong class="kv io"> b </strong>上使用所有这些方法，尽管我们看到<strong class="kv io"> b </strong>是一个原始类型。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi qn"><img src="../Images/0d3aabdc3182e14aab8ef8ccfa97ebac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vPB4mgmlOWknwc9iWaUi8A.png"/></div></div></figure><p id="a2ac" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是因为在Javascript中，当我们给一个变量<strong class="kv io"> (var b=5) </strong>赋值时，Javascript会在内部<strong class="kv io">构造</strong>我们添加的数字，这样我们就可以访问所有这些方法。这就是我们如何使用像<strong class="kv io"> toString </strong>、<strong class="kv io">fixed</strong>这样的东西。甚至在字符串值或字符串基元上，我们也可以有这样的方法。</p><p id="2131" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Javascript看到您想要使用对象方法，所以它自动假设您指的是对象而不是原语，所以它在内部运行构造函数对象。这也是像<strong class="kv io"> new Date() </strong>这样的事情的工作方式。</p><p id="7d85" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">你在创建对象，这很有用，因为它们有一个内置的原型，这样我们就可以运行不同种类的方法。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi qo"><img src="../Images/2b6068fa94ae11bf50bcd40eb50d45f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8CfTCJkHEjSoWrVCWF4EXw.png"/></div></div></figure><p id="7865" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以从技术上讲，在Javascript中，一切都是对象。</p><blockquote class="md"><p id="8a8b" class="me mf in bd mg mh mi mj mk ml mm lo dk translated">所以是的，从技术上讲，在Javascript中，一切都是对象。</p></blockquote><p id="679c" class="pw-post-body-paragraph kt ku in kv b kw mn jo ky kz mo jr lb lc mp le lf lg mq li lj lk mr lm ln lo ig bi translated">除了<strong class="kv io">空</strong>和<strong class="kv io">未定义</strong>之外，所有东西都有一个构造函数。我们为所有的东西都准备了构造函数，这样我们就有了可以对它们使用的方法。</p><h1 id="eda3" class="oj nm in bd nn ok ol om nq on oo op nt jt oq ju nw jw or jx nz jz os ka oc ot bi translated">Javascript中的终极OOP。</h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi qb"><img src="../Images/f387225d9c3b403d1f1282e04502b61d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hceq3FikqfuZJYP1Xdhksw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">构造函数</figcaption></figure><p id="874e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">还记得我们的构造函数吗？没有人真正喜欢添加方法的原型方式。所以有了ES6，Javascript终于引入了<strong class="kv io">类</strong>关键字。</p><blockquote class="md"><p id="bbb1" class="me mf in bd mg mh mi mj mk ml mm lo dk translated">OOP是基于<strong class="ak">类</strong>关键字的想法而创建的。一个班级是我们想要被创造的蓝图。</p></blockquote><p id="ae0d" class="pw-post-body-paragraph kt ku in kv b kw mn jo ky kz mo jr lb lc mp le lf lg mq li lj lk mr lm ln lo ig bi translated">OOP是根据<strong class="kv io">类</strong>关键字的想法创建的。一个班级是我们想要被创造的蓝图。</p><p id="ac60" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们看看这是如何工作的。</p><p id="8f6c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们可以简单地定义我们的Elf类:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi qp"><img src="../Images/c54e87ca9cae0c6c0d1b9969fc89642a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O9A1rztwXUDUHggPt5-5cg.png"/></div></div></figure><p id="8c93" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，正如OOP所建议的，我们希望将我们的功能保留在这个盒子里——<strong class="kv io">类</strong>。我们的属性、方法、状态和所有动作都在一个包含的环境对象中。</p><p id="b1c3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">每次实例化时，我们都使用<strong class="kv io"> new </strong>关键字和类。</p><p id="4306" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这才是OOP真正的妙处。我们正在模拟现实生活场景。我们正在创建一个精灵的职业，这是我们希望精灵成为的样子的蓝图。</p><p id="0d66" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">精灵有名字。他们有武器。他们也可以像<strong class="kv io"> attack() </strong>一样对这些属性进行操作。您可以继续向保存整个Elf对象的相同位置添加方法。</p><p id="1d1e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">任何时候我们需要更新一些东西或者改变或者增加一个方法，我们只需要在这里改变它，所有Elf的实例都会得到更新。</p><p id="e4b7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">实例</strong>是我们使用类的时候会经常听到的一个常用词。</p><p id="d247" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当我们调用一个类并在该类之外创建一个对象时，就会发生一个实例。例如，彼得是Elf的一个实例。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi qq"><img src="../Images/6f9024246496efe23023f59053166b7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WgeLvVYDbTMrsxdYjVTEew.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">彼得是小精灵的一个实例</figcaption></figure><p id="cfec" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，<strong class="kv io"> Instanceof </strong>是我们可以用来说我们正在创建一个类的实例的语言。</p><p id="3037" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这个带有<strong class="kv io">新</strong>关键字的叫做<strong class="kv io">实例化</strong>。我们正在实例化一个类。</p><p id="4698" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我删除<strong class="kv io">新的</strong>关键字，我会得到一个非常详细的错误。<em class="ms">没有new </em>就不能调用类构造函数。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi qr"><img src="../Images/9d5b10032510e2e4d197a10fef0f0358.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Xx7qpI_O5atULaOFIDqXQ.png"/></div></div></figure><p id="52d0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在你知道了。在这里，我们终于有OOP了，是吗？</p><p id="ae80" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">不完全是。</p><blockquote class="md"><p id="cf38" class="me mf in bd mg mh mi mj mk ml mm lo dk translated">这就是我们所说的<a class="ae ks" href="https://en.wikipedia.org/wiki/Syntactic_sugar#:~:text=In%20computer%20science%2C%20syntactic%20sugar,style%20that%20some%20may%20prefer." rel="noopener ugc nofollow" target="_blank">句法糖</a>。实际上，我们仍然在使用原型继承。我们没有使用类，因为类在其他语言中工作。这是Javascript最接近类的方式。</p></blockquote><p id="1d20" class="pw-post-body-paragraph kt ku in kv b kw mn jo ky kz mo jr lb lc mp le lf lg mq li lj lk mr lm ln lo ig bi translated">这就是我们所说的<a class="ae ks" href="https://en.wikipedia.org/wiki/Syntactic_sugar#:~:text=In%20computer%20science%2C%20syntactic%20sugar,style%20that%20some%20may%20prefer." rel="noopener ugc nofollow" target="_blank">句法糖</a>。实际上，我们仍然在使用原型继承。我们没有使用类，因为类在其他语言中工作。这是Javascript最接近类的方式。</p><p id="65ae" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在引擎盖下，他们仍然使用<strong class="kv io">新的</strong>关键字，与<strong class="kv io">原型</strong>。</p><p id="f8e0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">那么我们为什么不从一开始就创建类呢？这难道不会让一切变得更容易吗？</p><p id="ff4f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因为课程不一定是解决所有问题的答案。而且正如语言的创造者所说:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi qs"><img src="../Images/ff7be361b6c9dc79cc479d82dafc04af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XNoN2UiHsy7aJFt45VAElA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">来源:从零到精通</figcaption></figure><p id="470d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Brendan Eich的任务是创建一种语言，吸引习惯于类和OOP概念的Java开发人员。<br/>但同时，他们想创造一种竞争性的语言。出于营销的目的，他们不能让它完全一样。</p><p id="1a2c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">他必须有创造力。他使用了原型继承，这与Java和C++等语言中类的工作方式不同。</p><blockquote class="md"><p id="b377" class="me mf in bd mg mh mi mj mk ml mm lo dk translated">在其他语言中，类是真实存在的。在javascript中，类仍然只是对象。</p></blockquote><p id="81d8" class="pw-post-body-paragraph kt ku in kv b kw mn jo ky kz mo jr lb lc mp le lf lg mq li lj lk mr lm ln lo ig bi translated">在其他语言中，类是真实存在的。在javascript中，类仍然只是对象——Javascript中的一切都是对象。</p><h2 id="1e75" class="nl nm in bd nn no np dn nq nr ns dp nt lc nu nv nw lg nx ny nz lk oa ob oc od bi translated">Javascript有类吗？</h2><p id="c5e0" class="pw-post-body-paragraph kt ku in kv b kw oe jo ky kz of jr lb lc og le lf lg oh li lj lk oi lm ln lo ig bi translated">是的，它们是句法糖。但是class关键字只是原型继承。</p><p id="b593" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">而有人称这个<a class="ae ks" href="http://theoryapp.com/javascript-inheritance-pseudoclassical-vs-prototypal/#:~:text=Pseudoclassical%20Inheritance,to%20build%20the%20inheritance%20chain.&amp;text=It%20also%20adds%20a%20method,is%20inherited%20in%20the%20instance." rel="noopener ugc nofollow" target="_blank">为伪古典继承</a>因为它不是真正的古典继承。</p><p id="ca61" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是看着这个，我希望你能看到我们是如何从重复的代码，越来越难维护到更有组织的东西。我们创建了这一组更易于维护和扩展的功能。</p><p id="3b72" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">顺便说一下，你可能会问自己，为什么我们不把attack()方法添加到构造函数中呢？这是因为每次我们使用<strong class="kv io"> new </strong>关键字并创建或实例化一个类时，构造函数都会运行，因为每个精灵都有一个唯一的名字，也许还有一个唯一的武器。</p><p id="7514" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是attack()由该类的所有实例共享</p><p id="542d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我们把攻击转移到构造函数，那会占用内存空间。</p><p id="afbf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">而不是从每个对象创建一个攻击函数，如果我们添加到构造函数中，我们会这样做，这是我们试图避免的事情。相反，我们只有一个。所有这些实例都可以访问的一个位置中的一个函数。</p><h1 id="20ba" class="oj nm in bd nn ok ol om nq on oo op nt jt oq ju nw jw or jx nz jz os ka oc ot bi translated">Object.create Vs类</h1><p id="1c13" class="pw-post-body-paragraph kt ku in kv b kw oe jo ky kz of jr lb lc og le lf lg oh li lj lk oi lm ln lo ig bi translated">有热爱类的人，也有从来不想用类的人。有些人想避免使用<strong class="kv io"> new </strong>关键字和<strong class="kv io"> this </strong>关键字，因为他们说这会引起太多的混淆。</p><p id="09a0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以这只是个人喜好。备受尊敬的程序员热爱类。其他备受尊敬的程序员讨厌类。而且没有对错之分。</p><p id="eb35" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是需要注意的是，我们用类做的所有事情都可以用<strong class="kv io"> Object.create() </strong>来完成。</p><p id="a200" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有了<strong class="kv io"> Object.create() </strong>我们实际上拥有了我们需要的一切，一点也不混乱。我们能够创建这些原型链，而不用假装我们有类</p><p id="4010" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有些人把<strong class="kv io">叫做Object.create() </strong>纯粹的原型继承，因为这是纯粹的方式，而不是假装我们是别人。</p><p id="11b3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">你用什么由你决定。大多数Javascript社区不像类语法那样使用<strong class="kv io"> Object.create() </strong>。</p><p id="a58c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在大多数情况下，尤其是使用OOP原则的新代码库，他们会使用<strong class="kv io">类</strong>，但是Javascript的美妙之处在于它是多范例的。它允许我们根据手头的问题和我们与其他程序员的团队动态，有很多选择来编码我们想要的方式。</p><h1 id="8e0b" class="oj nm in bd nn ok ol om nq on oo op nt jt oq ju nw jw or jx nz jz os ka oc ot bi translated">操纵this关键字的4种方法</h1><ol class=""><li id="8c79" class="lp lq in kv b kw oe kz of lc qt lg qu lk qv lo lu lv lw lx bi translated">第一个是这个关于<strong class="kv io">新</strong>绑定的想法。此绑定用于构造函数。</li></ol><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi qw"><img src="../Images/4498771b1a868dd1f4dc24fc92b40b35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NpwnAcE8SzOrNnA2Hl56Ag.png"/></div></div></figure><p id="3b2e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> new </strong>绑定允许我们将<strong class="kv io"> this </strong>分配给我们实例化的对象。因此<strong class="kv io"> person1 </strong>将是this关键字。</p><p id="8bde" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是我们操纵这个关键字的一种方式。</p><p id="4198" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">2.另一种方式叫做<strong class="kv io">隐式绑定。</strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi qa"><img src="../Images/0498ee96a9523043fe69e02e86b72277.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*La3h0RPWNLW7IclmOVv4Yw.png"/></div></div></figure><p id="7dbd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里的<strong class="kv io">这个</strong>就是指<strong class="kv io">人</strong>。这就是隐式绑定。是最常见的一种。</p><p id="0d45" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">3.我们还看到了显式绑定。这是我们决定这个关键字应该指的是什么的时候。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi qr"><img src="../Images/b525a36c3b2e770fd4433e66d74784b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mgprSTidkKMRna5ZMlS2ng.png"/></div></div></figure><p id="fb80" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最初，<strong class="kv io">这个</strong>是指<strong class="kv io">人</strong>就像我们上面看到的。现在，如果我们想让<strong class="kv io">这个</strong>引用窗口对象，我们可以明确地告诉它<strong class="kv io">将</strong>绑定到什么。我们说绑定到窗口对象。</p><p id="00f8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">显式绑定使用<strong class="kv io">调用</strong>，<strong class="kv io">绑定，</strong>和<strong class="kv io">应用</strong>来显式地告诉程序嘿这是我想要的<strong class="kv io">这个</strong>是什么。我希望是窗户。</p><h2 id="fb64" class="nl nm in bd nn no np dn nq nr ns dp nt lc nu nv nw lg nx ny nz lk oa ob oc od bi translated">4.这个和箭头功能。</h2><p id="e2d0" class="pw-post-body-paragraph kt ku in kv b kw oe jo ky kz of jr lb lc og le lf lg oh li lj lk oi lm ln lo ig bi translated">有了箭头函数，我们了解到，与其他所有动态确定<strong class="kv io">这个</strong>作用域的情况不同——无论何时调用它，它都会被确定，有了箭头函数，我们可以进行词法作用域。那是我们写函数的地方，那是这个绑定到<strong class="kv io">的地方。</strong></p><p id="740c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以我可以这样做:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi qx"><img src="../Images/08e9dd73beeb8417b5c9e0fdad67d21f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dgWezbNffZIcSOroqQRHyg.png"/></div></div></figure><p id="1d26" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里一切正常，因为我们使用了箭头函数。如果我们不使用一个箭头函数，而只使用一个常规函数，那么，<strong class="kv io">这个</strong>就是我们通常不想要的窗口对象。</p><p id="ca3e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这一切都让我们能够驾驭<strong class="kv io">这个</strong>的力量。</p><h1 id="9fd0" class="oj nm in bd nn ok ol om nq on oo op nt jt oq ju nw jw or jx nz jz os ka oc ot bi translated">遗产</h1><p id="dbe3" class="pw-post-body-paragraph kt ku in kv b kw oe jo ky kz of jr lb lc og le lf lg oh li lj lk oi lm ln lo ig bi translated">OOP的一个核心是<strong class="kv io">继承</strong>——向下传递知识。</p><p id="d025" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">还记得一开始我们决定创造这个拥有所有这些角色的童话游戏吗？我们从精灵开始。但是你可以看到我们的目标是拥有很多东西，不仅仅是精灵。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi qp"><img src="../Images/c54e87ca9cae0c6c0d1b9969fc89642a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O9A1rztwXUDUHggPt5-5cg.png"/></div></div></figure><p id="4c76" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们希望有一只<strong class="kv io">龙</strong>、<strong class="kv io">骑士</strong>、<strong class="kv io">国王</strong>、<strong class="kv io">王后</strong>，也许还有一些魔术师。<br/>那么使用这个<strong class="kv io">继承</strong>的OOP原则，我们如何用我们已经完成的工作来完成它呢？</p><p id="ac01" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">假设我想要一个新的玩家，这个玩家是一个叫史莱克的奥尔加。我该如何着手创造这个奥尔加呢？<br/>当然，我能做的最糟糕的事情就是复制并粘贴这段代码来创建一个Olga类。</p><p id="4a32" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">复制和粘贴代码是我们想要避免的。</p><p id="6d81" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们的一个选择是复制elf并扩展它。为了复制我们已经拥有的内容，我们可以使用spread运算符。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi qy"><img src="../Images/8a7cf37c8e9903d87a661683475bef07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p7MYGg9b7CrdrraFP-2KyA.png"/></div></div></figure><p id="023d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这里，我将彼得复制到Ogre变量中。</p><p id="9076" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是现在，如果我做<strong class="kv io"> Orge__proto__ </strong>的话，我会得到基本对象。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi qz"><img src="../Images/388d3f4f3eb13c615cdffd1fd63da82c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k-m1iLw3HYjmUq88sxxXig.png"/></div></div></figure><p id="0605" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">彼得呢。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ra"><img src="../Images/ca8ac466404cda55601f827b4aca3d2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x1CFeuuXtVOw-taloxepdA.png"/></div></div></figure><p id="472a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我得到了<strong class="kv io">精灵</strong>。</p><p id="2db1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以我克隆了这个对象，但是<strong class="kv io">食人魔</strong>没有<strong class="kv io">精灵</strong>作为基类。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi rb"><img src="../Images/12571d0619794fbc95540a82391069a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*406vmIJos0rXln7DruwP_Q.png"/></div></div></figure><p id="6b9e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这些对象引用的不是内存中的同一个位置。它们是完全不同的东西。但是我也丢失了原型继承链。</p><p id="65df" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我连<strong class="kv io"> Orge.attack()都不会。</strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi rc"><img src="../Images/62a55054dfb69af89436b2b0ecd827f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9dMe-qBAV-DhCyyspFzqmQ.png"/></div></div></figure><p id="4d61" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我没有<strong class="kv io">攻击()</strong>——所以这是个问题。</p><p id="f4df" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们如何扩展这一点？这就是遗传的用处。在我们有这个类语法之前，用Javascript做起来真的很难。它包含了许多丑陋的原型代码。</p><p id="ce8b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在我们的例子中，我们稍微改变了命名。我们的超类现在是<strong class="kv io">角色。从这个超类，Elf <strong class="kv io">扩展了</strong>——这是一个关键字<strong class="kv io">字符</strong>类。</strong></p><p id="5e13" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这个东西叫做<a class="ae ks" href="https://hacks.mozilla.org/2015/08/es6-in-depth-subclassing/" rel="noopener ugc nofollow" target="_blank">在OOP中子类化</a>。</p><p id="2e49" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">也就是说，我们有一个基类或超类和子类。我们想从<strong class="kv io">角色</strong>类继承它的所有属性和方法，并用<strong class="kv io"> Elf </strong>扩展它来创造一些新的东西。</p><p id="a2dd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们把这个变得更有趣。假设精灵有一个额外的属性——一个<strong class="kv io">类型</strong>属性，让我们知道他们是什么类型的精灵。</p><p id="3fc2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们将如何着手做那件事？<br/>让我们添加类型属性。如果我添加一个构造函数，我这样做，type = type，这行得通吗？</p><p id="0b8b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们要实例化Elf类，给它起名字和武器；我们也想拥有这种类型。所以也许我们会有第三个参数。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="ab gu cl rd"><img src="../Images/e05739f82e953c7e023c120121f9a9d2.png" data-original-src="https://miro.medium.com/v2/format:webp/1*7mhGscbqkyp0lxP7qLAdCw.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated"><strong class="bd nn">类Elf扩展字符</strong>的意思是设置prototype __proto__指向字符。精灵现在有一个原型链到角色。</figcaption></figure><p id="3863" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> <em class="ms">必须叫超…..</em> </strong></p><p id="11e7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这就是说，为了让我们有自己的构造函数，并且能够使用<strong class="kv io">这个</strong>，并且知道<strong class="kv io">这个</strong>指的是什么，我们需要调用<strong class="kv io"> super </strong>，这里是<strong class="kv io"> Elf </strong>而不是<strong class="kv io">字符，</strong>我们有一个特殊的关键字叫做<strong class="kv io"> super。</strong></p><p id="b5ee" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">通过在构造函数内部做<strong class="kv io"> super </strong>，它说调用<strong class="kv io"> Elf </strong>的超类，也就是<strong class="kv io">角色。</strong>所以它会调用<strong class="kv io">角色</strong>，这样我们就可以创建<strong class="kv io"> this.name </strong>和<strong class="kv io"> this.weapon </strong>。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi re"><img src="../Images/8f06cea79c233e993bcbcf117f35d171.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*twwSPu0KIAgcaIms13C01A.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">在super里面，我们要通过它的<strong class="bd nn">名字</strong>和<strong class="bd nn">武器</strong>。</figcaption></figure><p id="023e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，这是标准的，尤其是基于类的语言，其中<strong class="kv io"> super </strong>是指超类。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi rf"><img src="../Images/47044bb25b77a39ad409f054d68a9f6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wOh0FwuVwPvtRRFRrvkDzQ.png"/></div></div></figure><p id="6d2a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因为为了在构造函数内部使用这个关键字，当我们扩展某个东西的时候，我们必须先调用super。<br/>这样如果我把<strong class="kv io"> console.log() </strong>移动到下面并运行，我就有了Elf，它附带了<strong class="kv io">名称</strong>和<strong class="kv io">武器</strong>。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi rg"><img src="../Images/00d9454f6c1fab75b7a0944e0e8e6e1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j6NLdIATIL37xHf1QlEHnA.png"/></div></div></figure><p id="2255" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是因为当super运行构造函数时，我们现在有了一个具有这些属性的character实例，我们可以使用this.type向它添加类型。</p><p id="474f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，在构建过程的最后，我们已经设置好了所有的属性。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi qc"><img src="../Images/3b554e21efa2cf1b7a355cc544d027a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gJj86eIPSG2eZTSZK7yoeQ.png"/></div></div></figure><p id="dc8f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">记住这个关键词简单的说我是谁我是谁？谁在叫我？在这种情况下，我们使用<strong class="kv io">新的</strong>关键字，这样<strong class="kv io">这个</strong>将被设置为Elf。</p><p id="b51b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是我们制作这个视频的初衷是想创造一个<strong class="kv io">食人魔。因此，让我们创建另一个类。</strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi rh"><img src="../Images/546997f1d9c9af94147157c25d0249b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sxZZPrymw8mDyTgcjzjDtg.png"/></div></div></figure><p id="c2ab" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我在这里做<strong class="kv io"> makeForte() </strong>并运行它，我就能够在Shrek上使用<strong class="kv io"> makeForte() </strong>方法或函数。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ri"><img src="../Images/986f674f1c01a419f74f6ceaf76963e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7pHKRAE5QssTOAjhUcRGgA.png"/></div></div></figure><p id="2b20" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是如果我让Dolby make forte，我会得到一个错误。</p><p id="0146" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们能够保持我们的代码整洁有序，并扩展我们的基本角色，在我们的游戏中创造所有这些不同的角色。我们可以重用我们以前编写的代码，但是也可以扩展这些类，使它们拥有自己独特的东西——像类型这样的属性，甚至像<strong class="kv io"> makeForte </strong>这样的方法。</p><p id="1cba" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">创建<strong class="kv io"> makeForte() </strong>意味着我们为<strong class="kv io"> Ogre </strong>类创建了自己的方法。但是我们在引擎盖下做的是我们扩展了原型。</p><p id="e311" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">和说<strong class="kv io">ogre . prototype . make forte()</strong>是一样的。在幕后，Javascript为我们创建了这个，因为我们使用了<strong class="kv io">类</strong>关键字。</p><p id="6b8e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">它看起来比不得不使用<strong class="kv io">原型</strong>要好得多，但正如我们之前看到的，它可能会有点令人困惑。除了它看起来更干净的事实之外，事情是有意义的，我们正在使用一些OOP原则，如<strong class="kv io">类</strong>、<strong class="kv io">扩展、</strong>和使用子类。</p><p id="c1b7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们还使用<strong class="kv io"> new </strong>关键字来创建实例。在底层，我们使用Javascript的原型继承在我们的对象之间建立这些原型链。</p><p id="3011" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了测试所有东西都连接正确，让我们做几个测试。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi qh"><img src="../Images/28750f99a013a1db9c6666b4414a793d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5HkQy5siy1-5j8t6m-Djdg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">Ogre是一个构造函数，所以我们使用Ogre.prototype，它是包含所有可用属性和方法的对象。</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi rj"><img src="../Images/9c896bea3fef44ab657a91d584cd76d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bMPOhKPeuCd2dewPsxPAIg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">character . prototype . isProtorypeOf(ogre . prototype)</figcaption></figure><p id="1868" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所有这些原型的东西令人困惑。使用is <strong class="kv io"> instanceof有一个更好的方法来检查这些连接。</strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi rk"><img src="../Images/f8a90aadca5a00a401fdf5e08b09b9cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vOCdJjkUEYJFBQVEp_Ur-Q.png"/></div></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi rl"><img src="../Images/259dcc21f49a210300996b7a3eb124aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jpRaC8rJYMASN40NnNs98A.png"/></div></div></figure><p id="16bd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们变得真实是因为杜比从角色一直延伸。</p><blockquote class="md"><p id="9907" class="me mf in bd mg mh mi mj mk ml mm lo dk translated"><strong class="ak">实例</strong>是当我们使用来自<strong class="ak">类的<strong class="ak"> new </strong>关键字时。我们创建一个类的实例。实例实际上是在创建该类的一个版本。</strong></p></blockquote><p id="2f0c" class="pw-post-body-paragraph kt ku in kv b kw mn jo ky kz mo jr lb lc mp le lf lg mq li lj lk mr lm ln lo ig bi translated"><strong class="kv io">实例</strong>是当我们使用来自<strong class="kv io">类的<strong class="kv io">新</strong>关键字时。我们创建一个类的实例。实例实际上是在创建该类的一个版本。</strong></p><p id="d39c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">继承</strong>——这就是我们用关键字<strong class="kv io">扩展</strong>所做的，从更高的类继承一些东西。Javascript中的继承并没有真正复制我们的功能。相反，它只是将原型链连接起来，这样你就不会创建副本和使事情变得低效。</p><p id="b79e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">相反，每当它在Ogre类中找不到什么的时候，它就会去查找Ogre超类，也就是character。</p><p id="a268" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以它使用原型继承在Javascript中创建了这种高效的链接。而且，与其他基于类的语言不同，Javascript只是对象s——它的对象继承自对象。没有技术课。另一方面，像Java这样的语言有实际的类。他们是一个东西。</p><p id="f2fb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">而类继承自类。有趣的是，当我们做类似<strong class="kv io">扩展</strong>的事情时，像Java和C++这样的语言实际上是在复制对象。而不是像Javascript那样，我们链接并引用对象。实际上在内存方面有一点效率。</p><h1 id="63cb" class="oj nm in bd nn ok ol om nq on oo op nt jt oq ju nw jw or jx nz jz os ka oc ot bi translated">公共与私人</h1><p id="744b" class="pw-post-body-paragraph kt ku in kv b kw oe jo ky kz of jr lb lc og le lf lg oh li lj lk oi lm ln lo ig bi translated">在许多有类的OOP语言中，私有和公共字段的概念非常重要。在Javascript中，我们没有这个。</p><p id="58be" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">对于任何不应该被访问的东西，从一个类甚至一个对象，我们会添加一个下划线，让其他人知道这是私有的。你不应该叫它。但是下划线实际上没有任何作用。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi rm"><img src="../Images/07d46c213ecd724f0254ae2bea463ff0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6r3vb1G31Pbm12mnxsaVkA.png"/></div></div></figure><p id="1763" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我仍然可以使用这个方法，甚至可能错误地将它重新赋值为false。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi rn"><img src="../Images/ec87596ce3f5c3e523acc0dc9747523c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8sJ6ans80X-2JVgb9dH8Qg.png"/></div></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi rg"><img src="../Images/fb73404d66a9a8f1eecc5fd4f750a966.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TGSX9fBhYooNY98iLRgSxw.png"/></div></div></figure><p id="c947" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以现在我已经覆盖了所有内容。</p><p id="9c74" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">像Java这样的其他语言有类似于<strong class="kv io"> private </strong>的东西——一个使东西私有的关键字，只能在类内部使用。</p><p id="de6f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是有一个<a class="ae ks" href="https://github.com/tc39/proposal-private-methods" rel="noopener ugc nofollow" target="_blank"> Ecma剧本提案</a>即将出台来解决这个问题。</p><p id="cabe" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Ecma脚本提案正处于第三阶段，是针对类字段声明的，可能还会有一些修改。</p><p id="8cf1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">目前，最接近于实现或拥有<strong class="kv io">私有</strong>状态或私有数据，只能在类内部访问，这是我们正在努力的方向。</p><h1 id="3373" class="oj nm in bd nn ok ol om nq on oo op nt jt oq ju nw jw or jx nz jz os ka oc ot bi translated">react.js中的OOP</h1><p id="e8d5" class="pw-post-body-paragraph kt ku in kv b kw oe jo ky kz of jr lb lc og le lf lg oh li lj lk oi lm ln lo ig bi translated">现在你可以在野外发现OOP了。</p><p id="0da5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">例如，如果您曾经使用过react.js，您可以看到他们是如何使用OOP原则的。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ro"><img src="../Images/227fa8d03196d13a13e05fab20efcbcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*w5pQsjjxANh3WfpDRA5Caw.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">来源:<a class="ae ks" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/</a></figcaption></figure><p id="bf52" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们现在可以查看代码并更好地理解它。我们创建了一个<strong class="kv io"> timer </strong>类，它扩展了<strong class="kv io">React . component . react . component</strong>是来自react团队的东西。他们已经为我们构建了这个类，它拥有所有这些特性，这样我们就可以使用自动为我们提供的<strong class="kv io"> render() </strong>之类的东西。</p><p id="5daf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们正在使用别人的代码，我们正在扩展那里的基本组件，以添加我们自己的功能。我们有接受道具的构造函数。我们有<strong class="kv io">state</strong>——我们的toggle类的状态，然后我们在这个类上创建我们自己的方法，比如<strong class="kv io"> tick() </strong>。</p><h1 id="a094" class="oj nm in bd nn ok ol om nq on oo op nt jt oq ju nw jw or jx nz jz os ka oc ot bi translated">面向对象的支柱</h1><p id="a730" class="pw-post-body-paragraph kt ku in kv b kw oe jo ky kz of jr lb lc og le lf lg oh li lj lk oi lm ln lo ig bi translated">我们从开发游戏的想法开始。利用这个想法，我们开始学习OOP，以及如何使用这种编程范式来改进我们的代码，使其更有组织性。不经意间，我们刚刚学会了OOP的四大支柱。</p><ol class=""><li id="5778" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo lu lv lw lx bi translated"><strong class="kv io">封装</strong>:记住在OOP之前我们有过程化编程。与过程式编程不同，在过程式编程中，我们用函数修改没有实际结构的数据，OOP将对象放在一个容器中，并将事物组织成模拟现实世界应用程序的单元。</li></ol><p id="8388" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是<strong class="kv io">封装</strong>。我们将代码包装到彼此相关的盒子中，以便这些盒子可以使用我们提供的方法和属性进行交互。这使得代码更容易维护，可重用性更高。这里有所有这些很好的类包，我们可以随时使用。</p><p id="c929" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">2.抽象:这仅仅意味着对用户隐藏复杂性。也就是创建更简单的接口，比如处理类，剩下的工作就是实例化类。比如一个<strong class="kv io">精灵</strong>的实例，它的所有属性和方法都已经存在了。</p><p id="7caf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">抽象的概念是，这是你可以使用的属性和方法，不用担心其他的。我会在幕后做所有的计算。这降低了复杂性，因为我们可以直接看到方法并理解一个<strong class="kv io">类</strong>能做什么。当我们有私有方法和私有变量时，抽象也会有所帮助——这是Javascript正在努力的方向。</p><p id="0da3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">3.继承:通过从其他对象继承，我们避免了重写相同的代码，并且通过共享方法节省了内存空间。</p><p id="9cd9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">继承是一个非常强大的概念，也是我最喜欢的OOP部分。</p><p id="e6f6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">4.<strong class="kv io">多态性。这个词本身意味着许多形式。多态性引起了激烈的争论。对它的含义有很多解释。但是这个想法是在不同的对象上调用相同的方法，每个对象以不同的方式响应。</strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi rp"><img src="../Images/a738e81373316acfef2de356298ff160.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iYxII1kBFZfdIVd5zuJhow.png"/></div></div></figure><p id="efdb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里先说<strong class="kv io">精灵</strong>和<strong class="kv io">食人魔</strong>职业的攻击方式不同。比如小精灵用<strong class="kv io">叫声</strong>攻击，<strong class="kv io">食人魔</strong>只是回<strong class="kv io"> arrrghhhh。</strong></p><p id="dbef" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在运行<strong class="kv io">杜比.攻击(wee) </strong>和<strong class="kv io">史莱克.攻击()</strong>给我们<strong class="kv io"> weeeeeee </strong>和<strong class="kv io"> arrrghhhh。</strong></p><p id="2c85" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是多态性的一个非常基本的方式，但是以多种形式出现的能力的概念是存在的。我们只是简单地覆盖了<strong class="kv io"> attack() </strong>方法，其中相同的方法对每种类型的类有不同的作用。或者我们可以做方法重载，也就是增加额外的特性或者额外的参数来增加方法的功能。</p><p id="e284" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">OOP中多态性的概念是，它能够根据对象的数据类型或类来不同地处理对象。现在，因为Javascript是一种动态类型语言，它限制了我们可以拥有的多态性的数量，但想法仍然是一样的。</p><p id="35ad" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为派生类重定义方法的能力，允许我们重用一些功能，但也可以为它们自己的对象和类定制方法。多态性很有用，因为我们不必一遍又一遍地复制和粘贴代码。我们可以使用超类的一些功能来适应我们自己的特定需求。</p><h2 id="6fb7" class="nl nm in bd nn no np dn nq nr ns dp nt lc nu nv nw lg nx ny nz lk oa ob oc od bi translated">这些是OOP的四大支柱。</h2><p id="ac57" class="pw-post-body-paragraph kt ku in kv b kw oe jo ky kz of jr lb lc og le lf lg oh li lj lk oi lm ln lo ig bi translated">我们一直在使用它们。在这些支柱的帮助下，我们实现了本节开始时设定的目标。</p><p id="012e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们创造了清晰易懂的代码。</p><p id="f0c4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">易于扩展的代码。</p><p id="438e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">易于维护，因为我们不必担心那些原型链。我们只是使用简单的类。一切都继承自超类。如果我们必须修改一个类，我们可以只在一个地方修改它。</p><p id="c401" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们还了解了内存效率，尤其是在Javascript中，对象使用引用而不是克隆和复制彼此。</p><p id="d10c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后，我们能够让我们的代码干燥。我们不会对每个对象一遍又一遍地重复自己。相反，我们有一个可以创造功能的地方。</p><p id="b6a0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以现在我们有了一种以批判和智慧的方式思考代码的方法；来构建你的代码。不用一个接一个，一行接一行地写代码，你现在有了一个基线来开始考虑代码和你应该如何组织它。不同的事物应该如何相互交流，才能创造出有这些想法的程序？</p><p id="d9c3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">关于多态性的练习。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi rq"><img src="../Images/17241fb092434b9854303864ad5a87e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/1*gSjphUjlbVxxcWUoQuW37A.png"/></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi rr"><img src="../Images/530148cb2f0644e3daf3dc2bbcd7ea11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*c-batC6BQkbnD1zQ1tLk_g.png"/></div></figure><h1 id="894a" class="oj nm in bd nn ok ol om nq on oo op nt jt oq ju nw jw or jx nz jz os ka oc ot bi translated">这就是面向对象的方法。</h1><p id="4f7b" class="pw-post-body-paragraph kt ku in kv b kw oe jo ky kz of jr lb lc og le lf lg oh li lj lk oi lm ln lo ig bi translated">那么我们学到了什么？<br/> 1。<strong class="kv io">本</strong>关键词<br/> 2。<strong class="kv io">新</strong>关键词<br/> 3。关于原型<br/> 4的一切。ES6类<br/> 5。基于类的语言比如Javas和C++ <br/> 6。继承<br/> 7。Object.create <br/> 8。私有vs公有<br/> 9。面向对象的4个原则</p></div></div>    
</body>
</html>