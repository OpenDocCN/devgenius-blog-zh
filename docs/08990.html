<html>
<head>
<title>Shortest Path Algorithm — Floyd Warshall &amp; Johnson’s</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最短路径算法——Floyd Warshall &amp; Johnson 的算法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/shortest-path-algorithm-floyd-warshall-johnsons-632fd7a9f8c7?source=collection_archive---------5-----------------------#2022-07-23">https://blog.devgenius.io/shortest-path-algorithm-floyd-warshall-johnsons-632fd7a9f8c7?source=collection_archive---------5-----------------------#2022-07-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="1722" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">图遍历算法系列第三部分。阅读<a class="ae ki" href="https://medium.com/nerd-for-tech/dfs-bfs-introduction-26a65fca2344" rel="noopener">第一部分</a>和<a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/shortest-path-algorithms-dijkstra-bellman-ford-3b640bdb0449">第二部分</a></p><p id="72e2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上一篇博客中，我们学习了两种单源最短路径算法，在这篇博客中，我们将看到在所有节点对中寻找最短路径的两种算法。</p><h1 id="0b9f" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">弗洛伊德·沃肖尔算法</h1><p id="1a3f" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">该算法采用动态规划的方法来解决问题。它将问题分解成更小的问题，然后组合答案来解决主要的最短路径问题。因此，利用这一点，我们可以确定到达图上任何其他节点的最快方法。</p><ol class=""><li id="6a4e" class="lm ln in jm b jn jo jr js jv lo jz lp kd lq kh lr ls lt lu bi translated">构建一个大小为(N*N)的矩阵(D ),给出每个节点对之间的最短路径。</li><li id="cd7a" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh lr ls lt lu bi translated">将最短路径初始化为无穷大。</li><li id="6cdc" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh lr ls lt lu bi translated">找出使用 0 个中间顶点的最短路径。</li><li id="935b" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh lr ls lt lu bi translated">在每次迭代中，增加中间顶点的数量。<code class="fe ma mb mc md b">D(i, j) = min(D[i][k] + D[k][j], D[i][j])</code>。这里 D[i][k]表示只使用前 K 个顶点的最短路径。并且 D[k][j]表示对(k，j)之间的最短路径。</li></ol><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="804b" class="mm kk in md b gy mn mo l mp mq">def FloydWarshall(N, edges):<br/>    g = [[math.inf for _ in range(N)] for _ in range(N)]<br/>    <br/>    for u, v, w in edges:<br/>        g[u][v] = w<br/>        g[v][u] = w</span><span id="1f3e" class="mm kk in md b gy mr mo l mp mq">    for u in range(N):<br/>        g[u][u] = 0<br/>    <br/>    for k in range(N):<br/>        for i in range(N):<br/>            for j in range(N):<br/>                if g[i][j] &gt; g[i][k] + g[k][j]:<br/>                    g[i][j] = g[i][k] + g[k][j]<br/>                    <br/>    print(g)<br/>    <br/>FloydWarshall(4, [[0,1,3],[1,2,1],[1,3,4],[2,3,1]])</span></pre><p id="934a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该算法的时间复杂度为<strong class="jm io"> O(N)。</strong></p><p id="5c3a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种算法对于稠密图是非常好的。对于稀疏图，我们使用另一种算法，这将在下面讨论。</p><h1 id="a360" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">约翰逊算法</h1><p id="b20f" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">该算法最适用于稀疏图。它依靠另外两种算法来确定最短路径。它使用贝尔曼-福特来检测负周期并消除任何负边缘。然后使用 Dijkstra 算法计算最短路径。</p><figure class="me mf mg mh gt mt gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/bb1e61f45ff422f1f87c8cf5e1cd2e09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*6caWOgyf4J5ZjgFCih6bOw.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">来源维基百科</figcaption></figure><ol class=""><li id="21d5" class="lm ln in jm b jn jo jr js jv lo jz lp kd lq kh lr ls lt lu bi translated">对于给定的图 G，在图中添加一个新的顶点<strong class="jm io"> q </strong>，并从新顶点向 G 的所有顶点添加边，设修改后的图为 G。</li><li id="ef80" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh lr ls lt lu bi translated">以<strong class="jm io"> q </strong>为源对 G 运行贝尔曼-福特算法。设贝尔曼-福特计算的距离为 h[0]，h[1]，..h[V-1]。如果我们发现一个负的重量循环，然后返回。注意，负权重循环不能由新顶点<strong class="jm io"> q </strong>创建，因为没有到<strong class="jm io"> q </strong>的边。所有边缘都来自<strong class="jm io"> q </strong>。</li><li id="9690" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh lr ls lt lu bi translated">重新加权原始图形的边。对于每条边(u，v)，将新权重指定为“原始权重+ h[u] — h[v]”。</li><li id="8f2d" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh lr ls lt lu bi translated">移除添加的顶点<strong class="jm io"> q </strong>并对每个顶点运行 Dijkstra 算法。</li></ol><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="0bff" class="mm kk in md b gy mn mo l mp mq">from collections import defaultdict<br/>import math</span><span id="0af2" class="mm kk in md b gy mr mo l mp mq">def get_min_distance(dist, visited):<br/>    minimum, minVertex = math.inf, 0<br/>    for vertex in range(len(dist)):<br/>        if minimum &gt; dist[vertex] and visited[vertex] == False:<br/>            minimum, minVertex = dist[vertex], vertex<br/>    return minVertex</span><span id="d163" class="mm kk in md b gy mr mo l mp mq">def Dijkstra(og, ng, src):<br/>    N = len(graph)<br/>    spt_set = defaultdict(lambda : False)<br/>    d = [math.inf] * N<br/>    d[src] = 0<br/>  <br/>    for count in range(N):<br/>        cur = get_min_distance(d, spt_set)<br/>        spt_set[cur] = True<br/>  <br/>        for vertex in range(N):<br/>            if ((spt_set[vertex] == False) and<br/>                (d[vertex] &gt; (d[cur] + ng[cur][vertex])) and<br/>                (og[cur][vertex] != 0)):<br/>                d[vertex] = (d[cur] + ng[cur][vertex])<br/>    <br/>    for v in range(N):<br/>        print ('Vertex ' + str(v) + ': ' + str(d[v]))</span><span id="9314" class="mm kk in md b gy mr mo l mp mq">def BellmanFord(edges, graph, N):<br/>    d = [math.inf] * (N + 1)<br/>    d[N] = 0<br/>  <br/>    for i in range(N):<br/>        edges.append([N, i, 0])<br/>  <br/>    for i in range(N):<br/>        for (src, des, weight) in edges:<br/>            if((d[src] != math.inf) and (d[src] + weight &lt; d[des])):<br/>                d[des] = d[src] + weight<br/>  <br/>    return d[0:N]<br/>  <br/>def JohnsonAlgorithm(graph):<br/>    edges = []<br/>    for i in range(len(graph)):<br/>        for j in range(len(graph[i])):<br/>            if graph[i][j] != 0:<br/>                edges.append([i, j, graph[i][j]])<br/>  <br/>    # Weights used to modify the original weights<br/>    new_weights = BellmanFord(edges, graph, len(graph))<br/>  <br/>    new_graph = [[0 for x in range(len(graph))] for y in<br/>                    range(len(graph))]<br/>  <br/>    # Modify the weights to get rid of negative weights<br/>    for i in range(len(graph)):<br/>        for j in range(len(graph[i])):<br/>            if graph[i][j] != 0:<br/>                new_graph[i][j] = (graph[i][j] + <br/>                        new_weights[i] - new_weights[j])<br/>  <br/>    # Run Dijkstra for every vertex as source one by one<br/>    for src in range(len(graph)):<br/>        print ('\nShortest Distance with vertex ' + str(src) + ' as the source:\n')<br/>        Dijkstra(graph, new_graph, src)<br/>  <br/># Driver Code<br/>graph = [[0, -5, 2, 3], <br/>         [0, 0, 4, 0], <br/>         [0, 0, 0, 1], <br/>         [0, 0, 0, 0]]<br/>  <br/>JohnsonAlgorithm(graph)</span></pre><p id="bb1d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该算法的时间复杂度为<strong class="jm io"> O(N + NE log N) </strong></p><p id="ef9d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">快乐阅读！！</p></div></div>    
</body>
</html>