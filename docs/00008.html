<html>
<head>
<title>Deep Learning: In gradient descent style! — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深度学习:以梯度下降的方式！—第二部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/deep-learning-in-gradient-descent-style-part-2-e159e2cf8a99?source=collection_archive---------0-----------------------#2018-05-12">https://blog.devgenius.io/deep-learning-in-gradient-descent-style-part-2-e159e2cf8a99?source=collection_archive---------0-----------------------#2018-05-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="80da" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">在前面的</em> <a class="ae kj" href="https://medium.com/@tomdeore/deep-learning-in-gradient-decent-style-part-1-ed747e7cc2a3" rel="noopener"> <em class="ki"> part-1 </em> </a> <em class="ki">中我们抓住了几个关键词，在这一部分我们将获得对神经网络及其构建模块的直觉。</em></p><p id="658d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在软件编程中，典型的函数如下所示:</p><pre class="kk kl km kn gt ko kp kq kr aw ks bi"><span id="b005" class="kt ku in kp b gy kv kw l kx ky">          #include &lt;stdio.h&gt;</span><span id="b3d9" class="kt ku in kp b gy kz kw l kx ky">          void functionName() <strong class="kp io">&lt;&lt;------|</strong><br/>          {                           <strong class="kp io">|</strong> <br/>              . . . .  . .  . . . .   <strong class="kp io">|</strong><br/>              . . . .  . .  . . . .   <strong class="kp io">| </strong>         <br/>                                      <strong class="kp io">|</strong>  <br/><strong class="kp io">|--------</strong> }                           <strong class="kp io">|</strong><br/><strong class="kp io">|</strong>                                     <strong class="kp io">|</strong><br/><strong class="kp io">|</strong>        int main()                   <strong class="kp io">| </strong><br/><strong class="kp io">|</strong>        {                            <strong class="kp io">|</strong><br/><strong class="kp io">|</strong>            . . . .  . .  . . . .    <strong class="kp io">|</strong><br/><strong class="kp io">|</strong>            . . . .  . .  . . . .    <strong class="kp io">|</strong>       <br/><strong class="kp io">|</strong>                                     <strong class="kp io">|</strong> <br/><strong class="kp io">|</strong>            functionName();  <strong class="kp io">--------|</strong>              <br/><strong class="kp io">|</strong>           <br/><strong class="kp io">|-------&gt;&gt;</strong>    . . . .  . .  . . . .<br/>              . . . .  . .  . . . .<br/>          }</span></pre><p id="1eda" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">函数名()；</p><p id="2cd1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里的整个思想是传递输入并获得输出，其中函数是一个'<strong class="jm io"> <em class="ki">'黑盒'</em> </strong>。这个黑匣子有一些由人类使用其中一种编程语言编写的逻辑。这就是我们到目前为止为实现应用程序和逻辑所做的工作。这在 Andrej Karpathy 的文章<a class="ae kj" href="https://medium.com/@karpathy/software-2-0-a64152b37c35" rel="noopener">软件 2.0 </a>中有详细描述。</p><figure class="kk kl km kn gt lb gh gi paragraph-image"><div class="gh gi la"><img src="../Images/58a9f7dbee9ea033acb81fc69aa6a288.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*gOCevStEQubW-lv6T4_K4w.png"/></div></figure><p id="e497" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在神经网络中，我们执行完全相同的任务，但这里的'<strong class="jm io">黑盒'</strong> magic 是一个数学函数。事实上，神经网络可以描述任何数学函数，因此被称为<strong class="jm io"> <em class="ki">通用函数逼近器</em> </strong>。这种数学函数在本质上是非线性的，具有大量的维度，但不要担心，我们很快就会进一步证明这一点。</p><p id="e49d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你需要同样的视觉证明，需要数学解释，迈克尔·尼尔森的免费书籍<a class="ae kj" href="http://neuralnetworksanddeeplearning.com/chap4.html" rel="noopener ugc nofollow" target="_blank">第四章</a>会给<strong class="jm io"><em class="ki"/></strong>最好的见解。我建议你通读所有的章节，因为对我来说，这是一本关于数字图书馆的最好的书。</p><blockquote class="le lf lg"><p id="5da3" class="jk jl ki jm b jn jo jp jq jr js jt ju lh jw jx jy li ka kb kc lj ke kf kg kh ig bi translated">注意:在继续之前，浏览一下迈克尔·尼尔森的免费书籍<a class="ae kj" href="http://neuralnetworksanddeeplearning.com/chap4.html" rel="noopener ugc nofollow" target="_blank">第 4 章</a>。</p></blockquote><p id="fd15" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果这第一直觉是清楚的，为什么我们说神经网络是通用函数逼近器？我们现在的状态非常好，可以进入细节了。</p><h1 id="5b98" class="lk ku in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">资料组</h1><p id="8c62" class="pw-post-body-paragraph jk jl in jm b jn mh jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd ml kf kg kh ig bi translated">干净的数据集对于神经网络按照我们希望的方式执行和预测是必不可少的。神经网络只理解整数作为输入数据，因此所有输入都必须转换为整数类型。假设:从 0-255(灰度图像数据)或一组人走过的距离 100-100，000(公里)，性别类型(男性为 0，女性为 1)等。它不理解文本、字符串等。</p><p id="55cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下一个要点是，在我们将数据输入神经网络之前，我们必须将数据转换成神经网络可以使用的东西。这种类型的转换称为数据预处理，预处理是对原始数据进行规范化和标准化。</p><p id="0805" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">数据的标准化意味着将任意范围内的任何数据降低到确定的范围内，即介于(0 到 1)之间，标准化可以消除异常值。如果数据不标准化，可能会导致网络不稳定，并可能导致爆炸梯度问题。</p><figure class="kk kl km kn gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mm"><img src="../Images/e0ea270b5537862eefa651b0a1a032eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IV_7FiaYMfUhAzJ1fg1PIQ.png"/></div></div></figure><p id="d702" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">继续讨论数据的形式，它可以是以下两种形式:</p><ul class=""><li id="93ab" class="mr ms in jm b jn jo jr js jv mt jz mu kd mv kh mw mx my mz bi translated"><strong class="jm io">非结构化数据</strong>:图像/图片、音频、视频等。</li><li id="c2ac" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh mw mx my mz bi translated"><strong class="jm io">结构化数据</strong>:股票、天气等。</li></ul><p id="6e28" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当然，由于数据的形式不同，因此网络也应该不同。在逻辑上，我们将讨论处理结构化和非结构化数据的各种不同方法。</p><p id="b194" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文中，我们将考虑图像数据，因为我们可以在视觉上获得更好的直觉。</p><h1 id="bb33" class="lk ku in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">感知器与神经网络的形成？</h1><p id="6836" class="pw-post-body-paragraph jk jl in jm b jn mh jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd ml kf kg kh ig bi translated">一个神经网络可以<strong class="jm io"> <em class="ki">刻画</em> </strong>任何数学函数。重要的词是'<strong class="jm io"> <em class="ki">描绘</em> </strong>'，因为我们没有明确地编写这样的函数，而是让网络<strong class="jm io"> <em class="ki">学习</em> </strong>一个最适合给定数据集  <em class="ki">的函数。</em>我再重复一遍，我们并不明确地为一项任务手工制作这些神经元，而是将数据集暴露给它们，让它们(作为一个完整的神经元网络)收敛到一个函数，该函数在这个给定数据集的属性上最适合<strong class="jm io"><em class="ki"/></strong>。换句话说，<strong class="jm io">最佳匹配</strong>意味着概括输出，不是硬编码，而是知道输入的属性并预测它们各自最接近的匹配。</p><p id="c607" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，训练是一个对输入数据集了解越来越多的迭代过程，为此，拥有<strong class="jm io"> <em class="ki">干净、充足、合适的数据集</em> </strong>非常重要，这是关键！</p><p id="3269" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感知器是神经网络的基本构建模块，假设我们想要描绘一个数学函数<strong class="jm io"><em class="ki">f(x)= MX+b</em></strong><em class="ki">，</em>和计算器<strong class="jm io"><em class="ki">∑(MX+b)</em></strong>它看起来像下面这样:</p><figure class="kk kl km kn gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi nf"><img src="../Images/39ddacffb1ce0aab2ee34e84fc9db6e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*liNfWVI3qsC4m4HK."/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">感知器—向前和向后传递</figcaption></figure><p id="a6a3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">只是快速回顾一下对迈克尔·尼尔森的书<a class="ae kj" href="http://neuralnetworksanddeeplearning.com/chap4.html" rel="noopener ugc nofollow" target="_blank">第四章</a>的理解:</p><p id="9ee8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"><em class="ki">【f(x)</em></strong>是一个线性函数，网络中的每个神经元进行线性运算，有多层叠加，会产生线性输出，即最终产生线性函数。</p><blockquote class="le lf lg"><p id="57d6" class="jk jl ki jm b jn jo jp jq jr js jt ju lh jw jx jy li ka kb kc lj ke kf kg kh ig bi translated">但是等等！</p></blockquote><p id="4115" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们说神经网络可以描述包括非线性在内的任何函数，那么这里缺少什么呢？</p><blockquote class="le lf lg"><p id="13e6" class="jk jl ki jm b jn jo jp jq jr js jt ju lh jw jx jy li ka kb kc lj ke kf kg kh ig bi translated">答案是激活功能</p></blockquote><p id="61de" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">激活函数意味着在网络中引入非线性，它们的作用就像迈克尔·尼尔森在第四章中解释的<strong class="jm io"><em class="ki"/></strong>(没有使用代数)，他使用视觉图形给阶跃函数以直观性，帮助我们理解非线性的概念。例如，Sigmod 或任何激活函数本质上都是非线性的，如果我们应用它们，每个神经元都会产生非线性输出，哇！</p><p id="2d45" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这一点上，如果你想回到迈克尔尼尔森给出的那些可视化的例子，将是非常有用和有趣的！</p><p id="3c26" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，我们现在可以认为神经网络可以描述我们喜欢的任何数学函数，即使只有一个隐藏层的神经元也可以构建这样一个复杂的函数，如下所示:</p><figure class="kk kl km kn gt lb gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/0dc9f6c4d18fadc392cd5da3cb7330e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*Gut9-xxIbFc_J75C886JQA.png"/></div></figure><p id="e15b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们从神经网络的角度来考虑线性回归问题。</p><p id="8c56" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> ŷ </strong>是我们想要预测的输出，这是一所房子的<em class="ki">最佳价格</em>，其中:y 轴是价格，x 轴是房子中卧室的数量。这里我们考虑，问题只有一个输入/特征，即“卧室数量”。如果你画出这个问题，它将是图形上的最佳拟合或直线，其中图形上所有数据点的损失是最小的。</p><p id="527a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用成本函数寻找损失，并使用梯度下降算法收敛到局部最小最优。收敛的整个过程称为反向传递或反向传播。</p><h1 id="977f" class="lk ku in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">多重特征</h1><p id="d3fb" class="pw-post-body-paragraph jk jl in jm b jn mh jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd ml kf kg kh ig bi translated">上面的房价例子很简单，因为我们只能从一个特征中选择，即多个卧室。但是生活并不总是那么简单，相反，在现实世界中，问题是复杂的，并且有许多相关的特征:</p><ol class=""><li id="26a2" class="mr ms in jm b jn jo jr js jv mt jz mu kd mv kh nl mx my mz bi translated">卧室数量</li><li id="4ee6" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh nl mx my mz bi translated">房子的面积</li><li id="2591" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh nl mx my mz bi translated">位置</li><li id="1962" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh nl mx my mz bi translated">预算</li><li id="515a" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh nl mx my mz bi translated">公共交通</li><li id="a9b4" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh nl mx my mz bi translated">学校</li><li id="efb7" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh nl mx my mz bi translated">房子里的便利设施(这些可以分解成单独的功能)</li><li id="de00" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh nl mx my mz bi translated">社会福利设施等。</li></ol><p id="1c28" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，如果你画一个上述问题的计算图，它看起来会像下面这样:</p><figure class="kk kl km kn gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi nm"><img src="../Images/19e55c58e3c274c549fd7d7746e293f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-32349EE3UqSUGTbtGGYYg.png"/></div></div></figure><p id="1e54" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如您在上面看到的，链接/连接是基于关系的，而在神经网络中，所有节点都连接到它之前和之后的所有其他节点，这意味着它是完全网状的网络(逐层)。随着输入/特征数量的增加，函数变得更加复杂，这对神经网络来说更好。这本质上表明，<strong class="jm io"> <em class="ki">让神经网络在它的节点</em> </strong>中找到可能的最佳关系，而不是人工设计它，因此所有的节点都在具有其对等层的全网状网络中，看起来像下面这样:</p><figure class="kk kl km kn gt lb gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/6cadf18df184d093bfd04aa8ccd88daa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*JxE9HYahNpcbW9mImEJRPA.png"/></div></figure><p id="07cd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将使每个隐藏层神经元的方程看起来像下面这样:</p><pre class="kk kl km kn gt ko kp kq kr aw ks bi"><span id="f95a" class="kt ku in kp b gy kv kw l kx ky">z = (w¹x¹ + w²x² + w³x³ + w⁴x⁴ + w⁵x⁵ + w⁶x⁶) + b</span><span id="348b" class="kt ku in kp b gy kz kw l kx ky">α = σ(z)</span><span id="8b77" class="kt ku in kp b gy kz kw l kx ky">where:<br/>x¹ - Number of bedrooms<br/>x² - Area<br/>x³ - Locality<br/>x⁴ - Public transport<br/>x⁵ - School<br/>x⁶ - Budget</span></pre><p id="12c9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有了多个特征，网络的维数增加，为了形象化它，考虑一个多维结构，否则它与单输入网络相同。</p><p id="1c8c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，每个特征将具有其自己的局部最小值，并且将学习特定的特征，并且在网络的末端，所有这样的特征被收集在一起，在称为全连接层的东西中，以预测类别。深度学习以学习图像中的多个特征而不是一个特征而闻名。</p><p id="4357" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例子:看下面的图片，深度学习应该能够讲述一个故事或至少一个句子，类似于</p><blockquote class="le lf lg"><p id="2463" class="jk jl ki jm b jn jo jp jq jr js jt ju lh jw jx jy li ka kb kc lj ke kf kg kh ig bi translated">“两个骑自行车的孩子，停下自行车与某人分享微笑”</p></blockquote><figure class="kk kl km kn gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi no"><img src="../Images/2be55950377a22b474e88c7b47d61754.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iM0x0rJECjsx93hxbn07Yg.jpeg"/></div></div></figure><p id="2c30" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">否则，我们会孤立地识别物体，比如:<strong class="jm io">自行车</strong>或<strong class="jm io">男孩</strong>。</p><p id="df31" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">培训是一项练习，我们在其中执行一些重要的操作:</p><ol class=""><li id="3ba8" class="mr ms in jm b jn jo jr js jv mt jz mu kd mv kh nl mx my mz bi translated">用输入数据集训练系统。</li><li id="51a6" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh nl mx my mz bi translated">用结果验证输入数据，并找出与预期值的差值或偏差，称为损失/误差。</li><li id="dd74" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh nl mx my mz bi translated">用已知的损失，弥补差距。这也被称为反向传播(又名<strong class="jm io">反向传播</strong>)和“<em class="ki">神经网络的心脏</em>”。</li></ol><p id="32b6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上述步骤循环进行，直到网络学习到最大精度，并且损耗最小。这需要时间和学习周期。这就像一个蹒跚学步的孩子在多次尝试失败后学会了走路。</p><h2 id="06b8" class="kt ku in bd ll np nq dn lp nr ns dp lt jv nt nu lx jz nv nw mb kd nx ny mf nz bi translated">学习网络的类型</h2><ol class=""><li id="de8b" class="mr ms in jm b jn mh jr mi jv oa jz ob kd oc kh nl mx my mz bi translated">被监督的<em class="ki">(跟老师学)</em></li><li id="9ef0" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh nl mx my mz bi translated">强化<em class="ki">(有限反馈学习)</em></li><li id="da96" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh nl mx my mz bi translated">无人监督<em class="ki">(无帮助学习)</em></li></ol><h1 id="dc62" class="lk ku in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">CNN 简介</h1><p id="05eb" class="pw-post-body-paragraph jk jl in jm b jn mh jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd ml kf kg kh ig bi translated">卷积是从输入数据中提取信息的一种方式。卷积神经网络用于图像澄清，有各种最先进的架构，但我们将讨论一般的 CNN。</p><p id="4b4f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是一种监督学习，训练数据被标记。这样做的方法是将一个特定对象的所有图像保存在一个目录中，并为其命名，该名称成为该对象的类/类别。例如:“猫”和“狗”图像保存在两个不同的目录中。名为“猫”的目录将包含所有猫的图片，同样，名为“狗”的目录将包含所有“狗”的图片。在图像分类的情况下，这些标签通常被称为类或类别。</p><p id="4396" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">CNN 有三大层:</p><ol class=""><li id="5c23" class="mr ms in jm b jn jo jr js jv mt jz mu kd mv kh nl mx my mz bi translated">卷积层(conv)</li><li id="20a7" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh nl mx my mz bi translated">汇集层(池)</li><li id="445e" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh nl mx my mz bi translated">全连接层</li></ol><p id="bd40" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将在创建网络时逐一介绍这些内容。</p><h1 id="b27f" class="lk ku in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">什么是卷积？</h1><p id="89ff" class="pw-post-body-paragraph jk jl in jm b jn mh jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd ml kf kg kh ig bi translated">这个<a class="ae kj" href="http://setosa.io/ev/image-kernels/" rel="noopener ugc nofollow" target="_blank">例子</a>解释了一切。</p><figure class="kk kl km kn gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi od"><img src="../Images/d2ee041e0248fde20068b17033306fad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j3lGZDpre_6Ii2JhMTBryg.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">单通道图像上的卷积</figcaption></figure><p id="18bb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">输入图像是我们想要找到特征的图像，在这种情况下，这是灰度(二维)图像，因此具有单通道。卷积从左上角开始，向右滑动一步，直到到达图像中的最后一个像素，向下移动一个像素，然后从左侧开始，依此类推。示例:输入图像上的彩色部分和过滤器卷积产生以下结果<em class="ki">(3 * 1+0 * 0+1 *-1+1 * 1+5 * 0+8 *-1+2 * 1+7 * 0+2 *-1)=-5</em></p><p id="37f3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">同样，我们向右移动一步，执行<em class="ki">(0 * 1+1 * 0+2 *-1+5 * 1+8 * 0+9 *-1+7 * 1+2 * 0+5 *-1)=-4</em></p><p id="925f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如上所述，结果存储在输出图像中。</p><p id="6b28" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">RGB 有三个通道，如下所示:</p><figure class="kk kl km kn gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi oe"><img src="../Images/37bbc8130f567cfc4415a0ee9a951b9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JaST10_6rQyYZl7qio5Ydg.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">RGB(三通道)图像上的卷积</figcaption></figure><p id="1c48" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 RGB 的情况下，每个红色滤光器与红色图像卷积，绿色滤光器与绿色图像卷积，蓝色滤光器与蓝色图像卷积，并且将它们的结果相加到输出图像。</p><blockquote class="le lf lg"><p id="aacc" class="jk jl ki jm b jn jo jp jq jr js jt ju lh jw jx jy li ka kb kc lj ke kf kg kh ig bi translated">到目前为止，它非常简单，但是让我们增加上面操作的复杂性。</p></blockquote><p id="e2c8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">如何得到输出图像的尺寸？</strong></p><pre class="kk kl km kn gt ko kp kq kr aw ks bi"><span id="fc4f" class="kt ku in kp b gy kv kw l kx ky"><strong class="kp io">(n — f + 1) x (n — f + 1)</strong></span><span id="ef7a" class="kt ku in kp b gy kz kw l kx ky">Where: <br/>n x n = dimension of input image<br/>f x f = dimension of filter</span><span id="a1fe" class="kt ku in kp b gy kz kw l kx ky">and therefore, if we apply this to the above grey scale example:</span><span id="f7f1" class="kt ku in kp b gy kz kw l kx ky">(6 - 3 + 1) x (6 - 3 + 1) ==&gt; (4 x 4) matrix</span></pre><p id="1bfd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">同样的公式也可以应用于 RGB 图像，只是 RGB 有通道，但我们看的是尺寸(即高度和宽度，而不是通道)。</p><h2 id="63af" class="kt ku in bd ll np nq dn lp nr ns dp lt jv nt nu lx jz nv nw mb kd nx ny mf nz bi translated">有两个主要问题——图像卷积</h2><ol class=""><li id="e7ab" class="mr ms in jm b jn mh jr mi jv oa jz ob kd oc kh nl mx my mz bi translated"><strong class="jm io">图像在维度上缩小</strong>:一个 6x6 的输入矩阵变成了 4x4，其中内部像素比外部像素经常被触摸一次。因此，与内部像素相比，边界像素的影响不会太大。</li><li id="d7a8" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh nl mx my mz bi translated"><strong class="jm io">信息丢失</strong>:丢弃图像边缘的大量信息。同样，与内部像素相比，它们的影响较小。</li></ol><p id="f290" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">解决方法是<strong class="jm io">垫高！</strong></p><p id="05cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过添加额外的边框来填充输入图像，这将保持与没有填充时相同的尺寸。</p><figure class="kk kl km kn gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi of"><img src="../Images/6fa41aaad1087b90d7a3a9260b4fe512.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YLiRISSGSzCBk6pURbwqUA.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">输入图像上的填充</figcaption></figure><p id="4060" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如我们所看到的，填充将保持输出图像与输入图像相同的尺寸。现在尺寸公式变为:</p><pre class="kk kl km kn gt ko kp kq kr aw ks bi"><span id="9bec" class="kt ku in kp b gy kv kw l kx ky"><strong class="kp io">(n + 2p — f + 1) x (n + 2p — f + 1)</strong></span><span id="ab71" class="kt ku in kp b gy kz kw l kx ky">Where: <br/>n x n = dimension of input image<br/>f x f = dimension of filter<br/>p     = padding</span><span id="a0f7" class="kt ku in kp b gy kz kw l kx ky">Let us say,<strong class="kp io"><br/>Input Image Dimensions = Output Image Dimensions</strong></span><span id="6375" class="kt ku in kp b gy kz kw l kx ky">n + 2p -f + 1 = n<br/>p = (f - 1) / 2</span><span id="31f1" class="kt ku in kp b gy kz kw l kx ky">So, if filter is <strong class="kp io">(3 x 3)</strong>, padding = (3 - 1) / 2 = <strong class="kp io">1</strong></span><span id="6a2a" class="kt ku in kp b gy kz kw l kx ky">if filter is <strong class="kp io">(5 x 5)</strong>, padding = (5 - 1) / 2 = <strong class="kp io">2</strong></span></pre><h1 id="ca82" class="lk ku in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">步幅卷积</h1><p id="20fc" class="pw-post-body-paragraph jk jl in jm b jn mh jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd ml kf kg kh ig bi translated">还有另一种用于减小图像尺寸的重要技术，叫做步幅</p><figure class="kk kl km kn gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi og"><img src="../Images/aa84059987bb7a84643c0510f5b6b5be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZtofJk4Kq8X1kd0S5ivA9Q.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">输入图像上的步幅</figcaption></figure><p id="8244" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当像素与另一个相邻像素有很强的相关性时，减小输出图像的大小是非常合理的。但小心这可能导致信息丢失，那意味着更大的步幅将导致更大的损失。但是我们将很快看到何时更恰当地使用 stride 是有意义。现在，只需理解卷积和步幅的概念。</p><p id="17cc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">随着跨步的到来，输出图像的尺寸变为:</p><pre class="kk kl km kn gt ko kp kq kr aw ks bi"><span id="5d6a" class="kt ku in kp b gy kv kw l kx ky"><strong class="kp io">(n + 2p — f)           (n + 2p — f)<br/> ---------- + 1    x    ---------- + 1<br/>      s                   s</strong></span><span id="42f7" class="kt ku in kp b gy kz kw l kx ky">Where: <br/>n x n = dimension of input image<br/>f x f = dimension of filter<br/>p     = padding<br/>s     = stride</span></pre><h1 id="448d" class="lk ku in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">单层网络</h1><p id="26a7" class="pw-post-body-paragraph jk jl in jm b jn mh jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd ml kf kg kh ig bi translated">这就是单层卷积网络(嗯！它还不是网络，而只是一个层)看起来像:</p><figure class="kk kl km kn gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi oh"><img src="../Images/3f75bd2a4c6a435da6dd7181d85e1386.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BlqffGLlAZ0INXIKhl6J_Q.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">CNN 中的单卷积层</figcaption></figure><p id="80cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们有 3 个 RGB 通道的(6×6)输入图像，这意味着我们将需要 3 个通道滤波器，在这种情况下，滤波器尺寸为(3×3)。输入图像没有任何填充，卷积运算的步长为 1。将有 4 个这样的(3×3)滤波器将与输入图像进行卷积，每个滤波器输出的结果将与偏差相加(图像中的每个像素将与偏差相加),并且 ReLU 非线性将应用于结果图像。每 4 个处理后的输出图像的最终结果将被连接以形成'<strong class="jm io">体积'</strong>,我们称之为输出体积。</p><p id="e0c1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该层中的参数数量=((滤波器的尺寸*通道的数量)+偏差)*滤波器的数量)</p><p id="9836" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们的例子中，</p><p id="3bf6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">参数= ((3 *3 *3)+ 1) *4)= 112 </em></p><p id="5cea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此时，你的脑海中会有很多疑问，如果没有，请再次经历这个过程:</p><p id="6530" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="ki">谁用什么值初始化滤镜？</em> </strong></p><p id="3cb2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">重要的是要理解，这些是我们试图训练的权重，以便我们的系统预测正确的输出，但如果权重初始化为零或任何特定的整数，那么所有神经元都将得到相同的结果，这是不希望的，需要打破这种情况。因此解决方案是权重的随机分布，因此网络将考虑克服随机性计算成本，并在梯度下降期间解决它。我强烈推荐写得很好的<a class="ae kj" href="https://stats.stackexchange.com/questions/200513/how-to-initialize-the-elements-of-the-filter-matrix" rel="noopener ugc nofollow" target="_blank">答案</a>。</p><p id="4de7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="ki">这些参数是什么？</em>T13】</strong></p><p id="1d8b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">同样，这些是我们正在训练和调整的个体权重，最终会学习到。但是，如果你的网络中有太多的参数，就很难训练所有的参数，这意味着你需要大量不同的数据。这是网络被设计得更深以减少整个网络中的参数的原因之一。还有其他各种各样的原因，比如:大规模分类需要深度网络，但我们不讨论这个。我们关心的是可训练参数，这些是重量。这些权重在反向传播期间被更新和调整。</p><p id="ba46" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，这是什么反向传播？ </p><p id="9c04" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">又名反向传播，是神经网络的核心。假设使用单个训练数据输入，我们获取网络的输出，通过与我们想要获得的输出进行比较来找到误差，在每个节点找到偏导数(对于权重和偏差),并将其推回到网络中，直到最后一个节点。这更像是一次为单个示例数据调整多个旋钮。下面的视频很好地解释了这一点。</p><figure class="kk kl km kn gt lb"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="f178" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这一点上，我们结束了这一部分，在下一部分中，我们将从头开始制作网络，这也基本上意味着我们将从此开始玩代码。</p><h2 id="7fa4" class="kt ku in bd ll np nq dn lp nr ns dp lt jv nt nu lx jz nv nw mb kd nx ny mf nz bi translated">民众</h2><ol class=""><li id="bb0d" class="mr ms in jm b jn mh jr mi jv oa jz ob kd oc kh nl mx my mz bi translated">视觉<a class="ae kj" href="https://youtu.be/Oqm9vsf_hvU?t=267" rel="noopener ugc nofollow" target="_blank">演示</a>由<em class="ki">奥塔维奥好。</em></li><li id="c309" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh nl mx my mz bi translated">Excel <a class="ae kj" href="https://github.com/fastai/fastai/blob/master/courses/dl1/excel/layers_example.xlsx" rel="noopener ugc nofollow" target="_blank">演示</a>(下载该文件并在 excel/Google-spreeds sheets 中打开)作者<em class="ki">杰瑞米·霍华德</em></li></ol><p id="5441" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">你可以在|</strong><a class="ae kj" href="https://www.linkedin.com/in/mdeore/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io">LinkedIn</strong></a><strong class="jm io">|</strong><a class="ae kj" href="https://tomdeore.wixsite.com/epoch" rel="noopener ugc nofollow" target="_blank"><strong class="jm io">网站</strong></a><strong class="jm io">|</strong><a class="ae kj" href="https://github.com/milinddeore" rel="noopener ugc nofollow" target="_blank"><strong class="jm io">Github</strong></a><strong class="jm io">|</strong></p></div></div>    
</body>
</html>