<html>
<head>
<title>Backtesting Trading Strategy with Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对熊猫的交易策略进行回溯测试</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/backtesting-trading-strategy-with-pandas-300ce7c1c9c1?source=collection_archive---------2-----------------------#2022-11-05">https://blog.devgenius.io/backtesting-trading-strategy-with-pandas-300ce7c1c9c1?source=collection_archive---------2-----------------------#2022-11-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="dc55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">回溯测试是根据历史数据评估交易策略表现的过程。将会有一系列的故事出版，记录回溯测试程序的发展。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/f72fb013ff6fea58540d25331697849b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*w5dTTr56URekygZu"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated"><a class="ae lb" href="https://unsplash.com/@m_____me?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> m. </a>在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><h2 id="735d" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">回溯测试移动平均交叉策略</h2><p id="55be" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我们将从测试一个简单的策略开始。也就是说，我们将使用移动平均线的简单交叉。我们将使用 pandas-ta 库来构建指标。</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="342b" class="lc ld iq mb b gy mf mg l mh mi">import pandas_ta as ta</span><span id="d855" class="lc ld iq mb b gy mj mg l mh mi">df["sma10"] = df.ta.sma(10)<br/>df["sma30"] = df.ta.sma(30)</span></pre><p id="1fbc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">交叉的基本思想是，当更快的均线(SMA_10)穿过更慢的均线(SMA_30)时，你进入多头仓位，当相反的情况发生时，你平仓。因此，我们需要识别 SMA_10 在 SMA_30 之上的所有数据点，以及那些序列的开始。</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="10a1" class="lc ld iq mb b gy mf mg l mh mi">df["over"] = df["sma10"] &gt; df["sma30"]<br/>df["cross_up"] = df["over"].ne(df["over"].shift()) &amp; df["over"]<br/>df["cross_down"] = df["over"].ne(df["over"].shift())&amp; ~df["over"]</span></pre><p id="66be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当前的 SMAs 比较与以前的不同是一个新趋势的标志。你可以在<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/streaks-in-pandas-time-series-c63fe62aa771">这篇文章</a>中阅读更多关于识别熊猫条纹的信息。</p><h2 id="34f5" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">运行回溯测试</h2><p id="95a7" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我们需要遍历所有的行。一般来说，向量化操作是首选的，但是在回测时，操作依赖于序列中的前一个操作。我们将跟踪我们是否在适当的位置，因为这决定了在每个迭代中做什么。</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="64d0" class="lc ld iq mb b gy mf mg l mh mi">for i in range(1, len(df)):<br/>    if not in_trade[-1]:<br/>        if df.loc[df.index[i - 1], "cross_up"]:<br/>            in_trade.append(True)<br/>            trades.append([df.index[i]])<br/>        else:<br/>            in_trade.append(False)<br/>    else:<br/>        if df.loc[df.index[i - 1], "cross_down"]:<br/>            in_trade.append(False)<br/>            trades[-1].append(df.index[i-1])<br/>        else:<br/>            in_trade.append(True)</span></pre><p id="46b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如你所见，我们总是检查前一行的指标。我们这样做是为了模拟实时行为。澄清一下，当从交换中检索烛台数据时，我们总是得到最后一根完整的蜡烛。理论上，我们不能在这个价格开始建仓，而是在下一根蜡烛线开始时建仓。</p><p id="1e3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">交易清单记录我们是否已经到位。for 循环中的执行依赖于这种状态，也就是说，当我们处于适当位置时，我们正在寻找向上的交叉进入交易，反之亦然。我们也记录我们何时进入和关闭假设的位置。我们通过在交易列表中添加相应事件的指数来实现这一点。</p><h2 id="75f8" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">计算 PnL 和假设费用</h2><p id="de74" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">在迭代的最后，我们得到了每笔交易的开始和结束时间。我们的目标是计算他们的盈利能力。我们通过从最终价格中减去起始价格来做到这一点。为了使这个过程更加真实，我们还包括了一个假设的数量和一个假设的费用率。</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="5d61" class="lc ld iq mb b gy mf mg l mh mi">quantity = 1<br/>fee_rate = 0.0001<br/><br/>trade_df = pd.DataFrame(trades, columns=["start_time", "end_time"])<br/>prices = pd.concat([<br/>            df.loc[trade_df["start_time"], "Open"]<br/>              .reset_index(drop=True),<br/>            df.loc[trade_df["end_time"], "Open"]<br/>              .reset_index(drop=True)<br/>        ], axis=1).set_axis(["start_price", "end_price"], axis=1)<br/><br/>trade_df = pd.concat([trade_df, prices], axis=1)</span></pre><p id="3a4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的代码中，我们通过过滤初始数据帧来选择交易时的价格。然后，我们使用定义的数量和费率来计算每笔交易的实际成本。</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="aeea" class="lc ld iq mb b gy mf mg l mh mi">trade_df["start_filled"] = quantity * trade_df["start_price"]<br/>trade_df["end_filled"] = quantity * trade_df["end_price"]<br/><br/>trade_df["buy_fee"] = fee_rate * trade_df["start_filled"]<br/>trade_df["sell_fee"] = fee_rate * trade_df["end_filled"]</span></pre><h2 id="aae5" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">我们战略的盈利能力</h2><p id="40f2" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">每笔交易的 P&amp;L 计算如下:</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="4d0c" class="lc ld iq mb b gy mf mg l mh mi">trade_df["P&amp;L"] = (<br/>        (trade_df["sell_filled"] - trade_df["sell_fee"]) -<br/>        (trade_df["buy_filled"] + trade_df["buy_fee"])<br/>)</span><span id="8af9" class="lc ld iq mb b gy mj mg l mh mi">trade_df["P&amp;L"].describe()</span></pre><p id="3dfc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们运行 describe 命令来计算我们的策略的总体性能。</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="5848" class="lc ld iq mb b gy mf mg l mh mi">count 152.000000<br/>mean 87.003663<br/>std 458.396582<br/>min -1867.960113<br/>25% -139.295142<br/>50% -3.247143<br/>75% 177.310014<br/>max 1745.465845<br/>Name: P&amp;L, dtype: float64</span></pre><p id="c04b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的策略做了 152 笔交易，平均 P&amp;L 为 87 美元。我们还可以看到，交易之间有很大的差异，即我们最差的交易是亏损 1867.9 美元，我们最好的交易是盈利 1745.5 美元。</p><h2 id="7105" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">未来的改进</h2><p id="c275" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">在未来的文章中，我们将增加额外的分析和策略。代码将使用面向对象的设计原则来构建，以进一步扩展其可用性。这个故事的所有代码都可以在我的 Github 上找到。</p><p id="8464" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>