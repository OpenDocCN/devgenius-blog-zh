<html>
<head>
<title>Maintainable JavaScript — Function Invocation and Equality</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可维护的 JavaScript——函数调用和相等</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/maintainable-javascript-function-invocation-and-equality-2cdd42683301?source=collection_archive---------10-----------------------#2020-09-21">https://blog.devgenius.io/maintainable-javascript-function-invocation-and-equality-2cdd42683301?source=collection_archive---------10-----------------------#2020-09-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1b0069b716b5776033be66ec22119263.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*t0TMF7DJsG5zwrjJ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@claybanks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">粘土堤</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="94c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果想继续使用代码，创建可维护的 JavaScript 代码很重要。</p><p id="9221" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将通过查看变量和函数来了解创建可维护 JavaScript 代码的基础。</p><h1 id="f132" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">函数调用</h1><p id="edff" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该用括号将直接函数调用括起来，这样我们就可以将它们与函数声明区分开来。</p><p id="643e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们应该写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="eef6" class="mn lc iq mj b gy mo mp l mq mr">const doSomething = (function() {<br/>  //...<br/>  return {<br/>    message: "hello"<br/>  }<br/>})();</span></pre><p id="0741" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用括号把函数括起来，这样我们就知道我们在调用它。</p><h1 id="6b5e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">严格模式</h1><p id="9470" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">ES5 引入了严格模式，它改变了 JavaScript 的执行和解析方式以减少错误。</p><p id="d341" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了启用严格模式，我们在想要启用严格模式的代码上方添加了<code class="fe ms mt mu mj b">'use strict'</code>。</p><p id="a043" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">避免将<code class="fe ms mt mu mj b">'use strict'</code>放在全局范围内是一个常见的建议。</p><p id="1185" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为如果我们将多个文件连接成一个文件，那么我们将在所有文件中启用严格模式。</p><p id="6911" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们对所有代码都使用严格模式，那么旧代码中很有可能会出现错误。</p><p id="e9ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，在我们修复所有代码以遵循严格模式之前，我们应该部分启用严格模式。</p><p id="dea3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5a57" class="mn lc iq mj b gy mo mp l mq mr">"use strict";</span><span id="c2f2" class="mn lc iq mj b gy mv mp l mq mr">function doSomething() {<br/>  // ...<br/>}</span></pre><p id="b6e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ba43" class="mn lc iq mj b gy mo mp l mq mr">function doSomething() {<br/>  "use strict";<br/>  // ...<br/>}</span></pre><p id="7b63" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想在多个函数上启用严格模式，我们应该写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a552" class="mn lc iq mj b gy mo mp l mq mr">(function() {<br/>  "use strict";</span><span id="b493" class="mn lc iq mj b gy mv mp l mq mr">  function doSomething() {<br/>    // ...<br/>  }</span><span id="a2fd" class="mn lc iq mj b gy mv mp l mq mr">  function doMoreWork() {<br/>    // ...<br/>  }<br/>})();</span></pre><p id="a20a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这很好，因为我们在函数中保持了严格的模式。</p><p id="986f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">新代码应该总是打开严格模式。</p><p id="82e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它纠正了许多错误，比如不小心给内置的全局变量赋值等等。</p><p id="98a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">默认情况下，模块总是有严格的模式，所以我们总是要遵循它。</p><h1 id="30d1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">箭头功能</h1><p id="48a0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">箭头函数是 ES6 中引入的一种较新的函数。</p><p id="e6b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这对于定义非构造函数非常有用，因为它们没有绑定到自己的<code class="fe ms mt mu mj b">this</code>，也没有自己的实例方法。</p><p id="87a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个好处是它不绑定到<code class="fe ms mt mu mj b">arguments</code>对象，所以我们不能用它来获取函数调用的参数。</p><p id="49b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="632c" class="mn lc iq mj b gy mo mp l mq mr">const doSomething = () =&gt; {<br/>  // ...<br/>}</span></pre><p id="d77c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">定义一个箭头函数。</p><p id="b959" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为他们没有绑定到自己的<code class="fe ms mt mu mj b">this</code>值，所以他们非常适合回调。</p><h1 id="4963" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">平等</h1><p id="b5b1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">由于类型强制，与<code class="fe ms mt mu mj b">==</code>或<code class="fe ms mt mu mj b">!=</code>相等是很棘手的。</p><p id="7de1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类型强制导致特定类型的变量被自动转换，以使操作成功。</p><p id="3e4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这可能会导致一些意想不到的结果。</p><p id="decf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们使用<code class="fe ms mt mu mj b">==</code>和<code class="fe ms mt mu mj b">!=</code>时，它们会对操作数进行类型强制。</p><p id="834c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果值没有相同的数据类型，那么将对一个或两个操作数进行类型强制。</p><p id="7a14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在很多情况下，他们并没有按照我们的期望去做。</p><p id="d3c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ad69" class="mn lc iq mj b gy mo mp l mq mr">console.log(5 == "5");</span></pre><p id="65a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">和日志<code class="fe ms mt mu mj b">true</code>。</p><p id="3ba5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c32b" class="mn lc iq mj b gy mo mp l mq mr">console.log(25 == "0x19");</span></pre><p id="5310" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也返回<code class="fe ms mt mu mj b">true</code>。</p><p id="647e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为类型强制是通过<code class="fe ms mt mu mj b">Number</code>函数完成的。</p><p id="1740" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在进行比较之前，字符串被转换为数字。</p><p id="4760" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是避免使用<code class="fe ms mt mu mj b">==</code>和<code class="fe ms mt mu mj b">!=</code>进行比较的一个原因。</p><p id="2a75" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而是用<code class="fe ms mt mu mj b">===</code>和<code class="fe ms mt mu mj b">!==</code>。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/b90ae51eaf4525f66f30d627cb481884.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*al7UNlfrWs1V1CMK"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@webaliser?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">ярославалексеенко</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><h1 id="09c3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="1828" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该小心函数调用。</p><p id="e4a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，箭头函数对于回调非常有用。</p><p id="47e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且应该用<code class="fe ms mt mu mj b">===</code>和<code class="fe ms mt mu mj b">!==</code>进行比较。</p></div></div>    
</body>
</html>