<html>
<head>
<title>Queue Data Structure || Using Singly Linked List</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">队列数据结构||使用单链表</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/queue-data-structure-using-singly-linked-list-7abe51e7a0c?source=collection_archive---------26-----------------------#2020-07-20">https://blog.devgenius.io/queue-data-structure-using-singly-linked-list-7abe51e7a0c?source=collection_archive---------26-----------------------#2020-07-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="4d67" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文中，我们将学习队列数据结构，以及如何在 swift 中使用链表对队列进行编码</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/74e93fbcd85cae8d6227a752f56d8a64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bCrMJDXGD3bSq_Ew"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">路易斯·恩古吉在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="9ff6" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">为什么？又是怎么做到的？</h1><p id="e7a2" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">队列基本上遵循 FIFO 组织，FIFO 的意思是先进先出。现在让我们来看一个例子，假设你有一台打印机，有很多人给打印机下命令要打印，现在打印机会把命令排列成队列，这样第一个人的命令会先得到打印。</p><p id="b507" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">队列主要执行两个主要动作，第一个是入队和出队。入队意味着在队列中添加元素，出队意味着从队列中移除元素。</p><p id="a6d5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将有两个指针头和尾，头将指向插入的第一个元素，尾将是下一个。</p><p id="b8e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以使用数组和链表来执行堆栈数据结构，但是使用数组来实现是困难和奇怪的，而使用链表来实现是非常方便和容易的。所以我们用链表来查找。</p><h1 id="eae9" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">在 Swift 中排队</h1><p id="acaa" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated"><strong class="jm io">现在让我们看看使用链表的代码:</strong></p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="7b25" class="mh la in md b gy mi mj l mk ml"><strong class="md io"><br/>public</strong> <strong class="md io">class</strong> Node&lt;T&gt;{<br/>    <strong class="md io">var</strong> value : T <br/>    <strong class="md io">var</strong> next : Node&lt;T&gt;? <br/>    <br/>    <strong class="md io">public</strong> <strong class="md io">init</strong>(value:T){  <br/>        <strong class="md io">self</strong>.value = value<br/>    }</span><span id="da37" class="mh la in md b gy mm mj l mk ml">}</span><span id="89b3" class="mh la in md b gy mm mj l mk ml"><strong class="md io">public</strong> <strong class="md io">class</strong> Queue&lt;T&gt;{<br/>    <strong class="md io">var</strong> head : Node&lt;T&gt;!<br/>    <strong class="md io">public</strong> <strong class="md io">var</strong> isEmpty : Bool { <strong class="md io">return</strong> head == <strong class="md io">nil</strong> }<br/>    <strong class="md io">var</strong> first : Node&lt;T&gt;? { <strong class="md io">return</strong> head }<br/>    <strong class="md io">var</strong> last : Node&lt;T&gt;? {<br/>        <strong class="md io">if</strong> <strong class="md io">var</strong> currentNode = <strong class="md io">self</strong>.head{<br/>            <strong class="md io">while</strong> <strong class="md io">case</strong> <strong class="md io">let</strong> next? = currentNode.next{<br/>                currentNode = next<br/>            }<br/>            <strong class="md io">return</strong> currentNode<br/>        }<strong class="md io">else</strong>{<br/>             <strong class="md io">return</strong> <strong class="md io">nil<br/>        </strong>}<br/>    }<br/>    <strong class="md io">func</strong> enqueue(value : T){<br/>        <strong class="md io">let</strong> newItem = Node(value: value)<br/>        <strong class="md io">if</strong> <strong class="md io">let</strong> lastNode = last{<br/>            lastNode.next = newItem<br/>        }<strong class="md io">else</strong>{<br/>            head = newItem<br/>        }<br/>    }</span><span id="88df" class="mh la in md b gy mm mj l mk ml"><strong class="md io">    func</strong> dequeue() -&gt; T? {<br/>        <strong class="md io">if</strong> <strong class="md io">self</strong>.head?.value == <strong class="md io">nil</strong> { <strong class="md io">return</strong> <strong class="md io">nil</strong>} <br/>        <strong class="md io">if</strong> <strong class="md io">let</strong> nextItem = <strong class="md io">self</strong>.head?.next {<br/>            head = nextItem<br/>        }<strong class="md io">else</strong>{<br/>            head = <strong class="md io">nil<br/>        </strong>}<br/>        <strong class="md io">return</strong> head?.value<br/>    }<br/>}</span></pre></div></div>    
</body>
</html>