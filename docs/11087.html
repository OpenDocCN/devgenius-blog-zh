<html>
<head>
<title>Looping through Objects and Arrays in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 JavaScript 中遍历对象和数组</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/looping-through-objects-and-arrays-in-javascript-4f4c05d1838c?source=collection_archive---------13-----------------------#2022-12-17">https://blog.devgenius.io/looping-through-objects-and-arrays-in-javascript-4f4c05d1838c?source=collection_archive---------13-----------------------#2022-12-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/2fdfad7072f080c0db6dda82811c84a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*1e3nY87vHETVmZUqirBG1g.jpeg"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk translated">照片由 istockphoto.com 从伊斯托克拍摄</figcaption></figure><p id="e5fc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">数据结构是一种以允许有效访问和修改的方式组织、管理和存储数据的格式。众所周知，对象和数组是 Javascript 中的数据结构类型。其他的还有:堆栈、队列、链表等。在本文中，我们将关注如何遍历两个最常用的数据结构，即<strong class="jx io">对象</strong>和<strong class="jx io">数组</strong>。</p><h1 id="be2d" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">阵列</strong></h1><p id="9c2f" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">这是存储在连续内存位置的项目集合。每个项目都可以通过其<strong class="jx io">索引</strong>(位置)编号来访问。数组总是从索引 0 开始。</p><p id="ce63" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有两种方法可以创建数组:</p><ol class=""><li id="9f27" class="lw lx in jx b jy jz kc kd kg ly kk lz ko ma ks mb mc md me bi translated">使用字符串文字</li></ol><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="5a35" class="mo ku in mk b gy mp mq l mr ms">const musicians = ['psquare','Rema','Ayrrastar','Wizkid','Davido'];</span></pre><p id="901e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">2.使用对象构造函数</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="1e44" class="mo ku in mk b gy mp mq l mr ms">const fruits = new Array("Pineapple","Water melon","Cucumber");</span></pre><p id="ea27" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">遍历数组元素</strong></p><p id="dc69" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以使用普通的 for，for..of 或 for…in 循环遍历数组中的元素。</p><p id="eb36" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">为循环</strong></p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="a852" class="mo ku in mk b gy mp mq l mr ms">// For Loop<br/>const fruits = ["Pineapple","Water melon","Cucumber"];<br/>for(let i=0; i&lt;=fruits.length; i++){<br/>console.log(fruits[i]);<br/>//Output<br/>Pineapple<br/>Water melon<br/>Cucumber</span></pre><p id="240c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的代码片段中，我们使用了 for 循环来遍历数组 fruits 的元素。我们首先初始化一个名为“I”的计数器变量，我们将它设置为 0 ( <em class="mt">让 i=0 </em>)，然后我们设置一个条件，假设数组 fruits(3)的长度仍然小于或等于计数器变量“I”的值(<em class="mt"> i &lt; =fruits.length </em>)，循环内的代码块(<em class="mt"> console.log(fruits[i]) </em>)应该继续运行，最后我们递增计数器变量“I”的值(<em class="mt">这一直持续到计数器变量“I”的值大于数组长度的值，即 3。然后，循环停止！。</em></p><p id="f169" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">为……的</strong></p><p id="3517" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个循环的语法是:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="4e14" class="mo ku in mk b gy mp mq l mr ms">for( variable of iterable){<br/>statement<br/>}<br/>/* where iterable can be an array, string, set etc */</span></pre><p id="811f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">示例代码:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="0178" class="mo ku in mk b gy mp mq l mr ms">const fruits = ["Pineapple","Water melon","Cucumber"];<br/>for(let fruit of fruits){<br/>    console.log(fruit)<br/>/* the variable fruit can be any variable name of your<br/>choice. Here I choose fruit you can choose whatever<br/>variable that makes sense to you<br/>**/<br/>}<br/>// output<br/>Pineapple<br/>Water melon<br/>Cucumber</span></pre><p id="cf6b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">为</strong>中的……</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="f5d7" class="mo ku in mk b gy mp mq l mr ms">const fruits = ["Pineapple","Water melon","Cucumber"];<br/>for(let fruit in fruits){<br/>    console.log(fruit)<br/>}<br/>//output<br/>0<br/>1<br/>2</span></pre><p id="5438" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">哎呀！我们得到的输出是多少！？。是用于..in on an array 不返回数组的元素，而是返回数组中每个元素的索引！。但是您仍然可以通过使用括号标记法从数组中访问元素来取回元素。让我们看一个例子:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="63e5" class="mo ku in mk b gy mp mq l mr ms">const fruits = ["Pineapple","Water melon","Cucumber"];<br/>for(let fruit in fruits){<br/>    console.log(fruits[fruit])<br/>}<br/>// output<br/>Pineapple<br/>Water melon<br/>Cucumber</span></pre><p id="1901" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是这是一个非常长的过程，需要很多代码。所以如果我们想遍历一个数组的元素，我们要么使用普通的 for 循环，要么使用 for..循环的。但我想我们最好的选择是..的。然后，如果我们关心的是遍历数组，并获得我们可以使用的每个元素的索引..英寸(尽管我们仍然可以使用 array.indexOf()方法来获取元素的索引)。</p><h1 id="6665" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">物体</strong></h1><p id="ce43" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">我们用来迭代数组的一些循环不适用于对象。这是因为对象在 javascript 中不是可迭代的数据结构。要检查特定的数据结构在 javascript 中是否是可迭代的，请在该数据结构上运行以下代码:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="0282" class="mo ku in mk b gy mp mq l mr ms">const arr =["kene","emeka","chidi"]<br/>console.dir(arr);</span></pre><p id="275e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">控制台上的输出:</p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/0a2fd913af99fdd7da7330557796c4b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*x_WlKkRigftxhECl-JgLig.png"/></div></figure><p id="0ad2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">向下滚动，点击“Array”展开，点击“Prototype”也展开，然后向下滚动，知道是否会找到“<strong class="jx io"> Symbol(Symbol.iterator)”。如果你能找到它，这意味着数据结构是可迭代的，否则就不是。</strong></p><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/0e19f3695fb3e81aef75068223741447.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*Pb7yFlWZIw6Enedi9NWQcw.png"/></div></figure><p id="0e8a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">查看上面的图片，您可以看到<strong class="jx io">符号(Symbol.iterator) </strong>值，这表明从我们的示例代码来看，数组“arr”是可迭代的，因此所有数组都是可迭代的，但是在对象上运行它，您会发现<strong class="jx io">符号(Symbol.iterator) </strong>不存在，因此表明对象是不可迭代的。</p><p id="87ec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">为循环</strong></p><p id="a98a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从上一段我们看到，对象是不可迭代的，所以试图使用 for 循环来迭代对象的元素是行不通的，因为对象不是基于索引的数组。因此在对象上使用 for 循环是不可能的。</p><p id="a2de" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">为……的</strong></p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="4064" class="mo ku in mk b gy mp mq l mr ms">let movieReviews={<br/>    Avater:10,<br/>    SpiderMan:9.5,<br/>    Merlin:7.8,<br/>    Wakanda:8.9,<br/>    JamesBond:8.3<br/>}<br/><br/>for(let movie of movieReviews){<br/>    console.log(movie);<br/>}<br/>//output<br/>TypeError: movieReviews is not iterable<br/>    at Object.&lt;anonymous&gt; (c:\Users\ADMIN\Desktop\CSS-in-Depth\index.js:9:18)<br/>    at Module._compile (node:internal/modules/cjs/loader:1155:14)<br/>    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1209:10)<br/>    at Module.load (node:internal/modules/cjs/loader:1033:32)<br/>    at Function.Module._load (node:internal/modules/cjs/loader:868:12)<br/>    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)<br/>    at node:internal/main/run_main_module:22:47</span></pre><p id="4442" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此外，使用 for…of 循环直接遍历对象的属性是行不通的。从上图中我们可以看出，这给了我们一个错误，因为一个对象不是可迭代的。它们没有像数组和字符串那样的索引。但是有一个方法可以解决这个问题！通过使用 objects 静态方法调用<strong class="jx io"> key()和</strong>values()。这两个方法都以你想要获取键值的对象作为参数。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="3bea" class="mo ku in mk b gy mp mq l mr ms">let obj ={<br/>name:"kenechukwu",<br/>age:27,<br/>address:"Nigeria"<br/>}<br/>let prop = Object.keys(obj);<br/>console.log(prop)<br/>//output<br/> ['name', 'age', 'address']<br/>/*<br/> returns an array that contains all the keys of the object "obj"<br/>*/<br/>let val = Object.values(obj)<br/>console.log(val)<br/>//output<br/>['kenechukwu', 25, 'Nigeria']<br/><br/>/*<br/> returns an array that contains all the values of the object "obj"<br/>*/</span></pre><p id="b587" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们看看如何使用 for…of 来使用这两个静态方法迭代一个对象</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="1fdc" class="mo ku in mk b gy mp mq l mr ms">let obj ={<br/>name:"kenechukwu",<br/>age:27,<br/>address:"Nigeria"<br/>}<br/>// for the keys<br/>for(let k of Object.keys(obj)){<br/>console.log(k)<br/>}<br/>//output<br/>name<br/>age<br/>address<br/>// for the values<br/>for(let k of Object.values(obj)){<br/>console.log(k)<br/>}<br/>//output<br/>kenechukwu<br/>27<br/>Nigeria<br/>// if we want to print the values side by side to the keys<br/>for(let k of Object.keys(obj)){<br/>console.log(k,obj[k])<br/>}<br/>//output<br/>name kenechukwu<br/>age 27<br/>address Nigeria</span></pre><p id="3bbb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如你所看到的，这种遍历对象内容的方法似乎太长了，可能会有点混乱。但是随着 ES6(ECMAScript6)的出现，这个问题得到了解决！。提供了一种遍历对象内容的新方法。</p><p id="da59" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">用于</strong>中的……</p><p id="6d27" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是在 ES6 中引入的，以便提供一种简单快速的方法来遍历对象的内容。让我们看一些代码片段，看看它是如何做到的</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="7961" class="mo ku in mk b gy mp mq l mr ms">let movieReviews = {<br/>    Avater: 10,<br/>    SpiderMan: 9.5,<br/>    Merlin: 7.8,<br/>    Wakanda: 8.9,<br/>    JamesBond: 8.3<br/>}<br/>for(let k in movieReviews){<br/>    console.log(k)<br/>}<br/>// This loops through the keys of the object only, not the values<br/>//output<br/>Avater<br/>SpiderMan<br/>Merlin<br/>Wakanda<br/>JamesBond<br/>// to get the values we use bracket notation method of object<br/><br/>for(let k in movieReviews){<br/>    console.log(movieReviews[k])<br/>}<br/>//output<br/>10<br/>9.5<br/>7.8<br/>8.9<br/>8.3</span></pre><h1 id="0b7a" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结论</h1><p id="3cf4" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">我们可以看到,<strong class="jx io"> for 循环</strong>在不可迭代的数据结构上根本不起作用，而的<strong class="jx io">for…并不直接处理它，只是使用一些对象静态方法 key()和 values()才起作用。只有在 ES6 中引入的</strong>循环中的<strong class="jx io">for……可以直接处理 object 之类的不可迭代数据结构。但是循环</strong>的<strong class="jx io">，循环</strong>的<strong class="jx io">和循环</strong>中的<strong class="jx io">可以很好地处理可迭代数据结构。</strong></p></div></div>    
</body>
</html>