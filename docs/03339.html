<html>
<head>
<title>Docker — The Most Loved Platform Every Developer Must Learn</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">docker——每个开发人员必须学习的最受欢迎的平台</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/docker-the-most-loved-platform-every-developer-must-learn-6e5bb702c97b?source=collection_archive---------4-----------------------#2020-10-24">https://blog.devgenius.io/docker-the-most-loved-platform-every-developer-must-learn-6e5bb702c97b?source=collection_archive---------4-----------------------#2020-10-24</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="cdc4" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">实际上，根据 Stack Overflow 调查，它是第二大最受开发者喜爱的平台。</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/0417b94e20aef95750d4d809dbdb04a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0P8yN5cxx6fHxvyY4imIHw.jpeg"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated">在<a class="ae kw" href="https://unsplash.com/s/photos/ship-with-containers?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kw" href="https://unsplash.com/@hdbernd?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Bernd Dittrich </a>拍摄的照片</figcaption></figure><p id="5ed2" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">您有没有想过，在一个已经有虚拟机应用程序的时代，我们为什么要转向基于容器的应用程序？docker 是如何让开发的任务变得更简单的？<em class="lt">一些顶级科技公司，如谷歌、亚马逊网络服务(AWS)、英特尔、特斯拉和瞻博网络，都有自己的定制版本的容器引擎。</em>他们严重依赖 it 来构建、运行、管理和分发他们的应用程序。在尝试判断有用性之前，您应该在入门时了解围绕 Docker 生态系统的最重要的元素和工具。我们来看看什么是 Docker，了解一下它的概念。</p><h1 id="01d5" class="lu lv ir bd lw lx ly lz ma mb mc md me jx mf jy mg ka mh kb mi kd mj ke mk ml bi translated">Docker 是什么鬼东西？</h1><p id="9b7b" class="pw-post-body-paragraph kx ky ir kz b la mm js lc ld mn jv lf lg mo li lj lk mp lm ln lo mq lq lr ls ik bi translated">Docker 是虚拟机(VM)的轻量级替代方案，旨在通过使用容器来简化应用程序的创建、部署和运行。维基百科对 Docker 的定义是，</p><blockquote class="mr"><p id="efb2" class="ms mt ir bd mu mv mw mx my mz na ls dk translated"><em class="nb">“一个开源项目，通过在 Linux 上提供一个额外的抽象层和</em><strong class="ak"><em class="nb">【OS-level virtual ization】</em></strong><em class="nb">的自动化，在</em><em class="nb">容器</em>  <em class="nb">中自动部署软件应用程序。”</em></p></blockquote><p id="9a5b" class="pw-post-body-paragraph kx ky ir kz b la nc js lc ld nd jv lf lg ne li lj lk nf lm ln lo ng lq lr ls ik bi translated">在任何主机操作系统上，我们都有一个 docker 引擎来运行其上的多个容器。这些 docker 容器上运行着一个应用程序，该应用程序又配备了运行该应用程序所需的所有二进制文件和库。</p><h1 id="ef41" class="lu lv ir bd lw lx ly lz ma mb mc md me jx mf jy mg ka mh kb mi kd mj ke mk ml bi translated">但是为什么是 Docker？</h1><p id="e95a" class="pw-post-body-paragraph kx ky ir kz b la mm js lc ld mn jv lf lg mo li lj lk mp lm ln lo mq lq lr ls ik bi translated">在 Docker 出现之前，行业面临的挑战是，在一台机器上开发的应用程序只能在开发环境中运行，而不能在测试或生产环境中运行。这是因为开发和生产之间的计算环境不同。这是 dockerization 使我们的任务更容易的时候。</p><p id="e290" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">Docker 在整个软件开发生命周期(SDLC)中提供了一致的环境，从而在整个生命周期中提供了更好的生产力。</p><h1 id="02ee" class="lu lv ir bd lw lx ly lz ma mb mc md me jx mf jy mg ka mh kb mi kd mj ke mk ml bi translated">集装箱化与虚拟化</h1><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj nh"><img src="../Images/196ce8d5e61ce0aa3b4d20e16005ef6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*fiPE0rcBAooUGLS9QetciQ.png"/></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated">虚拟化(左)和停靠化(右)的图示比较。<em class="nb">图片来源:谷歌</em></figcaption></figure><p id="8119" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在虚拟化中，每个应用程序都在虚拟机上运行，该虚拟机在主机操作系统上导入一个来宾操作系统。这样，我们可以在同一台机器上运行不同的应用程序。现在您可能想知道虚拟化的问题是什么？一个主要缺点是在同一主机系统上运行许多虚拟机会降低系统的性能。在该主机操作系统上运行的客户操作系统有其自己的一组内核库和依赖项，这些内核库和依赖项会占用大量资源，如硬盘处理器和 RAM，并且在启动实时应用程序时会花费很多时间。</p><p id="46eb" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">集装箱运输就这样被引进了。这里不需要来宾操作系统，相反，应用程序将利用主机操作系统。因此，每个容器都将共享主机操作系统，并且每个容器中都有自己的应用程序和库。容器将根据它们的需求使用 RAM 和磁盘空间，从而大大提高系统的性能。</p><h1 id="a60d" class="lu lv ir bd lw lx ly lz ma mb mc md me jx mf jy mg ka mh kb mi kd mj ke mk ml bi translated">Docker 网络的图示概述</h1><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj ni"><img src="../Images/adcc9807526846274d58f68d191929aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U7r7W6uQx5q2xLLmpljZ6Q.png"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated">Docker 概述。<em class="nb">图片来源——谷歌</em></figcaption></figure><h1 id="c2fc" class="lu lv ir bd lw lx ly lz ma mb mc md me jx mf jy mg ka mh kb mi kd mj ke mk ml bi translated">Dockerfile 文件</h1><p id="f2c9" class="pw-post-body-paragraph kx ky ir kz b la mm js lc ld mn jv lf lg mo li lj lk mp lm ln lo mq lq lr ls ik bi translated">Dockerfile 是一个文本文件(没有任何。txt 扩展名)，用于构建包含所有项目代码的 docker 映像。这个文件包含定制 docker 映像的命令和参数。Docker 可以通过读取 docker 文件中的指令来自动构建映像。</p><h2 id="62ed" class="nj lv ir bd lw nk nl dn ma nm nn dp me lg no np mg lk nq nr mi lo ns nt mk nu bi translated">Dockerfile 中使用的命令</h2><ul class=""><li id="c4ff" class="nv nw ir kz b la mm ld mn lg nx lk ny lo nz ls oa ob oc od bi translated"><strong class="kz is"> FROM → </strong> <em class="lt">定义一个用于启动构建过程的基础映像</em>。</li><li id="07e7" class="nv nw ir kz b la oe ld of lg og lk oh lo oi ls oa ob oc od bi translated"><strong class="kz is">维护者→ </strong> <em class="lt">该图像维护者的姓名和邮箱。</em></li><li id="2ece" class="nv nw ir kz b la oe ld of lg og lk oh lo oi ls oa ob oc od bi translated"><strong class="kz is">复制<em class="lt"> → </em> </strong> <em class="lt">将文件或目录复制到镜像中。</em></li><li id="6c1f" class="nv nw ir kz b la oe ld of lg og lk oh lo oi ls oa ob oc od bi translated"><strong class="kz is">添加<em class="lt">→</em></strong><em class="lt"/><strong class="kz is"><em class="lt"/></strong><em class="lt">与 COPY 相同，其中包含两个自变量 source 和 destination path。</em></li><li id="dc50" class="nv nw ir kz b la oe ld of lg og lk oh lo oi ls oa ob oc od bi translated"><strong class="kz is">运行<em class="lt"> → </em> </strong> <em class="lt">将命令作为参数运行，形成镜像，比如 apt-get install。</em></li><li id="23b3" class="nv nw ir kz b la oe ld of lg og lk oh lo oi ls oa ob oc od bi translated"><strong class="kz is"> CMD <em class="lt"> → </em> </strong> <em class="lt">容器初始化时运行的默认命令。可以用命令行参数覆盖。</em></li><li id="2f45" class="nv nw ir kz b la oe ld of lg og lk oh lo oi ls oa ob oc od bi translated"><strong class="kz is"> ENV → </strong> <em class="lt">在容器中设置一个环境变量。</em></li><li id="5120" class="nv nw ir kz b la oe ld of lg og lk oh lo oi ls oa ob oc od bi translated"><strong class="kz is">暴露<em class="lt"> → </em> </strong> <em class="lt">从容器中暴露端口。必须通过运行命令使用-P 或-p 向主机显式公开。</em></li><li id="ce8a" class="nv nw ir kz b la oe ld of lg og lk oh lo oi ls oa ob oc od bi translated"><strong class="kz is">卷<em class="lt"> → </em> </strong> <em class="lt">指定一个目录，用于存储与容器相关的文件内容。</em></li><li id="554e" class="nv nw ir kz b la oe ld of lg og lk oh lo oi ls oa ob oc od bi translated"><strong class="kz is">入口点<em class="lt"> → </em> </strong> <em class="lt">用于覆盖 cmd 命令。当容器运行时，这个命令是为构建的映像执行的第一个命令。</em></li><li id="727e" class="nv nw ir kz b la oe ld of lg og lk oh lo oi ls oa ob oc od bi translated"><strong class="kz is">用户<em class="lt"> </em> </strong> <em class="lt"> →为运行、CMD 和进入点设置用户。</em></li><li id="61eb" class="nv nw ir kz b la oe ld of lg og lk oh lo oi ls oa ob oc od bi translated"><strong class="kz is"> WORKDIR <em class="lt"> → </em> </strong> <em class="lt">设置运行、CMD、入口点、添加和复制的工作目录。</em></li></ul><h1 id="df7b" class="lu lv ir bd lw lx ly lz ma mb mc md me jx mf jy mg ka mh kb mi kd mj ke mk ml bi translated">Docker 图像</h1><p id="b8c4" class="pw-post-body-paragraph kx ky ir kz b la mm js lc ld mn jv lf lg mo li lj lk mp lm ln lo mq lq lr ls ik bi translated">映像是一个蓝图，可以从它开始任意数量的全新容器。它只读取用于创建容器的模板(<em class="lt"> Dockerfile </em>)。它包含特定应用程序的所有依赖项和要求。</p><h1 id="35ff" class="lu lv ir bd lw lx ly lz ma mb mc md me jx mf jy mg ka mh kb mi kd mj ke mk ml bi translated">码头集装箱</h1><p id="604f" class="pw-post-body-paragraph kx ky ir kz b la mm js lc ld mn jv lf lg mo li lj lk mp lm ln lo mq lq lr ls ik bi translated">假设您希望运行一个与系统中的其他东西隔离的命令。它应该只访问允许它访问的资源(存储、CPU、内存)，并且不知道机器上还有其他东西。在容器中运行的进程认为它是唯一的，并且只看到了映像中描述的内容的准系统 Linux 发行版。</p><p id="0142" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><em class="lt">这听起来很像虚拟机，对吗？是的。只有容器启动更快，资源开销更少。<strong class="kz is">这是一个 Docker 映像的运行时实例。它包含运行应用程序所需的一切。</strong>一个或多个图像可以用来构建一个容器。运行容器的机器不应该太关心里面有什么，dockerized 应用程序不关心它是在 Kubernetes 集群上还是在单个服务器上，反正它将能够运行。一个容器可以同时运行多个进程。但是我更愿意把它限制在一个，我还没有看到任何这样做的事情。你可以将许多服务打包到一个容器中(比如说<a class="ae kw" href="https://www.nginx.com/" rel="noopener ugc nofollow" target="_blank"> <em class="lt"> Nginx </em> </a>)，并让它们一起运行。</em></p><h1 id="66f3" class="lu lv ir bd lw lx ly lz ma mb mc md me jx mf jy mg ka mh kb mi kd mj ke mk ml bi translated">Docker 卷</h1><p id="da37" class="pw-post-body-paragraph kx ky ir kz b la mm js lc ld mn jv lf lg mo li lj lk mp lm ln lo mq lq lr ls ik bi translated">图像永远不会改变，只是你创造了新的，但仅此而已。另一方面，默认情况下，容器不会留下任何东西。如果您没有将容器保存为图像，对容器所做的任何更改都会在删除后立即丢失。因此，容器本质上是短暂的。</p><p id="bca0" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">但是数据持久化真的没有用吗？没错。这就是 docker 卷的用武之地。当启动 Docker 容器时，您可以指定某些目录是本地目录(主机)或卷的挂载点。写入主机装载目录的数据很容易理解(因为您知道它在哪里)，卷用于保存持久数据或共享数据，但是在使用它们时，您不必了解主机的任何信息。您可以创建一个卷，Docker 确保它在那里，并保存在主机系统的某个地方。</p><h1 id="d1df" class="lu lv ir bd lw lx ly lz ma mb mc md me jx mf jy mg ka mh kb mi kd mj ke mk ml bi translated">码头枢纽</h1><p id="7a19" class="pw-post-body-paragraph kx ky ir kz b la mm js lc ld mn jv lf lg mo li lj lk mp lm ln lo mq lq lr ls ik bi translated"><a class="ae kw" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>是 Docker 提供的一项服务，用于查找容器图像并与您的团队共享。它也称为容器注册表。</p><p id="2f24" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">它提供了以下主要功能:</p><ul class=""><li id="015f" class="nv nw ir kz b la lb ld le lg oj lk ok lo ol ls oa ob oc od bi translated"><strong class="kz is">存储库:</strong>推和拉容器图像。</li><li id="e054" class="nv nw ir kz b la oe ld of lg og lk oh lo oi ls oa ob oc od bi translated"><strong class="kz is">团队&amp;组织:</strong>管理对容器映像私有存储库的访问。</li><li id="df0e" class="nv nw ir kz b la oe ld of lg og lk oh lo oi ls oa ob oc od bi translated"><strong class="kz is">官方图片:</strong>拉取使用 Docker 提供的优质集装箱图片。</li><li id="1b78" class="nv nw ir kz b la oe ld of lg og lk oh lo oi ls oa ob oc od bi translated"><strong class="kz is">发布者图像:</strong>拉取并使用外部供应商提供的高质量容器图像。认证映像还包括支持和保证与 Docker Enterprise 的兼容性。</li><li id="7ef9" class="nv nw ir kz b la oe ld of lg og lk oh lo oi ls oa ob oc od bi translated"><strong class="kz is">构建:</strong>从 GitHub 和 Bitbucket 自动构建容器映像，并推送到 Docker Hub。</li><li id="dd3c" class="nv nw ir kz b la oe ld of lg og lk oh lo oi ls oa ob oc od bi translated"><strong class="kz is"> Webhooks: </strong>在成功推送存储库后触发动作，将 Docker Hub 与其他服务集成。</li></ul><h1 id="7889" class="lu lv ir bd lw lx ly lz ma mb mc md me jx mf jy mg ka mh kb mi kd mj ke mk ml bi translated"><strong class="ak">被迷住了吗？让我们安装 Docker </strong></h1><p id="e5b8" class="pw-post-body-paragraph kx ky ir kz b la mm js lc ld mn jv lf lg mo li lj lk mp lm ln lo mq lq lr ls ik bi translated">为了安装 Docker，你可以去他们的官网。</p><div class="om on gq gs oo op"><a href="https://docs.docker.com/engine/install/" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fp"><div class="or ab os cl cj ot"><h2 class="bd is gz z fq ou fs ft ov fv fx iq bi translated">安装 Docker 引擎</h2><div class="ow l"><h3 class="bd b gz z fq ou fs ft ov fv fx dk translated">Docker Engine 可在多种 Linux 平台、macOS 和 Windows 10 上通过 Docker Desktop 获得，并作为…</h3></div><div class="ox l"><p class="bd b dl z fq ou fs ft ov fv fx dk translated">docs.docker.com</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd kq op"/></div></div></a></div><p id="0191" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">你也可以使用 docker 的官方平台，在那里你可以尝试下面的命令来开始使用 docker。</p><div class="om on gq gs oo op"><a href="https://www.docker.com/play-with-docker" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fp"><div class="or ab os cl cj ot"><h2 class="bd is gz z fq ou fs ft ov fv fx iq bi translated">和 Docker 一起玩</h2><div class="ow l"><h3 class="bd b gz z fq ou fs ft ov fv fx dk translated">通过活动、在线资源和 Docker 程序与其他 Docker 用户联系。</h3></div><div class="ox l"><p class="bd b dl z fq ou fs ft ov fv fx dk translated">www.docker.com</p></div></div><div class="oy l"><div class="pe l pa pb pc oy pd kq op"/></div></div></a></div><h1 id="3a38" class="lu lv ir bd lw lx ly lz ma mb mc md me jx mf jy mg ka mh kb mi kd mj ke mk ml bi translated">使用 Docker 的命令</h1><p id="7d30" class="pw-post-body-paragraph kx ky ir kz b la mm js lc ld mn jv lf lg mo li lj lk mp lm ln lo mq lq lr ls ik bi translated">现在你已经安装了 Docker 或者登录到了操场，试试下面的命令，看看会发生什么。<em class="lt">你可以阅读大量的博客，但你只能在实践中学习，除非你是</em> <a class="ae kw" href="https://getyarn.io/yarn-clip/c4c5ea76-f603-41e3-aa28-abf56829f1a3" rel="noopener ugc nofollow" target="_blank"> <em class="lt">斯蒂芬·斯奇特过目不忘</em> </a> <em class="lt">。</em></p><p id="3df5" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">与图像交互的命令:</p><ul class=""><li id="cbb7" class="nv nw ir kz b la lb ld le lg oj lk ok lo ol ls oa ob oc od bi translated"><strong class="kz is"> docker 图像</strong> : <em class="lt">显示所有图像。</em></li><li id="169b" class="nv nw ir kz b la oe ld of lg og lk oh lo oi ls oa ob oc od bi translated"><strong class="kz is"> docker 导入:</strong> <em class="lt">从 tarball 创建图像。</em></li><li id="06d3" class="nv nw ir kz b la oe ld of lg og lk oh lo oi ls oa ob oc od bi translated"><strong class="kz is"> docker build: </strong> <em class="lt">从 Dockerfile 创建一个图像。</em></li><li id="ec2b" class="nv nw ir kz b la oe ld of lg og lk oh lo oi ls oa ob oc od bi translated"><strong class="kz is"> docker 提交:</strong> <em class="lt">从容器中创建一个图像。</em></li><li id="3dc0" class="nv nw ir kz b la oe ld of lg og lk oh lo oi ls oa ob oc od bi translated"><strong class="kz is"> docker rmi: </strong> <em class="lt">删除图像。</em></li><li id="f933" class="nv nw ir kz b la oe ld of lg og lk oh lo oi ls oa ob oc od bi translated"><strong class="kz is"> docker 历史:</strong> <em class="lt">列出一个图像的变化。</em></li></ul><p id="a27e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">与容器交互的命令:</p><ul class=""><li id="ada6" class="nv nw ir kz b la lb ld le lg oj lk ok lo ol ls oa ob oc od bi translated"><strong class="kz is"> docker -v </strong> : <em class="lt">显示 docker </em>当前安装的版本</li><li id="ad21" class="nv nw ir kz b la oe ld of lg og lk oh lo oi ls oa ob oc od bi translated"><strong class="kz is">docker–help</strong>:<em class="lt">列出了 docker </em>中可用的命令</li><li id="9ca6" class="nv nw ir kz b la oe ld of lg og lk oh lo oi ls oa ob oc od bi translated"><strong class="kz is"> docker pull </strong> : <em class="lt">将图像拉至 docker hub 库</em></li><li id="a3fc" class="nv nw ir kz b la oe ld of lg og lk oh lo oi ls oa ob oc od bi translated"><strong class="kz is"> docker run -it -d </strong> : <em class="lt">从图像中创建一个容器</em></li><li id="96cb" class="nv nw ir kz b la oe ld of lg og lk oh lo oi ls oa ob oc od bi translated"><strong class="kz is"> docker ps </strong> : <em class="lt">列出正在运行的容器</em></li><li id="30bd" class="nv nw ir kz b la oe ld of lg og lk oh lo oi ls oa ob oc od bi translated"><strong class="kz is"> docker ps -a </strong> : <em class="lt">显示所有运行和退出的容器</em></li><li id="960e" class="nv nw ir kz b la oe ld of lg og lk oh lo oi ls oa ob oc od bi translated"><strong class="kz is"> docker exec -it bash </strong> : <em class="lt">访问正在运行的容器(用于检查日志)</em></li><li id="762b" class="nv nw ir kz b la oe ld of lg og lk oh lo oi ls oa ob oc od bi translated"><strong class="kz is">停靠站</strong> : <em class="lt">停止运行中的容器</em></li><li id="4b6b" class="nv nw ir kz b la oe ld of lg og lk oh lo oi ls oa ob oc od bi translated"><strong class="kz is"> docker kill </strong> : <em class="lt">通过立即停止执行来杀死容器</em></li><li id="c749" class="nv nw ir kz b la oe ld of lg og lk oh lo oi ls oa ob oc od bi translated"><strong class="kz is"> docker 登录</strong> : <em class="lt">登录 docker hub 库</em></li><li id="0017" class="nv nw ir kz b la oe ld of lg og lk oh lo oi ls oa ob oc od bi translated"><strong class="kz is"> docker 推送</strong> : <em class="lt">将图像推送到 docker hub 库</em></li><li id="70c5" class="nv nw ir kz b la oe ld of lg og lk oh lo oi ls oa ob oc od bi translated"><strong class="kz is"> docker images </strong> : <em class="lt">列出本地存储库中的所有图像</em></li><li id="b72d" class="nv nw ir kz b la oe ld of lg og lk oh lo oi ls oa ob oc od bi translated"><strong class="kz is"> docker 构建</strong> : <em class="lt">从指定的 docker 文件</em>构建图像</li><li id="c7fe" class="nv nw ir kz b la oe ld of lg og lk oh lo oi ls oa ob oc od bi translated"><strong class="kz is"> docker 导出</strong> : <em class="lt">将容器的文件系统导出为 tar 存档</em></li><li id="a8bf" class="nv nw ir kz b la oe ld of lg og lk oh lo oi ls oa ob oc od bi translated"><strong class="kz is"> docker 导入</strong> : <em class="lt">从 tarball 导入内容以创建文件系统映像</em></li><li id="b8bf" class="nv nw ir kz b la oe ld of lg og lk oh lo oi ls oa ob oc od bi translated"><strong class="kz is">码头集装箱</strong> : <em class="lt">对集装箱</em>进行各种操作</li><li id="d9a5" class="nv nw ir kz b la oe ld of lg og lk oh lo oi ls oa ob oc od bi translated"><strong class="kz is"> docker 容器日志</strong> : <em class="lt">指定容器的日志</em></li><li id="3364" class="nv nw ir kz b la oe ld of lg og lk oh lo oi ls oa ob oc od bi translated"><strong class="kz is">码头集装箱</strong> <strong class="kz is">杀死</strong> : <em class="lt">杀死集装箱</em></li><li id="284f" class="nv nw ir kz b la oe ld of lg og lk oh lo oi ls oa ob oc od bi translated"><strong class="kz is">码头集装箱 rm </strong> : <em class="lt">删除停止的集装箱</em></li><li id="b1b1" class="nv nw ir kz b la oe ld of lg og lk oh lo oi ls oa ob oc od bi translated"><strong class="kz is"> docker 容器</strong>开始 : <em class="lt">开始一个容器</em></li></ul><h1 id="7fde" class="lu lv ir bd lw lx ly lz ma mb mc md me jx mf jy mg ka mh kb mi kd mj ke mk ml bi translated">等等，有缺点？</h1><p id="a0e9" class="pw-post-body-paragraph kx ky ir kz b la mm js lc ld mn jv lf lg mo li lj lk mp lm ln lo mq lq lr ls ik bi translated">具有不同操作系统要求的应用程序不能一起托管在同一个 Docker 主机上。例如，假设我们有 4 个不同的应用程序，其中 3 个应用程序需要基于 Linux 的操作系统，另一个应用程序需要基于 Windows 的操作系统。在这种情况下，需要基于 Linux 的操作系统的 3 个应用程序可以托管在单个 Docker 主机上，而需要基于 Windows 的操作系统的应用程序需要托管在不同的 Docker 主机上。</p><h1 id="4c40" class="lu lv ir bd lw lx ly lz ma mb mc md me jx mf jy mg ka mh kb mi kd mj ke mk ml bi translated">这是一个总结！</h1><p id="4d19" class="pw-post-body-paragraph kx ky ir kz b la mm js lc ld mn jv lf lg mo li lj lk mp lm ln lo mq lq lr ls ik bi translated">希望您对 Docker 及其有用性有所了解。既然现在 Docker 已经被用的无处不在，那可就有点吃不消了。<a class="ae kw" href="https://insights.stackoverflow.com/survey/2020#most-loved-dreaded-and-wanted" rel="noopener ugc nofollow" target="_blank">根据 2020 年堆栈溢出调查，Docker 是第二大最受开发者喜爱的平台</a>。希望你能明白为什么 Docker 如此重要，为什么每个开发人员都必须学习它。当然，这篇文章不会让你成为<em class="lt"> Docker Jedi </em>，你可以在他们的官方文档中了解更多。</p><div class="om on gq gs oo op"><a href="https://docs.docker.com/" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fp"><div class="or ab os cl cj ot"><h2 class="bd is gz z fq ou fs ft ov fv fx iq bi translated">码头文件</h2><div class="ow l"><h3 class="bd b gz z fq ou fs ft ov fv fx dk translated">Docker 文档的主页</h3></div><div class="ox l"><p class="bd b dl z fq ou fs ft ov fv fx dk translated">docs.docker.com</p></div></div><div class="oy l"><div class="pf l pa pb pc oy pd kq op"/></div></div></a></div></div><div class="ab cl pg ph hv pi" role="separator"><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl"/></div><div class="ik il im in io"><p id="a09b" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">如果你喜欢读这篇文章，你可能也会发现下面的文章值得你花时间去读。</p><div class="om on gq gs oo op"><a rel="noopener  ugc nofollow" target="_blank" href="/features-that-every-developer-must-know-about-spring-boot-c1c0d7f1c0a8"><div class="oq ab fp"><div class="or ab os cl cj ot"><h2 class="bd is gz z fq ou fs ft ov fv fx iq bi translated">每个开发人员都必须知道的关于 Spring Boot 的特性</h2><div class="ow l"><h3 class="bd b gz z fq ou fs ft ov fv fx dk translated">该框架通常被称为“类固醇上的弹簧”，的确如此。</h3></div><div class="ox l"><p class="bd b dl z fq ou fs ft ov fv fx dk translated">blog.devgenius.io</p></div></div><div class="oy l"><div class="pn l pa pb pc oy pd kq op"/></div></div></a></div><div class="om on gq gs oo op"><a href="https://python.plainenglish.io/design-patterns-that-every-software-developer-must-know-ac71f575e68" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fp"><div class="or ab os cl cj ot"><h2 class="bd is gz z fq ou fs ft ov fv fx iq bi translated">每个软件开发人员都必须知道的设计模式</h2><div class="ow l"><h3 class="bd b gz z fq ou fs ft ov fv fx dk translated">这些久经考验的解决方案提高了编程效率。</h3></div><div class="ox l"><p class="bd b dl z fq ou fs ft ov fv fx dk translated">python .平原英语. io</p></div></div><div class="oy l"><div class="po l pa pb pc oy pd kq op"/></div></div></a></div><div class="om on gq gs oo op"><a href="https://medium.com/swlh/comprehensive-notes-for-java-8-features-every-developer-must-have-c08efc8ba39" rel="noopener follow" target="_blank"><div class="oq ab fp"><div class="or ab os cl cj ot"><h2 class="bd is gz z fq ou fs ft ov fv fx iq bi translated">每个开发人员都必须具备的 Java 8 特性的综合说明</h2><div class="ow l"><h3 class="bd b gz z fq ou fs ft ov fv fx dk translated">Java SE 15 于 2020 年 9 月发布，附带一系列特性，但 Java 8 特性仍然是最…</h3></div><div class="ox l"><p class="bd b dl z fq ou fs ft ov fv fx dk translated">medium.com</p></div></div><div class="oy l"><div class="pp l pa pb pc oy pd kq op"/></div></div></a></div></div></div>    
</body>
</html>