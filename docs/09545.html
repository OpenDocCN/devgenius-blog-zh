<html>
<head>
<title>Learning Go, A Journey: Functions and Pointers #4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习围棋之旅:函数和指针#4</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/learning-go-a-journey-functions-and-pointers-4-cce061463ce4?source=collection_archive---------10-----------------------#2022-08-27">https://blog.devgenius.io/learning-go-a-journey-functions-and-pointers-4-cce061463ce4?source=collection_archive---------10-----------------------#2022-08-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="79aa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">大家好！很高兴再次见到你，我希望你过得很好。在这篇文章中，我想分享我在学习 Go 编程语言方面的进步。本周，我学习了函数和指针。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/56c16bf8aba3af451a09a47db79a9667.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9_miAcJW2ysU0hQwTJvggg.png"/></div></div></figure><h1 id="9473" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">功能</h1><p id="4158" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">函数允许我们将代码模块化成几个函数或包。我们可以将我们的代码分成不同目标的小块。要声明一个函数，我们可以使用以下语法</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/a9a1e9c1f41e532dc5d8de118805de43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oOXLFbuSfCx0lkT7"/></div></div></figure><ul class=""><li id="3f83" class="ly lz in jm b jn jo jr js jv ma jz mb kd mc kh md me mf mg bi translated">一个函数可以作为另一个类型的方法附加到该类型上(我们将在本文后面看到)</li><li id="0562" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated">一个函数有参数(可以没有也可以有一个以上的参数)当我们调用一个函数时，一个值被传递给一个叫做 arguments 的参数。</li><li id="76e8" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated">一个函数可以不返回任何值或返回 1 个以上的值</li></ul><p id="367b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，我们可以创建一个名为 sum 的函数来对两个值求和</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/a00645c7f4b60c75afe21deefa33c648.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wbP4USdvbzM1Mim_"/></div></div></figure><p id="c285" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">或者，如果我们想返回一个值，我们可以这样做</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/81f3f29102df50016fd01fba84001718.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*s8r44CBDoHfjnsin"/></div></div></figure><p id="b524" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如我们所看到的，如果我们从一个函数返回值，我们必须定义返回类型。现在，如果我们必须返回不止一个值呢？我们可以这样做</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/add8845e1bb4148b1dcd65b17045de7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*v-u5FBZA8utifF3F"/></div></div></figure><h2 id="1936" class="mm kv in bd kw mn mo dn la mp mq dp le jv mr ms li jz mt mu lm kd mv mw lq mx bi translated">可变参数</h2><p id="a49d" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">正如我之前提到的，函数可以带参数。该参数可以大于 1，甚至可以为零。如果我们想要传递很多参数，我们必须定义每个参数吗？答案是否定的，我们可以用可变参数来实现。例如</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi my"><img src="../Images/a09ec2861f5ddb455d3f25f5cb0dabec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*REDXY0Yh97XeNfFo"/></div></div></figure><p id="9587" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如我们所看到的，sum 函数的参数是用 int 类型的可变参数定义的。所以当我们调用 sum 函数时，我们可以传递任意多的参数。如果我们不给函数传递任何参数会怎么样？sum 函数中的值“a”将是一个空切片，它将返回 0。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi my"><img src="../Images/0310937a6d4bc855e1a26dffd1bf1464.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*THz_sQpj9iV0q2di"/></div></div></figure><h2 id="e3cb" class="mm kv in bd kw mn mo dn la mp mq dp le jv mr ms li jz mt mu lm kd mv mw lq mx bi translated">展开切片</h2><p id="2517" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">继续前面的讨论，如果我们想把一个片作为一个变量传递给一个有可变参数的函数呢？我们可以使用展开切片(实际上托德·麦克劳德称之为展开切片)。例如</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi my"><img src="../Images/ba699d66fe67f2c517cfc85af8a94d3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kI2ow8uyY6DlDd-V"/></div></div></figure><h2 id="ca3b" class="mm kv in bd kw mn mo dn la mp mq dp le jv mr ms li jz mt mu lm kd mv mw lq mx bi translated">推迟</h2><p id="cf48" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">“defer”语句调用一个函数，该函数的执行被延迟到周围函数返回的时刻，这可能是因为周围函数执行了一个 return 语句，到达了其函数体的末尾，也可能是因为相应的 goroutine 正在死机。例如</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/7286d8de0e86ae30ef65601a41e539bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*M1-RmuqtY3h1Onhj"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/55317ad3ba2faf1a4db56d7ce0d8de03.png" data-original-src="https://miro.medium.com/v2/resize:fit:354/0*Vodt5HQJt97Znd-x"/></div></figure><p id="03c0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们看到我们的代码流，func foo 应该在我们打印出“world”之前运行。但是，我们在调用 foo 之前添加了一个关键字“defer”。结果是函数 foo 在函数 main 退出之前运行</p><h2 id="7dab" class="mm kv in bd kw mn mo dn la mp mq dp le jv mr ms li jz mt mu lm kd mv mw lq mx bi translated">方法</h2><p id="c255" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">方法是附加到类型的函数。例如</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/8573ed91e28d0cfc2f658ed127d9446d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*b22QCQxYFVM5VRMe"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/214e94d255ac521f73d825838af91d31.png" data-original-src="https://miro.medium.com/v2/resize:fit:602/0*v778kcZQeibHIz9J"/></div></figure><p id="6c0e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如我们所看到的，我们将 introduce 函数附加到了类型“person”上。所以每一个类型为“person”的变量，我们都可以调用引入函数。此外，我们可以访问“person”类型的属性。</p><h2 id="af0a" class="mm kv in bd kw mn mo dn la mp mq dp le jv mr ms li jz mt mu lm kd mv mw lq mx bi translated">界面和多态性</h2><p id="fe1d" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">接口类型定义了一个类型集。接口类型的变量可以存储接口类型集中任何类型的值。这种类型被称为实现了接口</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/b9537dc08a50774d6c2bad55a1a02eae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oYazmjkzAcw-P92C"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/6695468cacabb18eef318268fb17a400.png" data-original-src="https://miro.medium.com/v2/resize:fit:344/0*2UKbtj6xNfjMn5r8"/></div></figure><p id="6a27" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如我们所看到的，我们可以定义一个接口类型，它可以存储任何类型的值。因此，当我们创建一个名为“foo”的函数时，它可以接收一个“speak”类型，可以是“person”或“vehicle”</p><h2 id="22bb" class="mm kv in bd kw mn mo dn la mp mq dp le jv mr ms li jz mt mu lm kd mv mw lq mx bi translated">匿名函数</h2><p id="c62b" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">匿名函数是没有标识符的函数。例如</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/28c2398f718aaf62324117709d3a6ac4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6hO9zyw3Xf68o8Wi"/></div></div></figure><h2 id="0553" class="mm kv in bd kw mn mo dn la mp mq dp le jv mr ms li jz mt mu lm kd mv mw lq mx bi translated">函数表达式</h2><p id="3854" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">Func 表达式是指我们将一个函数作为一个变量的值来存储。例如</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/c366aa6a388f4a12d6da67908a62044c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Vfgck-ef2Z93CW1g"/></div></div></figure><h2 id="c4f7" class="mm kv in bd kw mn mo dn la mp mq dp le jv mr ms li jz mt mu lm kd mv mw lq mx bi translated">返回一个函数</h2><p id="6a17" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">一个函数也可以返回一个函数。因为如果我们在 Go 编程语言规范上看到，函数也是类型。例如</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/a279de7063d811375f97e7539e05c416.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uAuJkOZZGxS3zCnf"/></div></div></figure><h2 id="e946" class="mm kv in bd kw mn mo dn la mp mq dp le jv mr ms li jz mt mu lm kd mv mw lq mx bi translated">回收</h2><p id="0fe2" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">回调是指我们将一个函数作为参数传递给另一个函数。例如</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/e1eb551e3322befb85124ccd8a3797f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xIquwoGIy7XmZd2b"/></div></div></figure><h2 id="fa79" class="mm kv in bd kw mn mo dn la mp mq dp le jv mr ms li jz mt mu lm kd mv mw lq mx bi translated">递归</h2><p id="ae9f" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">递归是函数调用自己。递归的一个常见研究案例是阶乘。例如</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/7cf7e8cfe94a38ee56e74fbbb14f2222.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uPoGEKnI35gW1xX9"/></div></div></figure><h1 id="392a" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">两颗北极指极星</h1><p id="e137" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">指针是我们可以指出内存中保存变量的地址的地方。例如</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/39aed47d06bbdcb2a4b132d98fa76a33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_MWCJAa-mAYaU27e"/></div></div></figure><p id="f299" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如我们所看到的，我们可以保存变量的地址，并根据它的地址改变值</p><h2 id="78d4" class="mm kv in bd kw mn mo dn la mp mq dp le jv mr ms li jz mt mu lm kd mv mw lq mx bi translated">何时使用指针</h2><p id="daa8" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">当我们想要存储大量数据并节省大量内存时，就需要使用指针。例如</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/903cbd04aa8c74b9c2a71f920314ddbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NYgFCjTydCl1Y6QX"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/f69c9f932c19b4a37a8aed534c250dca.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/0*e9FmEv6XrzaXcq-l"/></div></figure><p id="3831" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如我们所看到的，当我们想要对变量 x 进行计算而不创建新的变量(这会消耗另一个内存)时，我们可以存储它或者通过使用变量 x 的地址来覆盖它的值。</p><h2 id="f454" class="mm kv in bd kw mn mo dn la mp mq dp le jv mr ms li jz mt mu lm kd mv mw lq mx bi translated">参数指针</h2><p id="024b" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">指针也可以是函数的参数。例如</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/bd84b4cc0d390f5ce145db8c2fc0d493.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8NYNiAq1R1qPw88_"/></div></div></figure><h2 id="9a94" class="mm kv in bd kw mn mo dn la mp mq dp le jv mr ms li jz mt mu lm kd mv mw lq mx bi translated">方法集</h2><p id="ddd4" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">方法集决定什么方法附加到一个类型。顾名思义:给定类型的方法集是什么？这是它的方法集。例如</p><ul class=""><li id="892b" class="ly lz in jm b jn jo jr js jv ma jz mb kd mc kh md me mf mg bi translated">非指针接收器处理指针或非指针值</li><li id="d1cb" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated">指针接收器只能处理指针值</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/fc89212250b741818ad1dda7f9cf28fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:454/0*TO7Yonp0IBr0B4oS"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/c3064fb22f2a8b63684c228f50aeb3e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1AEPYmkLx1DLIQVK"/></div></div></figure></div><div class="ab cl nm nn hr no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ig ih ii ij ik"><p id="13aa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本文到此为止，别忘了留下一个赞，分享给别人。如果您有任何反馈，请在下面留下您的评论。感谢你阅读这篇文章，祝你有美好的一天👋。</p><p id="bc11" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">资源</p><ul class=""><li id="e195" class="ly lz in jm b jn jo jr js jv ma jz mb kd mc kh md me mf mg bi translated"><a class="ae nt" href="https://www.udemy.com/course/learn-how-to-code/" rel="noopener ugc nofollow" target="_blank">学习如何编码:谷歌的 Go (golang)编程语言</a></li><li id="17cb" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated"><a class="ae nt" href="https://go.dev/ref/spec" rel="noopener ugc nofollow" target="_blank">围棋编程语言规范</a></li><li id="d947" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated"><a class="ae nt" href="https://dasarpemrogramangolang.novalagung.com/" rel="noopener ugc nofollow" target="_blank">基础围棋编程</a></li></ul></div></div>    
</body>
</html>