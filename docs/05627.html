<html>
<head>
<title>JavaScript: Fun Intersection of 2 Linked Lists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript:两个链表有趣的交集</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/javascript-fun-intersection-of-2-linked-lists-ae6949594aa9?source=collection_archive---------2-----------------------#2021-09-20">https://blog.devgenius.io/javascript-fun-intersection-of-2-linked-lists-ae6949594aa9?source=collection_archive---------2-----------------------#2021-09-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/3a371dbc31703a554a668c1baae04f33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BxgUmdeRTaUeBl_BoE4T-A.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">寻找两个单链表的交集</figcaption></figure><p id="19f1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这是一个有趣的问题——寻找两个单链表的交点。对于上面的例子，节点 C1 是交叉节点。</p><h1 id="6440" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">天真的解决方案</h1><p id="9335" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">一种简单的方法是遍历链表 A 的每个节点，交叉检查链表 A 中是否存在相同的指针。</p><p id="9e4f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">假设链表 A 长度为<strong class="kb io"> <em class="ma"> M </em> </strong>，链表 B 长度为<strong class="kb io"> <em class="ma"> N. </em> </strong></p><p id="1847" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">时间复杂度为 O(M * N)。</p><p id="2f5a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们可以做得更好。让我们改进解决方案。</p><h1 id="b57f" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">双指针解决方案</h1><p id="cee6" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">让我们用下面的作为问题:</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/0f19ea3f69b1dc90aed4524ac60e609a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EdUtJb21JAWkAmN5NdCEWQ.png"/></div></div></figure><p id="de7e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">两个指针的解决方案是如此巧妙和简单！</p><p id="9c52" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们需要以相反的顺序连接两个链表，<strong class="kb io"> A + B </strong>和<strong class="kb io"> B + A </strong>。这将帮助我们对齐两个列表的末尾。</p><p id="7cb1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们将尾部重定向到另一个链表的头部旁边。a 的尾巴接着去了 B 的头。b 的尾巴接着到了 A 的头上。如下图。</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mf"><img src="../Images/774372bb5099a1fb49d3c2b3497a8d8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OnpSd3qGofjCSHLuUXnnPg.png"/></div></div></figure><p id="7d8f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在两个列表的长度基本相同！</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mg"><img src="../Images/308c0a4107b12ba627f1df9296c333ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c0BcIGenO9ku7KZ29fnc1w.png"/></div></div></figure><p id="21f8" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在我们只需检查两个列表是否在某个点合并或相交于同一个节点。如果它们不相交，当列表结束时，我们将在 null 退出。</p><p id="55bb" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> JavaScript 解决方案:</strong></p><pre class="mb mc md me gt mh mi mj mk aw ml bi"><span id="ed1e" class="mm ky in mi b gy mn mo l mp mq">var getIntersectionNode = function(headA, headB) {<br/>    let a = headA;<br/>    let b = headB;<br/>    <br/>    while (a != b) {<br/>        a = !a ? headB : a.next;<br/>        b = !b ? headA : b.next;<br/>    }<br/>    <br/>    return a;<br/>};</span></pre><p id="3d6d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">总之，如果节点存在，我们继续沿着列表 A 和列表 B 向下移动。如果我们到达一个节点不存在的点。如果我们在列表 A 的末尾，我们就把当前的指针发送到 B 的开头，反之亦然。最终，我们的 A 和 B 指针将在我们行进的同时穿过交叉点节点，然后我们将退出循环并返回该节点。</p><p id="8b25" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">时间复杂度也是 O(M+N)！</p><p id="fc26" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这是一个有趣的，巧妙的问题和解决方法，想分享一下！</p></div></div>    
</body>
</html>