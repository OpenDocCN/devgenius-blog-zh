<html>
<head>
<title>Developing a Modular App Using MVC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 MVC 开发模块化应用程序</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/developing-a-modular-app-fbec6bcf1815?source=collection_archive---------11-----------------------#2020-07-01">https://blog.devgenius.io/developing-a-modular-app-fbec6bcf1815?source=collection_archive---------11-----------------------#2020-07-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="1b48" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">使用模型控制器分离我们的代码</h2><div class=""/><div class=""><h2 id="6d22" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">开发可重用的网络课程第三部分</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/be2555b0a5b41f04706cc98966dc8ed0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jQumaOU1kT8de2ud6i5YzQ.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">所有的部分组成一个整体，但是一次专注于一个部分对大多数团队来说更有效率，尤其是在处理大型项目的时候。维护模块化开发且组织良好的代码库通常更容易。</figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi le"><img src="../Images/d88785579bb5161ccd3fe326ac18924e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Vwj5lvYSGOvyHNLUAp0bQ.png"/></div></div></figure><h2 id="826d" class="lf lg iq bd lh li lj dn lk ll lm dp ln lo lp lq lr ls lt lu lv lw lx ly lz iw bi translated">以下是第一部分，以防你错过:</h2><div class="ma mb gp gr mc md"><a href="https://medium.com/swlh/developing-a-reusable-networking-class-66ef1f7566f" rel="noopener follow" target="_blank"><div class="me ab fo"><div class="mf ab mg cl cj mh"><h2 class="bd ja gy z fp mi fr fs mj fu fw iz bi translated">开发一个可重用的网络类</h2><div class="mk l"><h3 class="bd b gy z fp mi fr fs mj fu fw dk translated">以及为什么编写可重用的代码很重要</h3></div><div class="ml l"><p class="bd b dl z fp mi fr fs mj fu fw dk translated">medium.com</p></div></div><div class="mm l"><div class="mn l mo mp mq mm mr ky md"/></div></div></a></div><h2 id="2d49" class="lf lg iq bd lh li lj dn lk ll lm dp ln lo lp lq lr ls lt lu lv lw lx ly lz iw bi translated">第二部分…</h2><div class="ma mb gp gr mc md"><a href="https://medium.com/swlh/implementing-automatic-codable-1e212b54848" rel="noopener follow" target="_blank"><div class="me ab fo"><div class="mf ab mg cl cj mh"><h2 class="bd ja gy z fp mi fr fs mj fu fw iz bi translated">实现自动编码</h2><div class="mk l"><h3 class="bd b gy z fp mi fr fs mj fu fw dk translated">开发一个可重用的网络类第二部分</h3></div><div class="ml l"><p class="bd b dl z fp mi fr fs mj fu fw dk translated">medium.com</p></div></div><div class="mm l"><div class="ms l mo mp mq mm mr ky md"/></div></div></a></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi le"><img src="../Images/d88785579bb5161ccd3fe326ac18924e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Vwj5lvYSGOvyHNLUAp0bQ.png"/></div></div></figure><p id="ad29" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi nm translated"><span class="l nn no np bm nq nr ns nt nu di">在第二部分的</span>中，我们已经了解了如何实现 Codable，如何制作可重用的编码和解码方法，以及如何使用我们的<code class="fe nv nw nx ny b">NetworkService</code>类来封装这些方法。</p><p id="cf35" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">这一次，我们将把这个<code class="fe nv nw nx ny b">NetworkService</code>放在一个应用程序中使用，这个应用程序使用一个可编码的结构来存储和检索使用 Firebase 的对象。</p><h2 id="1d85" class="lf lg iq bd lh li lj dn lk ll lm dp ln lo lp lq lr ls lt lu lv lw lx ly lz iw bi translated">组织</h2><p id="62b2" class="pw-post-body-paragraph mt mu iq mv b mw nz ka my mz oa kd nb lo ob nd ne ls oc ng nh lw od nj nk nl ij bi translated">我们完全可以在 ViewController 中开发这个应用程序——这并不复杂。但是后来，假设我们决定改变我们对请求进行错误处理的方式。如果我们不模块化地编写我们的代码库，我们就会陷入重构每种方法的困境。同样，对于这样规模的项目，<em class="oe">没什么大不了的。</em></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi of"><img src="../Images/f2ca503310dcfaa3b55460f1ff8ede0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QnYscEFMYXWECpweGcJlEg.png"/></div></div></figure><p id="2ed9" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">但是，开始添加新功能，故事就会发生巨大的变化。随着项目的发展，现在也许您要维护 100 个共享公共代码的方法，而您本可以编写一个方法并重用它，只需要重构这一个方法。见鬼，即使我们只是添加了另一个 ViewController，我们也会失去对所有网络代码的访问，除非我们建立了不必要的委托关系或其他形式的双向通信。</p><h1 id="89a2" class="og lg iq bd lh oh oi oj lk ok ol om ln kf on kg lr ki oo kj lv kl op km lz oq bi translated">模型视图控制器</h1><p id="e6f7" class="pw-post-body-paragraph mt mu iq mv b mw nz ka my mz oa kd nb lo ob nd ne ls oc ng nh lw od nj nk nl ij bi translated">我喜欢使用 MVC(或者模型、视图、控制器)开发我的应用程序。因此，在较小的应用程序中，我通常会创建 3 个主组和与每个主组相关的子组。每层一组—模型、视图和控制器。如果您正在跟进，并且还没有这样做，那么继续创建一个单一视图应用程序。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi or"><img src="../Images/2864d0fd9b0816eb1196d696a41e10f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uBCqtYGy415rlM869DAINw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">目前我们的视图层中唯一的东西是我们的故事板(或编程/SwiftUI 视图)。如果我们添加自定义视图，它们的文件也将属于视图层</figcaption></figure><h2 id="22f8" class="lf lg iq bd lh li lj dn lk ll lm dp ln lo lp lq lr ls lt lu lv lw lx ly lz iw bi translated">模型</h2><p id="6c2d" class="pw-post-body-paragraph mt mu iq mv b mw nz ka my mz oa kd nb lo ob nd ne ls oc ng nh lw od nj nk nl ij bi translated">我保持模型非常简单，除了偶尔计算的属性，通常排除任何逻辑。我将我的模型存储在模型组中。让我们为我们的模型创建一个文件和结构。记住只使用符合 Codable 的属性。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="os ot l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/c71ebe11af72b5917dd59d502f31e375.png" data-original-src="https://miro.medium.com/v2/resize:fit:366/format:webp/1*r_GSRKu3K3ZnLcw_nTUSxQ.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">模型层——Tada</figcaption></figure><h2 id="fcc3" class="lf lg iq bd lh li lj dn lk ll lm dp ln lo lp lq lr ls lt lu lv lw lx ly lz iw bi translated">视角</h2><p id="4ed1" class="pw-post-body-paragraph mt mu iq mv b mw nz ka my mz oa kd nb lo ob nd ne ls oc ng nh lw od nj nk nl ij bi translated">在视图层，我放置了我的故事板、自定义单元格、自定义视图等..本质上任何可以被认为是视图的东西。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/7454a70394da85de1a1b28726f570aad.png" data-original-src="https://miro.medium.com/v2/resize:fit:544/format:webp/1*R5A2wc6FNcV4mw70M4LM8w.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">视图层(目前只是故事板)</figcaption></figure><p id="358f" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">注意:一些关于把他们的故事板放在哪里的争论。对我来说，他们主要关心视图是有意义的，因为他们包含了视图和与之相关的信息。虽然视图保存在 ViewController 的表示中，它们也是视图和 View controller 之间的桥梁。我也看到人们把他们的故事板放在他们的资源(或应用程序)文件夹中，或者只是把它们挂在他们项目的根目录下。</p><h2 id="efdf" class="lf lg iq bd lh li lj dn lk ll lm dp ln lo lp lq lr ls lt lu lv lw lx ly lz iw bi translated">控制器</h2><p id="a9d4" class="pw-post-body-paragraph mt mu iq mv b mw nz ka my mz oa kd nb lo ob nd ne ls oc ng nh lw od nj nk nl ij bi translated">在控制器层，我放置了视图控制器和模型控制器。在这种规模的项目中，我可能不会对模型和视图控制器使用单独的组。但是让我们像发展这个项目一样发展它。</p><p id="535a" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">让我们把网络服务。我们模型控制器组的 Swift。以防你没有《T2》第二部的拷贝。您可以使用单独的文件，也可以将它们放在一个文件中。我要把我的全部放进一个。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="aba5" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">网络加载器和实现</p><p id="a67c" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">让我们也为模型控制器创建一个文件。我通常使用的命名约定是 modelNameController(独一无二，嗯！？🙄)</p><p id="1973" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">我将其余文件(AppDelegate、SceneDelegate、Assets.xcassets 和 Info.plist)放在一个没有文件夹的组中。我将这个组命名为资源。使用不带文件夹的群组会将文件保留在磁盘上的原始位置，但会在项目中移动它们。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/8f0c82ea13a9dc01242660fefa69ae41.png" data-original-src="https://miro.medium.com/v2/resize:fit:490/format:webp/1*JKguCZ3IUxZhd-Sxs6ECIQ.png"/></div></figure><p id="60d7" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">⚠️如果不这样做，将会产生一个编译器错误，该错误可以通过在项目的生成设置中更改文件的位置来解决。<a class="ae ow" href="https://medium.com/@salvador.rhenz/setting-info-plist-path-on-xcode-11-65bed161bea5" rel="noopener">指路</a> ⚠️</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/2eeb6f122c1b955ebce4f9262d12bc28.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*XNZAvUC_Pn7B_BQlITvlng.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">请注意文件夹图标左下方的阴影区域。这表示没有文件夹的群组</figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi le"><img src="../Images/d88785579bb5161ccd3fe326ac18924e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Vwj5lvYSGOvyHNLUAp0bQ.png"/></div></div></figure><h1 id="896c" class="og lg iq bd lh oh oi oj lk ok ol om ln kf on kg lr ki oo kj lv kl op km lz oq bi translated">让我们创建我们的用户界面</h1><p id="1779" class="pw-post-body-paragraph mt mu iq mv b mw nz ka my mz oa kd nb lo ob nd ne ls oc ng nh lw od nj nk nl ij bi translated">当我们在故事板和文件之间来回切换时，请耐心等待。</p><p id="f43e" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">为了简单起见，我现在将删除故事板上的 ViewController，并用一个<code class="fe nv nw nx ny b">UINavigationController </code>替换它。如果你注意到了，我们的导航控制器附带了一个<code class="fe nv nw nx ny b">UITableViewController</code></p><p id="db70" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">我还要删除 ViewController.swift 文件，替换为:<br/> 1。创建新文件<br/> 2。选择可可触摸类别<br/> 3。从 UITableViewController <br/> 4 子类化。将文件命名为某种语义(我将把我的命名为 AgentListViewController.swift)</p><p id="7314" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">现在回到故事板，我将把 UITableViewController 的类改为 AgentListViewController</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/8b6fafd0d4de1c3d930d0327ade290ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/1*WD58vQSf1sxdc-jB5VhM1A.png"/></div></figure><p id="b2f9" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">单击视图控制器上方的栏，并确保选中高亮显示的图标。然后更改类别并按键盘上的 enter 键</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/788be221e5165858b4ba23a19656cbbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:516/format:webp/1*ur-Ls0XI761eu63YGJxVrg.png"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi le"><img src="../Images/d88785579bb5161ccd3fe326ac18924e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Vwj5lvYSGOvyHNLUAp0bQ.png"/></div></div></figure><p id="fc11" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">完成后，我会将我的导航控制器设置为应用程序的入口点，否则，当我们运行应用程序时，我们只会看到一个黑屏。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/20dda2a04645892fa4b6f02f93187370.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/format:webp/1*2P9jo4ir-VXtGttglyx2Ag.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">点按导航控制器上方的栏，并确保选中高亮显示的图标</figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/a4213761d0668d3d3330953381f69326.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*PlBFMiMeaUQhTBkNufUaKQ.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">确保在“属性检查器”选项卡上选择了“初始视图控制器”</figcaption></figure><p id="7d3a" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">此时，我总是运行我的应用程序，如果我在源代码控制之下，我会提交我的初始项目。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pd"><img src="../Images/236bdca7d6b34c12f18b41893e2acd0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pQozsPMhK3oIdcabgdXM2Q.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">在这一点上，这应该是你的故事板。请注意导航控制器左侧的箭头，这表示它是您的应用程序的入口点。</figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi le"><img src="../Images/d88785579bb5161ccd3fe326ac18924e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Vwj5lvYSGOvyHNLUAp0bQ.png"/></div></div></figure><p id="1e2f" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi nm translated"><span class="l nn no np bm nq nr ns nt nu di">在</span>这一点上，我们没有任何东西可以在我们的应用程序中展示。我们可以在 Firebase 中手动输入数据，然后下载并解码……但这很繁琐。</p><p id="cc3b" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">我在测试的时候，经常喜欢用 Swift 做对象，编码成 JSON，然后发给服务器，看看能不能解码。一旦我们像现在这样有了基础设施，这是一个相当快速的健全测试。我已经如此习惯于保持我的 ViewControllers 没有不必要的代码，以至于我几乎已经不再使用它们来进行测试，而是经常选择单元测试来一箭双雕。不幸的是，这篇文章已经发展得不成比例了，所以这是另一天的主题。</p><p id="d06a" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">让我们在模型控制器中创建一个快速的一次性方法，用数据填充 Firebase 数据库。</p><h1 id="91f7" class="og lg iq bd lh oh oi oj lk ok ol om ln kf on kg lr ki oo kj lv kl op km lz oq bi translated">说到火焰基地</h1><p id="d02f" class="pw-post-body-paragraph mt mu iq mv b mw nz ka my mz oa kd nb lo ob nd ne ls oc ng nh lw od nj nk nl ij bi translated">首先，我们需要创建一个 Firebase 实例，并获得实时数据库(⚠️而不是云 firestore)的基本 URL。如果你还没有的话，去 https://firebase.google.com/的<a class="ae ow" href="https://firebase.google.com/" rel="noopener ugc nofollow" target="_blank">创建一个账户。</a></p><p id="1f14" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">请沿着这条路走下去——如果你离开这条路，我可能无法带你回到我们正在走的这条路上。开个玩笑…如果你迷路了，找不到回去的路，你可以重新开始，创造一个新的实例🤓。</p><h2 id="80ab" class="lf lg iq bd lh li lj dn lk ll lm dp ln lo lp lq lr ls lt lu lv lw lx ly lz iw bi translated">我们去 Firebase 控制台吧</h2><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pe"><img src="../Images/618b72e9d92c0a20fc5afa4449706a23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tdxNi5ooZ0dtQ4HPovFoxg.png"/></div></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/10a2a201f380e530d47b0fd819d9fbdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/format:webp/1*kJ_jcdSbOZ2c0Y9e45d9SA.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">进入控制台后，添加一个新项目</figcaption></figure><p id="71c2" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">我通常会禁用“玩具”应用的分析功能，但这没多大关系——我们没有使用 SDK。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/fd59ce76b715002d88bbc568ba06f830.png" data-original-src="https://miro.medium.com/v2/resize:fit:358/format:webp/1*hMWsKGtsASDw5Sp3OxUzGg.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">我们等待着…</figcaption></figure><p id="30b4" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">这一步会绊倒很多人。尤其是考虑到我说过不要使用云 Firestore。点击云 Firestore lol…</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/130ce8dc5d8cedc51734002b3aa80444.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*4BSyGEFH4aJr13BRyBtNeQ.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">我知道，我说过不要用云 Firestore…我责怪谷歌</figcaption></figure><p id="e6bd" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">向下滚动，直到看到实时数据库，然后单击创建数据库</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pi"><img src="../Images/29e818f7faf937cb16285dab5c9a1c22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PpgXIEoefzxfF7EsF94xQw.png"/></div></div></figure><p id="360e" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">让我们从测试模式开始，因为这是我们对这个应用程序所做的一切。如果你决定(或者你正在阅读这篇文章的目的是)将这个应用程序投入生产，你应该仔细阅读 Firebase 最佳安全实践，以确保你的用户数据不容易受到外部攻击。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi le"><img src="../Images/d88785579bb5161ccd3fe326ac18924e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Vwj5lvYSGOvyHNLUAp0bQ.png"/></div></div></figure><p id="0f69" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">让我们从这个屏幕中获取我们的 URL，并在我们的模型控制器中创建一个私有常量<code class="fe nv nw nx ny b">private let baseURL = URL(string:"https://your-firebase-database-project.firebaseio.com")</code></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pj"><img src="../Images/2d36958c0f87ebaef3545e875f15e556.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4I55KDFUoULi3h1wxn-5nw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">获取整个 URL，并在模型控制器中用它创建一个常量</figcaption></figure><p id="e95f" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">让我们向模型控制器添加几个其他属性。让我们给自己一个使用 URLSession 的 NetworkService 私有实例(所以默认初始化器)</p><p id="4f36" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">我还将添加一个私有的 lazy var firebaseURL。json 到我们的 baseURL。这是懒惰的，因为它需要使用我们的 baseURL，这是一个实例属性。惰性变量直到我们的类被初始化后才被初始化，这保证了在创建 firebaseURL 时我们将有一个 baseURL 的实例。</p><h2 id="bf3a" class="lf lg iq bd lh li lj dn lk ll lm dp ln lo lp lq lr ls lt lu lv lw lx ly lz iw bi translated">让我们在模型控制器中创建一个方法，将对象发送到数据库。</h2><p id="3721" class="pw-post-body-paragraph mt mu iq mv b mw nz ka my mz oa kd nb lo ob nd ne ls oc ng nh lw od nj nk nl ij bi translated">我会叫我的<code class="fe nv nw nx ny b">sendAgent(_ agent: Agent)</code></p><p id="7d2e" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">请记住，networkService.encode 接受一个请求和一个可编码的实例，对实例进行编码并将其附加到请求中。我们不需要为这个请求添加任何头，因为 Firebase 知道我们想要根据方法和以. json 结尾的 URL 做什么。</p><p id="b3fd" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">这是目前为止我们的 AgentController:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="f511" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">现在，让我们在视图控制器中给自己一个 AgentController 的私有实例，并使用它向 Firebase 发送一些代理。请记住在发送代码后删除代码，并验证代码是否已发送，否则每次运行应用程序时都会发送代码。</p><h2 id="1b37" class="lf lg iq bd lh li lj dn lk ll lm dp ln lo lp lq lr ls lt lu lv lw lx ly lz iw bi translated">但是首先，删除样板评论！</h2><p id="bb76" class="pw-post-body-paragraph mt mu iq mv b mw nz ka my mz oa kd nb lo ob nd ne ls oc ng nh lw od nj nk nl ij bi translated">它们既难看又没必要..让我们摆脱他们。除了 1 个方法之外的所有方法——离开<code class="fe nv nw nx ny b">cellForRowAt</code>(应该是<code class="fe nv nw nx ny b">numberOfRowsInSection</code>下的第一个)。继续并取消注释那个，但是删除其余的。如果您打算继续做下去，您可能想使用<code class="fe nv nw nx ny b">prepare(for segue: … </code>,但是您也可以开始输入它，稍后使用自动完成。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="bbd8" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">如果你运行你的应用程序并检查 Firebase，你可能会有点困惑。您可能期望看到 5 个代理，但只看到 1 个！</p><h2 id="eb10" class="lf lg iq bd lh li lj dn lk ll lm dp ln lo lp lq lr ls lt lu lv lw lx ly lz iw bi translated">怎么回事？？</h2><p id="0d61" class="pw-post-body-paragraph mt mu iq mv b mw nz ka my mz oa kd nb lo ob nd ne ls oc ng nh lw od nj nk nl ij bi translated"><em class="oe">“好的，Kenny…我运行了我的应用程序，然后去了 Firebase——我只存储了一个对象！”</em></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pk"><img src="../Images/15bc27c2315deda6f324cf2f5259d2f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IHcKM0AFSZZKQ0QznNA8nQ.png"/></div></div></figure><p id="0cc6" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">如果你参加了我的第二部分，你可能已经准备好了。你甚至可能试图通过发布请求来解决这个问题。这在技术上可以解决这个问题，但是如果您需要获得一个特定的代理，您就失去了从数据库中轻松提取代理的能力。你必须把它们都下载下来并解析列表来找到你要找的那个。</p><p id="0f64" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">无论如何，这里发生的是我们确实把所有 5 个特工都送到了 Firebase。Firebase 只是用它前面的一个覆盖了每一个，因为这就是 PUT 所做的。</p><p id="b97d" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">让我们修改发送方式。我们仍将使用一个 PUT 请求，所以如果您已经更改了您的请求，请继续将其更改回来。相反，我们要做的是对 JSON 进行不同的编码，这样它就以我们对象的标识符作为键，以我们的对象作为值来存储。请记住，在 Swift Land™️中，这是<code class="fe nv nw nx ny b">[String:Object]</code> …以后会派上用场。</p><p id="ab65" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">要做到这一点，我们所要做的就是修改我们用来创建请求的 URL，使它在 baseURL 之后. json 之前有代理的标识符。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="86f6" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">现在，在运行应用程序之前，您需要从 Firebase 数据库中删除数据(只需单击当您将鼠标悬停在数据库层次结构的最顶端时出现的小 x(我们的第一个代理之前的部分))。之后，运行你的应用程序，你将在 Firebase 中拥有 5 个对象！</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pl"><img src="../Images/e0bc5b1df7ea34886c39df27d67369a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qr--BL4maWEF5plCcSa6cA.png"/></div></div></figure><p id="5557" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">⚠️:好的，确保你现在从你的视图控制器中删除这段代码。我们不想每次都发！⚠️</p><p id="1348" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">太好了，现在我们在 Firebase 里有数据了。让我们下载我们的对象，并将它们存储在应用程序功能的核心位置——模型控制器。</p><p id="9c9d" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">让我们在模型控制器中创建一个可选的对象数组。我们将使用这些来显示我们的表视图。</p><p id="6cb1" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">还有一个方法，<code class="fe nv nw nx ny b">getObjectsFromFirebase</code>。getObjectsFromFirebase 将创建一个 get 请求，解码一个包含<code class="fe nv nw nx ny b">[agent.identifier:agent]</code>的字典，并通过映射该字典的值来设置代理数组。我们还需要一个完成处理程序，让我们的 UI 知道代理何时被解码成代理数组。我们将在主线程上调用 completion()，这样我们就可以安全地更新我们的 UI。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="bf48" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">现在我们的 AgentController 可以下载代理，并填充它的数组，让我们试一试。</p><p id="1059" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">在我们为 numberOfSections 返回 0 的地方，让我们将其更改为 1 或删除该方法(默认为 1 section)。</p><p id="6d5a" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">我们的 ObjectsListViewController 中的 numberOfCells 方法返回 0，让我们改变它，这样它返回 AgentController 的数组中的代理数量，<strong class="mv ja">或者</strong> 0，如果它是零。</p><p id="f203" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated"><code class="fe nv nw nx ny b">return agentController.agents?.count ?? 0</code></p><p id="8818" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">最后，让我们回到故事板，给我们的单元格一个标识符，将该标识符粘贴到 cellForRowAt 方法中，并将代理的名称分配给我们的单元格的 textLabel。</p><p id="18a1" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">在 viewDidLoad 中，调用 agent controller . getagentsfromfirebase。在完成块中，调用 tableView.reloadData。</p><p id="35a6" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">这是整个 ViewController:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="os ot l"/></div></figure><h1 id="fb14" class="og lg iq bd lh oh oi oj lk ok ol om ln kf on kg lr ki oo kj lv kl op km lz oq bi translated">总结</h1><p id="e2ce" class="pw-post-body-paragraph mt mu iq mv b mw nz ka my mz oa kd nb lo ob nd ne ls oc ng nh lw od nj nk nl ij bi translated">如果你一直和我在一起，从另一边走出来，对模块化开发应用有了更深的理解，那么恭喜你！我们在这个系列中讨论了很多！</p><p id="c76d" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">在第 1 部分中，我们开始看到通过开发一个可重用的网络类来开发模块化代码的好处。</p><p id="f311" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">在第二部分中，我们以模块化的方式实现了自动编码。</p><p id="12b6" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">我们只是将所有这些放在一个应用程序中，我们使用 Firebase 和他们的 REST API 进行模块化开发。</p><p id="223f" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated">干得好！</p><p id="6c24" class="pw-post-body-paragraph mt mu iq mv b mw mx ka my mz na kd nb lo nc nd ne ls nf ng nh lw ni nj nk nl ij bi translated"><em class="oe">下次和我一起分享更多干净的代码和最佳实践。</em></p></div></div>    
</body>
</html>