<html>
<head>
<title>Effective GRPC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有效GRPC</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/effective-grpc-9152bea2cf50?source=collection_archive---------4-----------------------#2020-07-18">https://blog.devgenius.io/effective-grpc-9152bea2cf50?source=collection_archive---------4-----------------------#2020-07-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/9b53c8b03cdab829e695e421d357b7cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Bq1_gxdCFyEB0ZiY"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">照片由<a class="ae jz" href="https://unsplash.com/@morningbrew?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">晨酿</a>在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="20b3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如今，几乎不可能不听到这样或那样的GRPC。越来越多的现代技术和公司使用它。下一代谷歌云服务API建立在GRPC之上，Kubernetes使用它，负载平衡器和路由器开始支持它，Spotify等公司逐渐从旧的替代产品中迁移出来。</p><p id="0432" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Whisk中的RPC服务有着良好的历史，多年来我们的内部服务通信都依赖于Twitter Finagle技术栈之上的Thrift二进制协议。</p><p id="079d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可以具体阅读RPC库和GRPC的好处，但在本文中，我想特别关注提高生产率和安全性，这是促使whish采用这项技术的原因。并就如何有效利用它提供一些建议</p><p id="9df2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我从未遇到过对GRPC的各个方面都满意的人，对该协议有某些不满，尤其是在字段的可选性方面。但是技术不需要完美，重要的是它能让团队更有效率。</p><h1 id="dade" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">选择GRPC</h1><p id="97f7" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">很可能，你对GRPC的特色至少有一些基本的了解。在继续之前，我想在这里简要概述一下这个选择的好处(正如我们所看到的)</p><p id="6776" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">非常流行的比较通常是GRPC与RESTful HTTP，所以我将重点放在这一点上</p><p id="6d7a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于通信开销低的小团队和服务，选择更复杂的东西的理由可能更少，但是随着你的成长，你开始面临更多的挑战</p><ul class=""><li id="e502" class="mb mc in kc b kd ke kh ki kl md kp me kt mf kx mg mh mi mj bi translated"><strong class="kc io">需要一份文件</strong></li><li id="d1b5" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated"><strong class="kc io">定义明确的通信协议</strong></li><li id="eaa5" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated"><strong class="kc io">异构技术堆栈</strong>和平台的可变性(服务器、网络、移动)</li></ul><p id="43bd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">是的，OpenAPI和Swagger解决了其中的一些问题，但是不同的框架和语言与之集成的方式不同。并不是每个库都很好地支持自动生成OpenAPI模式，编写手动规范需要大量的工作，最终也不能保证它与实现的一致性。我还没有遇到多少人对Swagger codegen感到满意，并且正在开箱即用</p><p id="a488" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">GRPC解决了这些问题，并为您提供了一个定义良好的类型安全模式，您可以将它集成到更多的语言中。</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><ol class=""><li id="1dbd" class="mb mc in kc b kd ke kh ki kl md kp me kt mf kx mv mh mi mj bi translated">编写它的方式很简单，你需要做的关于RESTful路径和动词的修改要少得多。</li><li id="01b2" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mv mh mi mj bi translated">这很容易阅读</li><li id="8b4c" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mv mh mi mj bi translated">它支持多种语言</li><li id="0bb6" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mv mh mi mj bi translated">它消除了路径匹配、参数序列化/反序列化等负担，并允许专注于实现</li><li id="8b44" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mv mh mi mj bi translated">提供类型安全</li></ol><p id="734b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你将会看到更多…</p><p id="140a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你确信这是值得考虑的，文章的其余部分将展示我们如何有效利用GRPC和利用生态系统的力量</p><h1 id="27ef" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">有效的实践</h1><h2 id="031c" class="mw kz in bd la mx my dn le mz na dp li kl nb nc lm kp nd ne lq kt nf ng lu nh bi translated">1.集成棉绒</h2><p id="8fa6" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">你不需要重新发明轮子，学习如何编写好的Protobuf。此外，人们可能会对风格有不同的看法。我建议通过遵循linter规则来更容易地摆脱争论以及开发和评审过程</p><p id="6e52" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不久前我们从优步的<a class="ae jz" href="https://github.com/uber/prototool'" rel="noopener ugc nofollow" target="_blank">原型工具</a>开始，但是现在我们推荐看看<a class="ae jz" href="https://buf.build/docs/introduction" rel="noopener ugc nofollow" target="_blank">的Buf Linter </a>。(Prototool的README中有一个部分现在也推荐它)</p><p id="e97d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通过集成linter，您将立即在您的组织中获得更一致的风格，并学习非常好的实践。</p><p id="e523" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此外，该工具允许您在模式中执行重大更改检测</p><p id="d983" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">总体而言，它将帮助您:</p><ul class=""><li id="d51b" class="mb mc in kc b kd ke kh ki kl md kp me kt mf kx mg mh mi mj bi translated">命名</li><li id="2868" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated">版本化模式</li><li id="0309" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated">Protobuf项目结构</li><li id="5121" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated">消息结构(例如枚举)</li><li id="e058" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated">突变检测</li></ul><h2 id="6ecb" class="mw kz in bd la mx my dn le mz na dp li kl nb nc lm kp nd ne lq kt nf ng lu nh bi translated">2.写作风格指南</h2><p id="754a" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">Linter会做得很好，但是关于Protobuf的定义仍然有一些不确定性，所以你会发现在你做的时候需要额外的样式指南</p><p id="ba7b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的重点是</p><p id="46c6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">错误</strong></p><p id="3997" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">涵盖关于错误消息、错误代码的格式以及我们如何以分散的方式在我们的代码库中定义它们的主题</p><p id="d853" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">可选和必填字段</strong></p><p id="f3c8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">涵盖挑选一个或另一个的最佳实践、关于<a class="ae jz" href="https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/wrappers.proto" rel="noopener ugc nofollow" target="_blank">包装器的建议、</a>额外注释</p><p id="4289" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">更新操作和字段掩码</strong></p><p id="b76f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">更新消息的结构、更新模式、字段掩码的使用(<a class="ae jz" href="https://www.youtube.com/watch?v=W421BNZA_74" rel="noopener ugc nofollow" target="_blank">视频</a>)以及针对不同场景和API类型的建议</p><p id="b14b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">与Linter一起，Style Guide将指导您的团队在Protobuf模式的定义上保持一致。而下一个项目将更多地关注生态系统</p><h2 id="05a9" class="mw kz in bd la mx my dn le mz na dp li kl nb nc lm kp nd ne lq kt nf ng lu nh bi translated">3.GRPC网络</h2><p id="9e35" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">上述的一切，我们用节俭协议也实现了很长时间，但所有这些都局限于我们在私有网络中的内部服务通信。我们所有的外部HTTP APIs都是RESTful的</p><p id="61d7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们到了GRPC为我们做额外工作的部分</p><p id="cf70" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">虽然Android和iOS客户端可以说GRPC协议，但web客户端不能</p><p id="efe5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是用GRPC网络协议解决的。常见的做法是在您的GRPC本地后端前放置一个特使代理，以便web客户端可以访问您的服务。</p><p id="be51" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以在这篇<a class="ae jz" href="https://blog.envoyproxy.io/envoy-and-grpc-web-a-fresh-new-alternative-to-rest-6504ce7eb880" rel="noopener ugc nofollow" target="_blank">特使博客文章</a>中读到更多。设置非常简单</p><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/d824b479254bd1782955743dec150ad5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fU0UteVuw_GgF2Nz.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">(图片摘自特使博客)</figcaption></figure><h2 id="686d" class="mw kz in bd la mx my dn le mz na dp li kl nb nc lm kp nd ne lq kt nf ng lu nh bi translated">4.GRPC网关</h2><p id="5d0a" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">虽然原生GRPC适用于移动客户端，GRPC网络使从网络前端访问成为可能，但我们不能让所有的外部客户端都遵守规则，必须整合它。REST HTTP仍然是一个很好的行业标准，几乎每个公司都把它作为主要的方法，而公共GRPC或GraphQL APIs的选择更合适。</p><p id="6a48" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就是<a class="ae jz" href="https://github.com/grpc-ecosystem/grpc-gateway" rel="noopener ugc nofollow" target="_blank"> GRPC门户</a>发挥作用的地方</p><blockquote class="nj nk nl"><p id="f115" class="ka kb nm kc b kd ke kf kg kh ki kj kk nn km kn ko no kq kr ks np ku kv kw kx ig bi translated">grpc-gateway是谷歌协议缓冲编译器<a class="ae jz" href="https://github.com/protocolbuffers/protobuf" rel="noopener ugc nofollow" target="_blank">协议</a>的一个插件。它读取protobuf服务定义，并生成一个反向代理服务器，将RESTful HTTP API翻译成gRPC。这个服务器是根据服务定义中的<code class="fe nq nr ns nt b"><a class="ae jz" href="https://github.com/googleapis/googleapis/blob/master/google/api/http.proto#L46" rel="noopener ugc nofollow" target="_blank">google.api.http</a></code>注释生成的。</p></blockquote><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nu"><img src="../Images/f8a1503fe056955dc3a69cf2f88d6ee1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6BOzeVCAwrIK1kn7"/></div></div></figure><p id="fb82" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们发现它工作得很好，现在新版本的Whisk Public API是直接从我们的Protobuf模式中派生出来的，带有HTTP注释。</p><p id="0e94" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这样，我们仍然不必担心HTTP层中的路径映射一致性和消息序列化/反序列化</p><h2 id="4a8f" class="mw kz in bd la mx my dn le mz na dp li kl nb nc lm kp nd ne lq kt nf ng lu nh bi translated">5.Armeria(特定于JVM)</h2><p id="b48b" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">Armeria 将自己定位为微服务框架。我们最近发现了它，它在Whisk上处于实验状态。</p><p id="0db9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它看起来对我们很有吸引力，允许我们在同一个服务中拥有GRPC-Web层，消除了对Envoy代理翻译的需求。</p><p id="42fe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它附带了很棒的在线文档和调试功能</p><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nv"><img src="../Images/b26711fe3835c8df94d718e2dc10ef3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*h0Lk41pisiRwL8JC.png"/></div></div></figure><p id="5c37" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Armeria还允许我们让更多的HTTP经典流(Cookie管理、重定向)与原生GRPC共存。</p><h2 id="ecee" class="mw kz in bd la mx my dn le mz na dp li kl nb nc lm kp nd ne lq kt nf ng lu nh bi translated">6.打字稿代码生成器[未发布]</h2><p id="b3a9" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">将GRPC作为我们新的前端&lt;&gt;后端服务通信的标准，我们在Whisk上做了额外的努力，并在开发我们的世代库的Web前端支持工具上做了一些投资</p><p id="e5d4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是一张对比图，其中包含了我们选择这种方式的一些原因</p><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nw"><img src="../Images/731911dda275b278246c648bead764d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yQez8Togup03zQU9kO94xA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">(Javascript GRPC生成器)</figcaption></figure><p id="083e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它的功能和差异值得单独的文章，但简而言之，它提供了使用TypeScript中的GRPC的更惯用的写作方式，并给出了更小的包大小。</p><h1 id="0886" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">摘要</h1><p id="01b7" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">我们看到GRPC生态系统现在已经足够成熟，确实可以提高一些团队开发人员的工作效率，并避免与构建HTTP服务的传统方法相关的各种错误。</p><p id="9a3b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">虽然有些人可能会认为该协议并不完美，我个人也同意一些抱怨，但GRPC的生态系统非常强大和充满活力，因此它的净效应是非常积极的。它现在是定义公共API的首选解决方案，在Whisk around工具和库方面做了一些工作后，它将更进一步，将我们长期建立的Thift二进制协议用于Scala后端服务之间的内部通信。</p><p id="4448" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我不会说它是一个银弹，但是它有可能使你的团队的开发流程更好。</p><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nx"><img src="../Images/c28b8a08e4b27c1465811cfaaa2adb59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-pSFX0PWqtxUZFuNzCxJ2Q.png"/></div></div></figure></div></div>    
</body>
</html>