<html>
<head>
<title>Java best practice: boolean vs exception</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 最佳实践:布尔与异常</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/java-best-practice-boolean-vs-exception-f561633239cc?source=collection_archive---------3-----------------------#2022-09-14">https://blog.devgenius.io/java-best-practice-boolean-vs-exception-f561633239cc?source=collection_archive---------3-----------------------#2022-09-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="fa5a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">选择什么:方法应该返回布尔值还是抛出异常？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/5afdcba8c6917cf3d6d606babb1682d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*MIKd8WYVzImCo9qs3plEAA.jpeg"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">日本古代武术——十臂功</figcaption></figure><p id="5c5b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这篇文章基于一些个人对旧 Java 代码的重构，而不是假装成一个导师。</p><p id="ee1d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">假设我们的方法应该返回 void 或 boolean。最高效的返回方式是什么，如何让代码清晰？我们应该避免将异常输出与其他输出类型混合。</p><p id="0f93" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们重构这段虚幻的混合代码:</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="5602" class="kz la in kv b gy lb lc l ld le">public boolean checkIfAccessGrant() throws NotAuthorizedException {<br/>    Client client = clientService.findByUserName("mumba.yumba");<br/>    if (client != null) {<br/>        Country country = clientService.resolveUserCountry(client);<br/>        if (country != null) {<br/>            return !country.isChargeUnavailable();<br/>        } else {<br/>            throw new NotAuthorizedException(getException(client));<br/>        }<br/>    } else if (isCurrentUserHasTheRole(SUPER_USER)) {<br/>        return true;<br/>    } else {<br/>        throw new NotAuthorizedException(getException(client));<br/>    }       <br/>}<br/>private String getException(Client client) {<br/>    String message = "";<br/>    if (client != null) {<br/>        message += "Client ID: " + client.getId();<br/>    }<br/>    else {<br/>        message += "No Client given.";<br/>    }<br/>    return message;<br/>}<br/>private void checkIfClientHasTheRole(Role roleName) throws NotAuthorizedException {<br/><br/>    Set&lt;Role&gt; roles = retrieveRolesByClient();<br/>    if (roles == null || !roles.contains(role)) {<br/>        throw new NotAuthorizedException(getException(client));<br/>    }<br/>}</span></pre><p id="3487" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">无论我们使用哪种编程语言，它总是相同的相似方法。将 void 作为方法的结果返回会更清楚。在负面情况下—抛出异常。</p><p id="9c2c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以，我们重构的代码:</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="0490" class="kz la in kv b gy lb lc l ld le">public void checkIfAccessGranted() throws NotAuthorizedException {</span><span id="e88c" class="kz la in kv b gy lf lc l ld le">    Client client = clientService.findByUserName("mumbai");<br/>    if (client != null) {<br/>       Country country = clientService.resolveUserCountry(client);<br/>       if (country == null || country.isChargeUnavailable()) {<br/>          throw new NotAuthorizedException(getException(client));<br/>       }<br/>    } else {<br/>       checkIfClientHasTheRole(MAINTENANCE_ROLE);<br/>    }<br/>}</span></pre><p id="0328" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当更多的全局函数调用这个方法 checkIfAccessGranted()时，不需要返回 boolean，检查异常就足够了。没有抛出异常，所以结论为真。</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="f5b2" class="kz la in kv b gy lb lc l ld le">boolean isSuccessful = true;<br/>try {<br/>    service.checkIfAccessGranted(<em class="lg">MANAGER_ROLE</em>);<br/>} catch (NotAuthorizedException e) {<br/>    <em class="lg">LOG</em>.info(e);<br/>    isSuccessful = false;<br/>} finally {<br/>    // add some measurement for statistics or clear the unused vars<br/>}</span></pre><p id="c7af" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当执行陷入停滞且没有替代方案时引发异常。但是我们只能在特定的地方抓住它们。这可能是从一层到另一层的大跳跃。</p><p id="70ad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果有必要在检查的每一步都使用“return”关键字，那么在最后一行也添加最终的 return。SonarQube 会坚持这个规则，他是对的。举例来说:</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="db74" class="kz la in kv b gy lb lc l ld le">public Class receiveGenericClass() {<br/>    try {<br/>        return Class.forName(GENERIC_CLASS_NAME);<br/>    } catch (ClassNotFoundException e) {<br/>        LOG.error("No generic Logger Class found.");<br/>    }<br/>    return null;<br/>}</span></pre><p id="47c8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">还要添加一些代码覆盖率的单元测试。</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="6299" class="kz la in kv b gy lb lc l ld le">@Autowired<br/>private ClientAccessService serviceUnderTest;<br/>@Autowired<br/>private ClientService clientService;</span><span id="5140" class="kz la in kv b gy lf lc l ld le">@Test<br/>public void shouldCheckForSSOUserAndWhenCountryNull() {<br/>    // given<br/>    Client client = new Client();<br/>    client.setId("superuser");<br/>    client.setName("Lord");</span><span id="4f40" class="kz la in kv b gy lf lc l ld le">    // when<br/>    <em class="lg">Mockito.when</em>(clientService.findByUserName("superuser")).<br/>        thenReturn(client);</span><span id="98a6" class="kz la in kv b gy lf lc l ld le">... we can mock any real method to provide fake response for test</span><span id="e196" class="kz la in kv b gy lf lc l ld le">    // then exception was thrown<br/>    <em class="lg">assertThrows</em>(NotAuthorizedException.class, () -&gt;<br/>        serviceUnderTest.checkIfAccessGranted());<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lh"><img src="../Images/e176fda04924f0d8c9985a5733b9c068.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Az_INn1HLT5vW_R0OGq7Ww.jpeg"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">另一个捕捉“异常”的设备——Kabutowari。用作头盔断路器。</figcaption></figure><p id="08b8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">assert not throws——罕见的测试方法。</strong></p><p id="d419" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有时有必要测试一下情况，因为没有抛出异常。或者我们只需要在特定的条件下抛出。实现依赖于 JUnit 版本或其他测试库。</p><p id="ecb8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最简单明了的方法:</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="1e3e" class="kz la in kv b gy lb lc l ld le">try {<br/>    serviceUnderTest.checkIfAccessGranted();<br/>} catch (Exception e) {<br/>    Assert.<em class="lg">fail</em>("Should not throw exception.");<br/>}</span></pre><p id="fe9a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 JUnit 5.20 版本之后，我们可以使用本地方法<code class="fe lm ln lo kv b">assertDoesNotThrow</code>:</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="1106" class="kz la in kv b gy lb lc l ld le">@Test<br/>public void shouldMethodNotThrowException(){</span><span id="e9f0" class="kz la in kv b gy lf lc l ld le"> assertDoesNotThrow(myObject::methodToBeTested);</span><span id="3a95" class="kz la in kv b gy lf lc l ld le"> org.junit.jupiter.api.Assertions.assertDoesNotThrow(()-&gt; method());<br/>}</span></pre><p id="da44" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">索纳库</strong></p><p id="eab9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这也可能是 SonarQube 的问题，就像这样:“要么记录，要么重新抛出这个异常”。它用严格的规则检查代码。如果我们捕捉到异常，无论如何都应该处理它。</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="b852" class="kz la in kv b gy lb lc l ld le">try {<br/>    checkIfClientHasTheRole(<em class="lg">MANAGER_ROLE</em>);<br/>} catch (NotAuthorizedException e) {<br/>    <em class="lg">LOG</em>.info(e);<br/>    //or<br/>    throw new NotAuthorizedException(getException(client));<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/8501d1185cfa07b389f3e9c562a51d45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*Dx8ZWptJ38hd_DwbnSnaVg.jpeg"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">朱特能抓住武士刀，理论上是可能的。不要试图实际去做！</figcaption></figure><p id="8794" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">结论</strong>。</p><p id="b015" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">选择哪种方法总是一个品味的问题。有时抛出异常比返回布尔值更好。否则。取决于任务逻辑。想法是基于这样一个事实，使代码风格清晰明了。</p><p id="cc25" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">链接</strong></p><div class="lq lr gp gr ls lt"><a href="https://junit.org/junit5/docs/5.2.0/release-notes/#new-features-and-improvements-2" rel="noopener  ugc nofollow" target="_blank"><div class="lu ab fo"><div class="lv ab lw cl cj lx"><h2 class="bd io gy z fp ly fr fs lz fu fw im bi translated">JUnit 5 发行说明</h2><div class="ma l"><h3 class="bd b gy z fp ly fr fs lz fu fw dk translated">发布日期:2018 . 4 . 29 范围:JUnit BOM，支持 Maven Surefire 2.21.0 允许用 Java 9 和…</h3></div><div class="mb l"><p class="bd b dl z fp ly fr fs lz fu fw dk translated">junit.org</p></div></div></div></a></div></div></div>    
</body>
</html>