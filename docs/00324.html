<html>
<head>
<title>Climbing B-Tree Indexes in Postgres</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Postgres中攀爬B树索引</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/climbing-b-tree-indexes-in-postgres-f82447a2d29c?source=collection_archive---------11-----------------------#2020-06-02">https://blog.devgenius.io/climbing-b-tree-indexes-in-postgres-f82447a2d29c?source=collection_archive---------11-----------------------#2020-06-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/c91b14c9b840fda4a45a48572635b91a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*84SvbHc7CTPsQZYS6D4teQ.png"/></div></div></figure><p id="d882" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在计算机科学中，B树是一种<a class="ae kt" href="http://www.entradasoft.com/blogs" rel="noopener ugc nofollow" target="_blank">自平衡</a>树数据结构，它保持数据有序，并允许在对数时间内进行搜索、顺序访问、插入和删除。Postgres有几种索引类型，但B树是最常见的。它们很适合分类和匹配</p><p id="902f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">全文:<a class="ae kt" href="http://www.entradasoft.com/blogs/climbing-b-tree-indexes-in-postgres" rel="noopener ugc nofollow" target="_blank">http://www . entradasoft . com/blogs/climbing-b-tree-indexes-in-postgres</a></p><p id="a3ad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">这里有一个表格中可用的索引类型的快速概述:</strong></p><p id="56b9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> B树:【Postgres的缺省值。</strong></p><p id="fae1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> GIN: </strong>用于JSONB和数组。作为倒排索引，它们包含每个单词的索引条目，以及匹配位置的压缩列表。</p><p id="3121" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">要点:</strong>用于全文搜索和地理空间数据类型。GiST索引是有损耗的，这意味着该索引可能产生错误的匹配。</p><p id="0cd6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> SP-GiST : </strong>适用于具有自然但不均匀聚类的大型数据集</p><p id="3aeb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> BRIN </strong>(块范围索引) :对于真正大的数据集，按顺序排列。例如，订单可能有一个日期列，大多数情况下，较早订单的条目出现在表中较早的位置。</p><p id="7d08" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">散列:</strong>每当使用=运算符进行比较时，索引列都会被查询计划器考虑使用散列索引。</p><h2 id="d657" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">B树的结构</h2><p id="e55e" class="pw-post-body-paragraph jv jw in jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">基本上，它是一个自动排序的数据结构。这就是它自我平衡的原因——它自己选择形状。<em class="ls"/>B树是二叉查找树的推广，因为一个节点可以有两个以上的孩子。与自平衡二分搜索法树不同，B树针对读写大型数据块的系统进行了优化。</p><p id="ccb3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">b树是“平衡的”，因为从根到任何叶节点的距离都是相同的。叶节点是没有子节点的节点。根节点是位于顶部的节点。B树是这样一种树，其中每个节点可以有多个孩子，或者更好地说，B树可以有N个孩子。在二分搜索法树中，每个节点可以有一个值，而B树有键的概念。键就像一个值列表，每个节点都将保存这些值。</p><h2 id="791c" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">让我们把它画出来:</h2><p id="40b3" class="pw-post-body-paragraph jv jw in jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">关于B树最重要的是他们的<a class="ae kt" href="http://www.entradasoft.com/blogs" rel="noopener ugc nofollow" target="_blank">平衡方面</a>。这个概念基于每个节点都有键的事实，就像上面的例子一样。B树自我平衡的方式真的很有趣，而键是这个功能最重要的方面。</p><figure class="lu lv lw lx gt jo gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/7aa146ebe3ad059a9af4d7a60d7a9556.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*Y-y5o1RiXvRSqVe6jtmS9Q.png"/></div></figure><p id="3ac8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">基本上，每当一个新的条目(或者，在我们的例子中，一个数字)被添加时，B树为条目找到合适的位置(或者，节点)。例如，如果我们要添加数字6，B树将“询问根节点”，它应该将该数字推入哪个节点。“问”无非是将新数与节点的键进行比较。由于数字6大于5，但小于数字10(它们是根节点键)，它将在根节点下创建一个新节点:</p><figure class="lu lv lw lx gt jo gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/411dbf40223945080c1e2b3a0fc0e4f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*W8iqTY75yZQE1LMn5Qfw4A.png"/></div></figure><p id="d8da" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过这种机制，B树总是有序的，并且在其中查找值是相当便宜的。</p><p id="16bf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，如果我们想查找键6，我们将比较6和根节点中的值，看到它在5和10之间。所以我们使用5和10之间的指针来查找包含6的节点。</p><p id="b5cc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是对Postgres实现的抽象，但是你可以想象为什么这比遍历表中的每个数字并检查它是否等于6要快。</p><p id="4101" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是为什么B树可以在O(logN)时间内进行搜索、插入和删除。</p><h2 id="9d3d" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">限制</h2><p id="718b" class="pw-post-body-paragraph jv jw in jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">几乎在所有用例中，索引的力量在大量数据上是显而易见的。这意味着索引必须和实际的数据表一样大。是吗？</p><p id="722f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">想象一下，如果我们正在处理数十亿条记录。这意味着索引表将以有序的方式存储数十亿条记录。好吧，PostgreSQL可以处理这个问题。但是，你能想象一个<code class="fe ly lz ma mb b">INSERT</code>命令需要多长时间吗？在数据表中添加记录需要很长时间，因为索引必须在正确的位置添加新记录，以保持索引的顺序。由于这种限制，B树索引的实现保留了<strong class="jx io">页面文件</strong>，简单地说，就是一个大B树数据结构上的节点。</p><p id="dee8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">语法:</strong></p><p id="fedd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">—在采购表上使用btree创建索引列<br/> —在&lt; &lt;表上创建索引&lt; &lt;索引_名称&gt; &gt;使用&lt; &lt;索引_类型&gt; &gt;</p><p id="e79d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">阅读更多…<a class="ae kt" href="http://www.entradasoft.com/blogs/climbing-b-tree-indexes-in-postgres" rel="noopener ugc nofollow" target="_blank">http://www . entradasoft . com/blogs/climbing-b-tree-indexes-in-postgres</a></p></div></div>    
</body>
</html>