<html>
<head>
<title>C# Tip: Formatting Inline SQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C#提示:格式化内联 SQL</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/c-tip-formatting-inline-sql-160b34bba877?source=collection_archive---------6-----------------------#2022-02-10">https://blog.devgenius.io/c-tip-formatting-inline-sql-160b34bba877?source=collection_archive---------6-----------------------#2022-02-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="50cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">嘿，这只是我做事的方式…</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/1f77496db317d5802b9b1a97a960b0ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0ryIDF0jz9H6kh2w"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">由<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae lb" href="https://unsplash.com/@sunder_2k25?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Sunder Muthukumaran </a>拍摄的照片</figcaption></figure><p id="e877" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们都知道格式化我们的代码对我们代码库的质量有多重要。我们从许多作者那里学到了缩进和样式的规则。在这篇文章中，我将保持简单。我将提供一些格式化内联 SQL 的基本技巧(如果你喜欢这类东西的话)。</p><blockquote class="lc ld le"><p id="9bc6" class="jn jo lf jp b jq jr js jt ju jv jw jx lg jz ka kb lh kd ke kf li kh ki kj kk ij bi translated">前半部分将从总体上讲述 SQL，后半部分将深入探讨更多的 C#细节。</p></blockquote></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><h1 id="f4e8" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">结构化查询语言</h1><h2 id="2205" class="mo lr iq bd ls mp mq dn lw mr ms dp ma jy mt mu me kc mv mw mi kg mx my mm mz bi translated">大写 SQL 关键字</h2><p id="2f05" class="pw-post-body-paragraph jn jo iq jp b jq na js jt ju nb jw jx jy nc ka kb kc nd ke kf kg ne ki kj kk ij bi translated">SQL 是一种非常英式的查询语言。区分什么是 SQL 单词和什么是结构/数据单词是很重要的。</p><p id="fd7f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lf">坏</em></p><pre class="km kn ko kp gt nf ng nh ni aw nj bi"><span id="308b" class="mo lr iq ng b gy nk nl l nm nn">select * from instances.productcosthistory where postedtimestamp &gt; ‘2022–01–01’</span></pre><p id="832d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lf">好的</em></p><pre class="km kn ko kp gt nf ng nh ni aw nj bi"><span id="3f81" class="mo lr iq ng b gy nk nl l nm nn">SELECT * FROM instances.productcosthistory WHERE postedtimestamp &gt; '2022-01-01'</span></pre><h2 id="227f" class="mo lr iq bd ls mp mq dn lw mr ms dp ma jy mt mu me kc mv mw mi kg mx my mm mz bi translated">在关键字处中断</h2><p id="49f6" class="pw-post-body-paragraph jn jo iq jp b jq na js jt ju nb jw jx jy nc ka kb kc nd ke kf kg ne ki kj kk ij bi translated">这只是帮助我们更快地定位感兴趣的查询部分。</p><p id="dca0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lf">坏</em></p><pre class="km kn ko kp gt nf ng nh ni aw nj bi"><span id="a670" class="mo lr iq ng b gy nk nl l nm nn">SELECT * FROM instances.productcosthistory PC JOIN instances.products P ON P.ProductId = PC.ProductId WHERE PC.postedtimestamp &gt; '2022-01-01'</span></pre><p id="9002" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lf">好的</em></p><pre class="km kn ko kp gt nf ng nh ni aw nj bi"><span id="51f0" class="mo lr iq ng b gy nk nl l nm nn">SELECT * <br/>FROM instances.productcosthistory PC <br/>JOIN instances.products P <br/>ON P.ProductId = PC.ProductId <br/>WHERE PC.postedtimestamp &gt; '2022-01-01'</span></pre><h2 id="2b2c" class="mo lr iq bd ls mp mq dn lw mr ms dp ma jy mt mu me kc mv mw mi kg mx my mm mz bi translated">子句缩进</h2><p id="3399" class="pw-post-body-paragraph jn jo iq jp b jq na js jt ju nb jw jx jy nc ka kb kc nd ke kf kg ne ki kj kk ij bi translated">有助于跟踪什么是主关键字的一部分(或者在这种情况下是 Join)</p><pre class="km kn ko kp gt nf ng nh ni aw nj bi"><span id="2e94" class="mo lr iq ng b gy nk nl l nm nn">SELECT * <br/>FROM instances.productcosthistory PC <br/>JOIN instances.products P <br/>    ON P.ProductId = PC.ProductId<br/>JOIN definitions.products PD<br/>    ON PD.DefinitionId = P.DefinitionId<br/>WHERE PC.postedtimestamp &gt; '2022-01-01'</span></pre><h2 id="c73a" class="mo lr iq bd ls mp mq dn lw mr ms dp ma jy mt mu me kc mv mw mi kg mx my mm mz bi translated">请使用方括号</h2><p id="9172" class="pw-post-body-paragraph jn jo iq jp b jq na js jt ju nb jw jx jy nc ka kb kc nd ke kf kg ne ki kj kk ij bi translated">这一条可能是最有争议的，但是对于数据库中定义的任何东西(例如，模式、表、列)都要使用括号。这使得在查询中识别这些对象更加容易。然而，任何临时的“变量”我一般不会放在括号里。</p><p id="33f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lf">不良</em></p><pre class="km kn ko kp gt nf ng nh ni aw nj bi"><span id="4164" class="mo lr iq ng b gy nk nl l nm nn">SELECT * <br/>FROM instances.productcosthistory PC <br/>JOIN instances.products P <br/>    ON P.ProductId = PC.ProductId<br/>JOIN definitions.products PD<br/>    ON PD.DefinitionId = P.DefinitionId<br/>WHERE PC.postedtimestamp &gt; '2022-01-01'</span></pre><p id="1b3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lf">好的</em></p><pre class="km kn ko kp gt nf ng nh ni aw nj bi"><span id="1e12" class="mo lr iq ng b gy nk nl l nm nn">SELECT * <br/>FROM [Instances].[ProductCostHistory] PC <br/>JOIN [Instances].[Products] P <br/>    ON P.[ProductId] = PC.[ProductId]<br/>JOIN [Definitions].[Products] PD<br/>    ON PD.[DefinitionId] = P.[DefinitionId]<br/>WHERE PC.[PostedTimestamp] &gt; '2022-01-01'</span></pre><h2 id="2d1a" class="mo lr iq bd ls mp mq dn lw mr ms dp ma jy mt mu me kc mv mw mi kg mx my mm mz bi translated">缩进多个条件或参数</h2><p id="7d04" class="pw-post-body-paragraph jn jo iq jp b jq na js jt ju nb jw jx jy nc ka kb kc nd ke kf kg ne ki kj kk ij bi translated">如果我们有一个 SELECT、WHERE、JOIN 或任何有多个子句的东西，添加一个换行符并执行缩进。基本上，让我们对一条信息保持 1 行。</p><pre class="km kn ko kp gt nf ng nh ni aw nj bi"><span id="d700" class="mo lr iq ng b gy nk nl l nm nn">SELECT <br/>    P.[ProductId],<br/>    P.[Name],<br/>    P.[Description]<br/>FROM instances.productcosthistory PC <br/>JOIN instances.products P <br/>    ON P.ProductId = PC.ProductId AND <br/>       P.CreatedTimestamp = PC.CreatedTimestamp<br/>JOIN Definitions.Products PD<br/>    ON PD.DefinitionId = P.DefinitionId<br/>WHERE <br/>    PC.PostedTimestamp &gt; '2022-01-01' AND<br/>    PD.Type = 0</span></pre><p id="4300" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这也适用于更新，</p><pre class="km kn ko kp gt nf ng nh ni aw nj bi"><span id="73f4" class="mo lr iq ng b gy nk nl l nm nn">UPDATE [dbo].[KeyValues]<br/>SET [Key] = 'Color',<br/>    [Value] = 'Blue'<br/>WHERE<br/>    [Key] = 'Color' AND<br/>    [Value] = 'Red'</span></pre><h2 id="bf40" class="mo lr iq bd ls mp mq dn lw mr ms dp ma jy mt mu me kc mv mw mi kg mx my mm mz bi translated">在 Insert 语句中对齐参数</h2><p id="f74e" class="pw-post-body-paragraph jn jo iq jp b jq na js jt ju nb jw jx jy nc ka kb kc nd ke kf kg ne ki kj kk ij bi translated">对我来说，插页有点不同。您可能要插入比选择或更新更多的字段。那么，我们真的想要一个 25 行长的 SQL 语句吗？大概不会。因此，不要将每个参数放在自己的行上，让我们在合理的水平宽度上换行，并确保参数对齐。</p><pre class="km kn ko kp gt nf ng nh ni aw nj bi"><span id="7d8d" class="mo lr iq ng b gy nk nl l nm nn">INSERT INTO [Snapshots].[Snapshots]<br/>    ([TargetTimestamp], [CreatedTimestamp], [SnapshotType],<br/>     [Notes], [AssociatedUserId])<br/>VALUES<br/>    (@TargetTimestamp, @CreatedTimestamp, @SnapshotType,<br/>     @Notes, @AssociatedUserId)</span></pre><p id="87c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这同样适用于使用 SELECT 语句插入时，</p><pre class="km kn ko kp gt nf ng nh ni aw nj bi"><span id="926e" class="mo lr iq ng b gy nk nl l nm nn">INSERT INTO [Snapshots].[Snapshots]<br/>    ([TargetTimestamp], [CreatedTimestamp], [SnapshotType],<br/>     [Notes], [AssociatedUserId])<br/>SELECT <br/>    [TargetTimestamp], @CreatedTimestamp, [SnapshotType],<br/>    'Cloned Snapshot', @AssociatedUserId<br/>FROM [Snapshots].[Snapshots]<br/>WHERE [SnapshotId] = 4660</span></pre><h2 id="ce88" class="mo lr iq bd ls mp mq dn lw mr ms dp ma jy mt mu me kc mv mw mi kg mx my mm mz bi translated">用一行和一个分号分隔复合查询</h2><p id="efae" class="pw-post-body-paragraph jn jo iq jp b jq na js jt ju nb jw jx jy nc ka kb kc nd ke kf kg ne ki kj kk ij bi translated">这是个人偏好，但是既然你无论如何都需要分号，为什么不只是在调用之间使用它来清楚地标识每个语句呢？</p><pre class="km kn ko kp gt nf ng nh ni aw nj bi"><span id="b43f" class="mo lr iq ng b gy nk nl l nm nn">DECLARE @Ids TABLE ([Id] INT NOT NULL)<br/>;<br/>INSERT INTO @Ids ([Id])<br/>SELECT S.[SnapshotId]<br/>FROM [Snapshots].[Snapshots] S<br/>JOIN [Snapshots].[InventoryTransactions] IT<br/>    ON IT.[SnapshotId] = S.[SnapshotId]<br/>;<br/>SELECT COUNT(*)<br/>FROM [Snapshots].[Snapshots]<br/>WHERE [SnapshotId] IN (SELECT [Id] FROM @Ids)<br/>;<br/>SELECT *<br/>FROM [Snapshots].[Snapshots]<br/>WHERE [SnapshotId] IN (SELECT [Id] FROM @Ids)<br/>;</span></pre><blockquote class="lc ld le"><p id="e8ed" class="jn jo lf jp b jq jr js jt ju jv jw jx lg jz ka kb lh kd ke kf li kh ki kj kk ij bi translated"><strong class="jp ir">澄清</strong>:我们实际上并不一定要使用分号(具体用 T-SQL)。大多数语句不需要它。然而，有几个这样做(即 CTE 声明)。事实是分号在 ANSI SQL-92 标准中，所以我使用它们。</p></blockquote><h2 id="994f" class="mo lr iq bd ls mp mq dn lw mr ms dp ma jy mt mu me kc mv mw mi kg mx my mm mz bi translated">缩进 SQL 块</h2><p id="87ba" class="pw-post-body-paragraph jn jo iq jp b jq na js jt ju nb jw jx jy nc ka kb kc nd ke kf kg ne ki kj kk ij bi translated">当语句与一个块(即<code class="fe no np nq ng b">BEGIN TRANS</code>或<code class="fe no np nq ng b">IF</code>)组合在一起时，缩进该块中的所有代码。</p><pre class="km kn ko kp gt nf ng nh ni aw nj bi"><span id="6246" class="mo lr iq ng b gy nk nl l nm nn">SET XACT_ABORT ON;<br/>BEGIN TRANSACTION;<br/>    INSERT INTO [Snapshots].[Snapshots]<br/>        ([TargetTimestamp], [CreatedTimestamp], [SnapshotType], <br/>         [Notes], [AssociatedUserId])<br/>    VALUES<br/>        (@targetTimestamp, @createdTimestamp, @snapshotType, <br/>         @notes, @associatedUserId)<br/>    ;<br/>    DECLARE @SnapshotId INT = SCOPE_IDENTITY()<br/>    ;<br/>    INSERT INTO [Snapshots].[InventoryTransactions] <br/>        ([SnapshotId], [Quantity], [ProductInstanceId],<br/>         [InventoryLocationId])<br/>    SELECT <br/>         @SnapshotId, SUM(IT.[Quantity]), IT.[ProductInstanceId], <br/>         IT.[InventoryLocationId]<br/>    FROM [Transactions].[InventoryTransactions] IT<br/>    GROUP BY <br/>        IT.[ProductInstanceId], <br/>        IT.[InventoryLocationId]<br/>    ;<br/>COMMIT;</span><span id="244b" class="mo lr iq ng b gy nr nl l nm nn">SELECT *<br/>FROM [Snapshots].[Snapshots]<br/>WHERE [SnapshotId] = @SnapshotId<br/>;</span></pre><blockquote class="lc ld le"><p id="1b64" class="jn jo lf jp b jq jr js jt ju jv jw jx lg jz ka kb lh kd ke kf li kh ki kj kk ij bi translated"><strong class="jp ir">注意</strong>:我在这里故意把分号放在<code class="fe no np nq ng b">BEGIN TRANSACTION</code>和<code class="fe no np nq ng b">COMMIT</code>的末尾。这已经是一个 block 语句了，而且在视觉上已经被隔离了，所以我看不出有什么理由浪费这一行。</p></blockquote><h1 id="2d1e" class="lq lr iq bd ls lt ns lv lw lx nt lz ma mb nu md me mf nv mh mi mj nw ml mm mn bi translated">C#</h1><p id="0a00" class="pw-post-body-paragraph jn jo iq jp b jq na js jt ju nb jw jx jy nc ka kb kc nd ke kf kg ne ki kj kk ij bi translated">现在让我们进入文章的 C#部分。以上所有规则都适用，但我们现在将在 C#中展示它们，并提供一些可读性提示。</p><h2 id="d020" class="mo lr iq bd ls mp mq dn lw mr ms dp ma jy mt mu me kc mv mw mi kg mx my mm mz bi translated">使用逐字@标识符</h2><p id="1fde" class="pw-post-body-paragraph jn jo iq jp b jq na js jt ju nb jw jx jy nc ka kb kc nd ke kf kg ne ki kj kk ij bi translated">通过在创建字符串时使用<a class="ae lb" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/verbatim" rel="noopener ugc nofollow" target="_blank">逐字标识符</a>，您可以在 SQL 的风格上给自己更多的灵活性。我们上面展示的一切都可以在这些字符串中工作。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h2 id="c5b2" class="mo lr iq bd ls mp mq dn lw mr ms dp ma jy mt mu me kc mv mw mi kg mx my mm mz bi translated">总是从新的一行开始</h2><p id="f086" class="pw-post-body-paragraph jn jo iq jp b jq na js jt ju nb jw jx jy nc ka kb kc nd ke kf kg ne ki kj kk ij bi translated">我觉得这一条想一想就很明显了。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h2 id="975e" class="mo lr iq bd ls mp mq dn lw mr ms dp ma jy mt mu me kc mv mw mi kg mx my mm mz bi translated">在声明开始后缩进 SQL 一次</h2><p id="6651" class="pw-post-body-paragraph jn jo iq jp b jq na js jt ju nb jw jx jy nc ka kb kc nd ke kf kg ne ki kj kk ij bi translated">就像任何其他相关代码一样，在声明之后缩进。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nx ny l"/></div></figure><blockquote class="lc ld le"><p id="25e3" class="jn jo lf jp b jq jr js jt ju jv jw jx lg jz ka kb lh kd ke kf li kh ki kj kk ij bi translated"><strong class="jp ir">额外提示</strong>:始终将最后一个引号和分号放在单独的一行，并确保它与如上所示的声明对齐。</p></blockquote><h2 id="6ed9" class="mo lr iq bd ls mp mq dn lw mr ms dp ma jy mt mu me kc mv mw mi kg mx my mm mz bi translated">让 SQL 靠近执行代码</h2><p id="282e" class="pw-post-body-paragraph jn jo iq jp b jq na js jt ju nb jw jx jy nc ka kb kc nd ke kf kg ne ki kj kk ij bi translated">不要做以下事情，</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="3684" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，我们将 SQL 作为常量分隔在类的顶部。我认为人们这样做是因为这样更“干净”但是我们所做的一切都是为了让它更具可读性，这样代码就更容易理解。让它远离正在执行的代码，现在我们必须去找到它。当这些类变得很大时，试图在类的顶部和方法之间来回跳转是令人沮丧的。</p><p id="d43b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相反，让我们像下面这样做，</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="46f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">老实说，如果不是 lambda 风格的方法，这可能更具可读性。但是，它更接近于执行，所以我可以很快看到这里发生了什么，在方法中。它在一个地方。</p><h2 id="01ca" class="mo lr iq bd ls mp mq dn lw mr ms dp ma jy mt mu me kc mv mw mi kg mx my mm mz bi translated">如果查询变得太复杂，就把它拆开</h2><p id="a415" class="pw-post-body-paragraph jn jo iq jp b jq na js jt ju nb jw jx jy nc ka kb kc nd ke kf kg ne ki kj kk ij bi translated">有时候查询是一个很难处理的问题，尤其是对于 C#代码。在我的例子中，我使用一些“提供者”来更容易地构建查询。必要时，我将利用插入的逐字组合来分解复杂的 SQL，</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="1b60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你仔细看，你会看到<code class="fe no np nq ng b">{provider.JoinClause}</code>和<code class="fe no np nq ng b">{provider.WhereClause}</code>。当然，这些子句也是动态的，所以这是我在没有极其复杂的查询的情况下完成任务的唯一方法。但是从可读性的角度来看，有时这是有帮助的。对我来说，说“<em class="lf">嘿，这部分可能很复杂，让我去看看那个特定的逻辑</em>”比试图在一个巨大的 SQL 语句中解析它更有帮助。</p><h2 id="d485" class="mo lr iq bd ls mp mq dn lw mr ms dp ma jy mt mu me kc mv mw mi kg mx my mm mz bi translated">在有帮助的时候加入评论</h2><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="1d78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有时您需要知道某些查询从哪里开始和停止，以及您在哪个部分。例如，这个查询按照不同的库存数量对其进行了分类。</p><p id="d325" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除此之外(这打破了我以前的一些规则)，对你来说可能看起来更干净。以下是格式不同的完全相同的查询，</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="cb6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我觉得这样看起来更干净(有时候；取决于我的心情)因为它包含的代码行更少。但我会让你决定。</p></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><h1 id="8af1" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">结论和签署</h1><p id="a3de" class="pw-post-body-paragraph jn jo iq jp b jq na js jt ju nb jw jx jy nc ka kb kc nd ke kf kg ne ki kj kk ij bi translated">希望这些技巧能给你一些在 C#应用程序中编写更简洁的内联 SQL 的想法。最终，从可读性的角度来看，由您来决定什么更好。我认为当你写代码的时候，你应该试着把你的同事考虑进去。你读起来总是更容易(因为是你写的)。但你的犯罪伙伴可能不会这么想。</p><p id="e8f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我知道你的想法！请<strong class="jp ir">跟随我</strong>来到 Medium。这有助于鼓励我继续写作！</p><p id="7cd8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lf">我思故我在，一个错误的程序员……</em></p></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><h2 id="e654" class="mo lr iq bd ls mp mq dn lw mr ms dp ma jy mt mu me kc mv mw mi kg mx my mm mz bi translated">相关文章</h2><ul class=""><li id="9f00" class="nz oa iq jp b jq na ju nb jy ob kc oc kg od kk oe of og oh bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/c-problem-sql-executor-service-deb459132a50"> C#问题:SQL 执行器服务</a></li><li id="fa56" class="nz oa iq jp b jq oi ju oj jy ok kc ol kg om kk oe of og oh bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/c-tip-sql-executor-service-dependency-injection-4455efb453b0"> C#问题:SQL 执行器服务——依赖注入</a></li><li id="62f2" class="nz oa iq jp b jq oi ju oj jy ok kc ol kg om kk oe of og oh bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/advanced-c-sql-server-bulk-upload-57ad6be6e6a1">高级 C# — SQL Server 批量上传</a></li><li id="ce91" class="nz oa iq jp b jq oi ju oj jy ok kc ol kg om kk oe of og oh bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/advanced-c-common-sql-table-structures-bb7f7149b887">高级 C# —通用 SQL 表结构</a></li></ul></div></div>    
</body>
</html>