<html>
<head>
<title>HashiCorp Stack in a Box: Running HashiQube Using the Vagrant Docker Provider</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机箱中的 HashiCorp 堆栈:使用浮动 Docker 提供程序运行 HashiQube</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/running-hashiqube-using-the-vagrant-docker-provider-3e551c0eca97?source=collection_archive---------7-----------------------#2022-11-25">https://blog.devgenius.io/running-hashiqube-using-the-vagrant-docker-provider-3e551c0eca97?source=collection_archive---------7-----------------------#2022-11-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/e827c954d030a0879d51b329f8542536.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XUcrghwCHX910Q2FMRfefA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">白雪覆盖的蜘蛛网。Adri Villela 的照片。</figcaption></figure><p id="d96e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你关注了我在 HashiQube 上的<a class="ae jz" href="https://medium.com/@adri-v/list/hashiqube-bfdcb9c84e10" rel="noopener">文章，你就会知道我是它的超级粉丝。对于门外汉，</a><a class="ae jz" href="https://github.com/servian/hashiqube" rel="noopener ugc nofollow" target="_blank"> HashiQube </a>提供了一个完整的<a class="ae jz" href="https://HashiCorp.com" rel="noopener ugc nofollow" target="_blank"> HashiCorp </a>堆栈，包括但不限于<a class="ae jz" href="https://www.nomadproject.io/" rel="noopener ugc nofollow" target="_blank">流浪者</a>、<a class="ae jz" href="https://www.vaultproject.io" rel="noopener ugc nofollow" target="_blank">金库</a>和<a class="ae jz" href="https://consul.io" rel="noopener ugc nofollow" target="_blank">执政官</a>，使用<a class="ae jz" href="https://vagrantup.com" rel="noopener ugc nofollow" target="_blank">流浪者</a>。</p><p id="b7b2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我已经有几个月没碰过哈希古布了😭在我离开 HashiQube 的时候，我给自己买了一台 14 英寸的 M1 Mac。显然，我非常渴望在我的新机器上尝试 HashiQube。但问题就在这里:<a class="ae jz" href="https://apple.stackexchange.com/questions/422565/does-virtualbox-run-on-apple-silicon" rel="noopener ugc nofollow" target="_blank">当时，VirtualBox 没有运行在苹果硅(M1/M2)处理器上</a>。幸运的是，我的恐慌非常短暂，因为<a class="ae jz" href="https://github.com/servian/hashiqube" rel="noopener ugc nofollow" target="_blank"> HashiQube </a>的维护者之一 Riaan Nolan 找到了一个解决方案:在 Docker 上运行 HashiQube。你看，虽然大多数人通常使用<a class="ae jz" href="https://developer.hashicorp.com/vagrant/docs/providers/virtualbox" rel="noopener ugc nofollow" target="_blank"> VirtualBox 的浮动提供程序</a>运行浮动，但你也可以使用<a class="ae jz" href="https://developer.hashicorp.com/vagrant/docs/providers/docker" rel="noopener ugc nofollow" target="_blank">浮动停靠程序提供程序</a>。Riaan 有一篇很棒的博文，讲述了他对 HashiQube 所做的一些调整，这样它就可以使用 Docker Provider 运行，而且<a class="ae jz" href="https://medium.com/@riaan.nolan/running-hashiqube-on-multi-arch-arm-and-x86-multi-os-linux-mac-windows-with-docker-desktop-4695e152cacb" rel="noopener">你绝对应该去看看</a>。此外，该解决方案同样适用于 M1 和非 M1(如英特尔)处理器。</p><p id="1c83" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我不是来重新讨论 Riaan 的解决方案的。这篇文章的目的是强调以下几点:</p><ul class=""><li id="631e" class="la lb in kc b kd ke kh ki kl lc kp ld kt le kx lf lg lh li bi translated">我使用浮动 Docker 提供程序运行 HashiQube 的经验。</li><li id="46f7" class="la lb in kc b kd lj kh lk kl ll kp lm kt ln kx lf lg lh li bi translated">我为自己的书呆子目的对它做了一些修改，你可能也会觉得有用！</li><li id="668f" class="la lb in kc b kd lj kh lk kl ll kp lm kt ln kx lf lg lh li bi translated">我在旅途中遇到的一些问题。</li></ul><p id="d72b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们开始吧！</p><blockquote class="lo lp lq"><p id="2e4a" class="ka kb lr kc b kd ke kf kg kh ki kj kk ls km kn ko lt kq kr ks lu ku kv kw kx ig bi translated"><strong class="kc io">注:</strong> <em class="in">看来</em> <a class="ae jz" href="https://osxdaily.com/2022/10/22/you-can-now-run-virtualbox-on-apple-silicon-m1-m2/" rel="noopener ugc nofollow" target="_blank"> <em class="in"> VirtualBox 现在应该运行在 M1/M2 的 MAC 上</em> </a> <em class="in">。我自己没有试过，尽管我的一个同事尝试在他的 M1 Mac 电脑上运行 VBox 中的 Windows，但没有成功。</em></p></blockquote><h1 id="f721" class="lv lw in bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">设置</h1><p id="ee9f" class="pw-post-body-paragraph ka kb in kc b kd mt kf kg kh mu kj kk kl mv kn ko kp mw kr ks kt mx kv kw kx ig bi translated">当我在 2021 年开始玩 HashiQube 的时候，我<a class="ae jz" href="https://github.com/avillela/hashiqube" rel="noopener ugc nofollow" target="_blank">创造了自己的 HashiQube 叉子</a>。然而，我还没有对<a class="ae jz" href="https://github.com/servian/hashiqube" rel="noopener ugc nofollow" target="_blank">上游回购</a>做出贡献，因为它包含了一些我自己的定制。</p><p id="9c6c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我的<a class="ae jz" href="https://medium.com/@adri-v/list/hashiqube-bfdcb9c84e10" rel="noopener">现有的 HashiQube 教程</a>是基于<a class="ae jz" href="https://github.com/avillela/hashiqube" rel="noopener ugc nofollow" target="_blank">我的 fork </a>，为了保证这些不断裂，我在我的 fork 中创建了一个新的分支，叫做<code class="fe my mz na nb b"><a class="ae jz" href="https://github.com/avillela/hashiqube/tree/m1_main" rel="noopener ugc nofollow" target="_blank">m1_main</a></code>。这个分支是基于最近在<a class="ae jz" href="https://github.com/servian/hashiqube" rel="noopener ugc nofollow" target="_blank">上游 HashiQube repo </a>中的工作，它使用了流浪码头工人提供者。</p><p id="6e4a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以下是我的一些修改。</p><h2 id="9f05" class="nc lw in bd lx nd ne dn mb nf ng dp mf kl nh ni mj kp nj nk mn kt nl nm mr nn bi translated">绕道 Traefik 有什么新功能？</h2><p id="53d5" class="pw-post-body-paragraph ka kb in kc b kd mt kf kg kh mu kj kk kl mv kn ko kp mw kr ks kt mx kv kw kx ig bi translated">在我开始修改 Traefik 之前，我想指出，自从我上次在 Nomad 上使用它以来，Traefik 已经发生了相当大的变化，我很高兴 Riaan 在 HashiQube 上做了所有繁重的工作来获得 Traefik 的最新和最棒的版本。必须热爱开源社区！💜</p><p id="1364" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那么有什么变化呢？首先，Traefik 现在已经完全与 Nomad 整合在一起了。在以前，你需要用 Nomad 运行 Consul 来利用 Traefik 的服务发现。现在，领事中间人出局了。</p><p id="7a99" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了启用特定服务的 Traefik 服务发现，您需要在您的<code class="fe my mz na nb b">service</code>节中执行以下操作，如下面的代码片段所示:</p><ul class=""><li id="fed0" class="la lb in kc b kd ke kh ki kl lc kp ld kt le kx lf lg lh li bi translated">添加我们熟悉和喜爱的 Traefik 标签</li><li id="1aa6" class="la lb in kc b kd lj kh lk kl ll kp lm kt ln kx lf lg lh li bi translated">将<code class="fe my mz na nb b">provider = "nomad"</code>添加到您的配置</li></ul><pre class="no np nq nr gt ns nb nt bn nu nv bi"><span id="ea47" class="nw lw in nb b be nx ny l nz oa">service {<br/>  name = "traefik-dashboard"<br/>  provider = "nomad"<br/>  tags = [<br/>    "traefik.enable=true",<br/>    "traefik.http.routers.dashboard.rule=Host(`traefik.localhost`)",<br/>    "traefik.http.routers.dashboard.service=api@internal",<br/>    "traefik.http.routers.dashboard.entrypoints=web",<br/>  ]<br/><br/>  port = "http"<br/><br/>  check {<br/>    type     = "tcp"<br/>    interval = "10s"<br/>    timeout  = "5s"<br/>  }<br/>}</span></pre><p id="2209" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">完整的例子，<a class="ae jz" href="https://github.com/avillela/hashiqube/blob/f77e72bf9a4343e02f3c04e786ba012c2da1de3b/hashicorp/nomad/jobs/traefik.nomad#L32-L49" rel="noopener ugc nofollow" target="_blank">见 traefik.nomad </a>的第 23–49 行。</p><p id="edb2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另一个变化是<code class="fe my mz na nb b">traefik.nomad</code>作业中的 Traefik 配置。在以前，Traefik 是通过一个<a class="ae jz" href="https://en.wikipedia.org/wiki/TOML" rel="noopener ugc nofollow" target="_blank"> TOML </a>文件配置的，该文件通过<code class="fe my mz na nb b">template</code>节提供给 Traefik 容器实例，就像这样(参见<a class="ae jz" href="https://github.com/avillela/hashiqube/blob/2916a65f2dfb4764102ad48bd5cf69941ff5c483/hashicorp/nomad/jobs/traefik.nomad#L72-L100" rel="noopener ugc nofollow" target="_blank"> old traefik.nomad，第 72–100 行</a>):</p><pre class="no np nq nr gt ns nb nt bn nu nv bi"><span id="f164" class="nw lw in nb b be nx ny l nz oa">      template {<br/>        data = &lt;&lt;EOF<br/>[entryPoints]<br/>    [entryPoints.web]<br/>    address = ":80"<br/>    [entryPoints.metrics]<br/>    address = ":8082"<br/>    [entryPoints.grpc]<br/>    address = ":7233"<br/><br/><br/>[api]<br/>    dashboard = true<br/>    insecure  = true<br/><br/>[log]<br/>    level = "DEBUG"<br/># Enable Consul Catalog configuration backend.<br/>[providers.consulCatalog]<br/>    prefix           = "traefik"<br/>    exposedByDefault = false<br/><br/>    [providers.consulCatalog.endpoint]<br/>      address = "http://localhost:8500"<br/>      scheme  = "http"<br/>EOF<br/><br/><br/>        destination = "local/traefik.toml"<br/>      }</span></pre><p id="7752" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，它看起来干净多了，就像这样(见<a class="ae jz" href="https://github.com/avillela/hashiqube/blob/f77e72bf9a4343e02f3c04e786ba012c2da1de3b/hashicorp/nomad/jobs/traefik.nomad#L69-L86" rel="noopener ugc nofollow" target="_blank">new traefik . nomad lines 69–86</a>):</p><pre class="no np nq nr gt ns nb nt bn nu nv bi"><span id="74e6" class="nw lw in nb b be nx ny l nz oa">    task "server" {<br/>      driver = "docker"<br/>      config {<br/>        image = "traefik:v2.8.0-rc1"<br/>        ports = ["admin", "http", "api", "metrics", "grpc"]<br/>        args = [<br/>          "--api.dashboard=true",<br/>          "--api.insecure=true", ### For Test only, please do not use that in production<br/>          "--log.level=DEBUG",<br/>          "--entrypoints.web.address=:${NOMAD_PORT_http}",<br/>          "--entrypoints.traefik.address=:${NOMAD_PORT_admin}",<br/>          "--entrypoints.metrics.address=:${NOMAD_PORT_metrics}",<br/>          "--entrypoints.grpc.address=:${NOMAD_PORT_grpc}",<br/>          "--providers.nomad=true",<br/>          "--providers.nomad.endpoint.address=http://10.9.99.10:4646" ### IP to your nomad server <br/>        ]<br/>      }<br/>    }</span></pre><p id="8596" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如您所见，配置现在作为<code class="fe my mz na nb b">args</code>被传递到容器实例中。但是参数中的这些<code class="fe my mz na nb b">NOMAD_PORT_xyz</code>值(例如<code class="fe my mz na nb b">NOMAD_PORT_http</code>)有什么关系呢？嗯，它们只是对 Traefik Jobspec 的<code class="fe my mz na nb b">network</code>节中定义的端口的引用。例如，假设我们定义一个名为<code class="fe my mz na nb b">http</code>的端口，如下所示(<a class="ae jz" href="https://github.com/avillela/hashiqube/blob/f77e72bf9a4343e02f3c04e786ba012c2da1de3b/hashicorp/nomad/jobs/traefik.nomad#L11-L13" rel="noopener ugc nofollow" target="_blank">参见 traefik.nomad，第 11–13 行</a>):</p><pre class="no np nq nr gt ns nb nt bn nu nv bi"><span id="7317" class="nw lw in nb b be nx ny l nz oa">network {<br/>  port  "http"{<br/>     static = 80<br/>  }<br/>...<br/>}</span></pre><p id="5750" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们的 Jobspec 中，这个端口可以在 Jobspec 的其他地方作为<code class="fe my mz na nb b">${NOMAD_PORT_http}</code>引用。漂亮。该死的。酷毙了。😎</p><h2 id="7a89" class="nc lw in bd lx nd ne dn mb nf ng dp mf kl nh ni mj kp nj nk mn kt nl nm mr nn bi translated">Traefik 作业规范调整</h2><p id="d0d6" class="pw-post-body-paragraph ka kb in kc b kd mt kf kg kh mu kj kk kl mv kn ko kp mw kr ks kt mx kv kw kx ig bi translated">现在你们都明白了新 Traefik 配置的样子，是时候谈谈我对<a class="ae jz" href="https://github.com/servian/hashiqube/blob/master/hashicorp/nomad/jobs/traefik.nomad" rel="noopener ugc nofollow" target="_blank"> upstream traefik.nomad </a>文件的修改了。我做了两处改动:</p><ol class=""><li id="84cd" class="la lb in kc b kd ke kh ki kl lc kp ld kt le kx ob lg lh li bi translated">将 gRPC 与 Traefik 一起使用</li><li id="9d56" class="la lb in kc b kd lj kh lk kl ll kp lm kt ln kx ob lg lh li bi translated">通过端口 80 使 Traefik 仪表板可用</li></ol><p id="7bba" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们开始吃吧。</p><p id="13c2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">使用 gRPC 和 Traefik </strong></p><p id="2a38" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为什么要为此烦恼呢？因为现在大量的服务使用 gRPC，我希望能够在 Nomad 中运行使用 gRPC 的服务。因为 Traefik 是我的负载平衡器，所以我需要在 Traefik 中进行配置来实现这一点。</p><p id="b6e3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我运行的一个使用 gRPC 的服务是<a class="ae jz" href="https://docs.lightstep.com/otel/quick-start-collector" rel="noopener ugc nofollow" target="_blank"> OpenTelemetry Collector </a>。OpenTelemetry Collector 可以通过 HTTP 和 gRPC 接收仪器数据，我希望两种方法都可用。</p><p id="b98f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了将 gRPC 与 Traefik 一起使用，我首先必须在<code class="fe my mz na nb b">traefik.nomad</code> ( <a class="ae jz" href="https://github.com/avillela/hashiqube/blob/f77e72bf9a4343e02f3c04e786ba012c2da1de3b/hashicorp/nomad/jobs/traefik.nomad#L26-L28" rel="noopener ugc nofollow" target="_blank">第 26–28 行</a>)中定义一个 gRPC 端口:</p><pre class="no np nq nr gt ns nb nt bn nu nv bi"><span id="a024" class="nw lw in nb b be nx ny l nz oa">network {<br/>  ...<br/>  port "grpc" {<br/>    static = 7233<br/>  }<br/>  ...<br/>}</span></pre><p id="4e7c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，在 Traefik <code class="fe my mz na nb b">task</code>小节中，我需要让 Traefik 知道 gRPC 端口。这是通过<code class="fe my mz na nb b">traefik.nomad</code>中的<a class="ae jz" href="https://github.com/avillela/hashiqube/blob/f77e72bf9a4343e02f3c04e786ba012c2da1de3b/hashicorp/nomad/jobs/traefik.nomad#L73" rel="noopener ugc nofollow" target="_blank">线 73 </a>和<a class="ae jz" href="https://github.com/avillela/hashiqube/blob/f77e72bf9a4343e02f3c04e786ba012c2da1de3b/hashicorp/nomad/jobs/traefik.nomad#L81" rel="noopener ugc nofollow" target="_blank">线 81 </a>完成的:</p><pre class="no np nq nr gt ns nb nt bn nu nv bi"><span id="1a22" class="nw lw in nb b be nx ny l nz oa">task "server" {<br/>  driver = "docker"<br/>  config {<br/>    image = "traefik:v2.8.0-rc1"<br/>    ports = ["admin", "http", "api", "metrics", "grpc"]<br/>    args = [<br/>      ...<br/>      "--entrypoints.grpc.address=:${NOMAD_PORT_grpc}",<br/>      ...<br/>    ]<br/>  }</span></pre><p id="0736" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您还需要配置服务的 Jobspec 来使用 gRPC。在我的例子中，这意味着配置<a class="ae jz" href="https://github.com/avillela/hashiqube/blob/m1_main/hashicorp/nomad/jobs/otel-collector.nomad" rel="noopener ugc nofollow" target="_blank">open telemetry Collector job spec</a>，我将在本文稍后介绍。</p><p id="9f0e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">通过端口 80 使 Traefik 仪表板可用</strong></p><p id="bbdd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我第一次将 Traefik 添加到 HashiQube 时，我通过<code class="fe my mz na nb b"><a class="ae jz" href="http://traefik.localhost." rel="noopener ugc nofollow" target="_blank">http://traefik.localhost</a></code>设置了 Traefik 仪表盘。我想在我的<code class="fe my mz na nb b">m1_main</code>分公司做同样的事情。我这样做是通过如下配置我的<code class="fe my mz na nb b">traefik-dashboard</code>服务:</p><pre class="no np nq nr gt ns nb nt bn nu nv bi"><span id="fe5a" class="nw lw in nb b be nx ny l nz oa">service {<br/>  name = "traefik-dashboard"<br/>  provider = "nomad"<br/>  tags = [<br/>    "traefik.enable=true",<br/>    "traefik.http.routers.dashboard.rule=Host(`traefik.localhost`)",<br/>    "traefik.http.routers.dashboard.service=api@internal",<br/>    "traefik.http.routers.dashboard.entrypoints=web",<br/>  ]<br/>  ...<br/>}</span></pre><p id="4f58" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">值得注意的事项:</p><ul class=""><li id="382a" class="la lb in kc b kd ke kh ki kl lc kp ld kt le kx lf lg lh li bi translated"><code class="fe my mz na nb b">traefik.http.routers.dashboard.entrypoints=web</code>告诉我们仪表板在 web 端口上可用(由于<a class="ae jz" href="https://github.com/avillela/hashiqube/blob/f77e72bf9a4343e02f3c04e786ba012c2da1de3b/hashicorp/nomad/jobs/traefik.nomad#L11-L13" rel="noopener ugc nofollow" target="_blank"> this config </a>和 this <a class="ae jz" href="https://github.com/avillela/hashiqube/blob/f77e72bf9a4343e02f3c04e786ba012c2da1de3b/hashicorp/nomad/jobs/traefik.nomad#L78" rel="noopener ugc nofollow" target="_blank"> config </a>，我们将其配置为端口<code class="fe my mz na nb b">80</code></li><li id="f2e2" class="la lb in kc b kd lj kh lk kl ll kp lm kt ln kx lf lg lh li bi translated"><code class="fe my mz na nb b">traefik.http.routers.dashboard.rule=Host(`traefik.localhost`)</code>配置显示 Traefik 仪表盘将在<code class="fe my mz na nb b"><a class="ae jz" href="http://traefik.localhost." rel="noopener ugc nofollow" target="_blank">http://traefik.localhost</a></code>对我们可用。</li></ul><p id="d779" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以点击查看完整的 Jobspec 列表<a class="ae jz" href="https://github.com/avillela/hashiqube/blob/m1_main/hashicorp/nomad/jobs/traefik.nomad" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="da27" class="nc lw in bd lx nd ne dn mb nf ng dp mf kl nh ni mj kp nj nk mn kt nl nm mr nn bi translated">配置 Nomad，允许它从私有的 GitHub 容器注册表中提取 Docker 图像</h2><p id="af93" class="pw-post-body-paragraph ka kb in kc b kd mt kf kg kh mu kj kk kl mv kn ko kp mw kr ks kt mx kv kw kx ig bi translated">你需要在你的 Jobspec 中从一个私有的<a class="ae jz" href="https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-container-registry" rel="noopener ugc nofollow" target="_blank"> GitHub 容器注册表</a>中提取 Docker 图像吗？没问题！我给 nomad.sh 添加了<a class="ae jz" href="https://medium.com/@adri-v/just-in-time-nomad-running-traefik-on-hashiqube-7d6dfd8ef9d8" rel="noopener">一些配置来启用这个功能。这是基于</a><a class="ae jz" href="https://medium.com/@adri-v/just-in-time-nomad-running-traefik-on-hashiqube-7d6dfd8ef9d8" rel="noopener">我之前在 HashiQube </a>上的工作，只是将相同配置的一个端口转移到我的新<code class="fe my mz na nb b"><a class="ae jz" href="https://github.com/avillela/hashiqube/tree/m1_main" rel="noopener ugc nofollow" target="_blank">m1_main</a></code>分支。更多信息，请查看这篇博文(跳到 HashiQube  部分的<strong class="kc io"> <em class="lr">运行科技雷达应用的第 3 步)。</em></strong></p><h2 id="459c" class="nc lw in bd lx nd ne dn mb nf ng dp mf kl nh ni mj kp nj nk mn kt nl nm mr nn bi translated">配置 Nomad/Vault 集成</h2><p id="80b1" class="pw-post-body-paragraph ka kb in kc b kd mt kf kg kh mu kj kk kl mv kn ko kp mw kr ks kt mx kv kw kx ig bi translated">有时候你会想从你的职业说明书中获取保险库的秘密。为了做到这一点，我<a class="ae jz" href="https://medium.com/@adri-v/just-in-time-nomad-configuring-hashicorp-nomad-vault-integration-on-hashiqube-388c14cb070a" rel="noopener">配置了 nomad.sh 和 vault.sh </a>以使 nomad 能够获取保险库机密。同样，这是基于<a class="ae jz" href="https://medium.com/@adri-v/just-in-time-nomad-configuring-hashicorp-nomad-vault-integration-on-hashiqube-388c14cb070a" rel="noopener">我之前在 HashiQube </a>上的工作，只是将相同的配置移植到我的新<code class="fe my mz na nb b"><a class="ae jz" href="https://github.com/avillela/hashiqube/tree/m1_main" rel="noopener ugc nofollow" target="_blank">m1_main</a></code>分支。更多详情，请查看这篇博文。</p><h2 id="25ff" class="nc lw in bd lx nd ne dn mb nf ng dp mf kl nh ni mj kp nj nk mn kt nl nm mr nn bi translated">开放式遥测收集器作业规范</h2><p id="6b1f" class="pw-post-body-paragraph ka kb in kc b kd mt kf kg kh mu kj kk kl mv kn ko kp mw kr ks kt mx kv kw kx ig bi translated">当我第一次将<a class="ae jz" href="https://medium.com/tucows/just-in-time-nomad-running-the-opentelemetry-collector-on-hashicorp-nomad-with-hashiqube-4eaf009b8382" rel="noopener">open telemetry Collector job spec 添加到 HashiQube </a>时，它只通过 HTTP 摄取遥测数据。在这次更新中，它同时支持 HTTP 和 gRPC。我还更新了 Jobspec，以便更好地使用 Traefik 的更新版本。</p><p id="d9af" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了将收集器 Jobspec 配置为与 HTTP 和 gRPC 一起使用，我需要将以下端口添加到<code class="fe my mz na nb b">otel-collector.nomad</code>的<code class="fe my mz na nb b">network</code>节中(参见第<a class="ae jz" href="https://github.com/avillela/hashiqube/blob/f77e72bf9a4343e02f3c04e786ba012c2da1de3b/hashicorp/nomad/jobs/otel-collector.nomad#L31-L36" rel="noopener ugc nofollow" target="_blank">31–36</a>行):</p><pre class="no np nq nr gt ns nb nt bn nu nv bi"><span id="62bc" class="nw lw in nb b be nx ny l nz oa">network {<br/>  ...<br/>  port "otlp" {<br/>    to = 4317<br/>  }<br/>  port "otlphttp" {<br/>    to = 4318<br/>  }<br/>  ...<br/>}</span></pre><p id="01d3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">收集器通过端口<code class="fe my mz na nb b">4318</code>接收 HTTP，通过端口<code class="fe my mz na nb b">4317</code>接收 gRCP，上面的端口定义反映了这一点。</p><p id="944b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我还需要在<code class="fe my mz na nb b">otel-collector.nomad</code>中为每个端口定义<code class="fe my mz na nb b">service</code>节(参见<a class="ae jz" href="https://github.com/avillela/hashiqube/blob/f77e72bf9a4343e02f3c04e786ba012c2da1de3b/hashicorp/nomad/jobs/otel-collector.nomad#L169-L188" rel="noopener ugc nofollow" target="_blank">第 169–188 行</a>):</p><pre class="no np nq nr gt ns nb nt bn nu nv bi"><span id="fb58" class="nw lw in nb b be nx ny l nz oa">service {<br/>  provider = "nomad"<br/>  tags = [<br/>    "traefik.tcp.routers.otel-collector-grpc.rule=HostSNI(`*`)",<br/>    "traefik.tcp.routers.otel-collector-grpc.entrypoints=grpc",<br/>    "traefik.enable=true",<br/>  ]        <br/>  port = "otlp"<br/>}<br/><br/><br/>service {<br/>  provider = "nomad"<br/>  tags = [<br/>    "traefik.http.routers.otel-collector-http.rule=Host(`otel-collector-http.localhost`)",<br/>    "traefik.http.routers.otel-collector-http.entrypoints=web",<br/>    "traefik.http.routers.otel-collector-http.tls=false",<br/>    "traefik.enable=true",<br/>  ]<br/>  port = "otlphttp"<br/>}</span></pre><p id="423b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上述配置现在将允许程序通过 HTTP 和 gRPC 向收集器发送 OpenTelemetry 数据。</p><blockquote class="lo lp lq"><p id="423c" class="ka kb lr kc b kd ke kf kg kh ki kj kk ls km kn ko lt kq kr ks lu ku kv kw kx ig bi translated"><strong class="kc io">注意:</strong> <em class="in">由于我们使用的是 Traefik 的新的改进版本，您会注意到我们还设置了</em> <code class="fe my mz na nb b"><em class="in">provider = "nomad"</em></code> <em class="in">。</em></p></blockquote><p id="5cac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">要通过 HTTP </strong>调用 OTel 收集器，您的端点应该是<code class="fe my mz na nb b">otel-collector-http.localhost</code>。为什么？首先，因为<code class="fe my mz na nb b">traefik.http.routers.otel-collector-http.rule=Host(`otel-collector-http.localhost`)</code>说端点的主机是<code class="fe my mz na nb b">otel-collector-http.localhost</code>。端口是<code class="fe my mz na nb b">80</code>，因为配置<code class="fe my mz na nb b">traefik.http.routers.otel-collector-http.entrypoints=web</code>要求将容器端口<code class="fe my mz na nb b">4318</code>映射到端口<code class="fe my mz na nb b">80</code>，我们<a class="ae jz" href="https://github.com/avillela/hashiqube/blob/f77e72bf9a4343e02f3c04e786ba012c2da1de3b/hashicorp/nomad/jobs/traefik.nomad#L11-L13" rel="noopener ugc nofollow" target="_blank">在 traefik.nomad </a>中将其公开为 HTTP 端口。</p><p id="829d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要查看真实示例的效果，请查看<a class="ae jz" href="https://github.com/avillela/go-otel-instrumentation/blob/7bd3cf52c586a489a49aaf7415c6d653ede14d84/server.go#L33" rel="noopener ugc nofollow" target="_blank">这个样例 Go 代码</a>。</p><p id="9dfc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">要通过 gRPC </strong>调用 OTel 收集器，您的端点应该是<code class="fe my mz na nb b">otel-collector-grpc.localhost:7233</code>。为什么？首先，因为<code class="fe my mz na nb b">traefik.tcp.routers.otel-collector-grpc.rule=HostSNI(`*`)</code>说端点的主机是<code class="fe my mz na nb b">*</code>。通常，我会想用一些更具体的东西，比如<code class="fe my mz na nb b">otel-collector-grpc.localhost</code>而不是<code class="fe my mz na nb b">*</code>。不幸的是，如果您想使用不带 TLS 的 TCP 路由器(这是您需要用于带 Traefik 的 gRPC 的配置的一部分)，<a class="ae jz" href="https://community.traefik.io/t/configuration-of-non-http-port-without-tls/5901/2" rel="noopener ugc nofollow" target="_blank">这就是要走的路</a>。如果你试图在配置中放入<code class="fe my mz na nb b">*</code>以外的东西，Traefik。威尔。尖叫。在。你。😱但是这也意味着在你的调用代码中，你可以把任何你想要的作为主机名，并且它会工作。所以我选择调用我的端点<code class="fe my mz na nb b">otel-collector-grpc.localhost</code>，这样就遵循了与我的 HTTP 端点相同的命名约定。但是对于我们的 HTTP 端点，端口号是<code class="fe my mz na nb b">80</code>，对于 gRPC，端口号是<code class="fe my mz na nb b">7233</code>。为什么不是<code class="fe my mz na nb b">4317</code>？因为在我们的服务配置中，<code class="fe my mz na nb b">traefik.tcp.routers.otel-collector-grpc.entrypoints=grpc</code>标签要求将容器端口<code class="fe my mz na nb b">4317</code>映射到端口<code class="fe my mz na nb b">7233</code>，我们<a class="ae jz" href="https://github.com/avillela/hashiqube/blob/f77e72bf9a4343e02f3c04e786ba012c2da1de3b/hashicorp/nomad/jobs/traefik.nomad#L26-L28" rel="noopener ugc nofollow" target="_blank">在 traefik.nomad </a>中将其公开为 gRPC 端口。</p><p id="408f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要查看真实例子的效果，请查看这个样例 Go 代码。</p><h2 id="8acd" class="nc lw in bd lx nd ne dn mb nf ng dp mf kl nh ni mj kp nj nk mn kt nl nm mr nn bi translated">名字解析</h2><p id="466a" class="pw-post-body-paragraph ka kb in kc b kd mt kf kg kh mu kj kk kl mv kn ko kp mw kr ks kt mx kv kw kx ig bi translated">因此，还记得我们是如何在 Traefik 配置中定义一系列端点的吗:</p><ul class=""><li id="fe06" class="la lb in kc b kd ke kh ki kl lc kp ld kt le kx lf lg lh li bi translated"><code class="fe my mz na nb b">otel-collector-grpc.localhost</code></li><li id="a74c" class="la lb in kc b kd lj kh lk kl ll kp lm kt ln kx lf lg lh li bi translated"><code class="fe my mz na nb b">otel-collector-http.localhost</code></li><li id="56e0" class="la lb in kc b kd lj kh lk kl ll kp lm kt ln kx lf lg lh li bi translated"><code class="fe my mz na nb b">traefik.locahost</code></li></ul><p id="1170" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好吧，这些端点不会被解析，除非您将它们添加到您的<code class="fe my mz na nb b">/etc/hosts</code>文件中，如下所示:</p><pre class="no np nq nr gt ns nb nt bn nu nv bi"><span id="d6d3" class="nw lw in nb b be nx ny l nz oa">127.0.0.1   traefik.localhost<br/>127.0.0.1   otel-collector-http.localhost<br/>127.0.0.1   otel-collector-grpc.localhost</span></pre><p id="e2d2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为什么我们要将这些映射到<code class="fe my mz na nb b">127.0.0.1</code>？当流浪者提供 HashiQube 时，它会启动一个 Docker 镜像来运行流浪者、执政官和金库(以及其他东西)，我们可以分别通过<code class="fe my mz na nb b"><a class="ae jz" href="http://localhost:4646/" rel="noopener ugc nofollow" target="_blank">http://localhost:4646</a></code>、<code class="fe my mz na nb b"><a class="ae jz" href="http://localhost:8500," rel="noopener ugc nofollow" target="_blank">http://localhost:8500</a></code>和<code class="fe my mz na nb b"><a class="ae jz" href="http://localhost:8200," rel="noopener ugc nofollow" target="_blank">http://localhost:8200</a></code>使用它们。这意味着对于所有的意图和目的，就好像游牧者，执政官和金库都在<code class="fe my mz na nb b">localhost</code>上运行。因此，当我们更新我们的<code class="fe my mz na nb b">/etc/hosts</code>文件时，我们将主机名映射到本地主机 IP，<code class="fe my mz na nb b">127.0.0.1</code>。</p><h2 id="5469" class="nc lw in bd lx nd ne dn mb nf ng dp mf kl nh ni mj kp nj nk mn kt nl nm mr nn bi translated">暴露端口</h2><p id="2002" class="pw-post-body-paragraph ka kb in kc b kd mt kf kg kh mu kj kk kl mv kn ko kp mw kr ks kt mx kv kw kx ig bi translated">等等……我们还没有完成端点的工作。因为我们仍然需要在我们的<code class="fe my mz na nb b">Vagrantfile</code>中公开我们的 HTTP 和 gRPC 端口，否则我们实际上不能从我们的客户机器中访问它们。为此，只需将这些行添加到您的<code class="fe my mz na nb b">Vagrantfile</code>(参见<a class="ae jz" href="https://github.com/avillela/hashiqube/blob/f77e72bf9a4343e02f3c04e786ba012c2da1de3b/Vagrantfile#L110" rel="noopener ugc nofollow" target="_blank">行 110 </a>和<a class="ae jz" href="https://github.com/avillela/hashiqube/blob/f77e72bf9a4343e02f3c04e786ba012c2da1de3b/Vagrantfile#L112" rel="noopener ugc nofollow" target="_blank">行 112 </a>):</p><pre class="no np nq nr gt ns nb nt bn nu nv bi"><span id="e78a" class="nw lw in nb b be nx ny l nz oa">...<br/>config.vm.network "forwarded_port", guest: 80, host: 80 # traefik dashboard<br/>...<br/>config.vm.network "forwarded_port", guest: 7233, host: 7233 # gRPC (traefik config)<br/>...</span></pre><p id="ba05" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们已经准备好启动 HashiQube 了！</p><h1 id="89e5" class="lv lw in bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">运行哈希库贝</h1><h2 id="e12b" class="nc lw in bd lx nd ne dn mb nf ng dp mf kl nh ni mj kp nj nk mn kt nl nm mr nn bi translated">先决条件</h2><ul class=""><li id="006a" class="la lb in kc b kd mt kh mu kl oc kp od kt oe kx lf lg lh li bi translated"><a class="ae jz" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>(撰写本文时的版本为 20.10.17)</li><li id="9d7b" class="la lb in kc b kd lj kh lk kl ll kp lm kt ln kx lf lg lh li bi translated"><a class="ae jz" href="https://www.vagrantup.com/" rel="noopener ugc nofollow" target="_blank">流浪者</a>(撰写本文时的版本为 2.3.1)</li><li id="dc10" class="la lb in kc b kd lj kh lk kl ll kp lm kt ln kx lf lg lh li bi translated"><a class="ae jz" href="https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token" rel="noopener ugc nofollow" target="_blank">一个 GitHub 个人接入令牌(PAT) </a></li></ul><h2 id="3384" class="nc lw in bd lx nd ne dn mb nf ng dp mf kl nh ni mj kp nj nk mn kt nl nm mr nn bi translated">启动</h2><p id="9561" class="pw-post-body-paragraph ka kb in kc b kd mt kf kg kh mu kj kk kl mv kn ko kp mw kr ks kt mx kv kw kx ig bi translated">在你点燃 HashiQube 之前，我想指出几件重要的事情。</p><p id="101d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，如果您将<code class="fe my mz na nb b">DOCKER_DEFAULT_PLATFORM</code>环境变量设置为<code class="fe my mz na nb b">linux/amd64</code>，您必须在启动 HashiQube 之前<strong class="kc io"> <em class="lr">取消设置</em> </strong>它，它将不会正确设置。我之所以指出这一点，是因为我的默认设置是<code class="fe my mz na nb b">DOCKER_DEFAULT_PLATFORM=linux/amd64</code>，因为我需要我的 OpenTelemetry 工作，而这个小设置在启动 HashiQube 时让我陷入混乱。</p><p id="ca78" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">其次，我想快速指出的是，当您通读<a class="ae jz" href="http://cd hashiqube # if you aren't already there vagrant up --provision-with basetools,docker,vault,consul,nomad --provider docker" rel="noopener ugc nofollow" target="_blank">快速入门</a>时，您会注意到 living provisioning 命令如下所示:</p><pre class="no np nq nr gt ns nb nt bn nu nv bi"><span id="d0f3" class="nw lw in nb b be nx ny l nz oa">vagrant up --provision-with basetools,docker,vault,consul,nomad --provider docker</span></pre><p id="3753" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe my mz na nb b">--provision-with</code>标志允许我指定我想在 HashiQube 中引导的服务。省略这个标志会引导出一大堆我不一定想要或需要的其他工具。在我的例子中，我只是想提出金库，执政官和游牧者。但是为什么还包括<code class="fe my mz na nb b">basetools</code>和<code class="fe my mz na nb b">docker</code>？我需要<code class="fe my mz na nb b">basetools</code>来配置 HashiQube 使用的基本 Docker 映像。我需要<code class="fe my mz na nb b">docker</code>，这样我就可以使用 Nomad 来运行容器化的工作负载。您可能还记得，nomad<a class="ae jz" href="https://medium.com/tucows/just-in-time-nomad-80f57cd403ca" rel="noopener">支持各种不同的工作负载，而不仅仅局限于容器</a>。此外，需要注意的是，金库、执政官和游牧者必须按照这个顺序进行设置。执政官靠金库，游牧者靠金库和执政官。</p><p id="017c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好了……是时候发动哈希库贝了。要开始工作，<a class="ae jz" href="http://cd hashiqube # if you aren't already there vagrant up --provision-with basetools,docker,vault,consul,nomad --provider docker" rel="noopener ugc nofollow" target="_blank">请遵循这里的说明</a>。一旦 HashiQube 启动序列完成，您应该会看到类似这样的内容:</p><figure class="no np nq nr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi of"><img src="../Images/b3e9a609d6c1111e098b0f837a9ff356.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BQSUHBB4Rd1OtoeyH6Hv-g.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">HashiQube 启动序列末尾的屏幕截图。</figcaption></figure><p id="1598" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">启动一切可能需要 10 分钟以上，所以请耐心等待。😁</p><p id="0cca" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们做一个小小的抽查，以确保一切顺利。首先，让我们去<code class="fe my mz na nb b"><a class="ae jz" href="http://localhost:4646:" rel="noopener ugc nofollow" target="_blank">http://localhost:4646</a></code> <a class="ae jz" href="http://localhost:4646:" rel="noopener ugc nofollow" target="_blank"> : </a>看看 Nomad</p><figure class="no np nq nr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi og"><img src="../Images/388f5fb017685802fa3eba794c0b0f42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sn6auBdRJuUzz6ND5xzJxw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">部署了 Traefik 的 Nomad UI 的屏幕截图。</figcaption></figure><p id="706a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请注意，Traefik 作业已经部署。这意味着我们可以通过进入<code class="fe my mz na nb b"><a class="ae jz" href="http://traefik.localhost:" rel="noopener ugc nofollow" target="_blank">http://traefik.localhost</a></code> <a class="ae jz" href="http://traefik.localhost:" rel="noopener ugc nofollow" target="_blank"> : </a>来启动 Traefik 仪表板</p><figure class="no np nq nr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oh"><img src="../Images/114fae3009c5321589c72f91d7f549e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EPpqAeSUltp3WG0L-Awqkw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">http://traefik.localhost 上 Traefik 仪表板的屏幕截图</figcaption></figure><p id="edd3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在你知道了！你现在和流浪汉码头提供商一起经营 HashiQube！最棒的是，无论你用的是英特尔电脑还是 M1 Mac 电脑，你都可以运行这段代码。吼吼！！🎉</p><h1 id="795b" class="lv lw in bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">最后的想法</h1><p id="9bd5" class="pw-post-body-paragraph ka kb in kc b kd mt kf kg kh mu kj kk kl mv kn ko kp mw kr ks kt mx kv kw kx ig bi translated">我惊喜地发现，在我的 M1 Mac 电脑上运行最新版本的 HashiQube，使用的是<a class="ae jz" href="https://developer.hashicorp.com/vagrant/docs/providers/docker" rel="noopener ugc nofollow" target="_blank">vagger Docker Provider</a>。很高兴知道除了<a class="ae jz" href="https://developer.hashicorp.com/vagrant/docs/providers/virtualbox" rel="noopener ugc nofollow" target="_blank"> VirtualBox 流浪提供者</a>之外，你还有一个选择，同样有效！此外，我发现使用上游回购作为我的基线，我能够相对容易地合并我自己的修改。</p><p id="acc8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我有几个一直渴望开始的小游牧项目，现在我终于可以开始了。我等不及要和你们分享这些了！我希望这也能让你对 M1(以及更远的地方)的 HashiQube 感到兴奋！</p><p id="8b15" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我现在要奖励你一张我可爱的毛茸茸的小朋友的照片，它们是邦尼(瑞普，我的小鞭炮)、穆基和菲比。</p><figure class="no np nq nr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oi"><img src="../Images/550b213c893831827b8733fc95d71adf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O1nugyiH4c86KrC59oyQsA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">毛茸茸的朋友:邦妮、穆琪和菲比。由<a class="ae jz" href="https://adri-v.medium.com" rel="noopener">阿德里·维勒拉</a>拍摄。</figcaption></figure><p id="62fb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">和平、爱和准则。🦄 🌈 💫</p><figure class="no np nq nr gt jo gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/79b5a3e4ef4f3cdfd64a8a83dbe89f1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:388/format:webp/1*l8XnAlMJVQZguFEqHWkQzw.png"/></div></figure></div></div>    
</body>
</html>