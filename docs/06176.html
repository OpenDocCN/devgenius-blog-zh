<html>
<head>
<title>Creational Design patterns, An overview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创造性设计模式概述</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/creational-design-pattenrs-5066c918e434?source=collection_archive---------8-----------------------#2021-12-19">https://blog.devgenius.io/creational-design-pattenrs-5066c918e434?source=collection_archive---------8-----------------------#2021-12-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="80bb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">设计模式为面向对象的设计提供了模板，它解决了软件工程中一个常见的问题。当开发人员预计他们将不止一次地解决同一个问题时，他们应该使用设计模式。</p><ul class=""><li id="143d" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated">创造型的</li><li id="5b2b" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">结构的</li><li id="7f35" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">行为的</li></ul><p id="1aa6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这篇文章中，我们将回顾创造性的设计模式</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi kw"><img src="../Images/6bb86e934250f938f3e2e272eae31083.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EavlFstUjxO66o0H"/></div></div><figcaption class="li lj gj gh gi lk ll bd b be z dk translated">照片由<a class="ae lm" href="https://unsplash.com/@aaronburden?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Aaron Burden </a>在<a class="ae lm" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><h2 id="8bea" class="ln lo in bd lp lq lr dn ls lt lu dp lv jv lw lx ly jz lz ma mb kd mc md me mf bi translated">概述:</h2><p id="256c" class="pw-post-body-paragraph jk jl in jm b jn mg jp jq jr mh jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh ig bi translated">创造性设计模式与如何从类中构造对象有关。创建对象可能听起来微不足道，但是不经意地将代码与对象实例的创建混在一起可能会导致令人头疼的问题。创造性设计模式提供了关于如何最好地将对象创建过程封装到程序中的强大建议。下面是各种类型的创造性设计模式</p><h2 id="ba9b" class="ln lo in bd lp lq lr dn ls lt lu dp lv jv lw lx ly jz lz ma mb kd mc md me mf bi translated">抽象工厂模式:</h2><p id="5186" class="pw-post-body-paragraph jk jl in jm b jn mg jp jq jr mh jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh ig bi translated">当您有一组需要创建的对象，并且您不想在运行时之前指定要创建的对象类时，可以使用抽象工厂模式。该模式提供了一个接口，用于创建相关对象的系列，而无需指定它们的具体类。</p><p id="f29a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，假设您正在编写一个程序，需要创建几种不同类型的窗口。您可以创建一个名为 WindowFactory 的抽象工厂类，并让它包含一个 createWindow()方法。该方法将返回 Window 的几个具体子类之一的实例，如 JFrame、JDialog 或 JWindow。</p><p id="5414" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于天真的读者来说，工厂方法模式和抽象工厂模式似乎是相似的。两者的区别在于动机。工厂方法模式通常负责创建单个产品，而抽象工厂模式创建整个系列的相关产品。此外，在工厂方法模式中，我们使用继承来创建更专门化的产品，而在抽象工厂模式中，我们通过传入被消费来创建所需产品的工厂来实践对象组合。</p><h2 id="9c30" class="ln lo in bd lp lq lr dn ls lt lu dp lv jv lw lx ly jz lz ma mb kd mc md me mf bi translated">构建器模式:</h2><p id="c710" class="pw-post-body-paragraph jk jl in jm b jn mg jp jq jr mh jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh ig bi translated">当您有一个需要分多个步骤构建的复杂对象时，可以使用构建器模式。这种模式使用一个单独的构造函数，允许通过多个步骤来构造对象。</p><p id="86d8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，假设您正在编写一个需要创建用户界面的程序。用户界面由一个窗口和窗口内的几个按钮组成。您可以创建一个名为 UIBuilder 的生成器类。UIBuilder 类将有一个创建窗口的 buildWindow()方法和一个创建按钮的 buildButton()方法。</p><p id="bdda" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">构建器模式可能看起来类似于抽象工厂模式，但是一个区别是构建器模式一步一步地创建对象，而抽象工厂模式一步一步地返回对象</p><h2 id="3bca" class="ln lo in bd lp lq lr dn ls lt lu dp lv jv lw lx ly jz lz ma mb kd mc md me mf bi translated">工厂方法模式:</h2><p id="acad" class="pw-post-body-paragraph jk jl in jm b jn mg jp jq jr mh jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh ig bi translated">当您想要创建对象而不指定将要创建的对象的类时，可以使用工厂方法模式。该模式定义了创建对象的接口，但是将实际的创建留给了子类。</p><p id="ade3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，假设您正在编写一个程序，需要创建几种不同类型的窗口。您可以定义一个名为 WindowFactory 的接口来创建窗口。然后您可以创建一个名为 JFrameFactory 的工厂类来实现 WindowFactory 接口。JFrameFactory 类将包含一个 createWindow()方法，该方法将返回 JFrame 子类的一个实例。</p><p id="2c51" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种模式会产生太多差别很小的子类。如果子类扩展了功能，那么超类就不能使用它，除非它将它向下转换为具体类型。向下转换可能会在运行时失败。</p><h2 id="77a1" class="ln lo in bd lp lq lr dn ls lt lu dp lv jv lw lx ly jz lz ma mb kd mc md me mf bi translated">单例模式:</h2><p id="2815" class="pw-post-body-paragraph jk jl in jm b jn mg jp jq jr mh jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh ig bi translated">当您希望将一个类的实例化限制为一个对象时，可以使用 Singleton 模式。这种模式将一个类的实例化限制为一个对象。</p><p id="9046" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，假设您正在编写一个程序，需要创建几种不同类型的窗口。您可以创建一个名为 WindowManager 的单例类。WindowManager 类将有一个 getWindow()方法，该方法将返回所需 Window 子类的实例。如果这个类没有实例，getWindow()方法会创建一个。</p><p id="197d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">可以通过将构造函数设为 protected 而不是 private 来子类化单例类。在某些情况下它可能是合适的。在这些场景中采用的一种方法是创建子类的单例的<strong class="jm io">寄存器，并且<code class="fe ml mm mn mo b"><strong class="jm io">getInstance</strong></code>方法可以接受一个参数或者使用一个环境变量来返回期望的单例。注册表维护字符串名称到单例对象的映射。</strong></p><h2 id="da8c" class="ln lo in bd lp lq lr dn ls lt lu dp lv jv lw lx ly jz lz ma mb kd mc md me mf bi translated">原型模式:</h2><p id="a953" class="pw-post-body-paragraph jk jl in jm b jn mg jp jq jr mh jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh ig bi translated">当您想要克隆一个现有的对象时，可以使用原型模式。这种模式通过克隆现有对象来创建新对象。</p><p id="2557" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，假设您正在编写一个需要创建用户界面的程序。用户界面由一个窗口和窗口内的几个按钮组成。您可以创建一个名为 UIPrototype 的原型类。UIPrototype 类将有一个 clone()方法，该方法将创建 UIPrototype 对象的副本。</p><p id="389f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">原型模式也有助于类的动态加载。允许动态加载的语言框架将创建加载类的实例，并在管理实体中注册它。应用程序可以在运行时向管理器请求加载的类的对象。注意，应用程序不能静态访问类的构造函数。</p></div><div class="ab cl mp mq hr mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ig ih ii ij ik"><p id="4cb2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">希望这篇文章能给你一个创造性设计模式的概述，我将会涵盖其他设计模式的概述并深入其中，让我知道你对文章的想法，干杯！</p></div></div>    
</body>
</html>