<html>
<head>
<title>Python Duck Typing &amp; EAFP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">蟒蛇鸭打字&amp; EAFP</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/python-duck-typing-eafp-8cd486aacff2?source=collection_archive---------12-----------------------#2022-08-10">https://blog.devgenius.io/python-duck-typing-eafp-8cd486aacff2?source=collection_archive---------12-----------------------#2022-08-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="d525" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">鸭子打字术语来源于一句谚语“如果它走路像鸭子，叫起来像鸭子，那么它一定是鸭子。”</p><p id="e774" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Duck typing 是一个与动态类型相关的概念，在动态类型中，对象的类型或类没有它定义的方法重要。当您使用 duck 类型时，您根本不检查类型。相反，您检查给定方法或属性的存在。</p><p id="a174" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在第一个例子中，我们没有使用 duck 类型化和检查类型。</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="46fe" class="kr ks in kn b gy kt ku l kv kw">class Duck:<br/><br/>    def quack(self):<br/>        print('Quack, quack')<br/><br/>    def fly(self):<br/>        print('Flap, Flap!')<br/><br/><br/>class Person:<br/><br/>    def quack(self):<br/>        print("I'm Quacking Like a Duck!")<br/><br/>    def fly(self):<br/>        print("I'm Flapping my Arms!")<br/><br/>def quack_and_fly(thing):<br/>    pass<br/>    # Not Duck-Typed (Non-Pythonic)<br/>    if isinstance(thing, Duck):<br/>        thing.quack()<br/>        thing.fly()<br/>    else:<br/>        print('This has to be a Duck!')<br/><br/>d = Duck()<br/>quack_and_fly(d)<br/>p = Person()<br/>quack_and_fly(p)<br/>Output-<br/>Quack, quack<br/>Flap, Flap!<br/>This has to be a Duck!</span></pre><p id="c44b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个例子中，我们有函数——Duck()和 Person()，在函数 quack _ and _ fly()中，我们检查实例是否是 Duck()类型并执行操作。</p><p id="5dbc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 Duck()函数对象的情况下，我们得到了一个庸医和苍蝇的方法，在 Person()对象的情况下，我们得到了一个类似这样的消息——这一定是一只鸭子。</p><p id="117b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以检查类型和执行操作不是鸭子打字。</p><p id="ca9c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是一个例子，我们将相同的代码转换成 Duck typing。</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="1814" class="kr ks in kn b gy kt ku l kv kw">class Duck:<br/><br/>    def quack(self):<br/>        print('Quack, quack')<br/><br/>    def fly(self):<br/>        print('Flap, Flap!')<br/><br/><br/>class Person:<br/><br/>    def quack(self):<br/>        print("I'm Quacking Like a Duck!")<br/><br/>    def fly(self):<br/>        print("I'm Flapping my Arms!")<br/><br/>def quack_and_fly(thing):<br/>    pass<br/>    try:<br/>        thing.quack()<br/>        thing.fly()<br/>    except AttributeError as e:<br/>        print(e)<br/><br/>d = Duck()<br/>quack_and_fly(d)<br/>p = Person()<br/>quack_and_fly(p)<br/>Output-<br/>Quack, quack<br/>Flap, Flap!<br/>I'm Quacking Like a Duck!<br/>I'm Flapping my Arms!</span></pre><p id="1d68" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种情况下，我们首先执行操作，如果它没有出现在方法中，那么我们将进行同样的处理。</p><p id="ba18" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这被称为 EAFP，或者在 Python 中请求原谅比请求许可更容易。它建议你马上去做你期望的工作。如果它不起作用并且发生了异常，那么只需捕捉异常并适当地处理它。</p><p id="4d19" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了理解这一点，首先查看下面的例子，其中<strong class="jm io"> LBYL </strong>代表三思而后行。这是一种传统的编程方法，被认为是非 Pythonic 式的工作方式。</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="415b" class="kr ks in kn b gy kt ku l kv kw">class Duck:<br/><br/>    def quack(self):<br/>        print('Quack, quack')<br/><br/>    def fly(self):<br/>        print('Flap, Flap!')<br/><br/><br/>class Person:<br/><br/>    def quack(self):<br/>        print("I'm Quacking Like a Duck!")<br/><br/>    def fly(self):<br/>        print("I'm Flapping my Arms!")<br/><br/>def quack_and_fly(thing):<br/>    pass<br/>    # LBYL (Non-Pythonic)<br/>    if hasattr(thing, 'quack'):<br/>        if callable(thing.quack):<br/>            thing.quack()<br/><br/>    if hasattr(thing, 'fly'):<br/>        if callable(thing.fly):<br/>            thing.fly()<br/><br/><br/>d = Duck()<br/>quack_and_fly(d)<br/>p = Person()<br/>quack_and_fly(p)<br/>Output-<br/>Quack, quack<br/>Flap, Flap!<br/>I'm Quacking Like a Duck!<br/>I'm Flapping my Arms!</span></pre><p id="dfa3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个例子中，首先，我们检查对象是否具有特定的属性，然后执行操作。这种解决问题的方法被称为 LBYL，因为它依赖于在执行期望的动作之前检查先决条件。</p><p id="5601" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 EAFP，我们首先执行操作，如果出现错误，我们将进行同样的处理。</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="cd0f" class="kr ks in kn b gy kt ku l kv kw">class Duck:<br/><br/>    def quack(self):<br/>        print('Quack, quack')<br/><br/>    def fly(self):<br/>        print('Flap, Flap!')<br/><br/><br/>class Person:<br/><br/>    def quack(self):<br/>        print("I'm Quacking Like a Duck!")<br/><br/>    def fly(self):<br/>        print("I'm Flapping my Arms!")<br/><br/>def quack_and_fly(thing):<br/>    pass<br/>    try:<br/>        thing.quack()<br/>        thing.fly()<br/>        thing.dance()<br/>    except AttributeError as e:<br/>        print("Attribute Error !!")<br/><br/><br/>d = Duck()<br/>quack_and_fly(d)<br/>p = Person()<br/>quack_and_fly(p)<br/>Output-<br/>Quack, quack<br/>Flap, Flap!<br/>Attribute Error !!<br/>I'm Quacking Like a Duck!<br/>I'm Flapping my Arms!<br/>Attribute Error !!</span></pre><p id="567f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，我调用了一个额外的方法 Dance()，这两个函数中都不存在，所以会出现 except block 和 printing 异常。</p></div></div>    
</body>
</html>