<html>
<head>
<title>Asynchronous Initialization With NodeJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 NodeJS 进行异步初始化</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/asynchronous-initialization-with-nodejs-d01017f558c7?source=collection_archive---------10-----------------------#2022-10-07">https://blog.devgenius.io/asynchronous-initialization-with-nodejs-d01017f558c7?source=collection_archive---------10-----------------------#2022-10-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d3b84a6910d32ce8156301da5c06e12d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*THGs9SrrWzGgUlbG6yKqDA.jpeg"/></div></div></figure><h1 id="47eb" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">简短的</h1><p id="7732" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">启动 nodeJS 服务器非常简单，但是由于 node 及其模块系统独特的异步特性，有时会有点棘手，尤其是在涉及异步操作的复杂设置中。</p><h1 id="2952" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">例子</h1><p id="be5e" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">假设想要使用 Express &amp; MongoDB 启动一个 HTTP 服务器一分钟。启动数据库连接的最常见方式是这样的，这在 web 上非常流行:</p><figure class="lr ls lt lu gt jo"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="b45e" class="pw-post-body-paragraph kt ku in kv b kw lx ky kz la ly lc ld le lz lg lh li ma lk ll lm mb lo lp lq ig bi translated">如果是这样，我们的应用程序模块将在需要时启动数据库连接——在创建 express 应用程序或启动服务器之前。</p><figure class="lr ls lt lu gt jo"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="b504" class="pw-post-body-paragraph kt ku in kv b kw lx ky kz la ly lc ld le lz lg lh li ma lk ll lm mb lo lp lq ig bi translated">值得一提的是，MongoDB 初始化是异步的，初看起来似乎没什么问题，但实际上却出现了一些问题:</p><ol class=""><li id="5bea" class="mc md in kv b kw lx la ly le me li mf lm mg lq mh mi mj mk bi translated"><strong class="kv io">故障:</strong>服务器初始化(并允许请求进入)发生在我们建立到数据库的连接之前，这使我们的应用程序在一定时间内处于不稳定状态。</li><li id="249b" class="mc md in kv b kw ml la mm le mn li mo lm mp lq mh mi mj mk bi translated"><strong class="kv io">没有错误传播:</strong>如果连接失败，在当前的设置下，我们只需记录一条错误消息(这很好)，但是如果我们想对此做出反应呢？小心关闭或通知其他模块连接失败。</li><li id="dc5c" class="mc md in kv b kw ml la mm le mn li mo lm mp lq mh mi mj mk bi translated"><strong class="kv io">太早:</strong>通过要求 db 模块，我们执行它并试图在早期初始化一个连接。也许我们希望这发生在我们设置的后期，或者在此之前应用一些逻辑？</li></ol><p id="985b" class="pw-post-body-paragraph kt ku in kv b kw lx ky kz la ly lc ld le lz lg lh li ma lk ll lm mb lo lp lq ig bi translated">从索引文件启动服务器将会导致<em class="mq">初始化混乱</em>，即使是简单的设置。</p><figure class="lr ls lt lu gt jo"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="901e" class="pw-post-body-paragraph kt ku in kv b kw lx ky kz la ly lc ld le lz lg lh li ma lk ll lm mb lo lp lq ig bi translated">想想一个更复杂的应用会发生什么。</p></div><div class="ab cl mr ms hr mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ig ih ii ij ik"><h1 id="1bad" class="jv jw in bd jx jy my ka kb kc mz ke kf kg na ki kj kk nb km kn ko nc kq kr ks bi translated"><strong class="ak">异步初始化</strong></h1><p id="8152" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">每个模块都会公开一个<em class="mq"> create </em>和<em class="mq"> destroy </em>方法，两者都是异步的。每个方法都将<em class="mq">初始化</em>和<em class="mq">终止</em>逻辑封装在里面。</p><figure class="lr ls lt lu gt jo"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="0e9f" class="pw-post-body-paragraph kt ku in kv b kw lx ky kz la ly lc ld le lz lg lh li ma lk ll lm mb lo lp lq ig bi translated">通过这样做，当且仅当 express 应用程序或另一个模块确实需要时，我们才能初始化数据库连接。出错和日志记录的控制流变得简单明了。</p><p id="9ed4" class="pw-post-body-paragraph kt ku in kv b kw lx ky kz la ly lc ld le lz lg lh li ma lk ll lm mb lo lp lq ig bi translated">最重要的是，一个初始化另一个模块的模块也要把它拆下来，保持我们的创建/销毁事件历史形成一个堆栈。只有先关闭所有依赖项，服务器才会关闭。</p><figure class="lr ls lt lu gt jo"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="dc60" class="pw-post-body-paragraph kt ku in kv b kw lx ky kz la ly lc ld le lz lg lh li ma lk ll lm mb lo lp lq ig bi translated">单个<em class="mq">异步初始化</em>使整个流程异步。因此，我们也必须以异步方式初始化我们的 express 应用程序— <strong class="kv io">,但这实际上是一件好事！</strong></p><p id="ab0e" class="pw-post-body-paragraph kt ku in kv b kw lx ky kz la ly lc ld le lz lg lh li ma lk ll lm mb lo lp lq ig bi translated">以下是一些原因:</p><ol class=""><li id="580d" class="mc md in kv b kw lx la ly le me li mf lm mg lq mh mi mj mk bi translated"><strong class="kv io">控制流程:</strong>如果我们在接受请求之前做一些繁重的工作或者应用一些定制的逻辑，这是控制整个服务器初始化流程的更好方法。</li><li id="2ce7" class="mc md in kv b kw ml la mm le mn li mo lm mp lq mh mi mj mk bi translated"><strong class="kv io">正确拆除:</strong>优雅地关闭我们的服务器，并将关闭数据库连接的任务委托给应用程序模块要容易得多——<em class="mq">无论谁打开它，都应该关闭它</em>。</li><li id="83d7" class="mc md in kv b kw ml la mm le mn li mo lm mp lq mh mi mj mk bi translated"><strong class="kv io">良好的测试设置:</strong>我们的集成测试可以在合适的时候轻松创建许多应用程序实例，并在它们完成后销毁它们。</li></ol><p id="a16b" class="pw-post-body-paragraph kt ku in kv b kw lx ky kz la ly lc ld le lz lg lh li ma lk ll lm mb lo lp lq ig bi translated">现在，即使是主索引文件看起来也更好了。</p><figure class="lr ls lt lu gt jo"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="14ad" class="pw-post-body-paragraph kt ku in kv b kw lx ky kz la ly lc ld le lz lg lh li ma lk ll lm mb lo lp lq ig bi translated">黑客快乐！</p></div></div>    
</body>
</html>