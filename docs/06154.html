<html>
<head>
<title>React 18: Automatic Batching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应 18:自动配料</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/react-18-automatic-batching-2f5d691b4f19?source=collection_archive---------7-----------------------#2021-12-17">https://blog.devgenius.io/react-18-automatic-batching-2f5d691b4f19?source=collection_archive---------7-----------------------#2021-12-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/7cab3006c472776de3dc954a1eec822c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*J3_GUEixVspgxT63.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">反应 18:自动配料</figcaption></figure><p id="06c2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我相信您过去听说过“反应批处理”这个术语，可能您(和我一样)对它的含义和实际用途感到困惑。</p><p id="4a71" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在继续这篇文章之前，请确保您查看了我的个人网站，并订阅了我的博客，我会在那里发布更多类似这样的内容:<a class="ae ky" href="https://tasoskakour.com/" rel="noopener ugc nofollow" target="_blank"><em class="kx">https://tasoskakour.com</em></a><em class="kx">。</em></p><p id="b519" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">一般来说，单词<em class="kx">批处理</em>可以以多种方式使用，但是对我们的用例有意义的一般定义可以表达为:</p><blockquote class="kz la lb"><p id="0026" class="jz ka kx kb b kc kd ke kf kg kh ki kj lc kl km kn ld kp kq kr le kt ku kv kw ig bi translated"><em class="in">作为计算机处理单元的一组作业、数据或程序。</em></p><p id="8a42" class="jz ka kx kb b kc kd ke kf kg kh ki kj lc kl km kn ld kp kq kr le kt ku kv kw ig bi translated"><em class="in">(批处理)数据处理的一种形式，在同一机器运行期间，许多输入作业被分组处理。</em></p></blockquote><h1 id="9491" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">什么是反应配料</h1><p id="9bb1" class="pw-post-body-paragraph jz ka in kb b kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw ig bi translated">基本上，当 React 应用“批处理”时，这意味着它<strong class="kb io">将多个状态更新组合成一个单一的重新渲染</strong>主要是为了更好的性能。</p><p id="1f17" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在 React 17 和之前的版本中，React 只在 React 事件处理程序中自动批处理任何状态更新<strong class="kb io">(就像<em class="kx">点击</em>或<em class="kx">改变</em>)。</strong></p><p id="1174" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">看看下面的代码，猜猜<code class="fe mi mj mk ml b">handleClick</code>函数会导致多少次重新渲染？</p><p id="66a6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">也不用担心<code class="fe mi mj mk ml b">useRenderCount</code>功能。这只是一个用来计算重渲染次数的自定义钩子:-)</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="a470" class="mu lg in ml b gy mv mw l mx my">const useRenderCount = () =&gt; {<br/>  const renderCounter = useRef(0); <br/>  useLayoutEffect(() =&gt; {<br/>    renderCounter.current++;<br/>  });<br/>  return renderCounter.current;<br/>};</span></pre><p id="fc00" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">实际演示:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="8e85" class="mu lg in ml b gy mv mw l mx my">const Demo1 = () =&gt; {<br/>    const renderCount = useRenderCount(); // we use this to count re-renders<br/>    const [countUp, setCountUp] = useState(0);<br/>    const [countDown, setCountDown] = useState(0);<br/><br/>    const handleClick = () =&gt; {<br/>        setCountUp((cUp) =&gt; cUp + 1);<br/>        setCountDown((cDown) =&gt; cDown - 1);<br/>    };<br/><br/>    return (<br/>        &lt;div style={{ textAlign: "center" }}&gt;<br/>            &lt;h4&gt;Demo 1 (Batching)&lt;/h4&gt;<br/>            &lt;button onClick={handleClick}&gt;Click me&lt;/button&gt;<br/>            &lt;h2&gt;Count up: {countUp}&lt;/h2&gt;<br/>            &lt;h2&gt;Count down: {countDown}&lt;/h2&gt;<br/>            &lt;div&gt;Number of rerenders: {renderCount}&lt;/div&gt;<br/>        &lt;/div&gt;<br/>    );<br/>}</span></pre><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mz"><img src="../Images/93fecaccba5c74bb0d61ba2206a4099f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cVErzMYoIg7_P_tf.gif"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">演示 1: React 事件处理程序被成功批处理。</figcaption></figure><p id="9d90" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">没错，它只会导致<strong class="kb io">一个</strong>重新渲染，因为 React 会把两个状态更新<code class="fe mi mj mk ml b">setCountUp</code>和<code class="fe mi mj mk ml b">setCountDown</code>批处理成一个！</p><p id="efba" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">很酷吧？React 将自动为我们处理这些问题，并避免不必要的重新渲染，这对性能非常好！此外，它将防止我们的组件呈现“半成品”状态，其中只有一个状态变量被更新，这可能会导致错误。</p><h1 id="c564" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">✋:但是……有一个问题</h1><p id="374b" class="pw-post-body-paragraph jz ka in kb b kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw ig bi translated"><strong class="kb io"> React(版本 18 之前)只会批量 React 事件处理程序。它不会批量更新 promises、setTimeout、本机事件处理程序或任何其他事件。</strong></p><p id="c206" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在现实世界中，有许多用例需要更新 React 不能批处理的处理程序中的多个状态。</p><p id="d673" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们看看下面的一些例子，React 不会批量更新，它会导致多次重新渲染。</p><h2 id="87dc" class="mu lg in bd lh na nb dn ll nc nd dp lp kk ne nf lt ko ng nh lx ks ni nj mb nk bi translated">setTimeout 内部的更新</h2><p id="367e" class="pw-post-body-paragraph jz ka in kb b kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw ig bi translated">在下面的演示中，<code class="fe mi mj mk ml b">setCountUp</code>和<code class="fe mi mj mk ml b">setCountDown</code>将导致<strong class="kb io">两个</strong>重新渲染，因为 React 无法在<code class="fe mi mj mk ml b">setTimeout</code>回调中批量处理多个更新。</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="dcca" class="mu lg in ml b gy mv mw l mx my">const Demo2 = () =&gt; {<br/>  const renderCount = useRenderCount();<br/>  const [countUp, setCountUp] = useState(0);<br/>  const [countDown, setCountDown] = useState(0);<br/><br/>  const handleClick = () =&gt; {<br/>    setTimeout(() =&gt; {<br/>      setCountUp((cUp) =&gt; cUp + 1);<br/>      setCountDown((cDown) =&gt; cDown - 1);<br/>    }, 500);<br/>  };<br/><br/>  return (<br/>    &lt;div className="Demo"&gt;<br/>      &lt;h4&gt;Demo 2 (setTimeout)&lt;/h4&gt;<br/>      &lt;button onClick={handleClick}&gt;Click me&lt;/button&gt;<br/>      &lt;h2&gt;Count up: {countUp}&lt;/h2&gt;<br/>      &lt;h2&gt;Count down: {countDown}&lt;/h2&gt;<br/>      &lt;div&gt;Number of rerenders: {renderCount}&lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mz"><img src="../Images/e0044c6c42e39b4e791ae463473e2cf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tuDiLt65CWXeFVKt.gif"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">演示 2:反应(&lt;17) is not able to batch setTimeout callbacks.</figcaption></figure><h2 id="bd83" class="mu lg in bd lh na nb dn ll nc nd dp lp kk ne nf lt ko ng nh lx ks ni nj mb nk bi translated">2) Updates inside a promise</h2><p id="8a51" class="pw-post-body-paragraph jz ka in kb b kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw ig bi translated">In the example below we fetch a random cat image when the button is clicked. React cannot batch the multiple state updates that’s after the  【T0】  fetch call, specifically the  【T1】  and  【T2】 .</p><p id="8633" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">However, it successfully batches the first two calls before the await:  【T3】  and  【T4】 .</p><p id="c786" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">So in total the  【T5】  function will cause 3 re-renders.</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="83fa" class="mu lg in ml b gy mv mw l mx my">const Demo3 = () =&gt; {<br/>  const renderCount = useRenderCount();<br/>  const [loading, setLoading] = useState(false);<br/>  const [cat, setCat] = useState(null);<br/><br/>  const handleClick = async () =&gt; {<br/>    // these two below will be batched<br/>    setLoading(true);<br/>    setCat(null);<br/>    const response = await fetch("https://thatcopy.pw/catapi/rest/");<br/>    if (response.ok) {<br/>      const json = await response.json();<br/>      setCat(json.url); // cannot batch<br/>    }<br/>    setLoading(false); // cannot batch<br/>  };<br/><br/>  return (<br/>    &lt;div className="Demo"&gt;<br/>      &lt;h4&gt;Demo 3 (Promise)&lt;/h4&gt;<br/>      &lt;button onClick={handleClick}&gt;Click me&lt;/button&gt;<br/>      &lt;h2&gt;Loading: {String(loading)}&lt;/h2&gt;<br/>      &lt;h2<br/>        style={{<br/>          display: "flex",<br/>          justifyContent: "center",<br/>          alignItems: "center"<br/>        }}<br/>      &gt;<br/>        Cat:{" "}<br/>        {cat ? (<br/>          &lt;img<br/>            alt="cat"<br/>            width="35"<br/>            height="35"<br/>            src={cat}<br/>            style={{ marginLeft: "8px" }}<br/>          /&gt;<br/>        ) : (<br/>          ""<br/>        )}<br/>      &lt;/h2&gt;<br/>      &lt;div&gt;Number of rerenders: {renderCount}&lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mz"><img src="../Images/eb77395de1b485cd9888d6e985cb3e3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NnXOo-WX6aWIi_de.gif"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">Demo 3: React (&lt;17) is not able to batch promises.</figcaption></figure><h2 id="6abd" class="mu lg in bd lh na nb dn ll nc nd dp lp kk ne nf lt ko ng nh lx ks ni nj mb nk bi translated">3) Updates inside a native event handler</h2><p id="35d8" class="pw-post-body-paragraph jz ka in kb b kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw ig bi translated">In the example below we use a native event handler by attaching a  【T6】  listener to our button. React is not able to batch these multiple state updates as well.</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="4ad7" class="mu lg in ml b gy mv mw l mx my">const Demo4 = () =&gt; {<br/>  const renderCount = useRenderCount();<br/>  const [countUp, setCountUp] = useState(0);<br/>  const [countDown, setCountDown] = useState(0);<br/><br/>  useEffect(() =&gt; {<br/>    const handleClick = () =&gt; {<br/>      setCountUp((cUp) =&gt; cUp + 1);<br/>      setCountDown((cDown) =&gt; cDown - 1);<br/>    };<br/><br/>    const element = document.querySelector("#my-button");<br/>    element.addEventListener("click", handleClick);<br/><br/>    return () =&gt; {<br/>      element.removeEventListener('click', handleClick);<br/>    };<br/>  }, []);<br/><br/>  return (<br/>    &lt;div className="Demo"&gt;<br/>      &lt;h4&gt;Demo 4 (Native event handler)&lt;/h4&gt;<br/>      &lt;button id="my-button"&gt;Click me&lt;/button&gt;<br/>      &lt;h2&gt;Count up: {countUp}&lt;/h2&gt;<br/>      &lt;h2&gt;Count down: {countDown}&lt;/h2&gt;<br/>      &lt;div&gt;Number of rerenders: {renderCount}&lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nl"><img src="../Images/5613a83250a39c07910e93517a0047c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*D3Jf8UL1_kDYl865.gif"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">React (&lt;17) is not able to batch native event handlers.</figcaption></figure><h2 id="eb93" class="mu lg in bd lh na nb dn ll nc nd dp lp kk ne nf lt ko ng nh lx ks ni nj mb nk bi translated">💡 Quick fix to the above scenarios</h2><p id="3f0c" class="pw-post-body-paragraph jz ka in kb b kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw ig bi translated">Obviously, a fix to the above scenarios would be to store all the “individual” states to a big state (or use a useReducer).</p><p id="e87a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">For example, the Demo with the fetch promise could be written as shown below in order to prevent unwanted re-renders:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="4a1f" class="mu lg in ml b gy mv mw l mx my">const Demo3Fix = () =&gt; {<br/>  const renderCount = useRenderCount();<br/>  const [state, setState] = useState({<br/>    loading: false,<br/>    cat: null<br/>  }); // a single state object<br/><br/>  const handleClick = async () =&gt; {<br/>    setState({<br/>      loading: true,<br/>      cat: null<br/>    }); // 1st re-render<br/>    const response = await fetch("https://thatcopy.pw/catapi/rest/");<br/>    if (response.ok) {<br/>      const json = await response.json();<br/>      setState((s) =&gt; ({ cat: json.url, loading: false })); // 2nd re-render<br/>    } else {<br/>      setState((s) =&gt; ({ ...s, loading: false })); // or this 2nd re-render<br/>    }<br/>  };<br/><br/>  const { cat, loading } = state;<br/><br/>  return (<br/>    ...<br/>  );<br/>};</span></pre><p id="c546" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">➡️ All the previous React 17 demos are available in this CodeSandbox: <a class="ae ky" href="https://codesandbox.io/s/cranky-mccarthy-g5ntm" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/cranky-mccarthy-g5ntm</a></p><h1 id="161b" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">对救援做出反应 18🎉</h1><p id="8f34" class="pw-post-body-paragraph jz ka in kb b kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw ig bi translated">React 18 为所有用例添加了自动批处理，以进一步提高性能。你可以在这里阅读更多<a class="ae ky" href="https://reactjs.org/blog/2021/06/08/the-plan-for-react-18.html" rel="noopener ugc nofollow" target="_blank"/>。它仍处于测试阶段。</p><p id="4a95" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这意味着对于我们之前所有例子中的<strong class="kb io">来说，React (18)会自动将多个状态更新批处理成一个更新。</strong></p><p id="1e8b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为了证明，看看下面的<em class="kx"> setTimeout </em>演示，我们唯一改变的是 React 到 18 的版本和<code class="fe mi mj mk ml b">index.js</code>内的代码，我们在那里指示 React 如何加载我们的应用程序。具体来说，为了让 React 18 利用这些新特性，我们需要利用<code class="fe mi mj mk ml b">createRoot</code> api。</p><p id="1767" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe mi mj mk ml b">index.js</code>在 React 17:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="bb83" class="mu lg in ml b gy mv mw l mx my">import { render } from "react-dom";<br/>import App from "./App";<br/><br/>render(&lt;App /&gt;, document.getElementById("root"));</span></pre><p id="b083" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe mi mj mk ml b">index.js</code>在 React 18:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="0b5c" class="mu lg in ml b gy mv mw l mx my">import { createRoot } from "react-dom";<br/>import App from "./App";<br/><br/>createRoot(document.getElementById("root")).render(&lt;App /&gt;);</span></pre><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nl"><img src="../Images/69629564be1cb314a1f7ed97b61be789.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pYC0RvtsFVqO6sMx.gif"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">React 18:它自动批处理 setTimeout 回调！</figcaption></figure><p id="48f5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">以下是 React 18 的所有实验代码:<a class="ae ky" href="https://codesandbox.io/s/objective-elbakyan-6u76m" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/objective-elbakyan-6u76m</a></p><h1 id="d0f5" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">不想批怎么办？</h1><p id="6d6b" class="pw-post-body-paragraph jz ka in kb b kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw ig bi translated">可能有这样一种情况，我们不希望 React 批量更新(尽管通常认为批处理是安全的)。我们可以通过使用如下所示的<code class="fe mi mj mk ml b">flushSync</code>函数来实现:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="c94b" class="mu lg in ml b gy mv mw l mx my">import { flushSync } from 'react-dom'; <br/><br/>const handleClick = () =&gt; {<br/>  flushSync(() =&gt; {<br/>    setCountUp((cUp) =&gt; cUp + 1);  // 1st re-render <br/>  })<br/>  flushSync(() =&gt; { <br/>    setCountDown((cDown) =&gt; cDown - 1); // 2nd re-render<br/>  })  <br/>};</span></pre><p id="be41" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这里值得注意的是，在 React 18 之前的版本中，我们可以通过使用如下未记录的 API <code class="fe mi mj mk ml b">unstable_batchedUpdates</code>来强制批处理 React 事件处理程序之外的状态更新:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="6255" class="mu lg in ml b gy mv mw l mx my">unstable_batchedUpdates(() =&gt; {<br/>  // these 2 below will be batched<br/>  setCountUp((cUp) =&gt; cUp + 1);<br/>  setCountDown((cDown) =&gt; cDown - 1);<br/>});</span></pre><p id="d7c7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">根据文档，这个 API 在 18 中仍然存在，但是已经没有必要了，因为批处理是自动发生的。在未来的版本中，它也可能被删除。</p><h1 id="e1c2" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结束了</h1><p id="6260" class="pw-post-body-paragraph jz ka in kb b kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw ig bi translated">我希望你喜欢这篇文章，回头见！😃</p></div><div class="ab cl nm nn hr no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ig ih ii ij ik"><p id="7c5b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="kx">最初发表于</em><a class="ae ky" href="https://tasoskakour.com/blog/react-18-automatic-batching" rel="noopener ugc nofollow" target="_blank">T5【https://tasoskakour.com】</a><em class="kx">。</em></p></div></div>    
</body>
</html>