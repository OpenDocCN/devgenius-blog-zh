<html>
<head>
<title>Let’s Build a Linux Shell — Part IV</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们构建一个 Linux Shell —第四部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/lets-build-a-linux-shell-part-iv-cefdd8f58138?source=collection_archive---------3-----------------------#2020-06-29">https://blog.devgenius.io/lets-build-a-linux-shell-part-iv-cefdd8f58138?source=collection_archive---------3-----------------------#2020-06-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/63a034618da33bf947720b333bcb87b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4z_0Q6YJHs6Rh_J8"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae jz" href="https://unsplash.com/@_imkiran?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Sai Kiran Anagani </a>拍摄的照片</figcaption></figure><p id="d569" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是关于如何构建 Linux shell 的教程的第四部分。可以从以下链接阅读本教程的前几部分:<a class="ae jz" href="https://medium.com/dev-genius/lets-build-a-linux-shell-part-i-954c95911501" rel="noopener">第一部分</a>、<a class="ae jz" href="https://medium.com/swlh/lets-build-a-linux-shell-part-ii-340ecf471028" rel="noopener">第二部分</a>、<a class="ae jz" href="https://medium.com/swlh/lets-build-a-linux-shell-part-iii-a472c0102849" rel="noopener">第三部分</a>。</p><p id="bcb6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">注意</strong>:你可以从<a class="ae jz" href="https://github.com/moisam/lets-build-a-linux-shell/tree/master/part4" rel="noopener ugc nofollow" target="_blank">这个 GitHub 库</a>下载第四部分的完整源代码。</p><h1 id="464a" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第四部分导言</h1><p id="3a25" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">在这一部分，我们将把<a class="ae jz" href="https://en.wikipedia.org/wiki/Symbol_table" rel="noopener ugc nofollow" target="_blank">符号表</a>添加到 shell 中。<strong class="kc io">符号表</strong>是一种数据结构，由<a class="ae jz" href="https://en.wikipedia.org/wiki/Compiler" rel="noopener ugc nofollow" target="_blank">编译器</a>和<a class="ae jz" href="https://en.wikipedia.org/wiki/Interpreter_(computing)" rel="noopener ugc nofollow" target="_blank">解释器</a>使用，将<a class="ae jz" href="https://en.wikipedia.org/wiki/Variable_(computer_science)" rel="noopener ugc nofollow" target="_blank">变量</a>存储为表中的条目。每个条目由一个键(变量的<strong class="kc io">名</strong>)和一个关联值(变量的<strong class="kc io">值</strong>)组成。键通常是唯一的，也就是说，我们不能有两个条目共享同一个键(也就是说，不能有两个变量共享同一个变量名)。</p><p id="db5d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通常，Linux shell 会在启动时填充它的符号表。在填充了符号表之后，编译器或解释器可以很容易地在表中搜索一个变量来检索该变量的值。我们还可以执行<a class="ae jz" href="https://en.wikipedia.org/wiki/Type_system#Type_checking" rel="noopener ugc nofollow" target="_blank">类型检查</a>，强制执行<a class="ae jz" href="https://en.wikipedia.org/wiki/Scope_(computer_science)" rel="noopener ugc nofollow" target="_blank">范围规则</a>(例如，使变量仅对声明它的函数可见)，以及<a class="ae jz" href="http://www2.linux-training.be/funhtml/ch14.html#idp53826080" rel="noopener ugc nofollow" target="_blank">将外壳变量</a>导出到外部命令。</p><p id="0c29" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了填充符号表，shell 读取<strong class="kc io">环境变量</strong>列表，该列表从其父进程(通常是用户登录的进程，或者是登录进程的子进程)传递给 shell。shell 将每个变量(及其值)添加到符号表中。然后，我们可以使用适当的内置实用程序随意编辑、删除或导出 shell 变量(我们将在本系列的后面讨论)。</p><h1 id="99f6" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">为什么我们需要一个符号表？</h1><p id="ea52" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">简而言之，符号表使我们能够定义外壳变量，修改它们的值，在执行<a class="ae jz" href="https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html" rel="noopener ugc nofollow" target="_blank">变量扩展</a>时使用不同外壳变量的值，并将变量导出到外部命令。当我们在本系列后面讨论<a class="ae jz" href="https://www.gnu.org/software/bash/manual/html_node/Positional-Parameters.html" rel="noopener ugc nofollow" target="_blank">位置</a>和<a class="ae jz" href="https://www.gnu.org/software/bash/manual/html_node/Special-Parameters.html" rel="noopener ugc nofollow" target="_blank">特殊外壳参数</a>时，符号表也会变得很方便。</p><p id="e62e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每当您要求 shell<strong class="kc io">回显</strong>、<strong class="kc io">导出</strong>或<strong class="kc io">取消设置</strong>shell 变量的值时，您实际上是要求 shell 访问和/或修改其符号表。所有 shell 都有某种符号表实现，尽管有些 shell 可能有不同的名称。</p><p id="85e2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，假设您调用了以下命令:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="aa0d" class="mk kz in mg b gy ml mm l mn mo">echo $PATH</span></pre><p id="c6e1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这应该会产生类似如下的输出:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="b2c2" class="mk kz in mg b gy ml mm l mn mo">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span></pre><p id="db51" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可能知道<code class="fe mp mq mr mg b">echo</code>命令与您在屏幕上看到的输出没有任何关系，除了<code class="fe mp mq mr mg b">echo</code>打印出路径这一事实。是外壳真正理解了<code class="fe mp mq mr mg b">$PATH</code>代表一个外壳变量名。也是<em class="ms">外壳</em>用实际路径值替换了单词<code class="fe mp mq mr mg b">$PATH</code>，然后传递给<code class="fe mp mq mr mg b">echo</code>。<code class="fe mp mq mr mg b">echo</code>命令只是简单地回显了 shell 传递给它的参数，这是您在屏幕上看到的可执行路径。</p><p id="c8cd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，为了能够定义、修改、取消设置和导出 shell 变量，我们首先需要实现我们的符号表。让我们看看下一步该怎么做。</p><h1 id="ad17" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">实现符号表</h1><p id="f3de" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">实现符号表有不同的方式，常见的有<a class="ae jz" href="https://en.wikipedia.org/wiki/Linked_list" rel="noopener ugc nofollow" target="_blank">链表</a>、<a class="ae jz" href="https://en.wikipedia.org/wiki/Hash_table" rel="noopener ugc nofollow" target="_blank">哈希表</a>和<a class="ae jz" href="https://en.wikipedia.org/wiki/Binary_search_tree" rel="noopener ugc nofollow" target="_blank">二分搜索法树</a>。每种方法都有利弊，我们没有时间也没有空间来详细讨论每一种方法。出于我们的目的，我们将使用<strong class="kc io">链表</strong>，这是最容易实现的，并且在访问速度和内存使用方面也相当不错。(<strong class="kc io">注:</strong>如果你想把 shell 用于<em class="ms">除了学习之外的任何事情</em>，你应该考虑把符号表实现改成使用哈希表或者二叉树的。你可以在这里找到哈希表实现<a class="ae jz" href="https://github.com/moisam/Layla-Shell/tree/master/src/symtab" rel="noopener ugc nofollow" target="_blank">的例子。</a></p><p id="0658" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在让我们开始破解代码。在您的源目录中，创建一个名为<code class="fe mp mq mr mg b"><em class="ms">symtab</em></code>的子目录(从您的终端模拟器调用<code class="fe mp mq mr mg b"><strong class="kc io">mkdir symtab</strong></code>)。导航到那个目录(<code class="fe mp mq mr mg b"><strong class="kc io">cd symtab</strong></code>)并创建一个名为<code class="fe mp mq mr mg b"><strong class="kc io">symtab.h</strong></code>的文件。将以下代码添加到刚刚创建的头文件中:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="ceb7" class="mk kz in mg b gy ml mm l mn mo"><em class="ms">#ifndef SYMTAB_H<br/>#define SYMTAB_H</em></span><span id="3305" class="mk kz in mg b gy mt mm l mn mo"><em class="ms">#include "../node.h"</em></span><span id="763a" class="mk kz in mg b gy mt mm l mn mo"><em class="ms">#define MAX_SYMTAB	256</em></span><span id="4f0d" class="mk kz in mg b gy mt mm l mn mo">/* the type of a symbol table entry's value */<br/>enum <strong class="mg io">symbol_type_e</strong><br/>{<br/>    SYM_STR ,<br/>    SYM_FUNC,<br/>};</span><span id="dff4" class="mk kz in mg b gy mt mm l mn mo">/* the symbol table entry structure */<br/>struct <strong class="mg io">symtab_entry_s</strong><br/>{<br/>    char     *<strong class="mg io">name</strong>;<br/>    enum      symbol_type_e <strong class="mg io">val_type</strong>;<br/>    char     *<strong class="mg io">val</strong>;<br/>    unsigned  int <strong class="mg io">flags</strong>;<br/>    struct    symtab_entry_s *<strong class="mg io">next</strong>;<br/>    struct    node_s *<strong class="mg io">func_body</strong>;<br/>};</span><span id="249f" class="mk kz in mg b gy mt mm l mn mo">/* the symbol table structure */<br/>struct <strong class="mg io">symtab_s</strong><br/>{<br/>    int    <strong class="mg io">level</strong>;<br/>    struct symtab_entry_s *<strong class="mg io">first</strong>, *<strong class="mg io">last</strong>;<br/>};</span><span id="3f00" class="mk kz in mg b gy mt mm l mn mo">/* values for the flags field of struct symtab_entry_s */                       <br/><em class="ms">#define FLAG_EXPORT (1 &lt;&lt; 0) /* export entry to forked commands */</em></span><span id="ad6a" class="mk kz in mg b gy mt mm l mn mo">/* the symbol table stack structure */<br/>struct <strong class="mg io">symtab_stack_s</strong><br/>{<br/>    int    <strong class="mg io">symtab_count</strong>;<br/>    struct symtab_s *<strong class="mg io">symtab_list</strong>[MAX_SYMTAB];<br/>    struct symtab_s *<strong class="mg io">global_symtab</strong>, *<strong class="mg io">local_symtab</strong>;<br/>};<br/></span><span id="fbec" class="mk kz in mg b gy mt mm l mn mo">struct symtab_s       *<strong class="mg io">new_symtab</strong>(int level);<br/>struct symtab_s       *<strong class="mg io">symtab_stack_push</strong>(void);<br/>struct symtab_s       *<strong class="mg io">symtab_stack_pop</strong>(void);<br/>int <strong class="mg io">rem_from_symtab</strong>(struct symtab_entry_s *entry, struct symtab_s *symtab);<br/>struct symtab_entry_s *<strong class="mg io">add_to_symtab</strong>(char *symbol);<br/>struct symtab_entry_s *<strong class="mg io">do_lookup</strong>(char *str, struct symtab_s *symtable);<br/>struct symtab_entry_s *<strong class="mg io">get_symtab_entry</strong>(char *str);<br/>struct symtab_s       *<strong class="mg io">get_local_symtab</strong>(void);<br/>struct symtab_s       *<strong class="mg io">get_global_symtab</strong>(void);<br/>struct symtab_stack_s *<strong class="mg io">get_symtab_stack</strong>(void);<br/>void <strong class="mg io">init_symtab</strong>(void);<br/>void <strong class="mg io">dump_local_symtab</strong>(void);<br/>void <strong class="mg io">free_symtab</strong>(struct symtab_s *symtab);<br/>void <strong class="mg io">symtab_entry_setval</strong>(struct symtab_entry_s *entry, char *val);<!-- --> </span><span id="7389" class="mk kz in mg b gy mt mm l mn mo"><em class="ms">#endif</em></span></pre><p id="37ec" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mp mq mr mg b"><strong class="kc io">symbol_type_e</strong></code>枚举定义了我们的符号表条目的类型。我们将使用类型<code class="fe mp mq mr mg b"><strong class="kc io">SYM_STR</strong></code>来表示 shell 变量，使用<code class="fe mp mq mr mg b"><strong class="kc io">SYM_FUNC</strong></code>来表示函数(我们将在本系列的后面处理 shell 函数)。</p><p id="703a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mp mq mr mg b"><strong class="kc io">struct symtab_entry_s</strong></code>结构代表我们的符号表条目。该结构包含以下字段:</p><ul class=""><li id="224f" class="mu mv in kc b kd ke kh ki kl mw kp mx kt my kx mz na nb nc bi translated"><code class="fe mp mq mr mg b">name</code> = &gt;此条目代表的外壳变量(或函数)的名称。</li><li id="15f3" class="mu mv in kc b kd nd kh ne kl nf kp ng kt nh kx mz na nb nc bi translated"><code class="fe mp mq mr mg b">val_type</code> = &gt; <code class="fe mp mq mr mg b">SYM_STR</code>为外壳变量，<code class="fe mp mq mr mg b">SYM_FUNC</code>为外壳函数。</li><li id="cd1b" class="mu mv in kc b kd nd kh ne kl nf kp ng kt nh kx mz na nb nc bi translated"><code class="fe mp mq mr mg b">val</code> = &gt;字符串值(仅适用于 shell 变量)。</li><li id="870c" class="mu mv in kc b kd nd kh ne kl nf kp ng kt nh kx mz na nb nc bi translated"><code class="fe mp mq mr mg b">flags</code> = &gt;表示我们将分配给变量和函数的不同属性，比如 export 和 readonly 标志(我们将在本系列的后面处理这些)。</li><li id="1145" class="mu mv in kc b kd nd kh ne kl nf kp ng kt nh kx mz na nb nc bi translated">指向下一个符号表条目的指针(因为我们将该表实现为一个单链表)。</li><li id="180d" class="mu mv in kc b kd nd kh ne kl nf kp ng kt nh kx mz na nb nc bi translated"><code class="fe mp mq mr mg b">func_body</code> = &gt;对于 shell 函数，函数体的<strong class="kc io">抽象语法树</strong>，或<strong class="kc io"> AST </strong>(我们在本教程的<a class="ae jz" href="https://medium.com/dev-genius/lets-build-a-linux-shell-part-i-954c95911501" rel="noopener">第一部分</a>中讨论过 AST)。</li></ul><p id="021d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mp mq mr mg b"><strong class="kc io">struct symtab_s</strong></code>结构代表一个单一的符号表。首先，我们将使用一个符号表，在其中我们将定义所有的 shell 变量。稍后，当我们讨论 shell 函数并开始使用脚本文件时，我们将需要定义更多的符号表。第零个符号表将是<strong class="kc io">全局表</strong>，我们将在其中定义我们的<strong class="kc io">全局</strong>变量(shell 可访问的变量，以及它执行的所有函数和脚本)。第一个及以上的符号表是<strong class="kc io">局部表</strong>，我们将在其中定义我们的<strong class="kc io">局部变量</strong>(这些变量只能被声明它们的 shell 函数或脚本访问)。通过以这种方式级联符号表，我们有效地实现了<a class="ae jz" href="https://en.wikipedia.org/wiki/Scope_(computer_science)" rel="noopener ugc nofollow" target="_blank">变量范围</a>。</p><p id="6247" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的<code class="fe mp mq mr mg b"><strong class="kc io">struct symtab_s</strong></code>结构包含以下字段:</p><ul class=""><li id="aa5a" class="mu mv in kc b kd ke kh ki kl mw kp mx kt my kx mz na nb nc bi translated"><code class="fe mp mq mr mg b">level</code> = &gt; 0 为全局符号表，1 及以上为局部符号表。</li><li id="f259" class="mu mv in kc b kd nd kh ne kl nf kp ng kt nh kx mz na nb nc bi translated"><code class="fe mp mq mr mg b">first</code>、<code class="fe mp mq mr mg b">last</code> = &gt;分别指向表格链表中第一个和最后一个条目的指针。</li></ul><p id="cb99" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，为了能够像我们上面讨论的那样级联符号表，我们需要定义并实现一个符号表栈<a class="ae jz" href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)" rel="noopener ugc nofollow" target="_blank"/>。<strong class="kc io">堆栈</strong>是一种<strong class="kc io">后进先出</strong>或<strong class="kc io"> LIFO </strong>的数据结构，其中最后添加(或<strong class="kc io">推入</strong>)的项目是第一个移除(或<strong class="kc io">弹出</strong>)的项目。结构代表了我们的符号表堆栈。该结构包含以下字段:</p><ul class=""><li id="c6be" class="mu mv in kc b kd ke kh ki kl mw kp mx kt my kx mz na nb nc bi translated"><code class="fe mp mq mr mg b">symtab_count</code> = &gt;当前堆栈中符号表的数量。</li><li id="2193" class="mu mv in kc b kd nd kh ne kl nf kp ng kt nh kx mz na nb nc bi translated">指向堆栈符号表的指针数组。第 0 项指向全局符号表，<code class="fe mp mq mr mg b">symtab_count-1</code>项指向最后一个(或局部)符号表。堆栈最多可以容纳<code class="fe mp mq mr mg b">MAX_SYMTAB</code>条目，我们在头文件的开头定义为 256 个。</li><li id="5051" class="mu mv in kc b kd nd kh ne kl nf kp ng kt nh kx mz na nb nc bi translated"><code class="fe mp mq mr mg b">global_symtab</code>、<code class="fe mp mq mr mg b">local_symtab</code> = &gt;分别指向全局和局部符号表的指针(便于访问)。</li></ul><p id="0651" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将在本课稍后实现堆栈。现在，我们将从编写使用符号表所需的函数开始。</p><h1 id="a89f" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">符号表功能</h1><p id="0437" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">创建<code class="fe mp mq mr mg b"><strong class="kc io">symtab.c</strong></code>文件(在<code class="fe mp mq mr mg b"><em class="ms">symtab</em></code>子目录中),并通过添加以下代码开始:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="0ddf" class="mk kz in mg b gy ml mm l mn mo"><em class="ms">#include &lt;stdlib.h&gt;<br/>#include &lt;stdio.h&gt;<br/>#include &lt;string.h&gt;<br/>#include "../shell.h"<br/>#include "../node.h"<br/>#include "../parser.h"<br/>#include "symtab.h"<br/></em></span><span id="034b" class="mk kz in mg b gy mt mm l mn mo">struct symtab_stack_s <strong class="mg io">symtab_stack</strong>;<br/>int    <strong class="mg io">symtab_level</strong>;<br/></span><span id="1b38" class="mk kz in mg b gy mt mm l mn mo">void <strong class="mg io">init_symtab</strong>(void)<br/>{<br/>    symtab_stack.symtab_count = 1;<br/>    symtab_level = 0;</span><span id="beeb" class="mk kz in mg b gy mt mm l mn mo">    struct symtab_s *<strong class="mg io">global_symtab</strong> = malloc(sizeof(struct symtab_s));</span><span id="5125" class="mk kz in mg b gy mt mm l mn mo">    if(!global_symtab)<br/>    {<br/>        fprintf(stderr, "fatal error: no memory for global symbol table\n");<br/>        exit(EXIT_FAILURE);<br/>    }</span><span id="3335" class="mk kz in mg b gy mt mm l mn mo">    memset(global_symtab, 0, sizeof(struct symtab_s));<br/>    symtab_stack.global_symtab  = global_symtab;<br/>    symtab_stack.local_symtab   = global_symtab;<br/>    symtab_stack.symtab_list[0] = global_symtab;<br/>    global_symtab-&gt;level        = 0;<br/>}</span></pre><p id="fc0b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我们有两个全局变量:</p><ul class=""><li id="0460" class="mu mv in kc b kd ke kh ki kl mw kp mx kt my kx mz na nb nc bi translated">指向符号表堆栈的指针(我们每个 shell 只需要一个堆栈)。</li><li id="1518" class="mu mv in kc b kd nd kh ne kl nf kp ng kt nh kx mz na nb nc bi translated"><code class="fe mp mq mr mg b">symtab_level</code> = &gt;堆栈中的当前级别(如果我们正在使用全局符号表，则为 0，否则为非零)。</li></ul><p id="75f5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">函数初始化我们的符号表堆栈，然后为我们的全局符号表分配内存并初始化。</p><p id="4f7d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，添加以下函数:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="148d" class="mk kz in mg b gy ml mm l mn mo">struct symtab_s *<strong class="mg io">new_symtab</strong>(int <strong class="mg io">level</strong>)<br/>{<br/>    struct symtab_s *<strong class="mg io">symtab</strong> = malloc(sizeof(struct symtab_s));</span><span id="9fbd" class="mk kz in mg b gy mt mm l mn mo">    if(!symtab)<br/>    {<br/>        fprintf(stderr, "fatal error: no memory for new symbol table\n");<br/>        exit(EXIT_FAILURE);<br/>    }</span><span id="1efd" class="mk kz in mg b gy mt mm l mn mo">    memset(symtab, 0, sizeof(struct symtab_s));<br/>    symtab-&gt;level = level;<br/>    return symtab;<br/>}</span></pre><p id="9bbf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每当我们想要创建一个新的符号表时(例如，当我们要执行一个 shell 函数时)，我们将调用<code class="fe mp mq mr mg b"><strong class="kc io">new_symtab()</strong></code>函数。</p><p id="5dd5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，添加以下函数:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="567b" class="mk kz in mg b gy ml mm l mn mo">void <strong class="mg io">free_symtab</strong>(struct symtab_s *<strong class="mg io">symtab</strong>)<br/>{<br/>    if(symtab == NULL)<br/>    {<br/>        return;<br/>    }</span><span id="4b0a" class="mk kz in mg b gy mt mm l mn mo">    struct symtab_entry_s *<strong class="mg io">entry</strong> = symtab-&gt;first;</span><span id="500b" class="mk kz in mg b gy mt mm l mn mo">    while(entry)<br/>    {<br/>        if(entry-&gt;name)<br/>        {<br/>            free(entry-&gt;name);<br/>        }</span><span id="e127" class="mk kz in mg b gy mt mm l mn mo">        if(entry-&gt;val)<br/>        {<br/>            free(entry-&gt;val);<br/>        }</span><span id="ee18" class="mk kz in mg b gy mt mm l mn mo">        if(entry-&gt;func_body)<br/>        {<br/>            free_node_tree(entry-&gt;func_body);<br/>        }</span><span id="9128" class="mk kz in mg b gy mt mm l mn mo">        struct symtab_entry_s *next = entry-&gt;next;<br/>        free(entry);<br/>        entry = next;<br/>    }</span><span id="3b69" class="mk kz in mg b gy mt mm l mn mo">    free(symtab);<br/>}</span></pre><p id="4547" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们处理完一个符号表时，我们将调用<code class="fe mp mq mr mg b"><strong class="kc io">free_symtab()</strong></code>函数，我们希望释放符号表及其条目所使用的内存。</p><p id="fdd6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，我们将定义一个调试函数:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="914b" class="mk kz in mg b gy ml mm l mn mo">void <strong class="mg io">dump_local_symtab</strong>(void)<br/>{<br/>    struct symtab_s *<strong class="mg io">symtab</strong> = symtab_stack.local_symtab;<br/>    int <strong class="mg io">i</strong> = 0;<br/>    int <strong class="mg io">indent</strong> = symtab-&gt;level * 4;</span><span id="58d1" class="mk kz in mg b gy mt mm l mn mo">    fprintf(stderr, "%*sSymbol table [Level %d]:\r\n", indent, " ", symtab-&gt;level);<br/>    fprintf(stderr, "%*s===========================\r\n", indent, " ");<br/>    fprintf(stderr, "%*s  No               Symbol                    Val\r\n", indent, " ");<br/>    fprintf(stderr, "%*s------ -------------------------------- ------------\r\n", indent, " ");</span><span id="2fec" class="mk kz in mg b gy mt mm l mn mo">    struct symtab_entry_s *<strong class="mg io">entry</strong> = symtab-&gt;first;</span><span id="c3cf" class="mk kz in mg b gy mt mm l mn mo">    while(entry)<br/>    {<br/>        fprintf(stderr, "%*s[%04d] %-32s '%s'\r\n", indent, " ",<br/>                i++, entry-&gt;name, entry-&gt;val);<br/>        entry = entry-&gt;next;<br/>    }</span><span id="0d32" class="mk kz in mg b gy mt mm l mn mo">    fprintf(stderr, "%*s------ -------------------------------- ------------\r\n", indent, " ");<br/>}</span></pre><p id="5f4d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个函数打印本地符号表的内容。当我们的 shell 启动时，局部和全局符号表将引用同一个表。只有当 shell 将要运行一个 shell 函数或脚本文件时，我们才有一个不同于全局表的本地表。(在本课的后面，我们将编写一个内置的实用程序，它将调用<code class="fe mp mq mr mg b"><strong class="kc io">dump_local_symtab()</strong></code>来帮助我们可视化 shell 的全局符号表的内容)。</p><p id="dc87" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在让我们定义一些函数来帮助我们处理符号表条目。在同一个文件(<code class="fe mp mq mr mg b"><strong class="kc io">symtab.c</strong></code>)中，添加以下函数:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="0346" class="mk kz in mg b gy ml mm l mn mo">struct symtab_entry_s *<strong class="mg io">add_to_symtab</strong>(char *<strong class="mg io">symbol</strong>)<br/>{<br/>    if(!symbol || symbol[0] == '\0')<br/>    {<br/>        return NULL;<br/>    }</span><span id="94ce" class="mk kz in mg b gy mt mm l mn mo">    struct symtab_s *<strong class="mg io">st</strong> = symtab_stack.local_symtab;<br/>    struct symtab_entry_s *<strong class="mg io">entry</strong> = NULL;</span><span id="3c88" class="mk kz in mg b gy mt mm l mn mo">    if((entry = do_lookup(symbol, st)))<br/>    {<br/>        return entry;<br/>    }</span><span id="2361" class="mk kz in mg b gy mt mm l mn mo">    entry = malloc(sizeof(struct symtab_entry_s));</span><span id="f4d1" class="mk kz in mg b gy mt mm l mn mo">    if(!entry)<br/>    {<br/>        fprintf(stderr, "fatal error: no memory for new symbol table entry\n");<br/>        exit(EXIT_FAILURE);<br/>    }</span><span id="7353" class="mk kz in mg b gy mt mm l mn mo">    memset(entry, 0, sizeof(struct symtab_entry_s));<br/>    entry-&gt;name = malloc(strlen(symbol)+1);</span><span id="78e1" class="mk kz in mg b gy mt mm l mn mo">    if(!entry-&gt;name)<br/>    {<br/>        fprintf(stderr, "fatal error: no memory for new symbol table entry\n");<br/>        exit(EXIT_FAILURE);<br/>    }</span><span id="cb2e" class="mk kz in mg b gy mt mm l mn mo">    strcpy(entry-&gt;name, symbol);</span><span id="9b2e" class="mk kz in mg b gy mt mm l mn mo">    if(!st-&gt;first)<br/>    {<br/>        st-&gt;first      = entry;<br/>        st-&gt;last       = entry;<br/>    }<br/>    else<br/>    {<br/>        st-&gt;last-&gt;next = entry;<br/>        st-&gt;last       = entry;<br/>    }</span><span id="aad8" class="mk kz in mg b gy mt mm l mn mo">    return entry;<br/>}</span></pre><p id="b0ac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此函数向局部符号表添加一个新条目。请记住，在本课开始时，我说过每个条目必须有一个唯一的键，这是我们给 shell 变量或函数的名称。为了确保这种唯一性，我们首先通过调用<code class="fe mp mq mr mg b"><strong class="kc io">do_lookup()</strong></code>(我们将在一分钟内定义它)来检查给定名称的条目是否存在。如果具有给定名称的条目存在，我们只是返回现有的条目，而不添加新的条目。否则，我们添加条目，设置其名称，并调整符号表的指针。最后，我们返回新添加的条目。</p><p id="bf7b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下一个函数执行相反的工作，即删除其关键字与给定名称匹配的符号表条目:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="ca5a" class="mk kz in mg b gy ml mm l mn mo">int <strong class="mg io">rem_from_symtab</strong>(struct symtab_entry_s *<strong class="mg io">entry</strong>, struct symtab_s *<strong class="mg io">symtab</strong>)<br/>{<br/>    int<strong class="mg io"> res</strong> = 0;<br/>    if(entry-&gt;val)<br/>    {<br/>        free(entry-&gt;val);<br/>    }</span><span id="97b1" class="mk kz in mg b gy mt mm l mn mo">    if(entry-&gt;func_body)<br/>    {<br/>        free_node_tree(entry-&gt;func_body);<br/>    }</span><span id="f6a2" class="mk kz in mg b gy mt mm l mn mo">    free(entry-&gt;name);</span><span id="d7bc" class="mk kz in mg b gy mt mm l mn mo">    if(symtab-&gt;first == entry)<br/>    {<br/>        symtab-&gt;first = symtab-&gt;first-&gt;next;</span><span id="5e27" class="mk kz in mg b gy mt mm l mn mo">        if(symtab-&gt;last == entry)<br/>        {<br/>            symtab-&gt;last = NULL;<br/>        }<br/>        res = 1;<br/>    }<br/>    else<br/>    {<br/>        struct symtab_entry_s *<strong class="mg io">e</strong> = symtab-&gt;first;<br/>        struct symtab_entry_s *<strong class="mg io">p</strong> = NULL;</span><span id="e151" class="mk kz in mg b gy mt mm l mn mo">        while(e &amp;&amp; e != entry)<br/>        {<br/>            p = e;<br/>            e = e-&gt;next;<br/>        }</span><span id="02e1" class="mk kz in mg b gy mt mm l mn mo">        if(e == entry)<br/>        {<br/>            p-&gt;next = entry-&gt;next;<br/>            res = 1;<br/>        }<br/>    }</span><span id="9e91" class="mk kz in mg b gy mt mm l mn mo">    free(entry);<br/>    return res;<br/>}</span></pre><p id="1a00" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个函数释放条目使用的内存，并调整链表指针，从符号表中删除条目。</p><p id="b059" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要执行查找(即搜索具有给定名称的变量)，我们需要在同一个文件中定义以下函数:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="b977" class="mk kz in mg b gy ml mm l mn mo">struct symtab_entry_s *<strong class="mg io">do_lookup</strong>(char *<strong class="mg io">str</strong>, struct symtab_s *<strong class="mg io">symtable</strong>)<br/>{<br/>    if(!str || !symtable)<br/>    {<br/>        return NULL;<br/>    }</span><span id="da8d" class="mk kz in mg b gy mt mm l mn mo">    struct symtab_entry_s *<strong class="mg io">entry</strong> = symtable-&gt;first;</span><span id="b9ce" class="mk kz in mg b gy mt mm l mn mo">    while(entry)<br/>    {<br/>        if(strcmp(entry-&gt;name, str) == 0)<br/>        {<br/>            return entry;<br/>        }<br/>        entry = entry-&gt;next;<br/>    }</span><span id="e192" class="mk kz in mg b gy mt mm l mn mo">    return NULL;<br/>}</span></pre><p id="9c67" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个函数从第一个条目开始搜索给定的符号表。如果条目的键与我们正在寻找的变量名相匹配，函数将返回条目。否则，该函数会跟随链表指针依次查看每个条目，直到找到一个条目，它的键与我们想要的名称相匹配。如果没有找到匹配，我们返回<code class="fe mp mq mr mg b">NULL</code>。</p><p id="18d9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，添加以下函数:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="d42f" class="mk kz in mg b gy ml mm l mn mo">struct symtab_entry_s *<strong class="mg io">get_symtab_entry</strong>(char *<strong class="mg io">str</strong>)<br/>{<br/>    int <strong class="mg io">i</strong> = symtab_stack.symtab_count-1;</span><span id="e8e4" class="mk kz in mg b gy mt mm l mn mo">    do<br/>    {<br/>        struct symtab_s *<strong class="mg io">symtab</strong> = symtab_stack.symtab_list[i];<br/>        struct symtab_entry_s *<strong class="mg io">entry</strong> = do_lookup(str, symtab);</span><span id="4a41" class="mk kz in mg b gy mt mm l mn mo">        if(entry)<br/>        {<br/>            return entry;<br/>        }</span><span id="1852" class="mk kz in mg b gy mt mm l mn mo">    } while(--i &gt;= 0);</span><span id="6a2b" class="mk kz in mg b gy mt mm l mn mo">    return NULL;<br/>}</span></pre><p id="6721" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此函数搜索其关键字与给定名称匹配的符号表条目。起初这似乎是多余的，因为我们已经定义了<code class="fe mp mq mr mg b"><strong class="kc io">do_lookup()</strong></code>函数来搜索本地符号表。这里的区别是<code class="fe mp mq mr mg b"><strong class="kc io">get_symtab_entry()</strong></code>从局部符号表开始搜索整个栈。目前，这种区别并不重要，因为我们的局部和全局符号表指的是同一个表。只有当我们讨论 shell 函数和脚本文件时，您才能体会到这个函数的作用(所以请坚持住！).</p><p id="0323" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，添加以下函数:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="18f4" class="mk kz in mg b gy ml mm l mn mo">void <strong class="mg io">symtab_entry_setval</strong>(struct symtab_entry_s *<strong class="mg io">entry</strong>, char *<strong class="mg io">val</strong>)<br/>{<br/>    if(entry-&gt;val)<br/>    {<br/>        free(entry-&gt;val);<br/>    }</span><span id="b279" class="mk kz in mg b gy mt mm l mn mo">    if(!val)<br/>    {<br/>        entry-&gt;val = NULL;<br/>    }<br/>    else<br/>    {<br/>        char *<strong class="mg io">val2</strong> = malloc(strlen(val)+1);</span><span id="82a3" class="mk kz in mg b gy mt mm l mn mo">        if(val2)<br/>        {<br/>            strcpy(val2, val);<br/>        }<br/>        else<br/>        {<br/>            fprintf(stderr, "error: no memory for symbol table entry's value\n");<br/>        }</span><span id="afe4" class="mk kz in mg b gy mt mm l mn mo">        entry-&gt;val = val2;<br/>    }<br/>}</span></pre><p id="47f1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该函数释放用于存储旧条目值的内存(如果有)。然后，它创建新值的副本，并将其存储在符号表条目中。</p><p id="b620" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就是符号表函数。现在让我们写一些函数来帮助我们使用符号表堆栈。</p><h1 id="a299" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">符号表堆栈功能</h1><p id="e782" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">将以下代码添加到同一个源文件<code class="fe mp mq mr mg b"><strong class="kc io">symtab.c</strong></code>:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="39cc" class="mk kz in mg b gy ml mm l mn mo">void <strong class="mg io">symtab_stack_add</strong>(struct symtab_s *<strong class="mg io">symtab</strong>)<br/>{<br/>    symtab_stack.symtab_list[symtab_stack.symtab_count++] = symtab;<br/>    symtab_stack.local_symtab = symtab;<br/>}<br/></span><span id="3d1b" class="mk kz in mg b gy mt mm l mn mo">struct symtab_s *<strong class="mg io">symtab_stack_push</strong>(void)<br/>{<br/>    struct symtab_s *<strong class="mg io">st</strong> = new_symtab(++symtab_level);<br/>    symtab_stack_add(st);<br/>    return st;<br/>}<br/></span><span id="1d8e" class="mk kz in mg b gy mt mm l mn mo">struct symtab_s *<strong class="mg io">symtab_stack_pop</strong>(void)<br/>{<br/>    if(symtab_stack.symtab_count == 0)<br/>    {<br/>        return NULL;<br/>    }</span><span id="ca4d" class="mk kz in mg b gy mt mm l mn mo">    struct symtab_s *<strong class="mg io">st</strong> = symtab_stack.symtab_list[symtab_stack.symtab_count-1];</span><span id="6d86" class="mk kz in mg b gy mt mm l mn mo">    symtab_stack.symtab_list[--symtab_stack.symtab_count] = NULL;<br/>    symtab_level--;</span><span id="c359" class="mk kz in mg b gy mt mm l mn mo">    if(symtab_stack.symtab_count == 0)<br/>    {<br/>        symtab_stack.local_symtab  = NULL;<br/>        symtab_stack.global_symtab = NULL;<br/>    }<br/>    else<br/>    {<br/>        symtab_stack.local_symtab = symtab_stack.symtab_list[symtab_stack.symtab_count-1];<br/>    }</span><span id="adb0" class="mk kz in mg b gy mt mm l mn mo">    return st;<br/>}<br/></span><span id="ba14" class="mk kz in mg b gy mt mm l mn mo">struct symtab_s *<strong class="mg io">get_local_symtab</strong>(void)<br/>{<br/>    return symtab_stack.local_symtab;<br/>}<br/></span><span id="2af3" class="mk kz in mg b gy mt mm l mn mo">struct symtab_s *<strong class="mg io">get_global_symtab</strong>(void)<br/>{<br/>    return symtab_stack.global_symtab;<br/>}<br/></span><span id="2113" class="mk kz in mg b gy mt mm l mn mo">struct symtab_stack_s *<strong class="mg io">get_symtab_stack</strong>(void)<br/>{<br/>    return &amp;symtab_stack;<br/>}</span></pre><p id="bb0e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以下是上述功能的快速分类:</p><ul class=""><li id="9e93" class="mu mv in kc b kd ke kh ki kl mw kp mx kt my kx mz na nb nc bi translated"><code class="fe mp mq mr mg b">symtab_stack_add()</code>将给定的符号表添加到堆栈中，并将新添加的表指定为本地符号表。</li><li id="16a4" class="mu mv in kc b kd nd kh ne kl nf kp ng kt nh kx mz na nb nc bi translated">创建一个新的空符号表，并将其放入堆栈顶部。</li><li id="140c" class="mu mv in kc b kd nd kh ne kl nf kp ng kt nh kx mz na nb nc bi translated"><code class="fe mp mq mr mg b">symtab_stack_pop()</code>移除(或弹出)堆栈顶部的符号表，根据需要调整堆栈指针。</li><li id="da18" class="mu mv in kc b kd nd kh ne kl nf kp ng kt nh kx mz na nb nc bi translated"><code class="fe mp mq mr mg b">get_local_symtab()</code>和<code class="fe mp mq mr mg b">get_global_symtab()</code>分别返回指向局部和全局符号表的指针。</li><li id="a569" class="mu mv in kc b kd nd kh ne kl nf kp ng kt nh kx mz na nb nc bi translated"><code class="fe mp mq mr mg b">get_symtab_stack()</code>返回一个指向符号表堆栈的指针。</li></ul><h1 id="5c67" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">初始化我们的符号表堆栈</h1><p id="5746" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">还记得在本教程开始时我告诉过你，shell 需要初始化它的全局符号表，并将环境列表中的变量添加到该表中吗？在这一部分，我们将初始化符号表堆栈和全局符号表。在本系列的下一部分，我们将读取环境变量列表并将它们添加到符号表中。</p><p id="2867" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">继续在您的源目录中创建一个名为<code class="fe mp mq mr mg b">initsh.c</code>的源文件，并添加以下代码:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="29af" class="mk kz in mg b gy ml mm l mn mo"><em class="ms">#include &lt;string.h&gt;<br/></em><em class="ms">#include "shell.h"<br/>#include "symtab/symtab.h"</em></span><span id="1aed" class="mk kz in mg b gy mt mm l mn mo">extern char **<strong class="mg io">environ</strong>;</span><span id="370b" class="mk kz in mg b gy mt mm l mn mo">void <strong class="mg io">initsh</strong>(void)<br/>{<br/>    init_symtab();</span><span id="dc96" class="mk kz in mg b gy mt mm l mn mo">    struct symtab_entry_s *<strong class="mg io">entry</strong>;<br/>    char **<strong class="mg io">p2</strong> = environ;</span><span id="f753" class="mk kz in mg b gy mt mm l mn mo">    while(*p2)<br/>    {<br/>        char *<strong class="mg io">eq</strong> = strchr(*p2, '=');<br/>        if(eq)<br/>        {<br/>            int <strong class="mg io">len</strong> = eq-(*p2);<br/>            char <strong class="mg io">name</strong>[len+1];</span><span id="670d" class="mk kz in mg b gy mt mm l mn mo">            strncpy(name, *p2, len);<br/>            name[len] = '\0';<br/>            entry = add_to_symtab(name);</span><span id="0a06" class="mk kz in mg b gy mt mm l mn mo">            if(entry)<br/>            {<br/>                symtab_entry_setval(entry, eq+1);<br/>                entry-&gt;flags |= <em class="ms">FLAG_EXPORT</em>;<br/>            }<br/>        }<br/>        else<br/>        {<br/>            entry = add_to_symtab(*p2);<br/>        }<br/>        p2++;<br/>    }</span><span id="76f0" class="mk kz in mg b gy mt mm l mn mo">    entry = add_to_symtab("PS1");<br/>    symtab_entry_setval(entry, "$ ");</span><span id="5eb3" class="mk kz in mg b gy mt mm l mn mo">    entry = add_to_symtab("PS2");<br/>    symtab_entry_setval(entry, "&gt; ");<br/>}</span></pre><p id="30cc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此函数初始化符号表堆栈(包括全局符号表)并扫描环境列表，将每个环境变量(及其值)添加到表中。最后，该函数添加了两个变量，我们将使用它们来存储我们的提示字符串，<strong class="kc io"> PS1 </strong>和<strong class="kc io"> PS2 </strong>(我们在<a class="ae jz" href="https://medium.com/dev-genius/lets-build-a-linux-shell-part-i-954c95911501" rel="noopener">第一部分</a>中讨论过提示字符串)。不要忘记将函数原型添加到您的<code class="fe mp mq mr mg b"><strong class="kc io">shell.h</strong></code>头文件中:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="8e55" class="mk kz in mg b gy ml mm l mn mo">void <strong class="mg io">initsh</strong>(void);</span></pre><p id="9f99" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，在进入 REPL 循环之前，我们需要从我们的<code class="fe mp mq mr mg b"><strong class="kc io">main()</strong></code>函数中调用这个函数。为此，将下面一行添加到<code class="fe mp mq mr mg b"><strong class="kc io">main()</strong></code>，就在循环体之前:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="cbf9" class="mk kz in mg b gy ml mm l mn mo">initsh();</span></pre><p id="8169" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们需要做的最后一件事是更新我们的提示字符串打印函数，这样它们将使用我们刚刚添加到<code class="fe mp mq mr mg b"><strong class="kc io">initsh()</strong></code>的全局符号表中的<strong class="kc io"> PS1 </strong>和<strong class="kc io"> PS2 </strong>变量。我们还将编写我们的第一个内置实用程序<code class="fe mp mq mr mg b"><strong class="kc io">dump</strong></code>。</p><p id="f862" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来让我们将这些更改应用到我们的代码中。</p><h1 id="d0f3" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">更新提示打印功能</h1><p id="9ba3" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">打开你的<code class="fe mp mq mr mg b"><strong class="kc io">prompt.c</strong></code>文件。移除<code class="fe mp mq mr mg b"><strong class="kc io">print_prompt1()</strong></code>主体中的线路，并替换为以下代码:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="ffba" class="mk kz in mg b gy ml mm l mn mo">void <strong class="mg io">print_prompt1</strong>(void)<br/>{   <br/>    struct symtab_entry_s *<strong class="mg io">entry</strong> = get_symtab_entry("PS1");</span><span id="829e" class="mk kz in mg b gy mt mm l mn mo">    if(entry &amp;&amp; entry-&gt;val)<br/>    {<br/>        fprintf(stderr, "%s", entry-&gt;val);<br/>    }<br/>    else<br/>    {<br/>        fprintf(stderr, "$ ");<br/>    }<br/>}</span></pre><p id="b09b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">新代码检查是否存在名为<strong class="kc io"> PS1 </strong>的符号表条目。如果有，我们使用该项的值来打印第一个提示字符串。否则，我们使用默认的内置值，即<code class="fe mp mq mr mg b">$ </code>。</p><p id="0d24" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对<code class="fe mp mq mr mg b"><strong class="kc io">print_prompt2()</strong></code>函数的代码改动也差不多，这里就不展示了，不过你可以去我在本页顶部提供的 GitHub repo 链接查看。</p><p id="de09" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不要忘记在文件的顶部添加下面的 include 指令，就在<code class="fe mp mq mr mg b"><em class="ms">#include "shell.h"</em></code>行之后:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="cab3" class="mk kz in mg b gy ml mm l mn mo"><em class="ms">#include "symtab/symtab.h"</em></span></pre><h1 id="4781" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">定义我们的第一个内置实用程序</h1><p id="7a8d" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated"><a class="ae jz" href="https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io">内建实用程序</strong> </a>(又称为内建或内部命令)是一个命令，其代码被编译为外壳可执行程序本身的一部分，即外壳不需要执行<a class="ae jz" href="http://www.theunixschool.com/2012/03/internal-vs-external-commands.html" rel="noopener ugc nofollow" target="_blank">外部程序</a>，也不需要<a class="ae jz" href="https://en.wikipedia.org/wiki/Fork_(system_call)" rel="noopener ugc nofollow" target="_blank">派生</a>一个新进程来执行该命令。我们日常使用的许多命令，比如<code class="fe mp mq mr mg b">cd</code>、<code class="fe mp mq mr mg b">echo</code>、<code class="fe mp mq mr mg b">export</code>和<code class="fe mp mq mr mg b">readonly</code>，实际上都是内置的实用程序。你可以在 POSIX 标准<a class="ae jz" href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html" rel="noopener ugc nofollow" target="_blank">链接</a>中阅读更多关于 shell 内置工具的内容。</p><p id="91de" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本教程的过程中，我们将添加不同的内置工具来扩展我们的外壳。我们将从定义一个结构开始，这个结构将帮助我们存储关于不同内置实用程序的信息。</p><p id="70d4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">打开您的<code class="fe mp mq mr mg b"><strong class="kc io">shell.h</strong></code>头文件，并在最后添加以下代码，就在<code class="fe mp mq mr mg b">#endif</code>指令之前:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="73a2" class="mk kz in mg b gy ml mm l mn mo">/* shell builtin utilities */<br/>int <strong class="mg io">dump</strong>(int <strong class="mg io">argc</strong>, char **<strong class="mg io">argv</strong>);</span><span id="5f9a" class="mk kz in mg b gy mt mm l mn mo">/* struct for builtin utilities */<br/>struct <strong class="mg io">builtin_s</strong><br/>{<br/>    char *<strong class="mg io">name</strong>;    /* utility name */<br/>    int (*<strong class="mg io">func</strong>)(int <strong class="mg io">argc</strong>, char **<strong class="mg io">argv</strong>); /* function to call to execute the utility */<br/>};</span><span id="3413" class="mk kz in mg b gy mt mm l mn mo">/* the list of builtin utilities */<br/>extern struct builtin_s <strong class="mg io">builtins</strong>[];</span><span id="4b3b" class="mk kz in mg b gy mt mm l mn mo">/* and their count */<br/>extern int <strong class="mg io">builtins_count</strong>;</span></pre><p id="a317" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">函数原型声明了我们的第一个内置实用程序<code class="fe mp mq mr mg b"><strong class="kc io">dump</strong></code>。<code class="fe mp mq mr mg b"><strong class="kc io">struct builtin_s</strong></code>结构定义了我们的内置实用程序，并具有以下字段:</p><ul class=""><li id="ed5b" class="mu mv in kc b kd ke kh ki kl mw kp mx kt my kx mz na nb nc bi translated"><code class="fe mp mq mr mg b">name</code> = &gt;内置的实用程序名，我们将用它来调用该实用程序。</li><li id="5a51" class="mu mv in kc b kd nd kh ne kl nf kp ng kt nh kx mz na nb nc bi translated"><code class="fe mp mq mr mg b">func</code> = &gt;函数指针，指向在我们的 shell 中实现内置实用程序的函数。</li></ul><p id="43e1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将使用<code class="fe mp mq mr mg b"><strong class="kc io">builtins[]</strong></code>数组来存储关于内置实用程序的信息。该数组包含<code class="fe mp mq mr mg b"><strong class="kc io">builtins_count</strong></code>个元素。</p><p id="fa66" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在创建一个新的子目录，命名为<code class="fe mp mq mr mg b"><em class="ms">builtins</em></code>。这是我们定义所有内置实用程序的地方。接下来，创建文件<code class="fe mp mq mr mg b"><strong class="kc io">builtins.c</strong></code>并向其中添加以下代码:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="032d" class="mk kz in mg b gy ml mm l mn mo"><em class="ms">#include "../shell.h"</em></span><span id="dfc1" class="mk kz in mg b gy mt mm l mn mo">struct builtin_s <strong class="mg io">builtins</strong>[] =<br/>{   <br/>    { "dump"    , dump       },<br/>};</span><span id="c75b" class="mk kz in mg b gy mt mm l mn mo">int <strong class="mg io">builtins_count</strong> = sizeof(builtins)/sizeof(struct builtin_s);</span></pre><p id="6fa1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，我们将添加一个内置的实用程序，名为<code class="fe mp mq mr mg b"><strong class="kc io">dump</strong></code>，我们将使用它来转储或打印符号表的内容，这样我们就知道幕后发生了什么(我主要写了这个实用程序，以便我们的讨论听起来不会太抽象和理论化)。</p><p id="77c0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在<code class="fe mp mq mr mg b"><em class="ms">builtins</em></code>子目录中，创建文件<code class="fe mp mq mr mg b"><strong class="kc io">dump.c</strong></code>，并在其中添加以下代码:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="edc6" class="mk kz in mg b gy ml mm l mn mo"><em class="ms">#include "../shell.h"<br/>#include "../symtab/symtab.h"</em></span><span id="32c5" class="mk kz in mg b gy mt mm l mn mo">int <strong class="mg io">dump</strong>(int <strong class="mg io">argc</strong>, char **<strong class="mg io">argv</strong>)<br/>{<br/>    dump_local_symtab();<br/>    return 0;<br/>}</span></pre><p id="9975" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">简单吧？这个函数实现了我们的<code class="fe mp mq mr mg b"><strong class="kc io">dump</strong></code>内置实用程序，它打印本地符号表的内容。</p><h1 id="9105" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">更新执行者</h1><p id="5b4a" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">接下来，我们需要告诉我们的执行器我们新的内置实用程序，以便当我们输入命令<code class="fe mp mq mr mg b"><strong class="kc io">dump</strong></code>时，shell 执行我们的<code class="fe mp mq mr mg b"><strong class="kc io">dump()</strong></code>函数，而不是搜索名为<strong class="kc io"> dump </strong>的外部命令。为此，我们需要修复我们的<code class="fe mp mq mr mg b"><strong class="kc io">do_simple_command()</strong></code>函数。</p><p id="062e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在源目录中，打开<code class="fe mp mq mr mg b"><strong class="kc io">executor.c</strong></code>源文件并导航到<code class="fe mp mq mr mg b"><strong class="kc io">do_simple_command()</strong></code>函数的定义。现在找到两条线:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="40b0" class="mk kz in mg b gy ml mm l mn mo">argv[argc] = NULL;<br/>pid_t <strong class="mg io">child_pid</strong> = 0;</span></pre><p id="645f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这两行之间插入一个新行，并输入以下代码:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="5bd9" class="mk kz in mg b gy ml mm l mn mo">    int <strong class="mg io">i</strong> = 0;<br/>    for( ; i &lt; builtins_count; i++)<br/>    {<br/>        if(strcmp(argv[0], builtins[i].name) == 0)<br/>        {<br/>            builtins[i].func(argc, argv);<br/>            free_argv(argc, argv);<br/>            return 1;<br/>        }<br/>    }</span></pre><p id="3b47" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们的 shell 将检查它将要执行的命令的名称是否是内置实用程序的名称，如果是，它将调用实现内置实用程序的函数并返回。</p><p id="9ae4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就是这样！现在让我们编译并测试我们的 shell。</p><h1 id="9acf" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">编译外壳</h1><p id="63e6" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">让我们编译我们的外壳。打开您最喜欢的终端模拟器，导航到您的源目录，并确保其中有 14 个文件和 2 个子目录:</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/10ce0b0ce8fba27dc522d4de88ac2128.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iWQWWh4I9hik4HAK"/></div></div></figure><p id="38ed" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在使用以下命令编译 shell:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="9185" class="mk kz in mg b gy ml mm l mn mo">gcc -o shell executor.c initsh.c main.c node.c parser.c prompt.c scanner.c source.c <!-- -->builtins/builtins.c <!-- -->builtins/dump.c symtab/symtab.c</span></pre><p id="8836" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果一切顺利，<code class="fe mp mq mr mg b"><strong class="kc io">gcc</strong></code>应该不会输出任何东西，当前目录下应该有一个名为<code class="fe mp mq mr mg b"><strong class="kc io">shell</strong></code>的可执行文件:</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/18ee0dafbad0b256e38f450dbd65a012.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8hsVQdAtaPY-SQQA5nPA_Q.png"/></div></div></figure><p id="8277" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">(如果您从<a class="ae jz" href="https://github.com/moisam/lets-build-a-linux-shell/tree/master/part4" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>下载了源文件，您可以简单地从源目录运行<code class="fe mp mq mr mg b"><strong class="kc io">make</strong></code>，它会负责编译 shell)。</p><p id="ff95" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在通过运行<code class="fe mp mq mr mg b"><strong class="kc io">./shell</strong></code>调用 shell，并尝试我们新的内置实用程序<code class="fe mp mq mr mg b"><strong class="kc io">dump</strong></code>:</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/1049eb6ad8db7b4c2146452e8579e89f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d3w40skhUfs8J4vZDR24AQ.png"/></div></div></figure><p id="3053" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如您在输出中看到的，我们的全局符号表(级别 0)包含许多变量(在上面的例子中是 67)，这些变量对应于从我们的父进程传递给我们的 shell 的环境变量。最后两个条目代表我们的<strong class="kc io"> PS1 </strong>和<strong class="kc io"> PS2 </strong>变量。尝试输入一些其他命令，看看我们的 shell 在解析和执行简单命令方面表现如何。</p><h1 id="eade" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">下一步是什么</h1><p id="d965" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">现在可能还不明显，但是我们在这一部分所做的是一个巨大的成就。我们的符号表将使我们能够在 shell 中做一些重要的事情，比如执行单词扩展、将变量导出到外部命令、定义 shell 函数等等。</p><p id="7ffe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在下一部分中，我们将讨论单词扩展过程，以及如何在 shell 中添加单词扩展功能。</p><p id="4b5a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">敬请期待！</p></div></div>    
</body>
</html>