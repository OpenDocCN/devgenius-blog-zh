<html>
<head>
<title>Running QuestDB on GKE Autopilot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 GKE 自动驾驶仪上运行 QuestDB</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/running-questdb-on-gke-autopilot-dab25fd76e66?source=collection_archive---------4-----------------------#2021-03-18">https://blog.devgenius.io/running-questdb-on-gke-autopilot-dab25fd76e66?source=collection_archive---------4-----------------------#2021-03-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="86ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过监控和自动化备份扩展 QuestDB Helm 图表，以实现生产就绪设置。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/4011a040e4e96457a9f25569fe31db1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y-VWDVTYPDQmW0-Mp_S0UA.png"/></div></div></figure><p id="0fe3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最近，我一直在尝试使用 QuestDB 作为主要的时间序列数据库来流式传输和分析物联网/金融数据:</p><ul class=""><li id="e28b" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated"><a class="ae lg" href="https://levelup.gitconnected.com/streaming-heart-rate-data-with-iot-core-and-questdb-84304069592e" rel="noopener ugc nofollow" target="_blank">使用物联网核心和 QuestDB 流式传输心率数据</a></li><li id="18ed" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated"><a class="ae lg" href="https://medium.com/swlh/realtime-crypto-tracker-with-kafka-and-questdb-b33b19048fc2" rel="noopener">带卡夫卡和 QuestDB 的实时密码跟踪器</a></li></ul><p id="a129" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然我能够在这两个项目中验证 QuestDB 在存储大量数据和快速查询数据方面的能力，但我主要是通过 Docker 在我的笔记本电脑上运行它们。为了扩展我的实验，我想创建一个更适合生产的设置，包括 Kubernetes 上的监控和灾难恢复。因此，在本指南中，我们将与普罗米修斯和韦莱罗一起完成在 GKE 建立 QuestDB 的过程。</p><h1 id="1399" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">先决条件</h1><ul class=""><li id="a3f2" class="kx ky iq jp b jq mk ju ml jy mm kc mn kg mo kk lc ld le lf bi translated"><a class="ae lg" href="https://cloud.google.com/" rel="noopener ugc nofollow" target="_blank"> GCP 账户</a></li><li id="98e5" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated"><a class="ae lg" href="https://cloud.google.com/sdk/docs/install" rel="noopener ugc nofollow" target="_blank"> gcloud CLI </a></li><li id="7974" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated"><a class="ae lg" href="https://v3.helm.sh/docs/intro/install/" rel="noopener ugc nofollow" target="_blank">舵 3 </a></li></ul><h1 id="7796" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">设置 GKE 自动驾驶仪</h1><p id="9bdf" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">作为一名 DevOps 工程师/SRE，我是 GKE 的超级粉丝，因为与其他可用的托管 Kubernetes 选项相比，它提供了很多现成的功能，比如集群自动缩放、网络策略插件和托管 Istio。最近，谷歌云宣布了<a class="ae lg" href="https://cloud.google.com/blog/products/containers-kubernetes/introducing-gke-autopilot" rel="noopener ugc nofollow" target="_blank"> GKE 自动驾驶仪</a>，这是一种新的模式，可以进一步自动化库本内特操作，包括节点管理、安全/强化和资源优化。它将云运行的无服务器体验与 GKE 的灵活性和特性结合在一起。实际上，这意味着您现在需要为 pod 的使用付费，而不是为底层 Kubernetes 节点的计算和存储付费，这使得它成为资源利用率未知的项目的绝佳选择。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="c982" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建一个新的 GKE 自动驾驶仪集群也非常简单。不需要设置 Terraform 或 VPCs/auto scaler/节点组。只需创建一个谷歌云账户，导航至<a class="ae lg" href="https://cloud.google.com/" rel="noopener ugc nofollow" target="_blank">谷歌库本尼斯引擎</a>，启用库本尼斯引擎 API，点击“创建集群”:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mu"><img src="../Images/42eb7c9138aa015d7e4a3ebe7d5eb733.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*369tWdShI_HC4jy0WMkJcA.png"/></div></div></figure><p id="4509" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">单击“自动驾驶模式”下的“配置”按钮，为集群命名，并等待几分钟，让集群准备就绪。我在<code class="fe mv mw mx my b">us-east1</code>区域使用默认名称<code class="fe mv mw mx my b">autopilot-cluster-1</code>(现在可以随意跳过其他部分)。</p><p id="b246" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要配置 Kubernetes 上下文通过 Helm 与集群交互，使用下面的<code class="fe mv mw mx my b">gcloud</code>命令获取凭证:</p><pre class="km kn ko kp gt mz my na nb aw nc bi"><span id="5769" class="nd ln iq my b gy ne nf l ng nh">$ gcloud container clusters get-credentials autopilot-cluster-1 --region us-east1</span></pre><h1 id="c904" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">部署 QuestDB</h1><p id="1baa" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">QuestDB 提供了一个官方的舵图，默认情况下，它使用 50Gi PVC 来部署单个 StatefulSet pod。要安装图表，请添加 QuestDB Helm repo 并通过运行以下命令进行部署:</p><pre class="km kn ko kp gt mz my na nb aw nc bi"><span id="af03" class="nd ln iq my b gy ne nf l ng nh">$ helm repo add questdb <a class="ae lg" href="https://helm.questdb.io/" rel="noopener ugc nofollow" target="_blank">https://helm.questdb.io/</a><br/>$ helm upgrade --install questdb questdb/questdb</span></pre><p id="6bd4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于 GKE 自动驾驶仪不预配置节点容量，pod 最初将被标记为不可调度。等待几秒钟，直到 cluster autoscaler 触发扩展事件并安排<code class="fe mv mw mx my b">questdb</code> pod。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ni"><img src="../Images/005b6361c968effaae93c055a2d081a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R1k-AVPDzVRfES84Fm5NMw.png"/></div></div></figure><p id="360b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于快速冒烟测试，端口转发 HTTP 端点并与 web 控制台 UI 交互:</p><pre class="km kn ko kp gt mz my na nb aw nc bi"><span id="ddee" class="nd ln iq my b gy ne nf l ng nh">$ kubectl port-forward questdb-0 9000:9000</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nj"><img src="../Images/97d268272fdc90511c46187bd0d5dbc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4y3ykUUAyIIw-mXmVHW7CA.png"/></div></div></figure><h1 id="75e6" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">监控 Postgres 指标</h1><p id="77df" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">至此，我们有了一个健康的、正在运行的 QuestDB 实例。然而，如果不检查应用程序日志，就没有简单的方法来确定整个系统的健康状况并从 QuestDB 中获取指标。出于性能原因，QuestDB 团队决定将 REST 端点从其<code class="fe mv mw mx my b">min</code> <a class="ae lg" href="https://questdb.io/docs/operations/health-monitoring/" rel="noopener ugc nofollow" target="_blank"> HTTP 服务器中分离出来，该服务器在端口 9003 </a>上保存一个简单的健康状态。这个端口目前没有通过 Helm chart 公开，因此需要更改 StatefulSet 和 Service 部分，以允许探测器定期检查这个端点。</p><p id="eab7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不幸的是，QuestDB 目前还没有提供一个全面的指标端点，可以与 Prometheus 或 Postgres 进行本地集成。此支持的公开 Github 问题如下:</p><ul class=""><li id="bdf5" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated"><a class="ae lg" href="https://github.com/questdb/questdb/issues/532" rel="noopener ugc nofollow" target="_blank"> [#532]添加普罗米修斯指标端点</a></li><li id="a0d9" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated"><a class="ae lg" href="https://github.com/questdb/questdb/issues/837" rel="noopener ugc nofollow" target="_blank"> [#837]增加对公开数据库状态的支持，类似于 pg_stat_database 和 pg_stat_activity </a></li></ul><p id="ba88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管如此，我还是希望部署 Prometheus Postgres Exporter 来至少跟踪 QuestDB 的 up/down 状态，并建立一个框架来在这些特性可用时监控 Postgres 指标。</p><h2 id="b92d" class="nd ln iq bd lo nk nl dn ls nm nn dp lw jy no np ma kc nq nr me kg ns nt mi nu bi translated">暴露 Postgres 端口</h2><p id="0cf4" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">首先，我们需要修改默认的 QuestDB 图表，以暴露端口 8812 (Postgres 端点)。创建一个名为<code class="fe mv mw mx my b">questdb-values.yaml</code>的新 YAML 文件:</p><pre class="km kn ko kp gt mz my na nb aw nc bi"><span id="f91e" class="nd ln iq my b gy ne nf l ng nh">service:<br/>  expose:<br/>    postgresql:<br/>      enabled: true<br/>      port: 8812</span></pre><p id="9af5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更新现有部署:</p><pre class="km kn ko kp gt mz my na nb aw nc bi"><span id="8d6e" class="nd ln iq my b gy ne nf l ng nh">$ helm upgrade --install questdb questdb/questdb -f <!-- -->questdb-values.yaml</span></pre><h2 id="a5f1" class="nd ln iq bd lo nk nl dn ls nm nn dp lw jy no np ma kc nq nr me kg ns nt mi nu bi translated">安装 Prometheus Postgres 导出器</h2><p id="14a1" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">普罗米修斯头盔图由<code class="fe mv mw mx my b">prometheus-community</code>管理:</p><pre class="km kn ko kp gt mz my na nb aw nc bi"><span id="d3bf" class="nd ln iq my b gy ne nf l ng nh">$ helm repo add prometheus-community https://prometheus-community.github.io/helm-charts</span></pre><p id="37fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们需要修改默认值来抓取 QuestDB 并禁用默认指标，因为 QuestDB 当前没有存储<code class="fe mv mw mx my b">pg_stat_database</code>或<code class="fe mv mw mx my b">pg_stat_activity</code>。我们还希望 Prometheus 抓取我们的指标，所以我们需要添加注释来指定我们的抓取端口。</p><p id="9af1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建另一个名为<code class="fe mv mw mx my b">exporter-values.yaml</code>的 YAML 文件:</p><pre class="km kn ko kp gt mz my na nb aw nc bi"><span id="c0cd" class="nd ln iq my b gy ne nf l ng nh">config:<br/>  datasource:<br/>    host: questdb-0.questdb-headless<br/>    user: admin<br/>    password: quest<br/>    port: '8812'<br/>    database: qdb<br/>    sslmode: disable<br/>  disableDefaultMetrics: true</span><span id="7599" class="nd ln iq my b gy nv nf l ng nh">annotations: <br/>  prometheus.io/scrape: 'true'<br/>  prometheus.io/port: '9187'</span></pre><p id="364a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以安装 Postgres 导出器了:</p><pre class="km kn ko kp gt mz my na nb aw nc bi"><span id="77a0" class="nd ln iq my b gy ne nf l ng nh">$ helm upgrade -i postgres-exporter prometheus-community/prometheus-postgres-exporter -f exporter-values.yaml</span></pre><p id="a653" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们可以安装 Prometheus 来收集这些指标。创建一个新的 YAML 文件来保存我们的 Prometheus 配置，<code class="fe mv mw mx my b">prometheus-values.yaml</code>:</p><pre class="km kn ko kp gt mz my na nb aw nc bi"><span id="3b40" class="nd ln iq my b gy ne nf l ng nh">alertmanager:<br/>  enabled: false<br/>nodeExporter:<br/>  enabled: false<br/>pushgateway:<br/>  enabled: false</span></pre><p id="04ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于我们还没有来自 QuestDB 的真实指标，我们将只部署 Prometheus 服务器并接受默认配置。</p><pre class="km kn ko kp gt mz my na nb aw nc bi"><span id="ff84" class="nd ln iq my b gy ne nf l ng nh">$ helm upgrade -i prometheus prometheus-community/prometheus -f prometheus-values.yaml</span></pre><p id="ad9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">访问控制面板，通过端口转发运行我们的查询:</p><pre class="km kn ko kp gt mz my na nb aw nc bi"><span id="597e" class="nd ln iq my b gy ne nf l ng nh">$ export POD_NAME=$(kubectl get pods --namespace default -l \ "app=prometheus,component=server" -o jsonpath="{.items[0].metadata.name}")<br/>  kubectl --namespace default port-forward $POD_NAME 9090</span></pre><p id="b7cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">打开 localhost:9090，检查我们是否能够抓取<code class="fe mv mw mx my b">pg_up</code>:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nw"><img src="../Images/8569c721566bbfef104b47835171e1a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RYC-gxAIDQmPir1s7mZEvQ.png"/></div></div></figure><p id="8f25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="nx">(注:如果您正在寻找生产就绪的监控设置，请参考四部分系列“</em><a class="ae lg" href="https://yitaek.medium.com/practical-monitoring-with-prometheus-grafana-part-i-22d0f172f993" rel="noopener"><em class="nx">Prometheus 和 Grafana </em> </a> <em class="nx">的实际监控”。)</em></p><h1 id="11b6" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">使用 Velero 自动备份</h1><p id="1d88" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated"><a class="ae lg" href="https://velero.io/" rel="noopener ugc nofollow" target="_blank"> Velero </a>是一款开源工具，用于备份和恢复 Kubernetes 资源和持久卷。这对于灾难恢复(拍摄快照)或数据迁移非常有用。Velero 在 Kubernetes 集群内运行，并与各种存储提供商(如 AWS S3、GCP 存储、Minio)以及<a class="ae lg" href="https://velero.io/docs/v1.5/restic/" rel="noopener ugc nofollow" target="_blank"> restic </a>集成，以按需或按计划拍摄快照。</p><h2 id="5d55" class="nd ln iq bd lo nk nl dn ls nm nn dp lw jy no np ma kc nq nr me kg ns nt mi nu bi translated">装置</h2><p id="84b1" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">Velero 可通过<a class="ae lg" href="https://vmware-tanzu.github.io/helm-charts/" rel="noopener ugc nofollow" target="_blank">舵</a>或通过<a class="ae lg" href="https://velero.io/docs/v1.5/basic-install/" rel="noopener ugc nofollow" target="_blank"> CLI </a>工具安装。总的来说，CLI 似乎获得了最新的更新，而 Helm chart 稍微落后于兼容的 Docker 映像。</p><pre class="km kn ko kp gt mz my na nb aw nc bi"><span id="5854" class="nd ln iq my b gy ne nf l ng nh"># for MacOS<br/>$ <!-- -->brew install velero</span><span id="1846" class="nd ln iq my b gy nv nf l ng nh"># for Windows<br/>$ choco install velero</span></pre><h2 id="12f0" class="nd ln iq bd lo nk nl dn ls nm nn dp lw jy no np ma kc nq nr me kg ns nt mi nu bi translated">配置服务器组件</h2><p id="0e0c" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">要在 GCP 设置 Velero，我们需要:</p><ul class=""><li id="7efb" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated"><a class="ae lg" href="https://github.com/vmware-tanzu/velero-plugin-for-gcp#Create-an-GCS-bucket" rel="noopener ugc nofollow" target="_blank">创建一个 GCS 存储桶</a></li><li id="5cb4" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated"><a class="ae lg" href="https://github.com/vmware-tanzu/velero-plugin-for-gcp#Set-permissions-for-Velero" rel="noopener ugc nofollow" target="_blank">为 Velero 设置权限</a></li><li id="0302" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated"><a class="ae lg" href="https://github.com/vmware-tanzu/velero-plugin-for-gcp#Install-and-start-Velero" rel="noopener ugc nofollow" target="_blank">安装并启动 Velero </a></li></ul><h2 id="5153" class="nd ln iq bd lo nk nl dn ls nm nn dp lw jy no np ma kc nq nr me kg ns nt mi nu bi translated">创建 GCS 存储桶</h2><p id="fd8d" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">给出一个唯一的 bucket 名称，并使用<code class="fe mv mw mx my b">gsutil</code>工具创建 bucket(用您的 BUCKET 名称替换&lt; YOUR_BUCKET &gt;):</p><pre class="km kn ko kp gt mz my na nb aw nc bi"><span id="089c" class="nd ln iq my b gy ne nf l ng nh">PROJECT_ID=$(gcloud config get-value project)<br/>BUCKET=&lt;YOUR_BUCKET&gt;</span><span id="3564" class="nd ln iq my b gy nv nf l ng nh">gsutil mb gs://$BUCKET/</span></pre><h2 id="0ab0" class="nd ln iq bd lo nk nl dn ls nm nn dp lw jy no np ma kc nq nr me kg ns nt mi nu bi translated">设置 GCP 权限</h2><p id="e6c1" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">创建服务帐户:</p><pre class="km kn ko kp gt mz my na nb aw nc bi"><span id="52c6" class="nd ln iq my b gy ne nf l ng nh">gcloud iam service-accounts create velero \<br/> — display-name “Velero service account”</span></pre><p id="e6bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将计算权限附加到服务帐户:</p><pre class="km kn ko kp gt mz my na nb aw nc bi"><span id="3196" class="nd ln iq my b gy ne nf l ng nh">SERVICE_ACCOUNT_EMAIL=$(gcloud iam service-accounts list \<br/>  --filter="displayName:Velero service account" \<br/>  --format 'value(email)')</span><span id="841e" class="nd ln iq my b gy nv nf l ng nh">ROLE_PERMISSIONS=(<br/>    compute.disks.get<br/>    compute.disks.create<br/>    compute.disks.createSnapshot<br/>    compute.snapshots.get<br/>    compute.snapshots.create<br/>    compute.snapshots.useReadOnly<br/>    compute.snapshots.delete<br/>    compute.zones.get<br/>)<br/><br/>gcloud iam roles create velero.server \<br/>    --project $PROJECT_ID \<br/>    --title "Velero Server" \<br/>    --permissions "$(IFS=","; echo "${ROLE_PERMISSIONS[*]}")"<br/><br/>gcloud projects add-iam-policy-binding $PROJECT_ID \<br/>    --member serviceAccount:$SERVICE_ACCOUNT_EMAIL \<br/>    --role projects/$PROJECT_ID/roles/velero.server<br/><br/>gsutil iam ch serviceAccount:$SERVICE_ACCOUNT_EMAIL:objectAdmin gs://${BUCKET}</span></pre><p id="8b61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下载服务帐户密钥并保存为<code class="fe mv mw mx my b">credential-velero</code>:</p><pre class="km kn ko kp gt mz my na nb aw nc bi"><span id="dcfa" class="nd ln iq my b gy ne nf l ng nh">gcloud iam service-accounts keys create credentials-velero \<br/>    --iam-account $SERVICE_ACCOUNT_EMAIL</span></pre><p id="a8c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以安装 Velero 并启用 GCS 插件了:</p><pre class="km kn ko kp gt mz my na nb aw nc bi"><span id="55df" class="nd ln iq my b gy ne nf l ng nh">velero install \<br/>    --provider gcp \<br/>    --plugins velero/velero-plugin-for-gcp:v1.1.0 \<br/>    --bucket $BUCKET \<br/>    --secret-file ./credentials-velero</span></pre><p id="e4a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们可以使用 cron 字符串创建一个时间表:</p><pre class="km kn ko kp gt mz my na nb aw nc bi"><span id="dddf" class="nd ln iq my b gy ne nf l ng nh">velero schedule create questdb --schedule "0 7 * * *" -l "app.kubernetes.io/instance=questdb" --include-namespaces default</span></pre><p id="e1d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以验证在我们的存储桶中进行的备份:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ny"><img src="../Images/c561dc9b42e01516310828b54dcb0a58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hqon6Z2WCYpVlnzJ5QD7ag.png"/></div></div></figure><p id="73a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(<em class="nx">注:关于 Velero 上的深度潜水，请参考 Kubernetes 上的“</em> <a class="ae lg" href="https://medium.com/dev-genius/disaster-recovery-on-kubernetes-98c5c78382bb" rel="noopener"> <em class="nx">灾难恢复</em> </a> <em class="nx">”</em>)</p><h1 id="089a" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">后续步骤</h1><p id="9c4b" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">为了优化性能，QuestDB 选择从头构建一个与 ANSI SQL 兼容的时间序列数据库，而不是像 TimescaleDB 那样构建在 Postgres 之上。此外，作为一个较新的产品，QuestDB 缺少一些企业功能(例如复制、高可用性、从快照恢复)以及与其他流行项目的集成。不过，有了 Prometheus Postgres exporter 和 Velero，我们可以在 Kubernetes 上配置一个生产就绪的 QuestDB。我希望在将来的版本中，当监控和 ops 特性得到支持时，能够改进这个设置。</p></div></div>    
</body>
</html>