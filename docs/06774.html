<html>
<head>
<title>Creating an Automated Data Processing Pipeline with Apache Airflow, Kubernetes, and R — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Apache Airflow、Kubernetes 和 R 创建自动化数据处理管道—第 2 部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/creating-an-automated-data-processing-pipeline-with-apache-airflow-kubernetes-and-r-part-2-2e95c2e9ae5e?source=collection_archive---------7-----------------------#2022-02-02">https://blog.devgenius.io/creating-an-automated-data-processing-pipeline-with-apache-airflow-kubernetes-and-r-part-2-2e95c2e9ae5e?source=collection_archive---------7-----------------------#2022-02-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/4cc4867755f72f9877fc02a5929a61cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZfpXo879QC6Bys8f"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">照片由<a class="ae jz" href="https://unsplash.com/@inspirationfeed?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">吸气送料</a>在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="f56d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在<a class="ae jz" href="https://robert-a-gutierrez.medium.com/creating-an-automated-data-processing-pipeline-with-apache-airflow-kubernetes-and-r-part-1-925f99b812e7" rel="noopener">第一部分</a>中，我们设置了我们的 Cloud Composer 环境，我们的本地环境，并派生了模板库。</p><p id="564a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在这个设置已经完成了，我们可以开始有趣的部分了:创建一个容器映像用于我们的任务窗格，创建一个 DAG 和 task，设置我们的任务文件以便在任务窗格中执行，部署我们的代码，并观看神奇的事情发生。</p><h1 id="3394" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">我们的第一天:开始到结束</h1><p id="cb45" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">我在报告中包含了一个示例 DAG 和容器映像。我们可以在这里走一走，看看所有的东西是如何连接在一起的。如果你想自己阅读 DAG 代码，你可以在<code class="fe mb mc md me b">dags/example_dag.py</code>找到它。Dockerfile 文件和相关的图像资料可以在<code class="fe mb mc md me b">images/my_data_processor</code>中找到。</p><h2 id="4a0d" class="mf kz in bd la mg mh dn le mi mj dp li kl mk ml lm kp mm mn lq kt mo mp lu mq bi translated">步骤 1:容器图像</h2><p id="aaac" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">在任务执行之前，使用提供的容器映像启动一个 pod。如果我们知道我们的任务需要什么样的程序/库，我们可以将它构建到我们的容器映像中，这样我们的任务就可以使用它了。</p><p id="bbbc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看看我提供的 docker 文件:</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="7f12" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的图像基于令人敬畏的<code class="fe mb mc md me b">rocker/tidyverse</code>图像，然后添加一些额外的 Python 和 R 的东西。我们还在设置<code class="fe mb mc md me b">google-cloud-sdk</code>，这样我们就可以连接到谷歌云服务并使用它来执行操作。</p><p id="877f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请随意清理 R 包部分。我保留了我的团队一直在使用的所有软件包，但你可能不需要它们。</p><p id="2e7c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后我们将<code class="fe mb mc md me b">~/bin</code>添加到<code class="fe mb mc md me b">PATH</code>中，复制我们的引导脚本，并将其设置为入口点。</p><p id="dcb0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">和引导脚本:</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="cd09" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你会注意到这里有一些环境变量。这些是在我们初始化我们的<code class="fe mb mc md me b">KubernetesPodOperator</code>实例(我们的任务)时设置的。目前，您不需要接触这个脚本。它所做的只是使用 Google Cloud 进行认证，创建一些额外的目录，下载“任务文件”(这将是您为每个任务提供的一个 shell 脚本)，并执行它。</p><p id="b136" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有了 Dockerfile 和 bootstrap 脚本，让我们创建图像并上传到 Google Cloud，这样我们就可以在我们的任务中使用它了。</p><p id="fe49" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在终端标签或窗口中，导航到项目目录，然后转到<code class="fe mb mc md me b">images/my_data_processor</code>。如果你还没有安装 Docker Desktop 或者<code class="fe mb mc md me b">docker</code>和<code class="fe mb mc md me b">docker-machine</code>软件包，你现在应该这样做。</p><p id="7168" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们建立图像。</p><pre class="mr ms mt mu gt mx me my mz aw na bi"><span id="cc26" class="mf kz in me b gy nb nc l nd ne">$ docker build -t IMAGE_NAME .</span></pre><p id="16ad" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我只使用 IMAGE_NAME 的文件夹名，这样更容易理解。</p><p id="b7b5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦构建了图像，我们需要标记它并将其推送到容器注册表(我们将使用 Google 容器注册表)。</p><pre class="mr ms mt mu gt mx me my mz aw na bi"><span id="8f15" class="mf kz in me b gy nb nc l nd ne">$ docker tag IMAGE_NAME HOSTNAME/PROJECT-ID/IMAGE_NAME<br/>$ gcloud auth configure-docker<br/>$ docker push HOSTNAME/PROJECT-ID/IMAGE_NAME</span></pre><p id="9970" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mb mc md me b">HOSTNAME</code>是您正在推送的容器注册中心的主机名(在我们的例子中，我们使用了<code class="fe mb mc md me b">us.gcr.io</code>)。而<code class="fe mb mc md me b">PROJECT-ID</code>就是你的谷歌云项目 ID。</p><p id="94f7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">更新图像</strong></p><p id="5fdf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当您需要更新 Docker 映像时，只需重建并推送它:</p><pre class="mr ms mt mu gt mx me my mz aw na bi"><span id="c4e8" class="mf kz in me b gy nb nc l nd ne">$ docker build -t IMAGE_NAME .<br/>$ docker push HOSTNAME/PROJECT-ID/IMAGE_NAME</span></pre><p id="d28c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您想完全重建图像，您可以将<code class="fe mb mc md me b">--no-cache</code>传递给<code class="fe mb mc md me b">docker build</code>命令。然后将图像推送到注册表。</p><p id="f279" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">或者，对于更彻底的解决方案，您可以删除旧映像并重新构建它。然后用力。</p><pre class="mr ms mt mu gt mx me my mz aw na bi"><span id="e4f4" class="mf kz in me b gy nb nc l nd ne">$ docker rmi --force IMAGE_NAME<br/>$ docker build -t IMAGE_NAME .<br/>$ docker tag IMAGE_NAME HOSTNAME/PROJECT-ID/IMAGE_NAME<br/>$ docker push HOSTNAME/PROJECT-ID/IMAGE_NAME</span></pre><p id="7dbe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您已经修改了 docker 文件，但<code class="fe mb mc md me b">docker push</code>导致所有“层已经存在”消息，这将有所帮助。</p><p id="89fc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">本地测试图像</strong></p><p id="7fef" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您正在本地测试<code class="fe mb mc md me b">my_data_processor</code>图像或另一个类似的图像<em class="nf"/>，请注意 docker 文件中的<code class="fe mb mc md me b">ENTRYPOINT</code>指令。如果您运行一个 shell 脚本作为入口点，那么每个启动的容器都会启动并立即关闭。为了解决这个问题，我们需要覆盖<code class="fe mb mc md me b">ENTRYPOINT</code>指令来保持容器活动。然后，一旦它开始运行，我们就可以连接到它。</p><p id="59b1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们需要在这里运行两个命令。首先，启动一个容器并覆盖入口点:</p><pre class="mr ms mt mu gt mx me my mz aw na bi"><span id="f789" class="mf kz in me b gy nb nc l nd ne">$ docker run --name CONTAINER_NAME -dit --entrypoint=/bin/bash IMAGE_NAME</span></pre><p id="14dc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于容器名称，使用独特的和/或与图像名称相关的内容。</p><p id="5be4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦它开始运行，我们就可以初始化一个 shell 会话并连接到它:</p><pre class="mr ms mt mu gt mx me my mz aw na bi"><span id="18a4" class="mf kz in me b gy nb nc l nd ne">$ docker exec -it CONTAINER_NAME /bin/bash</span></pre><p id="d0dd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">完成测试后，要停止并删除容器，请运行:</p><pre class="mr ms mt mu gt mx me my mz aw na bi"><span id="7e98" class="mf kz in me b gy nb nc l nd ne">$ docker stop CONTAINER_NAME &amp;&amp; docker rm CONTAINER_NAME</span></pre><h2 id="fa91" class="mf kz in bd la mg mh dn le mi mj dp li kl mk ml lm kp mm mn lq kt mo mp lu mq bi translated">步骤 2: DAG 和任务代码</h2><p id="052a" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">让我们看一下 DAG 提供的示例:</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="bb19" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我设置它的方式与文档略有不同。我继续将任务代码放入一个单独的<code class="fe mb mc md me b">tasks</code>目录中，在这个目录中，有每个 DAG 的目录。由多个 Dag 使用的任何任务都在<code class="fe mb mc md me b">tasks/common</code>文件夹中。</p><p id="14a5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我们创建 DAG，设置调度和超时间隔，并提供一些默认参数。接下来，我们通过传入刚刚创建的 DAG 来初始化我们的任务。最后，我们通过使用箭头操作符来定义 DAG 中任务的关系。如果任何任务有多个依赖项，我们将使用任务列表。</p><pre class="mr ms mt mu gt mx me my mz aw na bi"><span id="c151" class="mf kz in me b gy nb nc l nd ne"># a simple linear DAG<br/>t1 &gt;&gt; t2 &gt;&gt; t3</span><span id="d984" class="mf kz in me b gy ng nc l nd ne"># a more complex DAG<br/>t1 &gt;&gt; [t2a, t2b]<br/>t2a &gt;&gt; t3a<br/>[t2b, t3a] &gt;&gt; t4</span></pre><p id="d23a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这可能看起来令人困惑，但是当我们部署 DAG 并查看图形视图时，您将能够更清楚地看到这些关系。</p><p id="f570" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">可以忽略<code class="fe mb mc md me b">trigger_arguments</code>属性。我将在本教程的下一部分解释这一点。</p><p id="3d3a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在让我们看看任务代码:</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="221d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我设置了一些函数来抽象和标准化一些任务初始化代码，并减少创建任务所需的行数。可以在<code class="fe mb mc md me b">tasks/__init__.py</code>查看。</p><p id="a7cb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mb mc md me b">generate_env_vars</code>设置应该传递给所有任务的默认环境变量，然后让我们定义特定于我们任务的环境变量。然后我们用<code class="fe mb mc md me b">verify_env_vars</code>验证我们的变量，这也增加了依赖于先前设置的变量的额外变量(像<code class="fe mb mc md me b">TASK_FOLDER</code>依赖于<code class="fe mb mc md me b">TASK_ID</code>来构建完整路径)。最后，<code class="fe mb mc md me b">generate_op_vars</code>对传递给 operator 类的变量做一些类似的事情，并让我们提供特定于任务的变量。</p><p id="5a36" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在<code class="fe mb mc md me b">common</code>中还有另一个任务，称为<code class="fe mb mc md me b">parse_job_args</code>，当我们手动触发一个任务时，它允许我们获取<code class="fe mb mc md me b">conf</code>中指定的任何数据，并将其推送到 XCom，以便 DAG 中的所有下游任务可以使用它。我将在本教程的下一部分更详细地解释它。</p><h2 id="8f34" class="mf kz in bd la mg mh dn le mi mj dp li kl mk ml lm kp mm mn lq kt mo mp lu mq bi translated">步骤 3:任务文件</h2><p id="38b1" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">现在让我们处理数据处理管道的“肉和土豆”,实际进行数据处理的脚本。</p><p id="76a8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于我们的 DAG 示例，我们将查看<code class="fe mb mc md me b">task_files/example_dag/hello_world</code>文件夹。任务文件首先被分成 DAG 文件夹，然后是任务文件夹。至少，我们需要一个文件，一个 shell 脚本，它是由容器的引导脚本执行的。这允许我们执行任意数量的代码，并调用我们想要的任何程序。这个文件夹是我们放置 R 脚本的地方，我们从 shell 脚本中执行它们。我会告诉你我的意思:</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="72ae" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的许多 shell 脚本以这种格式结束:从云存储中下载任务文件并<code class="fe mb mc md me b">chmod</code>使它们可执行，下载任何需要的公共文件，执行我们的 R 脚本(示例中有一个普通的 R 脚本和一个 RMarkdown 脚本)，然后将输出上传到<code class="fe mb mc md me b">runs</code>中的必要文件夹。</p><p id="4736" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在云存储中，我选择保存每个任务的输出，以便于调试。该文件夹存储在<code class="fe mb mc md me b">TASK_RESULTS_FOLDER</code>环境变量中，但格式如下:</p><pre class="mr ms mt mu gt mx me my mz aw na bi"><span id="ab64" class="mf kz in me b gy nb nc l nd ne">$CLOUD_STORAGE_BUCKET/runs/$DAG_ID/$CUSTOM_RUN_ID/$TASK_ID</span></pre><p id="0f1f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">CUSTOM_RUN_ID 是我在一个插件中定义的东西，我将在本教程的下一部分谈到它。你可以使用气流产生的<code class="fe mb mc md me b">run_id</code>变量。</p><h2 id="3f4e" class="mf kz in bd la mg mh dn le mi mj dp li kl mk ml lm kp mm mn lq kt mo mp lu mq bi translated">步骤 4:部署</h2><p id="e67e" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">现在我们准备在气流中测试它！</p><p id="44aa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用我们方便的部署脚本轻松地将所有内容上传到云存储，以便 Airflow 可以读取并填充 UI。在终端选项卡或窗口中，导航到项目根目录并运行:</p><pre class="mr ms mt mu gt mx me my mz aw na bi"><span id="24c3" class="mf kz in me b gy nb nc l nd ne">$ ./deploy.sh staging</span></pre><p id="36c2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">部署应该非常快。</p><p id="f8f7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们拉起气流，看看我们的劳动成果。您可以通过转到 Cloud Composer 环境并单击顶部的 Open Airflow UI 来获取 Airflow 实例的 URL。</p><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nh"><img src="../Images/ddff9c885cf234d45bc9687b18d0ed4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C9RIPxiY-0Xsr-EGW2rIpw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">我团队的气流 UI。example_dag 在里面，还有一些其他的测试。</figcaption></figure><p id="356c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您已将 DAG 设置为按计划运行，它可能已经在运行。如果没有，我们可以手动触发。</p><h2 id="1a02" class="mf kz in bd la mg mh dn le mi mj dp li kl mk ml lm kp mm mn lq kt mo mp lu mq bi translated">第五步:触发并观察</h2><p id="8b37" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">要触发我们的示例 DAG，请找到 example_dag 行，然后在最右边一列的图标集中找到“play button”图标。继续点击它。</p><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/00f0e3110c8e68adf499c45695966f65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bsuNEjwmorav7pGO0euxug.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">手动触发 DAG 时看到的屏幕</figcaption></figure><p id="672d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在文本框中，我们可以编写一些 JSON，这些 JSON 将被复制到任务中可用的<code class="fe mb mc md me b">conf</code>变量中。如果你想在这里写点什么，你可以，只要确保用括号括起来。</p><pre class="mr ms mt mu gt mx me my mz aw na bi"><span id="1204" class="mf kz in me b gy nb nc l nd ne">{"instantiator": "smith"}</span></pre><p id="27f8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">单击触发器。您应该会返回到主页，但现在您会在 DAG Runs 列中看到一个绿色圆圈。单击它，您将会看到图形视图页面。</p><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nj"><img src="../Images/93241ca4271dc994de3d8d538d7ef2a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AqU5cePv2oLQVODwunrQzg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">图形视图页面，DAG 的精彩视觉呈现。你将在这里呆很长时间。</figcaption></figure><p id="3fdf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每个盒子都是一项任务。您可以将鼠标悬停在这些框上以查看任务的状态，并单击它以查看任务实例的详细信息、任务的日志，以及手动更改状态(例如，如果您想要将其标记为失败并暂停执行)。</p><p id="3cf9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你做到了！一旦任务全部完成，您可以导航到云存储空间，转到<code class="fe mb mc md me b">runs</code>中的相关文件夹并查看输出。</p></div><div class="ab cl nk nl hr nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ig ih ii ij ik"><h1 id="982f" class="ky kz in bd la lb nr ld le lf ns lh li lj nt ll lm ln nu lp lq lr nv lt lu lv bi translated">总结</h1><p id="6d3e" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">您已经成功部署了 Cloud Composer 环境；设置您的第一个容器映像、DAG 和任务。部署您的容器映像、DAG 和任务。在气流中奔跑！有了这些知识，您就可以开始构建自己的 DAGS，并为您的工作负载修改或创建新的映像。气流是一个强大的工具，加上<code class="fe mb mc md me b">KubernetesPodOperator</code>和自定义容器图像的附加功能，可能性是无穷的！</p><p id="2f1f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本教程的下一部分，我们将查看样例插件，它为手动触发 Dag 和向任务传递参数提供了一个很好的 UI。</p></div></div>    
</body>
</html>