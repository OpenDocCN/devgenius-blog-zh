<html>
<head>
<title>Adapter &amp; Facade patterns for perfect wrapping</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">适配器和门面模式实现完美包装</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/adapter-facade-pattern-for-perfect-adapting-kotlin-ccbc8f8cfcd6?source=collection_archive---------9-----------------------#2022-03-25">https://blog.devgenius.io/adapter-facade-pattern-for-perfect-adapting-kotlin-ccbc8f8cfcd6?source=collection_archive---------9-----------------------#2022-03-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="063f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi ki translated">嘿，花样磨工伙伴！😲欢迎来到设计模式系列！这是我写的一系列关于模式的文章，以传播它们的愚蠢🙌</p><p id="5b19" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我建议你阅读以前的文章，在那里你可以挑选过多的知识:</p><ul class=""><li id="6137" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">策略模式:<a class="ae la" href="/towardsdev/strategy-pattern-for-independent-algorithms-kotlin-70ed24c7bd8b" rel="noopener ugc nofollow" target="_blank">https://medium . com/toward sdev/strategy-pattern-for-independent-algorithms-kot Lin-70 ed 24 c 7 BD 8 b</a></li><li id="19b7" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">观察者模式:<a class="ae la" href="/towardsdev/observer-pattern-for-loose-coupling-kotlin-f5ab804609bb" rel="noopener ugc nofollow" target="_blank">https://medium . com/toward sdev/observer-pattern-for-loose-coupling-kot Lin-f5ab 804609 bb</a></li><li id="3cfb" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">装饰模式:<a class="ae la" href="/towardsdev/decorator-decorator-pattern-for-object-composition-kotlin-7cec92cbaf7b" rel="noopener ugc nofollow" target="_blank">https://medium . com/toward sdev/decorator-decorator-pattern-for-object-composition-kot Lin-7 CEC 92 cbaf 7b</a></li><li id="2894" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">工厂模式:<a class="ae la" href="/dev-genius/factory-patterns-to-hide-instantiation-kotlin-d5f01cf01921" rel="noopener ugc nofollow" target="_blank">https://medium . com/dev-genius/factory-patternS-to-hide-instantiation-kot Lin-D5 f 01 cf 01921</a></li><li id="1fdc" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">单例模式:<a class="ae la" href="/dev-genius/singleton-pattern-for-one-of-a-kind-objects-java-a63c774d9d4" rel="noopener ugc nofollow" target="_blank">https://medium . com/dev-genius/singleton-pattern-for-one-of-a-class-objects-Java-a63c 774 d9d 4</a></li><li id="feee" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">命令模式:<a class="ae la" href="https://medium.com/dev-genius/command-pattern-for-encapsulated-invocation-kotlin-4338eb23d2ca" rel="noopener">https://medium . com/dev-genius/command-pattern-for-encapsulated-invocation-kot Lin-4338 EB 23 D2 ca</a></li></ul><p id="2c4c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后像往常一样支持<a class="lg lh ep" href="https://medium.com/u/fbfa235a954c?source=post_page-----ccbc8f8cfcd6--------------------------------" rel="noopener" target="_blank">奥赖利传媒</a>因为他们的书很宏伟:<a class="ae la" href="https://www.oreilly.com/library/view/head-first-design/9781492077992/" rel="noopener ugc nofollow" target="_blank">https://www . oreilly . com/library/view/head-first-design/9781492077992/</a></p><p id="f6e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">结构:</p><ul class=""><li id="4a3e" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">介绍</li><li id="c1a1" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">问题:适配器</li><li id="6107" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">额外第一部分</li><li id="1bd1" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">问题:外观</li><li id="466c" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">要遵循的设计原则</li><li id="b2dd" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">额外第二部分</li><li id="8cc7" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">最终解决方案代码:两种模式</li><li id="d059" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">图画</li></ul><p id="7f65" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">❗️At 首先，我给了一个运行到适配器&amp;然后切换到门面，这将需要更少的时间。我们去 go☄️吧</p></div><div class="ab cl li lj hr lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ig ih ii ij ik"><h1 id="9001" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">适配器和外观模式</h1><h1 id="70ef" class="lp lq in bd lr ls mn lu lv lw mo ly lz ma mp mc md me mq mg mh mi mr mk ml mm bi translated">适配器</h1><h2 id="75a6" class="ms lq in bd lr mt mu dn lv mv mw dp lz jv mx my md jz mz na mh kd nb nc ml nd bi translated">介绍</h2><p id="2a3e" class="pw-post-body-paragraph jk jl in jm b jn ne jp jq jr nf jt ju jv ng jx jy jz nh kb kc kd ni kf kg kh ig bi translated">模式是深入 OOP 世界的好选择。至少对我来说，这是那扇神奇的门，它的开启帮助我理解 OOP 不仅仅是类、继承、组合，而是内化为坚实的基础😱从头开始，看看如何炮制复杂的系统，所以 on🧑🏼‍💻</p><p id="70f7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">即使你不会记住世界上的每一个模式(你也不应该记住)，它们是银弹，抓住了它们，就会在你的头脑中为更优化的结构、更好的软件铺平道路&amp;结果，你会成为一流的软件工程师😎</p><h2 id="a87e" class="ms lq in bd lr mt mu dn lv mv mw dp lz jv mx my md jz mz na mh kd nb nc ml nd bi translated">问题:适配器</h2><p id="21ff" class="pw-post-body-paragraph jk jl in jm b jn ne jp jq jr nf jt ju jv ng jx jy jz nh kb kc kd ni kf kg kh ig bi translated">假设您有一个知道如何与某个类交互的客户端。</p><p id="7b71" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">基本例子:交流插头-&gt;插座。然后你搬到另一个国家🎌而现在你用的是以下结构:交流插头-&gt;交流电源<strong class="jm io">适配器</strong> - &gt;插座</p><p id="69e4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">编程中的适配器以同样的方式工作:它们接受<strong class="jm io">客户端类</strong>，包装到<strong class="jm io">最终类</strong>已知的接口中(假设它是我们的<strong class="jm io">供应商</strong>)。</p><blockquote class="nj nk nl"><p id="89b8" class="jk jl nm jm b jn jo jp jq jr js jt ju nn jw jx jy no ka kb kc np ke kf kg kh ig bi translated">请特别注意下面的代码。我起初认为这种模式极其容易，但却陷入了误解和损失时间的深渊😫</p></blockquote><p id="340f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先观察这个适配器的基本例子，然后我将做一个测试</p><figure class="nq nr ns nt gt nu"><div class="bz fp l di"><div class="nv nw l"/></div></figure><ol class=""><li id="e189" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh nx kx ky kz bi translated">我们有两个接口:<code class="fe ny nz oa ob b">Duck</code>和<code class="fe ny nz oa ob b">Turkey</code></li><li id="9de3" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nx kx ky kz bi translated">每个类都有自己的实现</li><li id="568d" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nx kx ky kz bi translated">想象一下<strong class="jm io">客户端</strong>知道如何与<strong class="jm io"> Duck </strong>类型的接口交互，但是我们有实现<strong class="jm io"> Turkey </strong>接口的类(我写了<code class="fe ny nz oa ob b">MallardDuck</code>作为例子，但是客户端对此一无所知)</li><li id="325b" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nx kx ky kz bi translated">在适配器中，我们实现了‼️ <strong class="jm io">适应‼️</strong>的接口，在我们的例子中是<code class="fe ny nz oa ob b">Duck</code></li><li id="4c02" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nx kx ky kz bi translated">将<strong class="jm io">adapter-to-Interface</strong>方法放入，将所使用的真实类的方法放入(PS:提供类的实例，这些实例将在内部利用那些方法)，在上面的代码中是:<code class="fe ny nz oa ob b">.gobble()</code> &amp; <code class="fe ny nz oa ob b">turkeyFly()</code></li></ol><p id="1d5c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">除了前面的文章，我特别从代码示例开始。希望这篇笔记能让你理解得更顺畅🙉</p><p id="7d0d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，让我使用一些与模式相关的术语，使它更学术化👨🏼‍🎓</p><ol class=""><li id="4211" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh nx kx ky kz bi translated">客户端是针对<strong class="jm io">目标接口</strong>实现的，其中<em class="nm">目标</em>是客户端知道如何与之交互的接口</li><li id="7d8a" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nx kx ky kz bi translated"><strong class="jm io">适配器</strong>实现<strong class="jm io">目标接口</strong>路由客户端的请求。在上面的例子中，<code class="fe ny nz oa ob b">TurkeyAdapter</code>实现了<strong class="jm io">目标接口</strong>，也就是<code class="fe ny nz oa ob b">Duck</code></li><li id="0340" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nx kx ky kz bi translated">适配器内部使用的实例是一个<strong class="jm io">适配器接口</strong>(即我们提供给<strong class="jm io">适配器</strong>的<code class="fe ny nz oa ob b">CoolTurkey</code>实现了<code class="fe ny nz oa ob b">Turkey</code>接口)</li><li id="b296" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nx kx ky kz bi translated">客户愉快地收到回复，而且永远不知道门后有任何黑魔法！🦹‍♂️</li></ol><blockquote class="nj nk nl"><p id="f9f2" class="jk jl nm jm b jn jo jp jq jr js jt ju nn jw jx jy no ka kb kc np ke kf kg kh ig bi translated">实际上，我将在本文中进一步讨论一些注意事项</p></blockquote><ul class=""><li id="f721" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">适配器<strong class="jm io">将客户端与最终代码(实现的接口)解耦。因此，我们的<strong class="jm io">客户端&amp;最终代码</strong>不需要改变，如果某些部分可能会改变(在许多时候，我们不能这样做)</strong></li><li id="eb09" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">注意<strong class="jm io">适配器</strong>如何将客户的请求映射到接口而不是具体的类，这意味着我们可以编写多个<strong class="jm io">适配器</strong>来转换不同的类集合</li></ul><h2 id="7658" class="ms lq in bd lr mt mu dn lv mv mw dp lz jv mx my md jz mz na mh kd nb nc ml nd bi translated">额外第一部分</h2><ol class=""><li id="86c7" class="kr ks in jm b jn ne jr nf jv oc jz od kd oe kh nx kx ky kz bi translated">老实说，有两种类型的适配器。上面的例子是一个规范的<strong class="jm io">对象适配器</strong>，带有<em class="nm">单一继承</em>和<em class="nm">组合</em>。而且是很好的一个(加上我们在 Java 中没有多重继承&amp; Kotlin)。但是，还有第二种类型:<strong class="jm io">类适配器</strong>使用<em class="nm">多重继承</em> &amp; <em class="nm">无组合</em>。我用 Python 写了一段代码来展示它的样子:</li></ol><figure class="nq nr ns nt gt nu"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="8ba6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">看，我们有两个抽象类(在 Python 中我们没有真正的接口)。然后我们有两个具体的类。最后，<strong class="jm io">适配器</strong>从一个知道如何使用美国类型套接字<code class="fe ny nz oa ob b">=&gt;</code>的客户端获取请求，将美国套接字的<code class="fe ny nz oa ob b">abstract class</code>作为继承中的第一个对象，并实现该方法。继承中的第二个对象是我们将重定向到的具体类。在我们的例子中是<code class="fe ny nz oa ob b">EuSocket</code></p><p id="efa4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">哪种适配器更好？不知道🤔甚至奥莱利媒体公司也没有声称自己是这本书的赢家。每个都有与组合继承方法相关的优点和缺点。</p><p id="09bb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.如果我们在使用的代码中没有一些方法呢？(我的意思是，<strong class="jm io">适配者代码</strong>)。例如，我们的客户端/代码知道如何与<strong class="jm io">迭代器</strong>交互，但是在最终代码中，我们坚持使用<strong class="jm io">枚举器</strong>。侧注:前者比后者新。<br/>那么，我们能绕过吗？不幸的是，只有借助例外。对于这种情况，请编写文档🤷‍♂️</p><p id="7bed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="lg lh ep" href="https://medium.com/u/fbfa235a954c?source=post_page-----ccbc8f8cfcd6--------------------------------" rel="noopener" target="_blank">奥赖利媒体</a>代码示例:</p><figure class="nq nr ns nt gt nu"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="c4f1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">看，我们的对象是<code class="fe ny nz oa ob b">enumerator</code>，但是公开的方法是<strong class="jm io">迭代器</strong></p><p id="eb57" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.<strong class="jm io">适配器</strong>可能与<strong class="jm io">装饰器</strong>混淆。但是前者将对象包装到现有的<em class="nm">接口</em>中，而后者增加了<em class="nm">职责</em>。要了解更多信息，请阅读我关于<strong class="jm io">装饰模式</strong>的文章:<a class="ae la" href="https://medium.com/towardsdev/decorator-decorator-pattern-for-object-composition-kotlin-7cec92cbaf7b" rel="noopener">https://medium . com/towardsdev/Decorator-Decorator-pattern-for-object-composition-kot Lin-7 CEC 92 cbaf 7b</a></p><h2 id="fe21" class="ms lq in bd lr mt mu dn lv mv mw dp lz jv mx my md jz mz na mh kd nb nc ml nd bi translated">问题:外观</h2><p id="1a67" class="pw-post-body-paragraph jk jl in jm b jn ne jp jq jr nf jt ju jv ng jx jy jz nh kb kc kd ni kf kg kh ig bi translated">在我看来，这种模式更接近我们 write✍人的日常生活🏻</p><p id="4064" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">想象一下，你有许多需要按顺序调用的类。此外，你有<strong class="jm io">接口</strong>，然后它由某个类实现。像几十个这样的东西...👀为什么不将实现接口的实例提供到一个包含类中，该类公开方法，这些实例调用它们的方法？🧐</p><pre class="nq nr ns nt gt of ob og oh aw oi bi"><span id="3c25" class="ms lq in ob b gy oj ok l ol om">               Facade class<br/>                 * instance_one = newA()<br/>                 * instance_two = newB()<br/>               <br/>                  methodA()<br/>                     instance_one.callA()<br/>                     instance_two.callAA()<br/>                  <br/>                  methodB()<br/>                     instance_one.callB()<br/>                     instance_two.callBB()</span><span id="2a41" class="ms lq in ob b gy on ok l ol om">interface A                         interface B<br/>    |                                   |<br/>class newA implements A             class newB implements B<br/>    * callA()                          * callAA()<br/>    * callB()                          * callBB()</span></pre><p id="f31d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我希望你得到了这个粗略的图表(我将在指定的部分进行代码运行)🤘</p><ul class=""><li id="5f9e" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">如果你需要访问那些底层组件的方法-&gt;你可以自由使用它们</li><li id="175d" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">我们<strong class="jm io">将</strong> <em class="nm">客户端</em>通过<strong class="jm io">门面</strong>发出的请求与<em class="nm">系统</em>解耦。如果接口改变了，hand❓❓No 中的类的实现需要改变我们的客户(通常我们不能)，但是重新做<strong class="jm io"> Facade </strong>你就很棒了！💯</li></ul><blockquote class="nj nk nl"><p id="a272" class="jk jl nm jm b jn jo jp jq jr js jt ju nn jw jx jy no ka kb kc np ke kf kg kh ig bi translated"><strong class="jm io">外观</strong>不仅简化了接口，而且<strong class="jm io">将</strong>客户端从最终系统中解耦</p></blockquote><h2 id="4425" class="ms lq in bd lr mt mu dn lv mv mw dp lz jv mx my md jz mz na mh kd nb nc ml nd bi translated">要遵循的设计原则</h2><ol class=""><li id="011a" class="kr ks in jm b jn ne jr nf jv oc jz od kd oe kh nx kx ky kz bi translated">知识最少原则(德米特法则):只和你最亲近的朋友交谈🌝</li></ol><p id="35e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">简而言之，这意味着我们需要<strong class="jm io">非常清楚</strong>我们在开发系统时使用的类。也就是说，不要盲目地从其他类调用一些方法，因为这在 bugs🪲会适得其反</p><p id="9bd8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">错误方法调用</strong>的例子:</p><figure class="nq nr ns nt gt nu"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="d2cb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们在从另一个方法返回的实例上调用方法:</p><ol class=""><li id="7581" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh nx kx ky kz bi translated"><code class="fe ny nz oa ob b">getThermometer()</code>返回实例</li><li id="1cd2" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nx kx ky kz bi translated">我们从<code class="fe ny nz oa ob b">1</code>打电话给<code class="fe ny nz oa ob b">getTemperature()</code></li></ol><p id="f520" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">调用方法时的准则:</p><ol class=""><li id="5901" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh nx kx ky kz bi translated">来自同一个班级</li><li id="8440" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nx kx ky kz bi translated">来自当前类的组件</li><li id="5dac" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nx kx ky kz bi translated">从传入方法的参数(可能是对象)</li><li id="8a21" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nx kx ky kz bi translated">从方法中创建/实例化的对象</li></ol><p id="bfe6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">‼️Danger:‼️不会在方法内部调用另一个方法返回的对象上调用方法。它增加了与方法/类相关的<strong class="jm io">朋友</strong>的数量，这在我们的例子中是不好的(参见上面的例子)</p><p id="3c92" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我在实践中向你展示一切是如何工作的:</p><figure class="nq nr ns nt gt nu"><div class="bz fp l di"><div class="nv nw l"/></div></figure><ol class=""><li id="f146" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh nx kx ky kz bi translated">主类是<code class="fe ny nz oa ob b">Car</code>，在这里我们触发<code class="fe ny nz oa ob b">start()</code>方法</li><li id="1b0d" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nx kx ky kz bi translated">下面我们来分解一下方法是如何在方法中被调用的:<br/> *第 30 行:对提供给方法<br/>的<strong class="jm io">参数</strong>使用方法*第 32 行:对类的组件使用方法，<strong class="jm io">引擎</strong> <br/> *第 33 行:使用当前类的方法，<code class="fe ny nz oa ob b">Car</code> <br/> *第 34 行:使用在方法中创建/实例化的类的方法</li></ol><p id="552f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">最后</strong>，让我向你展示如何修改上面的方法调用(糟糕的例子)🎉：</p><figure class="nq nr ns nt gt nu"><div class="bz fp l di"><div class="nv nw l"/></div></figure><ol class=""><li id="88e8" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh nx kx ky kz bi translated">我们调用<code class="fe ny nz oa ob b">giveHouseTemperature()</code>，但是我们不能盲目地在<code class="fe ny nz oa ob b">currentStation</code>上调用方法&amp;然后马上在<code class="fe ny nz oa ob b">thermometer</code>上调用。因此我们<strong class="jm io">解耦</strong>调用</li><li id="20d3" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nx kx ky kz bi translated">首先从<code class="fe ny nz oa ob b">currentStation</code>中取出温度计:在当前<strong class="jm io">类组件</strong>上使用方法</li><li id="fa16" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nx kx ky kz bi translated">然后在我们提供<strong class="jm io">温度计</strong>实例的类中调用<strong class="jm io">方法</strong></li><li id="ac0e" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nx kx ky kz bi translated">在提供给该方法的<strong class="jm io">参数上调用<code class="fe ny nz oa ob b">giveTemperature()</code></strong></li><li id="b4f5" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nx kx ky kz bi translated">最后，结果被返回到之前的方法，然后返回给我们🙌🏼</li></ol><h2 id="57e5" class="ms lq in bd lr mt mu dn lv mv mw dp lz jv mx my md jz mz na mh kd nb nc ml nd bi translated">额外部分:两个</h2><ol class=""><li id="e588" class="kr ks in jm b jn ne jr nf jv oc jz od kd oe kh nx kx ky kz bi translated"><strong class="jm io">最小知识原则</strong>用于<strong class="jm io">门面模式</strong> : <br/> *客户端只与门面交互:好东西(一个朋友)</li><li id="3770" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nx kx ky kz bi translated">系统代码可以升级而不影响<strong class="jm io">客户端</strong>(如果我们不改变<strong class="jm io">接口</strong>的东西。如果是这样，只有<strong class="jm io">立面</strong>会改变)</li><li id="ceeb" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nx kx ky kz bi translated">如果<strong class="jm io">门面</strong>本身混杂而失去了上述<em class="nm">原则</em>:在我们的主<strong class="jm io">门面</strong>内添加额外的<strong class="jm io">门面</strong>图案</li></ol><h2 id="9be2" class="ms lq in bd lr mt mu dn lv mv mw dp lz jv mx my md jz mz na mh kd nb nc ml nd bi translated">最终解决方案代码:两种模式</h2><p id="ceba" class="pw-post-body-paragraph jk jl in jm b jn ne jp jq jr nf jt ju jv ng jx jy jz nh kb kc kd ni kf kg kh ig bi translated">让我们浏览一下代码🤟🏼</p><ul class=""><li id="13c5" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">首先我们有<strong class="jm io">适配器</strong>模式:</li></ul><div class="oo op gp gr oq or"><a href="https://github.com/SleeplessChallenger/KotlinDesignPatterns/tree/main/src/main/kotlin/7_Adapter_Facade/Adapter" rel="noopener  ugc nofollow" target="_blank"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd io gy z fp ow fr fs ox fu fw im bi translated">KotlinDesignPatterns/src/main/kotlin/7 _ Adapter _ Facade/Adapter at main…</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">O'Reilly 设计模式在 Kotlin 的实现。为 sleep less challenger/KotlinDesignPatterns 开发做出贡献…</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">github.com</p></div></div><div class="pa l"><div class="pb l pc pd pe pa pf pg or"/></div></div></a></div><ol class=""><li id="06ea" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh nx kx ky kz bi translated"><code class="fe ny nz oa ob b">main.kt</code>封装了我们的客户<strong class="jm io">的请求</strong>。在这里，我们创建我们的最终对象，并封装到实现<strong class="jm io">目标接口</strong>的<strong class="jm io">适配器</strong>中</li><li id="c0d9" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nx kx ky kz bi translated">所以，<code class="fe ny nz oa ob b">TargetInterface.kt</code>是最初的接口。<code class="fe ny nz oa ob b">Target.kt</code>是我们实现的类</li><li id="b9bc" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nx kx ky kz bi translated"><code class="fe ny nz oa ob b">AdapteeInterface.kt</code>是我们新的代码接口&amp; <code class="fe ny nz oa ob b">Adaptee.kt</code>是我们新实现的类</li><li id="0583" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nx kx ky kz bi translated"><code class="fe ny nz oa ob b">Adapter.kt</code>是我们的<strong class="jm io">适配器</strong>，它再次实现了<strong class="jm io">旧的</strong>接口，因此公开了它的方法。但是我们向<strong class="jm io">适配器</strong>提供了我们的<strong class="jm io">新</strong>实例，这样我们就可以从公开的方法中调用实例上的那些方法<em class="nm"/></li></ol><p id="a6b1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我希望你得到了结构。如果有事不点击-&gt;写在 comments✌🏼</p><ul class=""><li id="0f77" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">现在我们转移到<strong class="jm io">门面</strong>模式:</li></ul><div class="oo op gp gr oq or"><a href="https://github.com/SleeplessChallenger/KotlinDesignPatterns/tree/main/src/main/kotlin/7_Adapter_Facade/Facade" rel="noopener  ugc nofollow" target="_blank"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd io gy z fp ow fr fs ox fu fw im bi translated">KotlinDesignPatterns/src/main/kotlin/7 _ Adapter _ Facade/Facade at main…</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">O'Reilly 设计模式在 Kotlin 的实现。为 sleep less challenger/KotlinDesignPatterns 开发做出贡献…</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">github.com</p></div></div><div class="pa l"><div class="ph l pc pd pe pa pf pg or"/></div></div></a></div><ol class=""><li id="a85f" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh nx kx ky kz bi translated"><code class="fe ny nz oa ob b">ProjectorInterface.kt</code> &amp; <code class="fe ny nz oa ob b">AmplifierInterface.kt</code>都是来自系统的接口</li><li id="64d1" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nx kx ky kz bi translated"><code class="fe ny nz oa ob b">Projector.kt</code> &amp; <code class="fe ny nz oa ob b">Amplifier.kt</code>是<strong class="jm io">从上面实现</strong>接口的具体类</li><li id="8571" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nx kx ky kz bi translated"><code class="fe ny nz oa ob b">OurFacade.kt</code>是<strong class="jm io">门面</strong>本身，其<strong class="jm io">将</strong>系统从客户端请求中解耦</li><li id="eeac" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nx kx ky kz bi translated"><code class="fe ny nz oa ob b">main.kt</code>是我们客户的要求。我们向<strong class="jm io"> Facade </strong>提供类的实例。它有现在由客户端拉的方法。在这些方法中，我们有调用它的方法的实例</li></ol><blockquote class="nj nk nl"><p id="7eca" class="jk jl nm jm b jn jo jp jq jr js jt ju nn jw jx jy no ka kb kc np ke kf kg kh ig bi translated">同样，如果系统的<strong class="jm io">接口</strong>发生变化(类的<strong class="jm io">实现</strong>也发生变化)，我们不需要对<strong class="jm io">客户端-系统</strong>的东西进行大的修改，只需要调整<strong class="jm io">外观</strong></p></blockquote><h2 id="73da" class="ms lq in bd lr mt mu dn lv mv mw dp lz jv mx my md jz mz na mh kd nb nc ml nd bi translated">图画🎨</h2><figure class="nq nr ns nt gt nu gh gi paragraph-image"><div role="button" tabindex="0" class="pj pk di pl bf pm"><div class="gh gi pi"><img src="../Images/f4629a6671cccc6130cee6160169e97c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pl2t85MRBSoLkVmilp5a1g.jpeg"/></div></div></figure><p id="1a5e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在图片上你可以看到:</p><ul class=""><li id="a443" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">左侧是<strong class="jm io">适配器图案</strong></li><li id="1b25" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">右侧是<strong class="jm io">立面图案</strong></li></ul><p id="2ffb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是一个有点乱，但希望你得到了要点💫</p><h2 id="6791" class="ms lq in bd lr mt mu dn lv mv mw dp lz jv mx my md jz mz na mh kd nb nc ml nd bi translated">Outro✌🏼</h2><blockquote class="nj nk nl"><p id="3fed" class="jk jl nm jm b jn jo jp jq jr js jt ju nn jw jx jy no ka kb kc np ke kf kg kh ig bi translated"><strong class="jm io">适配器模式</strong>的学术定义:适配器作为一个中间人，将我们现在系统中的接口转换成客户期望的接口(即之前已经在我们的系统中)。适配器让那些由于不兼容而没有(客户端&amp;我们的最终代码)就无法协同工作的类协同工作</p><p id="9549" class="jk jl nm jm b jn jo jp jq jr js jt ju nn jw jx jy no ka kb kc np ke kf kg kh ig bi translated"><strong class="jm io">门面模式</strong>的学术定义:它为系统中的一组接口(已实现)提供统一的接口/访问点。Facade 是一个高级接口(实际上，它不是一个接口，而是一个类，但在经典术语中是这么说的)，它简化了与低级系统的交互</p></blockquote><p id="6326" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">哇，信息量真大！🤯仔细再读一遍，如果有模糊的地方，在评论中提问💬</p><p id="2712" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以找到我:</p><ul class=""><li id="a20c" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">领英:<a class="ae la" href="http://www.linkedin.com/in/sleeplesschallenger" rel="noopener ugc nofollow" target="_blank">www.linkedin.com/in/sleeplesschallenger</a></li><li id="e8fe" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">GitHub:【https://github.com/SleeplessChallenger T2】</li><li id="b061" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">leet code:【https://leetcode.com/SleeplessChallenger/】T4</li><li id="f12b" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">电报:@无眠挑战者</li></ul></div></div>    
</body>
</html>