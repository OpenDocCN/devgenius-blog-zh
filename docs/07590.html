<html>
<head>
<title>Sealed Classes vs Enum Classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">密封类与枚举类</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/sealed-classes-vs-enum-classes-274a0b19cde0?source=collection_archive---------0-----------------------#2022-04-08">https://blog.devgenius.io/sealed-classes-vs-enum-classes-274a0b19cde0?source=collection_archive---------0-----------------------#2022-04-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="b365" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">定义、差异和用例</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8c7ec7be9e319615e70a94bddf839c41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BJNttw1jT2_tO2fhOetXUQ.jpeg"/></div></div></figure><p id="d7b1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本文旨在解释以下事项:</p><ul class=""><li id="d557" class="ku kv in jm b jn jo jr js jv kw jz kx kd ky kh kz la lb lc bi translated">枚举的定义</li><li id="4cdd" class="ku kv in jm b jn ld jr le jv lf jz lg kd lh kh kz la lb lc bi translated">枚举的需要</li><li id="6ad6" class="ku kv in jm b jn ld jr le jv lf jz lg kd lh kh kz la lb lc bi translated">如何以及何时使用枚举？</li><li id="df01" class="ku kv in jm b jn ld jr le jv lf jz lg kd lh kh kz la lb lc bi translated">向枚举添加构造函数参数</li><li id="a7a8" class="ku kv in jm b jn ld jr le jv lf jz lg kd lh kh kz la lb lc bi translated">枚举支持的一些方法</li><li id="83d7" class="ku kv in jm b jn ld jr le jv lf jz lg kd lh kh kz la lb lc bi translated">枚举的项目特定性质</li><li id="4e98" class="ku kv in jm b jn ld jr le jv lf jz lg kd lh kh kz la lb lc bi translated">when 块中枚举的用法</li><li id="7ee6" class="ku kv in jm b jn ld jr le jv lf jz lg kd lh kh kz la lb lc bi translated">密封类的定义</li><li id="f8b4" class="ku kv in jm b jn ld jr le jv lf jz lg kd lh kh kz la lb lc bi translated">密封类中支持的构造函数可见性</li><li id="8ea7" class="ku kv in jm b jn ld jr le jv lf jz lg kd lh kh kz la lb lc bi translated">展示密封类优于枚举的用例</li></ul><h1 id="47da" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">枚举</h1><p id="0219" class="pw-post-body-paragraph jk jl in jm b jn mg jp jq jr mh jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh ig bi translated">当我们必须表示一组不变的可能选项时，一个经典的选择是使用枚举。如果您曾经使用不同的常量来表示一个进程的不同状态，您可能想知道为什么首先使用枚举？我们就不能用不同的字符串常量吗？</p><h2 id="324e" class="ml lj in bd lk mm mn dn lo mo mp dp ls jv mq mr lw jz ms mt ma kd mu mv me mw bi translated">首先为什么是枚举？</h2><p id="2d88" class="pw-post-body-paragraph jk jl in jm b jn mg jp jq jr mh jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh ig bi translated">在 StackOverflow 上有一个很好的答案解释了这个概念:【https://stackoverflow.com/a/11575421/5742365】<a class="ae mx" href="https://stackoverflow.com/a/11575421/5742365" rel="noopener ugc nofollow" target="_blank">T2</a></p><p id="4c95" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的回答是这样说的:</p><p id="b378" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">假设您使用常量字符串(或<code class="fe my mz na nb b">int</code>值——同样适用于它们):</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="1477" class="ml lj in nb b gy ng nh l ni nj">// Constants for player types<br/>public static final String ARCHER = "Archer";<br/>public static final String WARRIOR = "Warrior";</span><span id="7469" class="ml lj in nb b gy nk nh l ni nj">// Constants for genders<br/>public static final String MALE = "Male";<br/>public static final String FEMALE = "Female";</span></pre><p id="d684" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后，您最终无法真正了解您的数据类型，从而导致潜在的不正确代码:</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="1fe7" class="ml lj in nb b gy ng nh l ni nj">String playerType = Constants.MALE;</span></pre><p id="d4aa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果使用枚举，结果会是:</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="0447" class="ml lj in nb b gy ng nh l ni nj">// Compile-time error - incompatible types!<br/>PlayerType playerType = Gender.MALE;</span></pre><p id="d8b8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">同样，枚举给出了一组有限的值:</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="6be2" class="ml lj in nb b gy ng nh l ni nj">String playerType = "Fred"; // Hang on, that's not one we know about...</span></pre><p id="9809" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">相对</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="615e" class="ml lj in nb b gy ng nh l ni nj">PlayerType playerType = "Fred"; // Nope, that doesn't work. Bang!</span></pre><p id="b6e3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，Java 中的枚举可以有更多的相关信息，也可以有行为。各方面都好多了。</p><h2 id="21ac" class="ml lj in bd lk mm mn dn lo mo mp dp ls jv mq mr lw jz ms mt ma kd mu mv me mw bi translated">如何以及何时使用枚举？</h2><p id="186e" class="pw-post-body-paragraph jk jl in jm b jn mg jp jq jr mh jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh ig bi translated">假设我们想要表示一周中的几天，我们可以如下定义一个枚举:</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="72a0" class="ml lj in nb b gy ng nh l ni nj">enum class Weekday<br/>{<br/>  MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY<br/>}</span></pre><h2 id="c830" class="ml lj in bd lk mm mn dn lo mo mp dp ls jv mq mr lw jz ms mt ma kd mu mv me mw bi translated">枚举中的构造函数参数</h2><p id="a7dd" class="pw-post-body-paragraph jk jl in jm b jn mg jp jq jr mh jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh ig bi translated">我们还可以向 enum 类添加构造函数参数。假设我们需要一个 enum 类来表示一组颜色。考虑到它们的 RGB 颜色代码，每种颜色可以具有它们自己的红色、绿色和蓝色比率。看看下面的例子:</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="4922" class="ml lj in nb b gy ng nh l ni nj">enum class Color(open val red: Int, val green: Int, open val blue: Int) {<br/>    <em class="nl">RED</em>(255, 0, 0),<br/>    <em class="nl">GREEN</em>(0, 255, 0),<br/>    <em class="nl">BLUE</em>(0, 0, 255);<br/>}</span></pre><p id="eff9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">enum 类中的方法也可以由任何 enum 常量重写。在下面的代码片段中，我们覆盖了红色案例中的 getRed()方法。</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="591f" class="ml lj in nb b gy ng nh l ni nj">enum class Color(open val red: Int, val green: Int, open var blue: Int) {<br/>    <em class="nl">RED</em>(255, 0, 0) {<br/>        override var red  = 200<br/>        override var blue = 55<br/><br/>        val test: String<br/>            get() = "Test"<br/>    },<br/>    <em class="nl">GREEN</em>(0, 255, 0),<br/>    <em class="nl">BLUE</em>(0, 0, 255);<br/>}</span></pre><p id="0867" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我还在 RED 中添加了一个<code class="fe my mz na nb b">test</code>属性。但是我们无法访问该属性。如果我们尝试这样做，属性将不会被识别。这是因为在枚举情况下，我们只能覆盖类的方法或属性。我们不能定义新的方法或属性并使用它们。</p><p id="e330" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每个枚举用例使用与类构造函数中定义的相同的构造函数参数集。我们不能像普通类一样实例化枚举类。举个例子，</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="f8ed" class="ml lj in nb b gy ng nh l ni nj">val color = Color() </span></pre><p id="f443" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不适用于上述枚举类。我们只能在 enum 类中使用 cases。</p><h2 id="564f" class="ml lj in bd lk mm mn dn lo mo mp dp ls jv mq mr lw jz ms mt ma kd mu mv me mw bi translated">枚举类支持的一些方法</h2><p id="696e" class="pw-post-body-paragraph jk jl in jm b jn mg jp jq jr mh jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh ig bi translated">可以使用上面的枚举类，如下例所示:</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="1346" class="ml lj in nb b gy ng nh l ni nj">fun main() {<br/>    val color = Color.<em class="nl">BLUE<br/>    println</em>(color.name)<br/>    <em class="nl">println</em>(color.blue)<br/><br/>    <em class="nl">println</em>()<br/>    <br/>    <em class="nl">println</em>(Color.<em class="nl">RED</em>.red)<br/>    <em class="nl">println</em>(Color.<em class="nl">RED</em>.blue)<br/>    <em class="nl">println</em>(Color.<em class="nl">RED</em>.green)<br/><br/>    <em class="nl">println</em>()<br/><br/>    val colors = Color.values()<br/><br/>    for(c in colors)<br/>        <em class="nl">println</em>("${c.ordinal} : ${c.name}")<br/>}</span><span id="5256" class="ml lj in nb b gy nk nh l ni nj"><strong class="nb io">Output</strong>:<br/>BLUE<br/>255</span><span id="b99b" class="ml lj in nb b gy nk nh l ni nj">200<br/>55<br/>0</span><span id="435b" class="ml lj in nb b gy nk nh l ni nj">0 : RED<br/>1 : GREEN<br/>2 : BLUE</span></pre><p id="7393" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">摆弄上面的例子可以更好地理解枚举。</p><h2 id="4cac" class="ml lj in bd lk mm mn dn lo mo mp dp ls jv mq mr lw jz ms mt ma kd mu mv me mw bi translated">枚举是特定于项目的</h2><p id="a0e1" class="pw-post-body-paragraph jk jl in jm b jn mg jp jq jr mh jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh ig bi translated">枚举可以保存的值总是特定于项的。举个例子，</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="15d7" class="ml lj in nb b gy ng nh l ni nj">val red = Color.<em class="nl">RED<br/></em>val red2 = Color.<em class="nl">RED<br/>println</em>(red == red2) //prints true</span><span id="e824" class="ml lj in nb b gy nk nh l ni nj">red2.blue = 25<br/><em class="nl">println</em>(red.blue) //prints 25</span></pre><h2 id="597a" class="ml lj in bd lk mm mn dn lo mo mp dp ls jv mq mr lw jz ms mt ma kd mu mv me mw bi translated">when 块中枚举的用法</h2><p id="e06a" class="pw-post-body-paragraph jk jl in jm b jn mg jp jq jr mh jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh ig bi translated">在 kotlin 的<code class="fe my mz na nb b">when</code>中可以使用枚举。<code class="fe my mz na nb b">when</code>既可以做陈述，也可以做表达式。</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="373f" class="ml lj in nb b gy ng nh l ni nj">when(color) {<br/>    Color.<em class="nl">RED </em>-&gt; <em class="nl">println</em>("The color is red: ${color.red}, ${color.green}, ${color.blue}")<br/>    Color.<em class="nl">GREEN </em>-&gt; <em class="nl">println</em>("The color is green: ${color.red}, ${color.green}, ${color.blue}")<br/>}</span></pre><p id="1575" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的代码片段中，when 用作语句。所以它忽略了我们错过了颜色的事实。蓝色或其他区块。</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="6a1d" class="ml lj in nb b gy ng nh l ni nj">val answer = when(color) {<br/>    Color.<em class="nl">RED </em>-&gt; "The color is red: ${color.red}, ${color.green}, ${color.blue}"<br/>    Color.<em class="nl">GREEN </em>-&gt; "The color is green: ${color.red}, ${color.green}, ${color.blue}"<br/>}</span></pre><p id="f6cd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的代码片段中，when 用作表达式。这次它显示了一个编译器错误，因为必须给变量<code class="fe my mz na nb b">answer</code>赋值。<code class="fe my mz na nb b">when</code>表达必须面面俱到。所以我们必须添加一个 else 块或者<code class="fe my mz na nb b">Color.BLUE</code>。</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="1524" class="ml lj in nb b gy ng nh l ni nj">val answer = when(color) {<br/>    Color.<em class="nl">RED </em>-&gt; "The color is red: ${color.red}, ${color.green}, ${color.blue}"<br/>    Color.<em class="nl">GREEN </em>-&gt; "The color is green: ${color.red}, ${color.green}, ${color.blue}"<br/>    Color.<em class="nl">BLUE </em>-&gt; "The color is blue: ${color.red}, ${color.green}, ${color.blue}"<br/>}<br/><em class="nl">println</em>(answer)</span></pre><p id="e1a1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们涵盖了 when 表达式中枚举类的所有情况，我们就不需要添加 else 块。即使我们添加了，也会被编译器认为是多余的。它还警告我们- <code class="fe my mz na nb b">when</code>是详尽的，所以<code class="fe my mz na nb b">else</code>在这里是多余的。</p><h1 id="964b" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">密封类</h1><p id="02fa" class="pw-post-body-paragraph jk jl in jm b jn mg jp jq jr mh jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh ig bi translated">Kotlin 中的密封类是另一个我们在 Java 中没有的新概念，它打开了另一个可能性的新世界。</p><p id="e301" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一个密封的类允许你<strong class="jm io">表示受约束的层次结构，其中一个对象只能是一个给定的类型</strong>。</p><p id="9c68" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">也就是说，我们有一个包含特定数量子类的类。在某种意义上，密封类类似于<code class="fe my mz na nb b"><a class="ae mx" href="https://kotlinlang.org/docs/enum-classes.html" rel="noopener ugc nofollow" target="_blank">enum</a></code>类:枚举类型的值集也是受限制的，但是每个枚举常量只作为<em class="nl">单个实例</em>存在，而密封类的子类可以有<em class="nl">多个</em>实例，每个实例都有自己的状态。</p><p id="d368" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">举个例子，考虑一个库的 API。它可能包含错误类，让库用户处理它可能抛出的错误。如果这种错误类的层次结构包括在公共 API 中可见的接口或抽象类，那么没有什么可以阻止在客户端代码中实现或扩展它们。然而，这个库不知道在它之外声明的错误，所以它不能用自己的类一致地对待它们。使用错误类的密封层次结构，库作者可以确保他们知道所有可能的错误类型，并且以后不会出现其他错误类型。</p><p id="b906" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每个子类可以有自己的构造函数参数集，这在枚举的情况下是不可能的。</p><p id="4176" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个差异<strong class="jm io">将允许来自密封类的对象保持状态</strong>。这将给我们带来一些优势，我们将在下面看到。</p><p id="b187" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">密封一个类会限制它的类层次结构。当您将一个类标记为<code class="fe my mz na nb b">sealed</code>时，您只能从指定的位置对其进行子类化。密封类的所有直接子类在编译时都是已知的。这允许您限制子类以进行详尽的评估。</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="2337" class="ml lj in nb b gy ng nh l ni nj"><strong class="nb io">sealed</strong> <strong class="nb io">class</strong> Error  <br/><strong class="nb io">sealed</strong> <strong class="nb io">class</strong> IOError(): Error  // extended only in same package and module<br/><strong class="nb io">class</strong> FileReadError(<strong class="nb io">val</strong> file: File): IOError() <br/><strong class="nb io">class</strong> DatabaseError(<strong class="nb io">val</strong> source: DataSource): IOError()  <br/><strong class="nb io">object</strong> RuntimeError : Error</span></pre><p id="2f7a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这些限制不适用于间接子类。如果密封类的直接子类没有被标记为密封的，那么它可以以其修饰符允许的任何方式进行扩展:</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="680d" class="ml lj in nb b gy ng nh l ni nj"><strong class="nb io">sealed</strong> <strong class="nb io">interface</strong> Error // has implementations only in same package and module<br/><br/><strong class="nb io">sealed</strong> <strong class="nb io">class</strong> IOError(): Error // extended only in same package and module<br/><strong class="nb io">open</strong> <strong class="nb io">class</strong> CustomError(): Error // can be extended wherever it's visible</span></pre><h2 id="bd73" class="ml lj in bd lk mm mn dn lo mo mp dp ls jv mq mr lw jz ms mt ma kd mu mv me mw bi translated">密封类中构造函数的可见性</h2><p id="d09c" class="pw-post-body-paragraph jk jl in jm b jn mg jp jq jr mh jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh ig bi translated">密封类的构造函数可以有两种<a class="ae mx" href="https://kotlinlang.org/docs/visibility-modifiers.html" rel="noopener ugc nofollow" target="_blank">可见性</a> : <code class="fe my mz na nb b">protected</code>(默认)或<code class="fe my mz na nb b">private</code>:</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="d24a" class="ml lj in nb b gy ng nh l ni nj"><strong class="nb io">sealed</strong> <strong class="nb io">class</strong> IOError {     <br/>    <strong class="nb io">constructor</strong>() { /*...*/ } // protected by default     <br/>    <strong class="nb io">private</strong> <strong class="nb io">constructor</strong>(description: String): <strong class="nb io">this</strong>() { /*...*/ } // private is OK     <br/>    // public constructor(code: Int): this() {} // Error: public and internal are not allowed <br/>}</span></pre><h2 id="9819" class="ml lj in bd lk mm mn dn lo mo mp dp ls jv mq mr lw jz ms mt ma kd mu mv me mw bi translated">展示密封类优于枚举的用例</h2><p id="683a" class="pw-post-body-paragraph jk jl in jm b jn mg jp jq jr mh jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh ig bi translated">密封类的子类可以有不同的构造函数参数集。举个例子，</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="1a10" class="ml lj in nb b gy ng nh l ni nj">sealed class Response&lt;out R&gt;<br/>class Success&lt;R&gt;(val value: R): Response&lt;R&gt;()<br/>class Failure(val error: Throwable): Response&lt;Nothing&gt;()</span><span id="6142" class="ml lj in nb b gy nk nh l ni nj">fun handle(response: Response&lt;String&gt;) {    <br/>    val text = when (response) {        <br/>        is Success -&gt; "Success, data are: " + response.valuei<br/>        is Failure -&gt; "Error"    <br/>    }    <br/>    print(text)<br/>}</span></pre><p id="81f3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就像在枚举中的<code class="fe my mz na nb b">when</code>一样，<code class="fe my mz na nb b">when</code>作为一个语句是不详尽的，但是<code class="fe my mz na nb b">when</code>作为一个表达式在密封类中也是详尽的。</p><p id="e2cb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">密封类也可以有所有的对象声明子类，当以这种方式使用时，它非常类似于枚举:</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="9b1c" class="ml lj in nb b gy ng nh l ni nj">sealed class PaymentOption {    <br/>     object Cash    <br/>     object Card    <br/>     object Transfer<br/>}</span></pre><p id="c41b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">虽然<strong class="jm io">我们不这样使用密封类</strong>，因为枚举更适合这种情况。</p><p id="adfb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">相对于 enum，密封类的优势在于子类可以保存特定于实例的数据。例如，当我们向应用程序的另一部分通知所选择的支付选项时，我们可以传递所选择的支付类型和特定于支付的数据，这些数据是后续处理所需要的。</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="d66d" class="ml lj in nb b gy ng nh l ni nj">import java.math.BigDecimal </span><span id="00ce" class="ml lj in nb b gy nk nh l ni nj">sealed class Paymentdata </span><span id="8be3" class="ml lj in nb b gy nk nh l ni nj">class CashPayment(val amount: BigDecimal, val pointId: Int): Payment()</span><span id="2677" class="ml lj in nb b gy nk nh l ni nj">data class CardPayment(val amount: BigDecimal, val orderId: Int): Payment()</span><span id="64f7" class="ml lj in nb b gy nk nh l ni nj">data class BankTransfer(val amount: BigDecimal, val orderId: Int): Payment() </span><span id="95d3" class="ml lj in nb b gy nk nh l ni nj">fun process(payment: Payment) {    <br/>    when (payment) {        <br/>        is CashPayment -&gt; { <br/>            showPaymentInfo(payment.amount, payment.pointId) <br/>        }<br/>        is CardPayment -&gt; {            <br/>            moveToCardPaiment(payment.amount, payment.orderId)   <br/>        }        <br/>        is BankTransfer -&gt; {            <br/>            val bankTransferRepo = BankTransferRepo()            <br/>            val transferDetails = bankTransferRepo.getDetails()<br/>            displayTransferInfo(payment.amount, transferDetails)<br/>            bankTransferRepo.setUpPaymentWathcher(payment.orderId,<br/>            payment.amount, transferDetails)        <br/>        }    <br/>    }<br/>}</span></pre><p id="ba2a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">密封类的一个很好的例子是表示各种各样的事件或消息，因为我们既有事件是什么的信息，又有每个事件可以保存数据。</p><p id="3726" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">枚举类表示一组具体的值，而密封类表示一组具体的类。由于那些类可以是对象声明，我们可以在一定程度上使用密封类来代替枚举，但不能反过来。</p><p id="c2e8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">枚举类的优点是它们可以被序列化和反序列化。他们有方法<code class="fe my mz na nb b">values()</code>和<code class="fe my mz na nb b">valueOf</code>。我们还可以使用<code class="fe my mz na nb b">enumValues</code>和<code class="fe my mz na nb b">enumValueOf</code>函数通过类型获取枚举值。枚举有序数，我们可以通过每一项来保存常量数据。它们非常适合表示一组恒定的可能值。</p><p id="a037" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">密封类的优点是它们可以保存特定于实例的数据。每个项目可以是一个类，也可以是一个对象(使用对象声明创建)。它们代表一组可选类(和类型、余积)。它们对定义替代项很有用，<code class="fe my mz na nb b">Result</code>要么是<code class="fe my mz na nb b">Success</code>要么是<code class="fe my mz na nb b">Failure</code>，<code class="fe my mz na nb b">Tree</code>要么是<code class="fe my mz na nb b">Leaf</code>要么是<code class="fe my mz na nb b">Node</code>，或者 JSON 值要么是列表、对象、字符串、布尔、int 或 null。它们对于定义一组可能发生的事件或消息也非常有用。</p><h2 id="5ab2" class="ml lj in bd lk mm mn dn lo mo mp dp ls jv mq mr lw jz ms mt ma kd mu mv me mw bi translated">参考</h2><p id="c251" class="pw-post-body-paragraph jk jl in jm b jn mg jp jq jr mh jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh ig bi translated">这篇博文中的一些例子和解释摘自</p><div class="nm nn gp gr no np"><a href="https://kotlinlang.org/docs/sealed-classes.html#location-of-direct-subclasses" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd io gy z fp nu fr fs nv fu fw im bi translated">密封类| Kotlin</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">密封的类和接口代表了对继承提供更多控制的受限类层次结构。所有…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">kotlinlang.org</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od ks np"/></div></div></a></div><p id="430e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">和</p><div class="nm nn gp gr no np"><a href="https://blog.kotlin-academy.com/enum-vs-sealed-class-which-one-to-choose-dc92ce7a4df5" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd io gy z fp nu fr fs nv fu fw im bi translated">枚举与密封类——选择哪一个？</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">TL；DR:枚举有像 valueOf，values 或 enumValues 这样的支持函数，这使得它们更容易迭代或…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">blog.kotlin-academy.com</p></div></div><div class="ny l"><div class="oe l oa ob oc ny od ks np"/></div></div></a></div><p id="a1ea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">希望这篇文章能帮助你更好地理解枚举和密封类的不同用例。</p><h1 id="1810" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">快乐学习！</h1></div></div>    
</body>
</html>