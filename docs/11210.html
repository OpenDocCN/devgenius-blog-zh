<html>
<head>
<title>Time Series ARIMA algorithm to forecast almost 500 stocks from S&amp;P 500 index</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">时间序列 ARIMA 算法预测标准普尔 500 指数近 500 只股票</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/using-arima-algorithm-to-forecast-almost-500-stocks-from-s-p-500-index-443679e6f41e?source=collection_archive---------5-----------------------#2022-12-25">https://blog.devgenius.io/using-arima-algorithm-to-forecast-almost-500-stocks-from-s-p-500-index-443679e6f41e?source=collection_archive---------5-----------------------#2022-12-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="1f38" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">一种使用 Pycaret lib、beta 方差和 yahoo finance 生成指标以构成未来股票投资组合的方法。</h2></div><p id="a53e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我想预测和验证哪些股票的未来可能价值比其他股票风险小；基于此；我能识别一些经济理论和统计指标；在这篇文章中，我将分享一些片段，这些片段可以提供<strong class="ke io">见解</strong>来玩股票预测，更准确地说是一个叫做<a class="ae ky" href="https://www.investopedia.com/terms/a/autoregressive-integrated-moving-average-arima.asp" rel="noopener ugc nofollow" target="_blank"> uto 回归综合移动平均线</a> (ARIMA)的时间序列模型。</p></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><p id="6eea" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"/>在发现澳洲之前，旧世界的人们相信所有的天鹅都是白色的，这是一个不容置疑的信念，因为它似乎完全被经验证据所证实。<strong class="ke io">、</strong> <a class="ae ky" href="https://www.nytimes.com/2007/04/22/books/chapters/0422-1st-tale.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io">纳西姆·尼古拉斯·塔勒布</strong> </a></p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div class="gh gi lh"><img src="../Images/754417c093356419fb45f85bd5c9a126.png" data-original-src="https://miro.medium.com/v2/resize:fit:1318/format:webp/1*XGGliZVvTxfOuHI2g5OHfg.png"/></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">字体:<a class="ae ky" href="https://sketchplanations.com/black-swan" rel="noopener ugc nofollow" target="_blank">https://sketchplanations.com/black-swan</a></figcaption></figure><p id="b448" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我意识到股票有黑天鹅，像 covid，乌克兰战争，Elon Musk，以及其他可以扰乱常态的情况，并以某种方式改变股票的方差行为。基于此，我开始四处寻找一些股票的风险管理系统，我发现了一个有趣的方法，叫做<a class="ae ky" href="http://capital%20asset%20pricing%20model%20-%20wikipedia/" rel="noopener ugc nofollow" target="_blank"> CAPM </a> <a class="ae ky" href="http://capital%20asset%20pricing%20model%20-%20wikipedia/" rel="noopener ugc nofollow" target="_blank"> —资本资产定价模型。</a></p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lt"><img src="../Images/4d9bff23c667c57dec38b62f3a94ce67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*REErQ4Hy2QxY6Te1b3k-hQ.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">标准普尔 500 指数——我们可以想象，在 2020 年中期，乔维德·疫情打破常规。</figcaption></figure><p id="d3e9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">CAPM 模型提供了一种叫做贝塔方差的理论。此功能可用于计算股票的系统风险，例如，通过比较股票和其他指数(如 S&amp;P500 指标)之间的方差。这一指标可以显示为一个因素，可用于根据某些指数选择不太不稳定的股票；更多细节，你可以查看这篇文章。</p></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><h1 id="0c81" class="ly lz in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated">不再多言，让我们深入数据！！</h1><p id="10cb" class="pw-post-body-paragraph kc kd in ke b kf mq jo kh ki mr jr kk kl ms kn ko kp mt kr ks kt mu kv kw kx ig bi translated">为了组织，我把这篇文章分成 6 个步骤来组织:取样、探索、修改、建模、总结。</p><p id="1f16" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所有这些步骤和代码都可以通过这个<a class="ae ky" href="https://github.com/gabrielhribeiro/PortifolioSP500" rel="noopener ugc nofollow" target="_blank"> git repo </a>获得。</p><p id="eff2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">样品</strong></p><p id="00d8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我们需要收集标准普尔 500 指数的股票。通过简单的网络搜集，我们将从维基百科页面收集 SP500 股票代码值。</p><pre class="li lj lk ll gt mv mw mx bn my mz bi"><span id="2f1a" class="na lz in mw b be nb nc l nd ne">#Identify after how much time they started at the SP500 after their foundation<br/>#Show how sectors are at the SP500<br/>#show quantity based on security<br/>#show GICS Sub-Industry<br/>#function to take stocks and values<br/>import pandas as pd<br/><br/>def returnstocks():<br/>    table=pd.read_html('https://en.wikipedia.org/wiki/List_of_S%26P_500_companies')<br/>    stocksdf = table[0]<br/>    stocksdf.to_csv('S&amp;P500-Info.csv')<br/>    stocksdf.to_csv("S&amp;P500-Symbols.csv", columns=['Symbol'])<br/>    stocksdf['Symbol'] = stocksdf['Symbol'].replace('.B','', regex=True)<br/>    return stocksdf<br/><br/>def eachstock():<br/>  myList = ['^GSPC']<br/>  for stick in returnstocks()['Symbol'].unique(): <br/>    myList.insert(0, stick)<br/>  return myList</span></pre><pre class="nf mv mw mx bn my mz bi"><span id="2393" class="na lz in mw b be nb nc l nd ne">tickers = ['^GSPC','ZTS','ZION','H','RA','YUM'..]</span></pre><p id="d12f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">函数 eachstock()将返回一个由 SP500 初始化的股票列表。</p></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><p id="0613" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">探索</strong></p><p id="afc9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在一些探索性分析中，我们可以确定 SP500 使用的主要部门，这些部门可以用来分散股票投资组合，因为分散风险越小，琐碎但重要的是避免特定部门的黑天鹅。</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi ng"><img src="../Images/83fbfcb47388bff4e07f92bd444eede0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fLQd_hTTwUJSk6sddjgzPg.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">SP500 地区</figcaption></figure><p id="8e07" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于这一步，我们使用来自<a class="ae ky" href="https://en.wikipedia.org/wiki/List_of_S%26P_500_companies" rel="noopener ugc nofollow" target="_blank">维基百科</a>的组件，并且我们将引入一个新的代理<a class="ae ky" href="https://pypi.org/project/yfinance/" rel="noopener ugc nofollow" target="_blank">雅虎金融</a>。雅虎财经有来自 https://finance.yahoo.com 的热门数据，我们可以利用这些数据来提高我们的决策能力，来创建股票投资组合。</p><pre class="li lj lk ll gt mv mw mx bn my mz bi"><span id="0c97" class="na lz in mw b be nb nc l nd ne">#@title Yahoo Finance request and beta/Alpha calculation<br/>#@markdown For this step, we are using the component from Wikipedia, and we are going to introduce a new agent, the yahoo finance. Yahoo Finance, has hot data from https://finance.yahoo.com, and we can use these data to improve our power to decision making, regarding to create a stocks portfolio.<br/><br/>yfin.pdr_override() #override method from pandas_datareader by importing data as pdr<br/><br/>tickers = eachstock()<br/><br/>#tickers = ['ZTS', 'ZION', '^GSPC']<br/><br/>#function for receive list of stocks, source where to search and initial date/lastdate<br/>def stockdoublebench_returns(ticker, initialdate, lastdate): #future change ticker for returnstocks()['Symbol'].unique()<br/>    stockdouble = yfin.download(ticker, initialdate, lastdate) #data = yf.download("SPY AAPL", period="max",)<br/>    return stockdouble['Adj Close']<br/><br/>#stockdoublebench_returns #run just this command to check the volatility of each one. <br/><br/>def stockdoublebench_percent(ticker, initialdate, lastdate): #future change ticker for returnstocks()['Symbol'].unique()<br/>    stockdoublepercent = yfin.download(ticker, initialdate, lastdate)<br/>    #return stockdouble['Adj Close']] #add this line to use the graph to compare the volatility<br/>    return stockdoublepercent['Adj Close'].pct_change()[1:]<br/><br/>#alpha, beta and stock<br/>abstocks = pd.DataFrame(columns=['Alpha', 'Beta', 'stocks']) #created dataframe<br/><br/>def alphabetastock(df, index): #Function for generate alpha and beta from stocks<br/>    for col in df: #for column in dataframe do<br/>        x = sm.add_constant(df[index].values) #create a matrix using 1 and the value<br/>        model = sm.regression.linear_model.OLS(df[col].values,x).fit() #linear regression to get values https://www.statsmodels.org/dev/generated/statsmodels.regression.linear_model.OLS.html<br/>        abstocks.loc[len(abstocks.index)] = [model.params[0], model.params[1], col] #add each value to the dataframe<br/>    return abstocks #model.params[0], model.params[1], col<br/><br/>#need to add a new line at the df for show the predicted values from each stock, and its important add the value<br/>#from the accuracy from test as well. </span></pre><p id="3ffb" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Dataframe <strong class="ke io"> abstocksna </strong>，返回值。阿尔法、贝塔和股票，关于贝塔和阿尔法的更多信息，请:查看这篇<a class="ae ky" href="https://www.investopedia.com/ask/answers/102714/whats-difference-between-alpha-and-beta.asp" rel="noopener ugc nofollow" target="_blank">文章</a>。</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/3fa6ebf13ce4bec75c084ac0a40f15d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*uSk7YrnC4inK-rfMGu44iw.png"/></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">阿尔法和贝塔方差</figcaption></figure><p id="7f03" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">设置我们的配置，我们能够检查更多有用的信息。</p></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><p id="b758" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">修改</strong></p><p id="59dc" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们需要准备要使用的数据，因为股票具有很高的波动性，所以我们需要规范化我们的数据，我们将使用来自<a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MinMaxScaler.html" rel="noopener ugc nofollow" target="_blank"> sklearn、</a>的 lib MinMaxScaler()，带有函数 fit_transform 和 inverse_transform，现在我们能够满足这一要求。由于 ARIMA 使用最小最大标量的结果比 z 得分法更好，我们将直接选择最小最大()来拟合和缩放我们的数据。</p><pre class="li lj lk ll gt mv mw mx bn my mz bi"><span id="4efe" class="na lz in mw b be nb nc l nd ne">stockdfs = pd.DataFrame()<br/>def datenormalization(stockdf): <br/>  global stockdfs<br/>  stockdf = stockdf.groupby('Date').sum()<br/>  stockdf = stockdf.asfreq(freq ='D'); <br/>  stockdfs = stockdf.ffill() #associate frequency by day to get hollidays<br/>  stockdfs.sort_index(ascending=True, inplace=True)<br/>  return pd.DataFrame(stockdfs)<br/>  <br/>obj = '' #global variable<br/>def scaler_fit(series):<br/>  global obj<br/>  scaler = MinMaxScaler()<br/>  obj = scaler.fit(series)<br/>  return obj<br/><br/>def min_max_fit(series): #normalization<br/>  scaler_fit(series)<br/>  scaler = MinMaxScaler()<br/>  series[list(series.columns)] = scaler.fit_transform(series)<br/>  return series<br/><br/>def min_max_inverse(series, obj): #denormalization<br/>  series[list(series.columns)] = obj.inverse_transform(series)<br/>  return series</span></pre><figure class="li lj lk ll gt lm gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/89cd10c17d383883e5e28f9389abf6b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:4/format:webp/1*nw5BYqW1X4oKZik9l2rSww.png"/></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated"><strong class="bd ma"> MinMaxScaler 将特征数据转换为范围[0，1]。</strong></figcaption></figure></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><p id="55e1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">型号</strong></p><blockquote class="nj nk nl"><p id="59fc" class="kc kd lg ke b kf kg jo kh ki kj jr kk nm km kn ko nn kq kr ks no ku kv kw kx ig bi translated">ARIMA 模型<strong class="ke io">使用差分将非平稳时间序列转换为平稳时间序列，然后根据历史数据预测未来值</strong>。这些模型使用数据中残差的“自动”相关性和移动平均值来预测未来值。<a class="ae ky" href="https://www.capitalone.com/tech/machine-learning/understanding-arima-models/" rel="noopener ugc nofollow" target="_blank">https://www . capital one . com/tech/machine-learning/understanding-ARIMA-models/</a></p></blockquote></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><p id="624d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">设置模型</strong></p><p id="672a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在一些测试中，我们确定了 ARIMA，一个在短时间内预测股票的最佳算法，对几天的预测。为了进行这些测试，我们使用 pycaret 来可视化和识别最适合的方法。</p><p id="7d78" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我们只是创建我们的设置，传递 fh(预测展望期)值和 fold，用于交叉验证。session_id 参数用于为此设置传递一个随机数。</p><blockquote class="nj nk nl"><p id="e78a" class="kc kd lg ke b kf kg jo kh ki kj jr kk nm km kn ko nn kq kr ks no ku kv kw kx ig bi translated">fh:预测范围是<strong class="ke io">准备预测的未来时间长度</strong>。</p></blockquote><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi np"><img src="../Images/8b689038601f1bbe871966738bc67dd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w1m2YZnPc2b02IoVgDXfIw.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">pycaret 设置</figcaption></figure><p id="9819" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Pycaret 返回一些关于目标训练和测试数据帧的好值，需要注意的一点是关于<a class="ae ky" href="https://www.reed.edu/economics/course_pages.archive/red_spots/endogenous_and_exogenous_v.htm" rel="noopener ugc nofollow" target="_blank">外生</a>变量，你如何将变量传递给 pycarat，如果你遇到问题，查看下面的参考。</p><div class="nq nr gp gr ns nt"><a href="https://github.com/pycaret/pycaret/issues/1588" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd io gy z fp ny fr fs nz fu fw im bi translated">为时序问题添加外部变量支持#1588 pycaret/pycaret</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">您的功能请求是否与某个问题相关？请描述一下。添加创建多元时间序列的能力描述…</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">github.com</p></div></div><div class="oc l"><div class="od l oe of og oc oh ln nt"/></div></div></a></div><p id="b174" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在设置过程之后，我们需要选择一个模型，因为我已经有一个 ARIMA 模型可供选择，如果你想让 Pycaret 选择/测试最适合你的算法，你可以使用函数 compare-models()，你可以通过 pycaret <a class="ae ky" href="https://pycaret.readthedocs.io/en/latest/api/time_series.html#pycaret.time_series.compare_models" rel="noopener ugc nofollow" target="_blank">文档</a>进行更深入的验证。</p><p id="c623" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">创建模型</strong></p><p id="e026" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于我已经选择了一个选项，我们将继续进行 ARIMA 模型，其中它被归类为时间序列预测算法。</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/cec60d2e5d80f28d12c2cf861be9618c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*Of0YUWA1AyM7jmoCOEPaSA.png"/></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">pycaret 度量</figcaption></figure><p id="1925" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">识别并阅读指标</strong></p><p id="f0f7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">布斯指标(梅伊和 MRSE)之间的相似性</strong></p><p id="5d1d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">1-度量的布斯表示基于关于原始代码(训练/测试)的预测模型的平均误差。</p><p id="366d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2-它们在 0-无穷大之间，返回幅度误差。</p><p id="0290" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">3-越接近零(0)，该值越好。</p><p id="bd1e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">更多详情:<a class="ae ky" href="https://medium.com/human-in-a-machine-world/mae-and-rmse-which-metric-is-better-e60ac3bde13d" rel="noopener"> <strong class="ke io">梅和 MRSE </strong> </a></p><p id="6aaf" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">检查结果—创建的模型</strong></p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi oj"><img src="../Images/76e2429b4f0f3daebb0cc4ea6a05b52e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hnfw2bt_G97ywdEl229StQ.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">绘图模型(arima)</figcaption></figure><p id="9e0f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">创建模型</strong></p><p id="4d0c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">敲定车型</strong></p><p id="6eb2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当共享的结果达到预期时，我们将最终确定模型。</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/1f56bf72567c54007c43725d8f236bf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*bfxMm8F_vZ_fmyv1x1hNBg.png"/></div></figure><p id="c32f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">绘制预测值—提前 5。</strong></p><p id="a363" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因为我们已经创建了模型，所以我们将预测 5 天的未来值。</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/25de80307b95b2c7b2a423e2276cb301.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*dFKUczMSOVFDHgyFXz-TPw.png"/></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">预测 5 天</figcaption></figure><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi om"><img src="../Images/fa4fe7091ee12042948ddfd9b964e56b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wTsCghzRYYt6Nrk1MzgsaA.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">预测结果</figcaption></figure><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi on"><img src="../Images/f3e07679a57a5fa2ac4c17362969b10f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OfYb7r7nlnjkitHuVcyMhg.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">绘图预测值-详细信息</figcaption></figure><p id="c7a1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">工程什么都一起</strong></p><p id="62c3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">之后，我们创建了两个函数，一个用于计算训练、归一化和反归一化，第二个函数用于创建一个数组并将每个信息合并到一个数据帧中，这样我们就可以进行进一步的分析。</p><p id="8ad7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所有算法的工作流程如下:</p><p id="5144" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"><em class="lg">minmax()→setup()→finalize model()→predict model()→inverseminmax()→merge results()→data frame[]→Validation→Delviery</em>T3】</strong></p><pre class="li lj lk ll gt mv mw mx bn my mz bi"><span id="58bb" class="na lz in mw b be nb nc l nd ne"> #@title Engineering All to Predict Stocks<br/> #@markdown Engineering to predict all 500 stocks<br/>from pycaret.time_series import *<br/><br/>pred_unseen_deno = pd.DataFrame()<br/>dffdstocks = pd.DataFrame()<br/>transpredicted = pd.DataFrame()<br/>dfstocks = pd.DataFrame()<br/>dfstocks.iloc[0:0]<br/><br/>def train_and_normalize(stock, initialdate, finaldate, predictdays, predictdaysx, crossvalidation):<br/>  global pred_unseen_deno<br/>  global transpredicted<br/>  stock_returns = datenormalization(stockdoublebench_returns(stock, initialdate, finaldate))<br/>  print(stock_returns)<br/>  exp2 = setup(min_max_fit(stock_returns[['Adj Close']]), fh = predictdays, fold = crossvalidation, session_id = 123)<br/>  arima2 = exp2.create_model('arima')<br/>  #pred_holdout = predict_model(arima2) <br/>  pred_unseen_deno = min_max_inverse(predict_model(exp2.finalize_model(arima2), fh = predictdaysx), obj)<br/>  #if you need to see the pred_holdout value<br/>  #pred_unseen_deno = min_max_inverse(predict_model(finalize_model(arima2), fh = predictdaysx), obj)<br/>  transpredicted = pred_unseen_deno.T<br/>  transpredicted['stocks'] = stock<br/>  return transpredicted<br/><br/>def iterate_predicted_stocks(initialdate, finaldate, predictdays,predictdaysx, crossvalidation): <br/>  global dffdstocks<br/>  global dfstocks<br/>  for value in (abstocksna['stocks']):<br/>    try: <br/>      train_and_normalize(value, initialdate, finaldate, predictdays, predictdaysx,crossvalidation) <br/>      dffdstocks = dffdstocks.append(transpredicted, ignore_index = True)<br/>      dfstocks = pd.merge(dffdstocks, abstocks, on='stocks')<br/>    except:<br/>      continue<br/>  return dfstocks<br/>  #We are going to use this function to start up our algoritm to predict future values. <br/>#initial date, last date, predictdays(for test), predictdate for future to be used after last date, and how <br/>#many values fold we are going to use for cross validation.<br/><br/>abstocks = alphabetastock(stockdoublebench_percent(tickers, '2015-01-01', '2022-12-25'),'^GSPC')<br/>abstocksna = abstocks.dropna()<br/>iterate_predicted_stocks('2015-01-01', '2022-12-25', 30, 10 ,5) </span></pre><p id="a9ec" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">函数 alphabetastock()首先被调用来计算α和β的所有值，然后这些值被保存在数据帧 abstocksna 中，之后函数 iterate_predicted_stocks()开始迭代并将每个值传递给我们的函数 train_and_normalize()，可以看到，我们提供了初始日期、最终日期、测试集(30)、未来预测值(10)，5 是用于<a class="ae ky" href="https://en.wikipedia.org/wiki/Cross-validation_(statistics)" rel="noopener ugc nofollow" target="_blank">交叉验证的数量。</a></p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi oo"><img src="../Images/92e9861a664f7d025913b2b2872b2081.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wlr6_MERc5XqLEVw6r9mOA.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">预测 500 只股票</figcaption></figure><p id="257e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">结论</strong></p><p id="5dea" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，我们能够获得所选日期的预测值，在这种情况下，我们将使用 5 天，我们有 Beta 方差和 Alpha 来帮助我们开发股票钱包。可以用高值、最小值、平均值和每个的扇区来增加该数据框架，以使用更多的统计推断来识别和应用粒子群算法，或者可以使用多标准决策来识别最佳的未来股票组合。</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi op"><img src="../Images/e09d7700a0abe5d866e9e58c59c4d1ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JSL_kDbk2a9sDIUC2OuzVA.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">绘制 beta 差异与最后一天预测库存的对比图</figcaption></figure><p id="f162" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">接下来的步骤</strong></p><ul class=""><li id="756e" class="oq or in ke b kf kg ki kj kl os kp ot kt ou kx ov ow ox oy bi translated">用新值增加最终数据帧，以获得更好的决策者。</li><li id="f5dd" class="oq or in ke b kf oz ki pa kl pb kp pc kt pd kx ov ow ox oy bi translated">定义股票投资组合的多准则算法。</li><li id="0fd1" class="oq or in ke b kf oz ki pa kl pb kp pc kt pd kx ov ow ox oy bi translated">优化未来投资组合..</li></ul></div></div>    
</body>
</html>