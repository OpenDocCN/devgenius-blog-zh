<html>
<head>
<title>Python — Do You Really Understand GIL?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">python——你真的了解 GIL 吗？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/python-do-you-really-understand-gil-8944fcd773cd?source=collection_archive---------5-----------------------#2022-05-23">https://blog.devgenius.io/python-do-you-really-understand-gil-8944fcd773cd?source=collection_archive---------5-----------------------#2022-05-23</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="be06" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">Python 全局解释器锁深潜</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/cf6e0f1b9b2c4a9c8927b2474f4108c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0nx5szhVc0iGC74uYM9gtQ.png"/></div></div></figure><p id="348f" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">Python 全局解释器锁或 GIL，简而言之，是一个互斥体(或锁)，只允许一个线程控制 Python 解释器。这意味着在任何给定的时间，只有一个线程可以处于执行状态。</p><p id="0145" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">如果你只开发单线程 Python 程序，你可能感觉不到影响。但是如果你正在做多线程 Python 编程，GIL 会成为一个瓶颈。</p><p id="09f4" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">让我们来看一个例子，下面是一个非常简单的 cpu 绑定代码:</p><pre class="kh ki kj kk gu lo lp lq lr aw ls bi"><span id="3de9" class="lt lu ir lp b gz lv lw l lx ly">def count_down(n):<br/>    while n &gt; 0:<br/>        n -= 1</span></pre><p id="25f1" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">现在，假设一个很大的数字<code class="fe lz ma mb lp b">n = 100000000</code>，让我们试着在单线程中执行<code class="fe lz ma mb lp b">count_down(n)</code>。</p><p id="625c" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">我的测试环境有 2 个 CPU，执行时间是:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj mc"><img src="../Images/615c66f0129d2b5af304fc82481831b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*1mSAEOznqpzaos8IJc-RJg.png"/></div></figure><p id="642d" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">这时候我们就试着用多线程来加速吧，比如下面这几行:</p><pre class="kh ki kj kk gu lo lp lq lr aw ls bi"><span id="52f9" class="lt lu ir lp b gz lv lw l lx ly">from threading import Thread</span><span id="4414" class="lt lu ir lp b gz md lw l lx ly"><br/>def count_down(n):<br/>    while n &gt; 0:<br/>        n -= 1</span><span id="eb5c" class="lt lu ir lp b gz md lw l lx ly">if __name__ == '__main__':<br/>    n = 100000000<br/>    t1 = Thread(target=CountDown, args=[n // 2])<br/>    t2 = Thread(target=CountDown, args=[n // 2])<br/>    t1.start()<br/>    t2.start()<br/>    t1.join()<br/>    t2.join()</span></pre><p id="8925" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">再次执行上面的程序，这次的结果看起来像:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj me"><img src="../Images/42301cd66b966616c3ef9a82a2775bfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*FCjNuWwSu0c1CG3W-xQaCQ.png"/></div></figure><p id="5d6f" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">您可以看到结果现在更慢了，总时间为 5.954 秒。即使您尝试使用四个线程，总执行时间仍将接近两个线程的执行时间。</p><p id="97d2" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">这是怎么回事？Python 线程是假线程吗？Python 的线程确实封装了底层操作系统线程。在 Linux 系统中是 Pthread(全称是 POSIX Thread)，在 Windows 系统中是 Windows Thread。</p><p id="6c18" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">此外，Python 线程也完全由 OS 管理，比如协调何时执行、管理内存资源、管理中断等等。</p><h1 id="2596" class="mf lu ir bd mg mh mi mj mk ml mm mn mo jx mp jy mq ka mr kb ms kd mt ke mu mv bi translated">为什么是 GIL？</h1><p id="3fdc" class="pw-post-body-paragraph ks kt ir ku b kv mw js kx ky mx jv la lb my ld le lf mz lh li lj na ll lm ln ik bi translated">GIL 是最流行的 Python 解释器 CPython 中的一个技术术语。它代表<code class="fe lz ma mb lp b">Global Interpreter Lock</code>，本质上是一个互斥体。<strong class="ku is">每一个 Python 线程，在 CPython 解释器中执行时，都会先锁定自己的线程，防止其他线程执行。</strong></p><p id="35d3" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">当然，CPython 做了一点小技巧来依次执行 Python 线程。通过这种方式，用户看到的是“伪并行”——Python 线程是交错的，以模拟真正的并行。</p><p id="4d1d" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">所以你可能会问，为什么 CPython 需要 GIL？这其实和 CPython 的实现有关。CPython 使用引用计数来管理内存。在 Python 脚本中创建的所有实例都有一个引用计数来记录有多少个指向它的指针。当引用计数为 0 时，内存自动释放。</p><p id="a8a9" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">您可以使用<code class="fe lz ma mb lp b">sys.getrefcount()</code>来检查参考计数:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj nb"><img src="../Images/3e5acdc58bb3020ee4c6cd255fa931e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:514/format:webp/1*SLreQHUVm1n0sgQbocyVyQ.png"/></div></figure><p id="328d" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated"><code class="fe lz ma mb lp b">a</code>、<code class="fe lz ma mb lp b">b</code>、<code class="fe lz ma mb lp b">getrefcount</code>均引用空列表。</p><p id="b226" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">这样，如果两个 Python 线程同时引用<code class="fe lz ma mb lp b">a</code>，就会造成引用计数竞争情况，引用计数可能只增加 1。那么当第一个线程结束时，引用计数可能会减少 1，内存可能会被释放。然后当第二个线程再次尝试访问<code class="fe lz ma mb lp b">a</code>时，就找不到有效的内存了。</p><p id="b6c2" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">因此，CPython 引入 GIL 主要有两个原因:</p><ul class=""><li id="04ef" class="nc nd ir ku b kv kw ky kz lb ne lf nf lj ng ln nh ni nj nk bi translated"><strong class="ku is">一是设计者避免了内存管理等复杂的竞争条件；</strong></li><li id="f330" class="nc nd ir ku b kv nl ky nm lb nn lf no lj np ln nh ni nj nk bi translated"><strong class="ku is">第二是因为 CPython 使用了很多 C 语言库，但是大多数 C 语言库本身并不是线程安全的(线程安全降低了性能，增加了复杂性)。</strong></li></ul><h1 id="de50" class="mf lu ir bd mg mh mi mj mk ml mm mn mo jx mp jy mq ka mr kb ms kd mt ke mu mv bi translated">GIL 是如何工作的？</h1><p id="69a5" class="pw-post-body-paragraph ks kt ir ku b kv mw js kx ky mx jv la lb my ld le lf mz lh li lj na ll lm ln ik bi translated">下图是 Python 中 GIL 程序的工作示例。其中，线程 1、2 和 3 依次执行。</p><p id="44bd" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">每个线程开始执行时，都会锁定 GIL，阻止其他线程执行；类似地，每个线程执行一段时间后，会释放 GIL 让其他线程执行。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj nq"><img src="../Images/df5414aceb3e5b200621fb79a1d1483b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EhguHDUThWcWlotK.png"/></div></div></figure><p id="488b" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">在 CPython 中，有一种机制叫做<code class="fe lz ma mb lp b">check_interval</code>，这意味着 CPython 解释器会轮询检查线程 GIL 的锁状态。每隔一段时间，Python 解释器会强制当前线程释放 GIL，以便其他线程有机会执行。</p><blockquote class="nr ns nt"><p id="019a" class="ks kt nu ku b kv kw js kx ky kz jv la nv lc ld le nw lg lh li nx lk ll lm ln ik bi translated">注意:当执行 I/O 操作时，当一个线程被阻塞时，GIL 将被立即释放，因此其他线程可以继续运行。</p></blockquote><h1 id="e4bf" class="mf lu ir bd mg mh mi mj mk ml mm mn mo jx mp jy mq ka mr kb ms kd mt ke mu mv bi translated">Python 中的线程安全</h1><p id="22a7" class="pw-post-body-paragraph ks kt ir ku b kv mw js kx ky mx jv la lb my ld le lf mz lh li lj na ll lm ln ik bi translated">然而，有了 GIL，并不意味着我们 Python 程序员不用担心线程安全。尽管我们知道 GIL 只允许一个 Python 线程执行，正如我前面提到的，Python 也有一个抢占机制，比如检查间隔。让我们考虑这样一段代码:</p><pre class="kh ki kj kk gu lo lp lq lr aw ls bi"><span id="1d0e" class="lt lu ir lp b gz lv lw l lx ly">import threading</span><span id="6897" class="lt lu ir lp b gz md lw l lx ly">n = 0</span><span id="8069" class="lt lu ir lp b gz md lw l lx ly">def foo():<br/>    global n<br/>    n += 1</span><span id="4908" class="lt lu ir lp b gz md lw l lx ly">threads = []<br/>for i in range(100):<br/>    t = threading.Thread(target=foo)<br/>    threads.append(t)</span><span id="28d9" class="lt lu ir lp b gz md lw l lx ly">for t in threads:<br/>    t.start()</span><span id="640f" class="lt lu ir lp b gz md lw l lx ly">for t in threads:<br/>    t.join()</span><span id="8eaf" class="lt lu ir lp b gz md lw l lx ly">print(n)</span></pre><p id="4d95" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">如果你执行它，你会发现虽然它大部分时间都打印<code class="fe lz ma mb lp b">100</code>，但有时也会打印<code class="fe lz ma mb lp b">99</code>或<code class="fe lz ma mb lp b">98</code>。</p><p id="02c0" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">这其实是因为代码<code class="fe lz ma mb lp b">n+=1</code>让线程变得不安全。如果翻译 foo 函数的<code class="fe lz ma mb lp b">bytecode</code>，你会发现它实际上由下面四行<code class="fe lz ma mb lp b">bytecode</code>组成:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj ny"><img src="../Images/d311c7bd532faae5ee5905b5d32ebdd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*J1-dg_rcqumAQTXVXg50Xg.png"/></div></figure><p id="ffba" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">而<code class="fe lz ma mb lp b">bytecode</code>的这四行中间很可能会被打断！所以即使有了 GIL，你仍然需要注意线程安全。GIL 的设计主要是为了方便 CPython 解释器级别的编写人员，而不是 Python 应用程序级别的程序员。</p><p id="494e" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">作为 Python 用户，我们仍然需要使用<code class="fe lz ma mb lp b">lock</code>来保证线程安全:</p><pre class="kh ki kj kk gu lo lp lq lr aw ls bi"><span id="5e29" class="lt lu ir lp b gz lv lw l lx ly">n = 0<br/>lock = threading.Lock()</span><span id="6a01" class="lt lu ir lp b gz md lw l lx ly">def foo():<br/>    global n<br/>    with lock:<br/>        n += 1</span></pre><p id="07a6" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">新的<code class="fe lz ma mb lp b">bytecode</code>看起来像:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj nz"><img src="../Images/963ac903a02a5d4c4f3b048edebb2a74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*JcwbxYE_JcSmHlV5TKKoQw.png"/></div></figure><h1 id="a3b7" class="mf lu ir bd mg mh mi mj mk ml mm mn mo jx mp jy mq ka mr kb ms kd mt ke mu mv bi translated">为什么 GIL 还没有被移除？</h1><p id="f059" class="pw-post-body-paragraph ks kt ir ku b kv mw js kx ky mx jv la lb my ld le lf mz lh li lj na ll lm ln ik bi translated">GIL 显然可以被移除，开发者和研究人员在过去已经多次这样做了，但所有这些尝试都破坏了现有的 C 扩展，这些扩展严重依赖于 GIL 提供的解决方案。</p><p id="543b" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">Python 的创始人、BDFL 吉多·范·罗苏姆在 2007 年 9 月的文章<a class="ae oa" href="https://www.artima.com/weblogs/viewpost.jsp?thread=214235" rel="noopener ugc nofollow" target="_blank">“移除 GIL 并不容易”</a>中给了社区一个答案:</p><blockquote class="nr ns nt"><p id="8e5b" class="ks kt nu ku b kv kw js kx ky kz jv la nv lc ld le nw lg lh li nx lk ll lm ln ik bi translated"><em class="ir">“只有当<em class="ir">单线程程序(以及多线程但 I/O 受限的程序)</em>的性能不下降<em class="ir"/>时，我才会欢迎 Py3k </em>中的一组补丁</p></blockquote><p id="b084" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">从那以后的任何尝试都没有满足这个条件。</p><p id="2567" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">好的一面是 GIL 是 CPython 解释器强加的一个限制。如果您的代码不需要 CPython 解释器来执行，它就不再受 GIL 的限制。</p><p id="a820" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">其实很多高性能应用场景已经有大量用 C 实现的 Python 库，比如<code class="fe lz ma mb lp b">NumPy</code>的矩阵运算，都是用 C 实现的，不受 GIL 的影响。</p></div></div>    
</body>
</html>