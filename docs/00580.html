<html>
<head>
<title>Python Closures- Demystified</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python闭包——去神秘化</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/python-closures-b71e8847286f?source=collection_archive---------15-----------------------#2020-06-11">https://blog.devgenius.io/python-closures-b71e8847286f?source=collection_archive---------15-----------------------#2020-06-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/c3b4e0750f6bbb1e52e2c1f678f20cc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mytOKI3j1rI-pB6p"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><a class="ae jz" href="https://unsplash.com/@sincerelymedia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">真诚媒体</a>在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="8650" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你好，python爱好者，在跳到实际主题之前，我希望你熟悉python嵌套函数的基础。人们经常混淆闭包和嵌套函数这两个术语，并互换使用。这些是同一个概念吗？让我们找出答案。</p><h1 id="5fb8" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">什么是闭包？</h1><blockquote class="lw"><p id="fae7" class="lx ly in bd lz ma mb mc md me mf kx dk translated">闭包是嵌套函数记住其封闭函数变量的状态的原因，即使在执行完成之后。这些变量的类型可以是另一个可调用的(即函数或类)或任何标准的数据类型。</p></blockquote><figure class="mg mh mi mj mk jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="06b6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的例子中，当'<em class="mn"> greeter_fun' </em>函数被调用时，它创建新的函数'<em class="mn"> greet' </em>,并返回它。因此'<em class="mn"> say_my_name' </em>将持有新创建函数的引用。</p><p id="0988" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里，内部函数打印消息“Hello <name>，但是它从哪里获得'<em class="mn"> name' </em>的值呢？<strong class="kc io">这里，结束进入了画面。</strong></name></p><blockquote class="mo mp mq"><p id="15b2" class="ka kb mn kc b kd ke kf kg kh ki kj kk mr km kn ko ms kq kr ks mt ku kv kw kx ig bi translated">不要混淆嵌套函数和闭包- <strong class="kc io">它们是不一样的！！</strong></p></blockquote><p id="ff4a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">闭包导致嵌套函数以某种方式运行，即记住自由变量的状态。</p><p id="37ca" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将很快讨论自由变量…</p></div><div class="ab cl mu mv hr mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ig ih ii ij ik"><h1 id="8484" class="ky kz in bd la lb nb ld le lf nc lh li lj nd ll lm ln ne lp lq lr nf lt lu lv bi translated">闭包是如何工作的？</h1><p id="7a34" class="pw-post-body-paragraph ka kb in kc b kd ng kf kg kh nh kj kk kl ni kn ko kp nj kr ks kt nk kv kw kx ig bi translated"><strong class="kc io"> <em class="mn">步骤1 </em> </strong>:当外部函数'<em class="mn"> greeter_fun' </em>被调用时，构建嵌套函数'<em class="mn"> greet' </em>。</p><p id="cdaa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> <em class="mn">第二步</em> </strong>:拍摄'<em class="mn"> greet' </em>函数的状态快照(包括<em class="mn"> name </em> = '海森堡'的值)。</p><p id="1a50" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> <em class="mn">第三步</em> </strong>:将此快照或元数据附加到'<em class="mn"> greet' </em>函数中。这不过是功能的封闭。</p><p id="3a53" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> <em class="mn">第四步</em> </strong>:返回新创建的'<em class="mn"> greet' </em>函数引用。</p><p id="54da" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，每当我们调用'<em class="mn"> say_my_name' </em>时，它将始终拥有由变量'<em class="mn"> name' </em>和值<em class="mn"> 'Heisenberg' </em>组成元数据。</p></div><div class="ab cl mu mv hr mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ig ih ii ij ik"><h1 id="70f4" class="ky kz in bd la lb nb ld le lf nc lh li lj nd ll lm ln ne lp lq lr nf lt lu lv bi translated">自由变量</h1><blockquote class="lw"><p id="91ae" class="lx ly in bd lz ma mb mc md me mf kx dk translated">在一个程序块中使用但没有在该程序块中定义的变量称为自由变量。</p></blockquote><blockquote class="mo mp mq"><p id="eaa0" class="ka kb mn kc b kd nl kf kg kh nm kj kk mr nn kn ko ms no kr ks mt np kv kw kx ig bi translated">在我们的例子中，'<strong class="kc io"> <em class="in">名称'</em> </strong>变量内部'<strong class="kc io"> <em class="in">问候'</em> </strong>函数是<strong class="kc io">自由变量</strong></p></blockquote><p id="8136" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">自由变量存在于附属于函数的元数据中。幸运的是，python可以访问这些元数据。由于的<em class="mn"> ay_my_name' </em>持有嵌套函数'<em class="mn"> greet '的引用，所以可以通过两种方式访问i </em> ts元数据<em class="mn"> - </em></p><h2 id="373d" class="nq kz in bd la nr ns dn le nt nu dp li kl nv nw lm kp nx ny lq kt nz oa lu ob bi translated"><strong class="ak"> 1。via <em class="oc"> __code__ </em>属性:</strong></h2><blockquote class="lw"><p id="5fb2" class="lx ly in bd lz ma mb mc md me mf kx dk translated">__code__属性包含'<em class="oc"> co_freevars' </em>字段，该字段是在代码块中定义的自由变量元组。</p></blockquote><p id="3db2" class="pw-post-body-paragraph ka kb in kc b kd nl kf kg kh nm kj kk kl nn kn ko kp no kr ks kt np kv kw kx ig bi translated">例如</p><figure class="od oe of og gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h2 id="89f4" class="nq kz in bd la nr ns dn le nt nu dp li kl nv nw lm kp nx ny lq kt nz oa lu ob bi translated">2.使用__closure__属性:</h2><blockquote class="lw"><p id="a434" class="lx ly in bd lz ma mb mc md me mf kx dk translated">__closure__返回'<em class="oc"> cell' </em>对象的元组，其中每个对象保存一个名为'<em class="oc"> cell_contents '的属性，t</em>his '<em class="oc">cell _ contents '</em>保存当前的<em class="oc"> 'co_freevar' </em>值。</p></blockquote><p id="407e" class="pw-post-body-paragraph ka kb in kc b kd nl kf kg kh nm kj kk kl nn kn ko kp no kr ks kt np kv kw kx ig bi translated">图表会让它更清楚……:-)</p><figure class="od oe of og gt jo gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/47f79d6479e0da57f9f89776d7448500.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*PEclm3UkzQqvUUMkxjvgTQ.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">图像:__closure__属性的结构</figcaption></figure><p id="30c3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如</p><figure class="od oe of og gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure></div><div class="ab cl mu mv hr mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ig ih ii ij ik"><p id="91dd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你想修改自由变量呢？你可以去改变它，对吗？</p><figure class="od oe of og gt jo gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/fc0b0e0a7bccc642945dcefeb5d69945.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*6X9zwkinime6EnvgGMI4vA.gif"/></div></figure><p id="e691" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">默认情况下，这些自由变量是只读的，你必须使用<strong class="kc io">非局部关键字</strong>将它们显式声明为非局部变量，以便修改它们。</p></div><div class="ab cl mu mv hr mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ig ih ii ij ik"><p id="6906" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">闭包提供了数据隐藏，因为当您需要对全局范围变量隐藏功能时，可以使用它们。此外，闭包可能是一个优雅的解决方案，而不是为更少的方法和属性编写类。</p><p id="4fc6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">闭包在装饰者中被广泛使用。如果你想了解更多，请查看我关于<a class="ae jz" href="https://medium.com/analytics-vidhya/python-decorators-a-weapon-to-be-mastered-be310b519ac5" rel="noopener">装修工</a>的详细文章。</p></div><div class="ab cl mu mv hr mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ig ih ii ij ik"><p id="c279" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您读到这里，我希望这篇文章能帮助您理解python中的闭包。</p><p id="ecf5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> <em class="mn">干杯！</em> </strong></p></div></div>    
</body>
</html>