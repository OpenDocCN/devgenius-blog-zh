<html>
<head>
<title>Open Closed principle and Rule engine design pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开闭原则和规则引擎设计模式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/open-closed-principle-and-rule-engine-design-pattern-904c784501e5?source=collection_archive---------0-----------------------#2021-08-15">https://blog.devgenius.io/open-closed-principle-and-rule-engine-design-pattern-904c784501e5?source=collection_archive---------0-----------------------#2021-08-15</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><p id="93c6" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">尊重隐私。</p><figure class="kn ko kp kq gu kr gi gj paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gi gj km"><img src="../Images/06ff00b2cd693506ef504dd87b5ed190.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SvJbC6miAhe3QMSA"/></div></div><figcaption class="ky kz gk gi gj la lb bd b be z dk translated">蒂姆·莫斯霍尔德在<a class="ae lc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="bdb4" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated"><a class="ae lc" href="https://en.wikipedia.org/wiki/SOLID" rel="noopener ugc nofollow" target="_blank">坚实</a>原则是美国软件工程师兼讲师<a class="ae lc" href="https://en.wikipedia.org/wiki/Robert_C._Martin" rel="noopener ugc nofollow" target="_blank">罗伯特·C·马丁，也就是众所周知的</a><a class="ae lc" href="https://en.wikipedia.org/wiki/Robert_C._Martin" rel="noopener ugc nofollow" target="_blank">罗伯特叔叔</a>提出的众多原则中的一部分在这篇文章中，我将谈论<a class="ae lc" href="https://en.wikipedia.org/wiki/SOLID" rel="noopener ugc nofollow" target="_blank"> S <strong class="jq is"> {O} </strong> LID </a>原则之一，即<a class="ae lc" href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle" rel="noopener ugc nofollow" target="_blank">开闭原则(OCP) </a>。</p><p id="c233" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">我会用 C#来演示代码，但是 OCP 是语言不可知的。</p><p id="02af" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated"><strong class="jq is">OCP 的官方定义是:</strong></p><blockquote class="ld"><p id="306f" class="le lf ir bd lg lh li lj lk ll lm kl dk translated"><em class="ln">软件实体(类、模块、功能等。)应该对扩展开放，但对修改关闭</em></p></blockquote></div><div class="ab cl lo lp hv lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ik il im in io"><h1 id="68f9" class="lv lw ir bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">OCP 的好处</h1><p id="465d" class="pw-post-body-paragraph jo jp ir jq b jr mt jt ju jv mu jx jy jz mv kb kc kd mw kf kg kh mx kj kk kl ik bi translated">OCP 推荐了一些使软件升级变得容易的方法。想象一个用例，WhatsApp 想要扩展聊天服务，向脸书信使发送消息。</p><p id="c107" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">开发人员希望重用聊天服务的相关组件。做这件事有两种方法。</p><ol class=""><li id="fa57" class="my mz ir jq b jr js jv jw jz na kd nb kh nc kl nd ne nf ng bi translated">修改现有的聊天服务，以支持新的要求。它会将聊天服务代码暴露给 bug。聊天服务的复杂性将会增加，自动化测试用例可能会失败。</li><li id="92d4" class="my mz ir jq b jr nh jv ni jz nj kd nk kh nl kl nd ne nf ng bi translated">使用相关组件扩展聊天服务代码。为支持新特性而编写的代码将采用新类的形式，但将受益于聊天服务的核心功能。这种方法的好处是可以独立地部署和测试新功能。</li></ol><p id="b47b" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">规则引擎设计模式是服从 OCP 的许多方式之一。许多其他设计模式允许我们遵循 OCP，但是我将本次会议限制在规则引擎设计模式，这是展示 OCP 威力的最简单的方法之一。</p></div><div class="ab cl lo lp hv lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ik il im in io"><h1 id="3c60" class="lv lw ir bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">规则引擎</h1><p id="bf6b" class="pw-post-body-paragraph jo jp ir jq b jr mt jt ju jv mu jx jy jz mv kb kc kd mw kf kg kh mx kj kk kl ik bi translated">帮助开发人员遵循 OCP 的流行设计模式之一是规则引擎设计模式。用多个复杂的业务规则处理同一个实体来开发软件应用程序是一种有效的设计模式。</p><p id="5398" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">业务规则可能是相互关联且复杂的。可能会涉及许多复杂的分支和条件逻辑。遵循 OCP 将使开发人员能够独立添加、删除或禁用业务结果。</p><figure class="kn ko kp kq gu kr gi gj paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gi gj nm"><img src="../Images/c8d78d780631a6ff50914cd2aa61ef27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jX3G5sVd8jCH6j683T_uXQ.jpeg"/></div></div></figure><p id="973a" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">规则引擎有两个组件:</p><ol class=""><li id="732a" class="my mz ir jq b jr js jv jw jz na kd nb kh nc kl nd ne nf ng bi translated">规则引擎—对实体执行所有规则以产生结果的引擎。</li><li id="9a39" class="my mz ir jq b jr nh jv ni jz nj kd nk kh nl kl nd ne nf ng bi translated">业务规则—规则定义处理逻辑或条件。</li></ol></div><div class="ab cl lo lp hv lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ik il im in io"><h1 id="bf4e" class="lv lw ir bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">税收计算器</h1><p id="4667" class="pw-post-body-paragraph jo jp ir jq b jr mt jt ju jv mu jx jy jz mv kb kc kd mw kf kg kh mx kj kk kl ik bi translated">让我们尝试为一个税收计算器应用程序实现规则引擎设计模式。纳税计算是一个复杂的过程，取决于许多因素，如年龄、总收入、居民身份等。<br/>很多业务规则评估这些因素来确定税额。政府政策驱动着这些商业规则，并且可以频繁地改变它们。在这个用例中，我将使用规则引擎设计模式来保持这些业务规则的独立性。</p><figure class="kn ko kp kq gu kr gi gj paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gi gj nn"><img src="../Images/f5695056cf33d9cd42aaa876e95627aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mlyJG43D1QRmDvSM7EckTw.jpeg"/></div></div></figure></div><div class="ab cl lo lp hv lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ik il im in io"><h2 id="179e" class="no lw ir bd lx np nq dn mb nr ns dp mf jz nt nu mj kd nv nw mn kh nx ny mr nz bi translated">实现规则引擎设计模式的步骤</h2><p id="15c6" class="pw-post-body-paragraph jo jp ir jq b jr mt jt ju jv mu jx jy jz mv kb kc kd mw kf kg kh mx kj kk kl ik bi translated">完整的代码可以在 https://github.com/tarunbhatt9784/TaxCalculator.git 的<a class="ae lc" href="https://github.com/tarunbhatt9784/TaxCalculator.git" rel="noopener ugc nofollow" target="_blank">找到</a></p><p id="3159" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated"><strong class="jq is">第一步——将所有规则写在一个地方</strong></p><p id="09cc" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">使用 if-then-else 条件语句在一个方法中编写所有规则。</p><figure class="kn ko kp kq gu kr"><div class="bz fq l di"><div class="oa ob l"/></div></figure><p id="fac6" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated"><strong class="jq is">第二步:</strong> <strong class="jq is">为每个规则创建类。</strong></p><p id="0210" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">为每个规则创建单独的类。在每个类文件中添加一个 ShouldRun()方法，以确定是否必须执行业务规则。</p><figure class="kn ko kp kq gu kr gi gj paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gi gj oc"><img src="../Images/e763ae43c9ccb7688740f1af04480fbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cKUXDJUSs4tMk5ohm_aMiw.jpeg"/></div></div></figure><p id="47fe" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">每个类都有两个方法— Evaluate()和 ShouldRun()。</p><p id="fbe8" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">因此，我们可以创建一个接口，让所有这些规则特定的类实现这个接口。让我们将这个接口命名为 ITaxCalculatorRule。</p><p id="21f9" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated"><strong class="jq is">第三步:</strong> <strong class="jq is">创建规则引擎</strong></p><p id="335a" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">一旦我们有了接口形式的每个规则的契约和具体的规则类，就该在规则引擎的帮助下处理它们了。规则引擎将负责评估这些规则。这是一个两步的过程:</p><ul class=""><li id="a018" class="my mz ir jq b jr js jv jw jz na kd nb kh nc kl od ne nf ng bi translated">查找规则接口的所有实现— ITaxCalculatorRule</li></ul><figure class="kn ko kp kq gu kr"><div class="bz fq l di"><div class="oa ob l"/></div></figure><ul class=""><li id="6db6" class="my mz ir jq b jr js jv jw jz na kd nb kh nc kl od ne nf ng bi translated">检查每个规则的 ShouldRun()，如果它返回 true，运行 Evaluate()方法</li></ul><figure class="kn ko kp kq gu kr"><div class="bz fq l di"><div class="oa ob l"/></div></figure><p id="dbff" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">完整的代码可以在<a class="ae lc" href="https://github.com/tarunbhatt9784/TaxCalculator.git" rel="noopener ugc nofollow" target="_blank">https://github.com/tarunbhatt9784/TaxCalculator.git</a>找到</p></div><div class="ab cl lo lp hv lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ik il im in io"><h2 id="06a3" class="no lw ir bd lx np nq dn mb nr ns dp mf jz nt nu mj kd nv nw mn kh nx ny mr nz bi translated">结论</h2><p id="b22c" class="pw-post-body-paragraph jo jp ir jq b jr mt jt ju jv mu jx jy jz mv kb kc kd mw kf kg kh mx kj kk kl ik bi translated">让我们总结并重申一下使用规则引擎设计模式的优势</p><ol class=""><li id="de9f" class="my mz ir jq b jr js jv jw jz na kd nb kh nc kl nd ne nf ng bi translated">业务规则的独立可测试性</li><li id="05d7" class="my mz ir jq b jr nh jv ni jz nj kd nk kh nl kl nd ne nf ng bi translated">规则引擎不需要随着每个业务规则的添加或删除而改变。</li><li id="86fc" class="my mz ir jq b jr nh jv ni jz nj kd nk kh nl kl nd ne nf ng bi translated">可以单独启用或禁用业务规则，而无需更改其他规则或规则引擎</li></ol><p id="5053" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">谢谢</p></div><div class="ab cl lo lp hv lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ik il im in io"><blockquote class="ld"><p id="5c28" class="le lf ir bd lg lh li lj lk ll lm kl dk translated">页（page 的缩写）s-Medium 是一个阅读、写作和向其他作者学习的绝佳平台。如果你想加入我的旅程，今天就加入<a class="ae lc" href="https://tarunbhatt9784.medium.com/membership" rel="noopener"> medium </a>。</p></blockquote><h1 id="d3a9" class="lv lw ir bd lx ly oe ma mb mc of me mf mg og mi mj mk oh mm mn mo oi mq mr ms bi translated">词汇表</h1><p id="2ffd" class="pw-post-body-paragraph jo jp ir jq b jr mt jt ju jv mu jx jy jz mv kb kc kd mw kf kg kh mx kj kk kl ik bi translated"><a class="ae lc" href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle" rel="noopener ugc nofollow" target="_blank">开闭原则—维基百科</a></p><p id="33dd" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated"><a class="ae lc" href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle" rel="noopener ugc nofollow" target="_blank">开闭原则——维基百科</a></p><p id="a14c" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated"><a class="ae lc" href="https://en.wikipedia.org/wiki/SOLID" rel="noopener ugc nofollow" target="_blank">固—百科</a></p><p id="bde5" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">罗伯特·c·马丁——维基百科</p><p id="ca6e" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated"><a class="ae lc" href="https://app.pluralsight.com/library/courses/csharp-solid-principles/table-of-contents" rel="noopener ugc nofollow" target="_blank">c#开发人员的坚实原则| Pluralsight </a></p><p id="7abb" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated"><a class="ae lc" href="https://app.pluralsight.com/library/courses/c-sharp-design-patterns-rules-pattern/table-of-contents" rel="noopener ugc nofollow" target="_blank"> C#设计模式:规则引擎模式| Pluralsight </a></p></div></div>    
</body>
</html>