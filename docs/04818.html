<html>
<head>
<title>Spring Boot application with GraalVM Native Image</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有 GraalVM 本机映像的 Spring Boot 应用程序</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/spring-boot-application-with-graalvm-native-image-8074034ba35f?source=collection_archive---------0-----------------------#2021-05-09">https://blog.devgenius.io/spring-boot-application-with-graalvm-native-image-8074034ba35f?source=collection_archive---------0-----------------------#2021-05-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/383245d3d6525748dd8f9b093b372083.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*FIxQ-0Z-rbZ9EmnLTQuCYw.png"/></div></figure><p id="b344" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">作为一名 JAVA 开发人员，进程有时会遭受较长的启动时间和相对较高的内存使用率😞。我们将寻找一个令人兴奋的解决方案。</p><p id="c6af" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在本文中，我们将检查一个简单的<strong class="jt io"> Spring Boot </strong>应用程序，然后使用 GraalVM 将它转换成一个<strong class="jt io">本机映像。</strong></p><p id="5e21" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果您不知道 GraalVM，不要担心。我们一会儿会讨论这个问题。现在，只要记住它是一个 JVM，在运行时<strong class="jt io">提供<strong class="jt io"> <em class="kp">提前</em> </strong>编译，结合编译<strong class="jt io"> <em class="kp">即时</em> </strong>。</strong></p></div><div class="ab cl kq kr hr ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="ig ih ii ij ik"><p id="50a6" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">让我们首先讨论一下我们今天要编写的 Spring Boot 应用程序。(这里我们将使用 Maven，但是您也可以使用 Gradle)。</p><p id="40c3" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">应用程序将公开两个 REST 端点，这两个端点都将接受 HTTP GET 请求。</p><ul class=""><li id="5ab1" class="kx ky in jt b ju jv jy jz kc kz kg la kk lb ko lc ld le lf bi translated">第一个端点应该提供对应于 Github 用户<strong class="jt io"> ( /users/{githubUserName})的信息。</strong></li><li id="f750" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lc ld le lf bi translated">第二个端点应该提供一个 Github 存储库的贡献者<br/><strong class="jt io">(</strong><a class="ae ll" href="http://localhost:8081/contributors/%7BgithubOrgName%7D/%7BgithubRepoName%7D" rel="noopener ugc nofollow" target="_blank"><strong class="jt io">/contributors/{ githubOrgName }/{ githubRepoName }</strong></a><strong class="jt io">)对应的信息。</strong></li></ul><p id="577e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><code class="fe lm ln lo lp b">GithubController</code>可以定义如下—</p><figure class="lq lr ls lt gt jo"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="03ba" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们在控制器中有自动连线的类，并使用它来获取用户或贡献者的详细信息。</p><figure class="lq lr ls lt gt jo"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="6776" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这里，我们使用<code class="fe lm ln lo lp b">RestTemplate</code>来调用 Github APIs。</p><p id="1f0a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在，让我们看看<code class="fe lm ln lo lp b">User</code> DTO 类，它将被用作 REST 响应。</p><figure class="lq lr ls lt gt jo"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="17cf" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这对于完成任务来说肯定是足够了，但是让我们给我们的应用程序增加一些趣味。</p><p id="01fe" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">Github API <strong class="jt io">强加了一个速率限制</strong>，因此你不能在一个小时内从一个给定的 IP 发出超过<code class="fe lm ln lo lp b">60</code>个请求。我们可以使用 Github 身份验证令牌来提高这个速率限制。</p><p id="fe46" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">让我们将<code class="fe lm ln lo lp b">GithubProperties</code>定义为 Spring Boot <code class="fe lm ln lo lp b">ConfigurationProperties</code>。</p><figure class="lq lr ls lt gt jo"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="1802" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">所以，现在我们可以在<code class="fe lm ln lo lp b">application.properties</code> / <code class="fe lm ln lo lp b">application.yaml</code>中添加一个名为<code class="fe lm ln lo lp b">github.token</code>的属性。由于使用了<code class="fe lm ln lo lp b">@ Validated</code>和<br/> <code class="fe lm ln lo lp b">@ Pattern</code>注释，在应用程序启动时，将确保属性遵循所述的正则表达式。</p><p id="f5c0" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在，在尝试调用 Github API 时，如何使用这个令牌呢？好吧，让我们实现一个 Spring <code class="fe lm ln lo lp b">RestTemplate</code>拦截器。</p><figure class="lq lr ls lt gt jo"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="0eb4" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这里，<code class="fe lm ln lo lp b">GithubAppTokenInterceptor</code>的<code class="fe lm ln lo lp b">intercept</code>函数添加了一个<code class="fe lm ln lo lp b">Authorization</code>请求头，其中包含所提供令牌的编码值。</p><figure class="lq lr ls lt gt jo"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="26de" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><code class="fe lm ln lo lp b">RateLimitHeaderInterceptor</code>的<code class="fe lm ln lo lp b">intercept</code>功能提取<br/> <code class="fe lm ln lo lp b">X-RateLimit-Remaining</code>响应报头并提供<code class="fe lm ln lo lp b">log</code>语句以提供关于剩余速率限制的信息。</p><p id="0b1a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">为了使用这两个拦截器，我们只需要在初始化<code class="fe lm ln lo lp b">restTemplate</code>对象时提供它们</p><figure class="lq lr ls lt gt jo"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="6d4c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">代码的最后一部分是应用程序的入口点。</p><figure class="lq lr ls lt gt jo"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="627a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">到目前为止我们讨论过的代码可以在这里找到—</p><div class="lw lx gp gr ly lz"><a href="https://github.com/shivamgarg7276/graal-spring-native/tree/main/spring-boot-without-aot" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd io gy z fp me fr fs mf fu fw im bi translated">shivamgarg 7276/graal-spring-native</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">您可以简单地使用这个命令来构建模块——mvn clean install。一旦构建成功，运行——mvn…</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">github.com</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn jp lz"/></div></div></a></div><p id="5e77" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在，使用<code class="fe lm ln lo lp b">mvn clean install</code>进行构建。然后运行<code class="fe lm ln lo lp b">mvn spring-boot:run</code>命令，应用程序将在端口<code class="fe lm ln lo lp b">8080</code>启动。</p><figure class="lq lr ls lt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mo"><img src="../Images/ce7202bb1ac0502ef644c341f7fb14b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fkxRGASEpbXgmPCjb84iiw.png"/></div></div></figure><figure class="lq lr ls lt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mt"><img src="../Images/d234a9ba23a16332f38b71ca93fe3942.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KNUD9QwGwu5DOuUic5KZxg.png"/></div></div></figure><p id="1367" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">点击<a class="ae ll" href="http://localhost:8080/users/shivamgarg7276" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/users/shivamgarg 7276</a>给出—</p><pre class="lq lr ls lt gt mu lp mv mw aw mx bi"><span id="4974" class="my mz in lp b gy na nb l nc nd">{<br/>    "login": "shivamgarg7276",<br/>    "name": "Shivam Garg",<br/>    "company": "Nutanix",<br/>    "avatarUrl": "https://avatars.githubusercontent.com/u/49524850?v=4",<br/>    "blogUrl": "https://www.linkedin.com/in/shivam-garg-067b46141/",<br/>    "numPublicRepos": 1,<br/>    "htmlUrl": "https://github.com/shivamgarg7276"<br/>}</span></pre><p id="ecad" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">因此，在我的机器上启动大约需要<code class="fe lm ln lo lp b"><strong class="jt io">1.5 sec</strong></code>时间，内存消耗大约需要<code class="fe lm ln lo lp b"><strong class="jt io">200 MB</strong></code>时间。这就完成了任务，但是我们将看到如何使用 GraalVM 来大规模改进它。</p></div><div class="ab cl kq kr hr ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="ig ih ii ij ik"><h1 id="58ea" class="ne mz in bd nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa bi translated">什么是 GraalVM，为什么它是 JAVA 应用程序的未来？</h1><p id="918c" class="pw-post-body-paragraph jr js in jt b ju ob jw jx jy oc ka kb kc od ke kf kg oe ki kj kk of km kn ko ig bi translated"><strong class="jt io">“GraalVM—字节码到位码”😀😀</strong></p><p id="5bd4" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">GraalVM 是一个高性能的多语言编译器，有助于实现-</p><ol class=""><li id="dcbc" class="kx ky in jt b ju jv jy jz kc kz kg la kk lb ko og ld le lf bi translated">提高应用吞吐量并减少延迟</li><li id="09bf" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko og ld le lf bi translated">将应用程序编译成小型独立的本机二进制文件</li><li id="65f9" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko og ld le lf bi translated">无缝使用多种语言和库</li></ol><p id="cea5" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">它既可以用于 Java JIT，也可以用于 AOT 编译。</p><p id="d767" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">对于 AOT 编译，它使用<strong class="jt io">本机映像构建器</strong>或<code class="fe lm ln lo lp b">native-image</code>技术将<em class="kp">Java 代码提前编译</em>为独立的可执行文件。它处理应用程序的所有类及其依赖项，包括来自 JDK 的类。它静态地分析这些数据，以确定在应用程序执行期间哪些类和方法是可访问的。</p><p id="1df9" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">您可以使用我在这里强调的步骤在您的系统上安装 GraalVM</p><div class="lw lx gp gr ly lz"><a href="https://github.com/shivamgarg7276/graal-spring-native/blob/main/README.md" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd io gy z fp me fr fs mf fu fw im bi translated">shivamgarg 7276/graal-spring-native</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">示例项目展示了一个没有 AOT 的 Spring Boot 应用程序，然后使用 GraalVM 将它转换为本机映像…</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">github.com</p></div></div><div class="mi l"><div class="oh l mk ml mm mi mn jp lz"/></div></div></a></div></div><div class="ab cl kq kr hr ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="ig ih ii ij ik"><h1 id="0a4f" class="ne mz in bd nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa bi translated">春季原生测试版</h1><p id="8d92" class="pw-post-body-paragraph jr js in jt b ju ob jw jx jy oc ka kb kc od ke kf kg oe ki kj kk of km kn ko ig bi translated">不久前，Spring 团队宣布了一个名为<em class="kp">Spring Native Beta</em><strong class="jt io"><em class="kp"/></strong>的项目，该项目支持使用 GraalVM 将 Spring 应用程序编译成本地映像。</p><p id="3017" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">内存消耗承诺低很多，启动几乎是瞬间的。</strong></p><figure class="lq lr ls lt gt jo"><div class="bz fp l di"><div class="oi lv l"/></div></figure><p id="0dd4" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在，让我们换个方式，在我们最初的 Spring Boot 应用程序中做一些改变，将它转换成一个<em class="kp">本地可执行的 Spring 应用程序</em>。😉</p><p id="125b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">一旦在您的机器上安装了 GraalVM，您需要在原始应用程序中进行这些更改——</p><ul class=""><li id="3d97" class="kx ky in jt b ju jv jy jz kc kz kg la kk lb ko lc ld le lf bi translated">添加<code class="fe lm ln lo lp b">org.springframework.experimental:spring-native-image</code> maven 依赖项。</li></ul><pre class="lq lr ls lt gt mu lp mv mw aw mx bi"><span id="36d3" class="my mz in lp b gy na nb l nc nd">&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework.experimental&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-native&lt;/artifactId&gt;<br/>  &lt;version&gt;0.9.2&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><ul class=""><li id="f999" class="kx ky in jt b ju jv jy jz kc kz kg la kk lb ko lc ld le lf bi translated">添加 Spring AOT 插件</li></ul><pre class="lq lr ls lt gt mu lp mv mw aw mx bi"><span id="a784" class="my mz in lp b gy na nb l nc nd">&lt;plugin&gt;<br/>  &lt;groupId&gt;org.springframework.experimental&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-aot-maven-plugin&lt;/artifactId&gt;<br/>  &lt;version&gt;0.9.2&lt;/version&gt;<br/>  &lt;executions&gt;<br/>    &lt;execution&gt;<br/>      &lt;id&gt;test-generate&lt;/id&gt;<br/>      &lt;goals&gt;<br/>        &lt;goal&gt;test-generate&lt;/goal&gt;<br/>      &lt;/goals&gt;<br/>    &lt;/execution&gt;<br/>    &lt;execution&gt;<br/>      &lt;id&gt;generate&lt;/id&gt;<br/>      &lt;goals&gt;<br/>        &lt;goal&gt;generate&lt;/goal&gt;<br/>      &lt;/goals&gt;<br/>    &lt;/execution&gt;<br/>  &lt;/executions&gt;<br/>&lt;/plugin&gt;</span></pre><ul class=""><li id="899d" class="kx ky in jt b ju jv jy jz kc kz kg la kk lb ko lc ld le lf bi translated">添加在<code class="fe lm ln lo lp b">package</code>阶段触发插件的 GraalVM <code class="fe lm ln lo lp b">native-image</code>概要文件</li></ul><pre class="lq lr ls lt gt mu lp mv mw aw mx bi"><span id="6409" class="my mz in lp b gy na nb l nc nd">&lt;profiles&gt;<br/>  &lt;profile&gt;<br/>    &lt;id&gt;native-image&lt;/id&gt;<br/>    &lt;build&gt;<br/>      &lt;plugins&gt;<br/>        &lt;plugin&gt;<br/>          &lt;groupId&gt;org.graalvm.nativeimage&lt;/groupId&gt;<br/>          &lt;artifactId&gt;native-image-maven-plugin&lt;/artifactId&gt;<br/>          &lt;version&gt;21.0.0.2&lt;/version&gt;<br/>          &lt;configuration&gt;<br/>            &lt;!-- The native image build needs to know the entry point to your application --&gt;<br/>            &lt;mainClass&gt;com.example.graal.restserver.main.RestApplicationWithAOT&lt;/mainClass&gt;<br/>            &lt;buildArgs&gt;<br/>              &lt;buildArg&gt;--enable-https&lt;/buildArg&gt;<br/>            &lt;/buildArgs&gt;<br/>          &lt;/configuration&gt;<br/>          &lt;executions&gt;<br/>            &lt;execution&gt;<br/>              &lt;goals&gt;<br/>                &lt;goal&gt;native-image&lt;/goal&gt;<br/>              &lt;/goals&gt;<br/>              &lt;phase&gt;package&lt;/phase&gt;<br/>            &lt;/execution&gt;<br/>          &lt;/executions&gt;<br/>        &lt;/plugin&gt;<br/>      &lt;/plugins&gt;<br/>    &lt;/build&gt;<br/>  &lt;/profile&gt;<br/>&lt;/profiles&gt;</span></pre><p id="9fce" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这里提供了<code class="fe lm ln lo lp b">mainClass</code>参数，它指向应用程序的入口点，即用<code class="fe lm ln lo lp b">SpringBootApplication</code>标注的类。<br/>同样，<code class="fe lm ln lo lp b">buildArgs</code>有<code class="fe lm ln lo lp b">--enable-https</code>，因为我们使用<code class="fe lm ln lo lp b">RestTemplate</code>调用基于 HTTPS 的 Github URLs。</p><p id="2683" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">到目前为止，我们讨论的代码更改可以在这里找到—</p><div class="lw lx gp gr ly lz"><a href="https://github.com/shivamgarg7276/graal-spring-native/tree/main/spring-boot-with-aot" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd io gy z fp me fr fs mf fu fw im bi translated">shivamgarg 7276/graal-spring-native</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">你可以简单地使用这个命令来构建这个模块——mvn——Pnative——image clean package</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">github.com</p></div></div><div class="mi l"><div class="oj l mk ml mm mi mn jp lz"/></div></div></a></div><p id="53a7" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">您可以简单地使用这个命令- <br/> <code class="fe lm ln lo lp b">mvn -Pnative-image clean package</code>来构建这个模块</p><p id="8319" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这将在模块的<code class="fe lm ln lo lp b">target</code>文件夹下创建一个包含 Spring Boot 应用程序的本地可执行文件。</p><p id="9100" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">简单地调用-<br/>-<code class="fe lm ln lo lp b">target/com.example.graal.restserver.main.restapplicationwithaot</code></p><p id="1373" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这将在端口<code class="fe lm ln lo lp b">8081</code>启动 Spring Boot 服务器。</p><figure class="lq lr ls lt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi ok"><img src="../Images/2ea299e2683c5ab4e430a246c517d5e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7NJg6MyjkRgw6LlzOxI9GA.png"/></div></div></figure><figure class="lq lr ls lt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi ol"><img src="../Images/195d1b5f2f76b1cfb948798c8756d9b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gtUIkD53DeB28DDb-HJ3lw.png"/></div></div></figure><p id="e525" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果你现在看到，我机器的启动时间是<code class="fe lm ln lo lp b"><strong class="jt io">0.093 sec</strong></code>😳 😯</p><p id="f10f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">那真是超级快。</p><p id="e9bf" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">此外，内存消耗显示低于<code class="fe lm ln lo lp b"><strong class="jt io">40 MB</strong></code> <strong class="jt io">。</strong>👌</p><p id="8f47" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">您还可以使用 GraalVM + Spring Native 生成一个优化的容器映像，该映像可以轻松部署并包含一个最小的操作系统层。</strong></p></div><div class="ab cl kq kr hr ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="ig ih ii ij ik"><h1 id="a5ef" class="ne mz in bd nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa bi translated"><strong class="ak">结论</strong></h1><p id="4b45" class="pw-post-body-paragraph jr js in jt b ju ob jw jx jy oc ka kb kc od ke kf kg oe ki kj kk of km kn ko ig bi translated">显然，您应该在您的机器上进行测试，以比较这些数字。但是，<strong class="jt io">这清楚地展示了 GraalVM 的真正力量，以及它将成为 Java 应用程序未来的原因。</strong>😄</p><p id="6a35" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">正如一些行业专家提到的—</p><figure class="lq lr ls lt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi om"><img src="../Images/a599e0d7455a65e085f9facab3a7edaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hGX2xgn77MgsV04ob7bU9A.png"/></div></div></figure><p id="7a11" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">原生图像有许多方面我还没有讨论，将在这篇文章接下来的部分讨论。我们将研究一些需要高级配置设置的极限情况，以及其他一些优化。</p><p id="789e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在<a class="ae ll" href="https://www.graalvm.org/" rel="noopener ugc nofollow" target="_blank">https://www.graalvm.org/</a>看看很酷的东西。</p><p id="c448" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">可以在评论里发表自己的看法，给出建议。</p><p id="9cea" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">谢谢😊</p><p id="0e66" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io"> <em class="kp">编辑:查看本文第二部分— </em> </strong></p><div class="lw lx gp gr ly lz"><a rel="noopener  ugc nofollow" target="_blank" href="/micronaut-application-comparison-with-spring-boot-and-support-for-graalvm-d0fb0d933d55"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd io gy z fp me fr fs mf fu fw im bi translated">Spring 的问题，Micronaut 如何解决它，以及后者对 GraalVM 的支持</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">微型机器人在春天证明了它的勇气</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">blog.devgenius.io</p></div></div><div class="mi l"><div class="on l mk ml mm mi mn jp lz"/></div></div></a></div></div></div>    
</body>
</html>