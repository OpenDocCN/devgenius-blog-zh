<html>
<head>
<title>3 ways to host a single-page application on Google App Engine 💡</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Google App Engine 上托管单页面应用程序的 3 种方式💡</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/3-ways-to-host-a-single-page-application-on-google-app-engine-cf757d373f92?source=collection_archive---------8-----------------------#2022-02-25">https://blog.devgenius.io/3-ways-to-host-a-single-page-application-on-google-app-engine-cf757d373f92?source=collection_archive---------8-----------------------#2022-02-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="d3c1" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">React + NestJS 在 GAE 上的应用</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/7f8260b82a6be2bf905e5190e06b09ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6T1LE0Q9gWcSad7gqsOdhg.png"/></div></div></figure><p id="5d3b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这更多的是描述我个人的开发和调试经验，而不是关于这个主题的一步一步的教程。欢迎对任何错误进行更正！如果这篇文章对你有帮助，你可以阅读我的其他文章:<a class="ae lk" href="https://hungvu.tech/?utm_source=medium.com&amp;utm_medium=referral&amp;utm_campaign=medium_crossposting" rel="noopener ugc nofollow" target="_blank">https://hungvu.tech/</a>。</p><h1 id="a97c" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">问题陈述🍀</h1><p id="6f98" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">我有一个用 NestJS 作为后端的 React 应用程序。Google App Engine 是我的目标部署环境。在我的<a class="ae lk" href="https://hungvu.tech/brainstorm-a-deployment-process-from-github-to-google-app-engine-and-cloud-sql-part-2?utm_source=medium.com&amp;utm_medium=referral&amp;utm_campaign=medium_crossposting" rel="noopener ugc nofollow" target="_blank"> Google App Engine 部署文章</a>中，我成功地制作了一个虚拟 NodeJS 应用程序部署到 App Engine，但是，它不包括前端。现在，我应该如何在那里托管我的单页应用程序呢？</p><p id="71aa" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我的文件夹结构如下。</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="aed8" class="mn lm in mj b gy mo mp l mq mr">- root<br/>   - .github/workflows<br/>   - front-end<br/>   - back-end</span></pre><h1 id="2916" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">有哪些做法？🤔</h1><p id="9e03" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">我知道有三种方式。</p><ol class=""><li id="f96c" class="ms mt in kq b kr ks ku kv kx mu lb mv lf mw lj mx my mz na bi translated">使用两个 App Engine 服务和<code class="fe nb nc nd mj b">dispatch.yaml</code>。</li><li id="ee3a" class="ms mt in kq b kr ne ku nf kx ng lb nh lf ni lj mx my mz na bi translated">使用一个应用引擎服务来托管 React 和 NestJS 应用。</li><li id="93e5" class="ms mt in kq b kr ne ku nf kx ng lb nh lf ni lj mx my mz na bi translated">使用一个应用引擎服务来托管 NestJS 应用，使用另一个服务器来托管静态 React 文件。</li></ol><h1 id="1d08" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">使用<code class="fe nb nc nd mj b">dispatch.yaml</code>🔑</h1><p id="7f39" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">当后端和前端是松散耦合时，这可以工作，我想利用谷歌身份感知代理。</p><h1 id="0e16" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">什么是<code class="fe nb nc nd mj b">dispatch.yaml</code>？</h1><p id="a12c" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">这是一个用于<strong class="kq io">应用引擎服务</strong>的配置文件。术语<strong class="kq io">服务</strong>在这里类似于<strong class="kq io">一个计算引擎实例</strong>(虽然不是直接等价的)。一个<code class="fe nb nc nd mj b">dispatch.yaml</code>文件在应用引擎服务级别覆盖路由规则。意思是，在请求到达我的 API 之前。</p><h1 id="2fed" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">使用</h1><p id="a720" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">假设我的<code class="fe nb nc nd mj b">front-end</code>在<code class="fe nb nc nd mj b">react.uc.r.appspot.com/</code>部署到<strong class="kq io">服务 react </strong>，而<code class="fe nb nc nd mj b">back-end</code>在<code class="fe nb nc nd mj b">api.uc.r.appspot.com/</code>部署到<strong class="kq io">服务 api </strong>。</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="ab01" class="mn lm in mj b gy mo mp l mq mr"># dispatch.yaml<br/># Put this one in my 'front-end' folder<br/># Assuming this is a configuration for service "react"<br/># All requests to 'react.uc.r.appspot.com/api/*' are routed to 'api.uc.r.appspot.com/'<br/>dispatch:<br/>  - url: "react.uc.r.appspot.com/api/*"<br/>    service: api</span></pre><h1 id="edb9" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">优点和缺点</h1><ol class=""><li id="dd7d" class="ms mt in kq b kr md ku me kx nj lb nk lf nl lj mx my mz na bi translated">优势</li></ol><ul class=""><li id="33da" class="ms mt in kq b kr ks ku kv kx mu lb mv lf mw lj nm my mz na bi translated">无需担心同源问题(例如，CORS)，因为资源是通过同一个域提供的。</li><li id="d3b1" class="ms mt in kq b kr ne ku nf kx ng lb nh lf ni lj nm my mz na bi translated">可以将前端和后端的部署分开(例如，创建仅当某个路径上的文件被更新时才运行的工作流)。固有地增加冗余和弹性。</li><li id="d1db" class="ms mt in kq b kr ne ku nf kx ng lb nh lf ni lj nm my mz na bi translated">减少服务器负载。</li><li id="25b8" class="ms mt in kq b kr ne ku nf kx ng lb nh lf ni lj nm my mz na bi translated">两者都可以受到谷歌身份感知代理的保护。</li></ul><p id="5443" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">2.不足之处</p><ul class=""><li id="7f8a" class="ms mt in kq b kr ks ku kv kx mu lb mv lf mw lj nm my mz na bi translated">当前端严重依赖后端时不适用，这将在下一个方法中进一步讨论。</li><li id="c944" class="ms mt in kq b kr ne ku nf kx ng lb nh lf ni lj nm my mz na bi translated">可能会增加成本，因为有 2 个在线应用引擎服务。</li></ul><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="17fa" class="mn lm in mj b gy mo mp l mq mr"># Sample of CORS error<br/>   Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at ...</span></pre><h1 id="07c9" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">后端存储反应资产并静态地为它们服务🔑</h1><p id="e99e" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">与第一种方法不同，当前端在第一次加载时需要来自后端的资源时，这种方法会有所帮助。例如，我的 React 应用程序需要一个 CSRF 令牌来使用我的 API。CSRF 令牌必须在用户第一次访问我的网站时可用。为此，我的 React 应用程序必须作为来自 NodeJS 后端的静态文件。</p><h1 id="8d13" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">使用</h1><p id="1dbf" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">以下说明适用于 NestJS 框架。我的应用程序只部署到一个域<code class="fe nb nc nd mj b">back-end.uc.r.appspot.com</code>。</p><ul class=""><li id="19ac" class="ms mt in kq b kr ks ku kv kx mu lb mv lf mw lj nm my mz na bi translated">在我的 GitHub 工作流中，在 React 构建过程完成后，我将静态 React 文件复制到了<code class="fe nb nc nd mj b">back-end</code>文件夹中。</li></ul><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="9d52" class="mn lm in mj b gy mo mp l mq mr"># CI/CD pipeline<br/>  steps: <br/>    ...<br/>    - name: Build front-end<br/>       ...<br/>    - name: Copy front-end built to back-end folder<br/>      working-directory: front-end<br/>      run: |<br/>        mkdir -p ../back-end/assets<br/>        cp -R build ../back-end/assets</span></pre><ul class=""><li id="2e4d" class="ms mt in kq b kr ks ku kv kx mu lb mv lf mw lj nm my mz na bi translated">在<code class="fe nb nc nd mj b">nest-cli.json</code>中，使用<code class="fe nb nc nd mj b">compilerOptions</code>将 React 资产复制到 NestJS <code class="fe nb nc nd mj b">dist</code>构建中。</li></ul><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="2f17" class="mn lm in mj b gy mo mp l mq mr">{<br/>    ...<br/>    "soruceRoot": "src",<br/>    "compilerOptions": {<br/>      "assets": ["../assets/"]<br/>    }<br/>}</span></pre><ul class=""><li id="3290" class="ms mt in kq b kr ks ku kv kx mu lb mv lf mw lj nm my mz na bi translated">仅将<code class="fe nb nc nd mj b">back-end</code>文件夹部署到应用引擎。包含 React 文件，可以静态提供。</li></ul><h1 id="015d" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">优点和缺点</h1><ol class=""><li id="9a4a" class="ms mt in kq b kr md ku me kx nj lb nk lf nl lj mx my mz na bi translated">优势</li></ol><ul class=""><li id="8e8d" class="ms mt in kq b kr ks ku kv kx mu lb mv lf mw lj nm my mz na bi translated">降低成本，因为只有一个在线应用引擎服务。</li><li id="0da2" class="ms mt in kq b kr ne ku nf kx ng lb nh lf ni lj nm my mz na bi translated">无需担心同源问题(例如，CORS)，因为资源是通过同一个域提供的。</li><li id="7e6b" class="ms mt in kq b kr ne ku nf kx ng lb nh lf ni lj nm my mz na bi translated">可以由谷歌身份感知代理保护。</li><li id="81af" class="ms mt in kq b kr ne ku nf kx ng lb nh lf ni lj nm my mz na bi translated">使用紧密耦合的 web 应用程序。</li></ul><p id="87cb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">2.不足之处</p><ul class=""><li id="08fe" class="ms mt in kq b kr ks ku kv kx mu lb mv lf mw lj nm my mz na bi translated">增加服务器负载，因为整个单页面应用程序都依赖于相同的应用引擎服务。</li><li id="21f7" class="ms mt in kq b kr ne ku nf kx ng lb nh lf ni lj nm my mz na bi translated">无法单独部署后端和前端。一个地方的改变需要全新的部署。固有地降低冗余和弹性。</li></ul><h1 id="8170" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">静态服务，但是 React 文件托管在另一个服务器上🔑</h1><p id="dfcb" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">一种常见的策略是使用(例如 Google 云存储桶),这种策略针对托管静态文件进行了优化，可以极大地提高性能。您还可以针对其他方面进一步微调服务器。</p><h1 id="c51b" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">使用</h1><p id="c45e" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">它本质上与第二种方法相同，但是根据情况有不同的配置，所以我不深入讨论。使用 App Engine 从 Google 云存储桶提供静态文件的示例可以在这里找到<a class="ae lk" href="https://cloud.google.com/appengine/docs/standard/go/serving-static-files" rel="noopener ugc nofollow" target="_blank">(官方 Google Cloud 文档)</a>。</p><h1 id="675b" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">优点和缺点</h1><ol class=""><li id="68fc" class="ms mt in kq b kr md ku me kx nj lb nk lf nl lj mx my mz na bi translated">优势</li></ol><ul class=""><li id="1b7b" class="ms mt in kq b kr ks ku kv kx mu lb mv lf mw lj nm my mz na bi translated">更好的冗余和弹性。</li><li id="3e23" class="ms mt in kq b kr ne ku nf kx ng lb nh lf ni lj nm my mz na bi translated">更好的性能和更容易微调。</li><li id="423a" class="ms mt in kq b kr ne ku nf kx ng lb nh lf ni lj nm my mz na bi translated">可以将前端和后端的部署分开(例如，创建仅当某个路径上的文件被更新时才运行的工作流)。固有地增加冗余和弹性。</li></ul><p id="c936" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">2.不足之处</p><ul class=""><li id="8538" class="ms mt in kq b kr ks ku kv kx mu lb mv lf mw lj nm my mz na bi translated">可能面临同源问题(例如，CORS)，因为文件托管在另一个域中。</li><li id="4818" class="ms mt in kq b kr ne ku nf kx ng lb nh lf ni lj nm my mz na bi translated">可能无法为前端激活 Google 身份识别代理。</li><li id="ca8a" class="ms mt in kq b kr ne ku nf kx ng lb nh lf ni lj nm my mz na bi translated">使用紧密耦合的 web 应用程序。</li><li id="1e9a" class="ms mt in kq b kr ne ku nf kx ng lb nh lf ni lj nm my mz na bi translated">你需要有使用另一个静态文件托管服务的经验，使用不同的平台可以分散你的控制。</li></ul><h1 id="58f7" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">包裹🍀</h1><p id="268e" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">总而言之，我可以</p><ol class=""><li id="6d21" class="ms mt in kq b kr ks ku kv kx mu lb mv lf mw lj mx my mz na bi translated">如果我的 React 应用程序和后端是松散耦合的，则使用 2 个应用程序引擎服务。</li><li id="ba33" class="ms mt in kq b kr ne ku nf kx ng lb nh lf ni lj mx my mz na bi translated">当我需要更好的性能、冗余和弹性时，使用 App Engine 托管后端，而使用另一个服务托管静态文件。</li><li id="b3f7" class="ms mt in kq b kr ne ku nf kx ng lb nh lf ni lj mx my mz na bi translated">如果紧密耦合，使用 1 个应用程序引擎来托管整个单页面应用程序。</li></ol></div></div>    
</body>
</html>