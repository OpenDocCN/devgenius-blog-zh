<html>
<head>
<title>Getting Started with MIPS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MIPS 入门</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/getting-started-with-mips-8dcce04925d4?source=collection_archive---------9-----------------------#2022-12-31">https://blog.devgenius.io/getting-started-with-mips-8dcce04925d4?source=collection_archive---------9-----------------------#2022-12-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="0af4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用 MIPS 汇编语言释放低级编程的威力！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9d81df57c08575cb7568b5e8522f690b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X-WGNQCQ6D-5oTBGBFKD6g.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">丹尼尔·科岗摄影</figcaption></figure><blockquote class="ky kz la"><p id="95b2" class="jk jl lb jm b jn jo jp jq jr js jt ju lc jw jx jy ld ka kb kc le ke kf kg kh ig bi translated">这篇文章是针对那些对低级编程有所了解并且熟悉循环、条件等编程概念的人的。它不会深入钻研诸如 RISC 体系结构或以二进制补码形式存储二进制数的概念。</p></blockquote><p id="e066" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">MIPS ( <em class="lb">无互锁流水线级</em>微处理器)是一种精简指令集计算(<em class="lb"> RISC </em>)架构，在许多现代计算机处理器中使用。由于其简单高效，它是嵌入式系统和其他低功耗设备的流行选择。</p><p id="7f96" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你不熟悉 MIPS 汇编语言，你可能不知道从哪里开始。在本文中，我将简要介绍 MIPS 架构及其基本组件。此外，我们还将介绍一些重要的思想和方法，您需要了解这些思想和方法才能创建和执行您自己的 MIPS 汇编程序，并将它们与它们在高级语言中的工作方式进行比较。到本文结束时，您将有一个理解 MIPS 汇编语言的坚实基础，并且您将准备好进一步研究更复杂的问题。</p><p id="0db7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文中，我们将使用 Java 作为高级语言的例子。</p><h1 id="2e26" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">我们怎么运行 MIPS？</h1><p id="930a" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">尽管有专门设计来运行 MIPS 的处理器可供购买，但用 MIPS 编码的一个很好的免费选择是使用用 Java 编写的 Mars 仿真器。你可以在这里找到下载<a class="ae mi" href="http://courses.missouristate.edu/kenvollmar/mars/" rel="noopener ugc nofollow" target="_blank">！</a></p><div class="mj mk gp gr ml mm"><a href="http://courses.missouristate.edu/kenvollmar/mars/" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd io gy z fp mr fr fs ms fu fw im bi translated">火星 MIPS 模拟器-密苏里州立大学</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">一个用于 MIPS 汇编语言编程的 IDE MARS 是一个轻量级的交互式开发环境(IDE)</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">courses.missouristate.edu</p></div></div><div class="mv l"><div class="mw l mx my mz mv na ks mm"/></div></div></a></div><p id="d670" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是一个免费的工具，你可以用它来运行和调试你的 MIPS 代码。</p><h1 id="e685" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">变量与寄存器</h1><p id="864f" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">MIPS 和高级语言存储数据的方式有一个重要的区别。Java 将数据存储在开发人员可以定义的变量中。例如，<code class="fe nb nc nd ne b">String a = "12"</code>定义了对指定值“12”的引用。MIPS 不是这样工作的——我们使用预定义的“寄存器”来存储数据。我们将在本文中使用的寄存器是“s”和“t”寄存器，也称为特殊寄存器和临时寄存器。我们也可以使用“a”和“v”寄存器，它们分别作为函数的输入和输出。根据您用来运行 MIPS 的处理器/仿真器，有一定数量的寄存器。这些寄存器可以存储 32 位带符号二进制补码值。</p><p id="ab54" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是因为这些寄存器专门绑定到处理器(或仿真器)上的位置，而变量通常存储在堆中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/e4e4f97ee1f7c12105521d2abf34b1b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1u-Lxzb4dUKv1wR5HBicSQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">原始照片由<a class="ae mi" href="https://unsplash.com/@thisisramiro?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Ramiro Mendes </a>在<a class="ae mi" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="6fbe" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">数据类型</h1><p id="e8ef" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">在上一节中，存储一个字符串被比作存储一个“32 位有符号二进制补码值”，但是这是如何工作的呢？MIPS 不像 Java 那样存储特定的数据类型。它存储所有的整数，我们定义如何处理它。那么我们如何在 MIPS 中存储一个字符串呢？我将展示一个例子:</p><pre class="kj kk kl km gt ng ne nh bn ni nj bi"><span id="68a8" class="nk lg in ne b be nl nm l nn no">.data<br/>################# .data means necessary data is stored here<br/>a: .asciiz "12" # define an ascii string in label a<br/>################# labels will be discussed later in the article<br/><br/>.text<br/>########### .text means executable code is stored here<br/>la $t0, a # la = load address. We are loading the address stored in label a<br/>########### t0 now contains an reference to where each character of "12" is stored</span></pre><p id="ca11" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这意味着我们的代码通常不如 java 这样的语言可读，因为我们的寄存器不能为特定的目的使用唯一的名称，并且在读取代码时，特定寄存器的预期数据类型并不明显。</p><h1 id="b8e8" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">标签、分支和执行顺序</h1><p id="f7d5" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">MIPS 中我们必须理解的一个重要元素是执行顺序。像许多编程语言一样，MIPS 代码按照编写的顺序执行:例如第 1 行-&gt;第 2 行-&gt;第 3 行…等等。然而，在像 Java 这样的语言中，你可以在类中的任何位置定义函数，并从其他函数中调用它们。这在 MIPS 中的工作方式略有不同。我们必须定义<code class="fe nb nc nd ne b">Labels</code>来“跳转”到，而不是调用函数。这类似于为 X 行定义一个名称，然后跳转到标签就是跳转到 X 行。这是循环中最常用的。例如，MIPS 中的一个<code class="fe nb nc nd ne b">while true</code>循环(无限)看起来像这样:</p><pre class="kj kk kl km gt ng ne nh bn ni nj bi"><span id="76c6" class="nk lg in ne b be nl nm l nn no">this_is_a_label:<br/>  # some code<br/>  j this_is_a_label</span></pre><p id="c71c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将被视为 while 循环。现在我们可以添加一些额外的代码来退出这个循环。我们可以用<code class="fe nb nc nd ne b">beq</code>或 branch_if_equal 指令来实现。该指令有多种变体如<code class="fe nb nc nd ne b">beqz blt bgt bltz etc...</code>或<em class="lb"> branch_if_equal_zero、branch_if_less_than、branch_if_greater_than、branch_if_less_than_zero 等</em>。这也是我们在 MIPS 中编写 if 语句的方式。让我们编辑前面的函数来退出循环</p><pre class="kj kk kl km gt ng ne nh bn ni nj bi"><span id="5195" class="nk lg in ne b be nl nm l nn no">li $t0, 0                     # load 0 into register t0<br/># li stands for load immediate. An immediate is a 16 bit integer. <br/># Therefore, li sets t0 to the immediate we provide<br/>this_is_a_label:              # define label<br/>  beqz $t0, exit_loop_label   # branch_if(t0)_equal_zero will be true, jumps to label in second arg<br/>  j this_is_a_label           # loop<br/>exit_loop_label:              # exit loop label<br/>  # ... end of program ...</span></pre><p id="190c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这条指令突然变得复杂了很多，但它展示了分支指令的基本思想。它验证条件是否为真，然后跳转到指定的标签。现在我们的 while 循环更像是<code class="fe nb nc nd ne b">while false</code>而不是<code class="fe nb nc nd ne b">while true</code>！</p><p id="466d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们展示一个 if 语句</p><pre class="kj kk kl km gt ng ne nh bn ni nj bi"><span id="7180" class="nk lg in ne b be nl nm l nn no">li $t0, 1<br/>bltz $t0, true_label<br/># where false is stored. will be ignored if branch condition is true<br/># ... do false stuff ....<br/>j end_statement # skip true label<br/>true_label:<br/># ...do true stuff...<br/>end_statement:<br/># end if statement</span></pre><p id="9657" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这涵盖了分支和跳转的基础，以及如何应用它来创建循环和条件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/7b48a8fbb5b3a1b35acbe9dcb4873274.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cmHubceKhrfTubLw8CjUmQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae mi" href="https://unsplash.com/@sammiechaffin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">余思敏燕雀</a>在<a class="ae mi" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的原始照片</figcaption></figure><h1 id="b592" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">系统调用</h1><p id="a3af" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">除了我们在 MIPS 中的传统功能之外，我们还可以通过系统调用或 syscalls 进行一些操作。你可以在这里找到 MIPS 系统调用的完整列表。这些系统调用允许我们访问特殊的功能，如文件输入/输出、打印、生成随机数、获取当前时间，甚至终止程序。让我们使用一个系统调用来打印一个整数:</p><pre class="kj kk kl km gt ng ne nh bn ni nj bi"><span id="2ba4" class="nk lg in ne b be nl nm l nn no">li $v0, 1    # load syscall number into v0. syscall 1 = print int<br/>li $a0, 45   # a0 is the input for syscall 1. It will print the int in a0<br/>syscall</span></pre><p id="dd56" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一个用来终止程序！</p><pre class="kj kk kl km gt ng ne nh bn ni nj bi"><span id="d383" class="nk lg in ne b be nl nm l nn no">end_of_program:<br/>  li $v0, 10 # load syscall number into v0. syscall 10 = terminate program<br/>  syscall</span></pre><p id="cd0f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">[电话与 1980 年苹果电脑通话的 img</p><p id="8161" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">总的来说，系统调用提供了一种增强 MIPS 代码功能的便捷方式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/c4bd5d68a20fbf573a29e2e2eb421b5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aWRF4bkXlSeRDmXLOuRKoA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae mi" href="https://unsplash.com/@lenneek?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Elena Koycheva </a>在<a class="ae mi" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的原始照片</figcaption></figure><h1 id="f206" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">加载和保存数据</h1><p id="6797" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">我们可以将目前所学的一切应用到 MIPS 中加载和保存数据。让我们以字符串数据类型为例。我们如何循环遍历每个字符并打印出来？MIPS 中的井字符串是空终止的，这意味着我们应该能够加载字符串的单个字节，然后从循环中取出<code class="fe nb nc nd ne b">beqz</code>。让我们现在试一下</p><pre class="kj kk kl km gt ng ne nh bn ni nj bi"><span id="4c00" class="nk lg in ne b be nl nm l nn no">.data ########### .data means necessary data is stored here<br/>hello_str: .asciiz "hello world" # define an ascii string in label hello_str<br/><br/>.text ########### .text means executable code is stored here<br/>la $t0, hello_str<br/>read_char_loop:<br/>  lbu $t1, 0($t0)         # load byte unsigned (non-negative) from address in t0 into t1<br/>  beqz $t1, end_char_loop # if t1 is 0, string is over. exit loop<br/>  move $a0, $t1           # copy value from t1 to a0 (we always print from a0)<br/>  li $v0, 11              # syscall for printing chars<br/>  syscall                 # print char in a0<br/>  addi $t0, $t0, 1        # move to next byte in t0 (next char)<br/>  j read_char_loop        # loop<br/>end_char_loop:<br/>  li $v0, 10<br/>  syscall                 # syscall 10 terminates program<br/>  </span></pre><p id="6b50" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如你所看到的，我们已经通过结合之前讨论的主题，在 MIPS 中快速跳转到更复杂的功能！</p><h1 id="90b2" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">功能</h1><p id="35ff" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">MIPS 有一个特殊的语法来声明函数，它在函数调用后保存指令的位置，并在函数完成时返回给它。它使用<code class="fe nb nc nd ne b">jal</code>或跳转链接关键字来实现。让我们定义一个函数，并探索代码实际上在做什么！</p><pre class="kj kk kl km gt ng ne nh bn ni nj bi"><span id="e78e" class="nk lg in ne b be nl nm l nn no">.data ########### .data means necessary data is stored here<br/>hello_str: .asciiz "hello function!" # define an ascii string in label hello_str<br/><br/>.text ########### .text means executable code is stored here<br/>main:<br/>  la $a0, hello_str  # load a0 with string address<br/>  jal print_chars    # run function<br/>  li $v0,10          # load syscall 10<br/>  syscall            # run syscall 10<br/><br/><br/>.globl print_chars<br/>print_chars:<br/>  # inputs: a0 = string address<br/>  move $t0, $a0             # copy value of a0 to t0<br/>  read_char_loop:<br/>    lbu $t1, 0($t0)         # load byte unsigned (non-negative) from address in t0 into t1<br/>    beqz $t1, end_char_loop # if t1 is 0, string is over. exit loop<br/>    move $a0, $t1           # copy value from t1 to a0 (we always print from a0)<br/>    li $v0, 11              # syscall for printing chars<br/>    syscall                 # print char in a0<br/>    addi $t0, $t0, 1        # move to next byte in t0 (next char)<br/>    j read_char_loop        # loop<br/>  end_char_loop:<br/>    jr $ra                  # exit function<br/>  </span></pre><p id="e2fe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的代码中，我们有一个主标签，它将输入加载到我们的函数中，调用我们的函数，然后在程序运行后终止程序。函数是用。globl decorator，这使得它可以全局访问。<code class="fe nb nc nd ne b">jal</code>关键字跳转到 print_chars 标签，同时在寄存器$ra 中存储下一行的地址:<code class="fe nb nc nd ne b">li $v0, 10</code>。在我们函数的结尾，我们<code class="fe nb nc nd ne b">jr</code>或者跳转寄存器回到$ra 中存储的值，继续我们的程序。这允许我们定义更复杂的程序，包括使用像高级编程语言这样的函数。</p><h1 id="4610" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">堆栈</h1><p id="ea05" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">堆栈是计算机内存的一部分，用于在程序运行时保存临时数据。函数参数、局部变量和返回地址只是保存在 MIPS 体系结构中的堆栈上的数据类型的几个例子。</p><p id="8784" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">随着更多的数据加载到堆栈中，堆栈指针$ sp(MIPS 处理器中对应于堆栈顶部的寄存器)递减，以指向堆栈上的下一个可用位置。MIPS 中的堆栈向下攀升，这意味着堆栈的顶部位于最高的内存地址。当数据弹出堆栈时，堆栈指针递增以释放不必要的数据。</p><p id="c08d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里有一个在 mips 中如何做到这一点的例子</p><pre class="kj kk kl km gt ng ne nh bn ni nj bi"><span id="2a60" class="nk lg in ne b be nl nm l nn no">addi $sp, $sp, -4      # allocate 4 bytes in the stack<br/>li $t0, 1              # set t0 to value we want to preserve<br/>sw $t0, 0($sp)         # save this value in allocated space<br/>                       # sw = save word, saves 4 bytes to stack<br/># do something to overwrite t0<br/>lw $t0, 0($sp)         # load value from allocated space<br/>addi $sp, $sp, 4       # deallocate space in the stack</span></pre><p id="43c1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个例子中，一个字(4 个字节)被分配到堆栈中，我们在堆栈中存储一个我们需要的字，运行一个可能会覆盖保存我们重要信息的寄存器的操作，然后将值恢复到寄存器中并释放堆栈。</p><p id="f943" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们将这一课应用到前面的 print_chars 函数中:</p><pre class="kj kk kl km gt ng ne nh bn ni nj bi"><span id="3cca" class="nk lg in ne b be nl nm l nn no">.data ########### .data means necessary data is stored here<br/>hello_str: .asciiz "hello function!" # define an ascii string in label hello_str<br/><br/>.text ########### .text means executable code is stored here<br/>main:<br/>  la $a0, hello_str         # load a0 with string address<br/>  jal print_chars           # run function<br/>  li $v0,10                 # load syscall 10<br/>  syscall                   # run syscall 10<br/><br/>.globl print_chars<br/>print_chars:<br/>  # inputs: a0 = string address<br/>  move $t0, $a0             # copy value of a0 to t0<br/>  read_char_loop:<br/>    addi $sp, $sp, -4       # allocate 4 bytes in the stack<br/>    sw $ra, 0($sp)          # save value of $ra to stack<br/>    jal print_one_char      # call function<br/>    lw $ra, 0($sp)          # load $ra from stack<br/>    addi $sp, $sp, 4        # deallocate stac<br/>    beqz $v0, end_char_loop # if v0=0, exit function else continue<br/>    addi $t0, $t0, 1        # move to next byte in t0 (next char)<br/>    j read_char_loop        # loop<br/>  end_char_loop:<br/>    jr $ra                  # exit function<br/><br/>.globl print_one_char<br/>print_one_char:<br/>  # inputs: a0 = address of one char<br/>  # outputs: v0 = end or continue<br/>  lbu $t1, 0($t0)           # load byte unsigned (non-negative) from address in t0 into t1<br/>  beqz $t1, end_char_funct  # if t1 is 0, string is over. exit loop<br/>  move $a0, $t1             # copy value from t1 to a0 (we always print from a0)<br/>  li $v0, 11                # syscall for printing chars<br/>  syscall                   # print char in a0<br/>  li $v0, 1                 # continue<br/>  jr $ra<br/>  end_char_funct:<br/>    li $v0, 0               # char is 0. Do not continue<br/>    jr $ra</span></pre><p id="1e41" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个程序不必要的复杂，但是它说明了本文中显示的概念以及如何使用堆栈和嵌套函数。堆栈的另一个用途是保存 s 寄存器——因为它们是特殊的，在程序运行之前和之后必须是相同的，如果我们需要这些寄存器，我们可以将它们以前的值存储在堆栈中并恢复它们！</p><h1 id="5d11" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="d779" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">总之，学习 MIPS 最初可能看起来令人生畏，但是通过一些指导和练习，它是作为一名计算机程序员所具有的有用能力。编写高效和成功的 MIPS 程序需要理解 MIPS 体系结构和汇编语言背后的基本思想，如寄存器、指令和堆栈。熟悉可用于构建和调试 MIPS 代码的工具和资源，包括模拟器和调试器，在学习过程中也会非常有益。只要有一点毅力和承诺，任何人都可以钻研低级编程的世界！</p><p id="b574" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您想继续学习 MIPS 并学习如何对您的低级代码应用单元测试，请查看我的文章！</p><div class="mj mk gp gr ml mm"><a rel="noopener  ugc nofollow" target="_blank" href="/introduction-to-unit-testing-in-munit-4ce7e24ff3f4"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd io gy z fp mr fr fs ms fu fw im bi translated">MUnit 中的单元测试介绍</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">低级代码不一定是未经测试的代码</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">blog.devgenius.io</p></div></div><div class="mv l"><div class="nr l mx my mz mv na ks mm"/></div></div></a></div><p id="3ece" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你也可以看看我的 MIPS 内容阅读列表，如下所示！</p><div class="mj mk gp gr ml"><div role="button" tabindex="0" class="ab bv gv cb fp ns nt bn nu ks ex"><div class="nv l"><div class="ab q"><div class="l di"><img alt="Daniel Kogan" class="l de bw nw nx fe" src="../Images/7850667f0a1b3a4df3d10e38d40dd0d7.png" width="20" height="20" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fill:40:40/1*AndoyUY0KtYQlny-dNuRJg.jpeg"/><div class="fb bw l nw nx fc n aw fd"/></div><div class="hh l fo"><p class="bd b dl z fp fq fr fs ft fu fv fw dk translated">丹尼尔·科岗</p></div></div><div class="oa ob gw l"><h2 class="bd io tk tl fp tm fr fs ms fu fw im bi translated">MIPS 和 MUnit 测试</h2></div><div class="ab q"><div class="l fo"><a class="bd b be z bi tn au to tp tq pw tr an eh ei ts tt tu el em eo de bk ep" href="https://medium.com/@danielkoganx/list/mips-and-munit-testing-77aed8ce48dc?source=post_page-----8dcce04925d4--------------------------------" rel="noopener follow" target="_top">View list</a></div><div class="tv l fo"><span class="bd b dl z dk">4 stories</span></div></div></div><div class="on dh oo fp ab op fo di"><div class="di of bv og oh"><div class="dh l"><img alt="" class="dh" src="../Images/93848048ab761a945c8634426d023c84.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/1*X-WGNQCQ6D-5oTBGBFKD6g.png"/></div></div><div class="di of bv oi oj ok"><div class="dh l"><img alt="" class="dh" src="../Images/a8678d135b4f27785654f1c415747a04.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/1*xGaSWaMkMcySOhu6auTzRA.png"/></div></div><div class="di bv ol om ok"><div class="dh l"><img alt="" class="dh" src="../Images/b425d085e8a13ad518556bf490421e71.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/1*zxdQQn_P6Xu44foCqO55Qw.png"/></div></div></div></div></div></div></div>    
</body>
</html>