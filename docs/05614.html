<html>
<head>
<title>Making HTTP Requests with React Query — Async Mutations and Invalidate Requests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React Query发出HTTP请求—异步突变和无效请求</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/making-http-requests-with-react-query-async-mutations-and-invalidate-requests-2c0c38e7e1c4?source=collection_archive---------6-----------------------#2021-09-17">https://blog.devgenius.io/making-http-requests-with-react-query-async-mutations-and-invalidate-requests-2c0c38e7e1c4?source=collection_archive---------6-----------------------#2021-09-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/896e0a5b4fe70e8544a94ca179b6536a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Lf0P9fcUePnqVDj8"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">史蒂文·拉斯利在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="19e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React查询库让我们可以在React应用程序中轻松地发出HTTP请求。</p><p id="cda7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解如何使用React Query发出HTTP请求。</p><h1 id="d652" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe lz ma mb mc b">mutateAsync</code></h1><p id="a7ec" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lz ma mb mc b">mutateAsync</code>方法让我们称<code class="fe lz ma mb mc b">mutate</code>为异步方式。</p><p id="a452" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它返回一个承诺，让我们以异步方式提交突变请求，这不会阻塞JavaScript主线程。</p><p id="3ad8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="dd86" class="mq lc iq mc b gy mr ms l mt mu">import axios from "axios";<br/>import React, { useState } from "react";<br/>import { useMutation } from "react-query";</span><span id="cc35" class="mq lc iq mc b gy mv ms l mt mu">export default function App() {<br/>  const { reset, mutateAsync } = useMutation((data) =&gt;<br/>    axios.post("https://jsonplaceholder.typicode.com/posts", data)<br/>  );<br/>  const [title, setTitle] = useState("");</span><span id="7ebe" class="mq lc iq mc b gy mv ms l mt mu">  const onCreateTodo = async (e) =&gt; {<br/>    e.preventDefault();<br/>    try {<br/>      const todo = await mutateAsync({<br/>        title<br/>      });<br/>      console.log(todo);<br/>    } catch (error) {<br/>      console.log(error);<br/>    } finally {<br/>      console.log("done");<br/>    }<br/>  };</span><span id="df79" class="mq lc iq mc b gy mv ms l mt mu">  return (<br/>    &lt;div&gt;<br/>      &lt;form onSubmit={onCreateTodo}&gt;<br/>        &lt;input<br/>          type="text"<br/>          value={title}<br/>          onChange={(e) =&gt; setTitle(e.target.value)}<br/>        /&gt;<br/>        &lt;br /&gt;<br/>        &lt;button type="submit"&gt;Create Todo&lt;/button&gt;<br/>        &lt;button type="button" onClick={() =&gt; reset()}&gt;<br/>          reset<br/>        &lt;/button&gt;<br/>      &lt;/form&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="30e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe lz ma mb mc b">mutateAsync</code>，它返回一个承诺和来自<code class="fe lz ma mb mc b">axios.post</code>调用的响应数据。</p><h1 id="3d46" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">重试突变</h1><p id="3f9c" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">使用React Query，如果它返回一个错误，我们可以很容易地重试我们的突变HTTP请求。</p><p id="6e86" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只需将<code class="fe lz ma mb mc b">retry</code>选项设置为我们想要重试的次数。</p><p id="fc84" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="ef61" class="mq lc iq mc b gy mr ms l mt mu">import axios from "axios";<br/>import React, { useState } from "react";<br/>import { useMutation } from "react-query";</span><span id="1085" class="mq lc iq mc b gy mv ms l mt mu">export default function App() {<br/>  const { reset, mutateAsync } = useMutation(<br/>    (data) =&gt; axios.post("https://jsonplaceholder.typicode.com/posts", data),<br/>    {<br/>      retry: 3<br/>    }<br/>  );<br/>  const [title, setTitle] = useState("");</span><span id="70e0" class="mq lc iq mc b gy mv ms l mt mu">  const onCreateTodo = async (e) =&gt; {<br/>    e.preventDefault();<br/>    try {<br/>      const todo = await mutateAsync({<br/>        title<br/>      });<br/>      console.log(todo);<br/>    } catch (error) {<br/>      console.log(error);<br/>    } finally {<br/>      console.log("done");<br/>    }<br/>  };</span><span id="8f46" class="mq lc iq mc b gy mv ms l mt mu">  return (<br/>    &lt;div&gt;<br/>      &lt;form onSubmit={onCreateTodo}&gt;<br/>        &lt;input<br/>          type="text"<br/>          value={title}<br/>          onChange={(e) =&gt; setTitle(e.target.value)}<br/>        /&gt;<br/>        &lt;br /&gt;<br/>        &lt;button type="submit"&gt;Create Todo&lt;/button&gt;<br/>        &lt;button type="button" onClick={() =&gt; reset()}&gt;<br/>          reset<br/>        &lt;/button&gt;<br/>      &lt;/form&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="d37c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果变异请求失败，我们用一个属性设置为3的对象调用<code class="fe lz ma mb mc b">useMutation</code>钩子来重试3次。</p><h1 id="6099" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使查询无效</h1><p id="978a" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以使查询无效，这样我们就可以将查询请求标记为陈旧，并自动再次发出请求。</p><p id="b4a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><p id="e7a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">index.js</code></p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="33b1" class="mq lc iq mc b gy mr ms l mt mu">import { StrictMode } from "react";<br/>import ReactDOM from "react-dom";<br/>import { QueryClient, QueryClientProvider } from "react-query";<br/>import App from "./App";</span><span id="c1fa" class="mq lc iq mc b gy mv ms l mt mu">const queryClient = new QueryClient();<br/>queryClient.invalidateQueries("yesNo", { exact: true });</span><span id="79c7" class="mq lc iq mc b gy mv ms l mt mu">const rootElement = document.getElementById("root");<br/>ReactDOM.render(<br/>  &lt;QueryClientProvider client={queryClient}&gt;<br/>    &lt;StrictMode&gt;<br/>      &lt;App /&gt;<br/>    &lt;/StrictMode&gt;<br/>  &lt;/QueryClientProvider&gt;,<br/>  rootElement<br/>);</span></pre><p id="3050" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">App.js</code></p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="e4a6" class="mq lc iq mc b gy mr ms l mt mu">import axios from "axios";<br/>import React from "react";<br/>import { useQuery } from "react-query";<br/>export default function App() {<br/>  const { data } = useQuery("yesNo", () =&gt; axios("https://yesno.wtf/api"));</span><span id="ea6a" class="mq lc iq mc b gy mv ms l mt mu">  return &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;<br/>}</span></pre><p id="1cb5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们称之为:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="05b2" class="mq lc iq mc b gy mr ms l mt mu">queryClient.invalidateQueries("yesNo", { exact: true });</span></pre><p id="b457" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过键使查询无效。</p><p id="85c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">exact</code>设置为<code class="fe lz ma mb mc b">true</code>意味着查询请求的键在失效前必须完全匹配。</p><h1 id="35be" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="9503" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们异步运行变异请求，并使查询请求无效，以便用Reacr Query再次发出请求。</p></div></div>    
</body>
</html>