<html>
<head>
<title>Debugging Go in Kubernetes with Delve and Tilt</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Delve 和 Tilt 在 Kubernetes 进行调试</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/debugging-go-in-kubernetes-with-delve-and-tilt-3014644378a2?source=collection_archive---------4-----------------------#2022-10-06">https://blog.devgenius.io/debugging-go-in-kubernetes-with-delve-and-tilt-3014644378a2?source=collection_archive---------4-----------------------#2022-10-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="5b1d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本文的想法是介绍一种调试运行在 Kubernetes 中的 Go 应用程序的简单方法。</p><p id="0c76" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们言归正传之前，让我们简单介绍一下我们将要使用的工具。</p><p id="1503" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">为什么是调试器？</strong></p><p id="2c97" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">谁没有发现他们的程序由于某种未知的原因而无法工作？在这种情况下，令人惊讶的是(或者不是)大多数人用于调试的是<code class="fe ki kj kk kl b">Println</code>。我承认滥用它无数次…</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/ab5437b646e416ac070a70c0b453d50c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HxDayZ4_vXeUQ8_g5ovz-Q.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae lc" href="https://github.com/MariaLetta/free-gophers-pack" rel="noopener ugc nofollow" target="_blank">https://github.com/MariaLetta/free-gophers-pack</a></figcaption></figure><p id="0043" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通常使用<code class="fe ki kj kk kl b">Println</code>是一个坏主意，因为它效率低下，因为您需要手动添加所有的变量，除了让代码变得混乱之外，还存在未覆盖的情况未打印的风险。</p><blockquote class="ld le lf"><p id="e5b0" class="jk jl lg jm b jn jo jp jq jr js jt ju lh jw jx jy li ka kb kc lj ke kf kg kh ig bi translated">调试器前来解救！</p></blockquote><p id="e2c7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了解决这个问题，我们将使用<a class="ae lc" href="https://github.com/go-delve/delve" rel="noopener ugc nofollow" target="_blank"><strong class="jm io">delver</strong></a>，一个 Golang 调试器。解释它是如何工作的不在本文的范围内，但是有很多好的教程。使用调试器的一些优点是:</p><ul class=""><li id="ee64" class="lk ll in jm b jn jo jr js jv lm jz ln kd lo kh lp lq lr ls bi translated">在调试点检查所有变量。</li><li id="b17a" class="lk ll in jm b jn lt jr lu jv lv jz lw kd lx kh lp lq lr ls bi translated">调用堆栈的可见性。</li><li id="eb84" class="lk ll in jm b jn lt jr lu jv lv jz lw kd lx kh lp lq lr ls bi translated">动态更新变量。</li></ul><blockquote class="ld le lf"><p id="01a4" class="jk jl lg jm b jn jo jp jq jr js jt ju lh jw jx jy li ka kb kc lj ke kf kg kh ig bi translated">说得对……但是在 Kubernetes 集群上运行的应用程序呢？</p></blockquote><p id="4be4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">为什么倾斜？</strong></p><p id="109a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae lc" href="https://github.com/tilt-dev/tiltç" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> Tilt </strong> </a>是一个开源的微服务开发环境，开发者可以将他们的应用部署到 Kubernetes。</p><p id="9d94" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">主要目标是通过帮助本地持续开发应用程序并将其部署到本地 Kubernetes 集群中来简化开发人员的体验。它通过监控源代码并自动构建和推进部署来实现这一点。</p><p id="5c81" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一个有用的功能是提供 UI 来监控部署过程，其中包含所有部署和日志的信息。</p><blockquote class="ld le lf"><p id="cde1" class="jk jl lg jm b jn jo jp jq jr js jt ju lh jw jx jy li ka kb kc lj ke kf kg kh ig bi translated">让我们两全其美，深究与倾斜！</p><p id="0444" class="jk jl lg jm b jn jo jp jq jr js jt ju lh jw jx jy li ka kb kc lj ke kf kg kh ig bi translated">从现在开始，我假设您已经安装了<strong class="jm io">Dever</strong>和<strong class="jm io"> Tilt </strong>并且运行了一个本地的 Kubernetes 集群，我将使用<a class="ae lc" href="https://minikube.sigs.k8s.io/docs/start/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> Minikube </strong> </a>来实现它。</p></blockquote><p id="ed0c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">言归正传！</strong></p><p id="d03f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我再一次在更高的层次上解释我们试图实现什么，以便我们有一个清晰的思维模式。我们的想法是通过调试服务器启动我们的应用程序，并公开它，这样我们就可以从我们的终端或 IDE 远程连接来调试它，就像我们在机器上运行我们的应用程序一样。</p><p id="ca86" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我创建了一个简单的应用程序作为我们的实验品:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="bb74" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦我们有了应用程序，我们需要能够将应用程序部署到集群(请忽略构建映像的步骤，因为它是在我们接下来将看到的<code class="fe ki kj kk kl b">Tiltfile</code>中完成的):</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="a079" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有了这一切，我们只需编写我们的<code class="fe ki kj kk kl b">Tiltfile</code>，一个 Tilt <strong class="jm io"> </strong>将在启动时运行的文件。它是用<code class="fe ki kj kk kl b">Python</code>的方言<a class="ae lc" href="https://github.com/bazelbuild/starlark" rel="noopener ugc nofollow" target="_blank"> Starlark </a>写的。想了解更多，可以查看<a class="ae lc" href="https://docs.tilt.dev/tiltfile_concepts.html" rel="noopener ugc nofollow" target="_blank">公文</a>。</p><p id="1ec1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看一下文件，然后解释我们真正在做什么:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="6d53" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">虽然评论已经解释了每一步都做了什么，但是为了更好地理解，我将试着把它分解一下。</p><p id="e85f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我们创建几个变量，并允许使用<code class="fe ki kj kk kl b">allow_k8s_contexts.</code>函数将 Tilt 部署到我们的集群。</p><p id="1c82" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，我们用<code class="fe ki kj kk kl b">docker_build_with_restart</code>函数加载<code class="fe ki kj kk kl b">restart_process</code>扩展。</p><p id="b769" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">之后，我们在本地构建要在 docker 文件中使用的二进制文件。注意，在 docker 文件中，我们还安装了 Delve 调试器。</p><p id="15f1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后，我们调用<code class="fe ki kj kk kl b">docker_build_with_restart</code>函数，它基本上是<code class="fe ki kj kk kl b">docker_build</code>的一个包装器，来构建镜像，另外它知道如何在一个实时更新结束时重新启动这个过程。</p><p id="bf54" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，我们从 yaml 文件<code class="fe ki kj kk kl b">k8s_yaml(deployment.yaml)</code>创建 Kubernetes 部署，并用<code class="fe ki kj kk kl b">port_forward</code>对其进行配置。从广义上讲，这将引导来自本地端口的所有流量，我们使用了与 Delver 服务器端口<code class="fe ki kj kk kl b">50100</code>相同的端口，但它可能与 Delver 服务器本身暴露的 pod 端口不同。因此，这将允许我们本地连接到在集群中运行的调试器。</p><p id="3866" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">如何运行它</strong></p><p id="414d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们已经有了所有的部分，让我们看看如何用调试器服务器<strong class="jm io"> </strong>运行 Tilt，然后连接它。</p><p id="5cbd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了运行应用程序，我在<code class="fe ki kj kk kl b">Makefile</code>中创建了一个简单的 make 目标，如下所示:</p><pre class="kn ko kp kq gt ma kl mb mc aw md bi"><span id="cc5d" class="me mf in kl b gy mg mh l mi mj">.PHONY: tilt-up<br/>tilt-up:<br/>   eval $$(minikube docker-env) &amp;&amp; tilt up; tilt down</span></pre><p id="21c2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将启动 Tilt，从而运行 Tiltfile。运行该命令后，您将在集群中运行您的应用程序，公开调试器服务器端口<code class="fe ki kj kk kl b">50100</code>。查看 pod 日志，您应该会看到类似这样的内容:</p><pre class="kn ko kp kq gt ma kl mb mc aw md bi"><span id="f273" class="me mf in kl b gy mg mh l mi mj">sample-app │ API server listening at: [::]:50100<br/>sample-app │ 2022–10–02T20:51:33Z warning layer=rpc Listening for remote connections (connections are not authenticated nor encrypted)</span></pre><p id="cbd2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们已经准备好了应用程序，让我们连接到它。</p><pre class="kn ko kp kq gt ma kl mb mc aw md bi"><span id="22d1" class="me mf in kl b gy mg mh l mi mj">dlv connect localhost:50100 --api-version=2</span></pre><p id="9323" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您按顺序执行了所有步骤，您应该能够毫无问题地连接到调试器。</p><blockquote class="ld le lf"><p id="5181" class="jk jl lg jm b jn jo jp jq jr js jt ju lh jw jx jy li ka kb kc lj ke kf kg kh ig bi translated"><strong class="jm io">奖励:</strong>我将把配置您首选 IDE 的调试器作为一项任务留给您，以便远程连接到我们的调试服务器，而不是通过终端手动访问它。</p></blockquote><p id="3486" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">关闭</strong></p><p id="edb7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我希望这篇文章对你有用，我已经说服你下次至少试一试调试器😊</p><p id="7580" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 Kubernetes 集群中运行调试器的事实增加了一点复杂性，但是诚实地使用 Tilt 消除了大部分的麻烦。</p><p id="68c6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">欢迎任何建议或改进，请分享。</p><p id="e9ed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">编码快乐！</p></div></div>    
</body>
</html>