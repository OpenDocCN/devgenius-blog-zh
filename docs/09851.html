<html>
<head>
<title>Ruby Truthiness</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">红宝石真度</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/ruby-truthiness-b3c451e440ca?source=collection_archive---------9-----------------------#2022-09-17">https://blog.devgenius.io/ruby-truthiness-b3c451e440ca?source=collection_archive---------9-----------------------#2022-09-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/cea56f1274a9e0a31a5a5ba70cd8777d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*089VOp206Gtzu9kr"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">马库斯·温克勒在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="b266" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">表达“真”或“假”的能力在任何编程语言中都是一个重要的概念。它帮助我们建立条件逻辑，理解对象或表达式的状态。通常一个值是“真”还是“假”的概念在<code class="fe ky kz la lb b">boolean</code>数据类型中被捕获。一个<code class="fe ky kz la lb b">boolean</code>是一个对象，它的唯一目的是传达它是“真”还是“假”。</p><blockquote class="lc"><p id="9b84" class="ld le in bd lf lg lh li lj lk ll kx dk translated">"布尔运算最大的好处是，即使你错了，你也只错了一点点."</p><p id="a94e" class="ld le in bd lf lg lh li lj lk ll kx dk translated">—未知</p></blockquote></div><div class="ab cl lm ln hr lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ig ih ii ij ik"><h1 id="fe19" class="lt lu in bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">布尔运算</h1><p id="e702" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">在 Ruby 中，布尔值由<code class="fe ky kz la lb b">true</code>和<code class="fe ky kz la lb b">false</code>对象表示。像 Ruby 中的其他东西一样，布尔对象背后也有一个真实的类，你可以在<code class="fe ky kz la lb b">true</code>和<code class="fe ky kz la lb b">false</code>上调用方法。</p><figure class="mw mx my mz gt jo"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="3484" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以在条件句中使用这两个布尔对象。</p><h2 id="3b9c" class="nc lu in bd lv nd ne dn lz nf ng dp md kl nh ni mh kp nj nk ml kt nl nm mp nn bi translated">示例 1</h2><p id="782a" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">下面会一直输出<code class="fe ky kz la lb b">'hi'</code>。</p><figure class="mw mx my mz gt jo"><div class="bz fp l di"><div class="na nb l"/></div></figure><h2 id="c8fe" class="nc lu in bd lv nd ne dn lz nf ng dp md kl nh ni mh kp nj nk ml kt nl nm mp nn bi translated">示例 2</h2><p id="fec9" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">反之，下面会一直输出<code class="fe ky kz la lb b">'goodbye'</code>。</p><figure class="mw mx my mz gt jo"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="7a57" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在实际代码中，你不会在条件中直接使用<code class="fe ky kz la lb b">true</code>或<code class="fe ky kz la lb b">false</code>对象。相反，您可能会在条件表达式中计算一些表达式或方法调用。无论表达式是什么，它都应该计算为一个<code class="fe ky kz la lb b">true</code>或<code class="fe ky kz la lb b">false</code>对象。</p><h2 id="fe69" class="nc lu in bd lv nd ne dn lz nf ng dp md kl nh ni mh kp nj nk ml kt nl nm mp nn bi translated">示例 3</h2><figure class="mw mx my mz gt jo"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="8bfa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上述输出<code class="fe ky kz la lb b">"small number"</code>是因为表达式<code class="fe ky kz la lb b">num &lt; 10</code>的计算结果为<code class="fe ky kz la lb b">true</code>。</p><h2 id="2d0c" class="nc lu in bd lv nd ne dn lz nf ng dp md kl nh ni mh kp nj nk ml kt nl nm mp nn bi translated">实例 4</h2><p id="60b9" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">如果<code class="fe ky kz la lb b">some_method_call</code>返回真值，下面将输出<code class="fe ky kz la lb b">"it's true!"</code>。</p><figure class="mw mx my mz gt jo"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="7536" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当以这种方式使用方法调用作为条件表达式时，您通常会希望方法返回一个布尔值，而不是依赖于非布尔值返回值的真假。</p><h2 id="f56e" class="nc lu in bd lv nd ne dn lz nf ng dp md kl nh ni mh kp nj nk ml kt nl nm mp nn bi translated">实例 5</h2><p id="afa9" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">对两个表达式求值时，逻辑运算符将返回 truthy falsey 值。</p><ul class=""><li id="9026" class="no np in kc b kd ke kh ki kl nq kp nr kt ns kx nt nu nv nw bi translated"><code class="fe ky kz la lb b">&amp;&amp;</code>是“and”运算符，在下面的例子中，只有当两个表达式都为真时，才会返回<code class="fe ky kz la lb b">true</code>。</li></ul><figure class="mw mx my mz gt jo"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="fcfd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">没什么好惊讶的。但是请注意，我们不必将<code class="fe ky kz la lb b">num &gt; 10</code>放在括号中。这意味着 Ruby 的操作符优先级顺序认为<code class="fe ky kz la lb b">&gt;</code>比<code class="fe ky kz la lb b">&amp;&amp;</code>优先级高。换句话说，Ruby 没有被弄糊涂；它没想到你是想这么做:<code class="fe ky kz la lb b">num &gt; (10 &amp;&amp; num.odd?)</code>。</p><h2 id="6784" class="nc lu in bd lv nd ne dn lz nf ng dp md kl nh ni mh kp nj nk ml kt nl nm mp nn bi translated">实例 6</h2><p id="1409" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">你可以用<code class="fe ky kz la lb b">&amp;&amp;</code>链接任意多的表达式，它将从左到右进行计算。如果任意一个表达式为<code class="fe ky kz la lb b">false</code>，整个<code class="fe ky kz la lb b">&amp;&amp;</code>链将返回<code class="fe ky kz la lb b">false</code>。</p><figure class="mw mx my mz gt jo"><div class="bz fp l di"><div class="na nb l"/></div></figure><ul class=""><li id="6594" class="no np in kc b kd ke kh ki kl nq kp nr kt ns kx nt nu nv nw bi translated"><code class="fe ky kz la lb b">||</code>是“或”操作符，在下面的例子中，如果任一被评估对象为真，将返回<code class="fe ky kz la lb b">true</code>。它没有<code class="fe ky kz la lb b">&amp;&amp;</code>操作符严格。</li></ul><h2 id="b2be" class="nc lu in bd lv nd ne dn lz nf ng dp md kl nh ni mh kp nj nk ml kt nl nm mp nn bi translated">例 7</h2><p id="716e" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">返回<code class="fe ky kz la lb b">false</code>的唯一方法是如果所有表达式都是<code class="fe ky kz la lb b">false</code>。</p><figure class="mw mx my mz gt jo"><div class="bz fp l di"><div class="na nb l"/></div></figure><ul class=""><li id="9ee6" class="no np in kc b kd ke kh ki kl nq kp nr kt ns kx nt nu nv nw bi translated"><code class="fe ky kz la lb b">&amp;&amp;</code>和<code class="fe ky kz la lb b">||</code>操作符表现出一种被称为<em class="nx">短路</em>的行为，这意味着一旦能够保证返回值，它将停止对表达式求值。</li></ul><h2 id="d903" class="nc lu in bd lv nd ne dn lz nf ng dp md kl nh ni mh kp nj nk ml kt nl nm mp nn bi translated">实施例 8</h2><p id="9f99" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">当<code class="fe ky kz la lb b">&amp;&amp;</code>操作符遇到第一个<code class="fe ky kz la lb b">false</code>表达式时<em class="nx">会将</em>短路。</p><figure class="mw mx my mz gt jo"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="fabc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意上面的代码没有生成<code class="fe ky kz la lb b">ZeroDivisionError</code>。这是因为<code class="fe ky kz la lb b">&amp;&amp;</code>操作符甚至没有对第二个表达式求值；由于第一个表达式是<code class="fe ky kz la lb b">false</code>，所以可以短路返回<code class="fe ky kz la lb b">false</code>。</p><p id="2560" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另外，注意<code class="fe ky kz la lb b">false || 3/0</code>会产生一个错误。</p><figure class="mw mx my mz gt jo"><div class="bz fp l di"><div class="na nb l"/></div></figure><h2 id="0541" class="nc lu in bd lv nd ne dn lz nf ng dp md kl nh ni mh kp nj nk ml kt nl nm mp nn bi translated">示例 9</h2><p id="a262" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">当<code class="fe ky kz la lb b">||</code>遇到第一个<code class="fe ky kz la lb b">true</code>表达式时会短路。</p><figure class="mw mx my mz gt jo"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="275d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的代码没有生成<code class="fe ky kz la lb b">ZeroDivisionError</code>，因为<code class="fe ky kz la lb b">||</code>没有计算第二个表达式；遇到<code class="fe ky kz la lb b">true</code>后短路了。</p><p id="bc00" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">与之前类似，注意<code class="fe ky kz la lb b">true &amp;&amp; 3/0</code>会产生一个错误。</p><figure class="mw mx my mz gt jo"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="5970" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">依赖短路行为可能很危险，但有时却很方便。我们将在下面的普通 Ruby 代码中看到一些使用它的例子。</p><h1 id="c3f3" class="lt lu in bd lv lw ny ly lz ma nz mc md me oa mg mh mi ob mk ml mm oc mo mp mq bi translated">真实性</h1><p id="9200" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">在回顾了布尔和逻辑运算符之后，我们终于能够谈论“真”的概念了。真实与<code class="fe ky kz la lb b">true</code>的不同之处在于，Ruby 认为不仅仅是<code class="fe ky kz la lb b">true</code>对象是“真实的”。事实上，Ruby 是一种非常自由的语言，除了 <code class="fe ky kz la lb b"><em class="nx">false</em></code> <em class="nx">和</em> <code class="fe ky kz la lb b"><em class="nx">nil</em></code>之外，<em class="nx">认为一切都是真实的。</em></p><p id="45f9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这意味着我们可以在条件中使用任何表达式，或者使用逻辑运算符，只要它的计算结果不是<code class="fe ky kz la lb b">false</code>或<code class="fe ky kz la lb b">nil</code>，它就被认为是真的。注意，Ruby <em class="nx">认为真的表达式</em>与<code class="fe ky kz la lb b">true</code>对象不同。这就是“真实”的含义。让我们看一个例子。</p><figure class="mw mx my mz gt jo"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="cd94" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你对 Ruby 一无所知，你可能会猜测上面应该输出<code class="fe ky kz la lb b">"error!"</code>，或者程序应该产生某种错误。但是如果你运行那个代码，它实际上会输出<code class="fe ky kz la lb b">"valid number"</code>。原因是 Ruby 认为任何整数都是“真的”。然而，这并不意味着上面的<code class="fe ky kz la lb b">num</code>变量等于<code class="fe ky kz la lb b">true</code>:</p><figure class="mw mx my mz gt jo"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="0991" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这意味着即使是整数<code class="fe ky kz la lb b">0</code>也被认为是真的，而在其他一些语言中却不是这样。Ruby 爱好者利用 Ruby 的真实性编写一些有趣的代码。例如，有时您会在条件或逻辑运算符中看到赋值:</p><figure class="mw mx my mz gt jo"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="689e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">据推测，<code class="fe ky kz la lb b">find_name</code>方法要么返回一个有效的对象，要么返回<code class="fe ky kz la lb b">nil</code>或<code class="fe ky kz la lb b">false</code>。像这样写代码是危险的，很容易被其他人误解为相等比较，而不是赋值。</p><p id="1a22" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">更常见的是，您会看到这样的代码:</p><figure class="mw mx my mz gt jo"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="b14c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的<code class="fe ky kz la lb b">if</code>条件是检查<code class="fe ky kz la lb b">name</code>不是<code class="fe ky kz la lb b">nil</code>，然后检查<code class="fe ky kz la lb b">name</code>的有效性。如果<code class="fe ky kz la lb b">name</code>为<code class="fe ky kz la lb b">nil</code>，它就依靠<code class="fe ky kz la lb b">&amp;&amp;</code>短路行为不执行<code class="fe ky kz la lb b">name.valid?</code>来实现这一点。记住如果<code class="fe ky kz la lb b">&amp;&amp;</code>遇到<code class="fe ky kz la lb b">false</code>就会短路，而<code class="fe ky kz la lb b">nil</code>被认为是“假的”。</p><p id="6a79" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当包含条件、逻辑操作符和真实性考虑时，它会变得令人困惑。但是有了上面的知识，我们就可以慢慢练习拆开复杂的代码了。</p><blockquote class="od oe of"><p id="7ec4" class="ka kb nx kc b kd ke kf kg kh ki kj kk og km kn ko oh kq kr ks oi ku kv kw kx ig bi translated">记住这条规则:除了<code class="fe ky kz la lb b">false</code>和<code class="fe ky kz la lb b">nil</code>，Ruby 中的所有东西都被认为是“真实的”。</p></blockquote></div></div>    
</body>
</html>