<html>
<head>
<title>Elegantly Log Elapsed Time in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Java 优雅地记录运行时间</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/elegantly-log-elapsed-time-in-java-aa6f91938344?source=collection_archive---------3-----------------------#2021-09-02">https://blog.devgenius.io/elegantly-log-elapsed-time-in-java-aa6f91938344?source=collection_archive---------3-----------------------#2021-09-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="9ceb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">避免重复你的代码</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/58cde261b56386d3b2a6c2e231e83311.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pVp01gELCM6dsa1_"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">保罗·库科在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="ba56" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您是否曾经需要比较两种方法的性能？最简单的方法是记录每个方法的执行时间，您可能会得到如下结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kz la l"/></div></figure><p id="e62b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是如果你想比较两种以上的方法，这个过程会变得很难看，因为你最终会重复你自己:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kz la l"/></div></figure><p id="1ed7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这篇文章中，我将解释一个更好的方法。</p><h2 id="d5cc" class="lb lc in bd ld le lf dn lg lh li dp lj jv lk ll lm jz ln lo lp kd lq lr ls lt bi translated">不要重复你自己</h2><p id="835d" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">如果我们可以编写一个方法，让<strong class="jm io">将另一个方法</strong>作为参数，并在时间记录代码中运行那个方法(比如上面的那个)，那就更好了，事实证明我们可以使用<strong class="jm io"> <em class="lz"> Java 函数接口</em> </strong>和引用 的<strong class="jm io"> <em class="lz">方法来编写这样一个方法，但是那些是什么呢？</em></strong></p><h2 id="0e2e" class="lb lc in bd ld le lf dn lg lh li dp lj jv lk ll lm jz ln lo lp kd lq lr ls lt bi translated">Java 功能接口</h2><p id="472b" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated"><em class="lz">函数接口</em>是包含<strong class="jm io">且仅有一个</strong>抽象方法的接口。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kz la l"/></div></figure><p id="5642" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因为它只有一个方法，这意味着我们可以使用 lambda 实现这个接口，或者我们可以使用方法引用。</p><h2 id="3d1b" class="lb lc in bd ld le lf dn lg lh li dp lj jv lk ll lm jz ln lo lp kd lq lr ls lt bi translated">Java 方法引用</h2><p id="7ef5" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">顾名思义，方法引用就是传递一个要存储在变量中的方法的引用的过程，对于上面的接口，变量的类型将是<em class="lz"> MyFunctional，</em>我们是这样做的:</p><p id="6875" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我们创建一个<strong class="jm io">静态</strong>方法，它匹配我们接口中抽象方法的签名</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kz la l"/></div></figure><p id="7ec5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后我们将引用放入一个变量中，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kz la l"/></div></figure><p id="237d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">类似地，我们可以将方法引用传递给接受类型为<em class="lz"> MyFunctional </em>的参数的方法</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kz la l"/></div></figure><p id="41d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以这样调用上面的方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kz la l"/></div></figure><h2 id="9510" class="lb lc in bd ld le lf dn lg lh li dp lj jv lk ll lm jz ln lo lp kd lq lr ls lt bi translated">把所有的放在一起</h2><p id="cefc" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">剩下的就是在我们的<em class="lz"> logTime </em>方法中添加时间日志记录，结果是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kz la l"/></div></figure><h2 id="0471" class="lb lc in bd ld le lf dn lg lh li dp lj jv lk ll lm jz ln lo lp kd lq lr ls lt bi translated">微小的改进</h2><p id="6457" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">上面的代码使用了一个我们手工创建的函数接口，事实证明 Java 有内置的函数接口，我们可以用它来加快速度，</p><p id="a476" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种情况下，我们将使用<strong class="jm io"> <em class="lz">双函数&lt; T，U，R &gt; </em> </strong>，因为它符合<em class="lz"> myAdd 的</em>签名(它接受两个参数并返回结果)，您可以查找符合大多数常见方法签名的函数接口的<a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html" rel="noopener ugc nofollow" target="_blank">列表。</a></p><p id="e219" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用<strong class="jm io"> <em class="lz">双函数&lt; T，U，R &gt; </em> </strong>我们的代码将如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kz la l"/></div></figure><p id="d1e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以现在，每当我们想要记录一个接受两个整数参数并返回一个整数结果的方法时，我们可以简单地将它传递给上面的<em class="lz"> log </em>方法，如下所示</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kz la l"/></div></figure><h2 id="72af" class="lb lc in bd ld le lf dn lg lh li dp lj jv lk ll lm jz ln lo lp kd lq lr ls lt bi translated">额外注释</h2><p id="a518" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">在 Python 中，我们会做同样的事情，除了我们会使用<strong class="jm io"> <em class="lz">装饰者</em> </strong>来代替，并且由于函数是一级公民，我们会得到一个更有用的方案。</p></div></div>    
</body>
</html>