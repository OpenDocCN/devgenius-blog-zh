<html>
<head>
<title>Overloading the Subscripting[] Operator in C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 C++中重载 Subscripting[]运算符</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/overloading-the-subscripting-operator-in-c-1745e8818e02?source=collection_archive---------10-----------------------#2022-11-01">https://blog.devgenius.io/overloading-the-subscripting-operator-in-c-1745e8818e02?source=collection_archive---------10-----------------------#2022-11-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="9aca" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">在 C++中实现 Get/Set 的地图方括号索引</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/8982efb81c25b53f5984dee502d828e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*R17CbBd2MPM7-HsuPP_51Q.png"/></div></div></figure><h2 id="3bae" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">放弃</h2><p id="e402" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls kx lt lu lv lb lw lx ly lf lz ma mb mc ig bi translated">我喜欢误用“索引”这个词，把它当作一个动词来使用，意思是在数据结构(通常是数组或列表)的索引处查找值。我更喜欢误用这个意思，将它扩展为“索引”一个地图，这只是获取存储在键中的值。本质上，“索引”是在某物上使用方括号操作符(<code class="fe md me mf mg b">mymap[key]</code>)。我不知道我为什么这么说，也不知道这是否是一件常见的事情，但从快速的谷歌搜索来看，我怀疑它不是。</p><h2 id="34a1" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">序言</h2><p id="f0bd" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls kx lt lu lv lb lw lx ly lf lz ma mb mc ig bi translated">最近，我决定用 C++实现一个红黑树作为个人项目。这已经以<code class="fe md me mf mg b">std::map</code>和<code class="fe md me mf mg b">std::set</code>的形式存在，实现起来很痛苦，因为 segfaults 几乎在每一行都发生，但是这对于红黑树(我正在学校学习)和 C++来说都是一个很好的练习(这总是需要改进的)。我让我的树处理 get、set、inserts 和 remove，一切都很好。然而，我错过了 C#和 python 的简单语法，在这两种语言中，人们可以用<code class="fe md me mf mg b">map[key] = value</code>索引地图，而不是使用笨重的方法和点语法。在实践中，我们可以写点，这没什么大不了的，但这已经是一个实验了，所以为什么不试着让使用变得更简单(更酷)呢？</p><h2 id="cbe2" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">运算符重载</h2><p id="9525" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls kx lt lu lv lb lw lx ly lf lz ma mb mc ig bi translated">C++允许我们覆盖定制类型的几乎所有操作符，例如<code class="fe md me mf mg b">+</code>、<code class="fe md me mf mg b">-</code>、<code class="fe md me mf mg b">&gt;</code>、<code class="fe md me mf mg b">=</code>和订阅操作符<code class="fe md me mf mg b">[]</code>。C/C++中的正常行为是像在<code class="fe md me mf mg b">pointer[5] = *(pointer+5)</code>中一样自动执行指针运算和解引用，但是在语义上，它已经变得与索引(或下标，因此得名)数组、列表和映射同义。为类型重载该操作符的语法是使用签名<code class="fe md me mf mg b">&lt;returnType&gt; operator[](&lt;paramType&gt; &lt;param&gt;)</code>创建一个方法。单数参数对应于方括号内的内容。该方法可以在地图<code class="fe md me mf mg b">mymap</code>上作为<br/> <code class="fe md me mf mg b">&lt;returnType&gt; v = mymap[&lt;param&gt;];</code>调用</p><h2 id="e33d" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">重载树上的[]</h2><p id="c601" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls kx lt lu lv lb lw lx ly lf lz ma mb mc ig bi translated">像我们想要的那样实现订阅操作符有点困难，因为它需要服务于两个功能，获取和设置。我们不能直接引用值字段，因为它有特定的 getters 和 setters，我们不想暴露它。因此，我们需要根据操作符的使用方式和位置来改变行为。<code class="fe md me mf mg b">int val = mymap[key];</code>应该调用 getter 方法，而<code class="fe md me mf mg b">mymap[key] = val;</code>应该调用 setter/insertion。真的没有办法让两个重载具有不同的行为(你可以自己尝试一下，看看为什么)，所以我们必须想出一个更棘手的解决方案。我们可以让<code class="fe md me mf mg b">operator[]</code> a 返回一个“代理”对象，它重载操作符并根据对它做了什么调用正确的方法。</p><pre class="kd ke kf kg gt mi mg mj mk aw ml bi"><span id="7082" class="ko kp in mg b gy mm mn l mo mp">rbtree&lt;K, V&gt;::getSetProxy operator[](K key) {<br/>    return getSetProxy(this, key);<br/>}</span></pre><p id="78cb" class="pw-post-body-paragraph lk ll in lm b ln mq jo lp lq mr jr ls kx ms lu lv lb mt lx ly lf mu ma mb mc ig bi translated">现在呼叫<code class="fe md me mf mg b">int val = mymap[key];</code>变成了<code class="fe md me mf mg b">int val = getSetProxy;</code>，而<code class="fe md me mf mg b">mymap[key] = val;</code>变成了<code class="fe md me mf mg b">getSetProxy = val;</code></p><h2 id="f784" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">getSetProxy</h2><p id="ed7e" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls kx lt lu lv lb lw lx ly lf lz ma mb mc ig bi translated">这个代理对象将根据用户试图做的事情来处理获取和设置。代理的构造接受对树的引用，以便它可以执行操作，还接受键，以便它知道在哪里获取/设置/插入。</p><p id="501d" class="pw-post-body-paragraph lk ll in lm b ln mq jo lp lq mr jr ls kx ms lu lv lb mt lx ly lf mu ma mb mc ig bi translated">设定的情况相当简单。我们将使用赋值操作符<code class="fe md me mf mg b">=</code>来设置，所以我们可以重载它来调用 setter 方法。</p><pre class="kd ke kf kg gt mi mg mj mk aw ml bi"><span id="5f17" class="ko kp in mg b gy mm mn l mo mp">class getSetProxy {<br/>    rbtree&lt;K, V&gt; *theTree;<br/>    K key;<br/>...<br/>    void operator=(V value) {<br/>        if (!theTree-&gt;setValue(key, value)) {<br/>            theTree-&gt;insert(key, value);<br/>        }<br/>    }<br/>...<br/>}</span></pre><p id="6923" class="pw-post-body-paragraph lk ll in lm b ln mq jo lp lq mr jr ls kx ms lu lv lb mt lx ly lf mu ma mb mc ig bi translated">赋值右侧的值被设置或插入到树中的键上。</p><p id="34b1" class="pw-post-body-paragraph lk ll in lm b ln mq jo lp lq mr jr ls kx ms lu lv lb mt lx ly lf mu ma mb mc ig bi translated">Get 有点棘手。C++中有一个操作符叫做隐式强制转换操作符，带有签名<code class="fe md me mf mg b">operator T() const;</code>，其中<code class="fe md me mf mg b">T</code>是要强制转换到的类型，<code class="fe md me mf mg b">const</code>只是意味着这个函数不能修改类。每当 C++需要转换成不同的类型时，就会调用这个函数。</p><pre class="kd ke kf kg gt mi mg mj mk aw ml bi"><span id="027f" class="ko kp in mg b gy mm mn l mo mp">myclass myobj = myobj();<br/>int myint = myobj;<br/>//          ^^^^^<br/>//          implicit cast int() is called</span></pre><p id="216c" class="pw-post-body-paragraph lk ll in lm b ln mq jo lp lq mr jr ls kx ms lu lv lb mt lx ly lf mu ma mb mc ig bi translated">所以在<code class="fe md me mf mg b">T val = getSetProxy;</code>中会调用<code class="fe md me mf mg b">operator T()</code>。我们可以重载它来获得如下功能:</p><pre class="kd ke kf kg gt mi mg mj mk aw ml bi"><span id="31d8" class="ko kp in mg b gy mm mn l mo mp">class getSetProxy {<br/>    rbtree&lt;K, V&gt; *theTree;<br/>    K key;<br/>...<br/>    operator V() const {<br/>        return theTree-&gt;getValue(key);<br/>    }<br/>...<br/>}</span></pre><h2 id="39dd" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">把所有的放在一起</h2><p id="c8a4" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls kx lt lu lv lb lw lx ly lf lz ma mb mc ig bi translated">请原谅我对符号、等式和所有即将发生的数学的滥用。</p><p id="124b" class="pw-post-body-paragraph lk ll in lm b ln mq jo lp lq mr jr ls kx ms lu lv lb mt lx ly lf mu ma mb mc ig bi translated"><code class="fe md me mf mg b">V value = mymap[key];<br/></code>→<code class="fe md me mf mg b">V value = getSetProxy{key = key};</code>→<br/>→<code class="fe md me mf mg b">V value = getSetProxy.operatorV();<br/></code>→<code class="fe md me mf mg b">V value = mymap.getValue(key);</code></p><p id="82d3" class="pw-post-body-paragraph lk ll in lm b ln mq jo lp lq mr jr ls kx ms lu lv lb mt lx ly lf mu ma mb mc ig bi translated"><code class="fe md me mf mg b">mymap[key] = value;</code>(为简单起见假设钥匙不在地图上)<br/> → <code class="fe md me mf mg b">getSetProxy{key = key} = value;</code> <br/> → <code class="fe md me mf mg b">getSetProxy{key = key}.operator=(value);<br/></code> → <code class="fe md me mf mg b">mymap-&gt;setValue(key, value)</code></p><h2 id="5676" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">收场白</h2><p id="29b7" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls kx lt lu lv lb lw lx ly lf lz ma mb mc ig bi translated">C++非常有趣，因为你可以真正把它变成你自己的语言。我能够用几行代码(尽管有点棘手)就把笨拙的语法变得我更熟悉。整个项目的代码，包括这个订阅部分可以在我的 GitHub 上的<a class="ae mv" href="https://github.com/ericbreyer/redBlackTreeInCpp" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div><div class="ab cl mw mx hr my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ig ih ii ij ik"><h1 id="2e0b" class="nd kp in bd kq ne nf ng kt nh ni nj kw jt nk ju la jw nl jx le jz nm ka li nn bi translated">关于作者</h1><p id="5526" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls kx lt lu lv lb lw lx ly lf lz ma mb mc ig bi translated">Eric Breyer 是莱斯大学的计算机科学本科生。你可以在他的<a class="ae mv" href="http://www.ericbreyer.com/" rel="noopener ugc nofollow" target="_blank">网站</a>，以及<a class="ae mv" href="https://github.com/ericbreyer" rel="noopener ugc nofollow" target="_blank"> GitHub </a>和<a class="ae mv" href="https://www.linkedin.com/in/eric-breyer/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上找到他。</p></div></div>    
</body>
</html>