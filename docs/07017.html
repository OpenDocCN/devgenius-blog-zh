<html>
<head>
<title>From JAVA 9 to JAVA 15: Evolutions and new features — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从 JAVA 9 到 JAVA 15:发展和新特性—第 1 部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/from-java-9-to-java-15-evolutions-and-new-features-part-1-c249947b7513?source=collection_archive---------9-----------------------#2022-02-19">https://blog.devgenius.io/from-java-9-to-java-15-evolutions-and-new-features-part-1-c249947b7513?source=collection_archive---------9-----------------------#2022-02-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="13c6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">每个 Java 开发者都应该知道的 Java 版本进化链。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f7b2182426f86a50908b1fa5a9d93234.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZPaKQngQDNquMr2ms9Jbsw.png"/></div></div></figure><h2 id="a0a3" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">简介:从 Java 9 到 Java 15</h2><p id="bdd5" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">根据 IDC(国际数据公司)的最新报告，超过 900 万全职开发人员使用 Java，Java 仍然是商业世界中最受欢迎和使用最广泛的语言之一。</p><p id="fff3" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">事实上，根据 ORACLE 的统计，今天全世界有 900 万 Java 开发人员，将近 510 亿个活跃的 JVM。</p><p id="701b" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">为了保持这种受欢迎程度，并进一步扩大 Java 社区，甲骨文自 2017 年 9 月发布 Java 9 以来，加快了 Java 发布的步伐。</p><p id="c47b" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">现在，每六个月发布一次改进，每三年发布一次 LTS(长期支持)版本，而不是每三年发布一次成千上万的修复和新功能。</p><p id="4724" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">目标是确保开发人员更高的生产力，并允许他们适应新的市场实践，同时提供可预测性和持续的稳定性。</p><p id="1981" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">这也将促进向新版本的迁移并扩大 Java 社区，这个问题已经在 Java 15 中实现，其中超过 20%的补丁由非 ORACLE 开发人员提供。</p><p id="5f6c" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">Java 8 之后的这种速度变化非常突然，许多公司还没有跟进，因为害怕或不知道每个新版本提供的好处。本文的目的是概述从 Java 9 到 Java 15(2020 年 9 月发布)的版本带来的不同发展，以便他们能够为其 SDK 的迁移做好最好的准备。</p><p id="8d49" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">在第一部分中，我们将关注语言的技术发展，这些发展简化了开发者的生活，改善了他们的日常生活。然后，我们将研究对 JVM 的各种改进，特别是最近推出的“垃圾收集器”。最后，我们将在第三部分结束，这一部分专门讨论从 JDK 中删除或将要删除的模块和 API。最后，我们将给出一些建议，以便您可以放心地进行迁移。</p><h1 id="a1d8" class="mm ks iq bd kt mn mo mp kw mq mr ms kz jw mt jx ld jz mu ka lh kc mv kd ll mw bi translated">技术改进</h1><h2 id="1379" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">1.文本块(Java 15 以后的标准模式)</h2><p id="658a" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">Java 编程中的文字字符串不限于短字符串，还可以对应于 XML 描述、SQL 查询、HTML 网页等。</p><p id="95b1" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">然后它们可以包含几个转义序列、换行符、特殊字符等。</p><p id="f137" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">让我们以 HTML 格式的网页为例:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="8bff" class="kr ks iq my b gy nc nd l ne nf">String html = "&lt;html&gt;\n" +<br/>              "    &lt;body&gt;\n" +<br/>              "        &lt;p&gt; Java, technical Enhancement &lt;/p&gt;\n" +<br/>              "    &lt;/body&gt;\n" +<br/>              "&lt;/html&gt;\n";</span></pre><p id="beab" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">这些写操作很麻烦，也可能成为开发人员的错误来源。</p><p id="1e57" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">为了解决这个问题，<strong class="lp ir"> Java 13 </strong>在预览模式中引入了二维“文本块”的新概念，这个概念在 Java 15 中已经标准化。以下是上一个示例的样子:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="0409" class="kr ks iq my b gy nc nd l ne nf">String html = """  //go back to the line<br/>              &lt;html&gt;<br/>                  &lt;body&gt;<br/>                      &lt;p&gt; Java, technical Enhancement &lt;/p&gt;<br/>                  &lt;/body&gt;<br/>              &lt;/html&gt;<br/>              """;</span></pre><p id="9e80" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">在相同的上下文中，<strong class="lp ir"> JAVA 13 </strong>为 String 类引入了新方法:</p><ul class=""><li id="d6b0" class="ng nh iq lp b lq mh lt mi la ni le nj li nk mf nl nm nn no bi translated">String::translateEscape:删除字符串中的转义序列</li><li id="ff42" class="ng nh iq lp b lq np lt nq la nr le ns li nt mf nl nm nn no bi translated">string::striping dent:删除每行开头的意外缩进。</li><li id="adf8" class="ng nh iq lp b lq np lt nq la nr le ns li nt mf nl nm nn no bi translated">String::formatted:允许您根据传递的参数格式化字符串。</li></ul><p id="3091" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">还有其他一些以前由<strong class="lp ir"> Java 11 </strong>介绍的简便方法:</p><ul class=""><li id="b64d" class="ng nh iq lp b lq mh lt mi la ni le nj li nk mf nl nm nn no bi translated">String::isBlank，String::repeat，String::lines:从行中返回流</li><li id="813a" class="ng nh iq lp b lq np lt nq la nr le ns li nt mf nl nm nn no bi translated">String::strip，String::stripLeading，String::stripTrailing:允许更好地管理空间。</li></ul><h2 id="1a82" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">2.开关(从 Java 14 开始的标准模式)</h2><p id="9a42" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">在 Java 中，文本块并不是唯一相当冗长的部分,“开关”也是一个指令，历史上写在许多行中。</p><p id="d6f3" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">这是<strong class="lp ir"> Java 12 </strong>之前一个“开关”的样子:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="e1a9" class="kr ks iq my b gy nc nd l ne nf">switch (day) {<br/>        case MONDAY:<br/>        case TUESDAY:<br/>        case THURSDAY:<br/>        case FRIDAY:<br/>            planning = "Workout";<br/>            break;<br/>        case WEDNESDAY:<br/>            planning = "Day off";<br/>            break;<br/>        case SUNDAY:<br/>        case SATURDAY:<br/>            planning = "Weekend";<br/>            break;<br/>        default:<br/>            throw new IllegalStateException(day+ "does not exist");<br/>    }</span></pre><p id="dab6" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">在<strong class="lp ir"> Java 12 之后，</strong>我们有了更简洁的东西:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="1431" class="kr ks iq my b gy nc nd l ne nf">int planning = switch (day) {<br/>    case MONDAY, TUESDAY, THURSDAY, FRIDAY -&gt; "Workout"; // “case” accept multiple values separated by commas <br/>    case WEDNESDAY -&gt; "Day off"; // it is possible to use the "arrow" operator<br/>    case SATURDAY, SUNDAY -&gt; "Weekend"; // no need to put "default" for enums if we cover all cases  <br/>    };</span></pre><p id="b2f5" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">也可以将代码块放在 close case 中。<strong class="lp ir"> Java 13 </strong>反过来又带来了一个新的<em class="nu">“yield”</em>关键字，取代了 break，让你可以脱离 switch。这些新特性随着 Java 14 进入了标准模式。</p><h2 id="eea3" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">3.局部变量的 VAR(Java 10 以后的标准模式)</h2><p id="8d69" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">考虑下面的例子:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="8233" class="kr ks iq my b gy nc nd l ne nf">BufferedReader reader = Files.newBufferedReader(...);<br/>List&lt;String&gt; programmingLanguage = List.of("java", "javaScript", "Swift",”C++”);<br/>Map&lt;String, List&lt;String&gt;&gt; mapping = retrieveWritersBooksMap();</span></pre><p id="1cc4" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">局部变量类型推断是<strong class="lp ir"> Java 10 </strong>最大的新特性。它避免了前面例子中的冗余，简化了复杂类型的显示。</p><p id="63d8" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">请注意，过度使用 var 会导致编译器混乱。为此，Java 对它的使用施加了一些限制。以下是一些未经授权的代码示例:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="367a" class="kr ks iq my b gy nc nd l ne nf">var value ;  //il faut obligatoirement initialiser les variables<br/>var object = null ; //variables must be initialized<br/>var a=1,b=2 ; // cannot declare multiple variables on the same line<br/>var words =   {“word1”, ”word2”}; // initializing an array requires an explicit type<br/>var addition =  {a, b} -&gt; a+b; // lamdas expressions require an explicit type but it is possible to cast<br/>var compareString = String ::compareTo ; // reference methods require an explicit type but it is possible to cast (using Comparator&lt;String&gt; in the example)<br/>var value = 10 ; value = ’’hello ‘’ ; // impossible to transform an already typed var</span></pre><p id="bbe0" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">使用<strong class="lp ir"> Java 11 </strong>，可以在 lambdas 函数内部使用 var。这种用法有一个很大的优势，因为它允许您对参数进行注释。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="175b" class="kr ks iq my b gy nc nd l ne nf">(@Nonnull var x, @Nullable var y) -&gt; x.process(y)</span></pre><h2 id="cfe5" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">4.流</h2><p id="26c7" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">Java 8 引入的新的流 API 通过提供一种更简单、更有效的“迭代器”模式的替代方式，从根本上改变了集合的处理方式，而“迭代器”模式的设置相对来说比较麻烦。</p><p id="2a8e" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">Java 9 反过来为这个 API 提供了新的方法，下面是一些例子:</p><ul class=""><li id="7c1a" class="ng nh iq lp b lq mh lt mi la ni le nj li nk mf nl nm nn no bi translated">Stream::takeWhile:允许使用“谓词”浏览集合。只要条件有效，我们就浏览集合。</li><li id="376e" class="ng nh iq lp b lq np lt nq la nr le ns li nt mf nl nm nn no bi translated">Stream::dropWhile:遵循 takeWhile 的反向操作。只有当条件有效时，我们才开始遍历集合。</li><li id="08ca" class="ng nh iq lp b lq np lt nq la nr le ns li nt mf nl nm nn no bi translated">Stream::Iterate:允许您通过指定起始值、谓词和增量函数来迭代集合。</li><li id="8e0c" class="ng nh iq lp b lq np lt nq la nr le ns li nt mf nl nm nn no bi translated">Stream::ofNullable:当值为 null 时，通过返回“可选”接口来避免 npe。</li></ul><p id="74b7" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">Java 11 引入了 Null/InputStream、OutputStream、Reader、Writer，允许用 Null 启动流而不生成 NPE。因此，透明地处理输入/输出是可能的，即使它们表示空值。</p><p id="b5a4" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">以“流”结束，<strong class="lp ir"> Java 12 </strong>在 java.util.stream.Collectors 接口上引入了 Stream::tee 方法。它将两个独立的集合作为输入，并允许使用一个双函数将它们组合起来:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="4ea9" class="kr ks iq my b gy nc nd l ne nf">Double average = numbers.stream()<br/>                        .collect(teeing(SummingDouble(i -&gt; i),<br/>                                  counting(),(sum, n) -&gt; sum / n));</span></pre><h2 id="ab86" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">5.密封的类</h2><p id="6426" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">sealed 关键字是<strong class="lp ir"> java 15 </strong>最重要的新特性之一。它的目的是将一个类/接口的实现或继承限制在由“<em class="nu">许可</em>关键字定义的类列表中:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="97e3" class="kr ks iq my b gy nc nd l ne nf">public abstract sealed class Shape<br/>    	permits Circle, Rectangle, Square {...}</span></pre><p id="9bf1" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">如果这些类是在同一个源文件中声明的，那么可以去掉“允许”关闭。</p><h2 id="4329" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">6.班级记录</h2><p id="efa4" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">记录不太冗长。事实上，它们减少了创建一个类所需的代码量(构造函数、getter/setter 访问器、equals()方法、hashcode())以及每次创建新属性时维护它所需的时间。</p><p id="d393" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">这里有一个例子:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="9445" class="kr ks iq my b gy nc nd l ne nf">public record Person (String firstName, String lastName) {}</span></pre><p id="64cf" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">它们最初是由 Java 14 以“预览”模式引入的。事实上，一个记录可以实现一个密封的接口，并且可以在一个方法内部本地声明。</p><h2 id="4bda" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak"> 7。空指针异常(Java 15 以后的标准模式)</strong></h2><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="5a61" class="kr ks iq my b gy nc nd l ne nf">String email = employee.getPersonalDetails().getEmail().toLowerCase();</span></pre><p id="8755" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">如本例所示，开发人员通常可以编写将多个方法链接在一起的代码。但是当 NPE 生成时，就不清楚错误来自哪里了。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="76d0" class="kr ks iq my b gy nc nd l ne nf">Exception in thread "main" java.lang.NullPointerException<br/>at com.enhancement.DemoNullPointerException.main(HelpfulNullPointerException.java:10</span></pre><p id="6b00" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">有了<strong class="lp ir"> Java 14 </strong>，JVM 提供了一个更明确的消息，准确地指出错误来自哪里。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="a2f7" class="kr ks iq my b gy nc nd l ne nf">Exception in thread "main" java.lang.NullPointerException: <br/>Cannot invoke "String.toLowerCase()" because the return value of <br/>"com.enhancement.DemoNullPointerException$PersonalDetails.getEmail()" is null<br/>at com.enhancement.DemoNullPointerException.main(HelpfulNullPointerException.java:10)</span></pre><p id="f9a1" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">这个增强是 Java 15 的标准配置。</p><h2 id="8412" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">8.JShell REPL“读取评估打印循环”(Java 9 以后的标准模式)</h2><p id="2d6d" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">由<strong class="lp ir"> Java 9 </strong>推出的“JShell”是一个用于评估 Java 代码的命令行工具。</p><p id="94b7" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">事实上，不再需要创建一个完整的程序(导入库，用 main()方法定义一个类，等等)。)来测试一个简单的表达式。这似乎很有用，尤其是对于不熟悉 Java 语言的开发人员。</p><p id="3a16" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">下面是一个用 Jshell 执行的代码示例:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="c19e" class="kr ks iq my b gy nc nd l ne nf">.. &gt;jshell<br/>|  Welcome to JShell -- Version 9<br/>|  For an introduction type: /help intro<br/><br/>jshell&gt;public long multiply(long n , long m ){<br/>   ...&gt;    return m * n ;<br/>   ...&gt; }<br/>|  created method multiply(long ,long)<br/>jshell&gt;long result = multiply(20 , 10 )<br/>result ==&gt; 200<br/>|  created variable result : long</span></pre><p id="735b" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">“Jshell”提供了一个命令列表，包括:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="c949" class="kr ks iq my b gy nc nd l ne nf">/set feedback verbose : provides more information about executed commands.<br/>/list -start : list all Jshell commands.<br/>/drop [nom_variable] : deletes the created variable.<br/>/vars : displays the list of all active variables in the current session.<br/>/vars [Nom_variable] : is used to display the variable [Variable_name] and its value.<br/>/vars – all : displays the list of all active, inactive and loaded variables at startup.<br/><br/>/types : allows you to list all the active types (Class, Interface, Enum) created in JShell.<br/>/types [Nom_Type] : is used to display the type corresponding to [Name_Type].<br/>/types -all : allows you to list all the types of the current session (active, inactive and loaded when starting JShell).<br/><br/>/edit : allows modifying the constructors in the current session.<br/>/edit 1 :  allows to modify the first constructor in the current session.<br/>/edit [Nom-constructeur] : allows you to modify a specific constructor in the current session.<br/>/exit: quits JShell.</span></pre><p id="9637" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">作为这一部分的结尾，这里简要介绍一些您可能感兴趣的其他改进:</p><ul class=""><li id="5dc0" class="ng nh iq lp b lq mh lt mi la ni le nj li nk mf nl nm nn no bi translated">接口中的“私有”方法:<strong class="lp ir"> Java 9 </strong></li></ul><p id="dc94" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">这有助于封装，并避免复制代码的某些部分和只公开所需的方法。</p><ul class=""><li id="f72a" class="ng nh iq lp b lq mh lt mi la ni le nj li nk mf nl nm nn no bi translated">不可变集合的工厂:<strong class="lp ir"> Java 9 </strong></li></ul><p id="d0e6" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">List.of()，Set.of()，Map.of()。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="d338" class="kr ks iq my b gy nc nd l ne nf">List&lt;String&gt; availableGC= List.of("GC1", "ZGC", "EPSILON");</span></pre><ul class=""><li id="2368" class="ng nh iq lp b lq mh lt mi la ni le nj li nk mf nl nm nn no bi translated">“try-with-resources”<strong class="lp ir">Java 9</strong>中的最终变量:如果资源是最终的，那么可以在“try”块之外声明“Closeable”资源。为资源的实例化创建实用方法也可以提高可读性。</li><li id="1ddd" class="ng nh iq lp b lq np lt nq la nr le ns li nt mf nl nm nn no bi translated">Predicate::not <strong class="lp ir"> Java11 </strong>:提供了一种简单的方法来反转“谓词”的值，用 lambdas 或方法引用来表示，降低了代码的复杂性。</li></ul><p id="c3fe" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">下一部:<a class="ae mg" rel="noopener ugc nofollow" target="_blank" href="/from-java-9-to-java-15-evolutions-and-new-features-part-2-7405530ab748">第二部</a>。</p><blockquote class="nv nw nx"><p id="a1de" class="ln lo nu lp b lq mh jr ls lt mi ju lv ny mj lx ly nz mk ma mb oa ml md me mf ij bi translated">我们在这里停下来，以免读得太长，下一部分我们将讨论对 JVM 的各种改进。</p></blockquote></div></div>    
</body>
</html>