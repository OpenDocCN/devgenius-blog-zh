# Python:时间复杂性

> 原文：<https://blog.devgenius.io/python-time-complexities-1988ec5d16d9?source=collection_archive---------2----------------------->

## 为您的算法测量时间！

![](img/1712cbd478505848d115655a9f5be257.png)

[图片](https://unsplash.com/photos/BXOXnQ26B7o)由 [Aron 视觉](https://unsplash.com/@aronvisuals)

**目录:**

*   什么是时间复杂度？
*   如何度量时间复杂度
*   为什么重要？
*   图表
*   时间建模
*   结论

**什么是时间复杂度？**

在比较不同算法和函数的时间效率时，这是一个问题。硬币的另一面是空间复杂性，我们将在另一篇文章中讨论。有时权衡是得到一个(时间效率)超过另一个(空间效率)，或者反之亦然，但那是视情况而定的。

在本文中，我将使用一个消费者投诉数据集，该数据集包含不同信用机构的 100 多万行数据。我们将创建三个函数来统计各州提出的投诉数量，并查看其运行情况。我们的第一个函数，`count_complaints_by_state1`使用一个`for loop`计算投诉的数量，接下来`count_complaints_by_state2`使用`pandas`计算，而`count_complaints_by_state3`使用`counter`库计算。你可以自由使用任何你喜欢的数据集！只需确保对代码进行适当的调整，以反映您使用的数据集，比如更改目标列名和数据集所在的文件路径。

**如何度量时间复杂度:**

—导入时间库。

![](img/3bac8261c1b2cef9a267a8ced0e06af6.png)

作者图片

—创建用于测试的函数/算法:

![](img/f503d268c56bf3e61c7b72cea3f54533.png)

作者图片

—创建一个变量，保存算法执行前的时间，称之为 start1。

![](img/73c642349187a15e348618dcb0e08587.png)

作者图片

—创建一个变量，保存算法执行后的时间，称之为 end1。

![](img/85e9a66c64908d7f5ed7082043e6b5dd.png)

作者图片

—用 start1 减去 end 1(end 1—start 1)，并将差值保存到一个名为 runtime 的变量中。这个运行时间是你的函数/算法执行的时间。

![](img/1dbbae70ecdfc564b2bbc9eab029b677.png)

作者图片

**为什么重要？**

最终目标是能够分析和预测执行时间如何随着数据的增长而增长。想象一下，我们有一个包含 50 行数据的 csv 文件，我们有三个算法以不同的方式做同样的事情。

![](img/b99d387232e03a832ecacbff9df6b2a9.png)

作者图片

—现在假设数据从 50 行增长到 500，000 行。让我们再运行一次，看看会发生什么。

![](img/8e376897bf510f7379d188f2f96c80e5.png)

作者图片

—我们可以看到我们的运行时的排名已经发生了变化。当数据被缩放时，我们的`count_complaints_by_state1`函数的运行时间运行得最慢，而之前它排在第二位。而最后来的`count_complaints_by_state2`，现在是第一。由于`count_complaints_by_state2`使用熊猫，它在内存中做所有的处理。

**图表:**

当你想捕捉你的算法/函数在你的数据放大时表现如何时，最好使用某种图表，更具体地说是折线图来可视化它们。拥有一个可视化的表示有助于我们以较少的努力获得正在发生的事情的总体想法，而不是在某种表格上比较不同的时间。

![](img/776bbe056d4ce37e6702ba5ad434a82c.png)

作者图片

—我们可以看到，与其他两个函数相比，使用 for 循环的函数在缩放数据大小时运行时间要慢得多。当遍历大小为 100 万+的数据时，它需要 30 秒左右的时间，与之相对的是，它的运行时间接近 0。

—有点难以看清，但表示熊猫功能的绿线位于计数器功能的蓝线正下方。请随意放大自己看。

**时间建模:**

观察一个算法并在高层次上理解运行时也很重要。这样你可以得到一个粗略的想法，看看是否值得重新审视和优化它。让我们学习如何对函数的时间复杂度建模，并看看执行时间是如何增长的。

![](img/80a3c7df43c3be73a2c57fbc574056dd.png)

作者图片

—当查看函数中的每一行时，假设每一行运行的时间为常数 1，因此为 1。当你看一个 for 循环时，你假设它根据数据的大小运行所需的次数，所以我们用 n 来表示。正如我们看到的`count_complaints_by_state1`包含一个 for 循环，这意味着 for 循环中的每一行执行不止一次。如果您正在处理的数据有 50 行，它将运行 50 次，如果有 100 万行，它将运行 100 万次，等等。要了解函数的实际时间复杂度，我们查看每一行运行时间为 1 的常数，并将它们相加。这样只剩下运行时间为 N 的行。所以我们的函数将有一个运行时`2+O(n)`。

—如果我们有一个嵌套的 for 循环，其中一个 for 循环在另一个循环内，那么我们将每个 for 循环的执行时间度量为 n。

![](img/bf25523d2632b5bb227e5308b61fe759.png)

作者图片

—所以我们可以看到，我们的第一个 for 循环运行了 N 次或`2+O(n)`也称为线性运行时。当我们查看嵌套的 for 循环时，它会在第一次 for 循环运行后运行所需的次数。因此，我们将第一个 for 循环的运行时间乘以第二个 for 循环的运行时间，`(1+1)+N * N`或`2+(n^2)`。

—这是一个图表，展示了时间复杂度的大 O 符号的类别:

![](img/eefc737ec4f7b0a151c2811cbdb7440a.png)

[图片](https://adrianmejia.com/most-popular-algorithms-time-complexity-every-programmer-should-know-free-online-tutorial-course/)阿德里安·梅希亚

**结论:**

学习如何测量算法的时间复杂度是一项非常有用的技能。它可以帮助您根据业务需求优化代码。减少运行时间，最终更有效地做出决策。在下一篇文章中，我们将讨论硬币的另一面，空间复杂性。github 上有一个代码链接供你测试。请注意，路径变量可能需要更改。希望你喜欢阅读，直到我们再次编码！

**相关内容:**

*   [Github 回购](https://github.com/ra1993/medium_projects/tree/main/time_complexity)
*   [时间复杂度](https://thedatascape.medium.com/python-space-complexity-dbfe5aabdcd)