<html>
<head>
<title>Experienced Developers Are Allergic to These 5 Bad Optional Practices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有经验的开发人员对这 5 个糟糕的可选实践过敏</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/experienced-developers-are-allergic-to-these-5-bad-optional-practices-ee1014940198?source=collection_archive---------4-----------------------#2022-03-05">https://blog.devgenius.io/experienced-developers-are-allergic-to-these-5-bad-optional-practices-ee1014940198?source=collection_archive---------4-----------------------#2022-03-05</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="ba2d" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated"><strong class="ak">随意滥用的隐性成本是什么？</strong></h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/2bd169ba472bc766df14cf59688fc6bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U7-LdgsJcZsd52LyDelIag.jpeg"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated">照片由<a class="ae kw" href="https://unsplash.com/@niklas_hamann?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Niklas Hamann </a>在<a class="ae kw" href="https://unsplash.com/s/photos/lack?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="f0ae" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><em class="lt">部分开发者滥用</em> <code class="fe lu lv lw lx b"><em class="lt">Optional</em></code> <em class="lt">。有些甚至不知道</em> <a class="ae kw" href="https://www.reddit.com/r/java/comments/t1ev7h/comment/hyfmdt0/?utm_source=share&amp;utm_medium=web2x&amp;context=3" rel="noopener ugc nofollow" target="_blank"> <em class="lt">什么是</em> </a> <code class="fe lu lv lw lx b"><a class="ae kw" href="https://www.reddit.com/r/java/comments/t1ev7h/comment/hyfmdt0/?utm_source=share&amp;utm_medium=web2x&amp;context=3" rel="noopener ugc nofollow" target="_blank"><em class="lt">Optional</em></a></code> <em class="lt">。</em></p><p id="54cc" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">他们仍然不明白<code class="fe lu lv lw lx b">Optional</code>的目的。他们工程过度。这个过度工程的成本是多少？</p><p id="ed5f" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">让我们看看下面的例子。</p><h1 id="abd0" class="ly lz ir bd ma mb mc md me mf mg mh mi jx mj jy mk ka ml kb mm kd mn ke mo mp bi translated">1.不要过度使用<code class="fe lu lv lw lx b">Optional</code></h1><p id="8ed4" class="pw-post-body-paragraph kx ky ir kz b la mq js lc ld mr jv lf lg ms li lj lk mt lm ln lo mu lq lr ls ik bi translated">Optional 有一个很酷的、吸引人的、可滥用的 API。它们链接到无穷大，而这只是一个简单的空值检查。这里有一个例子。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mv mw l"/></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated"><a class="ae kw" href="https://www.govnokod.ru/24731" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="4bb2" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">通过一点点的重构，你可以得到这样的东西。更少的包装，更少的链接，更惯用的解决方案。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mv mw l"/></div></figure><p id="8b50" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">通过更好的方法，我们得到了以下结果:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj mx"><img src="../Images/d059e80ec84bf5ca2e8bcde767943655.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GcpWSC_39rhdySgMojhJkA.png"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated"><a class="ae kw" href="https://jmh.morethan.io/?gist=98fd37eda2ddcc819ac8c485ce5d7c35" rel="noopener ugc nofollow" target="_blank">详情</a></figcaption></figure><p id="0d3b" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><code class="fe lu lv lw lx b">Optional</code>过度工程的成本是显而易见的。这对吞吐量有一点小影响，对单次触发时间也有明显影响。<em class="lt">更好的方法比过度设计的无意义的</em> <code class="fe lu lv lw lx b"><em class="lt">Optional</em></code> <em class="lt">快两倍。</em></p><h1 id="2e16" class="ly lz ir bd ma mb mc md me mf mg mh mi jx mj jy mk ka ml kb mm kd mn ke mo mp bi translated">2.不使用<code class="fe lu lv lw lx b">Optional</code>进行<code class="fe lu lv lw lx b">null</code>检查</h1><p id="df3d" class="pw-post-body-paragraph kx ky ir kz b la mq js lc ld mr jv lf lg ms li lj lk mt lm ln lo mu lq lr ls ik bi translated">我在 Reddit 上的某个地方发现了这个，并被震撼到了。还有开发者这样滥用 Optional。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mv mw l"/></div></figure><p id="5e81" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">你应该这样做。一个简单的空值检查应该可以解决这个问题。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mv mw l"/></div></figure><p id="738f" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">以下是这些基准测试的结果。Null check 比这种无意义的包装好几个数量级。<em class="lt">按预期使用</em> <code class="fe lu lv lw lx b"><em class="lt">Optional</em></code> <em class="lt">，不是为了提高可读性，或者根除空检查。</em></p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj mx"><img src="../Images/0bc97c1530be91f9aeebbd57ce5a7e7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tp_mbLM4X5xilvTTWsCHhA.png"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated"><a class="ae kw" href="https://jmh.morethan.io/?gist=fbb55449ecca9fdd8f198476d6cbd546" rel="noopener ugc nofollow" target="_blank">详情</a></figcaption></figure><h1 id="502f" class="ly lz ir bd ma mb mc md me mf mg mh mi jx mj jy mk ka ml kb mm kd mn ke mo mp bi translated">3.<code class="fe lu lv lw lx b">Optional</code> sum 的成本是多少？</h1><p id="1c75" class="pw-post-body-paragraph kx ky ir kz b la mq js lc ld mr jv lf lg ms li lj lk mt lm ln lo mu lq lr ls ik bi translated">这是我从<a class="ae kw" href="https://pkolaczk.github.io/overhead-of-optional/" rel="noopener ugc nofollow" target="_blank"> Piotr </a>得到的一个基准。这个基准侧重于总和。</p><p id="45c8" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">总和被测试为多种类型。Optional、OptionalLong 和常规 sum。还有从<code class="fe lu lv lw lx b">Optional</code>提炼出来的<code class="fe lu lv lw lx b">MyOptionalLong</code>，就像这个<a class="ae kw" href="https://www.reddit.com/r/rust/comments/q99eqe/rust_option_30x_more_efficient_to_return_than/hgynrll/?utm_source=share&amp;utm_medium=web2x&amp;context=3" rel="noopener ugc nofollow" target="_blank"> Redditor </a>建议的那样。</p><p id="9104" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">简单求和是对数字求和的最简单的方法，我们应该把它作为基线。Sum nulls 沿途有一些 null。其他人使用可选的总和。</p><p id="67b8" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><code class="fe lu lv lw lx b">MyOptionalLong</code>为<code class="fe lu lv lw lx b">isPresent</code>增加了一点改进。这使用引用相等来查看 Optional 是否有值。区别就在这里。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj my"><img src="../Images/6486af60074716503e685d544e7e7189.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i0Jo1k_F8YnxlMQGY-El8Q.png"/></div></div></figure><p id="c497" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这消除了对<code class="fe lu lv lw lx b">isPresent</code>布尔变量的需要。因此，这个方法是一个很好的内联候选方法。<em class="lt">小改进，值得思考！</em></p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj mz"><img src="../Images/4c6c926f4a083078268791867bcdba71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BwQ5-VK-dF0TNMkh7WgChg.png"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated"><a class="ae kw" href="https://jmh.morethan.io/?gist=7a9da3ea312be8fc6f5716e63caeb6eb" rel="noopener ugc nofollow" target="_blank">详情</a></figcaption></figure><p id="3550" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">自定义<code class="fe lu lv lw lx b">MyOptionalLong</code>效果最好。由于内联缓存、热度和引用检查，这种可选类型更好。如果你想挤压可选的性能，<code class="fe lu lv lw lx b"><a class="ae kw" href="https://gist.github.com/xfix/34b8c8717191c191e577a843cfc9e15b" rel="noopener ugc nofollow" target="_blank">MyOptionalLong</a></code> <a class="ae kw" href="https://gist.github.com/xfix/34b8c8717191c191e577a843cfc9e15b" rel="noopener ugc nofollow" target="_blank">可以帮助</a>。</p><p id="c7d6" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">对于其他人来说，纯粹的凡人，最好用<code class="fe lu lv lw lx b">OptionalLong</code>而不是普通的<code class="fe lu lv lw lx b">Optional</code>。</p><h1 id="efd8" class="ly lz ir bd ma mb mc md me mf mg mh mi jx mj jy mk ka ml kb mm kd mn ke mo mp bi translated">4.学习<code class="fe lu lv lw lx b">Optional</code>的方法</h1><pre class="kh ki kj kk gu na lx nb nc aw nd bi"><span id="a216" class="ne lz ir lx b gz nf ng l nh ni">if (a==null) {<br/>	return Optional.empty();<br/>} <br/>else {<br/>	return Optional.of(a);<br/>}</span></pre><p id="45a8" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这就是<code class="fe lu lv lw lx b">ofNullable</code>的作用。您可以查看它的源代码。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mv mw l"/></div></figure><p id="efee" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这里不做任何基准测试。无知的代价显而易见。先学习<code class="fe lu lv lw lx b">Optional</code>再使用。</p><h1 id="29c8" class="ly lz ir bd ma mb mc md me mf mg mh mi jx mj jy mk ka ml kb mm kd mn ke mo mp bi translated">5.getters 返回的<code class="fe lu lv lw lx b">Optional</code>的成本是多少？</h1><p id="5c2a" class="pw-post-body-paragraph kx ky ir kz b la mq js lc ld mr jv lf lg ms li lj lk mt lm ln lo mu lq lr ls ik bi translated">我们可以使用<code class="fe lu lv lw lx b">Optionals</code>作为字段。我们可以，但我们不应该。这增加了更多的复杂性，样板文件，并且不是<code class="fe lu lv lw lx b">Optional</code>的意图。</p><p id="92be" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">正如布莱恩·戈茨所说:人们用<code class="fe lu lv lw lx b">Optional</code>做他们想做的事情。有些人甚至把它们当作田地。</p><p id="1ee4" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">尼科莱举了一个这样的例子。检查这些并跟踪所有的东西是相当麻烦的。将<code class="fe lu lv lw lx b">Optional</code>添加到字段中会带来很多麻烦。</p><p id="46d8" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">你可能认为龙目岛的人已经解决了这个问题。是什么阻止我们在 getters 中返回选项。<a class="ae kw" href="https://stackoverflow.com/a/31674917/5999670" rel="noopener ugc nofollow" target="_blank">他们也根本不支持</a> <code class="fe lu lv lw lx b"><a class="ae kw" href="https://stackoverflow.com/a/31674917/5999670" rel="noopener ugc nofollow" target="_blank">Optional</a></code> <a class="ae kw" href="https://stackoverflow.com/a/31674917/5999670" rel="noopener ugc nofollow" target="_blank">作为 getters 的返回类型</a>。</p><p id="67e8" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">使用<code class="fe lu lv lw lx b">Optional</code>作为 getters 的返回类型的代价是什么？根据<a class="ae kw" href="https://gist.github.com/zivce/77510f4c37fd6a23066a1d478a8b52a8" rel="noopener ugc nofollow" target="_blank">我的愚测</a>，慢了 3 倍。包括单次注射时间和产量。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mv mw l"/></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated"><a class="ae kw" href="https://jmh.morethan.io/?gist=bfddaa4e577569efb0a418acfb23cacf" rel="noopener ugc nofollow" target="_blank">详情</a></figcaption></figure><h1 id="cff1" class="ly lz ir bd ma mb mc md me mf mg mh mi jx mj jy mk ka ml kb mm kd mn ke mo mp bi translated">外卖食品</h1><p id="137f" class="pw-post-body-paragraph kx ky ir kz b la mq js lc ld mr jv lf lg ms li lj lk mt lm ln lo mu lq lr ls ik bi translated">慢慢找<code class="fe lu lv lw lx b">Optional</code>虐。洒<code class="fe lu lv lw lx b">Optional</code>之前先问问自己用例是什么。</p><p id="7beb" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><code class="fe lu lv lw lx b">Optional</code>只解决一个空用例——值缺失。</p><blockquote class="nj nk nl"><p id="8bee" class="kx ky lt kz b la lb js lc ld le jv lf nm lh li lj nn ll lm ln no lp lq lr ls ik bi translated">当然，人会做自己想做的事。但是当我们添加这个特性时，我们有一个明确的意图，它不是一个通用的类型，尽管很多人希望我们这样做。我们的目的是为库方法返回类型提供一种有限的机制，在这种情况下，需要有一种明确的方式来表示“没有结果”，对此使用 null 极有可能导致错误。— <a class="ae kw" href="https://stackoverflow.com/questions/26327957/should-java-8-getters-return-optional-type/26328555#26328555" rel="noopener ugc nofollow" target="_blank">布莱恩·戈茨</a></p></blockquote></div></div>    
</body>
</html>