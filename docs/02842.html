<html>
<head>
<title>Receiving data over webhooks with Paystack in Laravel — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Laravel 中的 Paystack 通过 webhooks 接收数据—第 1 部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/receiving-data-over-webhooks-with-paystack-in-laravel-part-1-857bc4aab657?source=collection_archive---------0-----------------------#2020-09-04">https://blog.devgenius.io/receiving-data-over-webhooks-with-paystack-in-laravel-part-1-857bc4aab657?source=collection_archive---------0-----------------------#2020-09-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/f45c6078743841bb9a25b50916ad6471.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gxW94HpbRncjfsHuFnjokg.jpeg"/></div></div></figure><p id="6f9b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你是否曾经在构建一个应用程序时想:“我可以向这个服务的 API 发出请求，但是有没有办法让他们让我的应用程序知道<code class="fe kt ku kv kw b">X</code>何时发生？您可以尝试在设定的时间间隔内调用 API。获取响应，将其与上一个进行比较，然后继续。这是轮询，但效率很低，而且很容易达到速率限制。相反，一些 API 和服务提供了所谓的 webhook。他们不是联系他们，而是联系你。</p><h1 id="42c0" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">什么是 webhook？</h1><p id="f6ee" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">webhook(也称为 web 回调或 HTTP 推送 API)是应用程序向其他应用程序提供实时信息的一种方式。Webhooks 是一种发送通知的方式。它们本质上是单向的。发件人不在乎你用它做什么，在某些情况下甚至不在乎你是谁。他们最多只想得到一个回复，让他们知道你的应用已经收到了。webhook 在数据发生时将数据传送给其他应用程序，这意味着您可以立即获得数据。许多服务，如<a class="ae ma" href="https://stripe.com/docs/api/events" rel="noopener ugc nofollow" target="_blank"> Stripe API </a>、<a class="ae ma" href="https://sendgrid.com/docs/for-developers/tracking-events/event/" rel="noopener ugc nofollow" target="_blank"> Paystack API </a>、<a class="ae ma" href="https://developer.github.com/webhooks/" rel="noopener ugc nofollow" target="_blank"> GitHub API </a>和 Twillio API，都提供了在事件发生时以编程方式通知您的能力。webhook 向您选择的 URL 发出一个<code class="fe kt ku kv kw b">POST</code>请求，并带有一个<em class="mb">有效负载</em>，其中包含事件的详细信息。这使得 webhooks 对提供商和消费者来说都更加有效。webhooks 的唯一缺点是初始设置的困难。</p><p id="259b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您曾经构建过您的应用程序或其他应用程序使用的 REST API，那么您几乎已经了解了入门所需的一切。</p><p id="fab8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于我们的示例，流程如下所示:</p><ol class=""><li id="6b76" class="mc md in jx b jy jz kc kd kg me kk mf ko mg ks mh mi mj mk bi translated">Web 服务(Paystack API 或 Github API)将有效负载发送到应用程序的端点。</li><li id="26d3" class="mc md in jx b jy ml kc mm kg mn kk mo ko mp ks mh mi mj mk bi translated">你的应用程序接收有效负载。</li><li id="e119" class="mc md in jx b jy ml kc mm kg mn kk mo ko mp ks mh mi mj mk bi translated">你的应用程序响应并确认接收。</li><li id="d15b" class="mc md in jx b jy ml kc mm kg mn kk mo ko mp ks mh mi mj mk bi translated">你的应用程序作用于有效载荷数据。</li></ol><p id="16cb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mb">如果你想在构建应用程序消费 webhook 之前测试它的形状，可以使用类似</em><a class="ae ma" href="http://requestbin.net/" rel="noopener ugc nofollow" target="_blank"><em class="mb">request bin</em></a><em class="mb">这样的服务。</em></p><h1 id="8d69" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">我们将建造什么</h1><p id="13b8" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">在本教程中，我们将构建一个项目来监听来自 Paystack 的事件。</p><h1 id="195d" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">先决条件</h1><ul class=""><li id="0226" class="mc md in jx b jy lv kc lw kg mq kk mr ko ms ks mt mi mj mk bi translated">Laravel v5.8 或更高版本</li><li id="851a" class="mc md in jx b jy ml kc mm kg mn kk mo ko mp ks mt mi mj mk bi translated">spatie/laravel-web hook-客户端</li><li id="3a30" class="mc md in jx b jy ml kc mm kg mn kk mo ko mp ks mt mi mj mk bi translated">工资单账户。你可以在这里注册一个免费账户。</li></ul><h1 id="23d9" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">设置您的项目</h1><p id="883c" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">对于这个例子，我们将使用 Laravel，但是这个概念也适用于其他语言和框架。如果您要将 webhook 消费添加到现有项目中，请跳过下面的设置。</p><p id="6111" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，初始化一个新的 Laravel 项目:</p><pre class="mu mv mw mx gt my kw mz na aw nb bi"><span id="804d" class="nc ky in kw b gy nd ne l nf ng">composer create-project --prefer-dist laravel/laravel learning-webhook</span></pre><h1 id="e432" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">安装 Spatie 的 Laravel webhook 客户端包</h1><pre class="mu mv mw mx gt my kw mz na aw nb bi"><span id="5e6e" class="nc ky in kw b gy nd ne l nf ng">composer require spatie/laravel-webhook-client</span></pre><p id="d095" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">本教程使用 Spatie 的 webhook 客户端包来处理和处理传入的 webhook 事件，它还验证事件没有被破坏。</p><h1 id="205d" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">配置包</h1><p id="9fb4" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">您可以使用以下命令发布配置文件:</p><pre class="mu mv mw mx gt my kw mz na aw nb bi"><span id="8d57" class="nc ky in kw b gy nd ne l nf ng">php artisan vendor:publish --provider="Spatie\WebhookClient\WebhookClientServiceProvider" --tag="config"</span></pre><p id="cd5f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是将在<code class="fe kt ku kv kw b">config/webhook-client.php</code>发布的文件内容:</p><pre class="mu mv mw mx gt my kw mz na aw nb bi"><span id="3a19" class="nc ky in kw b gy nd ne l nf ng">return [<br/>    'configs' =&gt; [<br/>        [<br/>            /*<br/>             * This package support multiple webhook receiving endpoints. If you only have<br/>             * one endpoint receiving webhooks, you can use 'default'.<br/>             */<br/>            'name' =&gt; 'default',</span><span id="9ac8" class="nc ky in kw b gy nh ne l nf ng">            /*<br/>             * We expect that every webhook call will be signed using a secret. This secret<br/>             * is used to verify that the payload has not been tampered with.</span><span id="bc39" class="nc ky in kw b gy nh ne l nf ng">For the purpose of this article we will be using our Paystack secret key. Make sure you add it to the .env file            */<br/>            'signing_secret' =&gt; env('PAYSTACK_SECRET_KEY'),</span><span id="a8a0" class="nc ky in kw b gy nh ne l nf ng">            /*<br/>             * The name of the header containing the signature.<br/>             */<br/>            'signature_header_name' =&gt; 'x-paystack-signature',</span><span id="a716" class="nc ky in kw b gy nh ne l nf ng">            /*<br/>             *  This class will verify that the content of the signature header is valid.<br/>             *<br/>             * It should implement \Spatie\WebhookClient\SignatureValidator\SignatureValidator<br/>             */<br/>            'signature_validator' =&gt; \Spatie\WebhookClient\SignatureValidator\DefaultSignatureValidator::class,</span><span id="97f1" class="nc ky in kw b gy nh ne l nf ng">            /*<br/>             * This class determines if the webhook call should be stored and processed.<br/>             */<br/>            'webhook_profile' =&gt; \Spatie\WebhookClient\WebhookProfile\ProcessEverythingWebhookProfile::class,</span><span id="afb6" class="nc ky in kw b gy nh ne l nf ng">            /*<br/>             * This class determines the response on a valid webhook call.<br/>             */<br/>            'webhook_response' =&gt; \Spatie\WebhookClient\WebhookResponse\DefaultRespondsTo::class,</span><span id="3c4c" class="nc ky in kw b gy nh ne l nf ng">            /*<br/>             * The classname of the model to be used to store call. The class should be equal<br/>             * or extend Spatie\WebhookClient\Models\WebhookCall.<br/>             */<br/>            'webhook_model' =&gt; \Spatie\WebhookClient\Models\WebhookCall::class,</span><span id="0fa2" class="nc ky in kw b gy nh ne l nf ng">            /*<br/>             * The class name of the job that will process the webhook request.<br/>             *<br/>             * This should be set to a class that extends \Spatie\WebhookClient\ProcessWebhookJob.<br/>             */<br/>            'process_webhook_job' =&gt; '',<br/>        ],<br/>    ],</span></pre><p id="3f77" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">名词（noun 的缩写）b:我在“signature_header_name”和“PAYSTACK_SECRET_KEY”中添加了 Paystack 的签名头“x-paystack-signature”作为 signing_secret。为清楚起见，请点击查看 Paystack 关于设置 webhook <a class="ae ma" href="https://paystack.com/docs/payments/webhooks/" rel="noopener ugc nofollow" target="_blank">的文档:</a></p><h1 id="dcbf" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">准备数据库</h1><p id="58fd" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">默认情况下，所有的 webhook 调用都会保存在数据库中。</p><p id="f08c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要创建保存 webhook 调用的表，必须使用以下内容发布迁移:</p><pre class="mu mv mw mx gt my kw mz na aw nb bi"><span id="eb07" class="nc ky in kw b gy nd ne l nf ng">php artisan vendor:publish --provider="Spatie\WebhookClient\WebhookClientServiceProvider" --tag="migrations"</span></pre><p id="16c8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">迁移发布后，您可以通过运行迁移来创建<code class="fe kt ku kv kw b">webhook_calls</code>表:</p><pre class="mu mv mw mx gt my kw mz na aw nb bi"><span id="e07a" class="nc ky in kw b gy nd ne l nf ng">php artisan migrate</span></pre><h1 id="100a" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">负责路由</h1><p id="c27f" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">接下来，让我们来处理路由。Paystack 允许您在设置页面的 API &amp; Webhook 部分向您的仪表板添加 webhook URL。</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/e2ac156685204f5b65c8799488f61579.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*iV7a5_1hhss7QKa4nTx80Q.png"/></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated">在我的 Paystack 帐户上配置的 Webhook URL</figcaption></figure><p id="b7d8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在你的应用程序的 routes 文件中，你必须将该 URL 传递给<code class="fe kt ku kv kw b">Route::webhooks</code>，如下所示:</p><pre class="mu mv mw mx gt my kw mz na aw nb bi"><span id="295c" class="nc ky in kw b gy nd ne l nf ng">//routes/api.php</span><span id="0207" class="nc ky in kw b gy nh ne l nf ng">Route::webhooks('paystack-webhook');</span></pre><p id="6503" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在后台，这将注册一个<code class="fe kt ku kv kw b">POST</code>路由到这个包提供的控制器。因为向您发送 webhooks 的应用程序无法获得 csrf-token，所以您必须将该路由添加到<code class="fe kt ku kv kw b">VerifyCsrfToken</code>中间件的<code class="fe kt ku kv kw b">except</code>数组中:</p><pre class="mu mv mw mx gt my kw mz na aw nb bi"><span id="dc3f" class="nc ky in kw b gy nd ne l nf ng">// App/Http/Middleware/VerifyCsrfToken.php</span><span id="c986" class="nc ky in kw b gy nh ne l nf ng">protected $except = [<br/>    'paystack-webhook',<br/>];</span></pre><h1 id="1bda" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">创建我们自己的签名验证器</h1><p id="9c29" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">接下来我们需要做的是创建一个自定义的签名验证器，为什么我们需要创建一个签名验证器呢？</p><blockquote class="nn no np"><p id="1065" class="jv jw mb jx b jy jz ka kb kc kd ke kf nq kh ki kj nr kl km kn ns kp kq kr ks ig bi translated">验证事件源自 Paystack 非常重要，以避免基于 countefeit 事件传递值。</p></blockquote><p id="db32" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面引用的语句是我们为什么需要创建一个实现<code class="fe kt ku kv kw b">Spatie\WebhookClient\WebhookClient\SignatureValidator\SignatureValidator</code>接口的自定义签名验证器的原因。</p><pre class="mu mv mw mx gt my kw mz na aw nb bi"><span id="ef5f" class="nc ky in kw b gy nd ne l nf ng">//App/Handler/CustomSignatureValidator.php</span><span id="6701" class="nc ky in kw b gy nh ne l nf ng">&lt;?php</span><span id="bacc" class="nc ky in kw b gy nh ne l nf ng">namespace App\Handler;</span><span id="2e23" class="nc ky in kw b gy nh ne l nf ng">use Illuminate\Http\Request;</span><span id="06d7" class="nc ky in kw b gy nh ne l nf ng">use Spatie\WebhookClient\Exceptions\WebhookFailed;</span><span id="3540" class="nc ky in kw b gy nh ne l nf ng">use Spatie\WebhookClient\WebhookConfig;</span><span id="a13f" class="nc ky in kw b gy nh ne l nf ng">use Spatie\WebhookClient\SignatureValidator\SignatureValidator;</span><span id="ff44" class="nc ky in kw b gy nh ne l nf ng">class PaystackSignature implements SignatureValidator{<br/>    public function isValid(Request $request, WebhookConfig $config): bool{</span><span id="3106" class="nc ky in kw b gy nh ne l nf ng">$signature = $request-&gt;header($config-&gt;signatureHeaderName);</span><span id="24e1" class="nc ky in kw b gy nh ne l nf ng">if (! $signature) {</span><span id="a0b5" class="nc ky in kw b gy nh ne l nf ng">return false;<br/>     }</span><span id="bfc7" class="nc ky in kw b gy nh ne l nf ng">$signingSecret = $config-&gt;signingSecret;</span><span id="621a" class="nc ky in kw b gy nh ne l nf ng">if (empty($signingSecret)) {</span><span id="2343" class="nc ky in kw b gy nh ne l nf ng">throw WebhookFailed::signingSecretNotSet();<br/>     }</span><span id="806d" class="nc ky in kw b gy nh ne l nf ng">$computedSignature = hash_hmac('sha512', $request-&gt;getContent(), $signingSecret);</span><span id="a6e6" class="nc ky in kw b gy nh ne l nf ng">return hash_equals($signature, $computedSignature);<br/>   }<br/>}</span></pre><p id="f15d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">之后需要做的是用处理传入 webhook 响应的签名验证的类的名称来更新这个路径<code class="fe kt ku kv kw b">config/laravel-webhook-client.php</code>中的文件，以便真正确定它不是伪造的响应。</p><pre class="mu mv mw mx gt my kw mz na aw nb bi"><span id="8244" class="nc ky in kw b gy nd ne l nf ng">/*</span><span id="3738" class="nc ky in kw b gy nh ne l nf ng">*  This class will verify that the content of the signature header is valid.</span><span id="7c7b" class="nc ky in kw b gy nh ne l nf ng">*</span><span id="90b4" class="nc ky in kw b gy nh ne l nf ng">* It should implement \Spatie\WebhookClient\SignatureValidator\SignatureValidator</span><span id="9270" class="nc ky in kw b gy nh ne l nf ng">*/</span><span id="c053" class="nc ky in kw b gy nh ne l nf ng">'signature_validator' =&gt; App\Handler\CustomSignatureValidator::class,</span></pre><h1 id="57d9" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">存储和处理 webhooks</h1><p id="68a2" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">既然已经解决了这个问题，我们现在可以专注于处理 webhook 响应了。为此，我们需要创建一个名为<code class="fe kt ku kv kw b">Handler</code>的文件夹，并将其放在我们的<code class="fe kt ku kv kw b">App</code>目录中。</p><p id="431f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建文件夹后，我们需要在上面创建的文件夹中创建一个名为<code class="fe kt ku kv kw b">ProcessWebhook.php </code>的文件来处理(存储和处理)webhook 响应。</p><pre class="mu mv mw mx gt my kw mz na aw nb bi"><span id="e8c6" class="nc ky in kw b gy nd ne l nf ng">//App/Handler/ProcessWebhook.php<br/>&lt;?php</span><span id="a16d" class="nc ky in kw b gy nh ne l nf ng">namespace App\Handler;<br/>use \Spatie\WebhookClient\ProcessWebhookJob;</span><span id="1cff" class="nc ky in kw b gy nh ne l nf ng">//The class extends "ProcessWebhookJob" class as that is the class //that will handle the job of processing our webhook before we have //access to it.</span><span id="c2cb" class="nc ky in kw b gy nh ne l nf ng">class ProcessWebhook extends ProcessWebhookJob<br/>{</span><span id="1766" class="nc ky in kw b gy nh ne l nf ng">public function handle(){<br/>       $data = json_decode($this-&gt;webhookCall, true);<br/>       //Do something with the event<br/>       logger($data['payload']);<br/>       http_response_code(200); //Acknowledge you received the response</span><span id="76c7" class="nc ky in kw b gy nh ne l nf ng">}<br/>}</span></pre><p id="c2da" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">之后需要做的是用处理从 Paystack 或您可能使用的任何其他服务(比如 Github API、Stripe API 等)获得的 webhook 响应的类的名称来更新这个路径<code class="fe kt ku kv kw b">config/laravel-webhook-client.php</code>中的文件。</p><pre class="mu mv mw mx gt my kw mz na aw nb bi"><span id="9339" class="nc ky in kw b gy nd ne l nf ng">/*<br/>             * The class name of the job that will process the webhook request.<br/>             *<br/>             * This should be set to a class that extends \Spatie\WebhookClient\ProcessWebhookJob.<br/>             */<br/>            'process_webhook_job' =&gt; App\Handler\ProcessWebhook::class,<br/>        ],</span></pre><h1 id="32b2" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="9677" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">很有趣，对吧？在很短的时间内，我们就能够设置和配置一个 webhook-client 包来处理来自 Paystack 的事件。对于进一步的阅读，你可以在<a class="ae ma" href="https://github.com/spatie/laravel-webhook-client" rel="noopener ugc nofollow" target="_blank"> <em class="mb">阅读更多关于我们用于这个项目的包，它的官方文档</em> </a>也是如此。你也可以在<a class="ae ma" href="https://github.com/adejorosam/webhook-tutorial" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上查看这个项目的完整源代码。</p><p id="afc5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本文的下一部分，我们将看到如何在上线之前用 ngrok 在本地测试我们的 webhook！</p><p id="8946" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mb">如果你喜欢这个，点击💚所以其他人会在媒体上看到这个。</em></p><p id="11b2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">推特:@samss <a class="ae ma" href="https://twitter.com/samsss_a" rel="noopener ugc nofollow" target="_blank"> s_a </a></p></div></div>    
</body>
</html>