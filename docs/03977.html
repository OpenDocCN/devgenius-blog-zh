<html>
<head>
<title>Auto-scaling + Kubernetes = KEDA — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自动缩放+ Kubernetes = KEDA —第2部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/auto-scaling-kubernetes-keda-part-2-72fb3fc21c27?source=collection_archive---------5-----------------------#2021-01-10">https://blog.devgenius.io/auto-scaling-kubernetes-keda-part-2-72fb3fc21c27?source=collection_archive---------5-----------------------#2021-01-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/df431784048b9b86b3fbe441c43c0d2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*urJ_QDzPorqD9hgnxUfwnw.png"/></div></div></figure><p id="e6f6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">本文必备——Kubernetes、Azure函数App、Docker知识</em></p><p id="daca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<a class="ae ku" href="https://medium.com/dev-genius/auto-scaling-kubernetes-keda-part-1-d7638d67ea17" rel="noopener">第一部分</a>中，我已经解释了KEDA的高层想法。在这一部分，我们将看到实际的实现。</p><p id="d0cd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">用例</strong></p><p id="f8a9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有一个web应用程序，它从终端用户上传文件，并把它们放在云存储中。目标是以最小的延迟处理这些文件。为此，我们希望作业能够根据队列大小进行伸缩。</p><p id="1fc4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">组件</strong></p><ul class=""><li id="7a13" class="kv kw in jx b jy jz kc kd kg kx kk ky ko kz ks la lb lc ld bi translated">获取用户输入(文件)的Web应用程序</li><li id="b9ae" class="kv kw in jx b jy le kc lf kg lg kk lh ko li ks la lb lc ld bi translated">Azure Blob存储用于保存文件</li><li id="8bf9" class="kv kw in jx b jy le kc lf kg lg kk lh ko li ks la lb lc ld bi translated">Kubernetes与KEDA集群(真的，2.0版)</li><li id="1acc" class="kv kw in jx b jy le kc lf kg lg kk lh ko li ks la lb lc ld bi translated">Azure Function App作为一个作业，托管在Kubernetes集群中，处理来自存储的文件</li><li id="8a7b" class="kv kw in jx b jy le kc lf kg lg kk lh ko li ks la lb lc ld bi translated">存放docker图像的容器注册表</li></ul><p id="8a86" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这种情况下，web应用程序的实现并不重要。下面重点说一下azure功能app。</p><h2 id="285a" class="lj lk in bd ll lm ln dn lo lp lq dp lr kg ls lt lu kk lv lw lx ko ly lz ma mb bi translated">你可以使用这个github repo来获得所有的细节。</h2><ol class=""><li id="105e" class="kv kw in jx b jy mc kc md kg me kk mf ko mg ks mh lb lc ld bi translated"><strong class="jx io">安装</strong></li></ol><p id="7be6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一旦有了Kubernetes集群，就必须确保安装了KEDA。这很简单——只要遵循这里的官方指南<a class="ae ku" href="https://keda.sh/docs/2.0/deploy/" rel="noopener ugc nofollow" target="_blank">就行了</a>。</p><p id="3fb6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，您将拥有Kubernetes名称空间“keda”和几个部署。</p><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mi"><img src="../Images/1dfc773791b512a540320e904fb4dd89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nIwBiOWQzDBfJp17zCw-dA.png"/></div></div></figure><p id="3d0f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 2。作业启动</strong></p><p id="ae4e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">选择Azure Function App作为执行框架的主要原因是:</p><ul class=""><li id="73ba" class="kv kw in jx b jy jz kc kd kg kx kk ky ko kz ks la lb lc ld bi translated">效率——您不需要关心编码队列迭代——峰值、读取等；</li><li id="be8c" class="kv kw in jx b jy le kc lf kg lg kk lh ko li ks la lb lc ld bi translated">灵活性——您可以在Kubernetes集群中将其作为docker容器运行，或者直接在Azure平台上运行。</li></ul><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="4253" class="lj lk in mo b gy ms mt l mu mv">func init --worker-runtime dotnet --docker<br/>func new -n Demo -l C#</span></pre><p id="636c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">更新文件Demo.cs以指示连接字符串的存储位置(参数<strong class="jx io">连接</strong>):</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="5590" class="lj lk in mo b gy ms mt l mu mv">[FunctionName("Demo")]<br/>        public static void Run([QueueTrigger("myqueue-items", Connection = "AzureWebJobsStorage")]string myQueueItem, ILogger log)<br/>        {<br/>            log.LogInformation($"C# Queue trigger function processed: {myQueueItem}");<br/>        }</span></pre><p id="4741" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您正确配置了<strong class="jx io"> local.settings.json </strong>，并将一条消息添加到您的队列“myqueue-items”中，那么您可以通过从命令行启动它来测试您的函数:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="cc12" class="lj lk in mo b gy ms mt l mu mv">func start</span></pre><p id="f468" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 3。准备码头工人图像</strong></p><p id="63c9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">docker映像将用于托管我们之前创建的Azure function应用程序。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="3a82" class="lj lk in mo b gy ms mt l mu mv">docker build -t &lt;your registry name&gt;/demo-keda .</span></pre><p id="8bdd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">“demo-keda”是图像的名称。</p><p id="85bd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">并将其发送到注册表:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="da2a" class="lj lk in mo b gy ms mt l mu mv">docker push &lt;your registry name&gt;/demo-keda:latest</span></pre><p id="25d1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 4。准备Kubernetes </strong></p><p id="88e3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以通过以下命令为名称空间“demo”创建部署文件“deploy.yaml”。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="b730" class="lj lk in mo b gy ms mt l mu mv">func kubernetes deploy --name demo-keda --namespace demo \<br/>  --image-name &lt;your registry name&gt;/demo-keda:latest --dry-run &gt; deploy.yaml</span></pre><p id="1b9c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要将作业部署到kubernetes集群:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="9091" class="lj lk in mo b gy ms mt l mu mv">kubectl apply -f deploy.yaml</span></pre><p id="fdc2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">重要的</strong>！如果您使用KEDA 2.0版，请更新部署文件(ScaledObject一节):</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="3703" class="lj lk in mo b gy ms mt l mu mv">apiVersion: keda.sh/v1alpha1<br/>kind: ScaledObject<br/>metadata:<br/>  name: demo-keda<br/>  namespace: demo<br/>spec:<br/>  scaleTargetRef:<br/>    name: demo-keda<br/>  cooldownPeriod:  180<br/>  minReplicaCount: 0<br/>  maxReplicaCount: 2<br/>  advanced:<br/>    restoreToOriginalReplicaCount: true<br/>  triggers:<br/>  - type: azure-queue<br/>    metadata:<br/>      connectionFromEnv: AzureWebJobsStorage<br/>      queueName: myqueue-items<br/>      queueLength: '1'</span></pre><p id="b529" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 5。测试和监控</strong></p><p id="5a2f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最初，在您的名称空间“demo”中，活动窗格的数量应该为0。</p><p id="0c92" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您启动该命令，您可以开始监控由KEDA创建的窗格，如果您开始快速向队列添加消息:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="53c1" class="lj lk in mo b gy ms mt l mu mv">kubectl get pods -w -n demo</span></pre><p id="ad0a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 6。故障排除</strong></p><p id="f2f1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您的工作没有扩展，那么排除KEDA故障是有意义的。</p><p id="58a5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为此，我们需要来自pod“keda-operator-*”的日志。</p><p id="0448" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要查找要从中获取日志的所需pod的名称，请执行以下操作:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="4da7" class="lj lk in mo b gy ms mt l mu mv">kubectl get pods -n keda</span></pre><p id="54ae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要获取KEDA缩放日志:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="1d73" class="lj lk in mo b gy ms mt l mu mv">kubectl logs &lt;<!-- -->keda operator pod name<!-- -->&gt; -n keda</span></pre></div></div>    
</body>
</html>