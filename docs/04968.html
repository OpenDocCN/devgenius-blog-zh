<html>
<head>
<title>Close Holes in Your Code — Avoid Representing Invalid Scenarios</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">弥补代码中的漏洞——避免表现无效的场景</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/close-holes-in-your-code-avoid-representing-invalid-scenarios-9641e89b962e?source=collection_archive---------7-----------------------#2021-05-28">https://blog.devgenius.io/close-holes-in-your-code-avoid-representing-invalid-scenarios-9641e89b962e?source=collection_archive---------7-----------------------#2021-05-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="6c59" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">一个好的API不容易崩溃</h2><div class=""/><div class=""><h2 id="24fc" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">使用枚举设计Swift代码</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/02383945b3327a13ada2c52b0d637f7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-OfeetYdHaI_xwaIWaQaYw.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">保持这些孔关闭，这样你的用户就不会遇到干扰！</figcaption></figure><p id="1d4d" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">通常，在开发代码库时，您可能希望用两种可能结果中的一种来模拟一种情况。在Swift中，这通常意味着使用optionals作为方法的返回类型。想法是其中一个为零，另一个非零。</p><p id="5ba0" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在这种情况下，您可以创建一个方法，返回一个带有两个可选参数的元组。不是零的那个是通过测试的那个。这解决了想知道哪个包含值的问题。对你来说不幸的是，这产生了一个新问题。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ma"><img src="../Images/e750d6ac743d8acb5678e3fb6a6491f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IHJY36P_6D1eY5QE.png"/></div></div></figure><h2 id="0b85" class="mb mc iq bd md me mf dn mg mh mi dp mj ln mk ml mm lr mn mo mp lv mq mr ms iw bi translated">例如</h2><p id="ac1b" class="pw-post-body-paragraph le lf iq lg b lh mt ka lj lk mu kd lm ln mv lp lq lr mw lt lu lv mx lx ly lz ij bi translated">您需要知道一个对象是<code class="fe my mz na nb b">Item</code>还是<code class="fe my mz na nb b">Person</code>。在这个特定的场景中，it <em class="nc">必须让</em>成为其中之一。使用上面的方法和这个精心设计的例子:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ma"><img src="../Images/91789fdffa6e1fe29b7471b4fe786a75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*22pOwaz75yOVH1d8.png"/></div></div></figure><h1 id="7a7d" class="nf mc iq bd md ng nh ni mg nj nk nl mj kf nm kg mm ki nn kj mp kl no km ms np bi translated">您刚刚创建了一个无效的路径…</h1><h2 id="dc3d" class="mb mc iq bd md me mf dn mg mh mi dp mj ln mk ml mm lr mn mo mp lv mq mr ms iw bi translated"><code class="fe my mz na nb b">(person: nil, item: nil)</code>这不是我们所期待的结果。</h2><p id="27ce" class="pw-post-body-paragraph le lf iq lg b lh mt ka lj lk mu kd lm ln mv lp lq lr mw lt lu lv mx lx ly lz ij bi translated">记住，当你设计一个API时，你应该考虑下一个开发者。如果你正在为自己开发一个应用程序，那么下一个开发者就是你。我已经数不清有多少次不得不跳回到我几个月甚至几年前创建的代码中——不知道部分代码发生了什么，或者仅仅是因为我不记得我的初衷而误用了一些东西。</p><p id="f9ed" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">说到下一个开发者，如果这个开发者决定也为<code class="fe my mz na nb b">(person: person, item: item)</code>创建一个案例呢？这对于您设计API时所期望的结果也是无效的。</p><p id="cae2" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">创建这样的无效路径的问题是，你已经为bug潜入代码库创造了可能性。如果下一个开发人员用<code class="fe my mz na nb b">(person: nil, item: nil)</code>调用这个方法，但是他们期望一个非零结果，该怎么办？也许他们强行打开了它，现在我们遇到了麻烦…</p><p id="98e2" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">希望这不会造成那么大的问题，因为我确信你已经将全面的单元测试集成到你的应用程序中了…对吗？即便如此，它也为不必要的错误留下了空间，我们应该避免这种事情。</p><h2 id="1620" class="mb mc iq bd md me mf dn mg mh mi dp mj ln mk ml mm lr mn mo mp lv mq mr ms iw bi translated">可选方案增加了预期结果现场的复杂性</h2><p id="a2ca" class="pw-post-body-paragraph le lf iq lg b lh mt ka lj lk mu kd lm ln mv lp lq lr mw lt lu lv mx lx ly lz ij bi translated">不要误解我，我是可选方案的强烈支持者—这是我如此喜欢Swift的原因之一…但它们确实增加了复杂性。通过使用选项，您将看到必须打开结果才能看到它包含的内容。它让你做更多的决定。我要强行打开它吗？我可以打开它吗？我使用零合并吗？你明白了…</p><h1 id="1feb" class="nf mc iq bd md ng nh ni mg nj nk nl mj kf nm kg mm ki nn kj mp kl no km ms np bi translated">那么，如何避免无效路径，但仍然达到您想要的结果呢？</h1><p id="5b09" class="pw-post-body-paragraph le lf iq lg b lh mt ka lj lk mu kd lm ln mv lp lq lr mw lt lu lv mx lx ly lz ij bi translated">作为第一步，您可以创建一个非常简洁但是非常强大的enum，它封装了一个person案例、一个item案例和一个failure案例。人员和项目案例具有相关联的值<code class="fe my mz na nb b">person(Person)</code>和<code class="fe my mz na nb b">item(Item)</code>。失败案例也可以有一个像<code class="fe my mz na nb b">Error</code>这样的值，但是在这个例子中我们没有这样做。这只给了我们3个可能的返回路径:<code class="fe my mz na nb b">person(Person)</code>、<code class="fe my mz na nb b">item(Item)</code>。还有<code class="fe my mz na nb b">failure</code>。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="32fc" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">现在我们可以返回<code class="fe my mz na nb b">PersonItemResult</code>，而不是返回<code class="fe my mz na nb b">(person: Person?, item: Item?)</code>。在我们的方法中，我们将打开人和物品。如果它们的值成功展开，我们将返回适当的案例。如果都没有展开，我们返回失败案例。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c096" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在我们的调用站点，这为我们提供了案例和(如果有的话)相关的值。然而，我们仍然有一个无效路径要处理。如果一个人和一个项目都被传入怎么办？我们说过非此即彼。虽然我们的返回值代表一个或另一个，但在<code class="fe my mz na nb b">item</code>和<code class="fe my mz na nb b">person</code>都有值的情况下，我们不会失败——我们将只返回<code class="fe my mz na nb b">.person(person)</code>,因为第一种情况会通过。很简单，我们只需要确保<code class="fe my mz na nb b">item</code>在第一次检查中为零，而<code class="fe my mz na nb b">person</code>在第二次检查中为零。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nq"><img src="../Images/23feaeeb75dfac0c55428237e934867a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bGueHEav7idjFLk9bSvPPg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">不再有无效路径！</figcaption></figure><p id="d75b" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">要在没有操场输出的帮助下判断出它是哪种类型，您可以像这样简单地打开返回值:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="93b8" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">就是这样！您创建了一个枚举，它表示我们希望作为返回值表示的唯一事例，并且您阻止了无效事例返回有效值。</p><p id="b7b0" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">通过考虑我们的预期结果，我们可以很容易地防止错误潜入我们的代码库。像这样的枚举可以在许多不同的情况下与许多不同的类型一起使用，并且在转换一个闭包中的多个值时特别强大。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ma"><img src="../Images/91789fdffa6e1fe29b7471b4fe786a75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*22pOwaz75yOVH1d8.png"/></div></div></figure><p id="51f3" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">对于接下来的步骤，您可以创建一个HTTP客户机，它的enum只表示您希望客户机表示的<code class="fe my mz na nb b">URLResponse</code>、<code class="fe my mz na nb b">Data</code>和<code class="fe my mz na nb b">Error</code>的可能组合，然后将其用于您的闭包类型。</p><p id="46de" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">评论里见！⏬</p></div></div>    
</body>
</html>