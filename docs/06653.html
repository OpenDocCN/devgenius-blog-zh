<html>
<head>
<title>Scope Functions | Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">范围函数| Kotlin</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/scope-functions-kotlin-5131391ac48d?source=collection_archive---------8-----------------------#2022-01-23">https://blog.devgenius.io/scope-functions-kotlin-5131391ac48d?source=collection_archive---------8-----------------------#2022-01-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="9546" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们想为一个对象的上下文执行一个代码块时，有五个不同的<strong class="jm io">作用域函数</strong>可以使用。这是一个临时范围。在这个范围内，我们可以不使用对象的名称来访问它。</p><p id="1a09" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ki" href="https://kotlinlang.org/docs/scope-functions.html" rel="noopener ugc nofollow" target="_blank">基本上，这些函数做同样的事情:在一个对象上执行一段代码。不同的是这个对象是如何在块内变得可用的，以及整个表达式的结果是什么。</a></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/bf975aedfafb04a65d780f9a6916369e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sn6Lt3dsNv_ura8MEESXkw.png"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">关键差异表</figcaption></figure><h1 id="8739" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated"><strong class="ak">。&gt;让{ it-】T6】</strong></h1><p id="d7e0" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">Let 通常用于空校验。</p><p id="0311" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">即使我们用<strong class="jm io">“if”</strong>检查 null，不同的线程也可能访问该变量并导致应用程序崩溃。此外，该变量仍然是可空类型。</p><pre class="kk kl km kn gt mc md me mf aw mg bi"><span id="da43" class="mh la in md b gy mi mj l mk ml">if (number != null) {<br/>    val number2 = <em class="mm">number</em> + 1 // Number variable throws an error.<br/>}</span></pre><p id="6acc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是为什么我们必须使用 let。我们也可以将 let 块声明为一个值。let 块的最后一行将充当 return。同样，我们可以在 let 块中使用<strong class="jm io"> elvis 操作符</strong>。如果我们使用 elvis 操作符，我们的变量类型将不可为空。</p><pre class="kk kl km kn gt mc md me mf aw mg bi"><span id="bb51" class="mh la in md b gy mi mj l mk ml">val x = number?.<em class="mm">let </em><strong class="md io">{<br/>    </strong>val number2 = <strong class="md io">it </strong>+ 1<br/>    number2<br/><strong class="md io">} </strong>?: 3</span></pre><h1 id="9e1f" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi">}</h1></div><div class="ab cl mn mo hr mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ig ih ii ij ik"><h1 id="be24" class="kz la in bd lb lc mu le lf lg mv li lj lk mw lm ln lo mx lq lr ls my lu lv lw bi translated">。应用{ this--&gt;</h1><p id="46a5" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">如果我们要多次使用一个以上的属性或一个类的一个属性时使用 apply，我们就不需要每次都使用该类的对象。</p><pre class="kk kl km kn gt mc md me mf aw mg bi"><span id="d3bf" class="mh la in md b gy mi mj l mk ml">val intent = Intent().<em class="mm">apply </em><strong class="md io">{<br/>    </strong>putExtra("", "")<br/>    putExtra("", 0)<br/>    <em class="mm">action </em>= ""<br/><strong class="md io">}</strong></span></pre><h1 id="712f" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated"><strong class="ak"> } </strong></h1></div><div class="ab cl mn mo hr mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ig ih ii ij ik"><h1 id="d3b8" class="kz la in bd lb lc mu le lf lg mv li lj lk mw lm ln lo mx lq lr ls my lu lv lw bi translated">。运行{ this--&gt;</h1><p id="3079" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">Run 的工作方式类似于 with。但是当我们使用 run 的时候，如果要赋一个变量或者值，就必须在最后一行返回我们想要的类型，否则就是一个单位。</p><pre class="kk kl km kn gt mc md me mf aw mg bi"><span id="b030" class="mh la in md b gy mi mj l mk ml">val intent2 = Intent().<em class="mm">run </em><strong class="md io">{<br/>    </strong>putExtra("", "")<br/>    putExtra("", 0)<br/>    <em class="mm">action </em>= ""<br/>    this<br/><strong class="md io">}</strong></span></pre><h1 id="88e5" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi">}</h1></div><div class="ab cl mn mo hr mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ig ih ii ij ik"><h1 id="c206" class="kz la in bd lb lc mu le lf lg mv li lj lk mw lm ln lo mx lq lr ls my lu lv lw bi translated">with(){ this--&gt;</h1><p id="5cfd" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">一个非扩展函数:<strong class="jm io">上下文对象</strong>作为一个参数传递，但是在 lambda 内部，它作为一个接收器(<code class="fe mz na nb md b">this</code>)可用。<strong class="jm io">返回值</strong>为 lambda 结果。在我看来，同样适用。我不知道它们之间有什么不同。</p><pre class="kk kl km kn gt mc md me mf aw mg bi"><span id="e5cf" class="mh la in md b gy mi mj l mk ml">val intent3 = <em class="mm">with</em>(Intent()) <strong class="md io">{<br/>    </strong>putExtra("","")<br/><strong class="md io">}</strong></span></pre><h1 id="c8f2" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi">}</h1></div><div class="ab cl mn mo hr mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ig ih ii ij ik"><h1 id="c799" class="kz la in bd lb lc mu le lf lg mv li lj lk mw lm ln lo mx lq lr ls my lu lv lw bi translated">。也{ it--&gt;</h1><p id="e64d" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated"><strong class="jm io">上下文对象</strong>可作为实参使用(<strong class="jm io"> <em class="mm"> it </em> </strong>)。<strong class="jm io">返回值</strong>是对象本身。</p><p id="e4a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">同样</strong>对于执行一些将上下文对象作为参数的动作也很有用。对于需要引用对象而不是其属性和功能的操作，或者当您不想从外部作用域隐藏<strong class="jm io">这个</strong>引用时，也可以使用<strong class="jm io">。</strong></p><pre class="kk kl km kn gt mc md me mf aw mg bi"><span id="0ef3" class="mh la in md b gy mi mj l mk ml">fun getSquaredI() = (i * i).<em class="mm">also </em><strong class="md io">{<br/>    </strong>i++<br/><strong class="md io">}</strong></span></pre><h1 id="569e" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi">}</h1></div><div class="ab cl mn mo hr mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ig ih ii ij ik"><p id="1f25" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我所说的只是解释的摘要。可以查看<a class="ae ki" href="https://kotlinlang.org/docs/scope-functions.html#also" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="mm">链接</em></strong></a><strong class="jm io"><em class="mm"/></strong>了解更多详细信息。</p><blockquote class="nc nd ne"><p id="a36f" class="jk jl mm jm b jn jo jp jq jr js jt ju nf jw jx jy ng ka kb kc nh ke kf kg kh ig bi translated">感谢阅读，我希望它是有帮助的。</p></blockquote><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ni"><img src="../Images/0904b6b20affc82f808f756b0a795976.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LyC7wQiVsNNdVRWx"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">里克·范德克伦在<a class="ae ki" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure></div></div>    
</body>
</html>