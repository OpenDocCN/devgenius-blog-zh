<html>
<head>
<title>Secure your Spring Boot application using Keycloak</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Keycloak 保护您的 Spring Boot 应用程序</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/secure-your-spring-boot-application-using-keycloak-8c63e0530089?source=collection_archive---------0-----------------------#2022-03-06">https://blog.devgenius.io/secure-your-spring-boot-application-using-keycloak-8c63e0530089?source=collection_archive---------0-----------------------#2022-03-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/4735fe364be100184355163a5a1afdba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qIm4Qp5DyCvgX_-eY5hGRw.png"/></div></div></figure><p id="2b8e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用 Spring Boot 并在没有安全层的情况下公开我们的 API 端点并不是一个好主意。在本指南中，我们将介绍如何使用<strong class="jx io"> Keycloak </strong>设置<strong class="jx io"> Spring Security </strong>，因此我们需要在实际调用端点 API 之前对 Keycloak 服务进行认证。作为以前的 Spring Boot 教程，我们将在这里使用博客 api 的例子。</p><p id="914b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将首先克隆这个库:【https://github.com/mjovanc/medium-spring-keycloak】T4，然后使用<em class="ku"> IntelliJ </em>或更好的 IDE/编辑器打开这个项目。确保您已经用 PostgreSQL 设置了数据库。查看这里的教程了解如何设置它:<a class="ae kt" href="https://mjovanc.com/spring-boot-with-postgresql-and-hibernate-26dc00de27e" rel="noopener ugc nofollow" target="_blank">https://mjovanc . com/spring-boot-with-PostgreSQL-and-hibernate-26dc 00 de 27 e</a></p><p id="d7b2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，当我们可以在本地启动项目并且一切正常时，我们现在需要做的是添加对 Keycloak 和 Spring 安全性的依赖:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="1983" class="le lf in la b gy lg lh l li lj">// Security<br/>implementation group: 'org.keycloak', name: 'keycloak-spring-boot-starter', version: '16.1.0'<br/>implementation group: 'org.keycloak.bom', name: 'keycloak-adapter-bom', version: '16.1.0', ext: 'pom'<br/>implementation group: 'org.springframework.boot', name: 'spring-boot-starter-security', version: '2.6.2'</span></pre><p id="50be" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将此代码放入依赖块中的<strong class="jx io"> build.gradle </strong>中，然后按现在出现的 gradle 按钮<strong class="jx io"> Load Gradle Changes </strong>或按<strong class="jx io"> CTRL+SHIFT+O </strong>将依赖项下载到项目中。</p><p id="f1b4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们已经有了依赖项，我们将开始创建一个名为<strong class="jx io">安全</strong>的新包，其中有包<em class="ku">控制器</em>、<em class="ku">模型</em>、服务和<em class="ku">存储库</em>。我们创建一个名为<strong class="jx io">SecurityConfig.java</strong>的新类，并将以下代码放入其中:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="9d09" class="le lf in la b gy lg lh l li lj">package com.mjovanc.blog.security;<br/><br/>import org.keycloak.adapters.springboot.KeycloakSpringBootConfigResolver;<br/>import org.keycloak.adapters.springsecurity.KeycloakSecurityComponents;<br/>import org.keycloak.adapters.springsecurity.authentication.KeycloakAuthenticationProvider;<br/>import org.keycloak.adapters.springsecurity.config.KeycloakWebSecurityConfigurerAdapter;<br/>import org.springframework.beans.factory.annotation.Autowired;<br/>import org.springframework.context.annotation.Bean;<br/>import org.springframework.context.annotation.ComponentScan;<br/>import org.springframework.context.annotation.Configuration;<br/>import org.springframework.http.HttpMethod;<br/>import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;<br/>import org.springframework.security.config.annotation.web.builders.HttpSecurity;<br/>import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;<br/>import org.springframework.security.core.authority.mapping.SimpleAuthorityMapper;<br/>import org.springframework.security.core.session.SessionRegistryImpl;<br/>import org.springframework.security.web.authentication.session.RegisterSessionAuthenticationStrategy;<br/>import org.springframework.security.web.authentication.session.SessionAuthenticationStrategy;<br/><br/><br/>@Configuration<br/>@EnableWebSecurity<br/>@ComponentScan(basePackageClasses = KeycloakSecurityComponents.class)<br/>public class SecurityConfig extends KeycloakWebSecurityConfigurerAdapter {<br/><br/>    @Autowired<br/>    public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {<br/>        KeycloakAuthenticationProvider keycloakAuthenticationProvider<br/>                = keycloakAuthenticationProvider();<br/>        keycloakAuthenticationProvider.setGrantedAuthoritiesMapper(<br/>                new SimpleAuthorityMapper());<br/>        auth.authenticationProvider(keycloakAuthenticationProvider);<br/>    }<br/><br/>    @Bean<br/>    public KeycloakSpringBootConfigResolver KeycloakConfigResolver() {<br/>        return new KeycloakSpringBootConfigResolver();<br/>    }<br/><br/>    @Bean<br/>    @Override<br/>    protected SessionAuthenticationStrategy sessionAuthenticationStrategy() {<br/>        return new RegisterSessionAuthenticationStrategy(<br/>                new SessionRegistryImpl());<br/>    }<br/><br/>    @Override<br/>    protected void configure(HttpSecurity http) throws Exception {<br/>        super.configure(http);<br/>        http<br/>                .authorizeRequests()<br/>                .antMatchers(HttpMethod.<em class="ku">POST</em>).hasAnyRole("maintainer", "admin")<br/>                .antMatchers(HttpMethod.<em class="ku">PATCH</em>).hasAnyRole("maintainer", "admin")<br/>                .antMatchers(HttpMethod.<em class="ku">DELETE</em>).hasAnyRole("maintainer", "admin")<br/>                .antMatchers(HttpMethod.<em class="ku">PUT</em>).hasAnyRole("maintainer", "admin")<br/>                .antMatchers("/v1/posts").hasAnyRole("user", "maintainer", "admin")<br/>                .antMatchers("/v1/categories").hasAnyRole("user", "maintainer", "admin")<br/>                .antMatchers("/v1/tags").hasAnyRole("user", "maintainer", "admin")<br/>                .anyRequest().permitAll();<br/>    }<br/>}</span></pre><p id="fcd0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们在这里配置的最重要的部分是在名为<strong class="jx io">配置</strong>的方法中。我们使用<strong class="jx io"> HttpSecurity </strong>对象，并将其配置为将<em class="ku"> POST </em>、<em class="ku"> PATCH </em>、<em class="ku"> DELETE </em>和<em class="ku"> PUT </em>的使用仅限于维护者和管理员角色。我们定义的其他端点，用户角色以及维护者和管理员也可以通过执行<em class="ku"> GET </em>请求来访问:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="c8e2" class="le lf in la b gy lg lh l li lj">.authorizeRequests()<br/>.antMatchers(HttpMethod.<em class="ku">POST</em>).hasAnyRole("maintainer", "admin")<br/>.antMatchers(HttpMethod.<em class="ku">PATCH</em>).hasAnyRole("maintainer", "admin")<br/>.antMatchers(HttpMethod.<em class="ku">DELETE</em>).hasAnyRole("maintainer", "admin")<br/>.antMatchers(HttpMethod.<em class="ku">PUT</em>).hasAnyRole("maintainer", "admin")<br/>.antMatchers("/v1/posts").hasAnyRole("user", "maintainer", "admin")<br/>.antMatchers("/v1/categories").hasAnyRole("user", "maintainer", "admin")<br/>.antMatchers("/v1/tags").hasAnyRole("user", "maintainer", "admin")<br/>.anyRequest().permitAll();</span></pre><p id="4b60" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">配置这个非常简单。所以现在我们将添加一些配置到我们的<strong class="jx io"> application.yml </strong>属性文件中:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="d614" class="le lf in la b gy lg lh l li lj">spring:<br/>  datasource:<br/>    url: jdbc:postgresql://${POSTGRESQL_HOSTNAME:localhost}:${POSTGRESQL_PORT:5432}/${POSTGRESQL_DB_NAME:blogdb_dev}<br/>    username: ${POSTGRESQL_DB_USER:postgres}<br/>    password: ${POSTGRESQL_DB_PASSWORD:test1234}<br/>  jpa:<br/>    hibernate:<br/>      ddl-auto: update<br/><br/>keycloak:<br/>  auth-server-url: http://${KEYCLOAK_HOSTNAME:localhost}:${KEYCLOAK_PORT:11111}/auth<br/>  realm: BlogAPIKeycloak<br/>  resource: login-app<br/>  public-client: true<br/>  bearer-only: true</span></pre><p id="4673" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们设置了 Keycloak 将监听的<strong class="jx io"> auth-server-url </strong>，我们将使用哪个<strong class="jx io">领域</strong>名称，<strong class="jx io">资源</strong>名称，使用<strong class="jx io">公共客户端</strong>，并且我们将只使用<strong class="jx io">承载令牌</strong>而不是通过 GUI 登录。</p><p id="fbfd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们通过运行以下命令，使用<em class="ku"> Docker </em>来设置 Keycloak 服务:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="e43e" class="le lf in la b gy lg lh l li lj">docker run --name keycloak -e KEYCLOAK_USER=admin -e KEYCLOAK_PASSWORD=admin -p 11111:11111 jboss/keycloak -Djboss.http.port=11111</span></pre><p id="55c3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将下拉图像并为我们运行 Docker 容器，我们将发送两个环境变量<strong class="jx io"> KEYCLOAK_ADMIN </strong>和<strong class="jx io"> KEYCLOAK_ADMIN_PASSWORD </strong>，我们将使用它们登录到管理区域，以便为 KEYCLOAK 设置配置。现在我们转到 URL:<a class="ae kt" href="http://localhost:11111/auth" rel="noopener ugc nofollow" target="_blank">http://localhost:11111/auth</a>，我们将看到这样一个页面:</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lk"><img src="../Images/8444b305ca5123f1b7d775d507172ec5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jo-vi9dMZryWSLaKOzS-NQ.png"/></div></div></figure><p id="0e65" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们已经成功地在本地计算机上设置了 Keycloak 服务。这种设置<strong class="jx io">不应该在生产</strong>中使用，还有很多事情需要考虑，超出了本教程的范围。</p><p id="8b74" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，我们现在需要做的是使用运行容器时设置的凭据登录，然后我们创建一个新领域，如下图所示:</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ll"><img src="../Images/079e548fe18a9f3644f11624c0e8a459.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_OGo3U0uTzecD2wNiwPOMA.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">按“添加领域”按钮创建一个新领域</figcaption></figure><p id="2390" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将输入我们在之前的<strong class="jx io"> application.yml </strong>中定义的名称，<strong class="jx io">blogapikeyclook</strong>。然后，我们前往左侧面板的<strong class="jx io">客户端</strong>并创建一个新客户端。客户端名称应该是我们之前定义的资源名称，<strong class="jx io"> login-app </strong>。现在，当我们按保存时，我们需要选择名为<strong class="jx io">的字段，访问类型</strong>到<strong class="jx io">机密</strong>。我们还必须向字段<strong class="jx io">有效重定向 URIs </strong>添加一个值:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="8bdd" class="le lf in la b gy lg lh l li lj">http://localhost:8080/*</span></pre><p id="3531" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后前往标签<strong class="jx io">凭证</strong>和<strong class="jx io">生成密码</strong>并在此复制以备后用。按保存。</p><p id="5156" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们转到左侧面板的<strong class="jx io">角色</strong>。我们将在这里创建三个角色:<strong class="jx io">用户</strong>、<strong class="jx io">维护者</strong>和<strong class="jx io">管理员</strong>。然后我们转到<strong class="jx io">用户</strong>并创建两个用户:</p><blockquote class="lq"><p id="2f15" class="lr ls in bd lt lu lv lw lx ly lz ks dk translated">用户名:mjovanc <br/>密码:test1234</p><p id="0b9d" class="lr ls in bd lt lu lv lw lx ly lz ks dk translated">用户名:admin <br/>密码:test1234</p></blockquote><p id="1f30" class="pw-post-body-paragraph jv jw in jx b jy ma ka kb kc mb ke kf kg mc ki kj kk md km kn ko me kq kr ks ig bi translated">创建这些用户后，我们将设置密码并为每个用户添加一个角色。我们按下“查看所有用户”以显示我们创建的用户，进入每个用户，首先通过转到<strong class="jx io">凭证</strong>选项卡设置密码，并输入两次密码，不要忘记取消选中<strong class="jx io">临时</strong>，否则将无法进行身份验证。然后我们转到选项卡<strong class="jx io">角色映射</strong>，我们将<strong class="jx io">用户</strong>添加到 mjovanc，并将<strong class="jx io">管理员</strong>添加到 admin，这是显而易见的。</p><p id="1a52" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不错！我们现在已经完成了 Keycloak 中的配置。实际上，我们已经完成了所有的实现，所以是时候测试这是否真的可行了。</p><p id="0c3b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们打开<em class="ku"> Postman </em>并尝试验证和获取不记名令牌！</p><p id="0474" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">粘贴网址<a class="ae kt" href="http://localhost:11111/auth/realms/BlogAPIKeycloak/protocol/openid-connect/token" rel="noopener ugc nofollow" target="_blank">http://localhost:11111/auth/realms/BlogAPIKeycloak/protocol/OpenID-connect/token</a>。注意，这里我们指定了我们用来认证的<strong class="jx io"> BlogAPIKeycloak </strong>领域。填写以下信息:</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mf"><img src="../Images/c606d8842e670074387adb423c432e32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dn7IsywuszE2clvSDWjsig.png"/></div></div></figure><p id="045e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们看到一堆东西。我们选择执行一个<strong class="jx io"> POST </strong>请求，因为我们将向 Keycloak 服务发送一些数据。我们选择以<strong class="jx io"> x-www-form-urlencoded </strong>类型发送主体数据，并添加一些键值对，其中包含数据，如<strong class="jx io"> client_id </strong>、<strong class="jx io">用户名</strong>、<strong class="jx io">密码</strong>、<strong class="jx io"> grant_type </strong>和<strong class="jx io"> client_secret </strong>。</p><p id="ea10" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们在下面的响应区域看到的是我们从 Keycloak 收到的数据，例如访问令牌，它是<strong class="jx io">持有者</strong>令牌。我们在这里也得到一堆其他的东西，但是我们现在不讨论它的含义。</p><p id="7b12" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们已经验证了自己，让我们从 API 请求一些东西。我们复制已经收到的访问令牌，并将其粘贴到此处，如屏幕截图所示:</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mf"><img src="../Images/6ca9df7dc98fa6c52e88b4b813d84ab8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GS7eRiOxdIIsclgTtwR7yg.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">在这里，我们粘贴获得的访问令牌，我们需要选择类型作为不记名令牌</figcaption></figure><p id="8ed5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">显然，我们还没有向数据库中添加任何东西，但是我们得到了一个响应，表明它可以工作，因为我们得到了一个空列表。如果它不起作用，我们将得到一个<strong class="jx io">401</strong>T26】未授权的错误。</p><p id="6e63" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们现在做一个<em class="ku"> POST </em>请求来添加一篇博客文章，但是首先我们需要将自己认证为 admin，因此我们为 admin 放置凭证并获取访问令牌。然后，我们在<em class="ku">邮递员</em>中添加一个新的<em class="ku">帖子</em>请求，并添加以下内容:</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mf"><img src="../Images/90ecf644792b19a66fab2dbe4b31aa90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0TLziQnDgZcne7mUv4Ozww.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">发送带有 JSON 对象数据的 POST 请求</figcaption></figure><p id="2238" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里，我们像以前一样将访问令牌添加到<strong class="jx io">授权</strong>中，然后我们将<em class="ku"> JSON </em>对象数据添加到<strong class="jx io">主体</strong>部分中。正如我们可以看到的，我们从创建了的 API <strong class="jx io"> 201 得到了一个响应。所以它创建了一个新的对象！</strong></p><p id="6697" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们再做一次<em class="ku">获取</em>所有博文的请求:</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mf"><img src="../Images/df85f3f87ed21324bf9de2ce5eb545af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HuhSWrky4SffA0OZXy2THQ.png"/></div></div></figure><p id="2673" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">太好了！我们得到了我们在数组中创建的对象。所以现在我们有了一个全功能的 Keycloak 身份验证服务，它是用 Spring Boot 实现的，供开发使用。你可以用 Keycloak 配置很多东西，但是我们现在就用这个简单的例子。</p><p id="455c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我希望这个教程对你有用。如果你这样做了，请留下你的评论或关注我，以便在我写新文章时了解最新消息。</p></div></div>    
</body>
</html>