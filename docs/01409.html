<html>
<head>
<title>Common Vue Problems — Async Hosting, and More</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">常见的 Vue 问题—异步托管等等</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/common-vue-problems-async-hosting-and-more-69705bc35d95?source=collection_archive---------28-----------------------#2020-07-02">https://blog.devgenius.io/common-vue-problems-async-hosting-and-more-69705bc35d95?source=collection_archive---------28-----------------------#2020-07-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/fbf9a7e52e9d3333d9e58689b1b35a40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3JR3R9zxJlm28HTr"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@kalenemsley?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卡伦·艾姆斯利</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="51c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Vue.js 让开发前端应用变得简单。然而，我们仍有可能遇到问题。</p><p id="0df2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将看看一些常见的问题，并看看如何解决它们。</p><h1 id="6f2d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">异步-等待和装载</h1><p id="5254" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">async</code> / <code class="fe me mf mg mh b">await</code>语法，这样我们就可以在<code class="fe me mf mg mh b">mounted</code>钩子中干净利落地使用承诺。</p><p id="f738" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8e3b" class="mq lc iq mh b gy mr ms l mt mu">{<br/>  ...<br/>  <!-- -->data () {<br/>    return {<br/>      dataReady: false,      <br/>    }<br/>  },<br/><br/>  async mounted() {<br/>    await doSomething();<br/>    await doOtherThing();<br/>    doMore();<br/>    this.dataReady = true;<br/>  },<br/>  ...<br/>}</span></pre><h1 id="8bc8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">防止 Vue 组件中的事件冒泡</h1><p id="3cee" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们更喜欢使用<code class="fe me mf mg mh b">self</code>修饰符的事件冒泡。</p><p id="9c01" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它表明我们不希望事件传播到父元素和祖先元素。</p><p id="2ae2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="10fc" class="mq lc iq mh b gy mr ms l mt mu">&lt;div v-on:click.self="doSomething"&gt;...&lt;/div&gt;</span></pre><p id="ee08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以只有当 div 被点击时，才会调用<code class="fe me mf mg mh b">doSomething</code></p><h1 id="ef8a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">避免直接改变属性，因为值会被覆盖'错误</h1><p id="15e1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当我们想要通过 props 将一个值从父值更改为子值时，我们不应该直接更改它来更改父值的状态值。</p><p id="8717" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此错误显示在控制台中，因为我们正在覆盖属性值。</p><p id="92b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们应该使用 getter 和 setter 来创建一个计算属性，而不是直接修改 props。</p><p id="7074" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为从父节点传入的属性值会覆盖我们的更改。</p><p id="0422" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="bd8e" class="mq lc iq mh b gy mr ms l mt mu">computed: {<br/>  user: {<br/>    get(){<br/>      return this.username;<br/>    },<br/>    set(newValue){<br/>      this.$emit('update:username', newValue)<br/>    }   <br/>  }<br/>  ...<br/>}</span></pre><p id="9f83" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设<code class="fe me mf mg mh b">username</code>是一个 prop 值，它作为<code class="fe me mf mg mh b">user</code>的值返回。</p><p id="e9c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们设置<code class="fe me mf mg mh b">this.user</code>时，将会发出<code class="fe me mf mg mh b">update:username</code>事件，因此如果父节点监听<code class="fe me mf mg mh b">update:username</code>事件，它将会获得该值。</p><p id="f58c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">newValue</code>是我们发出的价值。</p><p id="131c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在在父节点中，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="dd96" class="mq lc iq mh b gy mr ms l mt mu">&lt;child @<!-- -->update:username='doSomething'&gt;&lt;/child&gt;</span></pre><p id="04dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设子组件名为<code class="fe me mf mg mh b">child</code>，我们监听<code class="fe me mf mg mh b">update:username</code>事件来更新值。</p><p id="747b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">发出的值将作为<code class="fe me mf mg mh b">doSomething</code>的第一个参数。</p><h1 id="4771" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在 Vue 组件中对 v-model 使用 contentEditable</h1><p id="42fa" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们使用<code class="fe me mf mg mh b">contenteditable</code>属性使一个元素的内容可编辑，我们需要监听<code class="fe me mf mg mh b">input</code>事件来获取最新的内容。</p><p id="a797" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b88b" class="mq lc iq mh b gy mr ms l mt mu">&lt;template&gt;<br/>  &lt;p<br/>    contenteditable<br/>    @input="onInput"<br/>  &gt;<br/>    {{ content }}<br/>  &lt;/p&gt;<br/>&lt;/template&gt;</span><span id="5eaf" class="mq lc iq mh b gy mv ms l mt mu">&lt;script&gt;<br/>export default {<br/>  data() {<br/>    return { content: 'hello' };<br/>  },<br/>  methods: {<br/>    onInput(e) {<br/>      console.log(e.target.innerText);<br/>    },<br/>  },<br/>};<br/>&lt;/script&gt;</span></pre><p id="6b09" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有<code class="fe me mf mg mh b">onInput</code>，它将输入事件对象作为<code class="fe me mf mg mh b">e</code>的值。</p><p id="72bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以用<code class="fe me mf mg mh b">e.target.innerText</code>得到最近一次改变的值。</p><h1 id="5199" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">具有嵌套级别路由的路由器视图</h1><p id="775c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们必须为每一层嵌套设置一个<code class="fe me mf mg mh b">router-view</code>。</p><p id="f1fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0deb" class="mq lc iq mh b gy mr ms l mt mu">routes: [<br/>  {<br/>    path: '/',<br/>    component: Dashboard<br/>  },<br/>  {<br/>    path: '/tasks',<br/>    component: Tasks<br/>  },<br/>  {<br/>    path: '/tasks/:id',<br/>    name: 'task-detail',<br/>    component: TaskDetails,<br/>    children: [<br/>      {<br/>        path: '/tasks/:taskId/statuses',<br/>        component: Statuses<br/>      },<br/>      {<br/>        path: '/tasks/:taskId/statuses/:statusId/details',<br/>        component: StatusDetails<br/>      },<br/>    ]<br/>  }<br/>]</span></pre><p id="2cd4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们有这些路线，那么我们需要一个<code class="fe me mf mg mh b">router-view</code>来存放顶层，另一个<code class="fe me mf mg mh b">TaskDetails</code>来存放状态路线。</p><p id="ff14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们可以看到在<code class="fe me mf mg mh b">routes</code>数组中列出的所有东西。</p><h1 id="2c4f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将 URL 参数传递给 URL</h1><p id="1e5c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">href</code>上的<code class="fe me mf mg mh b">v-bind</code>来设置路线。</p><p id="edc5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7141" class="mq lc iq mh b gy mr ms l mt mu">&lt;a :href="`/item/${item.id}`"&gt;Click&lt;/a&gt;</span></pre><p id="b3e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以将<code class="fe me mf mg mh b">item.id</code>插入到 URL 中。</p><h1 id="faee" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将 Vue 应用程序部署到节点服务器</h1><p id="93a0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用 Express 将应用程序作为静态资产托管，以便它加载 Vue 应用程序。</p><p id="6194" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1348" class="mq lc iq mh b gy mr ms l mt mu">const express = require('express');<br/>const path = require('path');<br/>const serveStatic = require('serve-static');<br/>app = express();<br/>app.use(serveStatic(<!-- -->path.join(<!-- -->__dirname, `/dist`)));<br/>const port = process.env.PORT || 5000;<br/>const hostname = '127.0.0.1';</span><span id="2b0a" class="mq lc iq mh b gy mv ms l mt mu">app.listen(port, hostname, () =&gt; {<br/>   console.log(`Server running`);<br/> });</span></pre><p id="6a12" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<code class="fe me mf mg mh b">serveStatic</code>中间件将 Vue 应用作为静态文件提供。</p><p id="c60d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">dist</code>文件夹有内置的 Vue app。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/85db72f7de92d811a2a25ddbd8a1471c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Gs0W92BwSnB9LeUy"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">约翰·麦肯在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="3c20" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="5270" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以在我们的方法和生命周期挂钩中使用<code class="fe me mf mg mh b">async</code>和<code class="fe me mf mg mh b">await</code>。</p><p id="cbe9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以将 Vue 应用程序作为静态文件托管在 Express 应用程序中。</p><p id="7fcd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于嵌套路由，我们应该有嵌套路由器视图。</p><p id="ca74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们使用<code class="fe me mf mg mh b">contentEditable</code>属性使元素的内容可编辑，我们可以从<code class="fe me mf mg mh b">input</code>事件中获得值。</p></div></div>    
</body>
</html>