<html>
<head>
<title>The Ruby Object Model (OOP in Ruby)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ruby 对象模型(Ruby 中的 OOP)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/the-ruby-object-model-24dc05670c67?source=collection_archive---------10-----------------------#2022-10-13">https://blog.devgenius.io/the-ruby-object-model-24dc05670c67?source=collection_archive---------10-----------------------#2022-10-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/54ad3ed496dcfacce6199dfc38339b72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MHXLHhdQYIQDy8Ib"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><a class="ae jz" href="https://unsplash.com/es/@dari_lli?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">达里里</a>在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="cba4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">面向对象编程(OOP)是为解决大型软件系统日益增加的复杂性而开发的编程范例。程序员很快发现，随着应用程序的复杂性和规模的增长，它们变得非常难以维护。由于整个程序的依赖性，程序中任何一点的微小变化都会导致一连串的错误。</p><p id="5e31" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">程序员需要一种方法来创建可以在不影响整个程序的情况下进行更改和操作的数据容器。他们需要一种方法来分离执行特定过程的代码区域，以便他们的程序可以是许多小部分的交互，而不是一个大块的依赖。</p><blockquote class="ky"><p id="5f00" class="kz la in bd lb lc ld le lf lg lh kx dk translated">"面向对象设计是计算的罗马数字."</p><p id="8ce2" class="kz la in bd lb lc ld le lf lg lh kx dk translated">—罗布·派克</p></blockquote></div><div class="ab cl li lj hr lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ig ih ii ij ik"><h1 id="fcfb" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">术语</h1><p id="9a44" class="pw-post-body-paragraph ka kb in kc b kd mn kf kg kh mo kj kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">进入 OOP。一种新的编码方式，完全不同于过程式编程风格。首先，让我们回顾一些术语。</p><h2 id="3dcb" class="ms lq in bd lr mt mu dn lv mv mw dp lz kl mx my md kp mz na mh kt nb nc ml nd bi translated">包装</h2><p id="db90" class="pw-post-body-paragraph ka kb in kc b kd mn kf kg kh mo kj kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">封装是隐藏部分功能并使它们对代码库的其余部分不可访问的过程。这是一种数据安全性，确保数据在没有明显意图的情况下不会被操纵或更改。它定义了您的应用程序的边界，并允许您的代码达到新的复杂程度。Ruby 和许多其他面向对象语言一样，通过定义对象和暴露接口(即方法)来完成这个任务。</p><p id="72b9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对象创建的另一个优点是它允许程序员在更高的抽象层次上思考。对象在现实世界中被表示为名词，并且可以被赋予描述程序员试图表示的行为的方法。</p><h2 id="df7e" class="ms lq in bd lr mt mu dn lv mv mw dp lz kl mx my md kp mz na mh kt nb nc ml nd bi translated">多态性</h2><p id="5f85" class="pw-post-body-paragraph ka kb in kc b kd mn kf kg kh mo kj kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">多态性指的是各种类型的数据响应公共接口的能力。例如，如果一个方法需要带有<code class="fe ne nf ng nh b">move</code>方法的参数对象，我们可以传递给它任何类型的参数，只要它有一个兼容的<code class="fe ne nf ng nh b">move</code>方法。这个物体可以代表一个人，一只猫，一只水母，甚至一辆汽车或火车。也就是说，它允许不同类型的对象响应相同的方法调用。</p><p id="0aad" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">“Poly”的意思是“许多”，而“morph”的意思是“形式”OOP 允许我们为新的目的重用预先编写的代码。</p><h2 id="5843" class="ms lq in bd lr mt mu dn lv mv mw dp lz kl mx my md kp mz na mh kt nb nc ml nd bi translated">遗产</h2><p id="4444" class="pw-post-body-paragraph ka kb in kc b kd mn kf kg kh mo kj kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">在 Ruby 中，当一个类继承另一个类(称为超类)的行为时，就使用了继承的概念。这允许 Ruby 程序员定义具有高度可重用性的基本类和更小的子类，以实现更细粒度、更详细的行为。</p><h2 id="b022" class="ms lq in bd lr mt mu dn lv mv mw dp lz kl mx my md kp mz na mh kt nb nc ml nd bi translated">混合蛋白</h2><p id="c25d" class="pw-post-body-paragraph ka kb in kc b kd mn kf kg kh mo kj kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">模块是将多态结构应用于 Ruby 程序的另一种方式。模块和类具有可比性，因为它们包含共享的行为。但是，模块不能用于创建对象。</p><p id="fe8b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">必须通过调用 include 方法将模块包含在类中。这就是所谓的 mixin。在一个模块中声明的行为，在它被混合之后，对类和它的对象变得可用。</p><h1 id="bf46" class="lp lq in bd lr ls ni lu lv lw nj ly lz ma nk mc md me nl mg mh mi nm mk ml mm bi translated">目标</h1><p id="3473" class="pw-post-body-paragraph ka kb in kc b kd mn kf kg kh mo kj kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">短语“在 Ruby 中，一切都是对象！”在 Ruby 社区中经常听到。然而，这并不完全正确。任何可以说是有值的东西(比如数字、字符串、数组)在 Ruby 中都是对象，但是像方法、块和变量这样的东西不是。</p><p id="6221" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">类用于创建对象。把类看作模型，把对象看作模型的产品。尽管单个对象是同一个类的实例，但它们的信息与其他对象不同。</p><p id="abbd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里有两个<code class="fe ne nf ng nh b">String</code>类对象作为例子:</p><pre class="nn no np nq gt nr nh ns nt aw nu bi"><span id="2212" class="ms lq in nh b gy nv nw l nx ny"> irb :001 &gt; “hello”.class<br/> =&gt; String<br/> irb :002 &gt; “world”.class<br/> =&gt; String</span></pre><p id="f4cd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在前面的例子中，我们使用 class 实例方法来确定每个对象属于哪个类。如您所见，从字符串到整数，每个对象实际上都是从类实例化的对象。</p><h1 id="98aa" class="lp lq in bd lr ls ni lu lv lw nj ly lz ma nk mc md me nl mg mh mi nm mk ml mm bi translated">班级</h1><p id="e37a" class="pw-post-body-paragraph ka kb in kc b kd mn kf kg kh mo kj kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">Ruby 类定义了其对象的属性和行为。类可以被认为是一个对象应该由什么组成和应该有什么能力的基本轮廓。我们使用类似于定义方法的语法来定义一个类。为了创建名称，我们用<code class="fe ne nf ng nh b">class</code>替换<code class="fe ne nf ng nh b">def</code>，并使用 CamelCase 命名约定。然后使用保留字<code class="fe ne nf ng nh b">end</code>完成定义。Ruby 文件名应该在 snake_case 中，并且应该对应于类名。在下面的例子中，文件名是<code class="fe ne nf ng nh b">good_dog.rb</code>，类名是<code class="fe ne nf ng nh b">GoodDog</code>。</p><figure class="nn no np nq gt jo"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="1545" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在前面的例子中，我们创建了一个<code class="fe ne nf ng nh b">GoodDog</code>类的实例，并将其保存在变量<code class="fe ne nf ng nh b">sparky</code>中。我们现在有了一个对象。<code class="fe ne nf ng nh b">Sparky</code>是<code class="fe ne nf ng nh b">GoodDog</code>类的一个对象或实例。我们也可以说我们从类<code class="fe ne nf ng nh b">GoodDog</code>实例化了一个名为<code class="fe ne nf ng nh b">sparky</code>的对象。OOP 中的术语你会习惯的，但是这里要记住的重要一点是对象是通过调用类方法<code class="fe ne nf ng nh b">new</code>返回的。</p><h1 id="ebd9" class="lp lq in bd lr ls ni lu lv lw nj ly lz ma nk mc md me nl mg mh mi nm mk ml mm bi translated">模块</h1><p id="d357" class="pw-post-body-paragraph ka kb in kc b kd mn kf kg kh mo kj kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">如前所述，模块是在 Ruby 中实现多态性的另一种方式。模块是一组行为，可以通过混合在其他类中使用。<code class="fe ne nf ng nh b"> include</code>方法用于将一个模块“混合”到一个类中。假设我们想要一个<code class="fe ne nf ng nh b">speak</code>方法用于我们的<code class="fe ne nf ng nh b">GoodDog</code>类，但是我们也想要一个<code class="fe ne nf ng nh b">speak</code>方法用于其他类。</p><p id="621a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们是这样做的:</p><figure class="nn no np nq gt jo"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="a068" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">值得注意的是，在前面的例子中，我们称之为<code class="fe ne nf ng nh b">sparky</code>的<code class="fe ne nf ng nh b">GoodDog</code>对象和我们称之为<code class="fe ne nf ng nh b">bob</code>的<code class="fe ne nf ng nh b">HumanBeing</code>对象都可以访问<code class="fe ne nf ng nh b">speak</code>实例方法。这是通过“混合”模块<code class="fe ne nf ng nh b">Speak</code>完成的。就好像我们复制了<code class="fe ne nf ng nh b">speak</code>方法，并将其粘贴到<code class="fe ne nf ng nh b">GoodDog</code>和<code class="fe ne nf ng nh b">HumanBeing</code>类中。</p><h1 id="e4ca" class="lp lq in bd lr ls ni lu lv lw nj ly lz ma nk mc md me nl mg mh mi nm mk ml mm bi translated">摘要</h1><p id="1813" class="pw-post-body-paragraph ka kb in kc b kd mn kf kg kh mo kj kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">这是对 Ruby 中 OOP 的一个非常快速的概述。要记住的要点是，类就像模具，它们包含方法。这些模型可以实例化继承这些方法的对象。最后，如果我们想创建一个对许多类都可用的方法，我们可以创建一个模块并把它和类混合在一起。</p></div></div>    
</body>
</html>