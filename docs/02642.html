<html>
<head>
<title>How to Use Basic Authentication for Rest Template</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何对 Rest 模板使用基本身份验证</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-use-basic-authentication-for-rest-template-8a19e82e2c24?source=collection_archive---------10-----------------------#2020-08-17">https://blog.devgenius.io/how-to-use-basic-authentication-for-rest-template-8a19e82e2c24?source=collection_archive---------10-----------------------#2020-08-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="df50" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这篇文章中，我将展示如何使用 Rest 模板来使用受基本认证保护的 RESTful API。作为这篇文章的一部分，我将展示如何构建一个 REST API，用基本的身份验证来保护它。</p><h1 id="7f54" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">概观</h1><p id="34cb" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">基本身份验证是可以用来保护 REST API 的机制之一。在我之前的文章中，我展示了如何用<a class="ae ll" href="https://betterjavacode.com/java/securing-spring-boot-rest-api" rel="noopener ugc nofollow" target="_blank"> Json Web Token </a>保护 REST API。</p><h1 id="6816" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">使用基本身份验证保护 REST API</h1><h1 id="a8b4" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">配置一个 REST API</h1><p id="6b20" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">首先，我们将展示一个简单的 REST API 来创建用户或从数据库中检索用户。然后，我们将使用基本的身份验证机制来保护这个 REST API。最后，我们将展示如何使用 Rest 模板的基本认证来调用这个 REST API。</p><p id="4c6a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们为这个 API 创建或检索用户的 REST 控制器类如下所示:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="9946" class="lv kj in lr b gy lw lx l ly lz">package com.betterjavacode.restdemo.controllers;</span><span id="88c6" class="lv kj in lr b gy ma lx l ly lz">import com.betterjavacode.restdemo.dto.UserDto; <br/>import com.betterjavacode.restdemo.managers.UserManager; <br/>import org.springframework.beans.factory.annotation.Autowired; import org.springframework.http.HttpStatus; <br/>import org.springframework.http.MediaType; <br/>import org.springframework.http.ResponseEntity; <br/>import org.springframework.web.bind.annotation.*; <br/>import java.util.List; </span><span id="b83f" class="lv kj in lr b gy ma lx l ly lz">@RestController <br/>public class UserController <br/>{ </span><span id="467d" class="lv kj in lr b gy ma lx l ly lz">    @Autowired <br/>    private UserManager userManager; </span><span id="eb7b" class="lv kj in lr b gy ma lx l ly lz">    @RequestMapping(value = "/user/", method = RequestMethod.GET)<br/>    public ResponseEntity&gt; listAllUsers() <br/>    { <br/>       List users = userManager.getAllUsers(); <br/>       if(users.isEmpty()) <br/>       { <br/>           return new ResponseEntity&gt;(HttpStatus.NO_CONTENT); <br/>       }<br/>       return new ResponseEntity&lt;&gt;(users, HttpStatus.OK); <br/>    }</span><span id="c874" class="lv kj in lr b gy ma lx l ly lz">    @RequestMapping(value = "/user/{id}", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE) <br/>    public ResponseEntity getUser(@PathVariable("id") long id) <br/>    { <br/>       UserDto userDto = userManager.getUser(id); <br/>       if(userDto == null) <br/>       { <br/>          return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND); <br/>       } <br/>       return new ResponseEntity&lt;&gt;(userDto, HttpStatus.OK); <br/>    } </span><span id="e3d7" class="lv kj in lr b gy ma lx l ly lz">    @RequestMapping(value = "/user/", method= RequestMethod.POST) <br/>    public ResponseEntity createUser(@RequestBody UserDto userDto)<br/>    { <br/>       UserDto user = userManager.createUser(userDto); <br/>       return new ResponseEntity&lt;&gt;(user, HttpStatus.OK); <br/>    } </span><span id="53e0" class="lv kj in lr b gy ma lx l ly lz">    @RequestMapping(value = "/user/{id}", method=RequestMethod.DELETE) <br/>    public ResponseEntity deleteUser(@PathVariable("id") long id) <br/>    { <br/>       UserDto user = userManager.getUser(id); <br/>       if(user == null) <br/>       { <br/>          return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND); <br/>       } <br/>       userManager.deleteUser(id); return new ResponseEntity&lt;&gt;(HttpStatus.NO_CONTENT); <br/>    } <br/>}</span></pre><p id="f771" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的用户数据库模型类如下所示:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="3788" class="lv kj in lr b gy lw lx l ly lz">package com.betterjavacode.restdemo.models; </span><span id="2eea" class="lv kj in lr b gy ma lx l ly lz">import javax.persistence.*; <br/>import java.io.Serializable; </span><span id="8a56" class="lv kj in lr b gy ma lx l ly lz">@Entity(name = "User") <br/>@Table(name = "users") <br/>public class User implements Serializable <br/>{ </span><span id="8fb2" class="lv kj in lr b gy ma lx l ly lz">   private static final long serialVersionUID = 20200816121023L;<br/>   public User() { } </span><span id="e826" class="lv kj in lr b gy ma lx l ly lz">   @Id <br/>   @GeneratedValue(strategy = GenerationType.IDENTITY) <br/>   @Column(name="id", nullable=false) <br/>   private long id; </span><span id="d5b7" class="lv kj in lr b gy ma lx l ly lz">   @Column(name="firstname", length=100) <br/>   private String firstname; </span><span id="c1d5" class="lv kj in lr b gy ma lx l ly lz">   @Column(name="lastname", length=100) <br/>   private String lastname; </span><span id="6312" class="lv kj in lr b gy ma lx l ly lz">   @Column(name="email", length=100) <br/>   private String email; </span><span id="91f6" class="lv kj in lr b gy ma lx l ly lz">   @Column(name="role", length=45) <br/>   private String role; </span><span id="c90a" class="lv kj in lr b gy ma lx l ly lz">   @Column(name="enabled") <br/>   private boolean enabled; </span><span id="f5c8" class="lv kj in lr b gy ma lx l ly lz">   public long getId () { return id; } </span><span id="446e" class="lv kj in lr b gy ma lx l ly lz">   public void setId (long id) { this.id = id; }</span><span id="9dd4" class="lv kj in lr b gy ma lx l ly lz">   public String getFirstname () { return firstname; } </span><span id="1fff" class="lv kj in lr b gy ma lx l ly lz">   public void setFirstname (String firstname) <br/>   { <br/>     this.firstname = firstname; <br/>   } </span><span id="5fd2" class="lv kj in lr b gy ma lx l ly lz">   public String getLastname () <br/>   { <br/>     return lastname; <br/>   } <br/>   <br/>   public void setLastname (String lastname) <br/>   { <br/>     this.lastname = lastname; <br/>   } </span><span id="b082" class="lv kj in lr b gy ma lx l ly lz">   public String getEmail () <br/>   { <br/>     return email;  <br/>   } </span><span id="67f1" class="lv kj in lr b gy ma lx l ly lz">   public void setEmail (String email) <br/>   { <br/>     this.email = email; <br/>   } </span><span id="9480" class="lv kj in lr b gy ma lx l ly lz">   public String getRole () <br/>   { <br/>     return role; <br/>   } </span><span id="dc87" class="lv kj in lr b gy ma lx l ly lz">   public void setRole (String role) <br/>   { <br/>     this.role = role; <br/>   } <br/>   <br/>   public boolean isEnabled () <br/>   { <br/>     return enabled; <br/>   } </span><span id="66e3" class="lv kj in lr b gy ma lx l ly lz">   public void setEnabled (boolean enabled) <br/>   { <br/>     this.enabled = enabled; <br/>   } <br/>}</span></pre><p id="68da" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了确保我们理解了这一点，我们使用 DTO 对象<code class="fe mb mc md lr b">UserDto</code>来创建和检索数据库中的数据。<code class="fe mb mc md lr b">User</code>是我们的数据库模型对象。</p><p id="5e0a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mb mc md lr b">UserDto</code>的对象将如下:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="d282" class="lv kj in lr b gy lw lx l ly lz">package com.betterjavacode.restdemo.dto; </span><span id="aed1" class="lv kj in lr b gy ma lx l ly lz">import com.betterjavacode.restdemo.models.User; <br/>import com.fasterxml.jackson.annotation.JsonIgnoreProperties; </span><span id="68eb" class="lv kj in lr b gy ma lx l ly lz">@JsonIgnoreProperties(ignoreUnknown = true) <br/>public class UserDto <br/>{ </span><span id="6629" class="lv kj in lr b gy ma lx l ly lz">   private String firstname; <br/>   private String lastname; <br/>   private String email; <br/>   public UserDto(){} <br/>   public UserDto(User user) <br/>   { <br/>     this.setEmail(user.getEmail());    <br/>     this.setFirstname(user.getFirstname()); <br/>     this.setLastname(user.getLastname()); <br/>   } </span><span id="8cd4" class="lv kj in lr b gy ma lx l ly lz">   public String getFirstname () <br/>   { <br/>     return firstname; <br/>   } </span><span id="e8bd" class="lv kj in lr b gy ma lx l ly lz">   public void setFirstname (String firstname) <br/>   { <br/>     this.firstname = firstname; <br/>   } </span><span id="a456" class="lv kj in lr b gy ma lx l ly lz">   public String getLastname () <br/>   { <br/>     return lastname; <br/>   } <br/>   <br/>   public void setLastname (String lastname) <br/>   { <br/>     this.lastname = lastname; <br/>   } </span><span id="b7ca" class="lv kj in lr b gy ma lx l ly lz">   public String getEmail () <br/>   { <br/>     return email; <br/>   } </span><span id="bbbe" class="lv kj in lr b gy ma lx l ly lz">   public void setEmail (String email) <br/>   { <br/>     this.email = email; <br/>   }</span><span id="2584" class="lv kj in lr b gy ma lx l ly lz">}</span></pre><p id="aadb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦我们配置了应用程序属性并创建了所需的数据库表，我们将启动应用程序。</p><p id="e7b3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，如果我们通过像 Postman 这样的客户端执行 API，我们将能够检索或创建用户对象。</p><p id="5abc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">目标是保护这个 API。</p><p id="3c2e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以在我们的项目构建中添加<code class="fe mb mc md lr b">Spring-Security</code>。</p><p id="98e3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mb mc md lr b">implementation "org.springframework.boot:spring-boot-starter-security"</code></p><p id="68e0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，如果我们在主应用程序类中添加注释<code class="fe mb mc md lr b">@EnableWebSecurity</code>，如下所示:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="5c2f" class="lv kj in lr b gy lw lx l ly lz">package com.betterjavacode.restdemo; <br/>import org.springframework.boot.SpringApplication; <br/>import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; </span><span id="2403" class="lv kj in lr b gy ma lx l ly lz">@SpringBootApplication <br/>@EnableWebSecurity <br/>public class RestdemoApplication <br/>{ <br/>  public static void main(String[] args) <br/>  { <br/>    SpringApplication.run(RestdemoApplication.class, args); <br/>  } <br/>}</span></pre><p id="e182" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们访问 API 来创建用户，我们将得到如下所示的<code class="fe mb mc md lr b">401 unauthorized</code>错误:</p><figure class="lm ln lo lp gt mf gh gi paragraph-image"><div class="gh gi me"><img src="../Images/ca037a4d866726ad00d1791028ad02bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*X7KYbL_GI1xG321N"/></div></figure><h1 id="fac6" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">基本认证</h1><p id="7377" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">传统上，一旦用户使用身份验证登录，对 REST API 的访问将发生在服务器端。</p><p id="f0b1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">基本身份验证提供了保护 REST API 的方法之一。与基于 OAuth 或 JWT 的安全性相比，这不是最安全的方式。在基本身份验证中，客户端使用<strong class="jm io"> HTTP 授权头</strong>在每个请求中发送<strong class="jm io"> Base64 编码的凭证</strong>。</p><p id="4718" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">客户端将在每个请求中发送授权头。即使这些凭据是 Base64 编码的，也总是有可能泄露它们。为了避免这种情况，我们可以使用 HTTPS。</p><p id="5952" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在从我们的实现角度来看，我们将添加一个<code class="fe mb mc md lr b">SecurityConfig</code>类来配置 REST API 的安全性。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="58d3" class="lv kj in lr b gy lw lx l ly lz">package com.betterjavacode.restdemo; </span><span id="c0a9" class="lv kj in lr b gy ma lx l ly lz">import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Configuration; <br/>import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder; <br/>import org.springframework.security.config.annotation.web.builders.HttpSecurity; <br/>import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; <br/>import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; </span><span id="c136" class="lv kj in lr b gy ma lx l ly lz">@Configuration <br/>@EnableWebSecurity <br/>public class SecurityConfig extends WebSecurityConfigurerAdapter <br/>{ <br/>   @Override <br/>   protected void configure(HttpSecurity httpSecurity) throws Exception <br/>   { <br/>      httpSecurity .csrf().disable() .authorizeRequests().anyRequest().authenticated() .and() .httpBasic(); <br/>   } </span><span id="a591" class="lv kj in lr b gy ma lx l ly lz">    @Autowired <br/>    public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception <br/>    { <br/>       auth.inMemoryAuthentication() .withUser("adminuser") .password("{noop}adminpassword") .roles("USER"); <br/>     } <br/>}</span></pre><p id="db81" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个类中的方法将配置基本认证，并且每个到达我们控制器的请求都需要被授权。</p><p id="8a3d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mb mc md lr b">configureGlobal</code>方法将添加对传入请求的身份验证。来自控制器的请求将针对我们为内存中身份验证配置的这些凭证进行验证。</p><p id="222c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mi">警告——这不是保护您的 API 的最安全的方式。肯定不是通过内存中的身份验证。不要在生产中使用它。</em></p><p id="8f07" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，如果我们通过 POSTMAN 执行 REST API，我们将看到如下成功响应:</p><figure class="lm ln lo lp gt mf gh gi paragraph-image"><div class="gh gi me"><img src="../Images/0817b4d975ef918e171ab66106e4422e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*47QEtMKF_lBEnIYg"/></div></figure><h1 id="b8c8" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">带有基本认证示例的 Rest 模板</h1><p id="8ebb" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">最初，我们使用 POSTMAN 作为客户端来调用我们的 REST APIs。但是在真实的场景中，我们不会使用 POSTMAN，您将必须以编程方式调用这些 API。</p><p id="d369" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将创建一个类<code class="fe mb mc md lr b">RestClient</code>，它将在构建基本认证时调用我们的 API。</p><p id="79ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用 Spring Boot 提供的<code class="fe mb mc md lr b">RestTemplate</code>时，你需要用一个<code class="fe mb mc md lr b">RequestEntity</code>通过<code class="fe mb mc md lr b">HttpHeaders</code>。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="0f79" class="lv kj in lr b gy lw lx l ly lz">private static HttpHeaders getHeaders () <br/>{ <br/>   String adminuserCredentials = "adminuser:adminpassword"; <br/>   String encodedCredentials = new String(Base64.encodeBase64(adminuserCredentials.getBytes())); <br/>   HttpHeaders httpHeaders = new HttpHeaders();   <br/>   httpHeaders.add("Authorization", "Basic " + encodedCredentials); <br/>   httpHeaders.setAccept(Arrays.asList(MediaType.APPLICATION_JSON)); <br/>   return httpHeaders; <br/>}</span></pre><p id="867f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们使用来自<code class="fe mb mc md lr b">RestTemplate</code>的<code class="fe mb mc md lr b">exchange</code>方法来调用包含基本认证的 API 和<code class="fe mb mc md lr b">HttpHeaders</code>。</p><p id="48b1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">整个班级<code class="fe mb mc md lr b">RestClient</code>将会如下图所示:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="f7b1" class="lv kj in lr b gy lw lx l ly lz">package com.betterjavacode.restdemo; </span><span id="2505" class="lv kj in lr b gy ma lx l ly lz">import com.betterjavacode.restdemo.dto.UserDto; <br/>import org.apache.tomcat.util.codec.binary.Base64; <br/>import org.json.JSONObject; <br/>import org.springframework.http.*; <br/>import org.springframework.web.client.RestTemplate; <br/>import java.util.Arrays; <br/>import java.util.LinkedHashMap; <br/>import java.util.List; </span><span id="6452" class="lv kj in lr b gy ma lx l ly lz">public class RestClient <br/>{ <br/>   public static final String REST_SERVICE_URL = "http://localhost:8080/user/"; <br/>   private static HttpHeaders getHeaders () <br/>   { <br/>      String adminuserCredentials = "adminuser:adminpassword"; <br/>     String encodedCredentials = new String(Base64.encodeBase64(adminuserCredentials.getBytes())); <br/>     HttpHeaders httpHeaders = new HttpHeaders(); <br/>     httpHeaders.add("Authorization", "Basic " + encodedCredentials); <br/>   httpHeaders.setAccept(Arrays.asList(MediaType.APPLICATION_JSON)); <br/>     return httpHeaders; <br/>   } <br/>   private static void listAllUsers() <br/>   { <br/>     System.out.println("Getting all users"); <br/>     RestTemplate restTemplate = new RestTemplate(); <br/>     HttpHeaders httpHeaders = getHeaders(); <br/>     HttpEntity httpEntity = new HttpEntity&lt;&gt;(httpHeaders);<br/>     ResponseEntity responseEntity = restTemplate.exchange(REST_SERVICE_URL, HttpMethod.GET, httpEntity, List.class); <br/>     if(responseEntity.hasBody()) <br/>     { <br/>        List users = responseEntity.getBody(); <br/>        if(users != null) <br/>        { <br/>           for(LinkedHashMap userMap: users) <br/>           { <br/>              System.out.println("User is " + userMap.get("firstname") + " " + userMap.get( "lastname")); <br/>           } <br/>        } <br/>      } <br/>      else <br/>      { <br/>        System.out.println("User not found"); <br/>      } <br/>    } <br/>    public static void main (String[] args) <br/>    { <br/>      listAllUsers(); getUser(1); <br/>    } <br/>    private static void getUser(long id) <br/>    { <br/>      System.out.println("Getting a user "); <br/>      String restUrl = REST_SERVICE_URL + id; <br/>      RestTemplate restTemplate = new RestTemplate(); <br/>      HttpHeaders httpHeaders = getHeaders(); <br/>      HttpEntity httpEntity = new HttpEntity&lt;&gt;(httpHeaders); <br/>      ResponseEntity responseEntity = restTemplate.exchange(restUrl, HttpMethod.GET, httpEntity, String.class); <br/>      if(responseEntity.hasBody()) <br/>      { <br/>        JSONObject jsonObject = new JSONObject(responseEntity.getBody()); <br/>        System.out.println(jsonObject.get("firstname")); <br/>        System.out.println(jsonObject.get("lastname")); <br/>      } <br/>      else <br/>      { <br/>        System.out.println("User not found"); <br/>      } <br/>    } <br/>}</span></pre><p id="bb85" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，如果我们执行该程序，我们将看到如下输出:</p><figure class="lm ln lo lp gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi me"><img src="../Images/0a3c1a1e67e58d4d09a1b07174260367.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*ovvwsVGsFmTuXoON"/></div></div></figure><p id="b749" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这篇文章中，我们展示了如何使用基本认证来保护 REST API。如果你喜欢这篇文章，在这里订阅我的博客<a class="ae ll" href="https://betterjavacode.com/subscribe" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="5507" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你想知道春季安全的根本吗？我将很快推出我的新书“简化 Spring 安全”。进入我的发布列表以获取更新和折扣代码。</p><h1 id="e172" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">参考</h1><ol class=""><li id="be32" class="mn mo in jm b jn lg jr lh jv mp jz mq kd mr kh ms mt mu mv bi translated">弹簧座模板— <a class="ae ll" href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html" rel="noopener ugc nofollow" target="_blank">文档</a></li><li id="8365" class="mn mo in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated">Spring Boot 休息模板— <a class="ae ll" href="https://www.tutorialspoint.com/spring_boot/spring_boot_rest_template.htm" rel="noopener ugc nofollow" target="_blank">用途</a></li></ol></div><div class="ab cl nb nc hr nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ig ih ii ij ik"><p id="72cc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mi">原载于 2020 年 8 月 17 日 https://betterjavacode.com</em><em class="mi">的</em> <a class="ae ll" href="https://betterjavacode.com/programming/how-to-use-basic-authentication-for-rest-template" rel="noopener ugc nofollow" target="_blank"> <em class="mi">。</em></a></p></div></div>    
</body>
</html>