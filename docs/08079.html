<html>
<head>
<title>Async/Await in NodeJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NodeJS 中的异步/等待</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/async-await-in-nodejs-644c6f55b19?source=collection_archive---------12-----------------------#2022-05-15">https://blog.devgenius.io/async-await-in-nodejs-644c6f55b19?source=collection_archive---------12-----------------------#2022-05-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/1cb01a5a9b84638c5a54cb058bbf89e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qt4y1yd91ESbhckX.png"/></div></div></figure><p id="ba78" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这篇文章中，我们将学习如何用 async/await 简化基于回调或承诺的 NodeJS 应用程序。如果你想阅读 NodeJS 中的承诺，那么请阅读我之前的帖子<a class="ae kt" href="https://krp-ajay.medium.com/promise-in-nodejs-d8db90fcdd48" rel="noopener">这里</a>。</p><h2 id="bc9d" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated"><strong class="ak">NodeJS 中的异步函数是什么？</strong></h2><p id="2481" class="pw-post-body-paragraph jv jw in jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">异步函数本身在 NodeJS 中可用，并且用 Async 关键字声明。Async 总是返回一个承诺，即使你没有明确地写他们这样做。另外，await 关键字目前只在异步函数中可用— <strong class="jx io">它不能在全局作用域</strong>中使用。</p><p id="bb2b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">异步/等待的好处是什么</p><ol class=""><li id="fe0a" class="ls lt in jx b jy jz kc kd kg lu kk lv ko lw ks lx ly lz ma bi translated">它允许我们在异步函数中使用 await 关键字。如果没有 async 关键字，等待它被视为错误</li><li id="0561" class="ls lt in jx b jy mb kc mc kg md kk me ko mf ks lx ly lz ma bi translated">它允许异步函数返回承诺</li></ol><p id="2dc2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Promise/async/await/Normal JS 函数示例以下三个函数 a、b、c 都是相同的</p><pre class="mg mh mi mj gt mk ml mm bn mn mo bi"><span id="0c18" class="mp kv in ml b be mq mr l ms mt">/**<br/> * @returns {Promise&lt;string&gt;}<br/> */<br/>function a() {<br/>    return Promise.resolve('a');<br/>}<br/>async function b() {<br/>    return Promise.resolve('b');<br/>}<br/><br/>async function c() {<br/>    return 'c';<br/>}<br/>console.log(a());<br/>console.log(b());<br/>console.log(c());</span></pre><h2 id="2e98" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated"><strong class="ak">异步/等待之间的差异&amp;承诺</strong></h2><p id="618e" class="pw-post-body-paragraph jv jw in jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">作为承诺，我们必须写信。然后用回调函数，但在异步等待中，我们可以简单地摆脱。然后函数(。然后被 await 替换)。</p><pre class="mg mh mi mj gt mk ml mm bn mn mo bi"><span id="82ac" class="mp kv in ml b be mq mr l ms mt">let run = async () =&gt; {<br/>    // Promise version of code<br/>    read('../dir/file1.txt')<br/>        .then(data =&gt; {<br/>        console.log(data.toString());<br/>    }).catch(err =&gt; {<br/>        console.log(err)<br/>    })<br/><br/>    // Async/Await version<br/>    const data = await read('../dir/file1.txt');<br/>    console.log(data.toString());<br/><br/>    // Async-Await version of reading multiple files<br/>    const [data1, data2, data3] = await Promise.all([<br/>        read('../dir/file1.txt'),<br/>        read('../dir/file2.txt'),<br/>        read('../dir/file3.txt')<br/>    ])<br/><br/>    console.log(data1.toString());<br/>    console.log(data2.toString());<br/>    console.log(data3.toString());<br/>}<br/><br/>run()</span></pre><p id="bd07" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们使用 async/await 时，我们很少需要。然后，因为 await 处理等待我们。</p><h2 id="0ca9" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">异步等待中的错误处理</h2><p id="7605" class="pw-post-body-paragraph jv jw in jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">如果承诺正常解析，那么 wait promise 返回结果。但是在拒绝的情况下，它抛出错误，就像在那一行有一个 throw 语句一样。下面的代码片段和</p><pre class="mg mh mi mj gt mk ml mm bn mn mo bi"><span id="67db" class="mp kv in ml b be mq mr l ms mt">async function getData() {<br/>  return Promise.reject(new Error("New Error!"));<br/>}</span></pre><p id="e678" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些代码片段是相同</p><pre class="mg mh mi mj gt mk ml mm bn mn mo bi"><span id="0f98" class="mp kv in ml b be mq mr l ms mt">async function getData() {<br/>  return new Error("New Error!");<br/>}</span></pre><p id="f476" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以使用 try 来捕捉这个错误..接球，和普通投掷的方式一样。如果出现错误，控件将跳转到 catch 块。</p><pre class="mg mh mi mj gt mk ml mm bn mn mo bi"><span id="5864" class="mp kv in ml b be mq mr l ms mt">async function getData() {<br/><br/>  try {<br/>    let response = await fetch('http://someurl');<br/>  } catch (err) {<br/>    // Error!<br/>    alert(err); <br/>  }<br/>}<br/><br/>getData();</span></pre><p id="bfac" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们不去尝试..catch，那么调用异步函数 f()生成的承诺将被拒绝。我们可以追加。接住来处理它:</p><pre class="mg mh mi mj gt mk ml mm bn mn mo bi"><span id="a79c" class="mp kv in ml b be mq mr l ms mt">async function getData() {<br/>  let response = await fetch('http://someurl');<br/>}<br/><br/>// getData() becomes a rejected promise<br/>getData().catch(alert); // Error!</span></pre><p id="d820" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们忘记添加。捕捉那里，然后我们得到一个未处理的承诺错误(在控制台中可见)。我们可以使用全局 unhandledrejection 事件处理程序来捕捉这样的错误。</p><p id="16f8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是我在 async/await 上要分享的全部内容。如果你有更多的观点要分享，请在下面评论。它将帮助我和其他人获得更多关于 async/await 的知识。感谢阅读。请关注支持和更多这样的内容。</p><p id="4ad2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你喜欢这篇文章吗？如果有，通过<a class="ae kt" href="https://www.youtube.com/channel/UCvEB7wXUEXGFE9lCx0USR3Q" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">订阅获取更多类似内容解码，我们的 YouTube 频道</strong> </a> <strong class="jx io">！</strong></p><p id="fe25" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注:更多精彩内容还可登陆<a class="ae kt" href="https://ajaykrp.me/" rel="noopener ugc nofollow" target="_blank"> https://ajaykrp.me </a>。请检查一下。</p></div></div>    
</body>
</html>