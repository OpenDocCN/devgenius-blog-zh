<html>
<head>
<title>VIPs (very important pods) in Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes的VIP(非常重要的豆荚)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/hardening-your-kubernetes-stack-pt-2-2f2db4ff410d?source=collection_archive---------5-----------------------#2020-07-29">https://blog.devgenius.io/hardening-your-kubernetes-stack-pt-2-2f2db4ff410d?source=collection_archive---------5-----------------------#2020-07-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="5991" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">Pod服务质量和Pod优先级</h2></div><p id="9b6b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">强化Kubernetes (k8s)堆栈的一部分是确保关键应用程序优先于不太关键的应用程序。K8s提供了几种方法来实现这一点。通过利用pod服务质量和pod优先级，您可以分别控制如何终止和调度pod。这是上一篇强化文章的延续:<a class="ae ky" href="https://medium.com/dev-genius/hardening-your-kubernetes-stack-pt-1-29b7006b5085" rel="noopener">https://medium . com/dev-genius/hardening-your-kubernetes-stack-pt-1-29b 7006 b 5085</a></p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi kz"><img src="../Images/63c9bcb3e496c9583451d5c1a83d15dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*900_1io6RnbBmIGf"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@edvardr?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Edvard Alexander lvaag</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h2 id="3ae7" class="lp lq in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">服务质量(QoS)</h2><p id="f51e" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">当节点接近或已经达到资源耗尽时，Pod QoS提供了关于如何杀死Pod的某些保证和排序。在k8s中，有两种类型的资源，不可压缩或可压缩。可压缩资源是k8s可以对其创建约束的资源。这个时候我们只能用CPU做到这一点。正如我在我的<a class="ae ky" href="https://medium.com/dev-genius/hardening-your-kubernetes-stack-pt-1-29b7006b5085" rel="noopener">上一篇文章</a>中提到的，你不能违反CPU限制，因为CPU限制本质上是时间片，你不能过度分配这些时间片。然而，与CPU不同，内存和磁盘空间在k8s中是不可压缩的资源，因此为了保护节点，k8s需要在节点耗尽资源时消除工作负载。pod被淘汰的顺序和优先级基于QoS等级。K8s根据pod的资源请求和限制来确定pod的QoS等级。它由3个类指定。</p><h2 id="aab4" class="lp lq in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">担保</h2><p id="b49e" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">这个类意味着pod保证不会被杀死，直到它们超过它们的极限。为了让一个pod接收保证等级，您必须为该pod中的每个容器设置请求和限制。除此之外，每个容器的请求必须符合限制。最简单的方法是设置没有请求的限制，因为k8s会默认pod的请求限制。</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="4c57" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意第一个容器echoserver是如何为两个容器定义请求和限制的，请求和限制值是相同的。第二个容器echoserver2只定义了限制，也可以工作。最后，由于pod内的所有容器都满足要求，所以pod将被分类为保证的。</p><h2 id="fd09" class="lp lq in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">可爆发的</h2><p id="3269" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">这个类意味着pod有最小的资源保证，但是如果需要并且节点有资源，它可以获得更多的资源。当存在内存压力时，如果超出请求，它们可能会被杀死。这发生在杀死BestEffort类豆荚之后。当为pod中的一个或多个容器设置了请求和可选限制，并且它们不满足保证的标准时，pod被分配此类。</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="6c11" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意，第一次部署有两个容器。你不需要匹配请求和限制。第二次部署我们只为容器定义了请求，这也很好。</p><h2 id="c096" class="lp lq in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">尽力而为</h2><p id="02a8" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">它们被视为最低优先级。如果节点内存不足，这些pod将首先被终止。当没有设置请求或限制时，pod被分配此类。</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="mn mo l"/></div></figure><h2 id="7388" class="lp lq in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">摘要</h2><p id="9931" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">当节点面临资源压力时，k8s会通过杀死节点上运行的pod来试图缓解。我们可以通过利用服务质量等级来确保按照优先级顺序终止某些pod。K8s通过如何设置资源请求和限制来确定这些类别。优先级保证&gt;突发&gt;尽力而为。我在本文开头提到磁盘空间是一种不可压缩的资源，但是它不是一种可以在pod级别指定的资源，因此我们没有包括磁盘定义。</p><p id="eed7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae ky" href="https://medium.com/google-cloud/quality-of-service-class-qos-in-kubernetes-bb76a89eb2c6" rel="noopener">来自谷歌</a>关于QoS的更多信息和<a class="ae ky" href="https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/" rel="noopener ugc nofollow" target="_blank">官方文档</a></p><h2 id="cf98" class="lp lq in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">Pod优先级和先占权</h2><p id="1ce7" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">Pod优先级和抢占控制着pod的调度方面。该功能需要创建一个资源调用<a class="ae ky" href="https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/#priorityclass" rel="noopener ugc nofollow" target="_blank">优先级类别</a>。优先级类定义了pods可以继承的值和类名。</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="1718" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">值可以是小于或等于10亿的任何32位整数。数字越大，它们就越重要。注意这一点，因为可能有系统关键的应用程序以更高的值运行，不应该被工作负载应用程序抢占，请检查您的集群的操作员。在您的集群中，默认情况下还有优先级类，您将看到有2个默认类，系统集群关键和系统节点关键，它们的值分别为20亿和20亿1千。正如你所看到的，k8也利用这一点为自己的资源。K8s通过将这些资源设置为不可能的高值来控制它们。</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="7a7f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如上例所示(第10行),通过设置<code class="fe mp mq mr ms b">priorityClassName: {priorityclassname}</code>为pod分配优先级。</p><p id="bd38" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在pod调度期间，pod被添加到调度队列中。在队列中，优先级值较高的单元将被放在优先级值较低的单元之前。默认情况下，所有没有优先级的pod都被赋予值0，除非设置了优先级<code class="fe mp mq mr ms b">globalDefault: true</code>，则默认值将被设置为该优先级的值。</p><h2 id="6f4c" class="lp lq in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">先占</h2><p id="fa03" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">默认情况下，还会为所有优先级启用抢占。当具有高优先级的pod待定并且没有可用节点时，k8s将尝试从节点中移除一个或多个具有较低优先级的pod，以便调度待定的高优先级pod。可以通过在优先级上设置<code class="fe mp mq mr ms b">PreemptionPolicy: Never</code>来禁用抢占。因为具有这些类的pod不会抢占在节点上运行的pod，所以它们会受到调度回退的影响。这意味着，如果一个pod不能被调度，它们将会以指数后退的方式重试。这将允许具有可能较低优先级的其他单元在较高优先级单元之前被调度。</p><h2 id="78cf" class="lp lq in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated"><strong class="ak">总结</strong></h2><p id="6ee1" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">您可以为pod创建优先级类别，以便控制调度pod的优先级。您可以通过检查每个优先级类的值来确定顺序。您也可以通过设置<code class="fe mp mq mr ms b">globalDefault: true</code>为所有没有优先级的pod创建一个全局默认优先级。默认情况下，如果k8s不能调度高优先级pod，则较高优先级等级的pod将抢占节点上较低优先级的pod。您可以通过在优先级上设置<code class="fe mp mq mr ms b">PreemptionPolicy: Never</code>来关闭此功能。</p><p id="3a69" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae ky" href="https://medium.com/dev-genius/hardening-your-kubernetes-stack-pt-1-29b7006b5085" rel="noopener">第1部分:资源请求和限制</a> <br/> <a class="ae ky" href="https://medium.com/dev-genius/hardening-your-kubernetes-stack-pt-3-b260d45fe6e" rel="noopener">第3部分:滚动更新和Pod中断预算</a> <br/> <a class="ae ky" href="https://medium.com/dev-genius/hardening-your-kubernetes-stack-pt-4-cc72b09b4557" rel="noopener">第4部分:水平Pod自动缩放和集群自动缩放</a></p></div></div>    
</body>
</html>