<html>
<head>
<title>PHP — P101: trim, htmlspecialchars and __call Built-In Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PHP — P101: trim、htmlspecialchars 和 __call 内置函数</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/php-p101-trim-htmlspecialchars-and-call-built-in-functions-7b4f25728db9?source=collection_archive---------11-----------------------#2022-11-26">https://blog.devgenius.io/php-p101-trim-htmlspecialchars-and-call-built-in-functions-7b4f25728db9?source=collection_archive---------11-----------------------#2022-11-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f729ac54f3f9157a1fc6fbc42fac864c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*81C_zQcKPXLoHoh49U3x5w.jpeg"/></div></div></figure><p id="1a15" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在过去的 100 篇 PHP 文章中，我们使用了各种内置函数。是时候把它们收集到一个地方，给出几个例子，并添加我可能遗漏的其他例子。你可能会问什么是内置函数。这只是 PHP 安装自带的一个功能。你不必知道他们在哪里。你不必实例化一个对象。它们在全球都有售。</p><p id="f288" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们要看的函数如下:</p><ul class=""><li id="ed72" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><code class="fe lf lg lh li b"><strong class="ka ir">trim(),</strong></code><strong class="ka ir"/><code class="fe lf lg lh li b"><strong class="ka ir">ltrim()</strong></code><strong class="ka ir"/><code class="fe lf lg lh li b"><strong class="ka ir">rtrim()</strong></code></li><li id="0a2c" class="kw kx iq ka b kb lj kf lk kj ll kn lm kr ln kv lb lc ld le bi translated"><code class="fe lf lg lh li b"><strong class="ka ir">htmlspecialchars()</strong></code></li><li id="7160" class="kw kx iq ka b kb lj kf lk kj ll kn lm kr ln kv lb lc ld le bi translated"><code class="fe lf lg lh li b"><strong class="ka ir">__call()</strong></code></li><li id="d6af" class="kw kx iq ka b kb lj kf lk kj ll kn lm kr ln kv lb lc ld le bi translated"><code class="fe lf lg lh li b">preg_match()</code></li><li id="9662" class="kw kx iq ka b kb lj kf lk kj ll kn lm kr ln kv lb lc ld le bi translated"><code class="fe lf lg lh li b">filter_var()</code></li><li id="0905" class="kw kx iq ka b kb lj kf lk kj ll kn lm kr ln kv lb lc ld le bi translated"><code class="fe lf lg lh li b">addslashes()</code></li><li id="a3f9" class="kw kx iq ka b kb lj kf lk kj ll kn lm kr ln kv lb lc ld le bi translated"><code class="fe lf lg lh li b">str_replace()</code></li><li id="36f7" class="kw kx iq ka b kb lj kf lk kj ll kn lm kr ln kv lb lc ld le bi translated"><code class="fe lf lg lh li b">strlen()</code></li><li id="669c" class="kw kx iq ka b kb lj kf lk kj ll kn lm kr ln kv lb lc ld le bi translated"><code class="fe lf lg lh li b">strtolower()</code></li><li id="dc7d" class="kw kx iq ka b kb lj kf lk kj ll kn lm kr ln kv lb lc ld le bi translated"><code class="fe lf lg lh li b">strtoupper()</code></li><li id="5826" class="kw kx iq ka b kb lj kf lk kj ll kn lm kr ln kv lb lc ld le bi translated"><code class="fe lf lg lh li b">ucfirst()</code></li><li id="6083" class="kw kx iq ka b kb lj kf lk kj ll kn lm kr ln kv lb lc ld le bi translated"><code class="fe lf lg lh li b">strpos()</code>、<code class="fe lf lg lh li b">stripos()</code>、<code class="fe lf lg lh li b">strrpos()</code>、<code class="fe lf lg lh li b">strripos()</code></li><li id="d52b" class="kw kx iq ka b kb lj kf lk kj ll kn lm kr ln kv lb lc ld le bi translated">数组函数有:<code class="fe lf lg lh li b">array_chunk()</code>、<code class="fe lf lg lh li b">array_diff()</code>、<code class="fe lf lg lh li b">array_key_exists()</code>、<code class="fe lf lg lh li b">array_key_first()</code>、<code class="fe lf lg lh li b">array_key_last()</code>、<code class="fe lf lg lh li b">array_map()</code>、<code class="fe lf lg lh li b">array_merge()</code>、<code class="fe lf lg lh li b">array_push()</code>、<code class="fe lf lg lh li b">array_sum()</code>、<code class="fe lf lg lh li b">asort()</code>、<code class="fe lf lg lh li b">arsort()</code>、<code class="fe lf lg lh li b">count()</code>、<code class="fe lf lg lh li b">in_array()</code>、<code class="fe lf lg lh li b">ksort()</code>、<code class="fe lf lg lh li b">krsort()</code>、<code class="fe lf lg lh li b">sort()</code>、<code class="fe lf lg lh li b">rsort()</code>、<code class="fe lf lg lh li b">shuffle()</code>、<code class="fe lf lg lh li b">sizeof()</code>、<code class="fe lf lg lh li b">is_array()</code>、<code class="fe lf lg lh li b">explode()</code>、<code class="fe lf lg lh li b">implode()</code></li><li id="e34a" class="kw kx iq ka b kb lj kf lk kj ll kn lm kr ln kv lb lc ld le bi translated">魔术方法有:<code class="fe lf lg lh li b">__invoke()</code>，<code class="fe lf lg lh li b">__toString()</code></li></ul><p id="d026" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">没有韵律或理由。我们先浏览一下名单。</p><h1 id="bcf1" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">trim()，ltrim()，rtrim()</h1><p id="bde8" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">这些是“修剪”或删除空格的字符串操作。<code class="fe lf lg lh li b">trim()</code>函数删除两边的空格；<code class="fe lf lg lh li b">ltrim()</code>仅删除字符串左侧的空白；<code class="fe lf lg lh li b">rtrim()</code>仅删除右侧的空白。这些函数都不能删除字符串中间的空格。</p><pre class="mr ms mt mu gt mv li mw bn mx my bi"><span id="b63f" class="mz lp iq li b be na nb l nc nd">&lt;?php<br/><br/>// trim()<br/>$string = " Hello There ";<br/>$string = trim($string);<br/>var_dump($string);</span></pre><pre class="ne mv li mw bn mx my bi"><span id="66cb" class="mz lp iq li b be na nb l nc nd">/app/98 Functions/index.php:6:string 'Hello There' (length=11)</span></pre><p id="eac8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lf lg lh li b">trim()</code>函数删除开头和结尾的空白。初始字符串长度为<code class="fe lf lg lh li b">13</code>，但仅在<code class="fe lf lg lh li b">trim()</code>功能应用后为<code class="fe lf lg lh li b">11</code>。</p><pre class="mr ms mt mu gt mv li mw bn mx my bi"><span id="3220" class="mz lp iq li b be na nb l nc nd">&lt;?php<br/><br/>// ltrim()<br/>$string = " Hello There ";<br/>$string = ltrim($string);<br/>var_dump($string);</span></pre><pre class="ne mv li mw bn mx my bi"><span id="c88b" class="mz lp iq li b be na nb l nc nd">/app/98 Functions/index.php:11:string 'Hello There ' (length=12)</span></pre><p id="91c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lf lg lh li b">ltrim()</code>函数只移除左边的空白。这就是为什么我们只剩下一个长度为<code class="fe lf lg lh li b">12</code>的字符串。</p><pre class="mr ms mt mu gt mv li mw bn mx my bi"><span id="2492" class="mz lp iq li b be na nb l nc nd">&lt;?php<br/><br/>// rtrim()<br/>$string = " Hello There ";<br/>$string = rtrim($string);<br/>var_dump($string);</span></pre><pre class="ne mv li mw bn mx my bi"><span id="cf90" class="mz lp iq li b be na nb l nc nd">/app/98 Functions/index.php:16:string ' Hello There' (length=12)</span></pre><p id="3ab2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lf lg lh li b">rtrim()</code>函数产生与<code class="fe lf lg lh li b">ltrim()</code>相同的字符串长度，但是最后一个空格这次被删除了，而不是第一个。</p><h1 id="8908" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">htmlspecialchars()</h1><p id="cc5a" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">这是一个非常重要的功能。它将特殊字符转换成 HTML 实体。这有助于防止您的应用程序接受恶意代码，如一些 JavaScript 注入。</p><pre class="mr ms mt mu gt mv li mw bn mx my bi"><span id="28a6" class="mz lp iq li b be na nb l nc nd">&lt;?php<br/><br/>$html = '&lt;script&gt;alert("Hacked");&lt;/script&gt;';<br/>$sanitized = htmlspecialchars($html);<br/>var_dump($sanitized);</span></pre><pre class="ne mv li mw bn mx my bi"><span id="70ce" class="mz lp iq li b be na nb l nc nd">/app/98 Functions/index.php:21:string '&amp;lt;script&amp;gt;alert(&amp;quot;Hacked&amp;quot;);&amp;lt;/script&amp;gt;' (length=55)</span></pre><p id="2a29" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如你所见，<code class="fe lf lg lh li b">&lt;</code>转化为<code class="fe lf lg lh li b">&amp;lt;</code>，<code class="fe lf lg lh li b">&gt;</code>转化为<code class="fe lf lg lh li b">&amp;gt;</code>。</p><h1 id="d41d" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">_ _ 调用()</h1><p id="3abc" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">call 方法允许方法重载。你可以想出任何你喜欢的方法名。我会告诉你我的意思。</p><pre class="mr ms mt mu gt mv li mw bn mx my bi"><span id="3c43" class="mz lp iq li b be na nb l nc nd">&lt;?php<br/><br/>class OverloadingTest<br/>{<br/>    private function cantAccess(string $name)<br/>    {<br/>        echo "Hello " . $name;<br/>    }<br/>}<br/><br/>$test = new OverloadingTest();<br/>$test-&gt;cantAccess("Dino Cajic");</span></pre><p id="3262" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们有一个非常简单的叫做<code class="fe lf lg lh li b">OverloadingTest</code>的类，它有一个私有方法<code class="fe lf lg lh li b">cantAccess</code>。如果我们实例化这个类并调用<code class="fe lf lg lh li b">cantAccess</code>方法，我们会得到致命错误。</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/0798abf14624c2940fa8405910d31b5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zTru6YIL_aVqjsR-32YVgg.png"/></div></div></figure><p id="5a8b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是假设您试图在用户通过身份验证的情况下授予对该方法的访问权。让我们首先“认证”用户。</p><pre class="mr ms mt mu gt mv li mw bn mx my bi"><span id="6860" class="mz lp iq li b be na nb l nc nd">&lt;?php<br/><br/>class OverloadingTest<br/>{<br/>    private bool $userHasAccess = false;<br/><br/>    public function __construct($userHasAccess)<br/>    {<br/>        $this-&gt;userHasAccess = $userHasAccess;<br/>    }<br/><br/>    private function cantAccess(string $name)<br/>    {<br/>        echo "Hello " . $name;<br/>    }<br/>}<br/><br/>$test = new OverloadingTest(true);<br/>$test-&gt;cantAccess("Dino Cajic");</span></pre><p id="e53c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在有一个类，<code class="fe lf lg lh li b">OverloadingTest</code>，它现在有一个私有属性叫做<code class="fe lf lg lh li b">$userHasAccess</code>；它被初始化为<code class="fe lf lg lh li b">false</code>。如果我们将<code class="fe lf lg lh li b">true</code>传递给构造函数，它会将属性值更改为<code class="fe lf lg lh li b">true</code>。太好了，但是我们还是不能访问<code class="fe lf lg lh li b">cantAccess()</code>私有方法。我们可以用我们的<code class="fe lf lg lh li b">__call()</code>方法。</p><pre class="mr ms mt mu gt mv li mw bn mx my bi"><span id="3468" class="mz lp iq li b be na nb l nc nd">&lt;?php<br/><br/>class OverloadingTest<br/>{<br/>    private bool $userHasAccess = false;<br/><br/>    public function __construct($userHasAccess)<br/>    {<br/>        $this-&gt;userHasAccess = $userHasAccess;<br/>    }<br/><br/>    public function __call($name, $args)<br/>    {<br/>        if ( $this-&gt;userHasAccess ) {<br/>            $this-&gt;cantAccess($args[0]);<br/>        }<br/>    }<br/><br/>    private function cantAccess(string $name)<br/>    {<br/>        echo "Hello " . $name;<br/>    }<br/>}<br/><br/>$test = new OverloadingTest(true);<br/>$test-&gt;cantAccess("Dino Cajic");</span></pre><p id="973f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们有一个<code class="fe lf lg lh li b">__call()</code>方法时，如果它们不可访问，它优先于我们的常规方法。所以，如果你调用<code class="fe lf lg lh li b">$test-&gt;cantAccess("Dino Cajic")</code>，它实际上调用了<code class="fe lf lg lh li b">__call()</code>方法。参数<code class="fe lf lg lh li b">$name</code>和<code class="fe lf lg lh li b">$args</code>将分别接收函数名和参数，分别为<code class="fe lf lg lh li b">cantAccess</code>和<code class="fe lf lg lh li b">Dino Cajic</code>。</p><p id="5dde" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的<code class="fe lf lg lh li b">__call()</code>方法首先检查<code class="fe lf lg lh li b">userHasAccess</code>是否存在，如果存在，则调用<code class="fe lf lg lh li b">cantAccess</code>方法并传递<code class="fe lf lg lh li b">$args[0]</code>方法；<code class="fe lf lg lh li b">$args</code>是<code class="fe lf lg lh li b">__call()</code>方法中的一个数组。</p><p id="fd31" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们收到的输出是预期的:<code class="fe lf lg lh li b">Hello Dino Cajic</code>。</p><p id="8afd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我选择了与我们的私有方法相同的名称，但是我可以选择任何名称，比如<code class="fe lf lg lh li b">randomFunction</code>。你认为这有用吗？</p><pre class="mr ms mt mu gt mv li mw bn mx my bi"><span id="51b5" class="mz lp iq li b be na nb l nc nd">&lt;?php<br/><br/>class OverloadingTest<br/>{<br/>    private bool $userHasAccess = false;<br/><br/>    public function __construct($userHasAccess)<br/>    {<br/>        $this-&gt;userHasAccess = $userHasAccess;<br/>    }<br/><br/>    public function __call($name, $args)<br/>    {<br/>        if ( $this-&gt;userHasAccess ) {<br/>            $this-&gt;cantAccess($args[0]);<br/>        }<br/>    }<br/><br/>    private function cantAccess(string $name)<br/>    {<br/>        echo "Hello " . $name;<br/>    }<br/>}<br/><br/>$test = new OverloadingTest(true);<br/>$test-&gt;randomFunction("Dino Cajic");</span></pre><p id="92d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">确实如此。所以你想通过什么都可以。让我们通过转储<code class="fe lf lg lh li b">$name</code>和<code class="fe lf lg lh li b">$args</code>参数来仔细看看<code class="fe lf lg lh li b">__call()</code>方法。</p><pre class="mr ms mt mu gt mv li mw bn mx my bi"><span id="a92d" class="mz lp iq li b be na nb l nc nd">&lt;?php<br/><br/>class OverloadingTest<br/>{<br/>    public function __call($name, $args)<br/>    {<br/>        var_dump($name);<br/>        var_dump($args);<br/>    }<br/>}<br/><br/>$test = new OverloadingTest(true);<br/>$test-&gt;randomFunction("Dino Cajic");</span></pre><pre class="ne mv li mw bn mx my bi"><span id="bc8b" class="mz lp iq li b be na nb l nc nd">/app/98 Functions/Overloading.php:17:string 'randomFunction' (length=14)<br/><br/>/app/98 Functions/Overloading.php:18:<br/>array (size=1)<br/>  0 =&gt; string 'Dino Cajic' (length=10)</span></pre><p id="7867" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如所料:<code class="fe lf lg lh li b">$name</code>是函数名<code class="fe lf lg lh li b">randomFunction</code>,<code class="fe lf lg lh li b">$args</code>是一个数组，包含我们刚刚传递给<code class="fe lf lg lh li b">Dino Cajic</code>的字符串。</p><p id="f36a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们回到我们的功能:</p><p id="c263" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lf lg lh li b">$this-&gt;cantAccess</code>而不是<code class="fe lf lg lh li b">$this-&gt;randomFunction</code></p><pre class="mr ms mt mu gt mv li mw bn mx my bi"><span id="c461" class="mz lp iq li b be na nb l nc nd">&lt;?php<br/><br/>class OverloadingTest<br/>{<br/>    private bool $userHasAccess = false;<br/><br/>    public function __construct($userHasAccess)<br/>    {<br/>        $this-&gt;userHasAccess = $userHasAccess;<br/>    }<br/><br/>    public function __call($name, $args)<br/>    {<br/>        if ( $this-&gt;userHasAccess ) {<br/>            $this-&gt;cantAccess($args[0]);<br/>        }<br/>    }<br/><br/>    private function cantAccess(string $name)<br/>    {<br/>        echo "Hello " . $name;<br/>    }<br/>}<br/><br/>$test = new OverloadingTest(true);<br/>$test-&gt;cantAccess("Dino Cajic");</span></pre><p id="3c7a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以在 __call()方法内部进行修改。我们不必在里面调用<code class="fe lf lg lh li b">$this-&gt;cantAccess()</code>;我们可以叫<code class="fe lf lg lh li b">$this-&gt;$name()</code>。</p><pre class="mr ms mt mu gt mv li mw bn mx my bi"><span id="cad0" class="mz lp iq li b be na nb l nc nd">&lt;?php<br/><br/>class OverloadingTest<br/>{<br/>    private bool $userHasAccess = false;<br/><br/>    public function __construct($userHasAccess)<br/>    {<br/>        $this-&gt;userHasAccess = $userHasAccess;<br/>    }<br/><br/>    public function __call($name, $args)<br/>    {<br/>        if ( $this-&gt;userHasAccess ) {<br/>            $this-&gt;$name($args[0]);<br/>        }<br/>    }<br/><br/>    private function cantAccess(string $name)<br/>    {<br/>        echo "Hello " . $name;<br/>    }<br/>}<br/><br/>$test = new OverloadingTest(true);<br/>$test-&gt;cantAccess("Dino Cajic");</span></pre><p id="e5d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这可能会变得超级混乱。让我们将第一个<code class="fe lf lg lh li b">__call()</code>参数从<code class="fe lf lg lh li b">$name</code>重命名为<code class="fe lf lg lh li b">$function_name</code>。</p><pre class="mr ms mt mu gt mv li mw bn mx my bi"><span id="a0c8" class="mz lp iq li b be na nb l nc nd">&lt;?php<br/><br/>class OverloadingTest<br/>{<br/>    private bool $userHasAccess = false;<br/><br/>    public function __construct($userHasAccess)<br/>    {<br/>        $this-&gt;userHasAccess = $userHasAccess;<br/>    }<br/><br/>    public function __call($function_name, $args)<br/>    {<br/>        if ( $this-&gt;userHasAccess ) {<br/>            $this-&gt;$function_name($args[0]);<br/>        }<br/>    }<br/><br/>    private function cantAccess(string $name)<br/>    {<br/>        echo "Hello " . $name;<br/>    }<br/>}<br/><br/>$test = new OverloadingTest(true);<br/>$test-&gt;cantAccess("Dino Cajic");</span></pre><p id="868d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们放大一下<code class="fe lf lg lh li b">__call()</code>方法。</p><pre class="mr ms mt mu gt mv li mw bn mx my bi"><span id="5937" class="mz lp iq li b be na nb l nc nd">public function __call($function_name, $args)<br/>{<br/>    if ( $this-&gt;userHasAccess ) {<br/>        $this-&gt;$function_name($args[0]);<br/>    }<br/>}</span></pre><ul class=""><li id="0f0a" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">一旦对象被实例化，我们调用方法<code class="fe lf lg lh li b">cantAccess</code>，它就调用<code class="fe lf lg lh li b">__call(“cantAccess”, array(“Dino Cajic”))</code>。</li><li id="7464" class="kw kx iq ka b kb lj kf lk kj ll kn lm kr ln kv lb lc ld le bi translated">接下来，如果调用了<code class="fe lf lg lh li b">userHasAccess</code>，<code class="fe lf lg lh li b">$this-&gt;$function_name</code>。这个和<code class="fe lf lg lh li b">$this-&gt;cantAccess</code>一次评估一样。</li><li id="e439" class="kw kx iq ka b kb lj kf lk kj ll kn lm kr ln kv lb lc ld le bi translated">第一个参数是从<code class="fe lf lg lh li b">$args</code>数组传递过来的，也就是<code class="fe lf lg lh li b">Dino Cajic</code> : <code class="fe lf lg lh li b">$this-&gt;cantAccess(“DinoCajic”)</code>。</li><li id="9808" class="kw kx iq ka b kb lj kf lk kj ll kn lm kr ln kv lb lc ld le bi translated">因为我们在同一个对象中，所以我们可以访问私有的<code class="fe lf lg lh li b">cantAccess</code>方法。它对表达式求值并回显出来。</li></ul><p id="7119" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">来固化这个概念。让我们创建另一个方法，并以完全相同的方式调用它。</p><pre class="mr ms mt mu gt mv li mw bn mx my bi"><span id="7e32" class="mz lp iq li b be na nb l nc nd">&lt;?php<br/><br/>class OverloadingTest<br/>{<br/>    private bool $userHasAccess = false;<br/><br/>    public function __construct($userHasAccess)<br/>    {<br/>        $this-&gt;userHasAccess = $userHasAccess;<br/>    }<br/><br/>    public function __call($function_name, $args)<br/>    {<br/>        if ( $this-&gt;userHasAccess ) {<br/>            $this-&gt;$function_name($args[0]);<br/>        }<br/>    }<br/><br/>    private function cantAccess(string $name)<br/>    {<br/>        echo "Hello " . $name . ". ";<br/>    }<br/><br/>    private function cantAccessTwo(int $age)<br/>    {<br/>        echo "You are " . $age . " years old.";<br/>    }<br/>}<br/><br/>$test = new OverloadingTest(true);<br/>$test-&gt;cantAccess("Dino Cajic");<br/>$test-&gt;cantAccessTwo(25);</span></pre><p id="cef4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们添加了<code class="fe lf lg lh li b">cantAccessTwo</code>方法。我们不能正常访问它，但是我们可以通过我们的<code class="fe lf lg lh li b">__call()</code>方法访问它。为了做，再加一个吧。我们将传递一个输出用户电子邮件的回调函数。这个函数我们称之为:</p><pre class="mr ms mt mu gt mv li mw bn mx my bi"><span id="8716" class="mz lp iq li b be na nb l nc nd">&lt;?php<br/>//...<br/><br/>$test-&gt;randomCallbackFunction( function($email) {<br/>    echo "Your email is " . $email;<br/>}, "dino@example.com" );</span></pre><p id="49b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您需要复习回调函数，可以这样做:</p><div class="ng nh gp gr ni nj"><a rel="noopener  ugc nofollow" target="_blank" href="/php-7-x-p42-callback-functions-6552477f2a87"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd ir gy z fp no fr fs np fu fw ip bi translated">PHP — P42:回调函数</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">是时候结束这个话题了。我通过令人痛苦的细节来简化这个概念。</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">blog.devgenius.io</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx jw nj"/></div></div></a></div><p id="6fca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是怎么回事？</p><ul class=""><li id="81fa" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">既然我们已经实现了<code class="fe lf lg lh li b">__call()</code>方法，我们将调用它。第一个参数是<code class="fe lf lg lh li b">randomCallbackFunction</code>名称。它被附加到<code class="fe lf lg lh li b">$function_name</code>参数上。</li><li id="f403" class="kw kx iq ka b kb lj kf lk kj ll kn lm kr ln kv lb lc ld le bi translated">第二个参数是一个匿名函数，它显然会接受一个电子邮件地址并输出该电子邮件。它附着在<code class="fe lf lg lh li b">$args[0]</code>上。</li><li id="6ef0" class="kw kx iq ka b kb lj kf lk kj ll kn lm kr ln kv lb lc ld le bi translated">传递了一个额外的参数:字符串<code class="fe lf lg lh li b">dino@example.com</code>。它附属于<code class="fe lf lg lh li b">$args[1]</code>。</li></ul><p id="161c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来我们需要修改我们的<code class="fe lf lg lh li b">__call()</code>方法。我们首先需要看看我们的方法是否存在。如果是的话，我们就称之为。</p><pre class="mr ms mt mu gt mv li mw bn mx my bi"><span id="3fe3" class="mz lp iq li b be na nb l nc nd">public function __call($function_name, $args)<br/>{<br/>    if ( $this-&gt;userHasAccess &amp;&amp; method_exists($this, $function_name) ) {<br/>        $this-&gt;$function_name($args[0]);<br/>    }<br/>}</span></pre><p id="9f64" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这对我们的<code class="fe lf lg lh li b">cantAccess</code>方法很好，但是<code class="fe lf lg lh li b">randomCallbackFunction</code>方法呢？不存在，我们跳过。回调函数存储在我们的<code class="fe lf lg lh li b">$args[0]</code>元素中。让我们将它赋给一个<code class="fe lf lg lh li b">$callback</code>变量，使它更加明确。</p><pre class="mr ms mt mu gt mv li mw bn mx my bi"><span id="26c6" class="mz lp iq li b be na nb l nc nd">public function __call($function_name, $args)<br/>{<br/>    if ( $this-&gt;userHasAccess &amp;&amp; method_exists($this, $function_name) ) {<br/>        $this-&gt;$function_name($args[0]);<br/>    } else {<br/>        $callback = $args[0];<br/>    }<br/>}</span></pre><p id="5d10" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">电子邮件地址存储在<code class="fe lf lg lh li b">$args[1]</code>中，所以让我们把它分配给更容易阅读的东西。</p><pre class="mr ms mt mu gt mv li mw bn mx my bi"><span id="2eb9" class="mz lp iq li b be na nb l nc nd">public function __call($function_name, $args)<br/>{<br/>    if ( $this-&gt;userHasAccess &amp;&amp; method_exists($this, $function_name) ) {<br/>        $this-&gt;$function_name($args[0]);<br/>    }<br/><br/>    $callback = $args[0];<br/>    $callback_argument = $args[1];<br/>}<br/><br/>public function __call($function_name, $args)<br/>{<br/>    if ( $this-&gt;userHasAccess &amp;&amp; method_exists($this, $function_name) ) {<br/>        $this-&gt;$function_name($args[0]);<br/>    } else {<br/>        $callback = $args[0];<br/>        $callback_argument = $args[1];<br/>    }<br/>}</span></pre><p id="5cd9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">太好了。现在我们需要称之为。但在此之前，我们需要确保它确实是一个可调用的函数。我们如何做到这一点？具有<code class="fe lf lg lh li b">is_callable</code>功能。</p><pre class="mr ms mt mu gt mv li mw bn mx my bi"><span id="6a62" class="mz lp iq li b be na nb l nc nd">public function __call($function_name, $args)<br/>{<br/>    if ( $this-&gt;userHasAccess &amp;&amp; method_exists($this, $function_name) ) {<br/>        $this-&gt;$function_name($args[0]);<br/>    } else {<br/>        $callback = $args[0];<br/>        $callback_argument = $args[1];<br/><br/>        if (is_callable($callback)) {<br/>            // Do Something if callable<br/>        }<br/>    }<br/>}</span></pre><p id="d0c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果它是可调用的，我们将调用回调并将<code class="fe lf lg lh li b">$callback_argument</code>传递给它，这是我们的<code class="fe lf lg lh li b">dino@example.com</code>电子邮件地址。</p><pre class="mr ms mt mu gt mv li mw bn mx my bi"><span id="488c" class="mz lp iq li b be na nb l nc nd">public function __call($function_name, $args)<br/>{<br/>    if ( $this-&gt;userHasAccess &amp;&amp; method_exists($this, $function_name) ) {<br/>        $this-&gt;$function_name($args[0]);<br/>    } else {<br/>        $callback = $args[0];<br/>        $callback_argument = $args[1];<br/><br/>        if (is_callable($callback)) {<br/>            $callback($callback_argument);<br/>        }<br/>    }<br/>}</span></pre><p id="b7ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完整的代码如下所示:</p><pre class="mr ms mt mu gt mv li mw bn mx my bi"><span id="a925" class="mz lp iq li b be na nb l nc nd">&lt;?php<br/><br/>class OverloadingTest<br/>{<br/>    private bool $userHasAccess = false;<br/><br/>    public function __construct($userHasAccess)<br/>    {<br/>        $this-&gt;userHasAccess = $userHasAccess;<br/>    }<br/><br/>    public function __call($function_name, $args)<br/>    {<br/>        if ( $this-&gt;userHasAccess &amp;&amp; method_exists($this, $function_name) ) {<br/>            $this-&gt;$function_name($args[0]);<br/>        } else {<br/>            $callback = $args[0];<br/>            $callback_argument = $args[1];<br/><br/>            if (is_callable($callback)) {<br/>                $callback($callback_argument);<br/>            }<br/>        }<br/>    }<br/><br/>    private function cantAccess(string $name)<br/>    {<br/>        echo "Hello " . $name . ". ";<br/>    }<br/><br/>    private function cantAccessTwo(int $age)<br/>    {<br/>        echo "You are " . $age . " years old. ";<br/>    }<br/>}<br/><br/>$test = new OverloadingTest(true);<br/>$test-&gt;cantAccess("Dino Cajic");<br/>$test-&gt;cantAccessTwo(25);<br/><br/>$test-&gt;randomCallbackFunction( function($email) {<br/>    echo "Your email is " . $email;<br/>}, "dino@example.com" );</span></pre><p id="4aa4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">结果是:</p><pre class="mr ms mt mu gt mv li mw bn mx my bi"><span id="5597" class="mz lp iq li b be na nb l nc nd">Hello Dino Cajic. You are 25 years old. Your email is dino@example.com</span></pre><p id="33e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一点清理工作。让我们将<code class="fe lf lg lh li b">$callback_argument</code>移入<code class="fe lf lg lh li b">is_callable</code>体内。如果它不可调用，就不能保证我们会在元素<code class="fe lf lg lh li b">$args[1]</code>上有争论。</p><pre class="mr ms mt mu gt mv li mw bn mx my bi"><span id="aefb" class="mz lp iq li b be na nb l nc nd">public function __call($function_name, $args)<br/>{<br/>    if ( $this-&gt;userHasAccess &amp;&amp; method_exists($this, $function_name) ) {<br/>        $this-&gt;$function_name($args[0]);<br/>    } else {<br/>        $callback = $args[0];<br/><br/>        if (is_callable($callback)) {<br/>            $callback_argument = $args[1];<br/>            $callback($callback_argument);<br/>        }<br/>    }<br/>}</span></pre><p id="3200" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">相当有趣的东西。我将把它留在这里，并在下一篇文章中继续我们剩余的功能。</p><div class="ng nh gp gr ni nj"><a href="https://github.com/dinocajic/php-youtube-tutorials" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd ir gy z fp no fr fs np fu fw ip bi translated">GitHub-dinocajic/PHP-YouTube-tutorials:PHP YouTube 教程的代码</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">PHP YouTube 教程的代码确保你已经安装了 Docker。克隆回购。运行以下命令…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">github.com</p></div></div><div class="ns l"><div class="ny l nu nv nw ns nx jw nj"/></div></div></a></div></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div class="gh gi og"><img src="../Images/d38dfe69e971357b4dc3a2599b6ca906.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uP5dYqPwFUd8lGGc.jpeg"/></div></figure><p id="5df9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Dino Cajic 目前是<a class="ae oh" href="http://absolutebiotech.com/" rel="noopener ugc nofollow" target="_blank"> Absolute Biotech </a>的 IT 主管，该公司是<a class="ae oh" href="https://www.lsbio.com/" rel="noopener ugc nofollow" target="_blank"> LSBio(寿命生物科学公司)</a>、<a class="ae oh" href="https://absoluteantibody.com/" rel="noopener ugc nofollow" target="_blank"> Absolute 抗体</a>、<a class="ae oh" href="https://www.kerafast.com/" rel="noopener ugc nofollow" target="_blank"> Kerafast </a>、<a class="ae oh" href="https://everestbiotech.com/" rel="noopener ugc nofollow" target="_blank"> Everest BioTech </a>、<a class="ae oh" href="https://www.nordicmubio.com/" rel="noopener ugc nofollow" target="_blank"> Nordic MUbio </a>和<a class="ae oh" href="https://www.exalpha.com/" rel="noopener ugc nofollow" target="_blank"> Exalpha </a>的母公司。他还担任我的自动系统的首席执行官。他拥有计算机科学学士学位，辅修生物学，并拥有十多年的软件工程经验。他的背景包括创建企业级电子商务应用程序、执行基于研究的软件开发，以及通过写作促进知识的传播。</p><p id="b077" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在<a class="ae oh" href="https://www.linkedin.com/in/dinocajic/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系他，在<a class="ae oh" href="https://instagram.com/think.dino" rel="noopener ugc nofollow" target="_blank"> Instagram </a>上关注他，或者<a class="ae oh" href="https://dinocajic.medium.com/subscribe" rel="noopener">订阅他的媒体出版物</a>。</p><p id="f55b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">阅读 Dino Cajic(以及 Medium 上成千上万的其他作家)的每一个故事。你的会员费直接支持迪诺·卡吉克和你阅读的其他作家。你也可以在媒体上看到所有的故事。 </p></div></div>    
</body>
</html>