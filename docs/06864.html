<html>
<head>
<title>Serving CSS In Go’s Native Server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Go 的原生服务器中提供 CSS 服务</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/serving-css-in-gos-native-server-8bc58d85d0b2?source=collection_archive---------6-----------------------#2022-02-08">https://blog.devgenius.io/serving-css-in-gos-native-server-8bc58d85d0b2?source=collection_archive---------6-----------------------#2022-02-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/c2194b1ff7c468811f2047465fd23ee5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MqGzIowOOSfH4YM0"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">照片由<a class="ae jz" href="https://unsplash.com/@flowforfrank?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">费伦茨·阿尔马西</a>在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="3ff9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我在 Golang 中遇到模板时，我决定尝试一下这个特性，只是为了学习如何使用它。我在一个单独的文件中设计了我的标记，并把它作为一个链接。</p><p id="e93a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦我启动了服务器，你可以想象当提供的页面非常普通时会有多惊讶。事实证明，样式表和任何其他静态文件只需要稍微调整一下就可以使用了。本文将研究如何应用这一微小且相当直接的调整。</p><h2 id="890b" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">先决条件</h2><p id="5bc7" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">要阅读这篇文章，你需要对 Go 有一个基本的了解，更重要的是，你需要了解 Go 内置的模板系统。</p><h2 id="712f" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">项目目标</h2><p id="66a0" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">最终目标是将从外部服务器获取的产品列表样式化为卡片列表。</p><h2 id="b316" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">服务器设置</h2><figure class="lw lx ly lz gt jo"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">初始服务器文件</figcaption></figure><p id="9684" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是服务器的基本设置，将在 localhost:8080 上为 web 应用程序提供服务。我们将使用标准的 net/http 包。</p><pre class="lw lx ly lz gt mc md me mf aw mg bi"><span id="af76" class="ky kz in md b gy mh mi l mj mk">go run server.go</span></pre><p id="a493" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上述命令将启动服务器。</p><h2 id="cf1e" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">文件夹结构</h2><pre class="lw lx ly lz gt mc md me mf aw mg bi"><span id="6885" class="ky kz in md b gy mh mi l mj mk">+-- server.go<br/>+-- views<br/>   +-- products.html<br/>   +-- stylesheets<br/>      +-- products.css<br/>      +-- reset.css</span></pre><p id="56ad" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设这是文件夹结构，并且我们已经将 main.css 文件作为链接包含在 index.html 中。</p><h2 id="4c71" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">获取数据</h2><p id="a2dd" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">我们对整个项目有了更广泛的了解，现在我们可以开始设置负责从 API 获取数据的函数。</p><figure class="lw lx ly lz gt jo"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">服务器文件</figcaption></figure><p id="c2ec" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ml mm mn md b">getProducts</code>函数处理从 API 获取数据，并利用已经设置好的<code class="fe ml mm mn md b">structs</code>来存储数据和返回数据。</p><p id="6a9f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ml mm mn md b">productsHandler</code>负责处理产品请求，使用<code class="fe ml mm mn md b">getProducts</code>函数获取数据，并为模板提供服务。</p><figure class="lw lx ly lz gt jo"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">产品模板</figcaption></figure><p id="8a5e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从上面可以看出，一旦进入模板，我们只需简单地遍历产品列表，并在卡片中列出它们。</p><h2 id="cde6" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">样式表设置</h2><p id="522b" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">第一个样式表是一个最小的重置文件，它将为所有浏览器提供公平的竞争环境，并减少不一致性。</p><figure class="lw lx ly lz gt jo"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">重置 css 文件。</figcaption></figure><p id="25eb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的大多数样式都可以在 products.css 文件中找到。</p><figure class="lw lx ly lz gt jo"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">产品和产品模板的样式。</figcaption></figure><h2 id="4dac" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">提供静态文件</h2><p id="705a" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">如果我们按原样提供应用程序，这是我们将得到的输出，针对上下文进行缩小:</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mo"><img src="../Images/720b00ff4045e4e4d9819496870eef52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TGcqc_0p2PcFwYY08NO_mA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">不带样式的教程输出图像</figcaption></figure><p id="a1d2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如我们所见，产品确实已经上市，但没有我们创造的风格。跳到检查器中，在 network 选项卡下，我们可以看到服务器无法定位我们的样式表。</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/5b51bdc1bd2040d5262bc3a1f54d53af.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/format:webp/1*uB9cdVAzVU2BXw3YKY2rxw.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">浏览器检查器中的“网络”标签</figcaption></figure><p id="3a49" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了解决这个问题，我们需要显式地服务我们的文件。我们可以做以下修改来服务我们的文件。</p><figure class="lw lx ly lz gt jo"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">对 func() main 的修改</figcaption></figure><p id="839f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我相信我们熟悉<code class="fe ml mm mn md b">HandleFunc()</code>函数，它本质上是将一个 url 匹配到一个处理程序，该处理程序将处理请求并返回一个响应。</p><p id="cda7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从上面可以看出，我们已经在<code class="fe ml mm mn md b">styles/reset</code>和<code class="fe ml mm mn md b">styles/products</code>路由/模式下为两个样式表定义了显式路由。在<code class="fe ml mm mn md b">HandleFunc</code>的第二个参数中，我们有处理函数，其中我们利用了<code class="fe ml mm mn md b">http.ServeFile</code>函数来服务特定的文件。</p><p id="ebe8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ml mm mn md b">http.ServeFile</code>接受三个参数，前两个是 responseWriter 和请求。第三个是我们要提供的文件的路径。需要注意的是，在我们的例子中，路径是相对于<code class="fe ml mm mn md b">server.go</code>文件所在的位置的。</p><p id="14b6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的方法可以很好地工作，页面的样式如下所示</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/38eceb3628a86df1f3fea5fe2ce33448.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*dx3oyaRLnnGRtgRyTC97YQ.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">带样式的教程输出图像</figcaption></figure><p id="0eb0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">虽然上述方法可行，但对于大量文件来说，它的可伸缩性不是很好。通常将所有样式存储在一个父结构中。因此，这就是为整个目录提供服务的方法出现的地方。</p><figure class="lw lx ly lz gt jo"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">对 func() main 的最终修改</figcaption></figure><p id="dea1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们用一个单独的路由代替了两个路由，利用<code class="fe ml mm mn md b">http.FileServer</code>函数打开了服务整个目录的途径。它接受一个 FileSystem 类型的参数，这实际上是一个接口。因此，我们使用<code class="fe ml mm mn md b">http.Dir</code>来类型转换我们的路径，该路径指向我们的文件将被提供的目录。路径可以是绝对的，也可以是相对的。<code class="fe ml mm mn md b">http.FileServer</code>返回一个<code class="fe ml mm mn md b">http.Handler</code>类型的变量，这个变量一会儿就有意义了。</p><p id="da40" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">设置好文件服务器对象后，我们需要为它分配一个路由以供使用。我们将利用带两个参数的<code class="fe ml mm mn md b">http.Handle</code>函数。第一个是路由模式，第二个是处理程序。</p><p id="656e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这种情况下，我们将对位于<code class="fe ml mm mn md b">./views/stylesheets</code>目录中的样式使用<code class="fe ml mm mn md b">/styles/</code>模式。</p><p id="33b0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将传递上面创建的变量<code class="fe ml mm mn md b">styles</code>作为第二个变量，因为<code class="fe ml mm mn md b">http.FileServer</code>返回类型<code class="fe ml mm mn md b">http.Handler</code>。</p><p id="d6d1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，无论我们将什么模式作为第一个参数传递，在我们的例子中，<code class="fe ml mm mn md b">/styles/</code>都需要从文件处理程序中去除。这是因为我们的文件目录是<code class="fe ml mm mn md b">./views/stylesheets</code>，如果我们请求<code class="fe ml mm mn md b">/styles/reset.css</code>，服务器会将整个 url 附加到目录中并搜索特定的文件。因此，服务器将尝试为<code class="fe ml mm mn md b">./views/stylesheets/styles/reset.css</code>提供服务，这当然是不存在的。</p><p id="dc94" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就是<code class="fe ml mm mn md b">http.StripPrefix</code>函数的用武之地。如果我们去掉<code class="fe ml mm mn md b">/styles/</code>字符串，应用程序现在会像预期的那样运行。如果使用统一模式<code class="fe ml mm mn md b">/</code>作为第一个参数<code class="fe ml mm mn md b">http.Handle</code>函数，则无需去除前缀。</p><h2 id="17a8" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">结论</h2><p id="c3c3" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">使用上面的小调整，你可以立刻提供静态文件。</p><p id="6017" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">整个项目的代码可以在 Github 上<a class="ae jz" href="https://github.com/kiptoo-korir/products-demo" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></div></div>    
</body>
</html>