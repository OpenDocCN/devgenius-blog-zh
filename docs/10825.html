<html>
<head>
<title>Java reminder: Overrides can narrow return type but not access</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 提醒:覆盖可以缩小返回类型，但不能缩小访问范围</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/java-reminder-overrides-can-narrow-return-type-but-not-access-63cc926bf26b?source=collection_archive---------11-----------------------#2022-12-02">https://blog.devgenius.io/java-reminder-overrides-can-narrow-return-type-but-not-access-63cc926bf26b?source=collection_archive---------11-----------------------#2022-12-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/876ef76bfb742d8528ab5518c60c9a16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NWdJSNz_9yq8lVoq"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Christina Kirschnerova 在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="f13d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当抱怨 Java 如何冗长时，几乎没有人提到默认访问修饰符。对于 Java 来说，这可能是一个更详细的好地方。</p><p id="acab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">考虑这个玩具例子:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="f454" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然<code class="fe lh li lj lk b">SomeClass</code>可以从其他包中被引用(因为它被标记为 public)，但是它不能在包外被扩展，因为子类必须覆盖<code class="fe lh li lj lk b">doSomething()</code>或者自己是抽象的。</p><p id="8763" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，下面是当我试图从<code class="fe lh li lj lk b">edu.example</code>包中扩展<code class="fe lh li lj lk b">SomeClass</code>时，在 Apache NetBeans 中发生的事情:</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div class="gh gi ll"><img src="../Images/31f8751cc8d9d07727f7cd96dd63535c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*gPk6EscMCKGOReUW10gdSQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Apache NetBeans 显示了一个错误，是关于一个类试图扩展另一个包中的一个类。</figcaption></figure><p id="3a90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为在 Java 类中，缺少访问修饰符意味着包是私有的。</p><p id="d211" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相比之下，在 Scala 中，如果你真的希望访问级别是包私有的，你必须显式地写“<code class="fe lh li lj lk b">private[org.example]</code>”——用相关包的名称替换“<code class="fe lh li lj lk b">org.example</code>”。</p><p id="728d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有时会让 Java 程序员，甚至是更有经验的程序员感到困惑，因为默认的访问修饰符在接口的花括号中意味着别的东西。这是一个界面的玩具示例:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="1944" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于接口被显式标记为 public，所以它可以在<code class="fe lh li lj lk b">org.example</code>包之外实现。如果我们在“<code class="fe lh li lj lk b">interface</code>”之前省略“<code class="fe lh li lj lk b">public</code>”，那么“<code class="fe lh li lj lk b">SomeCapable</code>”将是一个包私有接口。</p><p id="d0d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是<code class="fe lh li lj lk b">SomeCapable</code>的<code class="fe lh li lj lk b">doSomething()</code>是<em class="lm">不是</em>包私有。事实上，它是公共的，可以由<code class="fe lh li lj lk b">org.example</code>包之外的类实现。</p><p id="9eba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">问题是，当您将“方法签名”复制到实现类时，您可能会忘记放入“<code class="fe lh li lj lk b">public</code>”。这个错误我已经犯了好几次了。</p><p id="eeda" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">程序不会编译，你会得到一个错误信息。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ln"><img src="../Images/dd439e4076cf3aea8df597d7e44d9bbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GnjnlZirZnDMFQIVLZWdXg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Apache NetBeans 显示了一个错误，该错误与试图从接口实现公共函数的类有关。</figcaption></figure><p id="254b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无意中将访问从 public 缩小到 package private 会导致错误，这是有道理的。抽象函数的目的是促进多态性。</p><p id="8c22" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果对象<em class="lm"> X </em>是类型<em class="lm"> T </em>的一个实例，并且<em class="lm"> T </em>具有我们需要的<em class="lm"> X </em>的所有特征，那么我们可能并不真正关心<em class="lm"> X </em>是否实际上是专门化子类型<em class="lm"> U </em>的一个实例。</p><p id="9676" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是如果类型<em class="lm"> T </em>中声明的函数<em class="lm"> f </em>的访问在<em class="lm"> U </em>中更窄，那么<em class="lm"> U </em>真的可以说是<em class="lm"> T </em>的一个子类型吗？编译器别无选择，只能将其作为错误拒绝。</p><p id="1956" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">顺便说一下，我认为编译器警告中的术语“较弱的访问权限”是一个糟糕的选择。我应该写“更严格的访问权限”。</p><p id="97cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过在编译器期望的地方添加“<code class="fe lh li lj lk b">public</code>”，可以很容易地修复这种错误缩小的访问。然而，这感觉像是 Java 语言规范中的一个矛盾或杂质。</p><p id="66d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Scala 没有这种不一致性:如果在可以指定访问级别的地方没有指定访问级别，那么它就是公共的，无论是在类中还是在 trait 中(Scala trait 有时可以像 Java 接口一样编译)。</p><p id="1ff6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，在 Scala 中，就像在 Java 中一样，不能缩小覆盖的访问范围，但是可以缩小返回类型。</p><p id="a0f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于玩具示例，让我们将这一行添加到<code class="fe lh li lj lk b">SomeClass</code>:</p><pre class="lb lc ld le gt lo lk lp bn lq lr bi"><span id="a3e3" class="ls lt iq lk b be lu lv l lw lx">    abstract Object doSomething(Object obj);</span></pre><p id="0982" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后让我们创建一个实现类:</p><pre class="lb lc ld le gt lo lk lp bn lq lr bi"><span id="c42e" class="ls lt iq lk b be lu lv l lw lx">package org.example;<br/><br/>import java.math.BigInteger;<br/><br/>public class SomeClassImpl extends SomeClass {<br/><br/>    @Override<br/>    int doSomething(int m, int n) throws ArithmeticException {<br/>        return m * n / (m + n);<br/>    }<br/><br/>    @Override<br/>    BigInteger doSomething(Object obj) {<br/>        BigInteger hash = BigInteger.valueOf(obj.hashCode());<br/>        return hash.multiply(hash);<br/>    }<br/>    <br/>}</span></pre><p id="dd93" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">缩小的返回类型不会给调用者带来任何问题。如果他们调用一个<code class="fe lh li lj lk b">SomeClassImpl</code>实例作为一个<code class="fe lh li lj lk b">SomeClass</code>实例，他们将从单参数<code class="fe lh li lj lk b">doSomething()</code>中获得一个<code class="fe lh li lj lk b">Object</code>实例。</p><p id="4154" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是如果这些调用者显式地将单参数的<code class="fe lh li lj lk b">doSomething()</code>作为<code class="fe lh li lj lk b">SomeClassImpl</code>实例调用，那么他们在为<code class="fe lh li lj lk b">doSomething()</code>的返回值进行类型声明时会更加谨慎。</p><p id="82e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在<code class="fe lh li lj lk b">SomeClassImplTest</code>中，不必编写断言单参数<code class="fe lh li lj lk b">doSomething()</code>返回一个<code class="fe lh li lj lk b">BigInteger</code>的测试。</p><pre class="lb lc ld le gt lo lk lp bn lq lr bi"><span id="0254" class="ls lt iq lk b be lu lv l lw lx">    @Test<br/>    public void testDoSomethingReturnType() {<br/>        SomeClassImpl instance = new SomeClassImpl();<br/>        Object result = instance.doSomething("For testing purposes only");<br/>        assert result instanceof BigInteger;<br/>    }</span></pre><p id="1491" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">IntelliJ IDEA 可能会给你一个警告，这个测试是没有意义的，特别是这个实例被明确声明为<code class="fe lh li lj lk b">SomeClassImpl</code>而不是一般的<code class="fe lh li lj lk b">SomeClass</code>。</p><p id="6c62" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">即使可以缩小返回类型，也不能缩小参数类型，因为同样的原因，也不能缩小访问级别。</p><p id="a1d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果返回类型是原语，缩小覆盖的返回类型的能力就不太适用。例如，如果期望的是一个<code class="fe lh li lj lk b">int</code>(一个 32 位有符号整数)，您不能将返回类型缩小到一个<code class="fe lh li lj lk b">short</code>(一个 16 位有符号整数)。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/334b821571ea9337eee493f5e5fd75fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*H3Vx7ZRz4LMlQp_ySm1gig.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">显示 Apache NetBeans 将尝试将返回类型更改为短整数标记为错误的屏幕截图</figcaption></figure><p id="2f3b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">鉴于我在这里只展示了玩具示例，你可能会问这些东西的实际用途是什么，这是一个合理的问题。</p><p id="1cbd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你不太可能真的需要从<code class="fe lh li lj lk b">Object</code>中重写<code class="fe lh li lj lk b">clone()</code>，但是如果你这么做了，你就有理由将<code class="fe lh li lj lk b">clone()</code>的返回类型缩小到你正在处理的类。比我想的要复杂得多。</p><p id="79b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您的项目中有两个密切相关的子层次结构，则更有可能需要缩小重写的返回类型。</p><p id="42e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将从我自己的一个项目中给出一个实际的例子，但是对你来说它可能仍然像一个玩具例子，特别是如果你喜欢尽可能地保持你的继承层次结构。</p><p id="ffa6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<a class="ae kc" href="https://github.com/Alonso-del-Arte/algebraic-integer-calculator" rel="noopener ugc nofollow" target="_blank">我的代数整数计算器项目</a>中，<code class="fe lh li lj lk b">IntegerRing</code>是由<code class="fe lh li lj lk b">QuadraticRing</code>、<code class="fe lh li lj lk b">CubicRing</code>、<code class="fe lh li lj lk b">QuarticRing</code>等类实现的接口。同样，<code class="fe lh li lj lk b">AlgebraicInteger</code>接口也是由<code class="fe lh li lj lk b">QuadraticInteger</code>、<code class="fe lh li lj lk b">CubicInteger</code>、<code class="fe lh li lj lk b">QuarticInteger</code>等类实现的。</p><p id="bc21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lh li lj lk b">AlgebraicInteger</code>接口定义了<code class="fe lh li lj lk b">getRing()</code>函数，该函数应该返回一个<code class="fe lh li lj lk b">IntegerRing</code>。由于从<code class="fe lh li lj lk b">QuadraticInteger</code>实例返回<code class="fe lh li lj lk b">CubicRing</code>或<code class="fe lh li lj lk b">QuarticRing</code>对<code class="fe lh li lj lk b">getRing()</code>来说没有多大意义，所以<code class="fe lh li lj lk b">QuadraticInteger</code>类将<code class="fe lh li lj lk b">getRing()</code>的返回类型缩小到<code class="fe lh li lj lk b">QuadraticRing</code>。</p><p id="8d82" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我在一两个其他项目中使用了这种缩小功能。这是那些你并不总是需要的东西之一，但是知道它什么时候适用是有好处的。</p></div></div>    
</body>
</html>