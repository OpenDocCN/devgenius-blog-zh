<html>
<head>
<title>Threads In Java Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 中的线程第 2 部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/threads-in-java-part-2-e0e0b667c514?source=collection_archive---------6-----------------------#2021-03-09">https://blog.devgenius.io/threads-in-java-part-2-e0e0b667c514?source=collection_archive---------6-----------------------#2021-03-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="c2c8" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">了解创建和预防</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/9094891cbede3cead38bc6b084c1478c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*99jSTR42v0aOJpK9"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">照片由<a class="ae ks" href="https://unsplash.com/@thecreative_exchange?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">在<a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的创意交流</a></figcaption></figure><p id="e4a6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">继我上一篇关于 java 中线程的博客之后，让我们通过理解更多的线程概念来继续更深入地探索线程。</p><h1 id="a098" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated"><strong class="ak">如何防止线程执行</strong></h1><p id="347d" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">我们可以通过使用以下三种方法来阻止线程执行</p><ol class=""><li id="46f6" class="mm mn in kv b kw kx kz la lc mo lg mp lk mq lo mr ms mt mu bi translated">产量()</li><li id="5cb5" class="mm mn in kv b kw mv kz mw lc mx lg my lk mz lo mr ms mt mu bi translated">加入()</li><li id="b857" class="mm mn in kv b kw mv kz mw lc mx lg my lk mz lo mr ms mt mu bi translated">睡眠()</li></ol><h2 id="bfb1" class="na lq in bd lr nb nc dn lv nd ne dp lz lc nf ng mb lg nh ni md lk nj nk mf nl bi translated">1) <strong class="ak"> yield() </strong> :-</h2><p id="ef42" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">yield()出现在具有以下声明的线程类中</p><pre class="kd ke kf kg gt nm nn no np aw nq bi"><span id="0613" class="na lq in nn b gy nr ns l nt nu">Public static native void yield()</span></pre><p id="ffb8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果一个线程想要将改变给予另一个具有相同优先级的等待线程，</p><p id="181c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果一个线程正在执行，并且一个更高优先级的线程到来，那么这个正在执行的线程将被停止，并且一个更高优先级的线程将立即获得一个机会。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="668b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">第 20 行说明:</strong></p><p id="fbf7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我们不删除第 20 行，那么子线程第一次复杂化的可能性很高，因为每次主线程都在内部调用 yield 方法。</p><h2 id="0215" class="na lq in bd lr nb nc dn lv nd ne dp lz lc nf ng mb lg nh ni md lk nj nk mf nl bi translated">2) <strong class="ak"> join() </strong> :-</h2><p id="5a02" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">如果一个线程想要等待其他线程完成，那么这个线程可以调用 join()。</p><p id="f3c3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">必须等待的线程负责调用 join()</p><p id="12d7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">线程类定义了以下连接方法:</p><ol class=""><li id="98f3" class="mm mn in kv b kw kx kz la lc mo lg mp lk mq lo mr ms mt mu bi translated">公共最终无效联接()</li><li id="2220" class="mm mn in kv b kw mv kz mw lc mx lg my lk mz lo mr ms mt mu bi translated">公共最终无效联接(长毫秒)</li><li id="009c" class="mm mn in kv b kw mv kz mw lc mx lg my lk mz lo mr ms mt mu bi translated">公共最终无效连接(长毫秒，整数)</li></ol><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h2 id="5056" class="na lq in bd lr nb nc dn lv nd ne dp lz lc nf ng mb lg nh ni md lk nj nk mf nl bi translated">3) <strong class="ak">睡眠()</strong> :-</h2><p id="f82c" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">如果我们想暂停当前的活动线程，那么我们调用 sleep()。</p><p id="bef3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">线程类中存在 Sleep 方法，声明如下:</p><ol class=""><li id="f43f" class="mm mn in kv b kw kx kz la lc mo lg mp lk mq lo mr ms mt mu bi translated">公共静态本机无效睡眠(长毫秒)</li><li id="5acb" class="mm mn in kv b kw mv kz mw lc mx lg my lk mz lo mr ms mt mu bi translated">公共静态无效睡眠(长毫秒，整数)</li></ol><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h1 id="53a8" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated"><strong class="ak">如何中断一个线程</strong></h1><p id="2160" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">一个线程可以通过调用 Thread 类中的 interrupt()来中断另一个线程。</p><pre class="kd ke kf kg gt nm nn no np aw nq bi"><span id="9415" class="na lq in nn b gy nr ns l nt nu">Public void interrupt();</span></pre><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h2 id="a593" class="na lq in bd lr nb nc dn lv nd ne dp lz lc nf ng mb lg nh ni md lk nj nk mf nl bi translated"><strong class="ak">守护线程:- </strong></h2><p id="08e5" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">在后台执行的线程被称为守护线程。</p><p id="b285" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">守护线程最好的例子是垃圾收集器线程。</p><p id="6564" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">每当 java 编程出现问题或任何内存问题时，垃圾收集器线程总是在后台执行，垃圾收集器线程会销毁无用的对象。</p><p id="7220" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">它的主要目的是为非守护线程提供支持。</p><p id="e510" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们可以通过使用 thread 类的以下方法来检查和设置线程的守护进程性质:</p><ol class=""><li id="4567" class="mm mn in kv b kw kx kz la lc mo lg mp lk mq lo mr ms mt mu bi translated">public boolean isDaemon()</li><li id="ea6b" class="mm mn in kv b kw mv kz mw lc mx lg my lk mz lo mr ms mt mu bi translated">public void setDaemon()</li></ol><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h2 id="22d1" class="na lq in bd lr nb nc dn lv nd ne dp lz lc nf ng mb lg nh ni md lk nj nk mf nl bi translated"><strong class="ak">同步:- </strong></h2><p id="4a20" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">如果多个线程对一个 java 对象进行操作，那么就会出现数据不一致的问题，这也被称为竞争条件。</p><p id="fd61" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">通过使用同步修饰符，我们可以消除这个数据不一致的问题。</p><p id="522b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Synchronized 修饰符只适用于方法和块。</p><p id="3667" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果一个方法或块被声明为 synchronized，那么一次只允许一个线程对给定对象上的该方法或块进行操作，因此不会有数据不一致的问题。</p><p id="17f0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果一个线程想要执行任何需要锁定该对象的同步线程，一旦该线程获得了该对象的锁定，那么该线程就可以对该对象执行 synchronized()。</p><p id="9cf3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">锁的获取和释放都在 JVM 的控制之下，作为一个程序员，我们不需要关心它。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h2 id="f446" class="na lq in bd lr nb nc dn lv nd ne dp lz lc nf ng mb lg nh ni md lk nj nk mf nl bi translated">感谢阅读</h2></div></div>    
</body>
</html>