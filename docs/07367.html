<html>
<head>
<title>Using template files in Rust for a GTK4 libadwaita UI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Rust 中为 GTK4 libadwaita UI 使用模板文件</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/using-template-files-in-rust-for-a-gtk4-libadwaita-ui-8322694cbc3c?source=collection_archive---------2-----------------------#2022-03-19">https://blog.devgenius.io/using-template-files-in-rust-for-a-gtk4-libadwaita-ui-8322694cbc3c?source=collection_archive---------2-----------------------#2022-03-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8c47d21808d813d9b982f80148c1ed28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sK3i7T4oD8paVp9f"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Kelly Sikkema </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="9782" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上次我们开始<a class="ae kc" href="https://raduzaharia.medium.com/initial-setup-for-a-gtk4-app-with-libadwaita-in-rust-using-vscode-b6f8c127a75e" rel="noopener">为 Rust GTK4 应用程序创建环境，该应用程序将成为 RSS 阅读器。因为我们处理了初始设置，所以 UI 只是使用代码创建的，只是为了查看它的构建和运行。当然，这种策略是不可持续的，因为它创建了大量的代码，并且创建了非常难以阅读和更改的界面。GTK 世界的解决方案是 UI 模板文件。让我们看看它是如何工作的。</a></p><p id="9f26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，你可以在<a class="ae kc" href="https://github.com/raduzaharia-medium/gtk-rss-reader-templates" rel="noopener ugc nofollow" target="_blank"> github </a>上找到这篇文章的代码。我们将改进之前的代码，您可以在这里找到<a class="ae kc" href="https://github.com/raduzaharia-medium/gtk-rss-reader-initial" rel="noopener ugc nofollow" target="_blank"/>。虽然可以将代码放在一个可以简单克隆的公共 git 存储库中，但是我建议您在阅读本文时自己编写代码，尤其是如果您有一些 Rust 知识的话。</p><h2 id="d5a2" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">更新后的 Cargo.toml 和 main.rs</h2><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lu"><img src="../Images/54d9aef2f6a84338d4b97acf364dc8e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N6EtelA3rQMqCZkX_QbHWA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Cargo.toml 文件中的新依赖项</figcaption></figure><p id="1c9c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们将使用更多的 GTK4 特性，所以我们需要在我们的<code class="fe lz ma mb mc b">Cargo.toml</code>文件中添加更多的依赖项:</p><pre class="lv lw lx ly gt md mc me mf aw mg bi"><span id="d5bf" class="lb lc iq mc b gy mh mi l mj mk">[dependencies]<br/>libadwaita = "*"<br/>gtk4 = "*"<br/>glib = "*"</span></pre><p id="8286" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从截图中，您已经可以看到一个新的文件夹结构。你可以看到带有<code class="fe lz ma mb mc b">main-window.ui</code>的<code class="fe lz ma mb mc b">content</code>文件夹。这将是我们的应用程序 UI 描述，接下来我们将看到它的样子。还有一个新的<code class="fe lz ma mb mc b">main_window</code>文件夹存放我们的窗口代码。接下来我们会看到这一切，但首先，让我们看看<code class="fe lz ma mb mc b">main.rs</code>现在是什么样子:</p><pre class="lv lw lx ly gt md mc me mf aw mg bi"><span id="6ed8" class="lb lc iq mc b gy mh mi l mj mk">mod main_window;<br/>use main_window::MainWindow;</span><span id="9f9f" class="lb lc iq mc b gy ml mi l mj mk">use gtk4::{<br/>    prelude::{ApplicationExt, ApplicationExtManual},<br/>    traits::WidgetExt,<br/>};<br/>use libadwaita::Application;</span><span id="89cf" class="lb lc iq mc b gy ml mi l mj mk">fn build_ui(application: &amp;Application) {<br/>    let window = MainWindow::new(application);<br/>    window.show();<br/>}</span><span id="3a6b" class="lb lc iq mc b gy ml mi l mj mk">pub fn main() {<br/>    let application = Application::builder()<br/>        .application_id("com.example.gtk-rss-reader")<br/>        .build();</span><span id="21a2" class="lb lc iq mc b gy ml mi l mj mk">    application.connect_activate(build_ui);<br/>    application.run();<br/>}</span></pre><p id="1210" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们在这里再也看不到任何 UI 代码。<code class="fe lz ma mb mc b">build_ui</code>函数只是实例化了<code class="fe lz ma mb mc b">MainWindow</code>结构，并将其显示在屏幕上。对于<code class="fe lz ma mb mc b">Application</code>设置，我们也使用构建器模式，而不是旧的模式:</p><pre class="lv lw lx ly gt md mc me mf aw mg bi"><span id="9681" class="lb lc iq mc b gy mh mi l mj mk">pub fn main() {<br/>    let application = Application::new(<br/>        Some("com.example.gtk-rss-reader"), Default::default()); </span><span id="6bf5" class="lb lc iq mc b gy ml mi l mj mk">    application.connect_activate(build_ui); <br/>    application.run();<br/>}</span></pre><h2 id="e6e0" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">主窗口 UI 模板</h2><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lu"><img src="../Images/b3106307bd0cc6e2dfd773e57fef0eef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G3lukaqTt8ebEtR-9Fx9fw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">用户界面已被移动到 XML 文件中</figcaption></figure><p id="3e27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们来看看大的变化。首先是<code class="fe lz ma mb mc b">main-window.ui</code>。使用模板文件进行 UI 定义的目的是获得 UI 的单一描述，而不是一组命令。这样，描述更容易阅读、更改和跟踪。<code class="fe lz ma mb mc b">.ui</code>文件使用的语言只是一组嵌套的对象和属性。我们将<code class="fe lz ma mb mc b">MainWindow</code>定义为<code class="fe lz ma mb mc b">AdwApplicationWindow</code>的后代，并添加一个带有<code class="fe lz ma mb mc b">AdwHeaderBar</code>和<code class="fe lz ma mb mc b">GtkButton</code>的<code class="fe lz ma mb mc b">GtkBox</code>孩子。除了按钮之外，所有这些都是我们之前在代码中所做的:</p><pre class="lv lw lx ly gt md mc me mf aw mg bi"><span id="ab59" class="lb lc iq mc b gy mh mi l mj mk">let content = libadwaita::gtk::Box::new(Orientation::Vertical, 0);</span><span id="d321" class="lb lc iq mc b gy ml mi l mj mk">content.append(&amp;HeaderBar::builder()                                     <br/>    .title_widget(&amp;WindowTitle::new("My GTK4 RSS Reader", ""))                                     <br/>    .build());</span></pre><p id="45dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，当您查看上面的代码片段并将其与闪亮的新 XML 进行比较时，您可能会认为用代码编写整个 UI 可能更容易。这当然是少写。但是我们需要记住的是，UI 现在什么都不做，看起来也不怎么样。随着我们不断添加 UI 组件，代码的复杂性将很快压倒冗长的 XML 描述。更不用说 XML diff 和代码 diff 之间更容易的版本跟踪了。</p><h2 id="a837" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">窗口用户界面代码</h2><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lu"><img src="../Images/3fb7b68ad5f9a934e4faf46f8fda22d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qt-swA_93flSPNZ_Ai0H5w.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">主窗口结构</figcaption></figure><p id="aaf6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有了模板，太好了。但是正如我们在<code class="fe lz ma mb mc b">main.rs</code>文件中看到的，我们想要实例化一个<code class="fe lz ma mb mc b">MainWindow</code>结构，因为你不能实例化 XML。为此，我们将创建一个名为<code class="fe lz ma mb mc b">main_window</code>的新 Rust 模块，我们在<code class="fe lz ma mb mc b">main.rs</code>中引用它，如下所示:</p><pre class="lv lw lx ly gt md mc me mf aw mg bi"><span id="0974" class="lb lc iq mc b gy mh mi l mj mk">mod main_window;<br/>use main_window::MainWindow;</span></pre><p id="a1ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Rust 模块由<code class="fe lz ma mb mc b">src</code>文件夹中的<code class="fe lz ma mb mc b">main_window</code>文件夹和<code class="fe lz ma mb mc b">main_window</code>文件夹中的<code class="fe lz ma mb mc b">mod.rs</code>文件组成。这是我们需要遵守的惯例。<code class="fe lz ma mb mc b">MainWindow</code>模块描述了结构的依赖树:</p><pre class="lv lw lx ly gt md mc me mf aw mg bi"><span id="2180" class="lb lc iq mc b gy mh mi l mj mk">wrapper! {<br/>    pub struct MainWindow(ObjectSubclass&lt;MainWindowTemplate&gt;) <br/>        @extends ApplicationWindow, Window, Widget,<br/>        @implements ActionGroup, ActionMap, Accessible, Buildable,<br/>            ConstraintTarget, Native, Root, ShortcutManager;<br/>}</span></pre><p id="a5a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的语法不是典型的 Rust 语法。Rust 没有用于结构的<code class="fe lz ma mb mc b">extends</code>和<code class="fe lz ma mb mc b">implements</code>。在<code class="fe lz ma mb mc b">glib</code>中定义的<code class="fe lz ma mb mc b">wrapper!</code>宏允许我们说我们的<code class="fe lz ma mb mc b">MainWindow</code>结构继承自<code class="fe lz ma mb mc b">ApplicationWindow</code>等等，并实现某些接口。还是那句话，Rust 没有这些概念。锈有结构和特性。这里所发生的是我们使用一个<code class="fe lz ma mb mc b">glib</code>宏来简化 GTK 窗口小部件和窗口的定义。</p><p id="4396" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还为我们的<code class="fe lz ma mb mc b">MainWindow</code>添加了一个构造函数:</p><pre class="lv lw lx ly gt md mc me mf aw mg bi"><span id="d002" class="lb lc iq mc b gy mh mi l mj mk">impl MainWindow {<br/>    pub fn new(app: &amp;Application) -&gt; Self { <br/>        Object::new(&amp;[("application", app)])<br/>            .expect("Failed to create `Window`.") <br/>    }<br/>}</span></pre><p id="98c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该构造函数在<code class="fe lz ma mb mc b">build_ui</code>函数的<code class="fe lz ma mb mc b">main.rs</code>中使用，并简单地创建了<code class="fe lz ma mb mc b">MainWindow</code>。但是模板如何链接到<code class="fe lz ma mb mc b">MainWindow</code>结构呢？<code class="fe lz ma mb mc b">main-window.ui</code>叫什么？</p><p id="9229" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">再次注意到<code class="fe lz ma mb mc b">wrapper!</code>呼叫。<code class="fe lz ma mb mc b">MainWindow</code>定义包含另一点可疑的语法:<code class="fe lz ma mb mc b">(ObjectSubclass&lt;MainWindowTemplate&gt;)</code>。再说一次，这不是正常的生锈。该括号由<code class="fe lz ma mb mc b">wrapper!</code>宏启用。他们指示 Rust 构建考虑到<code class="fe lz ma mb mc b">MainWindowTemplate</code>的<code class="fe lz ma mb mc b">MainWindow</code>结构。</p><h2 id="0c6b" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">模板代码</h2><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lu"><img src="../Images/5073c538aa1d07f7ce2ad428c1b09a29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M7xCV7k7dYG84kw5vxULgw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">将模板链接到主窗口的代码</figcaption></figure><p id="c1cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">抱歉巨大的截图。正如我所说的代码也可以在<a class="ae kc" href="https://github.com/raduzaharia-medium/gtk-rss-reader-templates" rel="noopener ugc nofollow" target="_blank"> github </a>上找到，但是我想把它作为截图放在这里，这样你就可以知道它应该是什么样子了。它的每一点都很重要，如果你弄乱了这个文件中的任何东西，不管有多小，这个项目都不会编译或者运行。尤其是<code class="fe lz ma mb mc b">use</code>声明是交易破坏者。</p><p id="0432" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，一切开始的<code class="fe lz ma mb mc b">MainWindowTemplate</code>定义:</p><pre class="lv lw lx ly gt md mc me mf aw mg bi"><span id="c6dc" class="lb lc iq mc b gy mh mi l mj mk">#[derive(CompositeTemplate, Default)]<br/>#[template(file = "../../content/main-window.ui")]<br/>pub struct MainWindowTemplate {<br/>    #[template_child]<br/>    pub button: TemplateChild&lt;Button&gt;,<br/>}</span></pre><p id="8aa1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">MainWindowTemplate</code>来源于<code class="fe lz ma mb mc b">CompositeTemplate</code>,后者需要某些实现，我们稍后会看到。但是看看<code class="fe lz ma mb mc b">#[template]</code>的定义。这里是我们最后指定用于窗口的模板的地方。它是一个位于根文件夹中的文件，在<code class="fe lz ma mb mc b">content</code>子文件夹中，名为<code class="fe lz ma mb mc b">main-window.ui</code>。这个结构包含什么？定义我们想要使用的<code class="fe lz ma mb mc b">main-window.ui</code> XML 的哪些部分。在这种情况下，按钮。通过这种方式，我们可以将监听器连接到它，这样我们就可以检测到点击。但这一切都在后面的文章里。</p><p id="95d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">CompositeTemplate</code>要求<code class="fe lz ma mb mc b">ObjectSubclass</code>实现:</p><pre class="lv lw lx ly gt md mc me mf aw mg bi"><span id="8140" class="lb lc iq mc b gy mh mi l mj mk">#[object_subclass]<br/>impl ObjectSubclass for MainWindowTemplate {<br/>    const NAME: &amp;'static str = "MainWindow";<br/>    <br/>    type Type = MainWindow;<br/>    type ParentType = ApplicationWindow;</span><span id="dbd8" class="lb lc iq mc b gy ml mi l mj mk">    fn class_init(my_class: &amp;mut Self::Class) {<br/>        Self::bind_template(my_class);<br/>    }</span><span id="8253" class="lb lc iq mc b gy ml mi l mj mk">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {<br/>        obj.init_template();<br/>    }<br/>}</span></pre><p id="8f88" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个相当通用的实现，你可以从<code class="fe lz ma mb mc b">main-window.ui</code>的模板中清除一些细节。<code class="fe lz ma mb mc b">NAME</code>常数来自该行的<code class="fe lz ma mb mc b">class</code>:</p><pre class="lv lw lx ly gt md mc me mf aw mg bi"><span id="33f0" class="lb lc iq mc b gy mh mi l mj mk">&lt;template class="MainWindow" parent="AdwApplicationWindow"&gt;</span></pre><p id="bac4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">ParentType</code>是来自上述同一行的<code class="fe lz ma mb mc b">parent</code>,但请注意不同之处。在 Rust 代码中，结构名是<code class="fe lz ma mb mc b">ApplicationWindow</code>，在 XML 中是<code class="fe lz ma mb mc b">AdwApplicationWindow</code>。如果我们不用<code class="fe lz ma mb mc b">libadwaita</code>而是直接用 GTK4，我们会写<code class="fe lz ma mb mc b">GtkApplicationWindow</code>。<code class="fe lz ma mb mc b">Type</code>是我们之前定义的<code class="fe lz ma mb mc b">MainWindow</code>结构。</p><p id="5a1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来的两个方法是通用的。它们只是初始化模板绑定，如果你不这样做，你会得到一个空窗口。</p><p id="05fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">CompositeTemplate</code>还要求通用<code class="fe lz ma mb mc b">ObjectImpl</code>实现:</p><pre class="lv lw lx ly gt md mc me mf aw mg bi"><span id="9f6d" class="lb lc iq mc b gy mh mi l mj mk">impl ObjectImpl for MainWindowTemplate {<br/>    fn constructed(&amp;self, obj: &amp;Self::Type) {<br/>        self.parent_constructed(obj);<br/>    }<br/>}</span></pre><p id="7ffa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们有按钮事件处理程序和其他功能代码的时候，我们会在这里写更多，但是现在上面已经足够了。然后是几个更空的实现，再次感谢<code class="fe lz ma mb mc b">CompositeTemplate</code>:</p><pre class="lv lw lx ly gt md mc me mf aw mg bi"><span id="e01b" class="lb lc iq mc b gy mh mi l mj mk">impl WidgetImpl for MainWindowTemplate {}<br/>impl WindowImpl for MainWindowTemplate {}<br/>impl ApplicationWindowImpl for MainWindowTemplate {}<br/>impl AdwApplicationWindowImpl for MainWindowTemplate {}</span></pre><p id="91e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这样。构建并运行:</p><pre class="lv lw lx ly gt md mc me mf aw mg bi"><span id="adec" class="lb lc iq mc b gy mh mi l mj mk">#cargo build<br/>#cargo run</span></pre><p id="c308" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意漂亮的空应用程序窗口:</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mm"><img src="../Images/a4d98d9da1763bbd064dc7c628fac241.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t0KEmjNtMiHs8ywZY2X6rQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">几乎空无一人的 GTK4 libadwaita 窗口</figcaption></figure></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><p id="2925" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">暂时就这样了。<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/bundling-templates-into-resources-in-rust-for-the-gtk4-ui-eb387a7918bf">下次</a>我们将学习如何将窗口资源与构建的可执行文件捆绑在一起。现在，模板作为一个简单的文件从文件系统中读取。如果你复制应用程序的可执行文件，你将不得不把模板带到任何地方，放在代码期望它所在的同一个文件夹中。不是理想的情况。但是下一次我们将看到 GTK 如何在应用程序可执行文件中提供对捆绑这些模板的支持，以便轻松地分发它们。</p><p id="5f48" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一如既往，如果您有任何问题，请在评论区提问。下次见！</p></div></div>    
</body>
</html>