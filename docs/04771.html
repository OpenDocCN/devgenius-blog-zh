<html>
<head>
<title>Four built-in Array methods that every JavaScript developer should know and use</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个 JavaScript 开发人员都应该知道和使用的四个内置数组方法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/four-built-in-array-methods-that-every-javascript-developer-should-know-and-use-941ca2f6829b?source=collection_archive---------3-----------------------#2021-05-04">https://blog.devgenius.io/four-built-in-array-methods-that-every-javascript-developer-should-know-and-use-941ca2f6829b?source=collection_archive---------3-----------------------#2021-05-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="747a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">JavaScript 以其许多突出的特性而闻名，其中之一当然不是其标准库中的过多方法。这个规则的一个例外是数组对象原型中的方法——JavaScript 提供了处理数据所需的一切。让我们看看商店里有什么！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bb97cae3fadd706a1b3a9083c75dbfaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YsohVtXPzsCibbNH"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@eugenezhyvchik?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">尤金·日夫奇克</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="2636" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">为每一个</h1><p id="78b5" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">这可能是最直接的内置方法，也是每个人开始使用的第一个方法。最简单地说，它与 for 循环做同样的事情，但是性能稍差。它可能会提供额外的可读性(但不是免费的——通常是更有效的一种<code class="fe mc md me mf b">for loop</code>)。让我们考虑下面的例子，假设<code class="fe mc md me mf b">someFunction</code>是一个函数，它接受单个<code class="fe mc md me mf b">number</code>并执行某种副作用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="08d9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这可以替换为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="5c8a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因为它不是在<code class="fe mc md me mf b">for loop</code>中完成的，而是在传递给方法的回调中完成的，所以可读性可以进一步提高:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="9492" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是一个细心的读者会注意到最后一个例子中有些地方不太对劲——回调函数中似乎有太多的东西。这是做这件事的最好方法吗？肯定不会。这直接把我们带到了列表中的另一个方法，叫做</p><h1 id="d65a" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">过滤器</h1><p id="8287" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">这怎么能帮助我们呢？让我们看看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="9768" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种方法带来了一个明显的好处——上一个例子中使用的回调被分成了两个原子函数。事实上，第二个函数(<code class="fe mc md me mf b">callSomeFunction</code>)是从另一个模块导入的未修改的函数，这使得它更简单，可读性更好。</p><p id="4429" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mc md me mf b">filter</code>是如何工作的？它遍历数组并返回一个新数组，该数组仅由传递给<code class="fe mc md me mf b">filter</code>的回调返回一个<em class="mi">真值</em>的元素填充。</p><p id="5163" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如在开始提到的，所有显示使用<code class="fe mc md me mf b">forEach</code>方法的例子都假设数据将被用于执行某种副作用。但是如果我们只是需要数据转换呢？第一种方法肯定是</p><h1 id="a7d3" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">地图</h1><p id="1038" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">它是如何工作的？它接受一个回调函数，并返回一个与原始数组大小相同的新数组<strong class="jm io"/><strong class="jm io">【always】</strong>，每个元素都是原始数组中相同位置的一个元素，但其值被回调函数改变了。咻，这听起来很复杂，但实际上并不复杂。假设我们需要给数组的每个元素加 7。首先，让我们试着用一个<code class="fe mc md me mf b">for loop</code>来做这件事:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="11ac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">同样可以使用<code class="fe mc md me mf b">map</code>来完成:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="ef0a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这样更简洁，可读性更好，那只是一个变换！很容易想象一个包含几个步骤的用例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="74dc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本例中，数组中的每个元素如果高于 150，则衰减到 150，如果低于 50，则衰减到 50，然后所有结果都乘以 1.2。由于<code class="fe mc md me mf b">map</code>返回了<code class="fe mc md me mf b">Array</code>对象的一个实例，从而允许方法链接，这在使用不同的内置方法时特别有用，因此可以按顺序执行这些转换:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="77cb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本节中的所有例子都假设在转换一个数组的元素时，返回的数组与原始数组具有相同数量的元素——在最基本的用例中,<code class="fe mc md me mf b">map</code>以一种隔离的方式转换元素。由于需求的原因，这并不总是可能的，如果需要打破这种隔离，那么最好的方法就是调用</p><h1 id="7ed2" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">减少</h1><p id="4a44" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">这是<em class="mi">T21，内置方法的瑞士军刀——T5。对于<code class="fe mc md me mf b">Array</code>方法来说，这与<code class="fe mc md me mf b">NAND</code>对于逻辑运算来说几乎是一样的——大多数内置方法都可以使用<code class="fe mc md me mf b">reduce</code>来重新实现。<code class="fe mc md me mf b">map</code>？简单。<code class="fe mc md me mf b">find</code>？不努力。<code class="fe mc md me mf b">every</code>、<code class="fe mc md me mf b">includes</code>、<code class="fe mc md me mf b">flatMap</code>？所有这些(以及更多)都可以使用<code class="fe mc md me mf b">reduce</code>来实现——唯一的问题是，应该这样做吗？最后一个例子很容易实现，我看到人们使用<code class="fe mc md me mf b">reduce</code>最常见的问题是不知道何时正确使用它。</em></p><p id="a6a1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们考虑一下过滤 IT 人员的最后一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="22f2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这没那么糟糕，但是使用链接的方法(至少在我看来)可读性更好，特别是如果用于过滤器和映射的回调保存在项目范围的助手文件中。</p><p id="9d73" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里的主要经验是:如果你想声明一个临时变量，并根据数组的长度在 for 循环中改变它的值，你应该使用<code class="fe mc md me mf b">reduce</code>。让我们考虑一下<code class="fe mc md me mf b">reduce</code>最常见的用法——数组内容的求和。而不是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="1678" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">同样可以通过以下方式实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="566e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里发生了什么？<code class="fe mc md me mf b">reduce</code>接受两个参数。第一个是用于迭代数组并将结果传递给下一次迭代的函数，第二个是结果的初始值——最直观的是数字，但也可以是字符串、数组或对象。让我们考虑下面的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="4fa8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">或者下面这个:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="36c0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mc md me mf b">reduce</code>肯定需要一些努力来理解它，但绝对值得一试——看看它有多强大！</p><p id="4c81" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">今天到此结束，谢谢你读到这里！还有——你最喜欢的内置<code class="fe mc md me mf b">Array</code>方法是什么？请在评论中告诉我！</p></div><div class="ab cl mj mk hr ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ig ih ii ij ik"><p id="05bc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我指导软件开发人员。请在<a class="ae ky" href="https://mentorcruise.com/mentor/piotrjaworski/" rel="noopener ugc nofollow" target="_blank"> MentorCruise </a>上给我留言进行长期指导，或者在<a class="ae ky" href="https://www.codementor.io/@piotrjaworski" rel="noopener ugc nofollow" target="_blank">共同导师</a>上留言进行个别指导。</p></div></div>    
</body>
</html>