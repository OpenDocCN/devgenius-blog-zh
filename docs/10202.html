<html>
<head>
<title>How to Use Enum.find in Elixir</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在 Elixir 中使用 Enum.find</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-use-enum-find-in-elixir-40e103e4c969?source=collection_archive---------8-----------------------#2022-10-14">https://blog.devgenius.io/how-to-use-enum-find-in-elixir-40e103e4c969?source=collection_archive---------8-----------------------#2022-10-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b40a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在 Elixir 的集合中查找值的最佳方法是什么？如果您习惯于 C 或 JavaScript 等非函数式语言，您可能会考虑使用 for 循环。但是 Elixir 的功能性质意味着我们必须采取不同的方法:函数<em class="kl"> Enum.find </em>。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/5cf2e5c6484565eef712051f065c9bed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2Qqkn6zl3cymiyEv"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">由<a class="ae lc" href="https://unsplash.com/@markuswinkler?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马库斯·温克勒</a>在<a class="ae lc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="1e37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">函数<em class="kl"> Enum.find </em>(以及它的朋友<em class="kl"> Enum.find_index </em>和<em class="kl"> Enum.find_value </em>)适用于任何实现了<a class="ae lc" href="https://hexdocs.pm/elixir/1.14.1/Enumerable.html" rel="noopener ugc nofollow" target="_blank"> <em class="kl">可枚举</em> </a> <em class="kl"> </em>协议的类型，最显著的是<a class="ae lc" href="https://hexdocs.pm/elixir/1.14.1/List.html" rel="noopener ugc nofollow" target="_blank"> <em class="kl"> List </em> </a>、<a class="ae lc" href="https://hexdocs.pm/elixir/1.14.1/Map.html" rel="noopener ugc nofollow" target="_blank"> <em class="kl"> Map </em> </a>和<a class="ae lc" href="https://hexdocs.pm/elixir/1.14.1/Range.html" rel="noopener ugc nofollow" target="_blank"> <em class="kl"> Range </em> </a> <em class="kl">。对于本文中的例子，我们将坚持使用简单的列表。</em></p><h1 id="d19b" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">寻找简单的值</h1><p id="4974" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">为了在可枚举的中找到一个值，我们使用可枚举的数据和一个查找函数调用<em class="kl"> Enum.find </em>:</p><pre class="kn ko kp kq gt mg mh mi mj aw mk bi"><span id="cedf" class="ml le iq mh b gy mm mn l mo mp">e = [5, 10, 15]<br/>Enum.find(e, fn v -&gt; v == 10 end)</span><span id="558b" class="ml le iq mh b gy mq mn l mo mp">=&gt; 10</span></pre><p id="dbe1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果找不到我们要找的值，我们将得到<em class="kl"> nil </em>:</p><pre class="kn ko kp kq gt mg mh mi mj aw mk bi"><span id="7f0e" class="ml le iq mh b gy mm mn l mo mp">e = [5, 10, 15]<br/>Enum.find(e, &amp;(&amp;1 == 11))</span><span id="e7de" class="ml le iq mh b gy mq mn l mo mp">=&gt; nil</span></pre><h1 id="a586" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">查找索引:Enum.find_index</h1><p id="9013" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">如果我们感兴趣的是<em class="kl">一个条目出现在可枚举的什么位置</em>，我们可以使用<em class="kl"> Enum.find_index: </em></p><pre class="kn ko kp kq gt mg mh mi mj aw mk bi"><span id="c8cf" class="ml le iq mh b gy mm mn l mo mp">e = [5, 10, 15]<br/>Enum.find_index(e, fn v -&gt; v == 10 end)</span><span id="e2b4" class="ml le iq mh b gy mq mn l mo mp">=&gt; 1</span></pre><h1 id="cc24" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">使用地图查找</h1><p id="8e53" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">当我们用一个<em class="kl">映射调用<em class="kl"> Enum.find </em>时，</em>我们得到一个元组，其中包含一个键和一个传递给我们的 finder 函数的值:</p><pre class="kn ko kp kq gt mg mh mi mj aw mk bi"><span id="d5ed" class="ml le iq mh b gy mm mn l mo mp">e = %{a: 5, b: 10, c: 15}<br/>Enum.find(e, fn {k, v} -&gt; k == :b end)</span><span id="c015" class="ml le iq mh b gy mq mn l mo mp">=&gt; {:b, 10}</span></pre><p id="28fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(旁注，因为我们没有使用元组中的值<em class="kl"> v </em>，我们可能会得到一个未使用的变量警告。我们真的应该把它命名为<em class="kl"> _v </em>，但是为了便于说明，我们把它放在一边。</p><p id="b5ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">返回的值当然也是包含键和值的元组。这可能不是你想要发生的，但是下一节关于<em class="kl"> Enum.find_value </em>的内容将帮助我们解决这个问题。</p><h1 id="eae2" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">查找和转换值:Enum.find_value</h1><p id="d76e" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">在前面的例子中，我们得到了一个表示键和值的元组，但是如果我们实际上只想要元组中的一个元素呢？我们可以使用<em class="kl"> Enum.find_value </em>:</p><pre class="kn ko kp kq gt mg mh mi mj aw mk bi"><span id="79ee" class="ml le iq mh b gy mm mn l mo mp">e = %{a: 5, b: 10, c: 15}<br/>Enum.find_value(e, fn {k, v} -&gt; if k == :b, do: v, else: nil end)</span><span id="36df" class="ml le iq mh b gy mq mn l mo mp">=&gt; v</span></pre><h1 id="652d" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">使用捕获运算符(&amp;)查找</h1><p id="4b51" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">在我们到目前为止使用的所有示例中，我们都是这样编写测试函数的:</p><pre class="kn ko kp kq gt mg mh mi mj aw mk bi"><span id="636d" class="ml le iq mh b gy mm mn l mo mp">fn v -&gt; some_test(v) end</span></pre><p id="926e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是我们可以用捕捉操作符(&amp;)来简化。我们可以这样重写上面的函数:</p><pre class="kn ko kp kq gt mg mh mi mj aw mk bi"><span id="33bc" class="ml le iq mh b gy mm mn l mo mp">&amp;some_test(&amp;1)</span></pre><p id="de46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，函数参数被捕获为<em class="kl"> &amp; 1、&amp; 2、</em>等，尽管<em class="kl"> </em>和<em class="kl">enum . find</em>finder 函数只接受一个参数。所以改写一下我们之前的一个例子:</p><pre class="kn ko kp kq gt mg mh mi mj aw mk bi"><span id="9e32" class="ml le iq mh b gy mm mn l mo mp">e = [5, 10, 15]<br/>Enum.find(e, &amp;(&amp;1 == 10))</span><span id="a884" class="ml le iq mh b gy mq mn l mo mp">=&gt; 10</span></pre><h1 id="cdfc" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">额外收获:如何从头开始构建 Find</h1><p id="46db" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">我们一开始提到一些语言会使用 for 循环来实现这个功能，我们应该使用<em class="kl"> Enum.find </em>来代替。但是我们不想让人觉得<em class="kl"> Enum.find </em>是某种神奇的黑盒。让我们看看我们如何在 Elixir 中实现这个功能。</p><p id="2072" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们下面的实现使用了一种常见的函数模式<em class="kl">递归</em>，而不是一个在<em class="kl">列表中查找值的循环。</em>为了简单起见，我们将忽略本例中的其他<em class="kl">枚举数</em>。</p><p id="86d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它还使用了另一种常见的灵丹妙药习语，即函数输入上的<em class="kl">模式匹配</em>:如果列表为空，则答案始终为零。否则，我们对列表的第一项(v)和列表的其余部分进行模式匹配。如果对值<em class="kl"> v </em>的测试匹配，我们就找到了答案——否则，我们递归调用:</p><pre class="kn ko kp kq gt mg mh mi mj aw mk bi"><span id="4f96" class="ml le iq mh b gy mm mn l mo mp">defmodule ListUtil do<br/>  def find([], _), do<br/>    nil<br/>  end</span><span id="3775" class="ml le iq mh b gy mq mn l mo mp">  def find([v | rest], f) do<br/>    # invoke the test function on the first value in the list<br/>    if f.(v),  do: v, else: find(rest, f)<br/>  end<br/>end</span><span id="3ff9" class="ml le iq mh b gy mq mn l mo mp"># test our implementation<br/>ListUtil.find([1,2,3], fn i -&gt; i == 2 end)</span></pre><p id="b7ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样！虽然大多数时候您可以使用<em class="kl"> Enum.find </em>做您需要做的事情，但是如果需要迭代其他类型的数据结构，了解如何在 Elixir 中处理这类问题是很好的。</p><p id="77db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">原载于</em><a class="ae lc" href="https://blixtdev.com/how-to-use-enum-find-in-elixir/" rel="noopener ugc nofollow" target="_blank"><em class="kl">Blixtdev</em></a>。</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><p id="ae86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Jonathan 在大型和小型创业公司中拥有超过 20 年的工程领导经验。如果你喜欢这篇文章，请考虑加入 Medium 来支持 <a class="ae lc" href="https://medium.com/@jonnystartup/membership" rel="noopener"> <em class="kl">乔纳森和其他成千上万的作者</em> </a> <em class="kl">。</em></p></div></div>    
</body>
</html>