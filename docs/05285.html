<html>
<head>
<title>Data structures exercise: LRU cache in Java, with TDD</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据结构练习:Java中的LRU缓存，带TDD</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/data-structures-exercise-lru-cache-in-java-with-tdd-b61687da866?source=collection_archive---------3-----------------------#2021-07-13">https://blog.devgenius.io/data-structures-exercise-lru-cache-in-java-with-tdd-b61687da866?source=collection_archive---------3-----------------------#2021-07-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1dde8956275fd62c3bc472a9a95857bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hZCSKhPTkBLzAzH1"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">也许这不是LRU藏身地的最佳视觉比喻...照片由<a class="ae kc" href="https://unsplash.com/@eric_w1?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">埃里克·温特</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="067a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">改造现有的数据结构是一个很好的计算机编程练习。今天，我们将使用测试驱动开发(TDD)方法，在Java中制作一个最近最少使用的(LRU)缓存。</p><p id="6ca8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">LRU缓存本质上是一个固定容量的队列，保存名称-值对。当一个名称-值对被添加到缓存中时，它被添加到队列的前面(或者它被添加到末尾，然后立即移动到前面)。</p><p id="46d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">名称是检索值的关键字。当使用名称从LRU缓存中检索值时，如果名称-值对不在队列的前面，则将其移动到队列的前面。</p><p id="4b55" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当缓存已满时，仍然可以添加新的名称-值对，即使容量不会像其他数据结构(如数组支持的列表)那样扩展。</p><p id="31fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无论队列末尾的名称-值对是什么，最近最少使用的名称-值对都被移除(或“驱逐”或“遗忘”)，以便为新的名称-值对腾出空间。</p><p id="5423" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">理想情况下，名称类型是一个引用类型，实例化和比较相等性的成本非常低(比如像<code class="fe lb lc ld le b">Integer</code>这样的原始包装)。</p><p id="1fb5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">值类型是一种引用类型，重新计算起来应该非常昂贵，比如可能因为它需要数据库检索或互联网连接。如果重新计算会更快，那么从缓存中检索就不值得了。</p><p id="0fe5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管没有任何东西禁止我们对名称和值使用相同的类型。出于测试目的，我们可能会这样做。</p><p id="005b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">举个例子，假设我们正在用Java编写一个Web浏览器。我们可能使用<code class="fe lb lc ld le b">java.net.URL</code>作为名称，我们可能使用某种文档对象类型作为值。</p><p id="4955" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果用户打开了一堆标签页，并且忽略了其中的一个足够长的时间，当他或她回到那个被遗忘的标签页时，网络浏览器必须重新连接到互联网以重新获得HTML内容。</p><p id="25f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是最近使用的选项卡位于缓存的前端，当用户频繁地在这些选项卡上来回移动时，就可以提供这些选项卡了。这只是为了举例，因为网页浏览器可能不是LRU缓存的最佳用例。</p><p id="53ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据您使用的Java开发工具包(JDK)的版本，您可能会发现<code class="fe lb lc ld le b">java.util.Scanner</code>使用<code class="fe lb lc ld le b">sun.misc.LRUCache</code>来缓存正则表达式模式。</p><p id="046f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">给定的类可能会频繁调用<code class="fe lb lc ld le b">Scanner</code>实例的<code class="fe lb lc ld le b">nextInt()</code>和<code class="fe lb lc ld le b">nextDouble()</code>函数。那么适当的正则表达式应该在LRU缓存的前面，而<code class="fe lb lc ld le b">Scanner</code>实例可能需要的其他正则表达式在LRU缓存的后面，如果它们在那里的话。</p><p id="1392" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想在你自己的项目中使用<code class="fe lb lc ld le b">sun.misc.LRUCache</code>，你当然可以导入它。但是您会得到一个警告，让您知道这是一个专有类，将来可能会被删除。</p><p id="390d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个警告可以被抑制，但是需要一个大的规避来抑制它。一般来说，你最好留意警告，而不是压制或忽视它们。</p><p id="cce1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您的项目绝对必须有一个LRU缓存，您应该考虑获得一个第三方LRU缓存，这样您就知道它是可靠的、真实的，可能是专有的，但意味着由开发它的组织之外的人使用。</p><p id="ba29" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，作为一项编程练习，从头开始编写自己的程序肯定是值得的。尽管可以随意将<code class="fe lb lc ld le b">sun.misc.LRUCache</code>作为一个模型，或者如果您在自己的实现中遇到问题。</p><p id="76e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里有一个骨架:</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="b5db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你愿意，你可以把这个包命名为“<code class="fe lb lc ld le b">org.example.collections</code>”或者类似的名字，而不仅仅是“<code class="fe lb lc ld le b">collections</code>”</p><p id="a9dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此时，最小和最大容量常数仅供参考。如您所见，构造函数实际上并不强制约束。我们应该在某个时候为此编写测试。</p><p id="a9b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">显然，最小容量必须是一个正整数。但是1没有任何意义，因为这意味着一个名称-值对只保留在缓存中，直到添加下一个名称-值对。我认为4是有意义的最小容量。</p><p id="5466" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">至于最大容量，我不确定。在我查看的JDK源代码中，<code class="fe lb lc ld le b">Scanner</code>声明了一个容量为7的模式缓存。因此，我认为128人的最大容量应该足以满足大多数(如果不是所有)目的。</p><p id="5343" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，这是一个抽象类。这里只有一个抽象子程序，抽象函数<code class="fe lb lc ld le b">create()</code>，就像<code class="fe lb lc ld le b">sun.misc.LRUCache</code>一样。具体的子类必须定义<code class="fe lb lc ld le b">create()</code>，但是这个函数可能只能从<code class="fe lb lc ld le b">LRUCache</code>调用。</p><p id="7766" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">即便如此，<code class="fe lb lc ld le b">create()</code>需要受保护的访问，而不是包私有访问，这样它就可以被<code class="fe lb lc ld le b">collections</code>包之外的类实现。</p><p id="d437" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当一个不在缓存中的名字被调用时，<code class="fe lb lc ld le b">retrieve()</code>函数调用<code class="fe lb lc ld le b">create()</code>计算出相应的值放入队列中(在<code class="fe lb lc ld le b">sun.misc.LRUCache</code>中，<code class="fe lb lc ld le b">retrieve()</code>被称为<code class="fe lb lc ld le b">forName()</code>)。</p><p id="b752" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，如果名称在缓存中，则只需从缓存中检索相应的值，并将其返回给调用者，但是需要在某个地方显示最近的检索。</p><p id="55de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我省略了抽象的布尔函数<code class="fe lb lc ld le b">hasName()</code>。对于想要使用我们的<code class="fe lb lc ld le b">LRUCache</code>的人来说，工作量减少了，但是对于我们来说，工作量增加了，而且将来可能会有性能损失。</p><p id="1c3d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">布尔<code class="fe lb lc ld le b">has()</code>函数是我为了使测试更容易而添加的。它是包私有的，所以它可以被<code class="fe lb lc ld le b">LRUCacheTest</code>访问，但是不能被其他包中的类访问。其他包中的类不应该访问<code class="fe lb lc ld le b">LRUCache</code>的内部工作。</p><p id="4dba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们实际编写<code class="fe lb lc ld le b">retrieve()</code>函数时(目前它只返回null)，我们可以利用<code class="fe lb lc ld le b">has()</code>函数。也许是，也许不是，到了那里就知道了。</p><p id="1584" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">按照<code class="fe lb lc ld le b">sun.misc.LRUCache</code>模型，我们还需要一个私有的静态过程，将指定索引处的数组元素移动到数组的前面。但是我们需要首先编写测试。</p><p id="bea6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里是<code class="fe lb lc ld le b">LRUCacheTest</code>的骨架:</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="df70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我用的是JUnit 5。如果您正在使用JUnit 4，您将需要更改导入语句(例如，import <code class="fe lb lc ld le b">org.junit.Test</code>)。</p><p id="a842" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个测试类包含了一个私有的<code class="fe lb lc ld le b">collections.LRUCache</code>实现，它很像<code class="fe lb lc ld le b">Scanner</code>中<code class="fe lb lc ld le b">sun.misc.LRUCache</code>的匿名实现，直到名字和值类型的选择。</p><p id="7432" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管如此，还是有一些重要的区别。首先，我们需要能够调用不同大小的<code class="fe lb lc ld le b">LRUCacheImpl</code>构造函数(比如测试最小和最大容量约束)。这意味着我们必须写一个构造函数。</p><p id="6e73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还要注意初始化为0的<code class="fe lb lc ld le b">createCallCount</code>字段。每次调用<code class="fe lb lc ld le b">create()</code>时，它都会增加<code class="fe lb lc ld le b">createCallCount</code>。因此，如果<code class="fe lb lc ld le b">LRUCache</code>实例调用<code class="fe lb lc ld le b">create()</code>来重新计算一个值，而它本应该从队列中检索这个值，那么测试可以查询<code class="fe lb lc ld le b">createCallCount</code>并看到它增加了。</p><p id="d4ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们几乎准备好开始编写测试了。我将从Harsha Vardhan的<a class="ae kc" href="https://javascript.plainenglish.io/the-7-most-commonly-used-regular-expressions-in-javascript-bb4e98288ca6" rel="noopener ugc nofollow" target="_blank">最有用正则表达式的优秀列表</a>中抽取一些正则表达式。</p><p id="0c41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然那篇文章是为JavaScript程序员准备的，但是正则表达式语法是相同的。Java和JavaScript中的正则表达式是有区别的，但是我们不应该太在意这些区别。</p><p id="0ea0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我也想出了一些自己的正则表达式。如果本文中的正则表达式不是最聪明或最有效的，它可能是我想到的一个。</p><p id="9f3a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不必使用真实世界的例子来进行测试，我们可以创建一些虚拟类来进行测试。但是我更喜欢让我的测试比那更真实一些。</p><p id="29ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是第一个测试:</p><pre class="lf lg lh li gt ll le lm ln aw lo bi"><span id="44fd" class="lp lq iq le b gy lr ls l lt lu">    @Test<br/>    void testAddToCache() {<br/>        LRUCacheImpl cache = new LRUCacheImpl(DEFAULT_SIZE);<br/>        String expected = "^[a-zA-Z0–9+_.-]+@[a-zA-Z0–9.-]+$";<br/>        String actual = cache.retrieve(expected).pattern();<br/>        assertEquals(expected, actual);<br/>    }</span></pre><p id="7ce7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您使用的是JUnit 4，您需要将测试公开，而不是将包私有。</p><p id="d7e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正则表达式用于电子邮件地址验证(Harsha列出的最有用的正则表达式中的第二个)。</p><p id="d927" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于<code class="fe lb lc ld le b">Pattern</code>没有从<code class="fe lb lc ld le b">Object</code>覆盖<code class="fe lb lc ld le b">equals()</code>，我们需要依靠<code class="fe lb lc ld le b">String</code>比较。</p><p id="4641" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行它，看到它失败，因为<code class="fe lb lc ld le b">retrieve()</code>返回null而不是我们想要的正则表达式。不，实际上这个测试会导致一个空指针异常。</p><p id="b5ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这算不算测试失败？可能不是，因为<code class="fe lb lc ld le b">NullPointerException</code>不是<code class="fe lb lc ld le b">AssertionError</code>的实例。</p><p id="b12b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是如果你对这类事情不是超级教条主义者，那么继续让测试通过(我们会看到很多其他测试干净利落地失败)。</p><pre class="lf lg lh li gt ll le lm ln aw lo bi"><span id="5c46" class="lp lq iq le b gy lr ls l lt lu">    public V retrieve(N name) {<br/>        return <strong class="le ir">this.create(name);</strong><br/>    }</span></pre><p id="7210" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">应该可以了。但是当然<code class="fe lb lc ld le b">LRUCache</code>此时没有缓存任何东西。如果以相同的名称调用<code class="fe lb lc ld le b">retrieve()</code>两次，将重新计算该值，而不是从缓存中检索。因此这个测试:</p><pre class="lf lg lh li gt ll le lm ln aw lo bi"><span id="5fa4" class="lp lq iq le b gy lr ls l lt lu">    @Test<br/>    void testRetrieve() {<br/>        LRUCacheImpl cache = new LRUCacheImpl(DEFAULT_SIZE);<br/>        String romanName = "^(?=[MDCLXVI])M*(C[MD]|D?C{0,3})" <br/>                + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$";<br/>        Pattern expected = cache.retrieve(romanName);<br/>        Pattern actual = cache.retrieve(romanName);<br/>        assertEquals(expected, actual);<br/>    }</span></pre><p id="9cd7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这次的模式是验证罗马数字(这一个不是来自Harsha的列表)。</p><p id="ab07" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于模式应该在第二次从缓存中检索，我们可以在这个测试中使用引用相等。我开始怀疑我们是否真的需要<code class="fe lb lc ld le b">createCallCount</code>，或者<code class="fe lb lc ld le b">has()</code>函数。</p><p id="7556" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">测试彻底失败了，因为模式每次都要重新编译。</p><blockquote class="lv lw lx"><p id="53e3" class="kd ke ly kf b kg kh ki kj kk kl km kn lz kp kq kr ma kt ku kv mb kx ky kz la ij bi translated">org . opentest4j . assertionfailederror:应为:Java . util . regex .<strong class="kf ir">pattern @ 66480 DD 7</strong>&lt;^(？=[MDCLXVI])M*(C[MD]|D？C{0，3})(X[CL]|L？X{0，3})(I[XV]|V？I{0，3})$ &gt;却被:Java . util . regex .<strong class="kf ir">pattern @ 52a 86356</strong>&lt;^(？=[MDCLXVI])M*(C[MD]|D？C{0，3})(X[CL]|L？X{0，3})(I[XV]|V？我{0，3})$ &gt; <br/>期待:^(？=[MDCLXVI])M*(C[MD]|D？C{0，3})(X[CL]|L？X{0，3})(I[XV]|V？I{0，3})$ <br/>实际:^(？=[MDCLXVI])M*(C[MD]|D？C{0，3})(X[CL]|L？X{0，3})(I[XV]|V？I{0，3})$</p></blockquote><p id="16af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在您的机器上，散列码几乎肯定会不同，但总体结果是相同的:模式是重新创建的，而不是从缓存中检索的。</p><p id="d4f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们已经看到这个测试因为正确的原因而失败，所以我们可以确信它只会在应该通过的时候通过。</p><p id="0654" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要添加一些东西来保存这些值。参照<code class="fe lb lc ld le b">sun.misc.LRUCache</code>，我们看到Sun团队简单地使用了一个数组。我将使用两个数组，一个用于名称，一个用于值。</p><p id="151a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你只想用一个阵，像太阳队，参考<code class="fe lb lc ld le b">sun.misc.LRUCache</code>。只有Mark Reinhold被列为作者，但我相信这是一个团队的努力。</p><p id="8664" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将这些字段添加到<code class="fe lb lc ld le b">collections.LRUCache</code>:</p><pre class="lf lg lh li gt ll le lm ln aw lo bi"><span id="a2e0" class="lp lq iq le b gy lr ls l lt lu">    private final Object[] names;<br/>    private final Object[] values;</span><span id="d235" class="lp lq iq le b gy mc ls l lt lu">    private final int capacity;</span><span id="98b2" class="lp lq iq le b gy mc ls l lt lu">    private final int lastIndex;</span><span id="e217" class="lp lq iq le b gy mc ls l lt lu">    private int nextUp = 0;</span></pre><p id="d8e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我想分别制作<code class="fe lb lc ld le b">N[]</code>和<code class="fe lb lc ld le b">V[]</code>类型的<code class="fe lb lc ld le b">names</code>和<code class="fe lb lc ld le b">values</code>。如果我这样做，IntelliJ IDEA会给出未检查的强制转换警告，而Apache NetBeans不会。不知道为什么。所以我决定继续把它们都做成类型<code class="fe lb lc ld le b">Object[]</code>。</p><p id="ea36" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，修改构造函数如下:</p><pre class="lf lg lh li gt ll le lm ln aw lo bi"><span id="1e52" class="lp lq iq le b gy lr ls l lt lu">    public LRUCache(int size) {<br/>        // TODO: Throw exception if size &lt; MINIMUM_CAPACITY<br/>        // TODO: Throw exception if size &gt; MAXIMUM_CAPACITY<br/>        <strong class="le ir">this.capacity = size;<br/>        this.names = new Object[this.capacity];<br/>        this.values = new Object[this.capacity];<br/>        this.lastIndex = this.capacity - 1;</strong><br/>    }</span></pre><p id="529f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并将<code class="fe lb lc ld le b">retrieve()</code>修改成这样:</p><pre class="lf lg lh li gt ll le lm ln aw lo bi"><span id="024a" class="lp lq iq le b gy lr ls l lt lu">    public V retrieve(N name) {<br/>        <strong class="le ir">V value;<br/>        if (this.nextUp &gt; 0 &amp;&amp; name.equals(this.names[0])) {<br/>            value = (V) this.values[0];<br/>        } else {<br/>            value = this.create(name);<br/>            this.names[0] = name;<br/>            this.values[0] = value;<br/>            this.nextUp++;<br/>        }<br/>        return value;</strong><br/>    }</span></pre><p id="7e2a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看来我只是推迟了未检查的演员警告。我确实在寻找适当的方式来处理那个警告时被转移了方向。到目前为止，我还没有找到一种优雅的方式来摆脱这种困境。我想我们必须小心这里的类型系统。</p><p id="0b1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">至少这通过了测试。但是缓存只能保存一个值。所以我们写下一个测试:</p><pre class="lf lg lh li gt ll le lm ln aw lo bi"><span id="6da4" class="lp lq iq le b gy lr ls l lt lu">    @Test<br/>    void testCacheRetainsValueWhileCapacityAvailable() {<br/>        LRUCacheImpl cache <br/>                = new LRUCacheImpl(LRUCache.MINIMUM_CAPACITY);<br/>        String timeName = "^(?:\\d|[01]\\d|2[0-3]):[0-5]\\d$";<br/>        Pattern expected = cache.retrieve(timeName);<br/>        for (int i = 1; i &lt; LRUCache.MINIMUM_CAPACITY; i++) {<br/>            String fillerName = "^" + i + "*$";<br/>            cache.retrieve(fillerName);<br/>        }<br/>        Pattern actual = cache.retrieve(timeName);<br/>        assertEquals(expected, actual);<br/>    }</span></pre><p id="5422" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个正则表达式用于24小时格式的时间(例如，07:25，16:08)。放入缓存中。那么剩余的高速缓存容量被不太有用的模式填满。时间模式应该还在缓存中。</p><p id="9b00" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但这并没有发生，因为我们的缓存只使用了数组的第一个片段。我们可以简单地通过重写<code class="fe lb lc ld le b">retrieve()</code>来一次一个槽地填充数组来通过这个测试。现在考虑将名称-值对移到数组的前面还为时过早。</p><pre class="lf lg lh li gt ll le lm ln aw lo bi"><span id="7916" class="lp lq iq le b gy lr ls l lt lu">    public V retrieve(N name) {<br/>        <strong class="le ir">Object currName;</strong><br/>        V value;<br/>        <strong class="le ir">boolean notFound = true;<br/>        int index = 0;<br/>        while (notFound &amp;&amp; index &lt; this.nextUp) {<br/>            currName = this.names[index];<br/>            if (currName.equals(name)) {<br/>                notFound = false;<br/>            }<br/>            index++;<br/>        }<br/>        if (!notFound) {<br/>            value = (V) this.values[index - 1];<br/>        } else {<br/>            value = this.create(name);<br/>            this.names[this.nextUp] = name;<br/>            this.values[this.nextUp] = value;<br/>            this.nextUp++;<br/>            if (this.nextUp == this.capacity) {<br/>                this.nextUp--;<br/>            }<br/>        }</strong><br/>        return value;<br/>    }</span></pre><p id="f07b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这通过了测试，但我真的不喜欢它。这里有几个重构的机会。首先，它有二十多行。这不足以触发IntelliJ IDEA或NetBeans的建议，但足以引起问题。</p><p id="4879" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以让我们将数组搜索过程提取到一个私有函数中。</p><pre class="lf lg lh li gt ll le lm ln aw lo bi"><span id="ac75" class="lp lq iq le b gy lr ls l lt lu">    private static int indexOf(Object obj, Object[] array, <br/>                               int endBound) {<br/>        boolean found = false;<br/>        int curr = 0;<br/>        while (!found &amp;&amp; curr &lt; endBound) {<br/>            found = obj.equals(array[curr]);<br/>            curr++;<br/>        }<br/>        if (found) {<br/>            return curr - 1;<br/>        } else {<br/>            return -1;<br/>        }<br/>    }</span></pre><p id="33f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也许你的第一反应是让它成为一个可以访问<code class="fe lb lc ld le b">names</code>的实例函数，而不是一个需要<code class="fe lb lc ld le b">names</code>作为<code class="fe lb lc ld le b">Object[]</code>传入的静态函数。但是当我想为<code class="fe lb lc ld le b">values</code>做一个类似的功能时，我遇到了问题。所以我在两种情况下都使用了静态函数。</p><p id="f23b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完成后，我们可以像这样缩短<code class="fe lb lc ld le b">retrieve()</code>:</p><pre class="lf lg lh li gt ll le lm ln aw lo bi"><span id="da64" class="lp lq iq le b gy lr ls l lt lu">    public V retrieve(N name) {<br/>        V value;<br/>        <strong class="le ir">int index = indexOf(name, this.names, this.nextUp);</strong><br/>        if (<strong class="le ir">index &gt; -1</strong>) {<br/>            value = (V) this.values[<strong class="le ir">index</strong>];<br/>        } else {<br/>            value = this.create(name);<br/>            this.names[this.nextUp] = name;<br/>            this.values[this.nextUp] = value;<br/>            this.nextUp++;<br/>            if (this.nextUp == this.capacity) {<br/>                this.nextUp--;<br/>            }<br/>        }<br/>        return value;<br/>    }</span></pre><p id="cb30" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过了测试，它应该也能通过我们写的另外两个测试。而且还不到二十行。我们可以进一步缩短它，将Else子句提取到另一个私有函数，也许叫做<code class="fe lb lc ld le b">add()</code>。</p><p id="7157" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，更迫切的需求是编写一个测试，要求<code class="fe lb lc ld le b">LRUCache</code>实际跟踪名称-值的新近性，以便通过测试。</p><p id="b2b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当达到容量时，我们的<code class="fe lb lc ld le b">LRUCache</code>的当前版本只是在数组的最后一个槽中添加新的名称-值对，而不移动任何其他的。现在，我们最近最少使用的缓存更像是最近创建的缓存。</p><p id="238e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果最近没有检索到某个值，而添加了其他值，则旧值最终会被遗忘，这取决于容量。</p><p id="eac1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当编写测试时，我们不应该关心任何给定值在数组中的位置。我们应该只关心一个值是否在缓存中。这就是<code class="fe lb lc ld le b">has()</code>函数的用途。目前是存根。为了唤起你的记忆:</p><pre class="lf lg lh li gt ll le lm ln aw lo bi"><span id="4a5e" class="lp lq iq le b gy lr ls l lt lu">    // TODO: Write a test for this<br/>    boolean has(V value) {<br/>        return false;<br/>    }</span></pre><p id="ae1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们开始写测试，然后删除它，在那里做注释。</p><pre class="lf lg lh li gt ll le lm ln aw lo bi"><span id="3120" class="lp lq iq le b gy lr ls l lt lu">    @Test<br/>    void testHas() {<br/>        System.out.println("has");<br/>        LRUCacheImpl cache = new LRUCacheImpl(DEFAULT_SIZE);<br/>        String ssnName = "\\d{3}-\\d{2}-\\d{4}";<br/>        Pattern pattern = cache.retrieve(ssnName);<br/>        String msg = "After adding pattern " + pattern.toString()<br/>                + " to cache, cache should still have it";<br/>        assert cache.has(pattern) : msg;<br/>    }</span></pre><p id="46c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正则表达式用于验证作为<code class="fe lb lc ld le b">String</code>实例的社会保险号(SSN)在正确的位置有破折号，除此之外别无它用。</p><p id="6445" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">测试失败，即使我们知道<code class="fe lb lc ld le b">ssnName</code>已经被添加到缓存中(我们知道这一点是因为<code class="fe lb lc ld le b">testAddToCache()</code>应该还在通过)。但是<code class="fe lb lc ld le b">has()</code>无论如何都返回false。通过这个测试很容易:</p><pre class="lf lg lh li gt ll le lm ln aw lo bi"><span id="1c66" class="lp lq iq le b gy lr ls l lt lu">    boolean has(V value) {<br/>        return <strong class="le ir">true</strong>;<br/>    }</span></pre><p id="3093" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">测试通过，没有什么需要重构的。这是那种让TDD觉得很傻的事情。但重要的是我们接下来要写的测试:</p><pre class="lf lg lh li gt ll le lm ln aw lo bi"><span id="2f91" class="lp lq iq le b gy lr ls l lt lu">    @Test<br/>    void testDoesNotHave() {<br/>        LRUCacheImpl cache = new LRUCacheImpl(DEFAULT_SIZE);<br/>        String numberName = "([-+]?\\d*)";<br/>        Pattern pattern = Pattern.compile(numberName);<br/>        String msg = "New cache should not have "<br/>                + pattern.toString() + " or any other value";<br/>        assert !cache.has(pattern) : msg;<br/>    }</span></pre><p id="3518" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然这失败了，因为现在<code class="fe lb lc ld le b">has()</code>总是返回true。为了通过这个测试，我们可以利用私有的<code class="fe lb lc ld le b">indexOf()</code>函数。</p><pre class="lf lg lh li gt ll le lm ln aw lo bi"><span id="3dd4" class="lp lq iq le b gy lr ls l lt lu">    boolean has(V value) {<br/>        return <strong class="le ir">indexOf(value, this.values, this.capacity) &gt; -1</strong>;<br/>    }</span></pre><p id="bf27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">测试是我使用<code class="fe lb lc ld le b">has()</code>功能的主要动机。应该是纯功能，意思是没有副作用，不像<code class="fe lb lc ld le b">retrieve()</code>。那个应该有副作用，这才是重点。</p><p id="5965" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看起来我们已经准备好投入工作，使这个东西成为LRU缓存。</p><pre class="lf lg lh li gt ll le lm ln aw lo bi"><span id="8d18" class="lp lq iq le b gy lr ls l lt lu">    @Test<br/>    void testValueEventuallyForgotten() {<br/>        LRUCacheImpl cache = new LRUCacheImpl(DEFAULT_SIZE);<br/>        String romanName <br/>                = "^(?=[MDCLXVI])M*(C[MD]|D?C{0,3})(X[CL]|L?X{0,3})"<br/>                + "(I[XV]|V?I{0,3})$";<br/>        Pattern romanValue = cache.retrieve(romanName);<br/>        for (int i = 0; i &lt; DEFAULT_SIZE; i++) {<br/>            assert cache.has(romanValue);<br/>            String fillerName = "^" + i + "*$";<br/>            cache.retrieve(fillerName);<br/>        }<br/>        String msg = "After filling in " + DEFAULT_SIZE<br/>                + " other values, Roman pattern should be out";<br/>        assert !cache.has(romanValue) : msg;<br/>    }</span></pre><p id="440b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个测试会失败，因为无论什么值首先被添加到缓存中，它都会在缓存的生命周期内一直保留在缓存中。这是因为一旦达到容量，新的值总是在最后添加。</p><p id="732f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了通过这个测试，让我们改变<code class="fe lb lc ld le b">retrieve()</code>，以便一旦达到容量，<code class="fe lb lc ld le b">nextUp</code>被重置为零，而不是<code class="fe lb lc ld le b">lastIndex</code>——这接近函数的结尾:</p><pre class="lf lg lh li gt ll le lm ln aw lo bi"><span id="af45" class="lp lq iq le b gy lr ls l lt lu">            if (this.nextUp == this.capacity) {<br/>                this.nextUp<strong class="le ir"> = 0</strong>;<br/>            }</span></pre><p id="940e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了确保其他测试也能通过，我们需要用<code class="fe lb lc ld le b">this.capacity</code>替换<code class="fe lb lc ld le b">retrieve()</code>的<code class="fe lb lc ld le b">indexOf()</code>调用中的<code class="fe lb lc ld le b">this.nextUp</code>。</p><p id="017a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好了，我们差不多完成了，我们只需要放入使这个东西成为最近最少使用的缓存的功能。</p><p id="4e07" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的下一个测试与上一个测试非常相似，但是关键的区别在于，这一次我们将在添加到缓存的第一个项目的For循环中使用<code class="fe lb lc ld le b">retrieve()</code>而不是<code class="fe lb lc ld le b">has()</code>。</p><p id="e812" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着<code class="fe lb lc ld le b">LRUCache</code>应该在每次检索时将第一个添加到缓存中的条目放在队列的前面。</p><pre class="lf lg lh li gt ll le lm ln aw lo bi"><span id="b802" class="lp lq iq le b gy lr ls l lt lu">    @Test<br/>    void testFrequentlyRetrievedStaysCached() {<br/>        LRUCacheImpl cache = new LRUCacheImpl(DEFAULT_SIZE);<br/>        String dollarAmountName = "\\$\\d*\\.\\d{2}";<br/>        Pattern expected = cache.retrieve(dollarAmountName);<br/>        for (int i = 0; i &lt; DEFAULT_SIZE; i++) {<br/>            Pattern actual = cache.retrieve(dollarAmountName);<br/>            assertEquals(expected, actual);<br/>            String fillerName = "^" + (i + 1) + "*$";<br/>            cache.retrieve(fillerName);<br/>        }<br/>        String msg = "Cache should still have " <br/>                + expected.toString()<br/>                + " because it was retrieved repeatedly";<br/>        assert cache.has(expected) : msg;<br/>    }</span></pre><p id="512c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是测试当然会失败，因为此时我们实际拥有的是最近最少添加的缓存，而不是最近最少使用的缓存。</p><p id="2e18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们缺少的关键部分是一个私有过程，它将数组中指定位置的项移动到位置0。我们实现<code class="fe lb lc ld le b">LRUCache</code>的方式使得将数组移动助手作为一个独立的单元变得更加重要:我们将在<code class="fe lb lc ld le b">names</code>和<code class="fe lb lc ld le b">values</code>中都需要它。</p><p id="5850" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是数组移动助手的存根:</p><pre class="lf lg lh li gt ll le lm ln aw lo bi"><span id="f38c" class="lp lq iq le b gy lr ls l lt lu">    // STUB<br/>    private static void moveToFront(Object[] objects, <br/>                                    int position) {<br/>        // TODO: Implement this<br/>    }</span></pre><p id="dcf5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们实现了这一点，我们只需要对<code class="fe lb lc ld le b">retrieve()</code>函数做一些关键的修改。</p><pre class="lf lg lh li gt ll le lm ln aw lo bi"><span id="c0ed" class="lp lq iq le b gy lr ls l lt lu">    public V retrieve(N name) {<br/>        V value;<br/>        int index = indexOf(name, this.names, this.capacity);<br/>        if (index &gt; -1) {<br/>            value = (V) this.values[index];<br/>        } else {<br/>            value = this.create(name);<br/>            this.names[this.nextUp] = name;<br/>            this.values[this.nextUp] = value;<br/>            <strong class="le ir">index = this.nextUp;</strong><br/>            this.nextUp++;<br/>            if (this.nextUp == this.capacity) {<br/>                <strong class="le ir">this.nextUp--;</strong><br/>            }<br/>        }<br/>        <strong class="le ir">if (index &gt; 0) {<br/>            moveToFront(this.names, index);<br/>            moveToFront(this.values, index);<br/>        }</strong><br/>        return value;<br/>    }</span></pre><p id="5010" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我委托你负责<code class="fe lb lc ld le b">moveToFront()</code>的实际执行。提示:在IntelliJ IDEA中，如果你写了一个所谓的“手动数组拷贝”，你会得到一个建议，用一个<code class="fe lb lc ld le b">System.arraycopy()</code>来替换它。</p><p id="7d34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">记住:对于引用类型的数组，只有对象指针在数组中移动。除非运行时有自己的理由移动它们，否则对象本身会留在它们所在的地方，这个理由与我们的程序所做的事情无关。</p><p id="4a36" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，性能成本可能与在一个数字原语数组中移动值差不多。</p><p id="4df0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你在编写<code class="fe lb lc ld le b">moveToFront()</code>时遇到任何问题，你可以参考<code class="fe lb lc ld le b">sun.misc.LRUCache</code>的来源(谷歌“sun misc LRUCache”)。</p><p id="211f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">希望现在所有的单元测试都通过了。我忘了提醒你重构。这里当然有重构的机会。如果你不知道什么需要重构，看看警告和待办事项注释。</p><p id="54f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，这里有一个没有使用<code class="fe lb lc ld le b">MAXIMUM_CAPACITY</code>的警告。它有相应的Do注释，提醒我们让构造函数检查<code class="fe lb lc ld le b">size</code>参数没有超过<code class="fe lb lc ld le b">MAXIMUM_CAPACITY</code>。</p><p id="8ffe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以编写一个测试，尝试实例化一个比<code class="fe lb lc ld le b">MAXIMUM_CAPACITY</code>大一号的<code class="fe lb lc ld le b">LRUCache</code>。确保不要在<code class="fe lb lc ld le b">LRUCacheTest</code>中硬编码该值(例如129)，而是将其计算为<code class="fe lb lc ld le b">LRUCache.MAXIMUM_CAPACITY + 1</code>。</p><p id="592e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过测试应该要求<code class="fe lb lc ld le b">LRUCache</code>构造函数抛出一个带有非空异常消息的<code class="fe lb lc ld le b">IllegalArgumentException</code>。同样的还有<code class="fe lb lc ld le b">MINIMUM_CAPACITY</code>，如果你还没有处理好的话。</p><p id="586d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嗯，原来我们不需要<code class="fe lb lc ld le b">lastIndex</code>做任何事。继续删除它(包括它的构造函数初始化)。我还有一个从未使用过的单参数<code class="fe lb lc ld le b">indexOf()</code>函数，所以我也删除了它。</p><p id="71cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这应该只留下一个警告，关于<code class="fe lb lc ld le b">retrieve()</code>中未检查强制转换的讨厌警告。IntelliJ在这一点上没有太大的帮助，我不想隐藏任何警告。这很容易成为另一篇文章的主题。</p><p id="158e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我计划撰写关于从头实现数据结构的其他文章。接下来我考虑数组支持的集合和数组支持的列表。欢迎在评论中提出建议。</p><p id="ea20" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其他可用于编程练习的固定容量缓存包括最近使用的(MRU)缓存和最少使用的(LFU)缓存。</p><p id="7f02" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么为<code class="fe lb lc ld le b">LRUCache</code>和其他人写一个抽象超类也是一个有价值的练习。</p></div></div>    
</body>
</html>