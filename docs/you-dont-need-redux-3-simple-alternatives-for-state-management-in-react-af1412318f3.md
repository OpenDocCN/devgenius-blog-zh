# 您不需要 Redux——React 中状态管理的 3 个简单替代方案

> 原文：<https://blog.devgenius.io/you-dont-need-redux-3-simple-alternatives-for-state-management-in-react-af1412318f3?source=collection_archive---------0----------------------->

## 由于它的流行，Redux 经常是 React 中状态管理的默认选择——但是还有其他几个选择值得考虑。

![](img/eacce9d2cd2c2720a03641c25002f257.png)

照片由 [Patrick Fore](https://unsplash.com/@patrickian4?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

如果你正在编写一个 [React](http://reacts.org) 应用，你将需要一些策略来*管理状态——你如何存储和修改应用的数据。我询问的几乎所有 React 开发人员都使用 [Redux](https://redux.js.org) 进行状态管理，我询问的几乎每个人都有一些问题。好消息是，有许多很好的替代方案可供探索——在本文中，我们将研究几个不同的替代方案，看看它们如何与 Redux 相抗衡。*

# 什么是国家管理？

如果您正在 React 中构建一个应用程序，在某个时候您将需要开始管理数据:做一些像接受用户输入、计算值、从服务器获取和显示数据等事情。抽象地说，所有这些例子中涉及的任何类型数据的获取和设置都被称为*状态管理*。

您的状态管理策略有助于回答一些问题，如在哪里存储数据、如何访问数据、修改数据的界面和规则是什么样的。虽然这是状态管理库的核心功能，但是它们还可以提供许多其他的外围功能:数据验证类型检查、网络请求异步数据管理、撤销/重做等。

您可能会从 React 中了解到的第一种状态管理是`useState`钩子，它允许您存储和读取单个组件中的值。例如，如果你有一个带有复选框的表单，你可以使用`useState`来管理一个`checked`布尔值和一个`setChecked`函数来修改这个值。

但是，当您的状态需要位于组件之外，并且是您的大型应用程序的一部分时，该怎么办呢？此时，您将需要一个不同的解决方案——一个可以帮助您的应用程序“大图”的解决方案。

# Redux:房间里的大象

由于它的流行，状态管理的“默认”选择通常是一个叫做 Redux 的强大的库。如果其他人都选择 Redux，这似乎是一个安全的选择，对不对？答案是*可能吧。Redux 很棒，但它也有自己的一套包袱。*

通过 Redux 接口管理状态的核心概念包括创建描述状态变化的*动作、*简单对象；以及*还原器、*，其采用当前状态和动作以生成新状态。这些动作通过调用 *dispatch 发送给州政府。除此之外还有很多，但这些都是你需要开始的概念。*

如果你以前没有使用过 Redux，我鼓励你看一下快速入门指南，看看一个基本的 Redux 商店是如何运作的，以及这些核心概念是如何付诸行动的。

虽然 Redux 非常强大，但我还是不喜欢它的一些地方:

*   **很复杂**:让 Redux 如此强大的各种概念也意味着你要处理大量的抽象来处理简单的场景。将状态更新封装为动作的优势在于更受约束和更具语义的状态操作，但代价是增加了复杂性。
*   许多样板文件:与第一点相关，Redux 要求你写更多的代码来处理简单的用例。您可能会发现自己错过了 useState 提供的简单状态管理的简单性— `[value, setValue] = React.useState()`
*   **中间件**:Redux 的另一个复杂因素是，对于一些常见的用例，您可能会发现自己需要集成和配置 Redux 中间件的各个部分，本质上是插件。这不仅证明了 Redux 的强大和灵活性，也证明了它的复杂性——您可能会发现自己希望其中一些功能是内置的，并且更加“固执己见”。

# 选择#1:反应上下文

Redux 最简单的替代方法是使用 [React 的内置*上下文*](https://reactjs.org/docs/context.html) 功能*。状态管理库提供了许多重要的功能，其中之一就是跨多个远程组件访问内容的能力。这正是 React Contexts 所提供的，*没有状态管理库的任何其他特性。**

![](img/3a948df2d0776c0fc72497671bc1355e.png)

反应上下文:你有一份工作

在下面的例子中，我们展示了一个常见的上下文用例:通过一个应用程序传递一个主题值(以及一种更改它的方法),而没有显式地将该值钻取到每个需要它的组件。首先，我们在应用程序的高层创建一个上下文，并通过*提供者*传递我们希望在其他地方可用的数据。*数据可以是我们想要的任何东西*(甚至是与状态管理无关的东西)，但是在这个例子中，我们传入了一个包含颜色的数组和一个颜色设置函数。

```
const ThemeContext = React.createContext(["", () => {}]);const App = () => {
 const [color, setColor] = React.useState("#000")return (<ThemeContext.Provider value={[color, setColor]}>        
    <ComplicatedApplicationWithManyScreens />
  </ThemeContext.Provider>)
}
```

在我们应用程序的其他地方，如果我们需要访问(或改变)颜色，我们可以通过*消费者:*来完成

```
const ThemedScreen = () => {
  return (<ThemeContext.Consumer>
    {([color, setColor]) => (<Screen color={color} setColor={setColor} />)}
  </ThemeContext.Consumer>)
}
```

请注意，我们的`ThemedScreen`组件可以在视图层次结构中的任何位置，并且不需要传递任何特殊的道具——它将组件从上下文消费者中取出，并根据需要使用它们。

## **何时使用 React 上下文**

当您的状态管理需求非常简单，并且您不需要其他库提供的任何高级功能时，React Context 提供了一种简单、无依赖性的方式来管理状态。

此外，即使您确实使用了一些其他状态管理库，React Contexts 也是一个很好的工具，可用于“利基”状态管理用例，这些用例不遵循与应用程序中其他状态管理相同的模式。上面的例子，主题管理，是 React 上下文的一个很好的用例，因为它通常不需要其他类型的状态管理库提供的任何更高级的功能:通常没有很多验证、网络请求或复杂的数据转换的实例。

## **何时不使用 React 上下文**

如上所述，React 上下文最适合非常简单的用例。如果您确实需要更高级的功能，您将最终在上下文之上自己构建它，并且可能很快意识到其他方法会更好更快地解决这些问题。

使用上下文的另一个风险是，它对您的数据架构没有帮助:有些人可能会试图将越来越多的应用程序状态放在一个上下文中，但这通常不是一个好主意。随着状态变得越来越复杂，应用程序的性能将由于过度的重新渲染而受到影响。这是任何状态管理解决方案的一个风险，但在上下文中却是一个特别容易陷入的陷阱——其他解决方案往往会提供关于结构化数据的更好的指导。

我建议为这些*目标*用例使用上下文，比如主题化，如果它们非常适合的话，并且可能作为应用程序开发早期阶段的初始状态管理方法，但是要意识到局限性，并准备好在需要更高级的状态管理功能时进行切换。

# 选择 2:反冲

[反冲](https://recoiljs.org)是脸书正在开发的 Redux 的后起之秀。反冲是我个人的选择，很大程度上是因为它的简单:它本质上启用了一个类似于`useState`钩子的接口，但是通过一个高级的`RecoilRoot`包装器组件(本质上是一个如上所示的专用上下文)跨组件工作。

![](img/b03ddd6db1d959021e3fc78f475596e1.png)

第一步是使用反冲来定义各种应用状态称为*原子*:

```
*const* colorState = Recoil.atom({
  key: 'colorState',
  *default*: "#f00",
});
```

配置完成后，使用`useRecoilState`访问反冲值和设置器:

```
const ThemedScreen = () => {
  const [color, setColor] = Recoil.useRecoilState(colorState)
  return <Screen color={color} setColor={setColor} />
}
```

除了核心的状态管理功能，反冲还提供了对更高级功能的支持，如持久性、异步数据(如网络请求)和可定制的数据管理副作用(即在数据更改时执行其他操作)。

## **什么时候使用后坐力**

就我个人而言，反冲是我对新项目的默认选择。它为大多数项目提供了简单性和功能性的恰当平衡，尤其是在早期阶段。熟悉的`useState`风格的界面使其易于使用，对于库的新开发人员来说非常容易接近。开始使用它也只需要很少的代码开销。

## **何时不使用反冲**

虽然反冲提供了大量开箱即用的强大功能，但它是状态管理领域中最少的一个。如果你确实喜欢 Redux 的一些特性，但是想避免包袱，第三种选择可能会在简单性和表现力之间找到平衡点。

# 备选方案 3: Zustand

Zustand 是一个有趣的选择，因为它提供了一些反冲的简单性，但更多的是 Redux 的表现力。

![](img/cd47626e2b4f86a7a146e39ebb8c9d94.png)

Zustand 无疑赢得了比赛中“最可爱的标志”部分

像反冲一样，Zustand 默认情况下具有极大简化的状态管理体验，但也允许(可选地)在 Redux 中找到更具表现力的动作和 reducer 式功能。这个改编自文档的代码示例显示了它在设置商店时是如何工作的:

```
const useStore = create((set) => ({
  color: "#f00",
  setColor: (color) => set((state) => ({ color })),
  setDarkMode: () => set((state) => ({ color: "#000" }))
}))
```

然后使用组件中的存储:

```
function ThemedScreen() {
  const {color, setColor} = useStore((state) => state)
  return <Screen color={color} setColor={setColor} />
}
```

注意，`setColor`调用不是直接设置存储值，而是像 Redux 中的 reducer 一样，接受当前状态并将其转换到下一个状态。在这个例子中，我们还提供了一个更加语义化的`setDarkMode`函数，只是为了说明 Zustand 可以支持更典型的 Redux 使用模式。

像反冲一样，Zustand 也通过包含的和大部分预配置的中间件提供对异步动作、持久性等的支持。通过一些简单的包装器(或其他中间件)，它还可以提供一个接口，就像使用 Redux actions 一样。

## **何时使用** Zustand

如果你*确实*喜欢 Redux 的某些部分，但不一定是全部，Zustand 可以在你需要的地方有效地提供类似 Redux 的功能，但没有沉重的样板代码开销。

## **何时不使用** Zustand

因为就功能和复杂性而言，它位于反冲和 Redux 之间，所以有时直接选择其中一个工具可能更有意义，而不是试图用 Zustand 模拟它。

# 其他选择

虽然本文中讨论的库是 React 中状态管理的最佳选择，但是还有许多其他的选择。荣誉奖颁给了其他一些我没有亲自使用过，但获得好评的库: [MobX](http://mobx.js.org) 、 [Jotai](http://jotai.org) 和 [Valtio](https://github.com/pmndrs/valtio) 。

要更全面地深入了解关于状态管理的一些权衡和考虑，比如性能、内存使用和不可变与可变方法，我强烈推荐阅读本文。

# 结论——还原还是不还原？

在比较技术的时候，我总会提出一个观点，那就是不是关于哪种技术*更好*，而是关于哪种技术对于一个特定的*用例*更好。换句话说，这完全是一种权衡。

在本文中，我列出了 Redux 和其他状态管理库之间的一些权衡，以便您可以做出更明智的决定。对于状态管理来说，Redux 无疑是一个强大而成熟的库，但是您应该了解可供选择的库，并自己决定哪一个最适合您的应用程序。我不会说我再也不会使用 Redux，但我更有可能在使用大枪之前使用反冲或 Zustand 来解决这些状态管理问题。

[*Jonathan*](/@jonnystartup)*在大型创业公司&小型企业中拥有超过 20 年的工程领导经验。在业余时间，他在做一个文档自动化平台，*[](http://imagepipe.co/)**。**