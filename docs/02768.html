<html>
<head>
<title>React 2020 — P2: Deeper Intro</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应2020 — P2:更深入的介绍</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/react-2020-p2-deeper-intro-df82d7beee40?source=collection_archive---------5-----------------------#2020-08-28">https://blog.devgenius.io/react-2020-p2-deeper-intro-df82d7beee40?source=collection_archive---------5-----------------------#2020-08-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f58dd4c82c3b0f24474eef8cb55ea011.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QMiU_fdyMAgTPMy0Fel6EA.jpeg"/></div></div></figure><p id="9b7e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<a class="ae kw" href="https://medium.com/dev-genius/react-2020-p1-intro-and-installation-21a673ab6a22" rel="noopener">上一篇文章</a>中，我们浏览了我们创建的React应用程序的表面。现在，让我们更深入地了解应用程序，并为我们将在本系列中创建的React应用程序设置项目结构。</p><p id="ead4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<a class="ae kw" href="https://medium.com/dev-genius/react-2020-p1-intro-and-installation-21a673ab6a22" rel="noopener">之前的文章</a>中我们已经看过<em class="kx"> public/index.html </em>，但是为什么这个文件会获得React应用？当用户访问您的网站时，您的服务器会将该文件发送给用户。名称<em class="kx">索引</em>是大多数服务器将在公共目录中查找的默认文件名。如果您使用<em class="kx"> npm start </em>启动React应用程序，并在浏览器中检查代码，您会注意到页面底部包含了一些脚本。</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="46ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些脚本将React应用程序加载到您的<em class="kx"> &lt; div id="root" &gt; </em>中。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi le"><img src="../Images/ddaaae4f8c83c258d24c0d23203c7679.png" data-original-src="https://miro.medium.com/v2/resize:fit:1318/format:webp/1*jSH6rC28yUuBEu_uoNvKfA.png"/></div></figure><p id="adc0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经走过了当前的流程，但让我们快速回顾一下。</p><ol class=""><li id="1fb5" class="lf lg iq ka b kb kc kf kg kj lh kn li kr lj kv lk ll lm ln bi translated">React的入口点是<em class="kx"> src/index.js </em></li><li id="60ec" class="lf lg iq ka b kb lo kf lp kj lq kn lr kr ls kv lk ll lm ln bi translated"><em class="kx"> src/index.js </em>导入React、ReactDOM和<em class="kx"> App </em>组件。</li><li id="e3cf" class="lf lg iq ka b kb lo kf lp kj lq kn lr kr ls kv lk ll lm ln bi translated">React和ReactDOM是包。<em class="kx"> App </em>组件从<em class="kx"> src/App.js </em>导入。</li><li id="05b8" class="lf lg iq ka b kb lo kf lp kj lq kn lr kr ls kv lk ll lm ln bi translated"><em class="kx"> App </em>组件是一个返回JSX元素的功能组件。在这种情况下，它返回<em class="kx"> &lt; div &gt;空白页&lt; /div &gt; </em>。</li><li id="d3d6" class="lf lg iq ka b kb lo kf lp kj lq kn lr kr ls kv lk ll lm ln bi translated"><em class="kx"> App </em>组件从<em class="kx"> App.js </em>导出，导入到<em class="kx"> index.js </em>中。</li><li id="16cf" class="lf lg iq ka b kb lo kf lp kj lq kn lr kr ls kv lk ll lm ln bi translated">导入后，使用ReactDOM.render()方法进行渲染。<em class="kx"> render() </em>方法将<em class="kx"> App </em>组件内容放入包含<em class="kx"> id="root" </em>属性的HTML元素中。</li></ol><p id="8144" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们想创建另一个页面呢？在传统的静态HTML页面网站创建中，你需要创建<em class="kx"> public/about.html </em>。React应用程序被称为单页面应用程序，因此应用程序的唯一入口是通过<em class="kx">public/index . html:&lt;div id = " root "&gt;</em>。</p><h2 id="b18a" class="lt lu iq bd lv lw lx dn ly lz ma dp mb kj mc md me kn mf mg mh kr mi mj mk ml bi translated">成分</h2><p id="1cb4" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">组件只是用户界面的一部分。一旦创建，就可以反复使用。让我们看一下我们在介绍/安装文章中看到的同一张图。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/681635055d2f4352cfcdcefc908b6e3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*R0s5kNyoUJMoiBP1.png"/></div></figure><p id="954a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们有许多不同的组件:<em class="kx">标题</em>，<em class="kx">导航</em>，<em class="kx">页脚</em>等。<em class="kx">条</em>组件分组在<em class="kx">节</em>组件内，这意味着组件可以容纳其他组件。上面所有的组件都位于主组件的内部，对我们来说就是<em class="kx"> App </em>组件。</p><p id="9944" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以创建不同的组件，但它们分为两类:有状态的组件和无状态的组件。有些组件有状态，有些没有。我们将在后面的文章中讨论状态，但本质上，状态是一个存储数据并可被组件访问的对象。</p><p id="7787" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有功能组件和基于类的组件。当你查看<em class="kx"> src/App.js时，你已经看到了一个功能组件的例子。</em>功能组件只是一个返回<em class="kx"> JSX </em>元素的JavaScript函数。</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="1db5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，<em class="kx"> src/App.js </em>包含一个名为<em class="kx"> App </em>(功能组件)的函数，该函数返回<em class="kx"> JSX div </em>元素。</p><p id="69ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不过，您可能不熟悉基于类的组件。基于类的组件是扩展<em class="kx"> React的类。组件</em>并包含一个返回JSX元素的<em class="kx"> render() </em>方法。我们可以很容易地将上面的<em class="kx"> App </em>功能组件转换成一个类组件。</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="92b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您的代码不需要任何其他更改。React知道调用<em class="kx"> render() </em>方法，该方法将返回JSX元素。</p><p id="733c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为什么使用基于类的组件而不是功能组件？在钩子被引入之前，只有类组件可以利用<em class="kx">状态</em>。那不再是真的了。我来自一个基于类的OOP背景，所以我更喜欢类而不是钩子。然而，钩子似乎是由React推动的，所以我认为现在使用钩子比使用类更安全。我偷偷欣赏了所有其他基于OOP的开发者在网上发表他们的观点，声称他们喜欢类组件而不是功能组件。然而，我们在这里学习React，所以我们将详细研究两者。</p><h2 id="56f4" class="lt lu iq bd lv lw lx dn ly lz ma dp mb kj mc md me kn mf mg mh kr mi mj mk ml bi translated">设置项目结构</h2><p id="3782" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">我们将使用<em class="kx"> App.js </em>文件作为我们的切入点。我们创建的任何新组件都将被导入到<em class="kx"> App.js </em>中，并在那里呈现。我们将在我们的<em class="kx"> src </em>目录下创建一个<em class="kx">组件</em>目录，并将我们所有的组件放在那里。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/467e50f807e2d9b766e757cd1c6106a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*ZEzQ6-S65jU65P9dcTLWeg.png"/></div></figure><p id="8ccd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们创建一个快速组件来演示这一点。右键点击目录，新建一个文件:<em class="kx"> Test.js </em>。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/0180c2ab4af88a3eca55ea6b6e074e23.png" data-original-src="https://miro.medium.com/v2/resize:fit:502/format:webp/1*GLdEmNrRyYCyYE7V9dRy6g.png"/></div></figure><p id="77c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每个React组件必须以react import语句开始。我们将创建一个返回JSX元素的功能组件，并导出该组件。</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="9a93" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">组件已经创建，但是它现在对我们没有任何作用。由于我们将使用我们的<em class="kx">应用</em>组件来呈现我们所有的其他组件，我们需要将<em class="kx">测试</em>组件导入到我们的<em class="kx">应用</em>组件中，并在那里呈现它。</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="f85e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看上面的<em class="kx"> src/App.js </em>，我们从<em class="kx"> src/Components/Test.js </em>文件中导入<em class="kx">测试</em>组件。的’。/'状态，从当前目录(该文件所在的目录)开始，然后进入<em class="kx">组件</em>目录。一旦被导入，测试组件<em class="kx">就会使用<em class="kx"> &lt;组件名/ &gt; </em>语法呈现在第9行。如果JSX元素没有结束标记，您必须为它提供一个自结束标记:<em class="kx">&lt;component name&gt;</em>无效。</em></p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/ec6184887ff006288df3d25a6f22622e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ku424JvfStl4Jd8H5-GZoQ.png"/></div></div></figure><p id="e697" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望您开始理解React应用程序中的逻辑流程。在接下来的几篇文章中，我们将逐一探讨这些概念，并重申代码如何在应用程序中流动。</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="mv ld l"/></div></figure></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><div class="ky kz la lb gt nd"><a href="https://github.com/dinocajic/react-youtube-tutorials" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd ir gy z fp ni fr fs nj fu fw ip bi translated">dinocajic/react-YouTube-教程</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">React 2020 YouTube教程。在…上创建一个帐户，为dinocajic/react-YouTube-tutorials开发做出贡献</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">github.com</p></div></div><div class="nm l"><div class="nn l no np nq nm nr jw nd"/></div></div></a></div></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/98adc5bae1070c342c86f9cbe052a286.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QnG0AmYes6u8mgsV.jpeg"/></div></div></figure><p id="d154" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Dino Cajic目前是<a class="ae kw" href="https://www.lsbio.com/" rel="noopener ugc nofollow" target="_blank"> LSBio(寿命生物科学公司)</a>、<a class="ae kw" href="https://absoluteantibody.com/" rel="noopener ugc nofollow" target="_blank">绝对抗体</a>、<a class="ae kw" href="https://www.kerafast.com/" rel="noopener ugc nofollow" target="_blank"> Kerafast </a>、<a class="ae kw" href="https://everestbiotech.com/" rel="noopener ugc nofollow" target="_blank">珠穆朗玛生物科技</a>、<a class="ae kw" href="https://www.nordicmubio.com/" rel="noopener ugc nofollow" target="_blank">北欧MUbio </a>和<a class="ae kw" href="https://www.exalpha.com/" rel="noopener ugc nofollow" target="_blank"> Exalpha </a>的IT主管。他还担任我的自动系统的首席执行官。他有十多年的软件工程经验。他拥有计算机科学学士学位，辅修生物学。他的背景包括创建企业级电子商务应用程序、执行基于研究的软件开发，以及通过写作促进知识的传播。</p><p id="7942" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在<a class="ae kw" href="https://www.linkedin.com/in/dinocajic/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系他，在<a class="ae kw" href="https://instagram.com/think.dino" rel="noopener ugc nofollow" target="_blank"> Instagram </a>上关注他，或者<a class="ae kw" href="https://dinocajic.medium.com/subscribe" rel="noopener">订阅他的媒体刊物</a>。</p><p id="1f40" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">阅读Dino Cajic(以及Medium上成千上万的其他作家)的每一个故事。你的会员费直接支持迪诺·卡吉克和你阅读的其他作家。你也可以在媒体上看到所有的故事。 </p></div></div>    
</body>
</html>