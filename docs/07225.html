<html>
<head>
<title>Formatting Form Inputs in React to use accepts_nested_attributes_for in Rails</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 React 中格式化表单输入以在 Rails 中使用 accepts_nested_attributes_for</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/formatting-form-inputs-in-react-to-use-accepts-nested-attributes-for-in-rails-7eca7902fed0?source=collection_archive---------6-----------------------#2022-03-07">https://blog.devgenius.io/formatting-form-inputs-in-react-to-use-accepts-nested-attributes-for-in-rails-7eca7902fed0?source=collection_archive---------6-----------------------#2022-03-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/4613eb1337cfe193afc2d427261f4df9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SOJ3bMAtA9frF7kMmiKadQ.png"/></div></div></figure><h1 id="7518" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">介绍</h1><p id="b9e9" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">在之前的一篇<a class="ae lr" rel="noopener ugc nofollow" target="_blank" href="/passing-a-nested-array-of-objects-to-a-controller-to-update-associated-records-in-rails-38913ae01f6c">文章中，我描述了类方法<code class="fe ls lt lu lv b"><a class="ae lr" href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/NestedAttributes/ClassMethods.html" rel="noopener ugc nofollow" target="_blank">accepts_nested_attributes_for</a></code>如何允许你通过父类保存相关记录的属性，这在 Rails 中是默认关闭的。它允许您将嵌套属性传递到控制器操作中，这些操作可以创建、更新和删除相关记录。我还演示了如何在我的应用程序中配置模型和控制器来利用这一功能。</a></p><p id="d00d" class="pw-post-body-paragraph kt ku in kv b kw lw ky kz la lx lc ld le ly lg lh li lz lk ll lm ma lo lp lq ig bi translated">我将描述我如何设置<code class="fe ls lt lu lv b">CourseForm.js</code>来处理创建添加了学生的课程和更新现有课程中的学生。</p><h1 id="f7c5" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">设置状态</h1><p id="0af1" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">我需要设置一些状态变量来跟踪学生在表单中的输入。</p><pre class="mb mc md me gt mf lv mg mh aw mi bi"><span id="3518" class="mj jw in lv b gy mk ml l mm mn">const [listId, setListId] = useState(1)<br/>const [addedStudents, setAddedStudents] = useState([])<br/>const [formData, setFormData ] = useState({<br/>  ...<br/>  students: []<br/>})</span></pre><ul class=""><li id="7d4e" class="mo mp in kv b kw lw la lx le mq li mr lm ms lq mt mu mv mw bi translated">我使用<code class="fe ls lt lu lv b">listId</code>为每个学生输入创建一个唯一的键，因为新的输入没有学生 id 来引用。</li><li id="7585" class="mo mp in kv b kw mx la my le mz li na lm nb lq mt mu mv mw bi translated">我用<code class="fe ls lt lu lv b">addedStudents</code>按住已经添加的学生的<code class="fe ls lt lu lv b">id</code>。这样，后续的下拉菜单就不会将它们作为<code class="fe ls lt lu lv b">&lt;option&gt;</code>包含在内。</li><li id="b74f" class="mo mp in kv b kw mx la my le mz li na lm nb lq mt mu mv mw bi translated"><code class="fe ls lt lu lv b">formData</code>保存表单的数据，并包含一个包含所有学生的数组的<code class="fe ls lt lu lv b">students</code>键。</li></ul><h1 id="07b4" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">格式化来自 API 的学生数据</h1><p id="963c" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">因为我使用了相同的 React 组件来创建一个新类和更新一个当前类，所以我需要格式化 API 中的数据以便在表单中使用。大多数代码都是您的程序所独有的，所以我将只讨论与创建表单相关的代码。</p><pre class="mb mc md me gt mf lv mg mh aw mi bi"><span id="0105" class="mj jw in lv b gy mk ml l mm mn">const { classId } = useParams()</span><span id="b295" class="mj jw in lv b gy nc ml l mm mn">if(<strong class="lv io">course</strong> &amp;&amp; addedStudents.length &lt; 1) {<br/><strong class="lv io">  let initialListId = 0<br/></strong>  const formattedCourse = formatCourse(course)<br/>  <strong class="lv io">const studentsWithListIds = course.students.map(student =&gt; {<br/>    initialListId++<br/>    const studentCourseId = student.student_courses.find(<br/>        crs =&gt; crs.course_id === course.id<br/>      ).id<br/>    return {<br/>      listId: initialListId,<br/></strong>      full_name: student.full_name,<br/><strong class="lv io">      student_id: student.id,<br/>      course_id: classId,<br/>      student_course_id: studentCourseId<br/>    }<br/>  })</strong><br/>  <strong class="lv io">setAddedStudents(<br/>    studentsWithListIds.map(student =&gt; student.student_id)<br/>  )</strong><br/><strong class="lv io">  setFormData({...formattedCourse, students: studentsWithListIds})<br/>  setListId(initialListId)<br/></strong>}</span></pre><ul class=""><li id="d742" class="mo mp in kv b kw lw la lx le mq li mr lm ms lq mt mu mv mw bi translated">我使用 Redux 和<code class="fe ls lt lu lv b">class</code>来引用从 API 接收的那个类的数据。如果我没有使用 Redux，那么我会使用 useState。</li><li id="a022" class="mo mp in kv b kw mx la my le mz li na lm nb lq mt mu mv mw bi translated"><code class="fe ls lt lu lv b">initialListId</code>保存一个数字，每添加一个学生就增加一个，以防止 React 中出现重复的键。我没有使用<code class="fe ls lt lu lv b">listId</code>，因为更新它会导致页面刷新。</li><li id="bc80" class="mo mp in kv b kw mx la my le mz li na lm nb lq mt mu mv mw bi translated"><code class="fe ls lt lu lv b">studentCourseId</code>查找与此<code class="fe ls lt lu lv b">course</code>匹配的<code class="fe ls lt lu lv b">student_course</code>的<code class="fe ls lt lu lv b">id</code>。如果学生被用户从课程中删除，我将需要它。</li></ul><p id="6228" class="pw-post-body-paragraph kt ku in kv b kw lw ky kz la lx lc ld le ly lg lh li lz lk ll lm ma lo lp lq ig bi translated">在代码块结束时，我为<code class="fe ls lt lu lv b">addedStudent, formData, and listId</code>更新状态。现在，我准备创建学生输入。</p><h1 id="14be" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">在表单中创建学生输入</h1><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/4613eb1337cfe193afc2d427261f4df9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SOJ3bMAtA9frF7kMmiKadQ.png"/></div></div></figure><p id="d439" class="pw-post-body-paragraph kt ku in kv b kw lw ky kz la lx lc ld le ly lg lh li lz lk ll lm ma lo lp lq ig bi translated">我使用了与<a class="ae lr" rel="noopener ugc nofollow" target="_blank" href="/react-bootstrap-creating-controlled-forms-to-add-and-update-data-with-a-flexible-number-of-inputs-6d2e4e6977c7"> React Bootstrap 类似的逻辑:当我创建输入时，使用灵活的输入数量</a>创建受控表单来添加和更新数据。</p><p id="c432" class="pw-post-body-paragraph kt ku in kv b kw lw ky kz la lx lc ld le ly lg lh li lz lk ll lm ma lo lp lq ig bi translated">我正在使用<a class="ae lr" href="https://react-bootstrap.github.io/forms/overview/" rel="noopener ugc nofollow" target="_blank"> React Bootstrap </a>来设计我的表单。我在表格上加了这个:</p><pre class="mb mc md me gt mf lv mg mh aw mi bi"><span id="a0bf" class="mj jw in lv b gy mk ml l mm mn">&lt;Row&gt;<br/>  &lt;Form.Label&gt;Students&lt;/Form.Label&gt;<br/>  {renderStudents}<br/>&lt;/Row&gt;<br/>&lt;Row&gt;<br/>  &lt;Button variant=’yellow’ onClick={addStudent}&gt;Add Student&lt;/Button<br/>&lt;/Row&gt;</span></pre><p id="bc55" class="pw-post-body-paragraph kt ku in kv b kw lw ky kz la lx lc ld le ly lg lh li lz lk ll lm ma lo lp lq ig bi translated"><code class="fe ls lt lu lv b">renderStudents</code>为每个学生创建一个输入:</p><pre class="mb mc md me gt mf lv mg mh aw mi bi"><span id="a4ee" class="mj jw in lv b gy mk ml l mm mn">const renderStudents = formData.students.filter(<br/>  student =&gt; student.listId !== undefined).map(<br/>    student =&gt; &lt;AddStudent<br/>      key={student.listId}<br/>      student={student}<br/>      updateStudent={updateStudent}<br/>      removeStudent={removeStudent}<br/>      addedStudents={addedStudents}<br/>    /&gt;<br/>  )</span></pre><ul class=""><li id="eb2d" class="mo mp in kv b kw lw la lx le mq li mr lm ms lq mt mu mv mw bi translated">首先，我过滤掉<code class="fe ls lt lu lv b">formData</code>中的学生，只包括那些有<code class="fe ls lt lu lv b">listId</code>的学生。</li><li id="9e7d" class="mo mp in kv b kw mx la my le mz li na lm nb lq mt mu mv mw bi translated">然后，我映射每个学生并传递道具，我将在下面解释。</li></ul><h2 id="096d" class="mj jw in bd jx nd ne dn kb nf ng dp kf le nh ni kj li nj nk kn lm nl nm kr nn bi translated">创建<AddStudent/>组件</h2><p id="364f" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated"><code class="fe ls lt lu lv b">&lt;AddStudent /&gt;</code>组件创建一个下拉输入和一个按钮来删除学生。</p><pre class="mb mc md me gt mf lv mg mh aw mi bi"><span id="99e1" class="mj jw in lv b gy mk ml l mm mn">const AddStudent = ({<br/>  addedStudents,<br/>  removeStudent,<br/>  updateStudent,<br/>  student<br/>}) =&gt; {<br/>  return (<br/>    &lt;Row&gt;<br/>      &lt;Col&gt;<br/>        &lt;AddStudentDropDown<br/>          key={student.listId}<br/>          addedStudents={addedStudents}<br/>          student={student}<br/>          updateStudent={updateStudent}<br/>        /&gt;<br/>      &lt;/Col&gt;<br/>      &lt;Col&gt;<br/>        &lt;Button<br/>          onClick={() =&gt; removeStudent(student)}<br/>          variant='outline-dark'<br/>        &gt;x&lt;/Button&gt;<br/>      &lt;/Col&gt;<br/>    &lt;/Row&gt;<br/>  )<br/>}</span><span id="9a2b" class="mj jw in lv b gy nc ml l mm mn">export default AddStudent;</span></pre><p id="d712" class="pw-post-body-paragraph kt ku in kv b kw lw ky kz la lx lc ld le ly lg lh li lz lk ll lm ma lo lp lq ig bi translated">要添加学生:</p><pre class="mb mc md me gt mf lv mg mh aw mi bi"><span id="a315" class="mj jw in lv b gy mk ml l mm mn">const addStudent = () =&gt; {<br/>  setListId(listId + 1)<br/>  setFormData({...formData, students: [<br/>    ...formData.students, {<br/>      listId: listId + 1,<br/>      full_name: '',<br/>      student_id: '',<br/>    }<br/>  ]})<br/>}</span></pre><ul class=""><li id="5daa" class="mo mp in kv b kw lw la lx le mq li mr lm ms lq mt mu mv mw bi translated">我增加了<code class="fe ls lt lu lv b">listId</code>以防止重复，并给<code class="fe ls lt lu lv b">formData.students</code>添加了一个新学生。</li><li id="36e8" class="mo mp in kv b kw mx la my le mz li na lm nb lq mt mu mv mw bi translated">这个函数不包含关于学生的信息，所以我只添加了一个学生输入。</li></ul><h2 id="93b2" class="mj jw in bd jx nd ne dn kb nf ng dp kf le nh ni kj li nj nk kn lm nl nm kr nn bi translated">创建<code class="fe ls lt lu lv b">&lt;AddStudentDropdown /&gt;</code></h2><p id="e212" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated"><code class="fe ls lt lu lv b">&lt;AddStudentDropdown /&gt;</code>需要创建一个<code class="fe ls lt lu lv b">&lt;option&gt;</code>用于:</p><ul class=""><li id="be87" class="mo mp in kv b kw lw la lx le mq li mr lm ms lq mt mu mv mw bi translated">所有未注册的学生</li><li id="1317" class="mo mp in kv b kw mx la my le mz li na lm nb lq mt mu mv mw bi translated">被传承的学生，如果有一个被传承的话。</li></ul><p id="b63f" class="pw-post-body-paragraph kt ku in kv b kw lw ky kz la lx lc ld le ly lg lh li lz lk ll lm ma lo lp lq ig bi translated">我在<code class="fe ls lt lu lv b">studentOptions</code>中使用了 if/else 语句。</p><pre class="mb mc md me gt mf lv mg mh aw mi bi"><span id="ef5a" class="mj jw in lv b gy mk ml l mm mn">import { Form } from "react-bootstrap";<br/>import { selectAllStudents } from "../students/studentsSlice";<br/>import { useSelector } from "react-redux";</span><span id="0dd9" class="mj jw in lv b gy nc ml l mm mn">const AddStudentDropDown = ({<br/>  student, <br/>  updateStudent, <br/>  addedStudents <br/>}) =&gt; {</span><span id="f516" class="mj jw in lv b gy nc ml l mm mn">  const students = useSelector(selectAllStudents)<br/>  <strong class="lv io">const studentOptions</strong> = students.length &gt; 0 ? students.map((std) =&gt; {<br/><strong class="lv io">    //display the student passed down, if one is passed down<br/></strong>    if(std.id === student.student_id){<br/>      return &lt;option<br/>        value={student.student_id}<br/>        key={student.student_id}<br/>      &gt;{student.full_name}&lt;/option&gt;<br/><strong class="lv io">    //display all students not already in the class<br/></strong>    }else if(!addedStudents.includes(std.id)){<br/>      return &lt;option<br/>        value={std.id}<br/>        key={std.id}<br/>      &gt;{std.full_name}&lt;/option&gt;<br/>    }<br/>  }): null</span><span id="f3f1" class="mj jw in lv b gy nc ml l mm mn">  return (<br/>    &lt;Form.Group className="mb-3" controlId="students"&gt;<br/>      &lt;Form.Select <br/>        value={student.student_id} <br/>        <strong class="lv io">onChange={e =&gt; updateStudent(<br/>          e.target.value, <br/>          student.listId<br/>        )}</strong><br/>      &gt;<br/>      &lt;option&gt;Select a Student&lt;/option&gt;<br/>      {studentOptions}<br/>      &lt;/Form.Select&gt;<br/>    &lt;/Form.Group&gt;<br/>  )<br/>}<br/>export default AddStudentDropDown;</span></pre><p id="689f" class="pw-post-body-paragraph kt ku in kv b kw lw ky kz la lx lc ld le ly lg lh li lz lk ll lm ma lo lp lq ig bi translated">当学生被选中时，它触发<code class="fe ls lt lu lv b">updateStudent</code>并通过学生的<code class="fe ls lt lu lv b">id</code>和<code class="fe ls lt lu lv b">listId</code>。</p><h1 id="60aa" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">处理更新学生</h1><h2 id="59ea" class="mj jw in bd jx nd ne dn kb nf ng dp kf le nh ni kj li nj nk kn lm nl nm kr nn bi translated">场景规划</h2><p id="b46c" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">我开始为添加、删除和更新学生时可能出现的不同场景做计划。我不得不解释:</p><ul class=""><li id="cbd1" class="mo mp in kv b kw lw la lx le mq li mr lm ms lq mt mu mv mw bi translated">向新课程添加学生</li><li id="4265" class="mo mp in kv b kw mx la my le mz li na lm nb lq mt mu mv mw bi translated">从新课程中删除学生</li><li id="0472" class="mo mp in kv b kw mx la my le mz li na lm nb lq mt mu mv mw bi translated">向现有课程添加学生</li><li id="82d7" class="mo mp in kv b kw mx la my le mz li na lm nb lq mt mu mv mw bi translated">从现有课程中删除学生</li></ul><h2 id="6534" class="mj jw in bd jx nd ne dn kb nf ng dp kf le nh ni kj li nj nk kn lm nl nm kr nn bi translated">更新表单数据中的学生</h2><pre class="mb mc md me gt mf lv mg mh aw mi bi"><span id="840c" class="mj jw in lv b gy mk ml l mm mn">const updateStudent = (id, listId) =&gt; {<br/>  const newStudent = students.find(<br/>    student =&gt; student.id === parseInt(id, 10)<br/>  )<br/>  const added = []<br/>  const updatedStudents = formData.students.map(student =&gt; {<br/>    <strong class="lv io">if (student.listId === listId) {<br/>      const studentObj = {<br/>        listId: listId,<br/>        full_name: newStudent.full_name,<br/>        student_id: newStudent.id,<br/>      }</strong><br/>      added.push(studentObj.student_id)<br/>      return studentObj<br/>    }else{<br/>      added.push(student.id)<br/>      return student<br/>    }<br/>  })<br/>  setAddedStudents(added)<br/>  setFormData({...formData, students: updatedStudents})<br/>}</span></pre><ul class=""><li id="397e" class="mo mp in kv b kw lw la lx le mq li mr lm ms lq mt mu mv mw bi translated">在<code class="fe ls lt lu lv b">updatedStudents</code>中，我通过<code class="fe ls lt lu lv b">formData.students</code>映射并用匹配的<code class="fe ls lt lu lv b">listId</code>更新对象，并更新<code class="fe ls lt lu lv b">addedStudents</code>和<code class="fe ls lt lu lv b">formData</code>。<code class="fe ls lt lu lv b">formData.students</code>中的每个对象都有一个<code class="fe ls lt lu lv b">listId</code>，所以这将更新链接到该输入的学生信息。</li></ul><h2 id="ed95" class="mj jw in bd jx nd ne dn kb nf ng dp kf le nh ni kj li nj nk kn lm nl nm kr nn bi translated">从表单数据中删除学生</h2><pre class="mb mc md me gt mf lv mg mh aw mi bi"><span id="d14b" class="mj jw in lv b gy mk ml l mm mn">const removeStudent = (studentToRemove) =&gt; {<br/>  <strong class="lv io">if (!course || (course &amp;&amp; !course.students.find(student =&gt; student.id === studentToRemove.student_id)))</strong> {<br/>    setFormData({<br/>      ...formData, <br/>      students: formData.students.filter((student) =&gt; student !== studentToRemove)<br/>    })<br/>  }else{<br/>    const updatedStudents = formData.students.map( student =&gt; {<br/><strong class="lv io">      if(student.student_id === studentToRemove.student_id) {<br/></strong>        <strong class="lv io">return {<br/>          id: studentToRemove.student_course_id, <br/>          _destroy: '1'<br/>        }</strong><br/>      }else{<br/>        return student<br/>      }<br/>    })<br/><strong class="lv io">    setFormData({...formData, students: updatedStudents})<br/></strong>  }<br/>  <strong class="lv io">setAddedStudents([...addedStudents.filter(<br/>    id =&gt; id !== studentToRemove.id)]<br/>  )</strong><br/>}</span></pre><p id="172c" class="pw-post-body-paragraph kt ku in kv b kw lw ky kz la lx lc ld le ly lg lh li lz lk ll lm ma lo lp lq ig bi translated"><code class="fe ls lt lu lv b">if (!course || (course &amp;&amp; !course.students.find(student =&gt; student.id === studentToRemove.student_id)))</code></p><ul class=""><li id="5682" class="mo mp in kv b kw lw la lx le mq li mr lm ms lq mt mu mv mw bi translated">这将检查这是否是一个新的课程(<code class="fe ls lt lu lv b">!course</code>)，或者它是否是一个现有的课程，并且在加载该课程时该学生不是该课程的一部分(<code class="fe ls lt lu lv b">course &amp;&amp; !course.students.find(student =&gt; student.id === studentToRemove.student_id)</code>)</li><li id="6cba" class="mo mp in kv b kw mx la my le mz li na lm nb lq mt mu mv mw bi translated">如果是这种情况，那么该学生可以从<code class="fe ls lt lu lv b">formData.students</code>除名</li></ul><p id="a3df" class="pw-post-body-paragraph kt ku in kv b kw lw ky kz la lx lc ld le ly lg lh li lz lk ll lm ma lo lp lq ig bi translated">如果不是这样，那么需要更新<code class="fe ls lt lu lv b">formData.students</code>中的条目，以销毁表单提交中的<code class="fe ls lt lu lv b">student_courses</code>实例。</p><ul class=""><li id="5191" class="mo mp in kv b kw lw la lx le mq li mr lm ms lq mt mu mv mw bi translated"><code class="fe ls lt lu lv b">id:</code>被设置为<code class="fe ls lt lu lv b">student_course</code>的<code class="fe ls lt lu lv b">id</code>并且<code class="fe ls lt lu lv b">_destroy: 1</code>被添加到对象。这是<code class="fe ls lt lu lv b">accepts_nested_attributes_for</code> <a class="ae lr" href="https://api.rubyonrails.org/classes/ActiveRecord/NestedAttributes/ClassMethods.html" rel="noopener ugc nofollow" target="_blank">要求</a>的格式。</li></ul><h1 id="51f4" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">HTTP 请求</h1><h2 id="ffef" class="mj jw in bd jx nd ne dn kb nf ng dp kf le nh ni kj li nj nk kn lm nl nm kr nn bi translated">发布创建新类的请求</h2><pre class="mb mc md me gt mf lv mg mh aw mi bi"><span id="abb1" class="mj jw in lv b gy mk ml l mm mn">const coursePost = () =&gt; {</span><span id="72f1" class="mj jw in lv b gy nc ml l mm mn">  const strongParams = {<br/>    course: {<br/>      name: parseInt(formData.name),<br/>      meeting_day: parseInt(formData.meeting_day),<br/>      status: parseInt(formData.status),<br/>      setting: parseInt(formData.setting),<br/>      start_date: formData.start_date,<br/>      start_time: formData.start_time,<br/>      level: parseInt(formData.level),<br/><strong class="lv io">      student_courses_attributes: formData.students<br/></strong>    },<br/>  }</span><span id="22df" class="mj jw in lv b gy nc ml l mm mn">  fetch('/courses', {<br/>    method: "POST",<br/>    headers: {<br/>      ...headers,<br/>      ...getToken()<br/>    },<br/>    body: JSON.stringify(strongParams)</span><span id="21bd" class="mj jw in lv b gy nc ml l mm mn">  ...<br/>  }<br/>}</span></pre><p id="79a5" class="pw-post-body-paragraph kt ku in kv b kw lw ky kz la lx lc ld le ly lg lh li lz lk ll lm ma lo lp lq ig bi translated">对于 POST 请求，我需要更新 formData，如上所示。Rails 要求包含嵌套关联数据的键被命名为<code class="fe ls lt lu lv b">associated_table_name_attributes</code>，在本例中，关联表是<code class="fe ls lt lu lv b">student_course</code>，我使用了<code class="fe ls lt lu lv b">student_courses_attributes</code>，因为有许多<code class="fe ls lt lu lv b">student_courses</code>与每个<code class="fe ls lt lu lv b">course</code>相关联。</p><h2 id="a69e" class="mj jw in bd jx nd ne dn kb nf ng dp kf le nh ni kj li nj nk kn lm nl nm kr nn bi translated">更新现有课程的补丁请求</h2><pre class="mb mc md me gt mf lv mg mh aw mi bi"><span id="97b4" class="mj jw in lv b gy mk ml l mm mn">const coursePatch = () =&gt; {<br/><strong class="lv io">  const existingIds = course.students.map(student =&gt; student.id)<br/></strong>  const strongParams = {<br/>    course: {<br/>      name: parseInt(formData.name),<br/>      meeting_day: parseInt(formData.meeting_day),<br/>      status: parseInt(formData.status),<br/>      setting: parseInt(formData.setting),<br/>      start_date: formData.start_date,<br/>      start_time: formData.start_time,<br/>      level: parseInt(formData.level),<br/>      <strong class="lv io">student_courses_attributes: formData.students.filter(student =&gt; !existingIds.includes(student.student_id))<br/>    </strong>},<br/>  }</span><span id="4da2" class="mj jw in lv b gy nc ml l mm mn">  fetch(`/courses/${classId}`, {<br/>    method: "PATCH",<br/>    headers: {<br/>      ...headers,<br/>      ...getToken()<br/>    },<br/>    body: JSON.stringify(<strong class="lv io">strongParams</strong>)<br/>  })<br/>  ...<br/>}</span></pre><ul class=""><li id="fbde" class="mo mp in kv b kw lw la lx le mq li mr lm ms lq mt mu mv mw bi translated">这里，我从 student 对象的<code class="fe ls lt lu lv b">student_courses_attributes</code>数组中过滤掉所有未更改的学生记录。这确保我在提交表单时不会创建任何重复的记录。</li></ul><p id="13e7" class="pw-post-body-paragraph kt ku in kv b kw lw ky kz la lx lc ld le ly lg lh li lz lk ll lm ma lo lp lq ig bi translated">现在表单的这一部分是可操作的！</p><p id="4f93" class="pw-post-body-paragraph kt ku in kv b kw lw ky kz la lx lc ld le ly lg lh li lz lk ll lm ma lo lp lq ig bi translated">按照本教程和我的<a class="ae lr" rel="noopener ugc nofollow" target="_blank" href="/passing-a-nested-array-of-objects-to-a-controller-to-update-associated-records-in-rails-38913ae01f6c">上一篇</a>关于在后端设置的教程，你可以创建一个具有灵活数量输入的表单，并在你的 Rails 后端创建、更新和删除相关记录！</p><p id="bd67" class="pw-post-body-paragraph kt ku in kv b kw lw ky kz la lx lc ld le ly lg lh li lz lk ll lm ma lo lp lq ig bi translated">我希望这篇文章能帮助你在你的项目中实现同样的事情。如果是这样，请留下你的回购评论，让我可以看到你的工作！此外，如果你觉得这篇文章很有帮助，请鼓掌并跟我来查看未来的文章。</p></div></div>    
</body>
</html>