<html>
<head>
<title>Dynamic Programming: Longest Common Subsequence Visually Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动态编程:最长公共子序列直观解释</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/dynamic-programming-longest-common-subsequence-visually-explained-95e70ef71046?source=collection_archive---------12-----------------------#2020-06-29">https://blog.devgenius.io/dynamic-programming-longest-common-subsequence-visually-explained-95e70ef71046?source=collection_archive---------12-----------------------#2020-06-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e50deba49236ae11d4e11a92356bacef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*INrf-3a8ixRYy76QCXSfoA.jpeg"/></div></div></figure><p id="adf1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi kw translated">计算机科学中出现的另一类问题是寻找最长的公共子序列。如果有以下字符串，BEADCA和ABCDA，最长的公共子序列是什么？你可能会很快发现这两个字符串的最长公共子序列是BDA。可能有多个长度相等的子序列可以工作。让我们看看如何在这个问题中找到最长的公共子序列。</p><p id="0ede" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们从构造一个矩阵开始。一个序列放在矩阵的顶部，另一个放在左侧。对于每个行/列匹配，我们将输入1。如果没有匹配，我们将输入一个零，除非相邻的单元格已经大于零，在这种情况下，我们输入该值。对于相邻单元格已经大于1的所有其他匹配，新单元格将加1。让我们看看实际情况是怎样的。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lf"><img src="../Images/f72c50e46ceb4fc66c2cf3da7b0fc235.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FywGbmxpWhqZS9SgFkhIHA.png"/></div></div></figure><p id="27dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将从用零填充第一行和第一列开始。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lk"><img src="../Images/38421e88f2266b90d89b67555ee0f630.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c9dukmrU5mqqE0_UqPvtbg.png"/></div></div></figure><p id="1f5d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们从第一行B开始。行B与列a进行比较。因为没有匹配，所以为该点输入零。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ll"><img src="../Images/15d34de1f2b6dfa26e7b912648732fc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*dlEKxWnPHvkea1rh6TVKNQ.png"/></div></div></figure><p id="9aab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一个比较是在行B和列B之间。由于它们匹配，我们将添加值1，该值是从单元格(_，A)的添加的<strong class="ka ir">。</strong></p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lm"><img src="../Images/ffa8c9b3c292cf0bef262280a10d187c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GaODvism94NQ-51m2u0Fbw.png"/></div></div></figure><p id="96b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当比较B行和c列时，我们发现没有匹配。我们从单元格(B，B)中取出1。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi gj"><img src="../Images/312fa62949fee39ebde0906d8fe0948a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jSfegzhWFGdfI5lUYjdFZA.png"/></div></div></figure><p id="3fc2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">类似地，我们将1从单元格(B，C)携带到单元格(B，D)和单元格(B，A)。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ln"><img src="../Images/b0d8f707e787e279ddff57a993c70391.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xyFnt_1TduMtoDNWa2Jesw.png"/></div></div></figure><p id="313b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们移到第二排。对于E行，我们将其与第一列进行比较。因为它们不相同，所以我们为该单元格输入零。我们移动到B列。即使没有匹配，我们也可以从单元格(B，B)中取出1。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lo"><img src="../Images/12028031b68e802129b62db48a731879.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rujd67UMzBf2oaQ0o0E2vw.png"/></div></div></figure><p id="3b30" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为没有其他列值与行E匹配，所以我们可以将1带入下一行。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi gj"><img src="../Images/4c103faebdb7dde35e78364c9adbb695.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SxhLtlicw2hamYLT3bl4Iw.png"/></div></div></figure><p id="4ff5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们向下移动到行A。行A和列A是相同的，所以我们在单元格(A，A)中输入1。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lp"><img src="../Images/ad21b316ef9a8c547c9df4174e96a8c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dQca8MVgPo8TuORp-Ozucw.png"/></div></div></figure><p id="c010" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">继续向前，下一个值不匹配:A不匹配b。但是，我们可以从上往下取1。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lq"><img src="../Images/c070b2e20d3801e78b26cb1c35445281.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4CXIMRuyZ6lT_oFFKY2qFA.png"/></div></div></figure><p id="adfe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">行A与C或D都不匹配，所以我们将把1从单元格(A，B)移到这些单元格中。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lr"><img src="../Images/f8acbdca95f3454e1e26ae7b8129af6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0fftGIaHubXfFArp9xeuMQ.png"/></div></div></figure><p id="b287" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一个单元格匹配。我们将在左上角的单元格(E，D)中添加1，并在单元格(A，A)中输入新值2。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ls"><img src="../Images/7e361350a6401dc0cfb020d587b1971b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s8cQZCEyLGoJLIYeqa2n1Q.png"/></div></div></figure><p id="81e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们移到下一排。D行与第一列不匹配，所以我们只把1取下来。它与接下来的两列也没有匹配，所以我们将把1从单元格(D，A)移到单元格(D，B)和(D，C)。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lt"><img src="../Images/7020e19c8260ca7a6d61696acf737434.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bJqXpc6-7Acn0LBGLebiZQ.png"/></div></div></figure><p id="2c23" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">D行与D列匹配，所以我们将在左上角的单元格(A，C)中加1。每当有一个匹配，你总是会增加1到左上角的单元格，并将其插入到新的单元格。这些转换将帮助您创建最长的公共子序列。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lu"><img src="../Images/d158253ebc87e808ed54bc5de30cb58a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L1VoSKRS_twfV6cto4bIPQ.png"/></div></div></figure><p id="5ebc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">D行与A列不匹配，所以我们将把最大值移到它的位置。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lo"><img src="../Images/2d6f0debee55538f41f0aa564eafb6bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m8CnvatYKRESvY5Y-YU4OQ.png"/></div></div></figure><p id="9f75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">移至行C，第一个单元格的值为1，因为这是它们周围的最大值。A列与c行不匹配。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lu"><img src="../Images/4727029fdbc444679445427644278e59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3MZ6eu2QVdJx88Eth_55QA.png"/></div></div></figure><p id="8307" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一个单元格匹配，所以我们将位于左上角单元格中的值加1，并将其添加到新单元格中。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lo"><img src="../Images/6b7e019d44d4fb33ea4c5e51b7963f49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x8w2Qza9wiqHMk8GBaGuww.png"/></div></div></figure><p id="c1f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来的两个单元格不匹配，所以我们只将最大值移入这些单元格。当我们完成这个表时，我们将解释为什么我们从单元格(C，D)的上面移动，而从单元格(C，A)的左边移动。现在，只要知道我们正试图获得尽可能长的路径。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lv"><img src="../Images/fb1570a216777b05390fce5193b35dc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a3NEfrianlClugoxi9-AMw.png"/></div></div></figure><p id="e4b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在最后一行，A与列A匹配，所以我们将在左上角的单元格中加1，并将该值插入新的单元格中。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lu"><img src="../Images/93ffac5eecf174a7da75dfea9e1532f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vOI8_p7gxbfvvPdqXBrQUg.png"/></div></div></figure><p id="da64" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于单元格(A，B ),我们将把最大值移入其中。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lw"><img src="../Images/6b141c247a92361d83e2d34e3943386c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BTHWoxypkZmcuOWagQYS6Q.png"/></div></div></figure><p id="7a8c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">单元格(A，C)的上方比其左侧包含一个更大的值，所以我们将把这个更大的值从上方移入其中。根据经验，如果左边的值与上面的值相同，则从上面移动该值。这并不意味着你不应该考虑来自左边的其他路径。可能是一个相等大小的子序列来自左边。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lx"><img src="../Images/123790081862db42f2dc785566a5ccbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ukJGdVIVv2iZ3zAtrE6yug.png"/></div></div></figure><p id="5eb2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一个单元格的行与列值不匹配，所以我们将把它周围的最大值移到新的单元格中。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lu"><img src="../Images/0c73d1c08432b5e4ab874d2b678a0f72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wp1xbtDmDD_uEgf6kK_GCg.png"/></div></div></figure><p id="1b78" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，最后一个单元格的行和列值匹配，所以我们将在左上角的单元格中加1，并在那里输入新值。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lu"><img src="../Images/17ac61c348b415e47590e20dd4405740.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K63yzzrXKzVnnW1JsuGvQQ.png"/></div></div></figure><p id="bdb9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们知道最大的公共子序列将包含3个字母，所以我们将尝试沿着路径向上，从最后一个过渡单元格(从左上角单元格添加了1的单元格)开始，并查看这些值将会是什么。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lu"><img src="../Images/19b9ee59c8f934cfefa2e136d1aaaea2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xNbrvuM7yOAVudemUWC4BA.png"/></div></div></figure><p id="1480" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以很快看到最长的公共子序列是B，D，a。</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><p id="0a5b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mf">如果你喜欢你所读的，看看我的书，</em><a class="ae mg" href="https://www.amazon.com/Illustrative-Introduction-Algorithms-Dino-Cajic-ebook-dp-B07WG48NV7/dp/B07WG48NV7/ref=mt_kindle?_encoding=UTF8&amp;me=&amp;qid=1586643862" rel="noopener ugc nofollow" target="_blank"><em class="mf"/></a><em class="mf">算法说明性介绍。</em></p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/39d8474fd87f3208b7a6156dda7865fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WCVDYXXY5uM1YOSc.jpeg"/></div></div></figure><p id="2b43" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">迪诺·卡伊奇目前是<a class="ae mg" href="https://www.lsbio.com/" rel="noopener ugc nofollow" target="_blank"> LSBio(生命周期生物科学公司)</a>、<a class="ae mg" href="https://absoluteantibody.com/" rel="noopener ugc nofollow" target="_blank">绝对抗体</a>、<a class="ae mg" href="https://www.kerafast.com/" rel="noopener ugc nofollow" target="_blank"> Kerafast </a>、<a class="ae mg" href="https://everestbiotech.com/" rel="noopener ugc nofollow" target="_blank">珠穆朗玛生物</a>、<a class="ae mg" href="https://www.nordicmubio.com/" rel="noopener ugc nofollow" target="_blank">北欧MUbio </a>和<a class="ae mg" href="https://www.exalpha.com/" rel="noopener ugc nofollow" target="_blank"> Exalpha </a>的IT主管。他还担任我的自动系统的首席执行官。他有十多年的软件工程经验。他拥有计算机科学学士学位，辅修生物学。他的背景包括创建企业级电子商务应用程序、执行基于研究的软件开发，以及通过写作促进知识的传播。</p><p id="e06a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在<a class="ae mg" href="https://www.linkedin.com/in/dinocajic/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系他，在<a class="ae mg" href="https://instagram.com/think.dino" rel="noopener ugc nofollow" target="_blank"> Instagram </a>上关注他，或者<a class="ae mg" href="https://dinocajic.medium.com/subscribe" rel="noopener">订阅他的媒体出版物</a>。</p><p id="bf4a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae mg" href="https://dinocajic.medium.com/membership" rel="noopener"> <em class="mf">阅读迪诺·卡吉克(以及媒体上成千上万其他作家)的每一个故事。你的会员费直接支持迪诺·卡吉克和你阅读的其他作家。你也可以在媒体上看到所有的故事。</em> </a></p></div></div>    
</body>
</html>