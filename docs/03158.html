<html>
<head>
<title>DFS (Depth First Search) Traversal Techniques — Short and Sweet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DFS(深度优先搜索)遍历技术—简洁明了</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/dfs-depth-first-search-traversal-techniques-short-and-sweet-1e4c134babcf?source=collection_archive---------2-----------------------#2020-10-06">https://blog.devgenius.io/dfs-depth-first-search-traversal-techniques-short-and-sweet-1e4c134babcf?source=collection_archive---------2-----------------------#2020-10-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/4f8cd19828f79ce486a0c5a0b6978067.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*eyqACQAziXkSuMNmMeTa6A.png"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk translated"><a class="ae jv" href="https://thenafi36.wordpress.com/2014/09/26/uva-536-tree-recover/" rel="noopener ugc nofollow" target="_blank">https://thenafi 36 . WordPress . com/2014/09/26/UVA-536-tree-recover/</a></figcaption></figure><h1 id="311d" class="jw jx in bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">什么是二叉树？</h1><p id="cdc0" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">二叉树是一种树形数据结构，其中每个节点最多有两个子节点。这些孩子被称为左孩子和右孩子。树中最顶端的节点被称为根节点。</p><p id="ca53" class="pw-post-body-paragraph ku kv in kw b kx ls kz la lb lt ld le lf lu lh li lj lv ll lm ln lw lp lq lr ig bi translated">树是节点的集合。节点由边连接。每个节点都包含一个值，它可能有也可能没有子节点。</p><h1 id="6acf" class="jw jx in bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><strong class="ak">什么是遍历树？</strong></h1><p id="8b84" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">遍历树是对树中的每个节点只访问一次的过程。遍历树有两种广为人知的技术:</p><ul class=""><li id="4493" class="lx ly in kw b kx ls lb lt lf lz lj ma ln mb lr mc md me mf bi translated">DFS 或深度优先搜索</li><li id="44f6" class="lx ly in kw b kx mg lb mh lf mi lj mj ln mk lr mc md me mf bi translated">BFS 或广度优先搜索—层级顺序遍历</li></ul><p id="a7e0" class="pw-post-body-paragraph ku kv in kw b kx ls kz la lb lt ld le lf lu lh li lj lv ll lm ln lw lp lq lr ig bi translated">我们将关注 DFS(深度优先搜索)技术。这些算法可以推广应用到二叉树以外的其他类型的树。</p><h1 id="ec73" class="jw jx in bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">3 DFS 遍历技术</h1><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/bfe69412e0f2f0f918e2c11e1d0e5815.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*c7nIgmTkEyR6A0Ql-ezUlA.png"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk translated"><a class="ae jv" href="https://www.journaldev.com/44201/breadth-first-search-depth-first-search-bfs-dfs" rel="noopener ugc nofollow" target="_blank">https://www . journal dev . com/44201/width-first-search-depth-first-search-bfs-DFS</a></figcaption></figure><ol class=""><li id="c81a" class="lx ly in kw b kx ls lb lt lf lz lj ma ln mb lr mq md me mf bi translated">有序遍历—左、根、右<code class="fe mr ms mt mu b">3 1 4 0 2</code></li><li id="b4b5" class="lx ly in kw b kx mg lb mh lf mi lj mj ln mk lr mq md me mf bi translated">前序遍历—根、左、右<code class="fe mr ms mt mu b">0 1 3 4 2</code></li><li id="5206" class="lx ly in kw b kx mg lb mh lf mi lj mj ln mk lr mq md me mf bi translated">后序遍历——左、右、根<code class="fe mr ms mt mu b">3 4 1 2 0</code></li></ol><p id="0b06" class="pw-post-body-paragraph ku kv in kw b kx ls kz la lb lt ld le lf lu lh li lj lv ll lm ln lw lp lq lr ig bi translated">让我们首先建立我们的二叉树数据结构:</p><pre class="mm mn mo mp gt mv mu mw mx aw my bi"><span id="3e53" class="mz jx in mu b gy na nb l nc nd">function TreeNode(val, left, right) {<br/>  this.val = (val===undefined ? 0 : val)<br/>  this.left = (left===undefined ? null : left)<br/>  this.right = (right===undefined ? null : right)<br/>}</span></pre><h1 id="8371" class="jw jx in bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><strong class="ak">顺序遍历</strong></h1><p id="b740" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">Inorder 遍历最初在左子节点上连续递归，直到该根没有左子节点。</p><ol class=""><li id="3b8d" class="lx ly in kw b kx ls lb lt lf lz lj ma ln mb lr mq md me mf bi translated">在左侧子节点上递归</li><li id="ab85" class="lx ly in kw b kx mg lb mh lf mi lj mj ln mk lr mq md me mf bi translated">遍历当前根节点</li><li id="dfae" class="lx ly in kw b kx mg lb mh lf mi lj mj ln mk lr mq md me mf bi translated">在右侧子节点上递归</li></ol><p id="2140" class="pw-post-body-paragraph ku kv in kw b kx ls kz la lb lt ld le lf lu lh li lj lv ll lm ln lw lp lq lr ig bi translated">当我们弹出调用堆栈时(退出每个递归函数)，我们将继续推送值并在正确的节点上递归(如果它存在的话)。</p><pre class="mm mn mo mp gt mv mu mw mx aw my bi"><span id="936a" class="mz jx in mu b gy na nb l nc nd">var inorderTraversal = function(root) {<br/>    let result = [];<br/>    let helper = function(node) {<br/>        if (node) {<br/>            helper(node.left);<br/>            result.push(node.val);<br/>            helper(node.right);<br/>        }<br/>    }<br/>    helper(root);<br/>    return result;<br/>};</span></pre><h1 id="b4bf" class="jw jx in bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">前序遍历</h1><p id="43f3" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">与顺序类似，但是步骤的顺序不同。</p><ol class=""><li id="4586" class="lx ly in kw b kx ls lb lt lf lz lj ma ln mb lr mq md me mf bi translated">遍历当前根节点</li><li id="bdbe" class="lx ly in kw b kx mg lb mh lf mi lj mj ln mk lr mq md me mf bi translated">在左侧子节点上递归</li><li id="a668" class="lx ly in kw b kx mg lb mh lf mi lj mj ln mk lr mq md me mf bi translated">在右侧子节点上递归</li></ol><pre class="mm mn mo mp gt mv mu mw mx aw my bi"><span id="8d47" class="mz jx in mu b gy na nb l nc nd">var preorderTraversal = function(root) {<br/>    let result = [];<br/>    let helper = function(node) {<br/>        if (node) {<br/>            result.push(node.val);<br/>            helper(node.left);<br/>            helper(node.right);<br/>        }<br/>    }<br/>    helper(root);<br/>    return result;<br/>};</span></pre><h1 id="a873" class="jw jx in bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">后序遍历</h1><p id="6c5c" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">与顺序类似，但是步骤的顺序不同。</p><ol class=""><li id="f930" class="lx ly in kw b kx ls lb lt lf lz lj ma ln mb lr mq md me mf bi translated">在左侧子节点上递归</li><li id="e334" class="lx ly in kw b kx mg lb mh lf mi lj mj ln mk lr mq md me mf bi translated">在右侧子节点上递归</li><li id="6bc3" class="lx ly in kw b kx mg lb mh lf mi lj mj ln mk lr mq md me mf bi translated">遍历当前根节点</li></ol><pre class="mm mn mo mp gt mv mu mw mx aw my bi"><span id="bdca" class="mz jx in mu b gy na nb l nc nd">var preorderTraversal = function(root) {<br/>    let result = [];<br/>    let helper = function(node) {<br/>        if (node) {<br/>            helper(node.left);<br/>            helper(node.right);<br/>            result.push(node.val);<br/>        }<br/>    }<br/>    helper(root);<br/>    return result;<br/>};</span></pre></div><div class="ab cl ne nf hr ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ig ih ii ij ik"><h1 id="570e" class="jw jx in bd jy jz nl kb kc kd nm kf kg kh nn kj kk kl no kn ko kp np kr ks kt bi translated">下一个挑战——我们如何迭代地实现它？</h1><p id="30f9" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">当迭代地实现这个算法时，同样的概念也适用。我们可以将调用栈想象成一个数组，并继续将子树添加(推送)到调用栈中，直到它被弹出。</p><p id="22ee" class="pw-post-body-paragraph ku kv in kw b kx ls kz la lb lt ld le lf lu lh li lj lv ll lm ln lw lp lq lr ig bi translated">二叉树逆向遍历的迭代算法示例。</p><pre class="mm mn mo mp gt mv mu mw mx aw my bi"><span id="59a2" class="mz jx in mu b gy na nb l nc nd">var inorderTraversal = function(root) {<br/>    let result = [];<br/>    let stack = [];<br/>    while (root || stack.length &gt; 0) {<br/>        if (root) {<br/>            stack.push(root);<br/>            root = root.left<br/>        } else {<br/>            let save = stack.pop();<br/>            result.push(save.val);<br/>            root = save.right;            <br/>        }        <br/>    }<br/>    return result;<br/>};</span></pre><p id="1ae9" class="pw-post-body-paragraph ku kv in kw b kx ls kz la lb lt ld le lf lu lh li lj lv ll lm ln lw lp lq lr ig bi translated">尝试看看我们如何为 DFS 的另外两个变体重新排序算法。调用堆栈的序列在这里会是什么样子？</p></div><div class="ab cl ne nf hr ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ig ih ii ij ik"><p id="1aff" class="pw-post-body-paragraph ku kv in kw b kx ls kz la lb lt ld le lf lu lh li lj lv ll lm ln lw lp lq lr ig bi translated">我在黑客反应堆的第 13 周。我们现在正在建立自己的迷你应用程序！到目前为止，这是一个很好的学习经历，谁不喜欢建造东西。</p></div></div>    
</body>
</html>