<html>
<head>
<title>Singly Linked List — Typescript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单链表—打字稿</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/singly-linked-list-typescript-90e5bb24f221?source=collection_archive---------0-----------------------#2019-12-29">https://blog.devgenius.io/singly-linked-list-typescript-90e5bb24f221?source=collection_archive---------0-----------------------#2019-12-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/abdde127af295abf4f49821e44e1c67d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*o6bhDkuPkLX2CJXt"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">索尔马兹·哈塔米安在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="3c9c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我将讲解如何在typescript中创建一个单链表。首先我会给你看代码，然后我会解释它是如何工作的(用图片)</p><p id="4118" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您只想获取并使用这段代码，您可能需要省略每个类(node，LinkedList)前面的“export”。我在我的typescript存储库中为我的环境设置了它，但是您不需要它来处理单个文件中的列表。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="8826" class="lh li in ld b gy lj lk l ll lm">export class node {</span><span id="8669" class="lh li in ld b gy ln lk l ll lm">value:number;</span><span id="0b35" class="lh li in ld b gy ln lk l ll lm">next:node|null;</span><span id="7c6a" class="lh li in ld b gy ln lk l ll lm">constructor(value:number) {</span><span id="912b" class="lh li in ld b gy ln lk l ll lm">this.value = value;</span><span id="5653" class="lh li in ld b gy ln lk l ll lm">this.next = null;</span><span id="0eed" class="lh li in ld b gy ln lk l ll lm">}</span><span id="cf50" class="lh li in ld b gy ln lk l ll lm">}</span><span id="fd8a" class="lh li in ld b gy ln lk l ll lm">export class LinkedList {</span><span id="f881" class="lh li in ld b gy ln lk l ll lm">head:node|null = null</span><span id="c690" class="lh li in ld b gy ln lk l ll lm">constructor() {</span><span id="9b05" class="lh li in ld b gy ln lk l ll lm">this.head = null;</span><span id="4a78" class="lh li in ld b gy ln lk l ll lm">}</span><span id="30cc" class="lh li in ld b gy ln lk l ll lm">appendNode:Function = (value:number) =&gt; {</span><span id="3f4d" class="lh li in ld b gy ln lk l ll lm">if (this.head == null) {</span><span id="67e8" class="lh li in ld b gy ln lk l ll lm">this.head = new node(value)</span><span id="efd4" class="lh li in ld b gy ln lk l ll lm">} else if (this.head.next == null) {</span><span id="3ea8" class="lh li in ld b gy ln lk l ll lm">this.head.next = new node(value)</span><span id="e95f" class="lh li in ld b gy ln lk l ll lm">} else {</span><span id="d590" class="lh li in ld b gy ln lk l ll lm"><em class="lo">//    finding the tail</em></span><span id="d2fe" class="lh li in ld b gy ln lk l ll lm">let a:node|null = this.head.next</span><span id="d8be" class="lh li in ld b gy ln lk l ll lm">while (a.next) {</span><span id="c532" class="lh li in ld b gy ln lk l ll lm">a = a.next</span><span id="6eff" class="lh li in ld b gy ln lk l ll lm">}</span><span id="c3b4" class="lh li in ld b gy ln lk l ll lm">a.next = new node(value)</span><span id="593e" class="lh li in ld b gy ln lk l ll lm">}</span><span id="6e64" class="lh li in ld b gy ln lk l ll lm">}</span><span id="e5e8" class="lh li in ld b gy ln lk l ll lm">deletePosition:Function = (position:number) =&gt; {</span><span id="f40d" class="lh li in ld b gy ln lk l ll lm">if (this.head == null) {</span><span id="cf5d" class="lh li in ld b gy ln lk l ll lm">return "The list is empty"</span><span id="8064" class="lh li in ld b gy ln lk l ll lm">} else if (position == 1) {</span><span id="5269" class="lh li in ld b gy ln lk l ll lm">this.head = this.head.next</span><span id="e279" class="lh li in ld b gy ln lk l ll lm">} else {</span><span id="4922" class="lh li in ld b gy ln lk l ll lm">let counter:number = 2</span><span id="8b9d" class="lh li in ld b gy ln lk l ll lm">let a:null|node = this.head</span><span id="ec1f" class="lh li in ld b gy ln lk l ll lm">while (a.next &amp;&amp; counter != position) {</span><span id="44de" class="lh li in ld b gy ln lk l ll lm">a = a.next</span><span id="5197" class="lh li in ld b gy ln lk l ll lm">counter += 1</span><span id="5f4b" class="lh li in ld b gy ln lk l ll lm">}</span><span id="01bd" class="lh li in ld b gy ln lk l ll lm">a.next = a.next.next</span><span id="9fa7" class="lh li in ld b gy ln lk l ll lm">}</span><span id="c6f4" class="lh li in ld b gy ln lk l ll lm">}</span><span id="36d7" class="lh li in ld b gy ln lk l ll lm">putAllValuesInArray:Function = () =&gt; {</span><span id="4242" class="lh li in ld b gy ln lk l ll lm">let output: any[] = []</span><span id="9cd9" class="lh li in ld b gy ln lk l ll lm">if (this.head == null) {</span><span id="8db5" class="lh li in ld b gy ln lk l ll lm">return "The list is empty"</span><span id="2782" class="lh li in ld b gy ln lk l ll lm">} else if (this.head.next == null) {</span><span id="c7eb" class="lh li in ld b gy ln lk l ll lm">return this.head.value</span><span id="a40f" class="lh li in ld b gy ln lk l ll lm">} else {</span><span id="befc" class="lh li in ld b gy ln lk l ll lm">let c:node|null = this.head.next</span><span id="95f6" class="lh li in ld b gy ln lk l ll lm">while (c.next) {</span><span id="21a8" class="lh li in ld b gy ln lk l ll lm">output.push(c.value);</span><span id="d038" class="lh li in ld b gy ln lk l ll lm">c = c.next;</span><span id="0695" class="lh li in ld b gy ln lk l ll lm">}</span><span id="993a" class="lh li in ld b gy ln lk l ll lm">output.push(c.value)</span><span id="1922" class="lh li in ld b gy ln lk l ll lm">return output</span><span id="dbae" class="lh li in ld b gy ln lk l ll lm">}</span><span id="38c6" class="lh li in ld b gy ln lk l ll lm">}</span><span id="de4c" class="lh li in ld b gy ln lk l ll lm">findTail:Function = () =&gt; {</span><span id="7a72" class="lh li in ld b gy ln lk l ll lm">if (this.head== null) {</span><span id="3773" class="lh li in ld b gy ln lk l ll lm">return "The list is empty"</span><span id="f80a" class="lh li in ld b gy ln lk l ll lm">} else if (this.head.next == null) {</span><span id="e67a" class="lh li in ld b gy ln lk l ll lm">return this.head</span><span id="b69e" class="lh li in ld b gy ln lk l ll lm">} else {</span><span id="336f" class="lh li in ld b gy ln lk l ll lm">let a:node|null = this.head.next</span><span id="caa2" class="lh li in ld b gy ln lk l ll lm">while (a.next) {</span><span id="b3e5" class="lh li in ld b gy ln lk l ll lm">a = a.next</span><span id="d471" class="lh li in ld b gy ln lk l ll lm">}</span><span id="59e9" class="lh li in ld b gy ln lk l ll lm">return a</span><span id="0773" class="lh li in ld b gy ln lk l ll lm">}</span><span id="765c" class="lh li in ld b gy ln lk l ll lm">}</span><span id="7720" class="lh li in ld b gy ln lk l ll lm">}</span></pre><p id="f234" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我做东西的第一步总是把它画出来，或者做一个计划。这将有助于你理解它，并让你在这个过程中不至于迷失方向。</p><p id="9541" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">单链表是一种至少有两个并行对象的数据结构，每个对象都有几个属性。每个对象可以包含任意数量的包含值的属性，但是为了使这个列表正确，我们需要在每个对象中至少有一个属性指向列表中的下一个对象。</p><p id="6d5b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一开始就有两件事需要考虑。您可以有多个列表，每个列表将包含许多节点对象。因此，最简单的开始方法之一就是为列表和节点创建一个新类。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="c432" class="lh li in ld b gy lj lk l ll lm">class node {</span><span id="2f87" class="lh li in ld b gy ln lk l ll lm">}</span><span id="56c7" class="lh li in ld b gy ln lk l ll lm">class LinkedList {<br/>}</span></pre><p id="7367" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我要画出一个单链表的样子，这样我们就可以直接让它工作了。</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lp"><img src="../Images/c1c553af0ecdba49505da576a85577a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BR64lpmQd8C9cl_i575-VA.jpeg"/></div></div></figure><p id="18ba" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以我们知道我们将会有一些对象包含一些值和另一个指向列表中下一个对象的属性。列表的尾部将指向null。</p><p id="8563" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此外，这不是必需的，但一般来说，跟踪列表的头部是一种好的做法。这样做会使列表中的一些特征更容易实现。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="4543" class="lh li in ld b gy lj lk l ll lm">class node {</span><span id="1e6b" class="lh li in ld b gy ln lk l ll lm">value: number<br/>next: node | null</span><span id="5f7d" class="lh li in ld b gy ln lk l ll lm">constructor (value:number) {<br/>this.value = value;<br/>this.next = null</span><span id="3e1a" class="lh li in ld b gy ln lk l ll lm">}</span><span id="34be" class="lh li in ld b gy ln lk l ll lm">}</span><span id="8e0e" class="lh li in ld b gy ln lk l ll lm">class linkedList {</span><span id="9548" class="lh li in ld b gy ln lk l ll lm">head: node | null</span><span id="6f1f" class="lh li in ld b gy ln lk l ll lm">constrctor () {<br/>this.head = null</span><span id="2c68" class="lh li in ld b gy ln lk l ll lm">}</span><span id="c6ac" class="lh li in ld b gy ln lk l ll lm">}</span></pre><p id="9687" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">基本上，节点中的每个下一个属性都只能是null或另一个节点。</p><p id="8e20" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每个列表的每个头值都只能是null或另一个节点。</p><p id="5ac4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">(现在)制作一个没有值的节点是没有意义的。</p><p id="0b9f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这个特殊的例子中，我让每个值只能是一个数字，因为我喜欢数字。</p><p id="f551" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以用列表做很多事情，但是数据结构最起码的功能是添加值或者删除值。这就是我今天要讲的全部内容。我的列表中有一些额外的函数，比如“将所有的值放入一个数组中”,只是因为这是一种简单的方法来按顺序查看所有的值，并仔细检查我的append/delete函数是否正常工作。</p><p id="88ee" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以，看看我们的图，以及到目前为止我们的类，我们可以看到，我们可以简单地实例化list类的一个新成员，它将有一个指向null的头。新的节点成员将有一个值和一个指向null的下一个属性。</p><p id="dd1e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们继续添加一个节点。</p><p id="2a08" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我们检查头部是否为空(因为填充的列表必须总是有一个头部。)如果head为空，那么我们只需实例化一个新的节点成员，并将head转换为我们的新节点。</p><p id="f8a8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了做到这一点，我们简单地把这个:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="4e74" class="lh li in ld b gy lj lk l ll lm">if (this.head == null) {</span><span id="2c71" class="lh li in ld b gy ln lk l ll lm">this.head = new node(value)<br/>}</span></pre><p id="315d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们的追加节点函数中。</p><p id="f1ef" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是，如果我们的头部是一个节点，我们需要遍历列表找到尾部，然后确保尾部的下一个属性指向新的节点。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="3e17" class="lh li in ld b gy lj lk l ll lm">else {</span><span id="6fef" class="lh li in ld b gy ln lk l ll lm"><em class="lo">// finding the tail</em></span><span id="8749" class="lh li in ld b gy ln lk l ll lm">let a:node|null = this.head.next</span><span id="d475" class="lh li in ld b gy ln lk l ll lm">while (a.next) {</span><span id="1981" class="lh li in ld b gy ln lk l ll lm">a = a.next</span><span id="bd42" class="lh li in ld b gy ln lk l ll lm">}</span><span id="0e69" class="lh li in ld b gy ln lk l ll lm">// assigning the new node to tail.next</span><span id="754e" class="lh li in ld b gy ln lk l ll lm">a.next = new node(value)</span><span id="bed6" class="lh li in ld b gy ln lk l ll lm">}</span></pre><p id="9b66" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">跟踪事物的一个简单方法(你应该认识到这是一个常用的工具)是设置一个tracker变量，然后在你循环的时候改变这个tracker变量。</p><p id="3e88" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这种情况下，我说变量“a”要么是一个节点，要么为空。当a.next仍然是一个节点时，将“a”赋给列表中的下一个节点。一旦a.next为空，我们就会知道“a”已经被赋给了列表中的最后一个节点。(参考我们的图纸。在简单的单链表中，最后一个node.next总是指向“null”。)因为“a”是列表的尾部，而a.next是null，所以循环将中断，程序将继续计算块中的最后一条语句。</p><p id="f351" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">块中的最后一条语句将把一个新节点分配给a.next。</p><p id="0c1b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">嘣，我们的新节点被附加上了，这一点也不难。</p><p id="d078" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">删除一个节点</strong></p><p id="c5d0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你猜怎么着？根据我的经验，附加节点通常是数据结构实现中比较容易的一半。</p><p id="13b3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那么我们来说说删除一个节点。在删除节点时，您可以检查很多东西。您可以按值删除或按位置删除，甚至删除一系列节点。没关系。用于删除有问题的节点的基本概念总是相同的。</p><p id="6a35" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个过程涉及到将指针从前一个节点改变到下一个节点。再次让我们回到我们的图纸，因为这将使这更容易理解。</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lq"><img src="../Images/4a1a25b936b8ca75e8b0065debe07c3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RnYWsninTAqzMrYIdw5xUA.jpeg"/></div></div></figure><figure class="ky kz la lb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lr"><img src="../Images/cb6e3b038873f535486e68beeae4315e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6cwWWH4HHeQMr59NGnxppw.jpeg"/></div></div></figure><p id="110c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们正在删除的节点仍然有一个指向下一个节点的“next”属性，这并不重要，因为当我们遍历列表时，前一个节点的“next”属性将简单地跳过我们正在删除的节点，从而使它不可访问。</p><p id="5711" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">删除函数看起来几乎和追加节点函数一样。在本例中，我是按位置而不是值或其他任何东西来删除节点的。</p><p id="3b47" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我们需要查看列表是否为空。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="152b" class="lh li in ld b gy lj lk l ll lm">if (this.head == null) {</span><span id="b774" class="lh li in ld b gy ln lk l ll lm">return "The list is empty"</span><span id="e9d8" class="lh li in ld b gy ln lk l ll lm">}</span></pre><p id="ad35" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，如果我们删除列表中的第一个节点，我们只需遵循我们的指针改变逻辑，使列表的头实际上是第二个节点，从而使第一个节点不可访问。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="b8eb" class="lh li in ld b gy lj lk l ll lm">else if (position == 1) {</span><span id="e6e2" class="lh li in ld b gy ln lk l ll lm">this.head = this.head.next</span><span id="0f6f" class="lh li in ld b gy ln lk l ll lm">} </span></pre><p id="7cc9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，遍历列表，直到我们在我们想要的位置，然后改变相对属性指向我们想要的节点，以使被删除的节点不可访问。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="9342" class="lh li in ld b gy lj lk l ll lm">else {</span><span id="d315" class="lh li in ld b gy ln lk l ll lm">let counter:number = 2</span><span id="1a83" class="lh li in ld b gy ln lk l ll lm">let a:null|node = this.head</span><span id="dec4" class="lh li in ld b gy ln lk l ll lm">while (a.next &amp;&amp; counter != position) {</span><span id="8140" class="lh li in ld b gy ln lk l ll lm">a = a.next</span><span id="8b7b" class="lh li in ld b gy ln lk l ll lm">counter += 1</span><span id="4998" class="lh li in ld b gy ln lk l ll lm">}<br/>if (counter == position) {</span><span id="3b54" class="lh li in ld b gy ln lk l ll lm">a.next = a.next.next<br/>}</span><span id="d1fe" class="lh li in ld b gy ln lk l ll lm">}</span></pre><p id="ea51" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">基本上，我们遍历列表，使用和以前一样的“a”跟踪变量。此外，我使用一个“计数器”变量来跟踪我们在列表中的位置。</p><p id="6531" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">基本上，这个while循环将一直迭代，直到它到达列表的末尾，或者直到它找到我们正在寻找的位置。</p><p id="3065" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">关于这一点，可能看起来有点混乱，因为我们实际上是在迭代时检查下一个节点的位置，因为为了改变适当的next属性，我们需要能够以某种方式找到前一个节点。实现这一点最简单的方法是调整“计数器”的起始值，这样while循环将在目标节点之前中断一个节点。</p><p id="80e2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以通过输入一些函数调用并在命令行中查看结果来测试我们的列表，以确保它正常工作。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="79d8" class="lh li in ld b gy lj lk l ll lm">newList.appendNode(3);</span><span id="197a" class="lh li in ld b gy ln lk l ll lm">newList.appendNode(4);</span><span id="1bf8" class="lh li in ld b gy ln lk l ll lm">newList.appendNode(8);</span><span id="8406" class="lh li in ld b gy ln lk l ll lm">newList.appendNode(9);</span><span id="fdb7" class="lh li in ld b gy ln lk l ll lm">newList.appendNode(2);</span><span id="a903" class="lh li in ld b gy ln lk l ll lm">newList.appendNode(4);</span><span id="b6cc" class="lh li in ld b gy ln lk l ll lm">newList.appendNode(7);</span><span id="a60d" class="lh li in ld b gy ln lk l ll lm"><em class="lo">console.log(newList.head) //=&gt; node { value: 3, next: node { value: 4, next: node { value: 8, next: [node] }}}</em></span><span id="36f4" class="lh li in ld b gy ln lk l ll lm">console.log(newList.putAllValuesInArray()) <em class="lo">// =&gt; [ 3,4,8,9,2,4,7 ]</em></span><span id="7040" class="lh li in ld b gy ln lk l ll lm">newList.deletePosition(3)</span><span id="4fd1" class="lh li in ld b gy ln lk l ll lm">console.log(newList.putAllValuesInArray()) <em class="lo">// =&gt; [ 3,4,9,2,4,7 ]</em></span><span id="1f7e" class="lh li in ld b gy ln lk l ll lm">newList.deletePosition(5)</span><span id="79f2" class="lh li in ld b gy ln lk l ll lm">console.log(newList.putAllValuesInArray()) <em class="lo">// =&gt; [ 3,4,8,9,4,7 ]</em></span></pre><p id="713a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这里，我用一些值填充我的列表。然后我告诉它console.log列表，这样我就可以看到基本结构是否正确。然后我调用删除函数，并使用我的数组函数来确保它删除了正确的位置。(请记住，我的位置从1开始，所以不要假设它与数组索引相同)</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/06df463d22fa92c52b07fdce5f5139c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*txL6ZdxwCNX0wj6LchsUlA.jpeg"/></div></figure><p id="4089" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的基本列表结构似乎是正确的。</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/f18a51fc1eac4a1872fd196762da5bf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:528/format:webp/1*TGrKksUnF6vbBfcaTGIhnw.jpeg"/></div></figure><p id="8bcb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它似乎在删除我们希望它删除的位置。列表中的第三个位置是“8”，删除8后的第五个位置是第二个4。</p><p id="d4c9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">今天到此为止。请记住，这个列表纯粹是功能性的(至少是功能性的),如果你够聪明的话，它很容易被打破，但这应该足以让你开始。</p></div></div>    
</body>
</html>