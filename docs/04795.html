<html>
<head>
<title>SOLID Principles in Swift — Open / Closed Principle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift的坚实原则——开放/封闭原则</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/solid-principles-in-swift-open-closed-principle-21d70e7fd7d8?source=collection_archive---------6-----------------------#2021-05-07">https://blog.devgenius.io/solid-principles-in-swift-open-closed-principle-21d70e7fd7d8?source=collection_archive---------6-----------------------#2021-05-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/eafa2d98c957f976372a4d2915192117.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Hlrehr67Ghi198cl"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">蒂姆·莫斯霍尔德在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="14fc" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">背景</h1><p id="a205" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在这一系列的帖子中，我们将涉及软件开发的坚实原则。这些是一组原则/指导方针，当开发软件系统时遵循这些原则/指导方针，使得系统随着时间的推移更容易扩展和维护。让我们来看看他们寻求解决的问题:</p><ul class=""><li id="d74c" class="lz ma iq ld b le mb li mc lm md lq me lu mf ly mg mh mi mj bi translated">脆弱性:一个变化可能会破坏意想不到的部分，如果你没有一个好的测试覆盖率，这是很难检测到的</li><li id="1f6c" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated">不可移动性:一个组件很难在另一个项目或同一个项目的多个地方重用，因为它有太多耦合的依赖关系</li><li id="2ab0" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated">刚性:变更需要大量的努力，因为它影响到项目的几个部分</li></ul><p id="537c" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">那么坚实的原则是什么呢？</p><ul class=""><li id="494b" class="lz ma iq ld b le mb li mc lm md lq me lu mf ly mg mh mi mj bi translated">单一责任原则——一个类应该只有一个责任/只有一个改变的理由</li><li id="398f" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated">开闭原则——软件应该对扩展开放，但对修改关闭</li><li id="7266" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated">Liskov替换原则——程序中的对象应该可以用其子类型的实例替换，而不会改变程序的正确性</li><li id="6b5e" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated">接口分离原则——许多特定于客户端的接口比一个通用接口要好</li><li id="c16f" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated">依赖倒置原则——高级模块不应该依赖低级模块。两者都应该依赖于抽象</li></ul><p id="74f8" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">在这篇文章中，我们将集中讨论开闭原则。</p><h1 id="9299" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">这是什么意思？</h1><p id="c4ce" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">所以开闭原则规定:</p><blockquote class="ms mt mu"><p id="5edd" class="lb lc mv ld b le mb lg lh li mc lk ll mw mp lo lp mx mq ls lt my mr lw lx ly ij bi translated"><em class="iq">软件应该对扩展开放，但对修改关闭</em></p></blockquote><p id="caf8" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">这到底是什么意思？我认为在所有原则中，这是最难理解的。主要是因为这个解释留下了太多的解释空间。一个简单的谷歌搜索会提供几个例子来说明这个原理是如何工作的。在本文中，我将介绍我对这一原则的看法，以及如何构建符合这一原则的软件。</p><p id="1c45" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">让我们把注意力集中在一种类型上，这种类型违反了开闭原则。</p><h1 id="75da" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">枚举</h1><p id="bdb8" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在Swift中，enum是一个非常强大的工具。它们是第一类类型，并且可以具有相关联的值，并且符合例如协议。然而，当在特定系统或模块的边界使用时，它们会出现特定的问题。</p><p id="6446" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">让我们想象一个可以记录事件的分析系统。这是我在很多地方看到的设计模式:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="4136" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">让我们看看这里有什么。</p><ol class=""><li id="2966" class="lz ma iq ld b le mb li mc lm md lq me lu mf ly nf mh mi mj bi translated">首先定义的是一个包含所有可用的不同分析事件的枚举。一些具有相关的值。</li><li id="fc90" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly nf mh mi mj bi translated">接下来是我们的分析控制器，它将事件作为参数，从事件中获取信息，然后将其发送到我们的分析系统。</li><li id="7c56" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly nf mh mi mj bi translated">这里，我们扩展了AnalyticsEvent枚举，添加了两个变量，一个用于title，一个用于params，其中包含每个事件的开关。</li></ol><p id="fdd7" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">从表面上看，这似乎是一个不错的解决方案。我们将分析网络的实现隐藏在我们的AnalyticsController中，并设置了一组我们可以支持的事件。</p><h1 id="05d9" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">问题是</h1><p id="fc14" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">现在让我们看看这种方法引起的问题。</p><ul class=""><li id="190d" class="lz ma iq ld b le mb li mc lm md lq me lu mf ly mg mh mi mj bi translated">如果我们需要向我们的分析系统添加新事件，会发生什么？</li><li id="a85e" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated">如果我们的分析系统是一个单独的包或模块的一部分会怎么样？</li><li id="6116" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated">当我们有很多事件时会发生什么？</li></ul><p id="4ad2" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">首先，每次我们需要添加/更新或删除分析系统中的任何事件时，我们都需要修改枚举。我们不能只是实现新的事件，并让它们与系统兼容。此外，如果事件的数量变得非常大，那么代码的大小也会变大。这使得它很难阅读，维护和有点混乱。此外，enum现在具有多重责任，因为它覆盖了许多违反<a class="ae kc" href="https://pyartez.github.io/architecture/solid-principles-in-swift-single-responsibility-principle.html" rel="noopener ugc nofollow" target="_blank">单一责任原则</a>的事件。</p><p id="f210" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">第二个问题可能是更重要的一个，假设我们将应用程序分解成独立的包。这个分析控制器和事件将在一个单独的包中，如果我们想在不同的项目中重用它呢？这两种情况都变得非常困难，因为我们使用的enum需要更新以适应不同应用程序的事件。随着新事件的增加，这个包需要不断更新。</p><h1 id="c157" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">解决方案</h1><p id="4a92" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们已经发现了上述实现的一些问题，我们如何改变它来解决我们发现的这些问题呢？看看新的例子:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="6c3b" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">让我们来看看我们是如何改变示例的:</p><ol class=""><li id="6892" class="lz ma iq ld b le mb li mc lm md lq me lu mf ly nf mh mi mj bi translated">首先，我们现在已经删除了枚举。使用枚举作为可能选项的巨大列表被认为是一种代码味道。尤其是涉及到可能经常变化的事情。如果您有有限数量的不太可能改变的状态，那么它更适合于enum而不是analytics事件列表。现在，我们已经将这些枚举案例重构为两个独立的类。</li><li id="6e93" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly nf mh mi mj bi translated">我们已经为一个协议切换了enum，该协议公开了我们的分析控制器所需的必要项目(我们可能已经在前面的示例中这样做了，但是我们仍然拥有enum)。</li></ol><p id="9e07" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">那么这与之前的实现相比有什么优势呢？</p><ul class=""><li id="6ed2" class="lz ma iq ld b le mb li mc lm md lq me lu mf ly mg mh mi mj bi translated">由于事件现在位于不同的类中，我们现在遵循<a class="ae kc" href="https://pyartez.github.io/architecture/solid-principles-in-swift-single-responsibility-principle.html" rel="noopener ugc nofollow" target="_blank">单一责任原则</a>，每个事件都有自己的类，可以在需要时随时更新。</li><li id="648f" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated">现在，我们使用的是协议而不是枚举，我们现在可以向我们的应用程序添加新事件，而无需接触分析系统。只需创建一个新类，并使其符合AnalyticsEvent，我们就可以将它与analytics controller一起使用。</li><li id="2397" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated">此外，我们可以将我们的分析系统放在一个单独的可重用包中，然后我们的客户端应用程序可以定义自己的事件集来与系统一起使用。</li></ul><p id="17f8" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">我们的分析代码现在开放扩展，但不需要修改来支持新的事件。不像我们的枚举例子。</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="3602" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated"><em class="mv">原载于2021年5月7日</em><a class="ae kc" href="https://pyartez.github.io/architecture/solid-principles-in-swift-open-closed-principle.html" rel="noopener ugc nofollow" target="_blank"><em class="mv">https://pyartez . github . io</em></a><em class="mv">。</em></p></div></div>    
</body>
</html>