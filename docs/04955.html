<html>
<head>
<title>Shell Completion with Cobra and Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Cobra 和 Go 的外壳完井</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/shell-completion-with-cobra-and-go-c8368074d8f7?source=collection_archive---------0-----------------------#2021-05-27">https://blog.devgenius.io/shell-completion-with-cobra-and-go-c8368074d8f7?source=collection_archive---------0-----------------------#2021-05-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="6ef5" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">一个简短的例子，说明如何获得一个有效的 shell 完成脚本来将您的 CLI 推向下一个级别。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/67475b964a5a05d91244319f9f9843df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lRPR0k4VbSdWRAeJ"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">照片由<a class="ae ks" href="https://unsplash.com/@gamell?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">琼·加梅尔</a>在<a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="c28a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">您可能每天都在使用 CLI。根据 CLI 适用的解决方案，可用选项的数量可能会多得令人不知所措。因为没有视觉识别可用，我们依靠帮助来找到正确的参数。CLIs 的一个吸引人的扩展是为用户提供 shell 补全。通过不间断地显示命令的预期参数，简化了用户的生活。这篇文章解释了如何使用 Cobra 库在 Go 中获得一个 shell 完成 CLI。</p><p id="b41d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果您正在使用 Go 进行开发，Cobra 库是一个非常值得花时间的解决方案。这篇文章假设你熟悉这个库和它的主要概念(命令、标志等)。).Shell 完成不是由 Go 程序本身提供的。实际上，这是通过 Cobra 生成的 shell 脚本完成的，该脚本捕获用户与我们的 CLI 的交互。您可以在 15_cli 文件夹的<a class="ae ks" href="https://github.com/juanmanuel-tirado/savetheworldwithgo" rel="noopener ugc nofollow" target="_blank"> Build Systems with Go repo </a>中找到这些示例的源代码以及更多内容。</p><p id="9e0a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">以下 CLI 是一个简单的 Cobra 示例，它使用命令在控制台中打印一条消息(hello 或 bye)。</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="495d" class="lu lv in lq b gy lw lx l ly lz">package main<br/><br/>import (<br/>    "fmt"<br/>    "github.com/spf13/cobra"<br/>    "os"<br/>)<br/><br/>var RootCmd = &amp;cobra.Command{<br/>    Use: "say",<br/>    Long: "Root command",<br/>}<br/><br/>var HelloCmd = &amp;cobra.Command{<br/>    Use: "hello",<br/>    Short: "Say hello",<br/>    Run: func(cmd *cobra.Command, args []string) {<br/>        fmt.Println("Hello!!!")<br/>    },<br/>}<br/><br/>var ByeCmd = &amp;cobra.Command{<br/>    Use: "bye",<br/>    Short: "Say goodbye",<br/>    Run: func(cmd *cobra.Command, args []string) {<br/>        fmt.Println("Bye!!!")<br/>    },<br/>}<br/><br/>func init() {<br/>    RootCmd.AddCommand(HelloCmd,ByeCmd)<br/>}<br/><br/>func main() {<br/>    if err := RootCmd.Execute(); err != nil {<br/>        fmt.Fprintln(os.Stderr, err)<br/>        os.Exit(1)<br/>    }<br/>}</span></pre></div><div class="ab cl ma mb hr mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ig ih ii ij ik"><h1 id="60dd" class="mh lv in bd mi mj mk ml mm mn mo mp mq jt mr ju ms jw mt jx mu jz mv ka mw mx bi translated">创建一个 Shell 完成脚本</h1><p id="7677" class="pw-post-body-paragraph kt ku in kv b kw my jo ky kz mz jr lb lc na le lf lg nb li lj lk nc lm ln lo ig bi translated">Cobra 为 Bash、Zsh、Fish 和 PowerShell 生成 shell 完成脚本。<code class="fe nd ne nf lq b">Command</code>类型提供了带有类似<code class="fe nd ne nf lq b">GetXXXCompletions</code>签名的方法，为外壳<code class="fe nd ne nf lq b">XXX</code>生成相应的完成脚本。通常，CLI 中会添加一个<code class="fe nd ne nf lq b">completion</code>命令，允许用户为他们的 shells 生成相应的完成脚本。当脚本加载到 shell 中时，按 tab 键两次会显示有效的命令和帮助。以下示例显示了使用 root 命令的完成命令的可能实现(查看<a class="ae ks" href="https://github.com/spf13/cobra/blob/master/shell_completions.md" rel="noopener ugc nofollow" target="_blank">文档</a>了解更多详细信息)。</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="c14a" class="lu lv in lq b gy lw lx l ly lz">package cmd<br/><br/>import (<br/>    "github.com/spf13/cobra"<br/>    "os"<br/>)<br/><br/>var CompletionCmd = &amp;cobra.Command{<br/>    Use:   "completion [bash|zsh|fish|powershell]",<br/>    Short: "Generate completion script",<br/>    Long: "To load completions",<br/>    DisableFlagsInUseLine: true,<br/>    ValidArgs:             []string{"bash", "zsh", "fish", "powershell"},<br/>    Args:                  cobra.ExactValidArgs(1),<br/>    Run: func(cmd *cobra.Command, args []string) {<br/>        switch args[0] {<br/>        case "bash":<br/>            cmd.Root().GenBashCompletion(os.Stdout)<br/>        case "zsh":<br/>            cmd.Root().GenZshCompletion(os.Stdout)<br/>        case "fish":<br/>            cmd.Root().GenFishCompletion(os.Stdout, true)<br/>        case "powershell":<br/>            cmd.Root().GenPowerShellCompletionWithDesc(os.Stdout)<br/>        }<br/>    },<br/>}</span></pre><p id="c534" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我们使用</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="6533" class="lu lv in lq b gy lw lx l ly lz">RootCmd.AddCommand(HelloCmd,ByeCmd,CompletionCommand)</span></pre><p id="2278" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们可以为 Bash 生成并加载 shell 完成脚本，如下所示。</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="f74e" class="lu lv in lq b gy lw lx l ly lz">&gt;&gt;&gt; ./say completion bash &gt; /tmp/completion<br/>&gt;&gt;&gt; source /tmp/completion</span></pre><p id="c6cb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，按下 tab 键(表示为[tab])两次会显示以下内容:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="c9b7" class="lu lv in lq b gy lw lx l ly lz">&gt;&gt;&gt; ./say [tab][tab]<br/>bye         -- Say goodbye<br/>completion  -- Generate completion script<br/>hello       -- Say hello<br/>help        -- Help about any command</span></pre><p id="bb9e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">可以显示命令参数以获得更多帮助。有效参数的列表可以由类型为<code class="fe nd ne nf lq b">Command</code>的<code class="fe nd ne nf lq b">ValidArgs</code>字段提供。我们的完成命令已经为我们填充了这个字段。</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="9fc6" class="lu lv in lq b gy lw lx l ly lz">&gt;&gt; ./say completion [tab][tab]<br/>bash        fish        powershell  zsh</span></pre></div><div class="ab cl ma mb hr mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ig ih ii ij ik"><h1 id="c032" class="mh lv in bd mi mj mk ml mm mn mo mp mq jt mr ju ms jw mt jx mu jz mv ka mw mx bi translated">在运行时获取命令参数</h1><p id="b2e3" class="pw-post-body-paragraph kt ku in kv b kw my jo ky kz mz jr lb lc na le lf lg nb li lj lk nc lm ln lo ig bi translated">在某些情况下，命令的参数只能在运行时确定。例如，假设我们有一个应用程序，它使用某个用户的标识符在数据库中查询她的信息。用户 id 只有在数据库中存在时才是有效的参数。对于这些场景，可以使用字段<code class="fe nd ne nf lq b">ValidArgsFunction</code>中的函数定义有效参数列表。下面的例子用<code class="fe nd ne nf lq b">UserGet</code>函数中的随机选择器模拟不同用户的可用性。<code class="fe nd ne nf lq b">ShellCompDirective</code>是一个二进制标志，用于修改外壳行为。有关此标志及其作用的更多信息，请查阅文档。</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="2771" class="lu lv in lq b gy lw lx l ly lz">package main</span><span id="92d0" class="lu lv in lq b gy ng lx l ly lz">import (<br/>    "fmt"<br/>    "github.com/juanmanuel-tirado/savetheworldwithgo/15_cli/cobra/advanced/example_05/cmd"<br/>    "github.com/spf13/cobra"<br/>    "os"<br/>    "math/rand"<br/>    "time"<br/>)</span><span id="d782" class="lu lv in lq b gy ng lx l ly lz">var RootCmd = &amp;cobra.Command{<br/>    Use: "db",<br/>    Long: "Root command",<br/>}</span><span id="dd34" class="lu lv in lq b gy ng lx l ly lz">var GetCmd = &amp;cobra.Command{<br/>    Use: "get",<br/>    Short: "Get user data",<br/>    Args: cobra.ExactValidArgs(1),<br/>    Run: func(cmd *cobra.Command, args []string) {<br/>        fmt.Printf("Get user %s!!!\n",args[0])<br/>    },<br/>    ValidArgsFunction: UserGet,<br/>}</span><span id="f3ee" class="lu lv in lq b gy ng lx l ly lz">func UserGet (cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {<br/>    rand.Seed(time.Now().UnixNano())<br/>    if rand.Int() % 2 == 0 {<br/>        return []string{"John", "Mary"}, cobra.ShellCompDirectiveNoFileComp<br/>    }<br/>    return []string{"Ernest", "Rick", "Mary"}, cobra.ShellCompDirectiveNoFileComp<br/>}</span><span id="e3f4" class="lu lv in lq b gy ng lx l ly lz">func init() {<br/>    RootCmd.AddCommand(GetCmd, cmd.CompletionCmd)<br/>}</span><span id="c602" class="lu lv in lq b gy ng lx l ly lz">func main() {<br/>    if err := RootCmd.Execute(); err != nil {<br/>        fmt.Fprintln(os.Stderr, err)<br/>        os.Exit(1)<br/>    }<br/>}</span></pre><p id="d144" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在生成并加载 shell 补全脚本之后，补全使用如下所示的<code class="fe nd ne nf lq b">UserGet</code>函数动态建议用户 id。</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="e987" class="lu lv in lq b gy lw lx l ly lz">&gt;&gt;&gt; ./db get [tab][tab]<br/>John  Mary<br/>&gt;&gt;&gt; ./db [tab][tab]<br/>completion  -- Generate completion script<br/>get         -- Get user data<br/>help        -- Help about any command<br/>&gt;&gt;&gt; ./db get [tab][tab]<br/>Ernest  Mary    Rick</span></pre><p id="6dca" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">注意</strong>:如果这个例子不适用于您的终端，您可能需要安装 bash 完成包(<code class="fe nd ne nf lq b">sudo apt install bash-completion</code>)。</p><p id="d4fe" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如您所见，使用 Cobra 生成 shell 完成脚本非常简单。我希望您考虑在您的下一个项目中添加 shell 完成功能。</p><p id="cc42" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">感谢阅读。</p></div><div class="ab cl ma mb hr mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ig ih ii ij ik"><div class="kd ke kf kg gt nh"><a href="https://jmtirado.net/build-systems-with-go/" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd io gy z fp nm fr fs nn fu fw im bi translated">使用 GO 构建系统</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">岁月流逝，围棋不再是积木上的新玩意儿，它已经成为一种成熟的语言围绕着…</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">jmtirado.net</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv km nh"/></div></div></a></div></div></div>    
</body>
</html>