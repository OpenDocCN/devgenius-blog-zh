<html>
<head>
<title>SwiftDependencyChecker — check CocoaPods, Carthage and Swift PM dependencies for known vulnerabilities</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftDependencyChecker —检查CocoaPods、Carthage和Swift PM依赖项是否存在已知漏洞</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/swiftdependencychecker-check-cocoapods-carthage-and-swift-pm-dependencies-for-known-def2fba890c?source=collection_archive---------8-----------------------#2022-01-10">https://blog.devgenius.io/swiftdependencychecker-check-cocoapods-carthage-and-swift-pm-dependencies-for-known-def2fba890c?source=collection_archive---------8-----------------------#2022-01-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/76e826a7afb89a39fa7ce4e431c1087e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fZ14Xj4AQRZn-6Y_aZf7iw.png"/></div></div></figure><div class=""/><h1 id="649e" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">您的应用程序是否使用了任何存在已知漏洞的库？</h1><p id="9f99" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们的应用程序中漏洞的一个来源是使用第三方库的易受攻击版本。有公开的漏洞数据库，但是很难搜索它们，并且重新检查漏洞是乏味的。</p><p id="b60a" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">大多数检查易受攻击的第三方依赖项的工具都是为其他包管理器和语言构建的。其中一些工具为CocaPods提供了(大部分是实验性的)支持，但我没有找到任何工具可以支持在Swift中编写应用程序时使用的所有三种包管理器。</p><p id="db67" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">因此，我决定编写一个工具来检测易受攻击的第三方库的使用，该工具将满足以下要求:</p><ul class=""><li id="67a7" class="lz ma jb ky b kz lu ld lv lh mb ll mc lp md lt me mf mg mh bi translated">支持CocoaPods、Carthage、Swift包管理器</li><li id="cd0f" class="lz ma jb ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">与Xcode集成</li><li id="a9ab" class="lz ma jb ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">开源并免费使用</li><li id="f685" class="lz ma jb ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">没有收集用户数据</li><li id="13c1" class="lz ma jb ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">最小设置</li></ul><h1 id="fa37" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">分析包管理器清单文件</h1><p id="7402" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">首先分析Podfile.lock、Cartfile.resolved和Package.resolved，以检测应用程序中使用了哪些第三方库。这些文件包括直接和间接依赖关系。收集库名、版本、模块名和其他一些关于所用依赖项的数据。</p><p id="7fa2" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">Carthage和Swift包管理器都是分散的包管理器，没有可以通过这些包管理器使用的库的中央列表。通常，给定依赖关系的存储库地址包含在依赖关系声明中。这些信息将用于接下来的分析步骤。</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mn"><img src="../Images/99e10a81d83003ecedf7c2c666a79dab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*clk2mIIkRi-hQvYbdsBTwQ.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">AFNetworking podspec文件摘录</figcaption></figure><p id="2683" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">另一方面，CocoaPods是一个集中式的包管理器，只需在包管理器清单文件中提供库的名称就足够了。因为为了进一步的分析，我们需要库的存储库地址，所以从Podfile.lock中检索的库的名称被“翻译”。为此，克隆了包含通过Cocoapods提供的所有库的信息的<a class="ae mw" href="https://github.com/CocoaPods/Specs" rel="noopener ugc nofollow" target="_blank">规范库</a>。SwiftDepenencyChecker为每个库找到正确的podspec文件，并提取所需的信息。</p><p id="c5e5" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果设置中没有另外指定，SwiftDependencyChecker每周更新一次CocoaPods规范存储库。</p><h1 id="3d83" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">公共漏洞数据库</h1><p id="5f36" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">下一步是找出哪些库公开披露了漏洞。为此，我使用了<a class="ae mw" href="https://nvd.nist.gov" rel="noopener ugc nofollow" target="_blank">国家漏洞数据库</a> (NVD)。NVD提供了一个API来搜索漏洞，但是如果只给出项目名称，有时很难找到这些信息。NVD使用公共平台枚举(CPE)作为对象的唯一标识符。给定一个项目的CPE，很容易找到匹配这个项目的所有漏洞。</p><p id="a301" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">CPE-s以下列格式给出:</p><blockquote class="mx my mz"><p id="537f" class="kw kx na ky b kz lu lb lc ld lv lf lg nb lw lj lk nc lx ln lo nd ly lr ls lt ij bi translated">CPE:2.3:a:<strong class="ky jc">af networking _ project</strong>:<strong class="ky jc">af networking</strong>:0 . 2 . 1:*:*:*:*</p></blockquote><p id="7d91" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">cpe的每一部分都包含特定类型的数据:CPE格式、公司名称、项目名称、版本、关于版本的附加信息(例如，是否是测试版)、平台等等。</p><p id="b617" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">当我们可以将库与cpe-s匹配时，我们就可以通过NVD API轻松地查询这些库的漏洞。</p><h1 id="d8fe" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">将项目与CPE-s匹配</h1><p id="d2bb" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">为了将项目与CPE-s匹配，我使用了<a class="ae mw" href="https://nvd.nist.gov/products/cpe" rel="noopener ugc nofollow" target="_blank">官方CPE词典</a>。这本词典每天更新多次，可以从NVD网站下载。SwiftDependencyChecker下载cpe字典，对于项目中检测到的每个库，它会尝试将库的名称与字典中的项目引用进行匹配。每周下载一次新版cpe字典，以跟上字典中的新项目。</p><p id="5f81" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">当我们运行<br/>grep-A3-I-e " daltoniam/红蜘蛛" official-CPE-dictionary _ v 2.3 . XML<br/>时，我们得到以下输出:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ne"><img src="../Images/8ae525eb6964b77b1b924241424dd050.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YnNMftjR6GgpDG-kdjo_wg.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">摘自official-CPE-dictionary _ v 2.3 . XML</figcaption></figure><p id="374c" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">参考标记与连接到相应cpe项目的库名相匹配。这意味着与“daltoniam/红蜘蛛”库匹配的cpe是<br/> cpe:2.3:a:红蜘蛛_project:红蜘蛛:*:*:*:*:* *</p><p id="7819" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在SwiftDependencyChecker中，这种搜索是通过遍历字典行并匹配库名来完成的。从Podfile.lock翻译库名对于使这个过程更加准确是必要的。</p><h1 id="aa85" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">查询NVD数据库</h1><p id="ed07" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在cpe匹配步骤之后，SwiftDependencyChecker将查询NVD API来查找每个CPE的漏洞。对https://services.nvd.nist.gov/rest/json/cves/1.0? NVD的查询执行如下:<br/>cpeMatchString = \(CPE)&amp;resultsPerPage = 2000</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nf"><img src="../Images/dcd1dc2c1083c80090b066c45fde06b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Av6cb9KwoEOREr4rhmjJ-g.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">NVD API回应摘录</figcaption></figure><p id="9014" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">只有具有易受攻击版本的项目才有cpe-s，这意味着查询的数量尽可能少。NVD允许在没有应用密钥的情况下每分钟10次查询，在有应用密钥的情况下每分钟100次请求。SwiftDependencyChecker还不支持提供应用程序键来加速这些查询，但将来会支持。</p><p id="3c07" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">API的输出是json格式的，包含关于漏洞、其影响、其引用和受影响版本的信息。</p><p id="481e" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">该数据被解析并保存。对于SwiftDependencyChecker中的分析，了解哪些版本的库受到漏洞的影响尤为重要。</p><p id="4a39" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">受影响版本的数据作为嵌套节点给出，并指定如何组合它们的操作符。SwiftDependencyChecker当前记录，但忽略操作符，并将每个被指定为易受攻击的版本视为易受攻击。</p><p id="35ae" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">对NVD的查询每天进行一次。这意味着，如果对给定cpe的最后一次查询是在不到24小时之前执行的，则使用保存的数据，而不是进行新的查询。可以在设置中更改该时间间隔。</p><h1 id="6e0b" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">将库的使用与易受攻击的版本相匹配</h1><p id="209c" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">从NVD SwiftDependencyChecker查询漏洞后，它会检查是否有任何使用的库版本与易受攻击的版本相匹配。</p><p id="f4c8" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这里的一个困难是，库的版本约定是否在某个时候发生了变化。例如，一个库可能在开始时使用3.4.5形式的版本，后来使用2020.11.10.2形式的版本。目前，如果版本中的组件数量不同，那么在本例中，将比较前3个组件。如果根本无法比较两个版本，则使用的版本被认为是易受攻击的。</p><h1 id="e60e" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">来源分析</h1><p id="c274" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">为了将易受攻击的库使用与项目SwiftDependencyChecker检查项目文件夹中的所有swift文件，并尝试将导入语句与易受攻击的库版本的使用进行匹配。如果import语句与易受攻击的依赖项的使用相匹配，则会打印一条警告。</p><p id="b6fd" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">此外，SwiftDependencyChecker检查Podfile.lock、Cartfile.lock和Package.resolved文件，并将库名称与易受攻击的库使用进行匹配。对于每一个匹配，都会打印一个警告。</p><h1 id="a2f7" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">表演</h1><p id="ad0e" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">当第一次运行SwiftDependencyChecker时，需要下载多个大文件，并且需要翻译所有的CocoaPods库名称。这需要时间。随后的运行将会显著加快，因为关于cpe-s和翻译的许多信息都保存在相应json文件的DependencyInfo目录中。</p><h1 id="edc2" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">安装和使用</h1><p id="d85f" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">SwiftDependencyChecker在github 上<a class="ae mw" href="https://github.com/kristiinara/SwiftDependencyChecker" rel="noopener ugc nofollow" target="_blank">可用，也可以用以下命令与homebrew一起安装:</a></p><blockquote class="mx my mz"><p id="7ff9" class="kw kx na ky b kz lu lb lc ld lv lf lg nb lw lj lk nc lx ln lo nd ly lr ls lt ij bi translated">brew tap kristiinara/SwiftDependencyChecker<br/>brew安装SwiftDependencyChecker</p></blockquote><p id="6ad3" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">安装后，SwiftDependencyChecker可以按如下方式运行:</p><blockquote class="mx my mz"><p id="1a2b" class="kw kx na ky b kz lu lb lc ld lv lf lg nb lw lj lk nc lx ln lo nd ly lr ls lt ij bi translated">SwiftDependencyChecker分析-所有操作</p></blockquote><p id="d96d" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这将打印出所使用的易受攻击的库版本的信息。</p><blockquote class="mx my mz"><p id="436b" class="kw kx na ky b kz lu lb lc ld lv lf lg nb lw lj lk nc lx ln lo nd ly lr ls lt ij bi translated">快速依赖性检查器分析-行动来源分析</p></blockquote><p id="45cd" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">打印出与在源文件中使用易受攻击的库版本相关的警告。</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/ec6bd0ebadce6640ba494b3578d6876c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BpdCs7uqhL5BvNT9OW2_fw.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">运行脚本构建阶段</figcaption></figure><p id="176c" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">建议将以下内容作为新的“运行脚本”添加到Xcode项目的“构建阶段”下。然后输出在Xcode中显示为警告。以这种方式使用SwiftDependencyChecker可以自动检查新的漏洞，而无需任何用户交互。</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ng"><img src="../Images/f0ad8c198e8ea0178e7c5782d88f3cf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_xSyiHcZZJhc0HOEhg_AYA.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">SwiftDependencyChecker生成的Xcode中的警告</figcaption></figure><h1 id="581f" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">反馈</h1><p id="9df7" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如果您决定试用该工具，我将非常感谢您的任何反馈。如果你确实在你的项目中发现了漏洞，我也非常希望听到这个工具是有用的。如果你有任何问题，我很乐意回答。</p><h1 id="ff59" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">未来的工作</h1><ul class=""><li id="7b89" class="lz ma jb ky b kz la ld le lh nh ll ni lp nj lt me mf mg mh bi translated">支持NDV应用程序键</li><li id="f7e1" class="lz ma jb ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">让警告更好</li><li id="344c" class="lz ma jb ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">构建通知用户在没有积极开发的旧项目中发现的漏洞的功能</li></ul></div></div>    
</body>
</html>