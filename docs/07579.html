<html>
<head>
<title>Building CRUD REST APIs using Spring Boot, PostgreSQL &amp; JPA Repository with basic validations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用带有基本验证的 Spring Boot、PostgreSQL 和 JPA 库构建 CRUD REST APIs</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/building-crud-rest-api-with-basic-validations-using-spring-boot-postgresql-jpa-repository-d8dc4478bf7b?source=collection_archive---------0-----------------------#2022-04-07">https://blog.devgenius.io/building-crud-rest-api-with-basic-validations-using-spring-boot-postgresql-jpa-repository-d8dc4478bf7b?source=collection_archive---------0-----------------------#2022-04-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ad9cb5f17240b9fb7028e0370e44c577.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xu-HBfCOQpG1XVuURHRDCA.png"/></div></div></figure><p id="25e0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本文中，我将创建一些 REST APIs，它们将使用 Spring Boot、PostgreSQL 数据库和 JPA 存储库执行 CRUD 操作。在这篇文章的结尾，你会知道:</p><ul class=""><li id="28ee" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">如何配置 Spring Data，JPA 以使用 PostgreSQL 数据库</li><li id="1901" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">如何定义数据模型和存储库接口</li><li id="916a" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">如何创建 Spring Rest 控制器来处理 HTTP 请求</li><li id="c55e" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">使用 Spring Data JPA 与 PostgreSQL 数据库交互的方法。</li><li id="264e" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">如何在插入数据时实现基本验证？</li></ul><h1 id="d9d0" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">初步的</h1><ul class=""><li id="f54e" class="kt ku in jx b jy mf kc mg kg mh kk mi ko mj ks ky kz la lb bi translated">在开始之前，如果你想了解 Spring Boot &amp;如何创建一个 Spring Boot 应用程序，请访问我以前的文章 。</li><li id="eccc" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">如果你想用 Spring Boot、JPA 库&amp; MySQL、<a class="ae mk" href="https://medium.com/@pritam73/building-crud-rest-api-with-basic-validations-using-spring-boot-mysql-jpa-repository-3df8c0e431a0" rel="noopener"> <strong class="jx io">执行 REST APIs CRUD 操作，请访问本文</strong> </a>。</li><li id="3f70" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">如果你想用 Spring Boot &amp; Couchbase 服务器(NoSQL 数据库服务器)，<a class="ae mk" href="https://medium.com/@pritam73/building-crud-rest-apis-using-spring-boot-couchbase-server-nosql-with-basic-validations-a0a14c049cad" rel="noopener"> <strong class="jx io">执行 REST APIs CRUD 操作，请访问本文</strong> </a>。</li></ul><h1 id="babc" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">使用的工具和技术</h1><ul class=""><li id="86c5" class="kt ku in jx b jy mf kc mg kg mh kk mi ko mj ks ky kz la lb bi translated">Java 1.8</li><li id="ed57" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">Spring Boot</li><li id="ca56" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">PostgreSQL 和 JPA:数据库和交互</li><li id="a322" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">Eclipse IDE:编写代码</li><li id="9d3b" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">Maven:提供构建环境</li><li id="48ce" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">邮递员:API 测试</li></ul><h1 id="49fe" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">项目结构</h1><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/6c824860b8637a7f871673bfb5f5574e.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*iODMYwMjnKT0Sgsjm1aFaA.png"/></div></figure><p id="6b72" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我简单解释一下上述项目结构的各个部分。</p><ul class=""><li id="10dd" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">BeanValidator 类用于处理 API 的基本验证。</li><li id="7de9" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated"><strong class="jx io">result to</strong>类用于处理每个 API 的响应格式。</li><li id="01a6" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated"><strong class="jx io"> UserController </strong>类是一个 Rest 控制器，它有 Restful 请求的请求映射方法，例如:<strong class="jx io"> createUser，allUsers，getUserById，updateUser，deleteUserById </strong>。</li><li id="35e5" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">用户类是包括用户特定数据的实体。</li><li id="0c96" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated"><strong class="jx io">userrepository</strong>是一个为所有 CRUD 方法扩展 JpaRepository 的接口。它将在 UserService 类中自动连接。</li><li id="01a2" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated"><strong class="jx io"> UserService </strong>类用于在对用户数据执行 CRUD 操作时管理业务逻辑。</li><li id="1c64" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">Spring boot postgresqlcrudrestapiapplication 类是由 Spring 创建的，它包含了运行我们的应用程序的 main 方法。</li><li id="b542" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated"><strong class="jx io"> application.properties </strong>文件包含 Spring 数据源、JPA、Hibernate、端口号、上下文路径等配置。</li><li id="9f10" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated"><strong class="jx io"> pom.xml </strong>包含 Spring Boot、PostgreSQL、JPA 等的依赖关系。</li></ul><h1 id="3d18" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">为 API 创建和设置项目</h1><p id="88a6" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mq ki kj kk mr km kn ko ms kq kr ks ig bi translated">创建 Spring Boot 项目后，打开<strong class="jx io"> pom.xml </strong>并添加这些依赖项:</p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated"><strong class="ak"> pom.xml </strong></figcaption></figure><h1 id="b5b9" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">配置端口、上下文路径和 Spring 数据源</h1><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated"><strong class="ak">应用程序.属性</strong></figcaption></figure><ul class=""><li id="2da9" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated"><code class="fe mz na nb nc b">server.port</code>属性用于改变默认端口号。</li><li id="a0e5" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated"><code class="fe mz na nb nc b">server.servlet.context-path </code> properties 用于为你的应用程序定义根路径。我已经将<strong class="jx io">/用户</strong>定义为我根路径。</li><li id="8c2e" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated"><code class="fe mz na nb nc b">spring.datasource.url </code>属性用于定义与数据库连接的数据库 url。</li><li id="5c65" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated"><code class="fe mz na nb nc b">spring.datasource.username</code> &amp; <code class="fe mz na nb nc b">spring.datasource.password</code>属性与你的数据库安装相同。</li><li id="1725" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">Spring Boot 使用 Hibernate 实现 JPA，我们为 PostgreSQL 配置了<code class="fe mz na nb nc b">PostgreSQLDialect</code>。</li><li id="e6d2" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated"><code class="fe mz na nb nc b">spring.jpa.hibernate.ddl-auto</code>用于数据库初始化。我们将该值设置为<code class="fe mz na nb nc b">update</code>值，以便在数据库中自动创建一个与定义的数据模型对应的表。对模型的任何更改也会触发表的更新。对于生产来说，这个属性应该是<code class="fe mz na nb nc b">validate</code>。</li><li id="b079" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated"><code class="fe mz na nb nc b">spring.jpa.show-sql =false</code>用于从控制台隐藏 sql 查询。</li></ul><h1 id="89e0" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">定义数据模型</h1><ul class=""><li id="9be1" class="kt ku in jx b jy mf kc mg kg mh kk mi ko mj ks ky kz la lb bi translated">我们的数据模型是<strong class="jx io">User.java</strong>，有五个字段:id、姓名、电子邮件、mobNo、密码。</li><li id="40e0" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">在<strong class="jx io"> com.crud.restapi.model </strong>包下，我们定义用户类。</li></ul><p id="b2d1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> model/User.java </strong></p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated"><strong class="ak">User.java</strong></figcaption></figure><ul class=""><li id="57fb" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated"><code class="fe mz na nb nc b">@Entity</code>注释表明该类是一个持久的 Java 类。</li><li id="f3ed" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated"><code class="fe mz na nb nc b">@Table</code>注释提供了映射该实体的表格。</li><li id="3700" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated"><code class="fe mz na nb nc b">@Id</code>注释是针对主键的。</li><li id="00ad" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated"><code class="fe mz na nb nc b">@GeneratedValue</code>注释用于定义主键的生成策略。</li><li id="1421" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated"><code class="fe mz na nb nc b">GenerationType.AUTO</code>表示自动增量字段。</li><li id="d939" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated"><code class="fe mz na nb nc b">@</code> NotEmpty 注释用于处理特定字段的空值。</li></ul><h1 id="8ef8" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">定义服务来处理业务逻辑</h1><ul class=""><li id="51fa" class="kt ku in jx b jy mf kc mg kg mh kk mi ko mj ks ky kz la lb bi translated">在<strong class="jx io">服务</strong>包中创建一个用户服务类。</li><li id="f188" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">我们的服务类是 UserService.java，它包含了所有使用存储库处理 CRUD 操作的方法，并将响应返回给 UserController.java</li></ul><p id="96ab" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">service/userservice . Java</strong></p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated"><strong class="ak">UserService.java</strong></figcaption></figure><ul class=""><li id="2f6b" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated"><code class="fe mz na nb nc b">@Service</code>注释用于将类标记为提供某些业务功能的服务提供者。</li><li id="c8d0" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated"><code class="fe mz na nb nc b">@Autowired</code>用于将<strong class="jx io"> UserRepository </strong> bean 注入局部变量。</li></ul><h1 id="deab" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">定义存储库接口</h1><p id="2d74" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mq ki kj kk mr km kn ko ms kq kr ks ig bi translated">创建一个存储库，以便与数据库中的用户进行交互。<br/>在<strong class="jx io">仓库</strong>包中，创建扩展<code class="fe mz na nb nc b">JpaRepository</code>的<code class="fe mz na nb nc b">UserRepository</code>接口</p><p id="d31c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">存储库/用户存储库</strong></p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated"><strong class="ak">UserRepository.java</strong></figcaption></figure><ul class=""><li id="da83" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">上面我们已经在我们的用户存储库中扩展了 JpaRepository，所以我们可以使用 JpaRepository 的方法:<code class="fe mz na nb nc b">save()</code>、<code class="fe mz na nb nc b">findOne()</code>、<code class="fe mz na nb nc b">findById()</code>、<code class="fe mz na nb nc b">findAll()</code>、<code class="fe mz na nb nc b">count()</code>、<code class="fe mz na nb nc b">delete()</code>、<code class="fe mz na nb nc b">deleteById() </code>等等，而不需要实现这些方法。</li><li id="2926" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">我们还可以在 UserRepository 中定义我们的自定义方法。我已经定义了<code class="fe mz na nb nc b">findByEmailAndMobNo</code>，它根据电子邮件&amp;手机号码返回用户的数据。</li></ul><h1 id="0c7e" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">定义响应包</h1><p id="1289" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mq ki kj kk mr km kn ko ms kq kr ks ig bi translated">在包含任何 api 响应包的<strong class="jx io"> bean </strong>包中创建一个<strong class="jx io">result to</strong>类。</p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated"><strong class="ak">ResultDTO.java</strong></figcaption></figure><ul class=""><li id="f74c" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated"><code class="fe mz na nb nc b">@JsonInclude(JsonInclude.Include.NON_NULL)</code>表示如果属性的值不为空，则该属性被序列化。</li><li id="456b" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated"><code class="fe mz na nb nc b">@JsonIgnoreProperties(ignoreUnknown =true)</code>表示 JSON 字符串中的任何未知属性，即我们没有相应字段的任何属性都将被忽略。</li></ul><h1 id="ed9f" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">定义验证器</h1><p id="223f" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mq ki kj kk mr km kn ko ms kq kr ks ig bi translated">在<strong class="jx io"> bean </strong>包中创建一个<strong class="jx io"> BeanValidator </strong>类，它包含一些 CRUD 操作的基本验证。</p><p id="303a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> bean/BeanValidator </strong></p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated"><strong class="ak">BeanValidator.java</strong></figcaption></figure><ul class=""><li id="0e7e" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated"><code class="fe mz na nb nc b">@Component</code>注释允许 Spring 自动检测我们的定制 beans。换句话说，无需编写任何显式代码。</li></ul><h1 id="8bd5" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">定义 REST API 控制器</h1><p id="5e2a" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mq ki kj kk mr km kn ko ms kq kr ks ig bi translated">在包含 CRUD 操作的所有 API 的控制器包中创建一个 UserController 类。</p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated"><strong class="ak">UserController.java</strong></figcaption></figure><ul class=""><li id="63c4" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated"><code class="fe mz na nb nc b">@RestController</code>注释用于定义控制器，并指示方法的返回值应绑定到 web 响应体。</li><li id="27e5" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated"><code class="fe mz na nb nc b">@RequestMapping("/api/v1")</code>声明控制器中的所有 APIs url 将以<code class="fe mz na nb nc b">/api/v1</code>开头。</li><li id="7785" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">我们已经自动连接了 UserService &amp; BeanValidator，将 bean 作为局部变量注入。</li><li id="3ab6" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">表示 Spring 应该将请求体反序列化为一个对象。该对象作为处理程序方法参数传递。如果你想得到表单类型的数据，你应该使用<code class="fe mz na nb nc b">@ModelAttribute</code>而不是<code class="fe mz na nb nc b">@RequestBody</code>。</li><li id="4d1c" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">为了响应每个 api，我使用了 ResultDTO 类的构造函数，它包含了响应包。</li></ul></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><h1 id="328c" class="lh li in bd lj lk nk lm ln lo nl lq lr ls nm lu lv lw nn ly lz ma no mc md me bi translated">运行应用程序</h1><ul class=""><li id="9d83" class="kt ku in jx b jy mf kc mg kg mh kk mi ko mj ks ky kz la lb bi translated">要通过 IDE 运行 Spring Boot 应用，<strong class="jx io">右键单击项目- &gt;运行- &gt; Spring Boot 应用</strong>，或者您可以通过 CLI 运行您的项目。要使用 CLI <strong class="jx io">运行，请打开您的终端- &gt;转到您的项目的根文件夹- &gt;键入“mvn spring-boot:run”。</strong></li><li id="309f" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">一旦应用程序成功运行，就会在模式中自动生成用户表，因为我们已经在 application.properties 文件中将值设置为<strong class="jx io"> update </strong>。</li><li id="c6d8" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">当您检查数据库时，它看起来像:</li></ul><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi np"><img src="../Images/582df8e1eab6aa40646dd0c82dcec889.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fVixBiNXtSTFKgBhH3KGYw.png"/></div></div></figure><h2 id="75bc" class="nq li in bd lj nr ns dn ln nt nu dp lr kg nv nw lv kk nx ny lz ko nz oa md ob bi translated">我们在本文中创建的 REST APIs:</h2><ul class=""><li id="06b3" class="kt ku in jx b jy mf kc mg kg mh kk mi ko mj ks ky kz la lb bi translated">/api/v1/createUser (POST):创建一个新用户。</li><li id="fdf1" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">/api/v1/allUsers (GET):从数据库中检索所有用户。</li><li id="c067" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">/api/v1/getUserById (GET):从数据库中检索用户。</li><li id="5e46" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">/api/v1/updateUser (PUT):更新用户的记录。</li><li id="9720" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">/api/v1/deleteUserById (DELETE):删除用户。</li></ul><h2 id="9de7" class="nq li in bd lj nr ns dn ln nt nu dp lr kg nv nw lv kk nx ny lz ko nz oa md ob bi translated">通过调用 createUser api 创建一些用户</h2><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oc"><img src="../Images/a195fb69fc0ec99f396626576ca9f9cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SwSNRyfMdj9BCaSY3uKZ2w.png"/></div></div></figure><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi od"><img src="../Images/304cc0a77e45c05c495bcb0b6610c931.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ENwZfEGGjJJFTBMZlqTSg.png"/></div></div></figure><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oe"><img src="../Images/d9935387d005f70a793133b7dd64d1bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q2zlmJr3tgt9wdWrEU6toA.png"/></div></div></figure><h2 id="b5b4" class="nq li in bd lj nr ns dn ln nt nu dp lr kg nv nw lv kk nx ny lz ko nz oa md ob bi translated">通过调用 allUsers api 获取所有用户</h2><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi of"><img src="../Images/d836bd4156a7ac8b9c527184c24dcdeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wA6jfRuKQG1tPnqJ5GNSew.png"/></div></div></figure><h2 id="862a" class="nq li in bd lj nr ns dn ln nt nu dp lr kg nv nw lv kk nx ny lz ko nz oa md ob bi translated">通过调用 getUserById api 获取用户记录</h2><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi og"><img src="../Images/a37ab7a74107a8f8cf93ed12c2007867.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qRKxuhdz_uUB5rc_1BxxeA.png"/></div></div></figure><h2 id="94cb" class="nq li in bd lj nr ns dn ln nt nu dp lr kg nv nw lv kk nx ny lz ko nz oa md ob bi translated">通过调用 updateUser api 更新用户</h2><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi of"><img src="../Images/362b2adca84415c344bea52f6b3e2df8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R_0PeohRpBT-ppLfvr4MmQ.png"/></div></div></figure><h2 id="2035" class="nq li in bd lj nr ns dn ln nt nu dp lr kg nv nw lv kk nx ny lz ko nz oa md ob bi translated">通过调用删除 api 删除用户</h2><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi od"><img src="../Images/4efb1ba9b3a2d8e4dd99478a1e6fe8c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vA7lLOK25agP5asA3Cvixw.png"/></div></div></figure><blockquote class="oh oi oj"><p id="36f3" class="jv jw ok jx b jy jz ka kb kc kd ke kf ol kh ki kj om kl km kn on kp kq kr ks ig bi translated"><a class="ae mk" href="https://github.com/pritam73/SpringBoot_PostgreSQL_CRUD_RESTAPI" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">点击此处下载源代码</strong> </a></p></blockquote><h1 id="2f7a" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">#结论</h1><p id="85d8" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mq ki kj kk mr km kn ko ms kq kr ks ig bi translated">在本文中，我使用 Spring Boot、Spring Data JPA、Maven 构建了 REST CRUD APIs 来与 PostgreSQL 交互。在下一篇文章中，我将解释任何 NoSQL 数据库的相同之处。</p><p id="cf81" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我希望这是有用的。一声‘拍手’一定会鼓励我多写文章，多分享我的知识。</p><p id="aa19" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以<a class="ae mk" href="https://www.linkedin.com/in/pritam-kumar-85b64316b" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">在 LinkedIn </strong> </a>上联系我，讨论更多。所以请随意连接。</p></div></div>    
</body>
</html>