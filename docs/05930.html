<html>
<head>
<title>Algorithm Strategy and Various Algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法策略和各种算法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/algorithm-strategy-and-various-algorithms-bdbb7eb811fe?source=collection_archive---------0-----------------------#2021-11-24">https://blog.devgenius.io/algorithm-strategy-and-various-algorithms-bdbb7eb811fe?source=collection_archive---------0-----------------------#2021-11-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/a7495cefce35a13beb98272d4dad293b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/0*FwBfhT28NctHcQMQ"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk translated">来源:<a class="ae jv" href="http://news.unair.ac.id/2020/01/24/penemuan-proses-paralel-menggunakan-algoritma-alpha-miner-baru/" rel="noopener ugc nofollow" target="_blank">http://news . unair . AC . id/2020/01/24/pene muan-proses-paralel-menggunakan-algorit ma-alpha-miner-baru/</a></figcaption></figure><p id="b952" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">在我们了解算法策略之前，我们需要知道上面每个单词的意思。</p><ul class=""><li id="26bb" class="ku kv in jy b jz ka kd ke kh kw kl kx kp ky kt kz la lb lc bi translated">战略:是为实现特定目标而对活动进行的周密计划。</li><li id="671f" class="ku kv in jy b jz ld kd le kh lf kl lg kp lh kt kz la lb lc bi translated">算法:是通过计算解决问题的正确步骤序列。</li></ul><p id="4c06" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">因此，算法策略是解决问题的方法或技术的集合，以实现指定的，在这种情况下，方法或技术的描述是在解决问题的正确计算步骤的序列中陈述的。</p></div><div class="ab cl li lj hr lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ig ih ii ij ik"><h1 id="ff4f" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">算法策略目标</h1><p id="ca41" class="pw-post-body-paragraph jw jx in jy b jz mn kb kc kd mo kf kg kh mp kj kk kl mq kn ko kp mr kr ks kt ig bi translated">有两个原因(Levitin，2003):</p><ol class=""><li id="a08a" class="ku kv in jy b jz ka kd ke kh kw kl kx kp ky kt ms la lb lc bi translated">为新问题设计算法提供指导。</li><li id="ddcb" class="ku kv in jy b jz ld kd le kh lf kl lg kp lh kt ms la lb lc bi translated">可以根据底层设计思想对算法进行分类。</li></ol></div><div class="ab cl li lj hr lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ig ih ii ij ik"><h1 id="ec16" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">通用策略算法</h1><p id="1254" class="pw-post-body-paragraph jw jx in jy b jz mn kb kc kd mo kf kg kh mp kj kk kl mq kn ko kp mr kr ks kt ig bi translated">有几种公认的算法策略。可以根据客观目标使用这种策略，包括分而治之、贪婪、动态规划和最小生成树/MST。</p><h2 id="82aa" class="mt lq in bd lr mu mv dn lv mw mx dp lz kh my mz md kl na nb mh kp nc nd ml ne bi translated">各个击破</h2><p id="2fc3" class="pw-post-body-paragraph jw jx in jy b jz mn kb kc kd mo kf kg kh mp kj kk kl mq kn ko kp mr kr ks kt ig bi translated">分治算法是计算机科学领域中非常流行的算法。分而治之是一种算法，其原理是将太大的问题分解成几个小部分，以便更容易解决。分治算法的一般步骤:</p><ul class=""><li id="cbad" class="ku kv in jy b jz ka kd ke kh kw kl kx kp ky kt kz la lb lc bi translated">划分:将问题划分为几个与原问题相似但规模更小(理想情况下规模差不多)的子问题。</li><li id="eb0d" class="ku kv in jy b jz ld kd le kh lf kl lg kp lh kt kz la lb lc bi translated">征服:解决(递归地)每个努力问题。</li><li id="e741" class="ku kv in jy b jz ld kd le kh lf kl lg kp lh kt kz la lb lc bi translated">组合:将每个子问题的解组合起来，从而形成原问题解。</li></ul><p id="4cd7" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">一般的分而治之方案:</p><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/95c36ee71841d4dfa50e862c9640d73c.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/0*nHb0GzX_0Ohx7ws4.png"/></div></figure><p id="e3da" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">算法应用:</p><p id="abfe" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">最小和最大发行</p><p id="1fb3" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">问题:例如，已知具有 n 个元素的表 A 已经包含整数值。我们要同时确定表中的最小值和最大值。假设表 A 包含以下元素:</p><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/db9d127928cc979f042a5e2ee1f4def9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/0*ZitZPo-h-IVeHjwn.png"/></div></figure><p id="71da" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">分治算法的基本思想是:</p><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/1a543f3af23ecac108a14db43e18283e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/0*EXRtaDS-Yik9NnXs.png"/></div></figure><p id="9117" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">除法表的大小可以做得很小，以便更容易地找到最小值和最大值。在这种情况下，选择的小尺寸是 1 个元素或 2 个元素。</p></div><div class="ab cl li lj hr lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ig ih ii ij ik"><h1 id="33fe" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">贪婪的</h1><p id="d4c8" class="pw-post-body-paragraph jw jx in jy b jz mn kb kc kd mo kf kg kh mp kj kk kl mq kn ko kp mr kr ks kt ig bi translated">贪婪算法是一种通过在每一步找到最大临时值来使用问题解决方法的算法。这个临时最大值被称为局部最大值。在大多数情况下，贪婪算法不会产生最优解，贪婪算法通常会在相当短的时间内提供接近最优值的解。</p><p id="ebcb" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">贪婪算法的一般模式</p><p id="617f" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">贪婪算法由元素组成，贪婪算法应用中使用的元素包括:</p><ol class=""><li id="e18f" class="ku kv in jy b jz ka kd ke kh kw kl kx kp ky kt ms la lb lc bi translated">候选集</li></ol><p id="1dfa" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">包含构成解的元素的集合</p><p id="ca42" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">2.解集</p><p id="df03" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">被选为问题解决方案的集合。</p><p id="3a3b" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">3.选择功能</p><p id="08f0" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">选择最有可能达到最优解的候选项的函数。</p><p id="28b5" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">4.可行性函数</p><p id="beb0" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">一种功能，检查所选的候选对象是否能提供可行的解决方案。关键是候选项以及已经形成的一组解是否不违反现有的约束。</p><p id="c2e6" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">5.求解函数</p><p id="f1a1" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">返回布尔值的函数。如果已形成的解集是完整解，则为 True 如果解集不完整，则为 False。</p><p id="0fd0" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">6.目标函数</p><p id="1b7f" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">在寻找解决方案(优化)时，贪婪算法仅使用 2 种优化问题，即:</p><ul class=""><li id="1e91" class="ku kv in jy b jz ka kd ke kh kw kl kx kp ky kt kz la lb lc bi translated">最大值化</li><li id="8c8c" class="ku kv in jy b jz ld kd le kh lf kl lg kp lh kt kz la lb lc bi translated">轻视</li></ul><h2 id="d9c9" class="mt lq in bd lr mu mv dn lv mw mx dp lz kh my mz md kl na nb mh kp nc nd ml ne bi translated">贪婪算法实现</h2><p id="fc7b" class="pw-post-body-paragraph jw jx in jy b jz mn kb kc kd mo kf kg kh mp kj kk kl mq kn ko kp mr kr ks kt ig bi translated">贪婪策略:在每一步，从剩余的硬币中选择价值最大的硬币</p><pre class="ng nh ni nj gt nl nm nn no aw np bi"><span id="741b" class="mt lq in nm b gy nq nr l ns nt">function CoinExchange (input C: Coin_set; A : integer) → Coin_set<br/>{<br/>determine the optimal solution of the optimization problem with a greedy algorithm<br/>Input: candidate set C<br/>Output: solution set S<br/>}<br/>Declaration<br/>S : Coin_set<br/>x : Coin<br/>Algorithm:<br/>S {}<br/>while (∑(value of all coins in S) A) and (C {} ) do<br/>x The coin that has the greatest value<br/>C C — {x}<br/>if (∑ (value of all coins in S) + value of coins x A then<br/>S S {x}<br/>endif<br/>end while<br/>if (∑ (value of all coins in S) = A then<br/>return S<br/>else<br/>write("no solution")<br/>endif</span></pre></div><div class="ab cl li lj hr lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ig ih ii ij ik"><h1 id="a978" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">动态规划算法</h1><p id="a2f1" class="pw-post-body-paragraph jw jx in jy b jz mn kb kc kd mo kf kg kh mp kj kk kl mq kn ko kp mr kr ks kt ig bi translated">动态规划(以下简称“DP”)是一种算法设计技术，通过将问题分解为许多子问题来解决非常复杂的问题。DP 和分而治之(以下简称“D&amp;C”)的主要区别在于，在 DP 中我们复用了之前已经做过的子问题的计算结果。使用动态编程算法的一个例子是斐波那契数列。求解斐波那契数列的算法如下。</p><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/51c7d985a69d5e68b1c82853266fda3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/0*QH4OCR6JL3gA3VmA.png"/></div></figure></div><div class="ab cl li lj hr lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ig ih ii ij ik"><h1 id="4671" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">最小生成树</h1><p id="38f3" class="pw-post-body-paragraph jw jx in jy b jz mn kb kc kd mo kf kg kh mp kj kk kl mq kn ko kp mr kr ks kt ig bi translated">最小生成树(Minimum spanning tree)是一种寻找可以同时连接网络中所有点直到获得最小距离的连接路径的技术，当然每个节点一定不能以循环的方式连接。求最小范围有两种算法，即 Prim 的算法和 Kruskal 的算法。</p><h2 id="4f40" class="mt lq in bd lr mu mv dn lv mw mx dp lz kh my mz md kl na nb mh kp nc nd ml ne bi translated">Prim 算法</h2><p id="41ce" class="pw-post-body-paragraph jw jx in jy b jz mn kb kc kd mo kf kg kh mp kj kk kl mq kn ko kp mr kr ks kt ig bi translated">Prim 算法是图论中的一种算法，用于为互连的加权图找到最小生成树。这意味着边的子集形成包含节点的树，其中树中所有边的总权重被最小化。如果图是不连通的，那么对于其中一个连通的部分，它只有一个最小生成树。这种算法是由数学家沃伊奇·贾尼克在 1930 年发明的。</p><p id="6841" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">一般来说，Prim 的算法如下:</p><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/50c829da717dd35cb966896de8be3b10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/0*zttG_Ucyw2RuVNJo.png"/></div></figure><p id="aa18" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">示例:</p><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/c3efdb7ae20eb270576de16ee78f4028.png" data-original-src="https://miro.medium.com/v2/resize:fit:570/format:webp/0*KjDbCg-YRYEKDwph.png"/></div></figure><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/ac7f45752d177d91cdac8166653f5f63.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/0*sTFxd7kK2nI2zwPT.png"/></div></figure><h2 id="fc17" class="mt lq in bd lr mu mv dn lv mw mx dp lz kh my mz md kl na nb mh kp nc nd ml ne bi translated">克鲁斯卡尔算法</h2><p id="9780" class="pw-post-body-paragraph jw jx in jy b jz mn kb kc kd mo kf kg kh mp kj kk kl mq kn ko kp mr kr ks kt ig bi translated">Kruskal 算法是图论中的一种算法，在加权图中寻找最小生成树进行连接。这意味着找到构成包含每个顶点的树的边的子集，其中树中所有边的总权重最小。</p><p id="38a4" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">一般来说，Prim 的算法如下:</p><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/26ab40ed2ede9b4a574071356ee015f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/0*4mirTUDwcjIzfV4n.png"/></div></figure><p id="739b" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">示例:</p><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/f38b3b0b06198130da0a1d919c849319.png" data-original-src="https://miro.medium.com/v2/resize:fit:326/format:webp/0*xmI4c9wJ2-CVXQ_x.png"/></div></figure><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/82910fa8bd6e95181683a60ec00e98f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/0*N5IlUtO5xJhi6Mr1.png"/></div></figure></div><div class="ab cl li lj hr lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ig ih ii ij ik"><p id="1bb2" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">本文已在印尼文<a class="ae jv" href="https://agungprabowo8800.medium.com/strategi-algoritma-dan-macam-macam-algoritma-a26b55309e0b" rel="noopener">这里</a>发表</p><p id="3728" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">谢谢你。</p></div></div>    
</body>
</html>