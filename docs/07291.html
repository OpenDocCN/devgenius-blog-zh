<html>
<head>
<title>Understanding Gradle and Build Automation Tools</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解 Gradle 和构建自动化工具</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/understanding-gradle-and-build-automation-tools-4d2fa7d09d20?source=collection_archive---------6-----------------------#2022-03-12">https://blog.devgenius.io/understanding-gradle-and-build-automation-tools-4d2fa7d09d20?source=collection_archive---------6-----------------------#2022-03-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="01de" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我开始使用 Gradle 时，我只是讨厌它，因为我发现它不必要的复杂。不喜欢它的一个很好的理由是不知道构建自动化工具的概念。</p><p id="b1a4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦我理解了构建工具的用例，以及它是如何让开发人员轻松构建和部署项目的！就是这样！，对格雷尔的尊重越来越多，我决定读更多关于它的书。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ac762d286f5ca7538eb707c24e9dcda7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*57I7tLFIZvtH-E3C.png"/></div></div></figure><h1 id="d26b" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">什么是构建工具，它如何使开发人员的生活变得简单？</h1><p id="cf41" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">我们大多数开始使用或可能使用过 java 之类的语言的人都知道，要运行任何 java 文件，我们需要做的第一件事就是编译 java 文件并生成 Java 类，最后使用<code class="fe lx ly lz ma b">javac</code>命令运行它。</p><p id="10a9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">只对一两个文件这样做似乎没问题，也没有太大的负担，但是如果您想到有几十个甚至几百个文件，并且您必须通过手动完成所有编译任务来创建项目和 jar，那该怎么办呢？</p><p id="8868" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另外，如果你还需要在你的项目中使用第三方库，这又增加了一层复杂性。</p><p id="784e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这些构建工具为你做的是通过在幕后做艰苦的工作，编译、打包、发布、运行等来自动化所有这些过程。</p><p id="fe0a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">构建自动化工具为项目提供结构，编译并制作包/罐子，这样开发人员就可以专注于功能而不是构建过程。</p><p id="dd17" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，它还提供了许多有用的命令来<strong class="jm io">构建</strong>、<strong class="jm io">测试</strong>、<strong class="jm io">包以及更多的</strong>，如果没有构建自动化工具，很难想象当今任何规模的项目开发。</p><p id="f7cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">图中列出了几个构建自动化工具—</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/a6f8362bc7882f2fa7d7ea61a91a2ed3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*Z4b5Fj4LoqP6f_p-.png"/></div></figure><h2 id="a874" class="mc kv in bd kw md me dn la mf mg dp le jv mh mi li jz mj mk lm kd ml mm lq mn bi translated">格拉德是什么？</h2><p id="227a" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">我是从 gradle 开始的，对<strong class="jm io"> Maven </strong>或<strong class="jm io"> Ant </strong>了解不多，所以我主要是从其他人那里听说这些工具，不同的人根据他们的经验和工作时间喜欢不同的工具，有些人说 Maven 是一个很棒且容易使用的工具，有些人说 Gradle 就像 Maven 一样，有一些额外的功能等等。</p><p id="974b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所有这些都是真实的，适用于不同的场景，我们现在就来谈谈 gradle</p><blockquote class="mo mp mq"><p id="86bb" class="jk jl mr jm b jn jo jp jq jr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg kh ig bi translated">定义</p><p id="2cf7" class="jk jl mr jm b jn jo jp jq jr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg kh ig bi translated">Gradle 是一个开源的构建自动化工具，专注于灵活性和性能。Gradle 构建脚本是使用一个<a class="ae mv" href="https://groovy-lang.org/" rel="noopener ugc nofollow" target="_blank"> Groovy </a>或<a class="ae mv" href="https://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank"> Kotlin </a> DSL 编写的。阅读<a class="ae mv" href="https://gradle.org/features/" rel="noopener ugc nofollow" target="_blank"> Gradle 特性</a>了解 Gradle 的潜力。—文档</p></blockquote><p id="321b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Gradle 只是另一个具有大量功能和灵活性的构建自动化工具，不仅适用于 java，也适用于许多其他语言，如 Scala、C++、Groovy、Kotlin。</p><p id="e981" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它有很棒的特性，如<strong class="jm io">高性能、Jvm 基础、可扩展性、惯例、IDE 支持和扫描</strong>，我们也将看到 gradle 如何承诺这些功能。</p></div><div class="ab cl mw mx hr my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ig ih ii ij ik"><h2 id="3557" class="mc kv in bd kw md me dn la mf mg dp le jv mh mi li jz mj mk lm kd ml mm lq mn bi translated">格拉德内部是如何工作的？</h2><p id="b7f8" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">Gradle 是一个通用的构建工具，允许你构建几乎任何软件，因为它的内部工作假设你的项目的结构和它应该如何构建。</p><p id="627d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一般来说，像这样的工具被认为是某种结构中的项目，gradle 也不例外。</p><p id="0c18" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">渐变任务</strong></p><p id="e95d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mr">任务本身包括:</em></p><ul class=""><li id="c6ed" class="nd ne in jm b jn jo jr js jv nf jz ng kd nh kh ni nj nk nl bi translated"><strong class="jm io">动作:</strong>做一些事情的工作，比如复制文件或编译源代码</li><li id="26db" class="nd ne in jm b jn nm jr nn jv no jz np kd nq kh ni nj nk nl bi translated"><strong class="jm io">输入:</strong>动作使用或操作的值、文件和目录</li><li id="153d" class="nd ne in jm b jn nm jr nn jv no jz np kd nq kh ni nj nk nl bi translated"><strong class="jm io">输出:</strong>操作修改或生成的文件和目录</li></ul><p id="da58" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Gradle build 只不过是一组任务，每个任务都是由一组指令定义的。Gradle 将其构建建模为任务(工作单元)的<strong class="jm io"> <em class="mr">有向无环图(Dag)</em></strong>。Build 根据依赖关系将多组任务组合在一起以使其工作，gradle 有很好的依赖关系管理技术，它可以根据依赖关系结构知道哪个任务需要运行。</p><p id="d08a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此图显示了两个示例任务图，一个是抽象的，另一个是具体的，任务之间的依赖关系用箭头表示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/1b6eadd70426124ab48cc3d0e6c39e46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7QefSVN5kncis8Hg.png"/></div></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated"><em class="nw">来源-分级文档</em></figcaption></figure><p id="3378" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在任务图中模拟任何构建过程的能力使得 gradle 同时具有很大的灵活性和可扩展性。</p><p id="669b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使它更加灵活的是使用它们的构建脚本和构建 DSL 来创建您自己的定制任务。</p><h2 id="e196" class="mc kv in bd kw md me dn la mf mg dp le jv mh mi li jz mj mk lm kd ml mm lq mn bi translated">探索 build.gradle</h2><pre class="kj kk kl km gt nx ma ny nz aw oa bi"><span id="8a6a" class="mc kv in ma b gy ob oc l od oe">plugins {<br/>    id("org.jetbrains.kotlin.jvm") version "1.5.31"<br/><br/>    application<br/>}<br/><br/>repositories {<br/>    mavenCentral() <br/>}<br/><br/>dependencies {<br/>    implementation(platform("org.jetbrains.kotlin:kotlin-bom")) <br/><br/>    implementation("org.jetbrains.kotlin:kotlin-stdlib-jdk8") <br/><br/>    implementation("com.google.guava:guava:30.1.1-jre") <br/><br/>    testImplementation("org.jetbrains.kotlin:kotlin-test") <br/><br/>    testImplementation("org.jetbrains.kotlin:kotlin-test-junit") <br/>}<br/><br/>application {<br/>    mainClass.set("demo.AppKt") <br/>}</span></pre><ol class=""><li id="fb28" class="nd ne in jm b jn jo jr js jv nf jz ng kd nh kh of nj nk nl bi translated"><strong class="jm io">插件</strong></li></ol><p id="f2a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Gradle 的核心是有意为现实世界的自动化提供很少的东西。所有有用的特性，比如编译 Java 代码的能力，都是由<em class="mr">插件</em>添加的。插件增加新任务(如<a class="ae mv" href="https://docs.gradle.org/current/dsl/org.gradle.api.tasks.compile.JavaCompile.html" rel="noopener ugc nofollow" target="_blank"> JavaCompile </a>)、领域对象(如<a class="ae mv" href="https://docs.gradle.org/current/dsl/org.gradle.api.tasks.SourceSet.html" rel="noopener ugc nofollow" target="_blank"> SourceSet </a>)、约定(如 Java 源代码位于<code class="fe lx ly lz ma b">src/main/java</code>)以及扩展核心对象和其他插件的对象。</p><p id="1688" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将插件应用到项目允许插件扩展项目的功能</p><p id="1ca4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种情况下，是为了支持科特林。</p><p id="4272" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">插件中的<strong class="jm io"> <em class="mr">应用</em> </strong>只是为了让 gradle 知道这是一个应用，gradle 应该能够使用 CLI 命令构建它。</p><p id="1c3e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 2。储存库</strong></p><p id="fc2f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Gradle 可以从一个或多个基于 Maven、Ivy 或平面目录格式的存储库中解析依赖关系。</p><p id="773a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">构建软件的组织可能希望利用公共二进制存储库来下载和使用开源依赖项，或者可能还希望使用私有存储库。</p><p id="36db" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种情况下，它是 mavenCentral。</p><p id="8c6f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 3。依赖性</strong></p><p id="9cc7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，您可以定义项目中要使用的依赖项，gradle 中的每个依赖项都有一个范围，这意味着您希望在哪个位置使用它，可能是在执行期间，也可能是在测试阶段，这些都是使用实现和测试实现技术定义的。</p><p id="7430" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">许多 Gradle 插件将预定义的配置添加到您的项目中。例如，Java 插件添加了配置来表示源代码编译、执行测试等所需的各种类路径。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/dd2b97f74fd975208dae3553267eaa29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5HoGo4ioE5FCTsvV.png"/></div></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">资料来源:Gradle docs</figcaption></figure><p id="c30e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">4.<strong class="jm io">应用</strong></p><p id="3442" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在当前的例子中，它被用来定义项目的主类，gradle 可以选择它并从中启动项目，在这种情况下，它是 demo.AppKt。</p><p id="dfed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，gradle 还免费提供了一些命令，比如，clean，run，test，build 等等，所有这些命令都可以根据需要和需求进行修改。</p><p id="cdca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里要注意的是，构建文件的定义语言就像任何其他编程语言一样，这意味着你可以做几乎任何你可以在编程语言中做的事情，并且你应该非常小心地使用这个特性，确保不要在构建文件中添加任何复杂或不必要的东西，这会使它变慢。</p><h1 id="219e" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">通过 CLI 创建 gradle 项目</h1><p id="0db6" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">作为先决条件，你需要安装最新的 gradle 发行版，你可以在这里找到这个——<a class="ae mv" href="https://gradle.org/install/" rel="noopener ugc nofollow" target="_blank">https://gradle.org/install/</a></p><p id="c499" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">安装完毕后，请按照以下步骤操作</p><ol class=""><li id="705c" class="nd ne in jm b jn jo jr js jv nf jz ng kd nh kh of nj nk nl bi translated">创建项目目录并转到该目录</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/e65ab6e3ec447ed735a5c6da5dd6e006.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kiPtp7OUyX0L6inqMWO0Rw.png"/></div></div></figure><p id="24b7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.使用<code class="fe lx ly lz ma b">gradle init</code>命令初始化项目</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/75d0c3e1de16aa370533e6a629e7fa79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vVH2yju89tmwmaPgD1OJ-A.png"/></div></div></figure><p id="3950" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让 gradle 知道您想要创建哪种类型的项目，指定您选择的语言，并构建脚本 DSL，后跟项目和包名，在本例中我使用了默认的名称。</p><p id="1cec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.探索项目</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/2e79b6eee82a93bb503020802264be1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SlquuOoa_movi7sgB6ERQQ.png"/></div></div></figure><p id="26b6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">项目结构</strong><br/>├──build . grad le . kts<br/>├──grad le<br/>│└──wrapper<br/>│├──grad le-wrapper . jar<br/>│└──grad le-wrapper . properties<br/>├──grad le<br/>├──grad le . bat<br/>├──settings . grad le . kts<br/>└──src<br/>├──main<br/>│├──主<br/></p><p id="b533" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 13 个目录，8 个文件</strong></p><p id="aca7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，我们已经准备好了我们的示例项目，我们可以使用 gradle 命令来运行它，一旦项目启动并运行，现在就轮到您来探索更多关于定制和其他 suffs 的基础工作了。</p></div><div class="ab cl mw mx hr my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ig ih ii ij ik"><p id="b66e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">总的来说，我觉得在进行 gradle 项目之前必须有基本的理解，因为大多数时候，人们可能只是从不同的地方复制粘贴命令和脚本，而不知道实际的工作，这可能会使调试变得困难，也可能会减慢您的构建。</p><p id="1185" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">其中一个例子是每次都使用<strong class="jm io"> <em class="mr">清理构建</em> </strong>而不知道它的实际用途以及 gradle 如何使用缓存来使您的后续构建更快使用缓存，如果每次都使用清理构建功能都没有用，总体上至少知道您在执行什么。</p></div></div>    
</body>
</html>