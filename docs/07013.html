<html>
<head>
<title>Setup a Jenkins server to build a Spring Boot application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设置 Jenkins 服务器以构建 Spring Boot 应用程序</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/setup-a-jenkins-server-to-build-a-spring-boot-application-81b8d4c78083?source=collection_archive---------5-----------------------#2022-02-19">https://blog.devgenius.io/setup-a-jenkins-server-to-build-a-spring-boot-application-81b8d4c78083?source=collection_archive---------5-----------------------#2022-02-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ba7b86e8e9ce0a8b9f5d42b2c6a6a4c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9r2wqaWCJbX3NDJbr3aw9g.jpeg"/></div></div></figure><p id="f191" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本教程中，我们将介绍使用 Docker 和 Docker Compose 设置 Jenkins 服务器的步骤，以便能够从 GitHub 资源库构建 Spring Boot 应用程序。</p><h1 id="9c34" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">詹金斯配置代码</h1><p id="bee2" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">我们将从查看作为代码的詹金斯配置(JCasC)部分开始，因此我们将克隆存储库<a class="ae lw" href="https://github.com/mjovanc/medium-jenkins-casc" rel="noopener ugc nofollow" target="_blank">https://github.com/mjovanc/medium-jenkins-casc</a>，并且我们将分别检查每个文件，它们的作用以及我们为什么需要它们。本教程中有很多东西需要解开，所以偶尔喝一杯提神的饮料吧。</p><p id="43b5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那么为什么我们需要一个叫做詹金斯配置的东西作为代码呢？想象一下，您需要手动安装一个 Jenkins 服务器，并在 Jenkins 的 web UI 中输入配置。如果服务器出了问题，我们需要用 Jenkins 复制一个新的服务器，该怎么办？然后，我们需要在 web UI 中再次手动添加它们，并手动安装插件。如果你有一个更大的项目，这将花费很长时间，并且可能导致你正在构建的产品的交付出现很多问题。</p><p id="9b97" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">事实上，我试图找到关于 JCasC 的信息，但是在寻找好的教程时遇到了<strong class="jx io">问题，这些教程很全面，涵盖了做这件事所需的每一个步骤。所以我的目标是现在用一种<strong class="jx io">的基本方式</strong>向你们展示你们需要什么。我会尽我所能。如果有一些错误，请添加评论，我会尽快回答并纠正错误。</strong></p><p id="6b0d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，在存储库中，我们将首先打开文件<strong class="jx io"> config/jenkins.yml </strong>:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="db9b" class="mg ku in mc b gy mh mi l mj mk">jenkins:<br/>  systemMessage: "Welcome to Jenkins for the Spring Project!"<br/>  numExecutors: 4<br/>  mode: NORMAL<br/>  scmCheckoutRetryCount: 3<br/>  labelString: "mjovanc"  # we need to specify something here that we will define in our pipeline jobs, choose whatever name you want<br/><br/>  primaryView:<br/>    all:<br/>      name: All<br/><br/>tool:<br/>  jdk:<br/>    installations:<br/>    - name: "OpenJDK 16"<br/>      properties:<br/>      - installSource:<br/>          installers:<br/>          - zip:<br/>              subdir: "/var/jenkins_home/tools/hudson.model.JDK/OpenJDK_16/jdk-16.0.1"<br/>              url: "https://download.java.net/java/GA/jdk16.0.1/7147401fd7354114ac51ef3e1328291f/9/GPL/openjdk-16.0.1_linux-x64_bin.tar.gz"<br/><br/>jobs:<br/>  - script: |<br/>      job('seedjob-mjovanc') {<br/>        description('Set up all jobs')<br/>          <br/>        scm {<br/>          git {<br/>            branches('*/master')<br/>            remote {<br/>              credentials('mjovanc-jenkins-key')<br/>              url('git@github.com:mjovanc/medium-mjovanc-job-dsl.git')<br/>            }<br/>          }<br/>        }<br/>        steps {<br/>          dsl {<br/>            external('*.groovy')<br/>            removeAction('DELETE')<br/>            ignoreExisting(ignore = false)<br/>            removeViewAction('DELETE')<br/>          }<br/>        }<br/>        triggers {<br/>          cron('@midnight')<br/>        }<br/>      }</span></pre><p id="76de" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里有两个主要部分值得指出。我们有<strong class="jx io">詹金斯</strong>、<strong class="jx io">工具</strong>和<strong class="jx io">工作</strong>。</p><p id="af85" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">詹金斯是服务器的一般配置，如我们需要多少执行者等等。</p><p id="d94b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">工具</strong>是关于我们需要安装什么样的额外软件来构建我们的软件。我添加了 OpenJDK16，因为 Jenkins 使用的 OpenJDK11 无法工作。</p><p id="9a5b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">作业</strong>部分定义了启动 Jenkins 时最初应该存在的作业类型。所以我们在这里添加了一个 Groovy 脚本来设置一个作业，该作业将在午夜从一个外部存储库中获取更多的 Groovy DSL 作业，您可以从这里克隆这个库:<a class="ae lw" href="https://github.com/mjovanc/medium-mjovanc-job-dsl" rel="noopener ugc nofollow" target="_blank">https://github.com/mjovanc/medium-mjovanc-job-dsl</a>。因此，如果您要对外部存储库中的 DSL 作业进行任何更改，它将在午夜发生变化。</p><p id="c990" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们看看我们的<strong class="jx io">文档:</strong></p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="6f0a" class="mg ku in mc b gy mh mi l mj mk">FROM jenkins/jenkins:lts-jdk11<br/>USER root<br/><br/>COPY plugins.txt /usr/share/jenkins/ref/plugins.txt<br/>RUN /usr/local/bin/install-plugins.sh &lt;&lt; /usr/share/jenkins/ref/plugins.txt<br/><br/>RUN apt-get update -y<br/>RUN apt-get install -y apt-transport-https ca-certificates curl gnupg2 software-properties-common docker.io<br/>RUN docker --version<br/><br/>RUN usermod -aG docker jenkins<br/><br/>USER jenkins</span></pre><p id="6b24" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们定义了自己的<strong class="jx io"> Dockerfile </strong>，因为我们需要在 Docker 容器中安装 Docker，这样才能在 Jenkins 上构建 Docker 映像。</p><p id="c65b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的<strong class="jx io"> docker-compose.yml </strong>文件:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="85fb" class="mg ku in mc b gy mh mi l mj mk">version: '3.7'<br/><br/>services:<br/>  jenkins:<br/>    build: .<br/>    privileged: true<br/>    user: root<br/>    restart: on-failure:10<br/>    ports:<br/>      - 8080:8080<br/>    container_name: mjovanc-jenkins<br/>    volumes:<br/>      - ./:/jcasc<br/>      - ~/apps/jenkins:/var/jenkins_home<br/>      - /var/run/docker.sock:/var/run/docker.sock<br/>    environment:<br/>      - CASC_JENKINS_CONFIG=/jcasc/configs/jenkins.yml<br/>      - JENKINS_OPTS='--prefix=/'<br/>    logging:<br/>      driver: 'json-file'<br/>      options:<br/>        max-file: '3'<br/>        max-size: '10m'</span></pre><p id="1cb8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个文件定义了我们将从我们自己的<strong class="jx io"> Dockerfile </strong>构建，并将服务名设置为<strong class="jx io"> jenkins </strong>。我们还从我们的主机操作系统中映射了一些所需的卷，例如所有的 JCasC 配置和 Docker UNIX 套接字，以便能够在 Docker 容器中使用它们。</p><p id="917d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们还设置了两个环境变量。<strong class="jx io">CASC _ 詹金斯 _ 配置</strong>，它指向我们定义的<strong class="jx io">詹金斯. yml </strong>文件，因此詹金斯将知道它应该在启动时加载该文件。我们还设置了一个前缀，Jenkins 应该在 URL 上使用<strong class="jx io"> JENKINS_OPTS </strong>。所以网址会直接在<strong class="jx io"> / </strong>上。</p><p id="1681" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在 Jenkins 的 Web UI 中首次设置 Jenkins 服务器后，我们需要运行一些代码。我们转到脚本控制台并输入:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="4561" class="mg ku in mc b gy mh mi l mj mk"><strong class="mc io">def </strong>pluginList = <strong class="mc io">new </strong>ArrayList(Jenkins.instance.pluginManager.plugins)<br/>pluginList.sort <strong class="mc io">{ </strong>it.getShortName() <strong class="mc io">}</strong>.each<strong class="mc io">{<br/>  </strong>plugin <strong class="mc io">-&gt; <br/>    </strong>println ("$<strong class="mc io">{</strong>plugin.getDisplayName()<strong class="mc io">}</strong> ($<strong class="mc io">{</strong>plugin.getShortName()<strong class="mc io">}</strong>): $<strong class="mc io">{</strong>plugin.getVersion()<strong class="mc io">}</strong>")<br/><strong class="mc io">}</strong></span></pre><p id="a583" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将为我们提供一个已安装插件的长列表，因此我们可以在一个<strong class="jx io"> plugins.txt </strong>文件中定义它，这样下次我们需要设置一个新的 Jenkins 服务器时，我们只需在运行<strong class="jx io"> docker-compose up </strong>时从该文件加载即可。</p><p id="1a6f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来你需要做的就是把这个文件的名字<strong class="jx io">your-domain.com</strong>改成你自己的名字。为了设置<strong class="jx io"> NGINX </strong>配置，需要有这个文件，因为我们的 NGINX 将充当 Jenkins 服务器的<strong class="jx io">反向代理</strong>。文件看起来是这样的:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="2e69" class="mg ku in mc b gy mh mi l mj mk">upstream jenkins {<br/>  keepalive 32; # keepalive connections<br/>  server 127.0.0.1:8080; # jenkins ip and port<br/>}<br/><br/># Required for Jenkins websocket agents<br/>map $http_upgrade $connection_upgrade {<br/>  default upgrade;<br/>  '' close;<br/>}<br/><br/>server {<br/>    listen 80;<br/>    listen [::]:80;<br/>    return 301 https://$host$request_uri;<br/>}<br/><br/>server {<br/>    server_name your-domain.com; # managed by Certbot<br/><br/>   # this is the jenkins web root directory<br/>    # (mentioned in the /etc/default/jenkins file)<br/>    root            /root/apps/jenkins/war/;<br/><br/>    access_log      /var/log/nginx/jenkins.access.log;<br/>    error_log       /var/log/nginx/jenkins.error.log;<br/><br/>    # pass through headers from Jenkins that Nginx considers invalid<br/>    ignore_invalid_headers off;<br/><br/>    location ~ "^/static/[0-9a-fA-F]{8}\/(.*)$" {<br/>        # rewrite all static files into requests to the root<br/>        # E.g /static/12345678/css/something.css will become /css/something.css<br/>        rewrite "^/static/[0-9a-fA-F]{8}\/(.*)" /$1 last;<br/>    }<br/><br/>    location /userContent {<br/>        # have nginx handle all the static requests to userContent folder<br/>        # note : This is the $JENKINS_HOME dir<br/>        root /root/apps/jenkins/;<br/>        if (!-f $request_filename){<br/>            # this file does not exist, might be a directory or a /**view** url<br/>            rewrite (.*) /$1 last;<br/>            break;<br/>        }<br/>        sendfile on;<br/>    }<br/><br/>   location / {<br/>        sendfile off;<br/>        proxy_pass         http://jenkins;<br/>        proxy_redirect     default;<br/>        proxy_http_version 1.1;<br/><br/>        # Required for Jenkins websocket agents<br/>        proxy_set_header   Connection        $connection_upgrade;<br/>        proxy_set_header   Upgrade           $http_upgrade;<br/><br/>        proxy_set_header   Host              $host;<br/>        proxy_set_header   X-Real-IP         $remote_addr;<br/>        proxy_set_header   X-Forwarded-For   $proxy_add_x_forwarded_for;<br/>        proxy_set_header   X-Forwarded-Proto $scheme;<br/>        proxy_max_temp_file_size 0;<br/><br/>        #this is the maximum upload size<br/>        client_max_body_size       10m;<br/>        client_body_buffer_size    128k;<br/><br/>        proxy_connect_timeout      90;<br/>        proxy_send_timeout         90;<br/>        proxy_read_timeout         90;<br/>        proxy_buffering            off;<br/>        proxy_request_buffering    off; # Required for HTTP CLI commands<br/>        proxy_set_header Connection ""; # Clear for keepalive<br/>    }<br/><br/><br/>    listen [::]:443 ssl ipv6only=on; # managed by Certbot<br/>    listen 443 ssl; # managed by Certbot<br/>    ssl_certificate /etc/letsencrypt/live/your-domain.com/fullchain.pem; # managed by Certbot<br/>    ssl_certificate_key /etc/letsencrypt/live/your-domain.com/privkey.pem; # managed by Certbot<br/>    include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot<br/>    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot<br/>}</span></pre><p id="610c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您需要在该文件中更改到您自己的域，我将演示的下一个文件将在安装 NGINX 服务器后使用该文件复制到它的位置。这是脚本<strong class="jx io"> setup_start.sh </strong>:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="4ba2" class="mg ku in mc b gy mh mi l mj mk">#!/bin/bash<br/># <br/># Use this file to setup the environment for Jenkins<br/># and run the server<br/><br/># Variables<br/>JENKINS_DOMAIN=&lt;your domain&gt; # this domain should be the name of your nginx configuration file as well<br/>NGINX_SSL_EMAIL=&lt;your email&gt;<br/><br/># Installing necessary dependencies<br/>sudo apt-get update -y<br/>sudo apt-get install -y \<br/>    ca-certificates \<br/>    curl \<br/>    gnupg \<br/>    lsb-release \<br/>    nginx \<br/>    certbot<br/><br/>apt-get install -y python3-certbot-nginx<br/><br/># Setup NGINX<br/>sudo mkdir -p /var/log/nginx/jenkins<br/>sudo cp $JENKINS_DOMAIN /etc/nginx/sites-available/$JENKINS_DOMAIN<br/>sudo ln -s /etc/nginx/sites-available/$JENKINS_DOMAIN /etc/nginx/sites-enabled/<br/><br/># SSL<br/>sudo certbot --nginx -d $JENKINS_DOMAIN --non-interactive --agree-tos -m $NGINX_SSL_EMAIL<br/><br/># Reload<br/>nginx -t &amp;&amp; nginx -s reload<br/><br/># Add Docker’s official GPG key:<br/>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg<br/><br/># Setup the stable repository<br/>echo \<br/>  "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \<br/>  $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null<br/><br/># Install Docker Engine<br/>sudo apt-get update -y<br/>sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-compose<br/><br/># Start Docker and orchestrate<br/>docker-compose up -d</span></pre><p id="00a7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个脚本将安装 NGINX、Certbot、Docker 和 Docker Compose 所有必需的依赖项，然后运行 Jenkins。你需要在顶部编辑这个文件，把<strong class="jx io"> JENKINS_DOMAIN </strong>和<strong class="jx io"> NGINX_SSL_EMAIL </strong>的值改成你自己的域和邮箱地址。</p><p id="cea9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我想当然地认为您已经设置了一个 Linux 实例(VM ),并用 DNS A 记录指向了您自己的域。</p><p id="e35a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你想看到一些输出，你可以在<strong class="jx io"> docker-compose up </strong>之后移除<strong class="jx io"> -d </strong>标志。这在开始时是很好的，因为我们可以按照编排的过程来发现我们是否犯了任何错误。但是，当您完成后，您可以再次添加它。</p><p id="95b6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们准备启动应用程序，首先使用以下命令设置文件 setup_start.sh 的可执行权限，然后启动应用程序:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="a944" class="mg ku in mc b gy mh mi l mj mk">chmod +x ./setup_start.sh</span></pre><p id="802f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如我们在运行 shell 脚本时经常做的那样，我们只需使用以下命令运行它:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="d47e" class="mg ku in mc b gy mh mi l mj mk">./setup_start.sh</span></pre><p id="9a92" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">太好了！现在它已经开始运行了！</p><p id="0375" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们只需要对 Jenkins 做最后的修改，让它与配置部分一起工作。我们首先需要生成一个将要使用的 SSH 密钥。使用下面的命令生成一个:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="c711" class="mg ku in mc b gy mh mi l mj mk">ssh-keygen -t rsa</span></pre><p id="0b2b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">按照 CLI 给出的说明，选择一个合适的名字，也许是 jenkins-github？然后我们只需要将这个密钥添加到我们计算机上的 ssh 代理中:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="0c82" class="mg ku in mc b gy mh mi l mj mk">eval "$(ssh-agent -s)"<br/>ssh-add &lt;path to your ssh key&gt;</span></pre><p id="f6a9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们将转到我们的 GitHub 帐户，添加我们的<strong class="jx io"> public </strong>(。pub)宋承宪键在这里【https://github.com/settings/keys<a class="ae lw" href="https://github.com/settings/keys" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="6d39" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，对于 JCasC 部分，我们需要在 Jenkins Web UI 中执行一个手动步骤来添加作业加载到 Jenkins 所需的 SSH 凭证。如果存储库是公共的，您可以跳过这一步，删除 DSL 作业中的 credential()方法。<strong class="jx io">重要的</strong>要注意的是，我们需要给配置文件中所说的内容添加相应的凭证名称，看看这个作业在<strong class="jx io"> jenkins.yml </strong>里面是什么样子的。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ml"><img src="../Images/6c23e6e0dfe7dab5951688a92f5046d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k8O99K0bH7IPBxrT-FI1qQ.png"/></div></div></figure><p id="e8f6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">看看这篇关于如何在 Jenkins 上添加凭证的教程:<a class="ae lw" href="https://www.jenkins.io/doc/book/using/using-credentials/" rel="noopener ugc nofollow" target="_blank">https://www.jenkins.io/doc/book/using/using-credentials/</a></p><p id="f553" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">也许现在喝点饮料是个好主意。</p><h1 id="130a" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">詹金斯 DSL 作业</h1><p id="9955" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">有很多文件要看。振作起来，还会有更多。我们现在来看看 DSL 作业是什么样子的。</p><p id="f639" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将从查看 Spring API DSL 作业开始:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="1f2b" class="mg ku in mc b gy mh mi l mj mk">//---------------------------------------------------------------------------------<br/>// spring_api_job.groovy<br/>//---------------------------------------------------------------------------------<br/>// A pipeline job for the Spring Boot API application<br/>//---------------------------------------------------------------------------------<br/><br/>pipelineJob('Spring-API') <strong class="mc io">{<br/>    </strong>description('Build Spring Boot API')<br/><br/>    triggers <strong class="mc io">{<br/>        </strong>githubPush()<br/>    <strong class="mc io">}<br/><br/>    </strong>definition <strong class="mc io">{<br/>        </strong>cpsScm <strong class="mc io">{<br/>            </strong>scm <strong class="mc io">{<br/>                </strong>git <strong class="mc io">{<br/>                    </strong>remote <strong class="mc io">{<br/>                        </strong>url('git@github.com:mjovanc/medium-spring-api.git')<br/>                        credentials('mjovanc-jenkins-key')<br/>                    <strong class="mc io">}<br/><br/>                    </strong>branches('master')<br/>                    scriptPath('jenkins/main.jenkinsfile')<br/>                    extensions <strong class="mc io">{<br/>                        </strong>cleanBeforeCheckout()<br/>                    <strong class="mc io">}<br/>                }<br/>            }<br/>        }<br/>    }<br/>}</strong></span></pre><p id="8ee7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们定义类型<strong class="jx io"> pipelineJob </strong>及其名称和描述。我们还设置了一个触发器方法，名为<strong class="jx io"> githubPush() </strong>，每当我们得到一个新的提交时，它就会向 Jenkins 发送更新。所以我们需要设置一个<strong class="jx io"> webhook </strong>，但是我们会在浏览完文件之后再做。然后我们有一个定义部分，我们描述了什么存储库和什么凭据将用于验证我们自己。我们还指定我们将检出哪个分支，以及我们将在这个管道中使用哪个<strong class="jx io"> Jenkinsfile </strong>。</p><p id="dead" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">作为一项额外的 DSL 工作，我们将添加一个构建监视器视图:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="395d" class="mg ku in mc b gy mh mi l mj mk">//---------------------------------------------------------------------------------<br/>// spring_build_monitor.groovy<br/>//---------------------------------------------------------------------------------<br/>// Defines build monitor views for Spring API<br/>//---------------------------------------------------------------------------------<br/><br/>buildMonitorView('Spring-API') <strong class="mc io">{<br/>    </strong>description('Spring API master')<br/><br/>    recurse()<br/><br/>    jobs <strong class="mc io">{<br/>        </strong>name('master')<br/>    <strong class="mc io">}<br/><br/>    </strong>configure <strong class="mc io">{ </strong>project <strong class="mc io">-&gt; <br/>        </strong>(project / config / displayCommitters ).value = <strong class="mc io">true<br/>        </strong>(project / config / buildFailureAnalyzerDisplayedField).value = Name<br/>    <strong class="mc io">}<br/>}</strong></span></pre><p id="5d75" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以在这个 DSL 资源库中为不同的项目添加更多带有不同 Groovy 脚本的管道，Jenkins 会把它们捡起来添加进去。</p><p id="9364" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">需要注意的一点是，当 Jenkins 进行这些夜间检查时，如果我们更改了脚本或添加了新的脚本，我们需要手动进入 Jenkins 并<strong class="jx io">批准</strong>它们。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mm"><img src="../Images/19f5cf9f2ea23d7fe62303970f566e62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kDMTa-vGRy9IQEZlkBtPaQ.jpeg"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">等待脚本批准时的外观示例</figcaption></figure><p id="a3ad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们将在<strong class="jx io"> GitHub </strong>中设置<strong class="jx io"> webhook </strong>,我们转到存储库设置，转到 webhooks 并点击添加。现在，我们将添加有效载荷的网址，这确保詹金斯得到推送，并登记它发生了一些事情。添加以下内容:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="9913" class="mg ku in mc b gy mh mi l mj mk">https://your-jenkins-domain.com/github-webhook/</span></pre><p id="db59" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">选择选项，<strong class="jx io">让我选择单个事件</strong>，选择<strong class="jx io">按下</strong>并保存。</p><h1 id="5a19" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">与詹金斯和多克一起设计 Spring Boot</h1><p id="7ee1" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">现在我们要设置 Spring Boot 与詹金斯和 Docker。</p><p id="1601" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将使用我之前为另一个教程构建的博客应用:<a class="ae lw" href="https://medium.com/@mjovanc/spring-boot-with-postgresql-and-hibernate-part-2-5406f3c93665" rel="noopener">https://medium . com/@ mjovanc/spring-boot-with-PostgreSQL-and-hibernate-part-2-5406 f3c 93665</a>。但是我添加了一个新的存储库来将它们分开:<a class="ae lw" href="https://github.com/mjovanc/medium-spring-jenkins-docker" rel="noopener ugc nofollow" target="_blank">https://github.com/mjovanc/medium-spring-jenkins-docker</a>。</p><p id="6064" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们首先需要在存储库的根目录下创建一个名为<strong class="jx io"> jenkins </strong>的目录，然后在其中创建一个新文件<strong class="jx io"> main.jenkinsfile </strong>并放置以下代码:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="61b8" class="mg ku in mc b gy mh mi l mj mk">def SPRING_VERSION = "X.X.X"<br/><br/>pipeline {<br/>    agent {<br/>        node {<br/>            label 'spring'<br/>        }<br/>    }<br/><br/>    tools {<br/>        jdk 'OpenJDK 16'<br/>    }<br/><br/>    stages {<br/>        stage('Clean') {<br/>            steps {<br/>                echo 'Cleaning leftovers from previous builds'<br/>                sh "chmod +x -R ${env.WORKSPACE}"<br/>                sh './gradlew clean'<br/>            }<br/>        }<br/><br/>        stage('Compile') {<br/>            steps {<br/>                echo 'COMPILING JAVA'<br/>                sh './gradlew assemble'<br/>            }<br/>        }<br/><br/>        stage('Static Code Analysis') {<br/>            steps {<br/>                echo 'Running Static Code Analysis'<br/><br/>                echo 'Checking style'<br/>                sh './gradlew checkstyleMain'<br/><br/>                echo 'Checking duplicated code'<br/>                sh './gradlew cpdCheck'<br/><br/>                echo 'Checking bugs'<br/>                sh './gradlew spotbugsMain'<br/><br/>                echo 'Checking code standard'<br/>                sh './gradlew pmdMain'<br/>            }<br/>        }<br/><br/>        stage('Unit Test') {<br/>            steps {<br/>                echo 'Running all unit tests'<br/>                sh './gradlew test -Dspring.profiles.active=test'<br/>            }<br/>        }<br/><br/>        /* stage('Coverage Test') {<br/>            steps {<br/>                echo 'Coverage Test'<br/>            }<br/>        } */<br/><br/>        stage('Build Docker Image') {<br/>            steps {<br/>                script {<br/>                    echo 'Building Docker Image'<br/><br/>                    // Getting project version<br/>                    SPRING_VERSION = sh(<br/>                            script: './gradlew -q printVersion',<br/>                            returnStdout: true).trim()<br/><br/>                    echo "CURRENT VERSION: ${SPRING_VERSION}"<br/>                    sh "docker build -t spring-api:${SPRING_VERSION} ."<br/>                }<br/>            }<br/>        }<br/><br/>        stage('Publish Docker Image') {<br/>            steps {<br/>                script {<br/>                    echo 'Publish Docker Image to Docker Hub'<br/><br/>                    withCredentials([usernamePassword(credentialsId: 'DOCKER_HUB', usernameVariable: 'DOCKER_HUB_USER', passwordVariable: 'DOCKER_HUB_TOKEN')]) {<br/>                        sh """<br/>                            docker login -u $DOCKER_HUB_USER -p $DOCKER_HUB_TOKEN<br/>                            docker image tag spring-api:${SPRING_VERSION} spring/spring-api:${SPRING_VERSION}<br/>                            docker image tag spring-api:${SPRING_VERSION} spring/spring-api:latest<br/>                            docker push spring/spring-api:${SPRING_VERSION}<br/>                            docker push spring/spring-api:latest<br/>                        """<br/>                    }<br/>                }<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="d24b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该文件定义了应用程序在 Jenkins 中应该经历的所有管道阶段。我们还使用之前在 JCasC 的<strong class="jx io"> jenkins.yml </strong>文件中定义的相应标签来定义代理，以及我们将在此管道中使用的工具<strong class="jx io"> OpenJDK 16 </strong>。</p><p id="b301" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果有某个阶段目前不工作，也许是静态代码分析阶段，把它注释掉，你可以在以后修复它。</p><p id="bc0d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<strong class="jx io"> Docker </strong>阶段，我们将发布它要求凭据，您需要像以前一样将以下内容添加到您的 Jenkins 凭据页面，但使用这些变量:<strong class="jx io"> DOCKER_HUB </strong>、<strong class="jx io"> DOCKER_HUB_USER </strong>和<strong class="jx io"> DOCKER_HUB_TOKEN </strong>。</p><p id="8a48" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们还需要更改 build.gradle 文件，以使管道工作:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="08a0" class="mg ku in mc b gy mh mi l mj mk">buildscript <strong class="mc io">{<br/>   </strong>repositories <strong class="mc io">{<br/>      </strong>mavenCentral()<br/>   <strong class="mc io">}<br/>   </strong>dependencies <strong class="mc io">{<br/>      </strong>classpath("org.springframework.boot:spring-boot-gradle-plugin:2.5.2.RELEASE")<br/>   <strong class="mc io">}<br/>}<br/><br/></strong>plugins <strong class="mc io">{<br/>   </strong>id 'org.springframework.boot' version '2.5.2'<br/>   id 'io.spring.dependency-management' version '1.0.11.RELEASE'<br/>   id 'java'<br/>   id 'war'<br/>   id "com.dorongold.task-tree" version "2.1.0"<br/>   id 'checkstyle'<br/>   id 'pmd'<br/>   id 'de.aaschmid.cpd' version '3.3'<br/>   id "com.github.spotbugs" version "5.0.4"<br/><strong class="mc io">}<br/><br/></strong>group = 'com.mjovanc'<br/>version = '0.0.1'<br/>sourceCompatibility = '16'<br/><br/>repositories <strong class="mc io">{<br/>   </strong>mavenCentral()<br/><strong class="mc io">}<br/><br/></strong>dependencies <strong class="mc io">{<br/>   </strong>implementation 'org.springframework.boot:spring-boot-starter-data-jpa'<br/>   implementation 'org.springframework.boot:spring-boot-starter-web'<br/>   implementation 'org.springframework.session:spring-session-core'<br/>   implementation group: 'org.springframework.data', name: 'spring-data-commons', version: '2.5.2'<br/>   implementation group: 'org.springdoc', name: 'springdoc-openapi-ui', version: '1.5.9'<br/>   implementation group: 'com.h2database', name: 'h2', version: '1.4.200'<br/><br/>   runtimeOnly 'org.postgresql:postgresql'<br/>   providedRuntime 'org.springframework.boot:spring-boot-starter-tomcat'<br/>   testImplementation 'org.springframework.boot:spring-boot-starter-test'<br/><strong class="mc io">}<br/><br/></strong>test <strong class="mc io">{<br/>   </strong>useJUnitPlatform()<br/><strong class="mc io">}</strong></span><span id="b22e" class="mg ku in mc b gy mr mi l mj mk">war <strong class="mc io">{<br/>   </strong>enabled = <strong class="mc io">true<br/>   </strong>archiveClassifier = ''<br/><strong class="mc io">}</strong></span><span id="d3a2" class="mg ku in mc b gy mr mi l mj mk">//---------------------------------------------------------------------------------<br/>// STATIC CODE ANALYSIS CONFIGURATION<br/>//---------------------------------------------------------------------------------<br/><br/>checkstyle <strong class="mc io">{<br/>   </strong>toolVersion = '8.12'<br/>   ignoreFailures = <strong class="mc io">false<br/>   </strong>configFile = file("$<strong class="mc io">{</strong>projectDir<strong class="mc io">}</strong>/gradle/static-code-analysis/checkstyle/checkstyle.xml")<br/><strong class="mc io">}<br/><br/></strong>pmd <strong class="mc io">{<br/>   </strong>toolVersion = '6.7.0'<br/>   ignoreFailures = <strong class="mc io">false<br/>   </strong>ruleSetFiles = files("$<strong class="mc io">{</strong>projectDir<strong class="mc io">}</strong>/gradle/static-code-analysis/pmd/ruleset.xml")<br/>   ruleSets = []<br/>   rulesMinimumPriority = 3<br/><strong class="mc io">}<br/><br/></strong>cpd <strong class="mc io">{<br/>   </strong>language = 'java'<br/>   toolVersion = '6.1.0'<br/>   minimumTokenCount = 200 // approximately 5-10 lines<br/><strong class="mc io">}<br/><br/></strong>cpdCheck <strong class="mc io">{<br/>   </strong>reports <strong class="mc io">{<br/>      </strong>text.enabled = <strong class="mc io">true<br/>      </strong>xml.enabled = <strong class="mc io">false<br/>   }<br/>   </strong>ignoreAnnotations = <strong class="mc io">true<br/>   </strong>source = sourceSets.main.allJava // only java, groovy and scala classes in 'main' sourceSets<br/><strong class="mc io">}<br/><br/></strong>spotbugsMain <strong class="mc io">{<br/>   </strong>reports <strong class="mc io">{<br/>      </strong>html <strong class="mc io">{<br/>         </strong>required = <strong class="mc io">true<br/>         </strong>outputLocation = file("$projectDir/build/reports/spotbugs/main/spotbugs.html")<br/>         stylesheet = 'fancy-hist.xsl'<br/>      <strong class="mc io">}<br/>   }<br/>   </strong>excludeFilter = file("$<strong class="mc io">{</strong>projectDir<strong class="mc io">}</strong>/gradle/static-code-analysis/spotbugs/spotbugs-exclude.xml")<br/><strong class="mc io">}<br/><br/><br/></strong>//---------------------------------------------------------------------------------<br/>// TASKS<br/>//---------------------------------------------------------------------------------<br/><br/>tasks.withType(Checkstyle) <strong class="mc io">{<br/>   </strong>reports <strong class="mc io">{<br/>      </strong>xml.enabled <strong class="mc io">false<br/>      </strong>html.enabled <strong class="mc io">true<br/>   }<br/>}<br/><br/></strong>tasks.withType(Pmd) <strong class="mc io">{<br/>   </strong>reports <strong class="mc io">{<br/>      </strong>xml.enabled <strong class="mc io">false<br/>      </strong>html.enabled <strong class="mc io">true<br/>   }<br/>}<br/><br/></strong>task printVersion <strong class="mc io">{<br/>   </strong>doLast <strong class="mc io">{<br/>      </strong>println project.version<br/>   <strong class="mc io">}<br/>}</strong></span></pre><p id="363d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个文件有很多我不会在本教程中涉及的东西，但是有一些东西是需要说的。我们已经定义了一个名为<strong class="jx io"> printVersion </strong>的任务，我们在<strong class="jx io"> Jenkinsfile </strong>中使用它来获取当前版本。我们还有一个<strong class="jx io">战</strong>挡:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="d1d4" class="mg ku in mc b gy mh mi l mj mk">war <strong class="mc io">{<br/>   </strong>enabled = <strong class="mc io">true<br/>   </strong>archiveClassifier = ''<br/><strong class="mc io">}</strong></span></pre><p id="00bb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这确保了我们不会得到两个<strong class="jx io">。war </strong>文件，并且只有一个，所以我们的<strong class="jx io"> Dockerfile </strong>可以只选择第一个，因为如果我们改变版本，那么硬编码这个版本是不好的:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="17e0" class="mg ku in mc b gy mh mi l mj mk"># Using Tomcat 9.0 since the latest doesn't work with Spring Boot<br/>FROM tomcat:9.0-jdk16-openjdk<br/>ARG WAR_FILE=build/libs/spring-*.war<br/>RUN rm -rf /usr/local/tomcat/webapps/*<br/>COPY ${WAR_FILE} /usr/local/tomcat/webapps/ROOT.war<br/>EXPOSE 8080<br/>CMD ["catalina.sh", "run"]</span></pre><p id="fd09" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">差不多就是这样。我可能忘记提到一些事情，所以如果你不明白或者遇到任何问题，请提问。每当我看到需要澄清的地方，我都会更新。</p></div></div>    
</body>
</html>