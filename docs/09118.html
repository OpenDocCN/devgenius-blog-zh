<html>
<head>
<title>Advanced Node.js Topics: Caching.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级 Node.js 主题:缓存。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/advanced-node-js-topics-caching-e3d17dc1d738?source=collection_archive---------0-----------------------#2022-07-31">https://blog.devgenius.io/advanced-node-js-topics-caching-e3d17dc1d738?source=collection_archive---------0-----------------------#2022-07-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="8b0d" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">通过使用 Redis 缓存经常提取的数据来提高服务器性能。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/2cc0329e6a995c88e268937b98485983.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kweAChrF5o0hO83KK2fQHQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">雷迪斯</figcaption></figure><h1 id="edf1" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">简介:</h1><p id="25ff" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">Redis 是一个内存数据库，以 key: value 格式存储数据，因为它在内存中，所以速度快得离谱。</p><p id="cff2" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated"><strong class="lm io"> Redis 提供数据结构，如字符串、散列、列表、集合、有序集合</strong></p><blockquote class="ml mm mn"><p id="16b8" class="lk ll mo lm b ln mg jo lp lq mh jr ls mp mi lv lw mq mj lz ma mr mk md me mf ig bi translated">Redis 是一个开源的(BSD 许可的)，内存中的<strong class="lm io">数据结构存储</strong>，用作数据库、缓存、消息代理和流引擎。Redis 提供了数据结构，如<a class="ae ms" href="https://redis.io/topics/data-types-intro#strings" rel="noopener ugc nofollow" target="_blank">字符串</a>、<a class="ae ms" href="https://redis.io/topics/data-types-intro#hashes" rel="noopener ugc nofollow" target="_blank">哈希</a>、<a class="ae ms" href="https://redis.io/topics/data-types-intro#lists" rel="noopener ugc nofollow" target="_blank">列表</a>、<a class="ae ms" href="https://redis.io/topics/data-types-intro#sets" rel="noopener ugc nofollow" target="_blank">集合</a>、<a class="ae ms" href="https://redis.io/topics/data-types-intro#sorted-sets" rel="noopener ugc nofollow" target="_blank">排序集合</a>、位图、<a class="ae ms" href="https://redis.io/topics/data-types-intro#hyperloglogs" rel="noopener ugc nofollow" target="_blank">超级日志</a>、<a class="ae ms" href="https://redis.io/commands/geoadd" rel="noopener ugc nofollow" target="_blank">地理空间索引</a>和<a class="ae ms" href="https://redis.io/topics/streams-intro" rel="noopener ugc nofollow" target="_blank">流</a>。Redis 内置了<a class="ae ms" href="https://redis.io/topics/replication" rel="noopener ugc nofollow" target="_blank">复制</a>、<a class="ae ms" href="https://redis.io/commands/eval" rel="noopener ugc nofollow" target="_blank"> Lua 脚本</a>、<a class="ae ms" href="https://redis.io/topics/lru-cache" rel="noopener ugc nofollow" target="_blank"> LRU 驱逐</a>、<a class="ae ms" href="https://redis.io/topics/transactions" rel="noopener ugc nofollow" target="_blank">事务</a>和不同级别的<a class="ae ms" href="https://redis.io/topics/persistence" rel="noopener ugc nofollow" target="_blank">磁盘持久化</a>，通过<a class="ae ms" href="https://redis.io/topics/sentinel" rel="noopener ugc nofollow" target="_blank"> Redis Sentinel </a>和<a class="ae ms" href="https://redis.io/topics/cluster-tutorial" rel="noopener ugc nofollow" target="_blank"> Redis 集群</a>自动分区提供高可用性。<a class="ae ms" href="https://redis.io/docs/about/" rel="noopener ugc nofollow" target="_blank"> redi.io </a></p></blockquote></div><div class="ab cl mt mu hr mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ig ih ii ij ik"><h1 id="9b6d" class="ks kt in bd ku kv na kx ky kz nb lb lc jt nc ju le jw nd jx lg jz ne ka li lj bi translated">案例使用:</h1><p id="fe5b" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">为什么应该在服务器中实现缓存层，以及它将如何提高应用程序的性能。</p><ul class=""><li id="628b" class="nf ng in lm b ln mg lq mh lt nh lx ni mb nj mf nk nl nm nn bi translated">定期获取数据<br/>缓存获取过于频繁的数据是一个很好的实践，你不会让用户等太久才获得基本数据</li><li id="5c74" class="nf ng in lm b ln no lq np lt nq lx nr mb ns mf nk nl nm nn bi translated">减少针对数据库的查询执行<br/>通过使用缓存，您将减少针对数据库执行的查询数量，除了性能提升之外，您还可以避免数据库被返回相同结果的重复查询淹没。<br/>此外，如果你在一个昂贵的托管服务提供商那里托管你的应用，你会节省宝贵的带宽</li><li id="1ece" class="nf ng in lm b ln no lq np lt nq lx nr mb ns mf nk nl nm nn bi translated">提高应用性能<br/>缓存不仅可以提高数据库性能并保护数据库，还可以提高服务器-客户端的整体性能。<br/>为了理解这个概念，让我们假设你的服务器有一个名为 getArticle 的路由，到达这个路由的每个请求将花费大约半秒钟(~500 毫秒)来获得响应，通过缓存，第一个请求将花费大约半秒钟或更长时间，但是每个下一个请求将花费大约(~20 毫秒)！神奇吧？！<br/>我会用自己的应用证明这一点</li></ul></div><div class="ab cl mt mu hr mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ig ih ii ij ik"><h1 id="853a" class="ks kt in bd ku kv na kx ky kz nb lb lc jt nc ju le jw nd jx lg jz ne ka li lj bi translated">缓存与无缓存:</h1><p id="14fa" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">我在我的服务器上做了一个简单的基准测试(在单个 API 上，看看在没有缓存的情况下如何完成请求，并在有缓存的情况下重新测试同一个 API，看看改进情况。)</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nt"><img src="../Images/a693897ec9b68caf8a5d24742df4bf8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T7l-zLYC6UDvyNfPiq1xyA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">不缓存</figcaption></figure><p id="0dc6" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">上面的图片向你展示了，我的服务器花了一秒多的时间来完成请求，当然，每次我发出一个请求都要花差不多的时间！</p><p id="4ee9" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">下图是我在服务器的 API 中引入缓存机制的时候，你可以自己看到时间上的差异(我没有在请求中做任何改变)</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nu"><img src="../Images/c8edea7a21cd18fe56024e4cfa7d94aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DUpNj-3g9-bWIm2sTb9esw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">引入缓存</figcaption></figure><p id="ea5e" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">在接下来的时间里，完成同样的请求所需的时间已经减少到大约 10 毫升，这是一个显著的进步！</p><p id="fab0" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">我希望现在您对在自己的项目中实现这种技术感到兴奋。</p></div><div class="ab cl mt mu hr mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ig ih ii ij ik"><h1 id="422f" class="ks kt in bd ku kv na kx ky kz nb lb lc jt nc ju le jw nd jx lg jz ne ka li lj bi translated">安装:</h1><h2 id="f3f5" class="nv kt in bd ku nw nx dn ky ny nz dp lc lt oa ob le lx oc od lg mb oe of li og bi translated">在您的机器上安装<strong class="ak"> <em class="oh"> Redis </em> </strong></h2><p id="92c2" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">在 Linux 中，您可以通过在终端中键入来安装它</p><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="9c26" class="nv kt in oj b gy on oo l op oq">sudo apt-get -y install redis</span></pre><p id="c44f" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">在 macOS 中，在终端中发出以下命令</p><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="9c18" class="nv kt in oj b gy on oo l op oq">brew install redis</span></pre><p id="bf55" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">在 windows 中，在 windows 上获得 Redis 有点困难，因为它在 windows 中没有得到官方支持。</p><blockquote class="ml mm mn"><p id="e0a8" class="lk ll mo lm b ln mg jo lp lq mh jr ls mp mi lv lw mq mj lz ma mr mk md me mf ig bi translated">Redis 在 Windows 上不受官方支持。但是，您可以按照下面的说明在 Windows 上安装 Redis 进行开发。</p><p id="f444" class="lk ll mo lm b ln mg jo lp lq mh jr ls mp mi lv lw mq mj lz ma mr mk md me mf ig bi translated">要在 Windows 上安装 Redis，首先需要启用<a class="ae ms" href="https://docs.microsoft.com/en-us/windows/wsl/install" rel="noopener ugc nofollow" target="_blank">wsl 2</a>(Linux 的 Windows 子系统)。WSL2 允许您在 Windows 上本地运行 Linux 二进制文件。要使用这种方法，您需要运行 Windows 10 2004 版或更高版本或 Windows 11。</p><p id="448a" class="lk ll mo lm b ln mg jo lp lq mh jr ls mp mi lv lw mq mj lz ma mr mk md me mf ig bi translated"><a class="ae ms" href="https://redis.io/docs/getting-started/installation/install-redis-on-windows/" rel="noopener ugc nofollow" target="_blank">https://redis . io/docs/getting-started/installation/install-redis-on-windows/</a></p></blockquote><h2 id="7478" class="nv kt in bd ku nw nx dn ky ny nz dp lc lt oa ob le lx oc od lg mb oe of li og bi translated">将 node-Redis 安装到项目中:</h2><p id="cc48" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">node-Redis 是 Node.js 的一个现代化、高性能的 Redis 客户端。</p><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="5808" class="nv kt in oj b gy on oo l op oq">npm install redis</span></pre><p id="dc13" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">现在我们安装了 Redis 和 node-redis 包，让我们用这些伟大的工具做简单的工作，然后在一个真实的例子中尝试一下！</p><h2 id="fe28" class="nv kt in bd ku nw nx dn ky ny nz dp lc lt oa ob le lx oc od lg mb oe of li og bi translated">Redis 快速入门:</h2><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="4d82" class="nv kt in oj b gy on oo l op oq">// IMPORTANT : before you can establish connection to redis,</span><span id="7564" class="nv kt in oj b gy or oo l op oq">// you must start the redis-server</span><span id="22d3" class="nv kt in oj b gy or oo l op oq">const redis = require('redis');</span><span id="bcd0" class="nv kt in oj b gy or oo l op oq">// create client to communicate redis DB</span><span id="25f0" class="nv kt in oj b gy or oo l op oq">var client = redis.createClient();</span><span id="2ffc" class="nv kt in oj b gy or oo l op oq">(async function () {</span><span id="decb" class="nv kt in oj b gy or oo l op oq">await client.connect()</span><span id="660d" class="nv kt in oj b gy or oo l op oq">})()</span><span id="75db" class="nv kt in oj b gy or oo l op oq">// connect and error events</span><span id="42cb" class="nv kt in oj b gy or oo l op oq">client.on('error', function (err) {</span><span id="df24" class="nv kt in oj b gy or oo l op oq">console.log('Something went wrong ', err)</span><span id="fbc5" class="nv kt in oj b gy or oo l op oq">});</span><span id="e941" class="nv kt in oj b gy or oo l op oq">client.on('connect', function () {</span><span id="0a9c" class="nv kt in oj b gy or oo l op oq">console.log('Redis Connected!')</span><span id="db43" class="nv kt in oj b gy or oo l op oq">});</span></pre><h2 id="8143" class="nv kt in bd ku nw nx dn ky ny nz dp lc lt oa ob le lx oc od lg mb oe of li og bi translated">连接到 Redis 服务器:</h2><p id="a577" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">要启动 Redis 服务器，您需要在终端中运行:</p><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="607f" class="nv kt in oj b gy on oo l op oq">redis-server</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi os"><img src="../Images/53ba10d702fb0a48c8529c377dc8aa4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m3VFF1YrEAs5Iv4IpCdwtQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">启动 Redis 服务器</figcaption></figure><p id="6b61" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">示例:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/f1be234a82cb1ff77d57ef6333559081.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*7SSJ_dwuRdNj5Kj5mWMx9w.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">set()和 get()</figcaption></figure><p id="fc35" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">上面我们创建了一个客户端，并开始连接 Redis 服务器，现在我们可以使用所有的功能。</p><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="c848" class="nv kt in oj b gy on oo l op oq">// used to put data into redis<br/>client.set("key" , "some value")</span><span id="d014" class="nv kt in oj b gy or oo l op oq">// used to get data from redis<br/>client.get("key")<br/>// output = "some value"</span></pre></div><div class="ab cl mt mu hr mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ig ih ii ij ik"><h1 id="5c47" class="ks kt in bd ku kv na kx ky kz nb lb lc jt nc ju le jw nd jx lg jz ne ka li lj bi translated">现实世界的例子:</h1><p id="9db3" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">现在最大的问题是，我如何利用这些简单的函数 set()和 get()，来提高我的服务器性能？</p><p id="79da" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">让我们看看我自己的服务器(express server 从 MongoDB atlas 中获取报价并发送回。)</p><p id="a5eb" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">该基准测试来自我自己的报价 API(将很快在 RapidAPI 中发布)，我们将看到当我们请求 1000、3000 和 5000 个数据文档时所用时间的差异，这次我将通过从缓存中获取相同的数据来重复测试。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ou"><img src="../Images/eddecc08967a330084360a21465cc118.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WlIStPkrZXLJofgsqsMWFQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">提取 1000 个未缓存的文档</figcaption></figure><p id="4219" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">从数据库中获取 1000 个文档几乎需要 2 秒钟</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ov"><img src="../Images/90659db1bc745ecdf26e64cf39c9ee78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CpMabHFxMv2Q-1Rs2zTS8A.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">从缓存中取出同样的 1000 个文档</figcaption></figure><p id="e867" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">但是从缓存中获取相同数量的数据只需要 25 毫秒！</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ow"><img src="../Images/221bc77c0dfc7c89fd215f540859fcd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QyVgrhEP96djw4-leWF3Jg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">在没有缓存的情况下获取了 3000 个文档</figcaption></figure><p id="d9a7" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">从数据库中获取 3000 个文档几乎花了 4 秒钟！</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ox"><img src="../Images/e26e634dd8a78b7b5298d3d135124c82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J2O6lES5WuaECApEVQ3VRg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">从缓存中获取 3000 个文档</figcaption></figure><p id="e5a3" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">但是从缓存中获取相同数量的数据只需要 45 毫秒！</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oy"><img src="../Images/e7afd1ff7b76245b17754dd355248481.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ukpN2xdQn6j-MdAFuFHmAw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">在没有缓存的情况下获取了 5000 个文档</figcaption></figure><p id="875d" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">从数据库中获取 5000 个文档几乎花了 5 秒钟！</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oz"><img src="../Images/18f4765796f3eca782f7bd3bf592cae0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RCD9m4QawG4ZOXBblzyi9g.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">从缓存中获取 5000 个文档</figcaption></figure><p id="6363" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">但是从缓存来看，只用了 60 毫秒！</p><p id="0788" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">很神奇吧？？</p></div><div class="ab cl mt mu hr mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ig ih ii ij ik"><h2 id="b0c7" class="nv kt in bd ku nw nx dn ky ny nz dp lc lt oa ob le lx oc od lg mb oe of li og bi translated">缓存机制:</h2><p id="229d" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">缓存只是在您的服务器上添加另一层，这一层将拦截您的数据库将要执行的查询，它将搜索该查询之前是否被缓存，如果是，它将返回缓存的数据作为响应，而不会将查询发送到数据库，如果查询之前没有被缓存，它将把查询发送到数据库以执行，然后将结果存储在缓存(Redis)中以备即将到来的请求。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pa"><img src="../Images/aa879dbe6e9e72a8c15dbaee7fd7b931.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Sze6sykRanXIf3PD.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated"><a class="ae ms" href="https://linuxiac.com/redis-as-cache/" rel="noopener ugc nofollow" target="_blank"> Linuxiac </a>的积分</figcaption></figure><p id="68f1" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">所以为了阐明我们想要做的事情:</p><ol class=""><li id="207a" class="nf ng in lm b ln mg lq mh lt nh lx ni mb nj mf pb nl nm nn bi translated">使用上面的代码将服务器连接到 Redis</li><li id="0a78" class="nf ng in lm b ln no lq np lt nq lx nr mb ns mf pb nl nm nn bi translated">我们想要劫持(拦截、中断，随你怎么称呼)向数据库发送查询的过程，这样我们就可以决定这个查询之前是否被缓存</li><li id="a605" class="nf ng in lm b ln no lq np lt nq lx nr mb ns mf pb nl nm nn bi translated">如果缓存了，则返回缓存的数据并结束响应。不要向数据库发送任何内容</li><li id="b7b6" class="nf ng in lm b ln no lq np lt nq lx nr mb ns mf pb nl nm nn bi translated">如果没有缓存，发送查询以执行，并将结果作为响应发送，然后将结果存储在缓存中以供新请求使用。</li></ol><p id="225d" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">首先，您需要在您的项目中创建一个名为 cache.js 的新文件，您可以随意命名它，如果您有服务目录，可以将其放在任何地方。</p><p id="5b55" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">这个文件将包含我们的服务器缓存数据和从 Redis 检索数据所需的所有逻辑。</p><p id="c5c8" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">开始时，我们需要连接到 Redis 并确保它工作正常</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/1664608b228ff1fe0e63b3f2d4cb3df6.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*2HaSV90Nb1amz4TRys2gww.png"/></div></figure><h2 id="c270" class="nv kt in bd ku nw nx dn ky ny nz dp lc lt oa ob le lx oc od lg mb oe of li og bi translated">密钥创建:</h2><p id="7217" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">为了在 Redis 中存储数据，我们需要给每个查询一个惟一且一致的键，这样我们就可以在请求到达时检索正确的查询。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pd"><img src="../Images/928a01e3bfe12cb65827f06376b0d6c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bw8C3PgUkDzPU5Dh4ktGeA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">Redis 数据库的密钥创建</figcaption></figure><p id="40fc" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">基本上，对任何数据库的每个查询都有过滤器和选项来获取特定的文档或记录。</p><p id="de83" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">我们将利用这个东西，把这些过滤器变成一个字符串</p><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="bbb1" class="nv kt in oj b gy on oo l op oq">JSON.stringfy({ {title : "story"} , {skip : 10} })<br/>// our key = "{{"title" : "story" }, {"skip" : 10}}"<br/>// everytime any client will request the data that can be fetched<br/>// with this query, the server will repsonse with the cached data</span></pre><p id="5ebf" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">现在，我们有了需要在数据库中执行的每个查询的键，接下来我们要做的是在 Redis 中搜索这个键，如果它确实存在，则返回它的值而不是执行查询，如果没有找到，则在数据库中执行查询，并将查询结果及其键存储在 Redis 中以供下次请求使用，然后将结果发送给用户。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pe"><img src="../Images/25f6436fc161a46e1a0131f1dcca8ac3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J8RrpcwTaHFbv--rv-Qknw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">Redis 缓存数据</figcaption></figure><pre class="kd ke kf kg gt oi oj ok ol aw om bi"><span id="7d0c" class="nv kt in oj b gy on oo l op oq">// this line will add the data fetched from mongoDB to redis<br/>client.set(key, JSON.stringify(result))<br/>// always remember, Redis only store values as a string or numbers<br/></span></pre><h2 id="7f71" class="nv kt in bd ku nw nx dn ky ny nz dp lc lt oa ob le lx oc od lg mb oe of li og bi translated">总结:</h2><p id="f307" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">首先，您需要为每个查询创建一个惟一且一致的键。</p><p id="968e" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">第二，在 Redis 中搜索这个键，如果找到了，返回它的值，如果没有，执行查询并将结果存储在 Redis 中，最后发送给用户。</p></div><div class="ab cl mt mu hr mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ig ih ii ij ik"><h1 id="f557" class="ks kt in bd ku kv na kx ky kz nb lb lc jt nc ju le jw nd jx lg jz ne ka li lj bi translated">参考资料:</h1><p id="f106" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">深入学习 node.js 的所有课程中最好的。</p><p id="afab" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated"><a class="ae ms" href="https://www.udemy.com/course/advanced-node-for-developers/?ranMID=39197&amp;ranEAID=SAyYsTvLiGQ&amp;ranSiteID=SAyYsTvLiGQ-EDfB120pgYcJlhkNSEBp4Q&amp;LSNPUBID=SAyYsTvLiGQ&amp;utm_source=aff-campaign&amp;utm_medium=udemyads" rel="noopener ugc nofollow" target="_blank">https://www.udemy.com/course/advanced-node-for-developers/?ran mid = 39197&amp;rane aid = saystvligq&amp;ranSiteID = saystvligq-edfb 120 pgycjlhnknsebp 4 q&amp;lsn pubid = saystvligq&amp;UTM _ source = aff-campaign&amp;UTM _ medium = udemyads</a></p><div class="pf pg gp gr ph pi"><a href="https://www.digitalocean.com/community/tutorials/how-to-implement-caching-in-node-js-using-redis" rel="noopener  ugc nofollow" target="_blank"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd io gy z fp pn fr fs po fu fw im bi translated">如何使用 Redis | DigitalOcean 在 Node.js 中实现缓存</h2><div class="pp l"><h3 class="bd b gy z fp pn fr fs po fu fw dk translated">大多数应用程序都依赖于数据，无论数据来自数据库还是 API。从 API 获取数据会向网络发送…</h3></div><div class="pq l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">www.digitalocean.com</p></div></div><div class="pr l"><div class="ps l pt pu pv pr pw km pi"/></div></div></a></div><div class="pf pg gp gr ph pi"><a href="https://blog.risingstack.com/redis-node-js-introduction-to-caching/" rel="noopener  ugc nofollow" target="_blank"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd io gy z fp pn fr fs po fu fw im bi translated">Redis + Node.js:缓存- RisingStack 工程简介</h2><div class="pp l"><h3 class="bd b gy z fp pn fr fs po fu fw dk translated">我认为理解和使用缓存是编写代码的一个非常重要的方面，所以在这篇文章中，我将解释…</h3></div><div class="pq l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">blog.risingstack.com</p></div></div><div class="pr l"><div class="px l pt pu pv pr pw km pi"/></div></div></a></div><div class="pf pg gp gr ph pi"><a href="https://dev.to/franciscomendes10866/caching-in-node-js-using-redis-2o80" rel="noopener  ugc nofollow" target="_blank"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd io gy z fp pn fr fs po fu fw im bi translated">使用 Redis 在 Node.js 中缓存</h2><div class="pp l"><h3 class="bd b gy z fp pn fr fs po fu fw dk translated">这一次我们将使用 Redis 在现有的 node.js 应用程序中实现缓存，但是首先让我们了解…</h3></div><div class="pq l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">开发到</p></div></div><div class="pr l"><div class="py l pt pu pv pr pw km pi"/></div></div></a></div><div class="pf pg gp gr ph pi"><a href="https://medium.com/geekculture/fasten-your-node-js-application-with-a-powerful-caching-mechanism-using-redis-fd76b8aa482f" rel="noopener follow" target="_blank"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd io gy z fp pn fr fs po fu fw im bi translated">使用 Redis 的强大缓存机制来保护您的 Node JS 应用程序</h2><div class="pp l"><h3 class="bd b gy z fp pn fr fs po fu fw dk translated">使用 Redis 提高应用程序的速度</h3></div><div class="pq l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">medium.com</p></div></div><div class="pr l"><div class="pz l pt pu pv pr pw km pi"/></div></div></a></div><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="qa qb l"/></div></figure><div class="pf pg gp gr ph pi"><a href="https://redis.io/docs/stack/get-started/tutorials/stack-node/" rel="noopener  ugc nofollow" target="_blank"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd io gy z fp pn fr fs po fu fw im bi translated">Node.js 的 Redis OM</h2><div class="pp l"><h3 class="bd b gy z fp pn fr fs po fu fw dk translated">学习如何用 Redis Stack 和 Node.js 构建这个教程将向你展示如何用 Node.js 和 Redis 构建一个 API</h3></div><div class="pq l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">redis.io</p></div></div></div></a></div></div><div class="ab cl mt mu hr mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ig ih ii ij ik"><p id="f46d" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">感谢您的阅读，如果您有任何关于 javascript 或本系列的问题，请随时提问，我非常感谢您对我的内容的任何反馈。</p><p id="2f33" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">我希望你能在<a class="ae ms" href="https://twitter.com/Osam1010" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae ms" href="https://github.com/osama865/" rel="noopener ugc nofollow" target="_blank"> Github </a>和<a class="ae ms" href="http://o-portfolio.netlify.com/" rel="noopener ugc nofollow" target="_blank"> my portfolio </a>上找到我。</p></div></div>    
</body>
</html>