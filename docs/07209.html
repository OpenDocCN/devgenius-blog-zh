<html>
<head>
<title>Get started with Docker and Docker Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开始使用 Docker 和 Docker Compose</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/get-started-with-docker-and-docker-compose-cddcb5a3f3b9?source=collection_archive---------2-----------------------#2022-03-06">https://blog.devgenius.io/get-started-with-docker-and-docker-compose-cddcb5a3f3b9?source=collection_archive---------2-----------------------#2022-03-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/7a82756d7008e062f6ba9a89a32c87b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gm4KnU_sEl1nyGqkgvatSQ.jpeg"/></div></div></figure><p id="d788" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">除了 embedded，很难找到一家软件公司不利用 Docker 作为他们的容器解决方案。如果是一家专注于网络的公司，那就更难了。出现这种情况有一个很好的原因，它让开发者/SRE/DevOps 工程师的生活变得更加容易。</p><p id="ea71" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">早期可能面临的问题是“它在我的机器上工作”这样的事情。简而言之，当部署到生产环境或另一个开发人员的机器上时，它的行为可能与预期的不同，因此会遇到问题。现在，当使用 Docker 时，我们可以很容易地说“它在每台机器上都以相同的方式工作”。这真的很好，我们现在可以确定我们以前没有的交付成果，这样我们就可以交付一个好的产品，特别是在生产中。</p><p id="7183" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">来自维基百科:</p><blockquote class="kt"><p id="252a" class="ku kv in bd kw kx ky kz la lb lc ks dk translated"><strong class="ak"> Docker </strong>是一套平台即服务(PaaS)产品，使用操作系统级虚拟化来交付名为<em class="ld">容器</em>的软件包中的软件。这项服务有免费和高级两个等级。托管这些容器的软件被称为<strong class="ak"> Docker 引擎</strong>。它于 2013 年首次启动，由 Docker，Inc .开发。</p></blockquote><p id="354b" class="pw-post-body-paragraph jv jw in jx b jy le ka kb kc lf ke kf kg lg ki kj kk lh km kn ko li kq kr ks ig bi translated">这是 Docker 架构及其工作原理:</p><figure class="lk ll lm ln gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lj"><img src="../Images/a5356966b0fb046bff29e4d383a7c83b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y9Ob8IFGDLJ9DJeAkAmXYQ.png"/></div></div></figure><p id="0360" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本教程中，你需要了解 Spring Boot 和格雷德尔是如何工作的，以便理解一些构建过程。</p><h1 id="807f" class="lo lp in bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">提取 Docker 图像并运行容器</h1><p id="d565" class="pw-post-body-paragraph jv jw in jx b jy mm ka kb kc mn ke kf kg mo ki kj kk mp km kn ko mq kq kr ks ig bi translated">所以从客户端(你的操作系统)，你运行命令到你的计算机上运行的<strong class="jx io"> Docker 守护进程</strong>。您可以从<strong class="jx io">映像</strong>中设置<strong class="jx io">容器</strong>，创建映像，创建<strong class="jx io">卷</strong>，创建<strong class="jx io">网络</strong>等等。当我们运行如下命令时:</p><pre class="lk ll lm ln gt mr ms mt mu aw mv bi"><span id="ffc3" class="mw lp in ms b gy mx my l mz na">docker run -e POSTGRES_PASSWORD=password -d postgres</span></pre><p id="1769" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是尝试运行一个包含名为<strong class="jx io"> postgres </strong>的图像的容器。我们添加了一个环境变量<strong class="jx io"> POSTGRES_PASSWORD </strong>及其值，因此 PostgreSQL 将使用它作为默认用户<strong class="jx io"> postgres </strong>。Docker 然后尝试在本地找到它，如果没有，它将尝试从配置的注册表(默认 Docker Hub)中提取映像。然后它试图启动它，我们得到它被分配的容器 ID 的完整散列值。因此，当我们运行<strong class="jx io"> docker ps </strong>时，我们会在这里获得以下相关信息:</p><figure class="lk ll lm ln gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nb"><img src="../Images/42c4c80c4e2dd111fff6c51a42ad7a30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NdVliO5P5DN0lAf7GBJ5Ag.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">docker ps</figcaption></figure><p id="1b15" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里，我们获得了唯一的容器 ID、我们正在使用的映像、传递给容器的命令、容器的创建时间、当前状态(是启动还是退出)、它正在侦听的端口以及协议和分配的名称。如果我们愿意，我们可以更改名称，这就是我们使用 Docker 的方式，我们只需要稍微更改我们之前的命令:</p><pre class="lk ll lm ln gt mr ms mt mu aw mv bi"><span id="4340" class="mw lp in ms b gy mx my l mz na">docker run --name mydb -e POSTGRES_PASSWORD=password -d postgres</span></pre><p id="ea1f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是在再次运行该命令之前，我们需要删除现有的容器，因为它将在同一个端口上侦听两次。我们首先必须停止所有正在运行的容器:</p><figure class="lk ll lm ln gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ng"><img src="../Images/7b228afd66cdaa7b7f5564fc0e2e53ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8qy_anIHEkf8NyvBhlE7UA.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">docker kill $(docker ps -q)</figcaption></figure><p id="8c7d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，我们用两种不同的方式进行清理(也许还有更多我不知道的方式)。我们可以像这样做一次彻底的清理:</p><figure class="lk ll lm ln gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ng"><img src="../Images/3357cb693e33cbc64aade2110971e177.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yF1EipMTNsexPrgvQq6_0A.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">docker 系统清理-全部</figcaption></figure><p id="debc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你必须意识到这移除了所有的东西。所以大部分时候用这个<em class="nh"/>不是个好办法。但如果你觉得自己一直在做很多事情，只想从头开始，这个不错。</p><p id="0594" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在大多数情况下，还有另一个更好的选择。我们运行这些命令:</p><figure class="lk ll lm ln gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/0c0e1f6d3e8d3f41543bed95b279cbf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BJDczbKEMo5XFuWyCqCJMQ.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">码头工人 rm <container name=""/></figcaption></figure><p id="7b12" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，我们只需使用命令<strong class="jx io"> docker rm </strong>及其容器<strong class="jx io">名称</strong>，或者您也可以将<strong class="jx io">容器 ID </strong>用于该命令。因此，您可以看到，我们在这里删除了<strong class="jx io"> keen_napier </strong>，我们只有新的容器。由于我们停止了所有集装箱，我们必须开始新的集装箱，我们可以通过以下方式做到这一点:</p><figure class="lk ll lm ln gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/578465d077eb10c43afb5affaab1957c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KlycZS7ANnOf_O4QOpHEMg.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">docker 启动 mydb</figcaption></figure><p id="dbd4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以在这里用<strong class="jx io"> docker start </strong>命令再次启动它是非常容易的。</p><p id="6a98" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们有一个 Docker 容器启动并运行。关于 Docker，我们可以在这里讨论很多东西，但是我们将坚持基本的东西。当我们运行该命令在 Docker 容器中设置 PostgreSQL 时，它会自动为我们添加一个<strong class="jx io">卷</strong>。当我们需要写一些东西时，卷是必不可少的，这对于数据库来说是至关重要的。Docker 不允许在容器中写入，所以我们总是需要给它附加一个卷。我们将很快介绍如何创建我们自己的 docker 映像，但让我们探索如何在我们的计算机上查看 Docker 卷:</p><figure class="lk ll lm ln gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/a7d7a23014d95f648bc02efb68e9c952.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HtUJBcM-ZAvlwEQdgsJYJw.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">docker 卷 ls</figcaption></figure><p id="3be6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们列出了目前拥有的所有卷。我们有两个，因为我们没有删除最后一个。那么，我们如何知道哪一个连接到当前正在运行的那个呢？我们可以通过检查当前的 Docker 容器来做到这一点:</p><figure class="lk ll lm ln gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/6a3ffe7760d120901febd1a58004537b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oijd2TRrvAOhOLVrZBBN6Q.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">码头工人检查<container id=""/></figcaption></figure><p id="6115" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里我们看到了很多关于它的信息，这对故障排除非常有用。</p><figure class="lk ll lm ln gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/c4fbc636d82f9751f5eefd24e2df01fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PWBfvN1svJcVMj0MP2_2xw.png"/></div></div></figure><p id="2ce9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们向下滚动一点，我们可以找到<strong class="jx io"> Mounts </strong>数组，我们可以看到卷哈希值，并将其与我们在之前的映像 643579 a4 F6 ce 50 dff 92865 e7d 9163 BF 3c b 16867 b 7274 c 2353 c 859 ea 86 ffeb 96 中看到的值进行比较。这是我们需要保留的卷，让我们删除另一个卷，因为我们不再需要它:</p><figure class="lk ll lm ln gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/7df52d108d761b45a34b41ea317cddd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DqBdR1ss0MMpsrJNSVhe7Q.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">docker 卷 rm <volume id=""/></figcaption></figure><p id="286e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们在这里得到一个确认，返回的哈希值表明它已经被删除。太好了！</p><h1 id="e6ba" class="lo lp in bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">使用 Docker 文件创建 Docker 映像</h1><p id="f2b8" class="pw-post-body-paragraph jv jw in jx b jy mm ka kb kc mn ke kf kg mo ki kj kk mp km kn ko mq kq kr ks ig bi translated">现在让我们看看如何通过创建 Docker 文件来创建我们自己的自定义 Docker 映像。因为我们已经通过 Spring Boot 之前，我们可以尝试使我们的 Spring Boot 申请到一个码头形象。克隆下储存库:<a class="ae nj" href="https://github.com/mjovanc/medium-docker-spring" rel="noopener ugc nofollow" target="_blank">https://github.com/mjovanc/medium-docker-spring</a></p><p id="7a4e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们下载所有的依赖项并构建应用程序，我建议使用 IntelliJ。打开项目，然后 IntelliJ 会通过查看<strong class="jx io"> build.gradle </strong>文件直接自动下载所有东西。然后我们需要通过运行<strong class="jx io">来构建它。/Gradle build</strong>或在 IntelliJ 中按下右侧边栏上的 grad le 并双击 build:</p><figure class="lk ll lm ln gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/fe6aba2003e74ab337e0b92d4b261178.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3qyyzOKk6dd2gbR6W2J1KQ.png"/></div></div></figure><p id="99ad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，当我们完成这些后，我们将获得一个<strong class="jx io">。war </strong>文件在<strong class="jx io">里面。/build/libs/blog-0.0.1.war </strong>。这是必需的，这样我们就可以用 Dockerfile 获取这个文件，并将其添加到图像中。因此，让我们在项目的根目录下创建 Dockerfile 文件:</p><pre class="lk ll lm ln gt mr ms mt mu aw mv bi"><span id="4f71" class="mw lp in ms b gy mx my l mz na"><em class="nh"># Using Tomcat 9.0 since the latest doesn't work with Spring Boot<br/></em>FROM tomcat:9.0-jdk16-openjdk<br/>ARG WAR_FILE=build/libs/blog-*.war<br/>RUN rm -rf /usr/local/tomcat/webapps/*<br/>COPY ${WAR_FILE} /usr/local/tomcat/webapps/ROOT.war<br/>EXPOSE 8080<br/>CMD ["catalina.sh", "run"]</span></pre><p id="a205" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是 docker 文件的必要代码。我们首先使用一个现有的图像<strong class="jx io">Tomcat:9.0-JDK 16-open JDK</strong>，然后我们根据需要修改它。我们设定了一个论点。war 文件存在，那么我们删除所有<strong class="jx io">。警告存在的<strong class="jx io">/usr/local/Tomcat/web apps</strong>中的</strong>文件，然后我们复制那个<strong class="jx io">。我们已经创建了 war </strong>文件，并将它放在删除所有<strong class="jx io">文件相同目录中。war </strong>文件，这样 Tomcat 就可以使用那个文件，然后我们将容器暴露给端口<strong class="jx io"> 8080 </strong>，这样就可以在我们的主机操作系统上的 Docker 容器之外访问它，然后运行 shell 脚本<strong class="jx io"> catalina.sh </strong>，并带有参数<strong class="jx io"> run </strong>。</p><p id="9005" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在代码已经就绪，我们需要构建图像:</p><figure class="lk ll lm ln gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/07b64356b9cdf454d3906aefad56c7c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*At1IO_ViHXLWsk4Jv_5cJA.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">码头工人建造。</figcaption></figure><p id="51fb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们还可以构建映像并对其进行标记，这样我们就可以通过运行以下命令来获得它的名称和版本:</p><figure class="lk ll lm ln gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/5d99f4c058b6d473e33f9613d1c940cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UqizL9FDZvVxYeZvuZ9Uww.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">docker build-t mjovanc/blog-API:0 . 0 . 1。</figcaption></figure><p id="3772" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们已经成功地建立了我们的第一个码头工人形象。现在我们只需要启动它。由于我们已经在<strong class="jx io"> application.yml </strong>中为我们的环境变量设置了回退值，我们不需要在本地启动容器时传递它们:</p><pre class="lk ll lm ln gt mr ms mt mu aw mv bi"><span id="bde7" class="mw lp in ms b gy mx my l mz na">docker run --name blog-api mjovanc/blog-api:0.0.1</span></pre><p id="e409" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在容器已经启动并运行了！这是一个如何创建和运行 Docker 容器的非常基本的例子。</p><h1 id="bea7" class="lo lp in bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">使用 Docker Compose 进行编排</h1><p id="fcb2" class="pw-post-body-paragraph jv jw in jx b jy mm ka kb kc mn ke kf kg mo ki kj kk mp km kn ko mq kq kr ks ig bi translated">现在我们将研究如何使用 Docker Compose 来设置 PostgreSQL 和 Spring Boot。</p><blockquote class="kt"><p id="9f7c" class="ku kv in bd kw kx ky kz la lb lc ks dk translated">Compose 是一个定义和运行多容器 Docker 应用程序的工具。使用 Compose，您可以使用 YAML 文件来配置应用程序的服务。然后，只需一个命令，您就可以从您的配置中创建并启动所有服务。</p></blockquote><p id="6f82" class="pw-post-body-paragraph jv jw in jx b jy le ka kb kc lf ke kf kg lg ki kj kk lh km kn ko li kq kr ks ig bi translated">在这里阅读更多关于 Docker Compose 的内容:<a class="ae nj" href="https://docs.docker.com/compose/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/compose/</a></p><p id="95dc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将使事情变得简单一点，因为我们可以用<strong class="jx io"> YAML </strong>文件格式配置一切。让我们看看这个 Docker 合成文件:</p><pre class="lk ll lm ln gt mr ms mt mu aw mv bi"><span id="3e48" class="mw lp in ms b gy mx my l mz na">version: '3.7'<br/><br/>services:<br/>  spring:<br/>    build: .<br/>    container_name: blog-api<br/>    environment:<br/>      POSTGRESQL_HOSTNAME: postgres<br/>      POSTGRESQL_PORT: 5432<br/>      POSTGRESQL_DB_NAME: qryptic_dev<br/>      POSTGRESQL_DB_USER: postgres<br/>      POSTGRESQL_DB_PASSWORD: test1234<br/>      KEYCLOAK_HOSTNAME: keycloak<br/>      KEYCLOAK_PORT: 11111<br/>      <em class="nh"># This below is optional if you need to specify a specific Spring Boot profile to use<br/>      # JAVA_OPTS: '-Dspring.profiles.active=dev'<br/>    </em>ports:<br/>      - "8080:8080"<br/>    links:<br/>      - postgres<br/>      - keycloak<br/>    depends_on:<br/>      - postgres<br/>    networks:<br/>      - blog-net<br/><br/>  postgres:<br/>    image: postgres<br/>    container_name: postgres<br/>    restart: always<br/>    environment:<br/>      POSTGRES_DB: qryptic_dev<br/>      POSTGRES_USER: postgres<br/>      POSTGRES_PASSWORD: test1234<br/>    volumes:<br/>      - postgres:/data/postgres<br/>    ports:<br/>      - "5432:5432"<br/>    networks:<br/>      - blog-net<br/><br/>  keycloak:<br/>    image: jboss/keycloak<br/>    container_name: keycloak<br/>    restart: always<br/>    environment:<br/>      DB_VENDOR: h2<br/>      KEYCLOAK_USER: admin<br/>      KEYCLOAK_PASSWORD: password<br/>      PROXY_ADDRESS_FORWARDING: "true"<br/>    volumes:<br/>      - keycloak:/var/lib/keycloak/data<br/>      - ./keycloak/realm-export.json:/opt/jboss/keycloak/realm-export.json<br/>    expose:<br/>      - 11111<br/>    ports:<br/>      - "11111:11111"<br/>    command:<br/>      - "-b 0.0.0.0"<br/>      - "-Djboss.http.port=11111"<br/>      - "-Dkeycloak.import=/opt/jboss/keycloak/realm-export.json"<br/>    networks:<br/>      - blog-net<br/><br/>volumes:<br/>  postgres:<br/>  keycloak:<br/><br/>networks:<br/>  blog-net:<br/>    driver: bridge</span></pre><p id="7c3e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些东西有很多东西我们需要打开和经历。很明显我们这里有一种叫做钥匙槽的东西。这只是为了演示我们如何在这里添加更多的东西。但是对于本教程，我将注释掉<em class="nh">键盘锁</em>，因为我们不会在这里使用它。但是如果你需要设置 Keycloak，这里有一个我个人用过的很好的例子。</p><p id="1bce" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，让我们深入研究一下<strong class="jx io"> docker-compose.yml </strong>文件中的第一行:</p><pre class="lk ll lm ln gt mr ms mt mu aw mv bi"><span id="a4c6" class="mw lp in ms b gy mx my l mz na">version: '3.7'</span></pre><p id="7409" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这指定了我们将使用的 Docker Compose 的版本，不同版本之间的语法可能会有所不同。在这里查看它的文档:<a class="ae nj" href="https://docs.docker.com/compose/compose-file/compose-versioning/" rel="noopener ugc nofollow" target="_blank">https://docs . docker . com/compose/compose-file/compose-versioning/</a></p><pre class="lk ll lm ln gt mr ms mt mu aw mv bi"><span id="f510" class="mw lp in ms b gy mx my l mz na">services:<br/>  spring:<br/>    build: .<br/>    container_name: blog-api<br/>    environment:<br/>      POSTGRESQL_HOSTNAME: postgres<br/>      POSTGRESQL_PORT: 5432<br/>      POSTGRESQL_DB_NAME: blogdb_dev<br/>      POSTGRESQL_DB_USER: postgres<br/>      POSTGRESQL_DB_PASSWORD: test1234<br/>      KEYCLOAK_HOSTNAME: keycloak<br/>      KEYCLOAK_PORT: 11111<br/>      <em class="nh"># This below is optional if you need to specify a specific Spring Boot profile to use<br/>      # JAVA_OPTS: '-Dspring.profiles.active=dev'<br/>    </em>ports:<br/>      - "8080:8080"<br/>    links:<br/>      - postgres<br/>      - keycloak<br/>    depends_on:<br/>      - postgres<br/>    networks:<br/>      - blog-net</span></pre><p id="097c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里，我们定义应该编排哪种服务。我们将 spring 定义为一个服务，并将路径添加到 Dockerfile，我们将其设置为<strong class="jx io">。</strong>(<strong class="jx io">docker-compose . yml</strong>文件所在的当前目录)。然后我们设置容器的名称，如果我们不设置，它会将名称设置为服务名(spring)，然后我们定义我们需要的所有环境变量。我们还设置内部和外部应该使用什么端口来公开。我们在这里设置了到 postgres 和 keycloak 服务的链接，并且我们还为 postgres 服务设置了一个 depends_on，这意味着在我们启动 Spring Boot 之前，我们首先需要编排 PostgreSQL 数据库，以便它在启动应用程序时不会失败，并且我们定义了它应该连接到的网络。我们将所有服务都设置为具有此网络，以便它们可以相互通信。</p><pre class="lk ll lm ln gt mr ms mt mu aw mv bi"><span id="ecf7" class="mw lp in ms b gy mx my l mz na">postgres:<br/>  image: postgres<br/>  container_name: postgres<br/>  restart: always<br/>  environment:<br/>    POSTGRES_DB: blogdb_dev<br/>    POSTGRES_USER: postgres<br/>    POSTGRES_PASSWORD: test1234<br/>  volumes:<br/>    - postgres:/data/postgres<br/>  ports:<br/>    - "5432:5432"<br/>  networks:<br/>    - blog-net</span></pre><p id="19bc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们做同样的事情，但是定义 PostgreSQL 配置。我们指定将从 Docker Hub 注册表中下载(如果尚未下载)的映像。我们将重启设置为 always，设置一些环境变量来定义应该创建什么数据库以及我们将使用什么用户，并设置密码。我们还为容器定义了卷，这样我们就可以存储保存到数据库中的数据，像以前一样使用 PostgreSQL 的默认端口号存储端口，并将其设置为与 spring 服务相同的网络。</p><pre class="lk ll lm ln gt mr ms mt mu aw mv bi"><span id="faf3" class="mw lp in ms b gy mx my l mz na">keycloak:<br/>  image: jboss/keycloak<br/>  container_name: keycloak<br/>  restart: always<br/>  environment:<br/>    DB_VENDOR: h2<br/>    KEYCLOAK_USER: admin<br/>    KEYCLOAK_PASSWORD: password<br/>    PROXY_ADDRESS_FORWARDING: "true"<br/>  volumes:<br/>    - keycloak:/var/lib/keycloak/data<br/>    - ./keycloak/realm-export.json:/opt/jboss/keycloak/realm-export.json<br/>  expose:<br/>    - 11111<br/>  ports:<br/>    - "11111:11111"<br/>  command:<br/>    - "-b 0.0.0.0"<br/>    - "-Djboss.http.port=11111"<br/>    - "-Dkeycloak.import=/opt/jboss/keycloak/realm-export.json"<br/>  networks:<br/>    - blog-net</span></pre><p id="ca92" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们定义了要使用的 keycloak 服务。请注意，我们为 realm-export.json 添加了一个卷，我们附加了该文件，这样我们就可以将该文件导入到 Keycloak 中，而不必手动将配置添加到 Keycloak 服务中。我们有一个添加文件来进行导入的命令。此外，我们还将发送给 Keycloak，我们将使用另一个端口，而不是标准的 8080，因为 Spring Boot 运行在端口 8080 上。</p><pre class="lk ll lm ln gt mr ms mt mu aw mv bi"><span id="9f6a" class="mw lp in ms b gy mx my l mz na">volumes:<br/>  postgres:<br/>  keycloak:<br/><br/>networks:<br/>  blog-net:<br/>    driver: bridge</span></pre><p id="254e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里，我们定义应该存在的卷和具有网桥类型的驱动程序类型的网络。</p><p id="e4a7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是一个如何用 Docker Compose 设置 Spring Boot、PostgreSQL 和 Keycloak 的例子。但是我们暂时不考虑 Keycloak，所以我会注释掉关于 Keycloak 的所有内容，这样我们现在就可以测试运行了。但是首先让我们通过运行以下命令删除之前添加到 Docker 中的所有内容:</p><pre class="lk ll lm ln gt mr ms mt mu aw mv bi"><span id="7174" class="mw lp in ms b gy mx my l mz na">docker kill $(docker ps -q)<br/>docker system prune --all</span></pre><p id="07d0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们现在有了这个更新的<strong class="jx io"> docker-compose.yml </strong>文件:</p><pre class="lk ll lm ln gt mr ms mt mu aw mv bi"><span id="ef65" class="mw lp in ms b gy mx my l mz na">version: '3.7'<br/><br/>services:<br/>  spring:<br/>    build: .<br/>    container_name: blog-api<br/>    environment:<br/>      POSTGRESQL_HOSTNAME: postgres<br/>      POSTGRESQL_PORT: 5432<br/>      POSTGRESQL_DB_NAME: qryptic_dev<br/>      POSTGRESQL_DB_USER: postgres<br/>      POSTGRESQL_DB_PASSWORD: test1234<br/>      <em class="nh"># KEYCLOAK_HOSTNAME: keycloak<br/>      # KEYCLOAK_PORT: 11111<br/>      # This below is optional if you need to specify a specific Spring Boot profile to use<br/>      # JAVA_OPTS: '-Dspring.profiles.active=dev'<br/>    </em>ports:<br/>      - "8080:8080"<br/>    links:<br/>      - postgres<br/>      <em class="nh"># - keycloak<br/>    </em>depends_on:<br/>      - postgres<br/>    networks:<br/>      - blog-net<br/><br/>  postgres:<br/>    image: postgres<br/>    container_name: postgres<br/>    restart: always<br/>    environment:<br/>      POSTGRES_DB: qryptic_dev<br/>      POSTGRES_USER: postgres<br/>      POSTGRES_PASSWORD: test1234<br/>    volumes:<br/>      - postgres:/data/postgres<br/>    ports:<br/>      - "5432:5432"<br/>    networks:<br/>      - blog-net<br/><br/><em class="nh">#  keycloak:<br/>#    image: jboss/keycloak<br/>#    container_name: keycloak<br/>#    restart: always<br/>#    environment:<br/>#      DB_VENDOR: h2<br/>#      KEYCLOAK_USER: admin<br/>#      KEYCLOAK_PASSWORD: password<br/>#      PROXY_ADDRESS_FORWARDING: "true"<br/>#    volumes:<br/>#      - keycloak:/var/lib/keycloak/data<br/>#      - ./keycloak/realm-export.json:/opt/jboss/keycloak/realm-export.json<br/>#    expose:<br/>#      - 11111<br/>#    ports:<br/>#      - "11111:11111"<br/>#    command:<br/>#      - "-b 0.0.0.0"<br/>#      - "-Djboss.http.port=11111"<br/>#      - "-Dkeycloak.import=/opt/jboss/keycloak/realm-export.json"<br/>#    networks:<br/>#      - blog-net<br/><br/></em>volumes:<br/>  postgres:<br/>  <em class="nh"># keycloak:<br/><br/></em>networks:<br/>  blog-net:<br/>    driver: bridge</span></pre><p id="c13a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们运行 Docker Compose:</p><pre class="lk ll lm ln gt mr ms mt mu aw mv bi"><span id="1f04" class="mw lp in ms b gy mx my l mz na">docker-compose up</span></pre><p id="2552" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们还可以设置标志<strong class="jx io"> -d </strong>，这样我们就不会在运行应用程序时得到所有的实时控制台输出:</p><pre class="lk ll lm ln gt mr ms mt mu aw mv bi"><span id="82fa" class="mw lp in ms b gy mx my l mz na">docker-compose up -d</span></pre><figure class="lk ll lm ln gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nl"><img src="../Images/6ad914440cb71143ebda862ad32eb29b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rlNorr51CBn-WUD30qiH_g.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">docker-排版</figcaption></figure><figure class="lk ll lm ln gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nl"><img src="../Images/5c59bebc53b359b3bacaf29523d40cbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m-ko3oosoS5f9jX7R0KhfQ.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">我们现在可以看到 Spring 已经启动，PostgreSQL</figcaption></figure><figure class="lk ll lm ln gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nl"><img src="../Images/ddbaf81d23a2e208e432f700764ede5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7vHIQL9s5dft8xxN9jZj3w.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">使用 docker-compose up -d 时</figcaption></figure><p id="b707" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要停止 Docker 编写，我们可以按 CTRL+C。然后我们还可以删除由以下用户创建的网络:</p><pre class="lk ll lm ln gt mr ms mt mu aw mv bi"><span id="c9c5" class="mw lp in ms b gy mx my l mz na">docker-compose down</span></pre><p id="bfae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果使用<strong class="jx io"> -d </strong>标志，我们也可以通过运行上面的命令来停止编排。</p><p id="780b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们要重建所有映像，如果我们做了一些更改，我们可以运行以下命令:</p><pre class="lk ll lm ln gt mr ms mt mu aw mv bi"><span id="d11f" class="mw lp in ms b gy mx my l mz na">docker-compose up --build</span></pre><p id="3884" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将强制重建所有映像。</p><p id="257e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就我个人而言，当我开发一个 Spring Boot 应用程序时，使用 Docker Compose 来设置 Spring Boot 周围的一切非常好，比如 PostgreSQL 和 Keycloak，甚至可能是一个带有 Angular 或 React 的前端框架。但有时我想省去 Spring Boot，因为重新构建项目以生成一个. war 文件，然后再次运行 docker compose 等会花费很多时间。</p><p id="a0e2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，如果您和我一样，想在开发时省去 Spring Boot，您可以运行这个命令来跳过编排 Spring Boot:</p><pre class="lk ll lm ln gt mr ms mt mu aw mv bi"><span id="9794" class="mw lp in ms b gy mx my l mz na">docker-compose up --scale blog-api=0</span></pre><p id="722b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这用起来非常方便。将 spring 作为 Docker Compose 中的一项服务仍然很好，因为我可以克隆存储库，然后运行 docker-compose up，一切都为我编排好了，这样我就可以最大限度地减少在本地设置项目以进行测试等工作的时间。</p><p id="2683" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我觉得了解 Docker 让我在开发中更有效率，因为我不必浪费时间手动设置系统和开发环境。</p><p id="d06f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以用 Docker 和 Docker Compose 做很多其他的事情，但是我现在就说到这里，也许在接下来的教程中，我可以更深入地研究一些可能发生的问题以及如何解决它们。</p><p id="d0a7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我希望你觉得这个教程很有用，如果有任何问题，请在这里留言，或者关注我的下一个教程。干杯！</p></div></div>    
</body>
</html>