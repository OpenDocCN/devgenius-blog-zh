<html>
<head>
<title>Shallow vs Deep clone in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 中的浅层克隆与深层克隆</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/shallow-vs-deep-clone-in-java-7d13df690d6c?source=collection_archive---------5-----------------------#2021-01-20">https://blog.devgenius.io/shallow-vs-deep-clone-in-java-7d13df690d6c?source=collection_archive---------5-----------------------#2021-01-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="b082" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">Java 没有提供复制构造函数。那么有什么方法可以创建一个对象的副本呢？</h2></div><p id="abfd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对象应该以这样的方式复制，即新创建的复制对象和原始对象具有相同的数据成员和成员函数。这就是我们求助于<strong class="ke io"> <em class="ky">克隆()</em> </strong>的方法。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="d17b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要克隆一个对象，任何类(这里是双胞胎)，让那个类实现可克隆的<a class="ae lg" href="https://www.baeldung.com/java-marker-interfaces" rel="noopener ugc nofollow" target="_blank">标记接口。</a>我们可以看到，在类演示中，类双胞胎的对象兄弟是从原始对象姐妹克隆而来的。并且对象兄弟具有与对象姐妹相同的成员函数。此外，对象兄弟已经复制了对象姐妹的所有数据成员，以及那些数据成员的值。</p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><blockquote class="lo lp lq"><p id="937c" class="kc kd ky ke b kf kg jo kh ki kj jr kk lr km kn ko ls kq kr ks lt ku kv kw kx ig bi translated"><strong class="ke io">浅克隆</strong></p></blockquote><p id="c352" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当一个原始对象被克隆，并且该原始对象有一个<strong class="ke io"> <em class="ky">引用一个用户定义的类</em> </strong>。那么<strong class="ke io">引用将与克隆对象共享。</strong></p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="b392" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里对象<strong class="ke io"> <em class="ky">法国</em><em class="ky">类国家</em> </strong>被克隆成对象<strong class="ke io"> <em class="ky">德国</em> </strong>。对象<strong class="ke io"> <em class="ky">法国</em> </strong>保存变量<strong class="ke io"> <em class="ky"> happinesIndexRank，povertyIndexRank </em> </strong>和，<strong class="ke io"> <em class="ky">引用自定义类 UnitedNations 作为变量 un </em> </strong>。而对象法国和对象德国持有变量 happinesIndexRank 和 povertyIndexRank 的单独且排他的副本。这两个对象共享它们之间的参考 un。法国. un 和德国. un 指向联合国的同一个对象，因此法国. un 和德国. un 的 hashcode 是相同的。这意味着更改 france.un 对象的数据将反映在 germany.un 对象中，反之亦然。这被称为浅层克隆，在 Java 中这是默认发生的。</p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><blockquote class="lo lp lq"><p id="a69d" class="kc kd ky ke b kf kg jo kh ki kj jr kk lr km kn ko ls kq kr ks lt ku kv kw kx ig bi translated"><strong class="ke io">深度克隆</strong></p></blockquote><p id="bc4d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">浅层克隆可以通过对克隆方法进行少量更改来克服。深度克隆比浅层克隆略贵。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="5339" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从对象法国克隆对象德国时，在克隆方法本身的变量 germany.un 中将类 UnitedNations 的新对象分配给对象德国。这就导致了深度克隆。原始对象法国和克隆对象德国看不同的对象类联合国。法国. un 和法国.德国的 hashcode 是不一样的。在任一个中所做的更改都不会反映在另一个中。</p></div></div>    
</body>
</html>