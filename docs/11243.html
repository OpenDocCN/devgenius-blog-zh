<html>
<head>
<title>Exploring the Fundamentals of Recursion: Subsets, Permutations, and Combinations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索递归的基础:子集、置换和组合</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/exploring-the-fundamentals-of-recursion-subsets-permutations-and-combinations-189001dc000e?source=collection_archive---------8-----------------------#2022-12-27">https://blog.devgenius.io/exploring-the-fundamentals-of-recursion-subsets-permutations-and-combinations-189001dc000e?source=collection_archive---------8-----------------------#2022-12-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jk jl jm jn gh gi paragraph-image"><div class="ab gu cl jo"><img src="../Images/d338f88dc34b2b5d11c1275d05ec625b.png" data-original-src="https://miro.medium.com/v2/format:webp/1*PxjGKOLuzYapS93nQICVlg.png"/></div></figure><p id="c5c1" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在本帖中，我们将深入迷人的递归世界，探索构成这一强大编程技术基础的三个基本概念:子集、置换和组合。</p><h2 id="798d" class="kp kq in bd kr ks kt dn ku kv kw dp kx kc ky kz la kg lb lc ld kk le lf lg lh bi translated">递归</h2><p id="8142" class="pw-post-body-paragraph jr js in jt b ju li jw jx jy lj ka kb kc lk ke kf kg ll ki kj kk lm km kn ko ig bi translated">递归是一种编程技术，它涉及根据函数本身定义函数，允许函数一遍又一遍地重复特定的任务，直到满足某个条件。这个概念一开始看起来可能很混乱，但是通过一点实践和对底层逻辑的理解，你会发现递归可以成为解决复杂问题的强大工具。</p><p id="3ccb" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">所以，事不宜迟，让我们从探索递归的三个基本概念中的第一个开始我们的旅程:</p></div><div class="ab cl ln lo hr lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ig ih ii ij ik"><h2 id="d675" class="kp kq in bd kr ks kt dn ku kv kw dp kx kc ky kz la kg lb lc ld kk le lf lg lh bi translated">1.子集</h2><p id="b05e" class="pw-post-body-paragraph jr js in jt b ju li jw jx jy lj ka kb kc lk ke kf kg ll ki kj kk lm km kn ko ig bi translated">子集是组成更大集合的一组元素，在递归的上下文中，我们可以使用这个概念来生成集合中所有可能的元素组合。</p><p id="7053" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">例 1: </strong></p><p id="ebbf" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">输入:nums = [1，2，3，4] <br/>输出:<br/>[]<br/>【1】<br/>【2】<br/>【1，2】<br/>【3】<br/>【1，3】<br/>【2，3】<br/>【1，2，3】<br/>【4】<br/>【1，4】<br/>【2，4】<br/>【1，2，4】<br/>【3，4】<br/></p><p id="08bd" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">最重要的是，从输入和输出，我们需要可视化的树。一旦可视化完成，实现递归就非常容易了。<br/>例:【1，3】这里我们取了 1 和 3，而忽略了 2 和 4。</p><p id="062a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们遵循的过程是加工和未加工的方法。</p><h2 id="3035" class="kp kq in bd kr ks kt dn ku kv kw dp kx kc ky kz la kg lb lc ld kk le lf lg lh bi translated">加工和未加工方法</h2><ul class=""><li id="c92e" class="lu lv in jt b ju li jy lj kc lw kg lx kk ly ko lz ma mb mc bi translated">让我们来理解什么是加工过的方法和未加工的方法。这里，我们将有两个选择，要么接受一个元素，要么忽略该元素。</li><li id="6781" class="lu lv in jt b ju md jy me kc mf kg mg kk mh ko lz ma mb mc bi translated">下面的树显示了流程和取消流程方法是如何工作的</li></ul><figure class="mi mj mk ml gt jn gh gi paragraph-image"><div class="ab gu cl jo"><img src="../Images/df74d101bfb847080f98abf61b1d257c.png" data-original-src="https://miro.medium.com/v2/format:webp/1*oESrUuLUNxz90C9_-LumKA.png"/></div></figure><ul class=""><li id="eedf" class="lu lv in jt b ju jv jy jz kc mm kg mn kk mo ko lz ma mb mc bi translated">如果我们对[1，2，3，4]的给定输入应用这个过程和 unprocess 方法，那么递归树将看起来像这样</li></ul><figure class="mi mj mk ml gt jn gh gi paragraph-image"><div class="ab gu cl jo"><img src="../Images/59f9cf2b351bc7ffa37d7f90168040f6.png" data-original-src="https://miro.medium.com/v2/format:webp/1*X-hb6j7fJFg_UggvpLwsxg.png"/></div></figure><p id="11f1" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在，如果对生成的树进行中缀遍历，我们将得到所需的输出。</p><figure class="mi mj mk ml gt jn gh gi paragraph-image"><div class="ab gu cl jo"><img src="../Images/ee0cb1cf7aed6783a07aa7601595bb71.png" data-original-src="https://miro.medium.com/v2/format:webp/1*tmzpTSP6pyqj9U20mza4ZA.png"/></div></figure><p id="ec2e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">因此，我们由此推断出如下结论</p><ol class=""><li id="a7bd" class="lu lv in jt b ju jv jy jz kc mm kg mn kk mo ko mp ma mb mc bi translated">我们在每次函数调用时都需要打印语句。</li><li id="7c1e" class="lu lv in jt b ju md jy me kc mf kg mg kk mh ko mp ma mb mc bi translated">我们将遵循自顶向下的方法，基本条件在顶部，递归调用在底部。</li><li id="024a" class="lu lv in jt b ju md jy me kc mf kg mg kk mh ko mp ma mb mc bi translated">基本条件是当我们到达数组的末尾时，在我们的例子中是 4。</li></ol><pre class="mi mj mk ml gt mq mr ms mt aw mu bi"><span id="7ccf" class="kp kq in mr b gy mv mw l mx my">def subset(output, index):<br/>    #Print statement#<br/>    print(output)<br/>    <br/>    #Base condition#<br/>    if index == len(arr):<br/>        return<br/>    <br/>    #Recusive logic#<br/><br/>#Function calling#<br/>subset(output=[], index=0)</span></pre><p id="8362" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">所以，我们的第一个模板已经准备好了。</p><p id="ed70" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在，让我们演练并探索如何编写递归逻辑。<br/>为，此见树的横向形式。在第一次递归调用中，我们有[1，2，3，4]。</p><figure class="mi mj mk ml gt jn gh gi paragraph-image"><div class="ab gu cl jo"><img src="../Images/0e34273607fe2d0563816d88f9181085.png" data-original-src="https://miro.medium.com/v2/format:webp/1*-irkw6uy9_WCq5ANPpHJYw.png"/></div></figure><p id="4c22" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们怎么才能得到这个[1，2，3，4]？通过一个循环很简单。此外，您可以看到在空数组中有[1]、[2]、[3]、[4]。所以，这意味着我们在输出[]中添加了迭代器。之后，追加它，我们正在做一个递归调用。</p><p id="a337" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">记住，已处理和未处理规则说，如果我们添加了一些东西，那么在调用之后我们也需要删除它。所以在递归调用之后，我们将调用 list.pop()方法。代码将如下所示。</p><pre class="mi mj mk ml gt mq mr ms mt aw mu bi"><span id="5a7e" class="kp kq in mr b gy mv mw l mx my">arr = [1,2,3,4]<br/><br/>def subset(output, index):<br/>    #Print statement#<br/>    print(output)<br/>    <br/>    #Base condition#<br/>    if index == len(arr):<br/>        return<br/>    <br/>    #Recusive logic#<br/>    for i in range(index, len(arr)):<br/>        output.append(arr[i])<br/>        subset(output, i+1)<br/>        output.pop()<br/><br/>#Function calling#<br/>subset(output=[], index=0)</span><span id="7b61" class="kp kq in mr b gy mz mw l mx my">[]<br/>[1]<br/>[1, 2]<br/>[1, 2, 3]<br/>[1, 2, 3, 4]<br/>[1, 2, 4]<br/>[1, 3]<br/>[1, 3, 4]<br/>[1, 4]<br/>[2]<br/>[2, 3]<br/>[2, 3, 4]<br/>[2, 4]<br/>[3]<br/>[3, 4]<br/>[4]</span></pre><p id="e495" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在，假设我们想返回输出而不是打印。不要忘记重要的一点，在 python 中，一切都是通过引用传递的。所以我们需要使用 copy.copy()。如下图所示:</p><pre class="mi mj mk ml gt mq mr ms mt aw mu bi"><span id="aa75" class="kp kq in mr b gy mv mw l mx my">class Solution:<br/>    def subsets(self, nums: List[int]) -&gt; List[List[int]]:<br/>        final_output = []<br/>        def sub(output, index):<br/>            #Print statement#<br/>            final_output.append(copy.copy(output))<br/><br/>            #Base condition#<br/>            if index == len(nums):<br/>                return<br/><br/>            #Recusive logic#<br/>            for i in range(index, len(nums)):<br/>                output.append(nums[i])<br/>                sub(output, i+1)<br/>                output.pop()<br/><br/>        #Function calling#<br/>        sub(output=[], index=0)<br/>        return final_output</span></pre><p id="c16a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">当通过 leetcode 提交时，我们的方法在时间和空间复杂度上快了 80%:</p><figure class="mi mj mk ml gt jn gh gi paragraph-image"><div class="ab gu cl jo"><img src="../Images/d4c23359e35bfd02e150f5d26b1cc34a.png" data-original-src="https://miro.medium.com/v2/format:webp/1*ENu94F4D0VfXFRSpnKgGqQ.png"/></div></figure><h2 id="3204" class="kp kq in bd kr ks kt dn ku kv kw dp kx kc ky kz la kg lb lc ld kk le lf lg lh bi translated">时间复杂度分析:</h2><ul class=""><li id="97fa" class="lu lv in jt b ju li jy lj kc lw kg lx kk ly ko lz ma mb mc bi translated">在这里，这个函数是一个递减函数，即对于每个调用，我们在 for 循环中缩小搜索范围。</li><li id="d60f" class="lu lv in jt b ju md jy me kc mf kg mg kk mh ko lz ma mb mc bi translated">所以递归关系不会只看代码就直接形成。我们需要看到形成的树的深度。</li><li id="b246" class="lu lv in jt b ju md jy me kc mf kg mg kk mh ko lz ma mb mc bi translated">下面显示了每一步执行的递归调用的数量。</li></ul><figure class="mi mj mk ml gt jn gh gi paragraph-image"><div class="ab gu cl jo"><img src="../Images/1d1dbe0d4e4f2d7fafe40c23d8ef2bbc.png" data-original-src="https://miro.medium.com/v2/format:webp/1*KO1_NRdz4qwW51_ZzU-bkQ.png"/></div></figure><ul class=""><li id="53a3" class="lu lv in jt b ju jv jy jz kc mm kg mn kk mo ko lz ma mb mc bi translated">递归调用的总数= 15 = 2^n-1。因此，时间复杂度是 O(2^n).</li></ul><p id="5ac3" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">给定代码的递归关系可以表示如下:</p><pre class="mi mj mk ml gt mq mr ms mt aw mu bi"><span id="1c2a" class="kp kq in mr b gy mv mw l mx my">T(n) = 2 * T(n-1) + O(1)</span></pre><p id="95bc" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">其中，<code class="fe na nb nc mr b">T(n)</code>是输入列表大小为<code class="fe na nb nc mr b">n</code>的函数的运行时间，<code class="fe na nb nc mr b">O(1)</code>表示执行循环中的基本情况和代码所需的恒定时间。</p><p id="4b05" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这种递归关系可以通过分析递归函数调用的次数来导出。每个递归调用处理一个更小版本的输入列表，由于输入列表的长度是固定的<code class="fe na nb nc mr b">n</code>，递归调用的次数将受到 2 的幂的限制。具体来说，该函数将进行<code class="fe na nb nc mr b">2^n</code>递归调用，因为每个调用处理输入列表的一个子集，并且有<code class="fe na nb nc mr b">2^n</code>个大小为<code class="fe na nb nc mr b">n</code>的列表的可能子集。</p><p id="d58f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">使用替换法可以进一步简化递归关系:</p><pre class="mi mj mk ml gt mq mr ms mt aw mu bi"><span id="9490" class="kp kq in mr b gy mv mw l mx my">T(n) = 2 * T(n-1) + O(1)<br/>  = 2 * (2 * T(n-2) + O(1)) + O(1)<br/>  = 2^2 * T(n-2) + 2 * O(1) + O(1)<br/>  = 2^2 * (2 * T(n-3) + O(1)) + 2 * O(1) + O(1)<br/>  = 2^3 * T(n-3) + 3 * O(1)<br/>  ...<br/>  = 2^n * T(0) + n * O(1)<br/>  = 2^n * O(1) + n * O(1)<br/>  = O(2^n)</span></pre></div><div class="ab cl ln lo hr lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ig ih ii ij ik"><h2 id="9a7b" class="kp kq in bd kr ks kt dn ku kv kw dp kx kc ky kz la kg lb lc ld kk le lf lg lh bi translated">2.排列</h2><p id="b133" class="pw-post-body-paragraph jr js in jt b ju li jw jx jy lj ka kb kc lk ke kf kg ll ki kj kk lm km kn ko ig bi translated">排列，是一组元素按特定顺序的排列。使用递归，我们可以生成给定集合的所有可能的排列，允许我们以特定的顺序检查元素的每个可能的组合。</p><p id="b3cc" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">例如，给定一组元素{1，2，3}，一些可能的排列是:</p><p id="e351" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">输入:[1，2，3] <br/>输出:[[1，2，3]，[1，3，2]，[2，1，3]，[2，3，1]，[3，1，2]，[3，2，1]</p><p id="18ec" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">输入:[1，2] <br/>输出:[[1，2]，[2，1]]</p><p id="2163" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">从上面的例子中，如果你考虑[1，2，3]，[2，1，3]，[2，3，1]，那么在这个例子中，1 是逐步移动的。因此，我们将使用这种逻辑，并建立递归树。</p><figure class="mi mj mk ml gt jn gh gi paragraph-image"><div class="ab gu cl jo"><img src="../Images/f01b1e257835bf1f87d5e43e3244fc72.png" data-original-src="https://miro.medium.com/v2/format:webp/1*6kOKDtqBI7ZdwsMWuDd-zg.png"/></div></figure><p id="d047" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">因此由此我们得出以下结论:</p><ol class=""><li id="b712" class="lu lv in jt b ju jv jy jz kc mm kg mn kk mo ko mp ma mb mc bi translated">输出是在基本条件下获得的。</li><li id="b98e" class="lu lv in jt b ju md jy me kc mf kg mg kk mh ko mp ma mb mc bi translated">基本条件是当索引到达末尾时</li></ol><pre class="mi mj mk ml gt mq mr ms mt aw mu bi"><span id="e6fa" class="kp kq in mr b gy mv mw l mx my">def permute(output, index):<br/>    <br/>    #Base Condition#<br/>    if index == len(arr):<br/>        print(output)<br/>        return<br/>    #Recursive function#<br/>    <br/>permute(arr[0],0)</span></pre><p id="93b0" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在，让我们演练并探索如何编写递归逻辑。因为，这看到了树的横向形式。在第一次递归调用中，我们有[1，2]和[2，1]。因此，我们迭代 n+1 项并插入元素。</p><figure class="mi mj mk ml gt jn gh gi paragraph-image"><div class="ab gu cl jo"><img src="../Images/4e65b0b1ef0b777c4c9e886798ef534c.png" data-original-src="https://miro.medium.com/v2/format:webp/1*eTs4hpw2WDO2hYogFHdMoA.png"/></div></figure><p id="d60a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如前所述，我们遵循已处理和未处理的方法，我们将删除插入的元素。</p><pre class="mi mj mk ml gt mq mr ms mt aw mu bi"><span id="4efb" class="kp kq in mr b gy mv mw l mx my">arr = [1,2,3]<br/>def permute(output, index):<br/><br/>    #Base Condition#<br/>    if index == len(arr):<br/>        print(output)<br/>        return<br/>        <br/>    #Recursive function#<br/>    for iter_ in range(len(output)+1):<br/>        output.insert(iter_,arr[index])<br/>        permute(output,index+1)<br/>        output.pop(iter_)<br/>    <br/>permute([arr[0]],1) #Start from 1 and not from empty@</span><span id="3958" class="kp kq in mr b gy mz mw l mx my">[3, 2, 1]<br/>[2, 3, 1]<br/>[2, 1, 3]<br/>[3, 1, 2]<br/>[1, 3, 2]<br/>[1, 2, 3]</span></pre><h2 id="55f1" class="kp kq in bd kr ks kt dn ku kv kw dp kx kc ky kz la kg lb lc ld kk le lf lg lh bi translated">分析代码的时间复杂度</h2><ul class=""><li id="06e3" class="lu lv in jt b ju li jy lj kc lw kg lx kk ly ko lz ma mb mc bi translated">这个码的递归关系是 T(n) = n*T(n-1)。因为我们在做 n 次迭代，调用 n-1 个函数。求解该递推关系的方法如下:</li></ul><figure class="mi mj mk ml gt jn gh gi paragraph-image"><div class="ab gu cl jo"><img src="../Images/b265a60e405d401f82daa1419cc0a9c6.png" data-original-src="https://miro.medium.com/v2/format:webp/1*fiYgMR76egwpyCUavzqVuQ.png"/></div></figure><p id="f5ac" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">因此总的时间复杂度是 O(n！)</p></div><div class="ab cl ln lo hr lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ig ih ii ij ik"><h2 id="7b82" class="kp kq in bd kr ks kt dn ku kv kw dp kx kc ky kz la kg lb lc ld kk le lf lg lh bi translated">组合</h2><p id="92ef" class="pw-post-body-paragraph jr js in jt b ju li jw jx jy lj ka kb kc lk ke kf kg ll ki kj kk lm km kn ko ig bi translated">组合，是从一个较大的集合中选择的元素组，不考虑顺序。通过使用递归，我们可以在一个集合中生成所有可能的元素组合，让我们全面了解元素组合的各种方式。</p><p id="3ead" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">示例:<br/>输入:n=4，k=3</p><p id="f12f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">输出:<br/> (1，2，3) (1，2，4) (1，3，4) (2，3，4)</p><p id="4792" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">通过使用已处理和未处理的方法，递归树将形成如下:</p><figure class="mi mj mk ml gt jn gh gi paragraph-image"><div class="ab gu cl jo"><img src="../Images/622a74231e034c0af0ff2cec47a37237.png" data-original-src="https://miro.medium.com/v2/format:webp/1*WlTe0tXWLGfyxRk48bQKTg.png"/></div></figure><p id="50e1" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">从递归树中获得的结论:</p><ol class=""><li id="b37d" class="lu lv in jt b ju jv jy jz kc mm kg mn kk mo ko mp ma mb mc bi translated">当我们到达最后一个索引时，应用基本条件</li><li id="a8ef" class="lu lv in jt b ju md jy me kc mf kg mg kk mh ko mp ma mb mc bi translated">当到达递归树的第 k 个深度时，我们打印输出</li></ol><pre class="mi mj mk ml gt mq mr ms mt aw mu bi"><span id="a03e" class="kp kq in mr b gy mv mw l mx my">def combination(output, index, depth):<br/>    <br/>    #Base Condition#<br/>    if index == len(arr):<br/>        return<br/>    if depth == k:<br/>        print(output)<br/>        return<br/>    <br/>    #Recursive Call#</span></pre><p id="26e0" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在，应用递归的逻辑，看看树呼吸的形式。<br/>所以，如你所见，我们对每个数组元素进行迭代，然后执行递归调用。</p><pre class="mi mj mk ml gt mq mr ms mt aw mu bi"><span id="46a0" class="kp kq in mr b gy mv mw l mx my">n = 4<br/>k = 3<br/>arr = [i for i in range(1,n+1)]<br/>def combination(output, index, depth):<br/>    <br/>    #Base Condition#<br/>    if index == len(arr)+1:<br/>        return<br/>    if depth == k:<br/>        print(output)<br/>        return<br/>    <br/>    #Recursive Call#<br/>    for i in range(index,len(arr)):<br/>        output.append(arr[i])<br/>        combination(output,i+1,depth+1)<br/>        output.pop()<br/><br/>combination([],0,0)</span><span id="bcf3" class="kp kq in mr b gy mz mw l mx my">[1, 2, 3]<br/>[1, 2, 4]<br/>[1, 3, 4]<br/>[2, 3, 4]</span></pre><p id="084b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这个码的递归关系是 T(n) = n*T(n-1，k-1)。因为我们在减少深度的同时也在减少迭代的次数。它将按如下方式解决:</p><p id="0f1b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">T(n，k) = n * T(n-1，k-1) <br/> = n * (n-1) * T(n-2，k-2) <br/> = n * (n-1) * (n-2) * T(n-3，k-3)<br/>=…<br/>= n *(n-1)*(n-2)*…*(n-k+1)</p><p id="8cf4" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在，解决这个序列有点棘手！！！让我们一步一步来看</p><p id="6593" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">一个简单的 n！=(n)<em class="nd">(n-1)</em>(n-2)<em class="nd">…</em>(n-k+1)<em class="nd">(n-k)</em>(n-k-1)<em class="nd">…32</em>1<br/>反之，(n-k)！=(𝑛−𝑘)<em class="nd">(𝑛−𝑘−1)</em>(𝑛−𝑘−2)<em class="nd">…32</em>1</p><p id="ea38" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果你仔细看，然后<br/> 𝑛！=𝑛(𝑛−1)(𝑛−2)⋯(𝑛−𝑘+1)⋅(𝑛−𝑘)!</p><p id="c809" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">因此，𝑛！/(𝑛−𝑘)!=𝑛(𝑛−1)(𝑛−2)⋯(𝑛−𝑘+1).</p><p id="e378" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">表达式 n！/(n-k)！等于 O(n^k)，因为随着 n 的增加，它的增长率与 n^k 的增长率相同。</p><p id="9f29" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">要了解这种情况的原因，请考虑以下因素:</p><ul class=""><li id="c66d" class="lu lv in jt b ju jv jy jz kc mm kg mn kk mo ko lz ma mb mc bi translated">当 n = k 时，表达式 n！/(n-k)！= k！/(k-k)！= k！/0!= k^k</li><li id="f5b0" class="lu lv in jt b ju md jy me kc mf kg mg kk mh ko lz ma mb mc bi translated">当 n = k+1 时，表达式 n！/(n-k)！= (k+1)！/(k+1-k)！= (k+1)！/1!= (k+1)^k</li><li id="cd78" class="lu lv in jt b ju md jy me kc mf kg mg kk mh ko lz ma mb mc bi translated">当 n = k+2 时，表达式 n！/(n-k)！= (k+2)！/(k+2-k)！= (k+2)！/2!= (k+2)^k</li><li id="abe4" class="lu lv in jt b ju md jy me kc mf kg mg kk mh ko lz ma mb mc bi">…</li></ul><p id="a374" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">可以看到，表达式 n！/(n-k)！随着 n 的增加，以与 n^k 相同的速度增长。这意味着这段代码的时间复杂度是 O(n^k).</p><p id="6ce2" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">需要注意的是，表达式 n！/(n-k)！是时间复杂度的上限，这意味着实际的时间复杂度可以更低。然而，它对代码的时间复杂度提供了一个很好的估计。</p></div><div class="ab cl ln lo hr lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ig ih ii ij ik"><p id="8d0e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><em class="nd">感谢你阅读我的文章</em></p><p id="eca7" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">普里图尔·戴夫(<a class="ae ne" href="http://linktr.ee/prituldave" rel="noopener ugc nofollow" target="_blank">http://linktr.ee/prituldave</a>)</p></div></div>    
</body>
</html>