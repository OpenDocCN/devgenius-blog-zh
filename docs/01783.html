<html>
<head>
<title>JavaScript Best Practices — Classes and Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript 最佳实践—类和类型</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/javascript-best-practices-classes-and-types-4f43c91938cf?source=collection_archive---------23-----------------------#2020-07-11">https://blog.devgenius.io/javascript-best-practices-classes-and-types-4f43c91938cf?source=collection_archive---------23-----------------------#2020-07-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/98c4d22c6be7ad7e8d7b5141cb68cb1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9GYaESzN5zBj1jNW"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@anyadiary?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Waranya Mooldee </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="ab28" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使代码易于阅读和维护，我们应该遵循一些最佳实践。</p><p id="0f90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将看看我们应该遵循的一些最佳实践，以使每个人的生活更轻松。</p><h1 id="de04" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">类型检查</h1><p id="4b1b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以编写一致的 API 来避免类型检查。</p><p id="c738" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8319" class="mn lc iq mj b gy mo mp l mq mr">function travelToNewYork(vehicle) {<br/>  if (vehicle instanceof Airplane) {<br/>    vehicle.fly(this.currentLocation, 'new york');<br/>  } else if (vehicle instanceof Car) {<br/>    vehicle.drive(this.currentLocation, 'new york');<br/>  }<br/>}</span></pre><p id="41c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a0b6" class="mn lc iq mj b gy mo mp l mq mr">function travelToNewYork(vehicle) {<br/>  vehicle.move(this.currentLocation, 'new york');<br/>}</span></pre><p id="c4ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一个<code class="fe ms mt mu mj b">move</code>方法，而不是<code class="fe ms mt mu mj b">fly</code>和<code class="fe ms mt mu mj b">drive</code>方法。</p><h1 id="bbcc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用方法链接</h1><p id="2ad6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以在我们的方法中返回<code class="fe ms mt mu mj b">this</code>来使慈善。</p><p id="0db7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="696e" class="mn lc iq mj b gy mo mp l mq mr">class Cube {<br/>  constructor(length, width, height) {<br/>    this.length = length;<br/>    this.width = width;<br/>    this.height = height;<br/>  }<br/><br/>  setHeight(height) {<br/>    this.height = height;<br/>  }<br/><br/>  setLength(length) {<br/>    this.length = length;<br/>  }<br/><br/>  setWidth(width) {<br/>    this.width = width;<br/>  }<br/><br/>  save() {<br/>    console.log(this.height, this.length, this.width);<br/>  }<br/>}</span></pre><p id="4ba7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="420e" class="mn lc iq mj b gy mo mp l mq mr">class Cube {<br/>  constructor(length, width, height) {<br/>    this.length = length;<br/>    this.width = width;<br/>    this.height = height;<br/>  }<br/><br/>  setHeight(height) {<br/>    this.height = height;<br/>    return this<br/>  }<br/><br/>  setLength(length) {<br/>    this.length = length;<br/>    return this;<br/>  }<br/><br/>  setWidth(width) {<br/>    this.width = width;<br/>    return this;<br/>  }<br/><br/>  save() {<br/>    console.log(this.make, this.model, this.color);<br/>    return this;<br/>  }<br/>}</span></pre><p id="bb95" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过写来使用它:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7f02" class="mn lc iq mj b gy mo mp l mq mr">new Cube(1, 2, 3).setWidth(2).setLength(4).setHeight(6);</span></pre><h1 id="a69e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">继承之上的组合</h1><p id="9b7d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该构造类而不是继承它们。</p><p id="a778" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">子类没有组合类灵活。</p><p id="c5e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2e15" class="mn lc iq mj b gy mo mp l mq mr">class Employee {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }<br/><br/>  // ...<br/>}<br/><br/>class EmployeePayrollData extends Employee {<br/>  constructor(salary) {<br/>    super();<br/>    this.salary = salary;<br/>  }<br/><br/>  // ...<br/>}</span></pre><p id="2bbd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">EmployeePayrollData</code>不需要<code class="fe ms mt mu mj b">Employee</code>的内容，所以不应该写这个。</p><p id="0ce8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3762" class="mn lc iq mj b gy mo mp l mq mr">class EmployeePayrollData {<br/>  constructor(salary) {<br/>    super();<br/>    this.salary = salary;<br/>  }<br/><br/>  // ...<br/>}</span><span id="36d9" class="mn lc iq mj b gy mv mp l mq mr">class Employee {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }<br/><br/>  setPayrollData(data){<br/>    this.payrollData = new EmployeePayrollData(data);<br/>  }<br/>}</span></pre><p id="fbf3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这两个类之间没有关系，所以不需要<code class="fe ms mt mu mj b">extends</code>。</p><p id="4fc0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只是在我们喜欢的地方使用它们。</p><h1 id="6c3f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">单一责任原则</h1><p id="2846" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">每个类都应该有一个单一的责任。</p><p id="72ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们的<code class="fe ms mt mu mj b">Employee</code>类只保存员工数据并执行员工操作:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="cb0d" class="mn lc iq mj b gy mo mp l mq mr">class Employee {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }<br/><br/>  //...<br/>}</span></pre><p id="8ab0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想添加与员工无关的功能，那么就把它们放在别的地方。</p><h1 id="4796" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">开/关原则</h1><p id="14a7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">开放/封闭原则意味着一段代码对于扩展是开放的，对于修改是封闭的。</p><p id="63c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着我们应该能够在不改变现有代码的情况下添加新功能。</p><p id="9f01" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建子类是添加功能的好方法:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5bab" class="mn lc iq mj b gy mo mp l mq mr">class HttpRequester {<br/>  constructor(adapter) {<br/>    this.adapter = adapter;<br/>  }<br/><br/>  fetch(url) {<br/>    return this<br/>      .adapter<br/>      .request(url)<br/>      .then(response =&gt; {<br/>        // ...<br/>      });<br/>  }<br/>}</span><span id="cc4e" class="mn lc iq mj b gy mv mp l mq mr">class NodeRequester extends HttpRequester{<br/>  constructor() {<br/>    super();<br/>  }<br/><br/>  request(url) {<br/>    // do node request<br/>  }<br/>}<br/><br/>class AjaxRequester extends HttpRequester {<br/>  constructor() {<br/>    super();<br/>    this.name = "nodeAdapter";<br/>  }<br/><br/>  request(url) {<br/>    // do ajax request<br/>  }<br/>}</span></pre><h1 id="b3fc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">利斯科夫替代原理</h1><p id="f352" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Liskov 替换原则指出，我们应该能够用子类替换父类，并获得相同的结果。</p><p id="af8e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着我们将共享代码保存在父类中。</p><p id="b259" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="930a" class="mn lc iq mj b gy mo mp l mq mr">class Rectangle {<br/>  constructor() {<br/>    this.width = 0;<br/>    this.height = 0;<br/>  }<br/><br/>  setWidth(width) {<br/>    this.width = width;<br/>  }<br/><br/>  setHeight(height) {<br/>    this.height = height;<br/>  }<br/><br/>  getArea() {<br/>    return this.width * this.height;<br/>  }<br/>}<br/><br/>class Square extends Rectangle {<br/>  setWidth(width) {<br/>    this.width = width;<br/>    this.height = width;<br/>  }<br/><br/>  setHeight(height) {<br/>    this.width = height;<br/>    this.height = height;<br/>  }</span><span id="91c5" class="mn lc iq mj b gy mv mp l mq mr">  getArea() {<br/>    return this.width * this.height;<br/>  }<br/>}</span></pre><p id="eaa0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有<code class="fe ms mt mu mj b">Rectangle</code>类，它有与<code class="fe ms mt mu mj b">Square</code>类相同的方法。</p><p id="9da1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们共享相同的计算。</p><p id="2d43" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">唯一的区别是正方形的宽度和高度是一样的。</p><p id="0e63" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用一个<code class="fe ms mt mu mj b">Square</code>实例替换一个<code class="fe ms mt mu mj b">Rectangle</code>，并且仍然设置宽度和高度并获得面积。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/4a08a90ec6f655b2f9a4dacccd580b06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Bl42YZg_yOB2NUy8"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@zamax?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">古斯塔沃·赞贝利</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><h1 id="5fab" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="5b2d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该使我们的 API 一致，以避免类型检查。</p><p id="9279" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在类方法中返回<code class="fe ms mt mu mj b">this</code>,使它们可以链接。</p><p id="16f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类应该有一个单一的职责，子类应该能够被用来代替父类。</p></div></div>    
</body>
</html>