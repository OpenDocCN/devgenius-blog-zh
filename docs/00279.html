<html>
<head>
<title>SwiftUI Menu Widget (easy to customize &amp; integrate)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI菜单小部件(易于定制和集成)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/swiftui-menu-widget-easy-to-customize-integrate-75a36f067d83?source=collection_archive---------9-----------------------#2020-05-29">https://blog.devgenius.io/swiftui-menu-widget-easy-to-customize-integrate-75a36f067d83?source=collection_archive---------9-----------------------#2020-05-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ee32b9d60ae54e59ce20314e463189a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NIFjuB6N8F3QoMBN_GjprA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">带有菜单部件的主屏幕。</figcaption></figure><p id="37e5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我厌倦了在应用程序中看到和使用相同的标签视图导航，所以我创建了一个菜单小部件，它稍微混合了导航，但没有使它过于复杂或混乱。本教程概述了我如何从零开始创建它，以及如何将它轻松集成到你的iOS应用程序中。虽然它是在SwiftUI中构建的，但有一些方法可以将其与UIKit视图集成(稍后将提供教程)。如果你只是想要成品，这里有<a class="ae kx" href="https://github.com/mgipson/MenuWidget/tree/master/MenuWidget" rel="noopener ugc nofollow" target="_blank"> GitHub回购</a>。</p><h1 id="d173" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">从头开始</h1><p id="7329" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">让我们开始吧，从一个空白的单视图App XCode项目开始。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mb"><img src="../Images/1f382ea9ad8eb6e51399a72445465ca9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6wljNvzmQ5GSgM38o6N_bw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">使用SwiftUI，不要包含测试。</figcaption></figure><p id="e959" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">创建后，将ContentView.swift重命名为ViewController.swift在该文件和SceneDelegate.swift中将有几个实例，您需要将ContentView更改为ViewController。你不需要<em class="mg">重命名，我只是发现它有助于在更大的项目中保持事物的直线。</em></p><p id="fb19" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">因为这是从头开始的，我们需要添加一些SwiftUI文件，这些文件将是我们要显示的不同视图。我创建了ViewA、ViewB、ViewC每个视图都有一行简单的文本，其中包含它们的视图名称。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mh"><img src="../Images/fa971d4fdacbf0440c7a3c46db82c98d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_NmxggVqCXJunHTivT9slw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">显示视图a。为了简单起见，在ViewB和ViewC中也做了同样的工作。</figcaption></figure><p id="ebb7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">回到ViewController，我删除了PreviewProvider，因为我通常只使用模拟器进行测试，并添加了以下内容，这导致了一个中间有“视图A”的纯白屏幕。</p><pre class="mc md me mf gt mi mj mk ml aw mm bi"><span id="6a64" class="mn kz in mj b gy mo mp l mq mr">struct ViewController: View { <br/> <strong class="mj io">@State var page:String = "ViewA" </strong><br/>  var body: some View { <br/>   <strong class="mj io">VStack { <br/>    if page == "ViewA" { ViewA() } <br/>    if page == "ViewB" { ViewB() } <br/>    if page == "ViewC" { ViewC() } <br/>   } //end of page vstack </strong><br/>  } //end of view <br/>} //end of struct</span></pre><h1 id="a3f2" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">切换屏幕</h1><p id="07d9" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">还没有办法在屏幕之间切换，所以这是我们接下来要添加的。在下面的代码片段中，实现了以下内容:</p><ul class=""><li id="e5b2" class="ms mt in kb b kc kd kg kh kk mu ko mv ks mw kw mx my mz na bi translated">设置屏幕大小和图标大小(相对于屏幕大小设置图标大小以进行缩放)。</li><li id="6e68" class="ms mt in kb b kc nb kg nc kk nd ko ne ks nf kw mx my mz na bi translated">在页面VStack下面，我们添加了一个ZStack，它包含了一个按钮的v stack；在ZStack中嵌套VStack似乎是多余的，但是带有。如果只应用于按钮VStack，bottomTrailing对齐(菜单放置在右下角而不是屏幕中心默认位置时需要)不会有相同的效果。</li><li id="0a13" class="ms mt in kb b kc nb kg nc kk nd ko ne ks nf kw mx my mz na bi translated">将页面和按钮堆栈组合在一个ZStack中，使按钮层叠在页面上。</li></ul><pre class="mc md me mf gt mi mj mk ml aw mm bi"><span id="b156" class="mn kz in mj b gy mo mp l mq mr">struct ViewController: View {<br/> @State var page:String = "ViewA"<br/> <strong class="mj io">let screenSize = UIScreen.main.bounds<br/> let iconSize = UIScreen.main.bounds.width*0.07</strong><br/> <br/> var body: some View {<br/> <strong class="mj io"> ZStack {</strong><br/>   VStack {<br/>    if page == "ViewA" { ViewA() }<br/>    if page == "ViewB" { ViewB() }<br/>    if page == "ViewC" { ViewC() }<br/>   } //end of page vstack<br/>   <strong class="mj io">ZStack {<br/>    VStack {<br/>     Button(action: { self.page = "ViewA" }) <br/>     {<br/>      Image(systemName: "a.circle.fill").resizable().frame(width: iconSize, height: iconSize)<br/>     }<br/>     Button(action: { self.page = "ViewB" }) <br/>     {<br/>      Image(systemName: "b.circle.fill").resizable().frame(width: iconSize, height: iconSize)<br/>     }<br/>     Button(action: { self.page = "ViewC" }) <br/>     {<br/>      Image(systemName: "c.circle.fill").resizable().frame(width: iconSize, height: iconSize)<br/>     }<br/>    }.padding([.all]) //end of button vstack<br/>   }.frame(width: screenSize.width, height: screenSize.height, alignment: .bottomTrailing) //end of button zstack</strong><br/>  <strong class="mj io">} //end of view zstack</strong><br/> } //end of view<br/>} //end of struct</span></pre><figure class="mc md me mf gt jo gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/d7bcf33eed2d3b50bb4df0689a313e6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:448/1*zD-_Gqycz-6LaMzTeMNmhA.gif"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">成功！</figcaption></figure><h1 id="c043" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">功能性！=使用起来很有趣</h1><p id="6e8c" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">酷，切换屏幕工作！但是在它实际可用之前，还有几个问题需要解决。</p><ul class=""><li id="02fd" class="ms mt in kb b kc kd kg kh kk mu ko mv ks mw kw mx my mz na bi translated">正确定位屏幕上的菜单</li><li id="6e8f" class="ms mt in kb b kc nb kg nc kk nd ko ne ks nf kw mx my mz na bi translated">给按钮样式改头换面</li><li id="60a3" class="ms mt in kb b kc nb kg nc kk nd ko ne ks nf kw mx my mz na bi translated">添加一个“触发器”来展开和折叠菜单，这样我们就不会经常看到所有的按钮(会妨碍背景屏幕)</li></ul><h2 id="606f" class="mn kz in bd la nh ni dn le nj nk dp li kk nl nm lm ko nn no lq ks np nq lu nr bi translated">按钮样式</h2><p id="f87c" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">我们可以通过创建一个按钮样式来一石二鸟(在这个例子中，我坚持使用非常简单的东西，但是它演示了如何创建一个可重用的、统一的按钮样式)。在ViewController结构上方，添加:</p><pre class="mc md me mf gt mi mj mk ml aw mm bi"><span id="4aa7" class="mn kz in mj b gy mo mp l mq mr">struct PageButtonStyle: ButtonStyle { <br/> let buttonSize = UIScreen.main.bounds.width*0.12 <br/> func makeBody(configuration: Self.Configuration) -&gt; some View { <br/>  return configuration.label <br/>   .foregroundColor(Color.white) <br/>   .frame(width: buttonSize, height: buttonSize) <br/>   .background(Color.green) <br/>   .scaleEffect(configuration.isPressed ? 0.9 : 1.0) <br/> } <br/>}</span></pre><p id="6565" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在将按钮样式附加到VStack中的每个按钮，如下所示:</p><pre class="mc md me mf gt mi mj mk ml aw mm bi"><span id="d991" class="mn kz in mj b gy mo mp l mq mr">Button(action: { self.page = "ViewA" }) <br/>{ <br/> Image(systemName: "a.circle.fill").resizable().frame(width: iconSize, height: iconSize) }<strong class="mj io">.buttonStyle(PageButtonStyle()).cornerRadius(15)</strong></span></pre><h2 id="33ac" class="mn kz in bd la nh ni dn le nj nk dp li kk nl nm lm ko nn no lq ks np nq lu nr bi translated">展开和折叠</h2><p id="6b4e" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">这要怎么做？让我们考虑清楚。</p><p id="4405" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果我们在一个屏幕上，菜单部件应该是一个按钮，其图标与当前屏幕匹配。当我们点击它时，它应该会展开并显示菜单中的所有按钮，而有当前屏幕图标的按钮应该会变成一个向上的箭头，显示菜单已展开。当点击菜单中的一个按钮时，屏幕就会切换。菜单应该只在点击箭头按钮时折叠，箭头按钮应该恢复显示当前屏幕的图标。</p><p id="ac60" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">来实施吧！</p><p id="f69b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在现有变量下，添加<code class="fe ns nt nu mj b">expand</code>(表示菜单是否应该展开)和<code class="fe ns nt nu mj b">icon</code>(表示当前屏幕的图标)。</p><pre class="mc md me mf gt mi mj mk ml aw mm bi"><span id="e5c1" class="mn kz in mj b gy mo mp l mq mr">struct ViewController: View {<br/> @State var page:String = "ViewA"<br/> let screenSize = UIScreen.main.bounds<br/> let iconSize = UIScreen.main.bounds.width*0.07<br/><strong class="mj io"> @State var expand:Bool = false<br/> @State var icon:String = "a.circle.fill"</strong></span></pre><p id="14bf" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在button VStack中，在所有现有按钮周围添加一个if语句；当<code class="fe ns nt nu mj b">expand</code>为真时将显示所有按钮，为假时仅显示当前屏幕的按钮。在if语句下面，添加另一个按钮；这将是当前屏幕/箭头按钮，应该一直显示。在每个按钮动作中，给<code class="fe ns nt nu mj b">icon</code>添加一个与页面对应的变量赋值；这用于当前屏幕按钮。</p><pre class="mc md me mf gt mi mj mk ml aw mm bi"><span id="235e" class="mn kz in mj b gy mo mp l mq mr">VStack { <br/> <strong class="mj io">if expand { </strong><br/>   Button(action: { <br/>   self.page = "ViewA" <br/>   <strong class="mj io">self.icon = "a.circle.fill" </strong><br/>  }) { <br/>   Image(systemName: "a.circle.fill").resizable().frame(width: iconSize, height: iconSize) <br/>  }.buttonStyle(PageButtonStyle()).cornerRadius(15) </span><span id="7fec" class="mn kz in mj b gy nv mp l mq mr">  Button(action: { <br/>   self.page = "ViewB" <br/>   <strong class="mj io">self.icon = "b.circle.fill" </strong><br/>  }) { <br/>   Image(systemName: "b.circle.fill").resizable().frame(width: iconSize, height: iconSize) <br/>  }.buttonStyle(PageButtonStyle()).cornerRadius(15) </span><span id="82b7" class="mn kz in mj b gy nv mp l mq mr">  Button(action: { <br/>   self.page = "ViewC" <br/>   <strong class="mj io">self.icon = "c.circle.fill" </strong><br/>  }) { <br/>   Image(systemName: "c.circle.fill").resizable().frame(width: iconSize, height: iconSize) <br/>  }.buttonStyle(PageButtonStyle()).cornerRadius(15) <br/> <strong class="mj io">} //end of if statement</strong><br/>  <br/>  <strong class="mj io">//Arrow/Current Screen <br/>  Button(action: { <br/>   self.expand.toggle() <br/>  }) { <br/>   Image(systemName: expand ? "chevron.up" : icon).resizable().frame(width: iconSize, height: expand ? iconSize/3 : iconSize) <br/>  }.buttonStyle(PageButtonStyle()).cornerRadius(15) </strong><br/>}.padding([.all]) //end of button vstack</span></pre><p id="8274" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在“箭头/当前屏幕”按钮上，我们添加了一个切换<code class="fe ns nt nu mj b">expand</code>的动作，指示菜单是否应该展开/折叠。对于图标，如果菜单被展开，我们显示人字形箭头，如果没有展开，则显示<code class="fe ns nt nu mj b">icon</code>(无论设置为什么值)(使用一个方便的三元运算符)。此外，我们希望人字形箭头是成比例的，所以如果那是按钮图标(当<code class="fe ns nt nu mj b">expand</code>为真时就会是)，那么缩小高度(使用三元运算符完成…它们是最好的！).</p><h2 id="9710" class="mn kz in bd la nh ni dn le nj nk dp li kk nl nm lm ko nn no lq ks np nq lu nr bi translated">比以前更好</h2><p id="9254" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">开始了。更好的按钮设计，在屏幕上适当的定位，以及一个展开/折叠菜单。就快好了。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/a1c14eb45729fbe210d1c120b6e73206.png" data-original-src="https://miro.medium.com/v2/resize:fit:448/1*lgyVYZV4XbCx4bmZSNIz7A.gif"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">屏幕切换，好的按钮设计，好的菜单定位，菜单展开和折叠。</figcaption></figure><h1 id="a70d" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">普通的简得到了升级</h1><p id="8942" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">这看起来不错，但仍然是一种气泡。如果有一些动画和手势会更好，你不觉得吗？</p><h2 id="6b08" class="mn kz in bd la nh ni dn le nj nk dp li kk nl nm lm ko nn no lq ks np nq lu nr bi translated">动画</h2><p id="7796" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">这太简单了，你不会相信的。</p><p id="c485" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我希望人字形箭头在被点击时收缩和伸展，菜单在展开和折叠时淡入淡出。只需将<code class="fe ns nt nu mj b">.animation(.spring())</code>追加到人字形按钮和按钮VStack。</p><pre class="mc md me mf gt mi mj mk ml aw mm bi"><span id="b94b" class="mn kz in mj b gy mo mp l mq mr">...<br/> //Chevron/Current Screen<br/> Button(action: {<br/>  self.expand.toggle() <br/> }) {<br/>  Image(systemName: expand ? "chevron.up" : icon).resizable().frame(width: iconSize, height: expand ? iconSize/3 : iconSize)<br/> }.buttonStyle(PageButtonStyle()).cornerRadius(15)<strong class="mj io">.animation(.spring())<br/></strong>}.padding([.all])<strong class="mj io">.animation(.spring())</strong> //end of button vstack</span></pre><h2 id="d328" class="mn kz in bd la nh ni dn le nj nk dp li kk nl nm lm ko nn no lq ks np nq lu nr bi translated">手势-拖动菜单</h2><p id="a554" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">实现这个功能后，我意识到有时候右边的菜单会挡住后面屏幕上的东西，如果能移动它就好了。如果有人用左手拿着手机呢？必须用拇指穿过屏幕才能够到它是相当讨厌的。</p><p id="7073" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">因此，让我们实现一个拖动手势。在现有变量下，添加<code class="fe ns nt nu mj b">rightSide</code>(表示菜单在右边还是左边)。</p><pre class="mc md me mf gt mi mj mk ml aw mm bi"><span id="5ac8" class="mn kz in mj b gy mo mp l mq mr">struct ViewController: View {<br/> @State var page:String = "ViewA"<br/> let screenSize = UIScreen.main.bounds<br/> let iconSize = UIScreen.main.bounds.width*0.07<br/><strong class="mj io"> </strong>@State var expand:Bool = false<br/> @State var icon:String = "a.circle.fill"<br/> <strong class="mj io">@State private var rightSide:Bool = true </strong></span></pre><p id="4c65" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在这些变量的下方和视图主体的上方，添加menuDrag手势。如果用户从屏幕的右半部分拖动到左半部分，这将切换<code class="fe ns nt nu mj b">rightSide</code>，反之亦然。</p><pre class="mc md me mf gt mi mj mk ml aw mm bi"><span id="458c" class="mn kz in mj b gy mo mp l mq mr">var menuDrag: some Gesture {<br/> DragGesture().onChanged { value in }.onEnded { value in<br/>  if (self.rightSide &amp;&amp; value.translation.width &lt; -(self.screenSize.width*0.5)) || (!self.rightSide &amp;&amp; value.translation.width &gt; self.screenSize.width*0.5) {<br/>   self.rightSide.toggle()<br/>  }<br/> }<br/>}</span></pre><p id="1d2c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们只是将<code class="fe ns nt nu mj b">.animation(.spring())</code>追加到了人字形按钮和按钮VStack上；让我们把<code class="fe ns nt nu mj b">.gesture(menuDrag)</code>也加进去。我们还想在按钮ZStack的对齐方式中添加一个三元运算符。</p><pre class="mc md me mf gt mi mj mk ml aw mm bi"><span id="fbc3" class="mn kz in mj b gy mo mp l mq mr">...<br/>  //Chevron/Current Screen<br/>  Button(action: {<br/>   self.expand.toggle() <br/>  }) {<br/>   Image(systemName: expand ? "chevron.up" : icon).resizable().frame(width: iconSize, height: expand ? iconSize/3 : iconSize)<br/>}.buttonStyle(PageButtonStyle()).cornerRadius(15).animation(.spring())<strong class="mj io">.gesture(menuDrag)<br/> </strong>}.padding([.all]).animation(.spring())<strong class="mj io">.gesture(menuDrag)</strong> //end of button vstack<br/>}.frame(width: screenSize.width, height: screenSize.height, <strong class="mj io">alignment: rightSide ? .bottomTrailing : .bottomLeading</strong>) //end of button zstack</span></pre><h2 id="601a" class="mn kz in bd la nh ni dn le nj nk dp li kk nl nm lm ko nn no lq ks np nq lu nr bi translated">瞧啊。</h2><figure class="mc md me mf gt jo gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/ba4bc0bca4efe222b783e011dc0db7a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:448/1*oipG0zqcjhDs1duxaOHcnQ.gif"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">成功！</figcaption></figure><h1 id="fa5f" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">还有更多！</h1><p id="d561" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">现在，我们有了一个自定义菜单小部件，可以轻松集成到任何SwiftUI项目中。换成你自己的颜色也非常容易(甚至是渐变！)、图标、屏幕等。你甚至可以改变它，当你点击任何一个按钮，而不仅仅是人字形箭头时，它可以水平扩展或关闭。</p><p id="a16c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">查看<a class="ae kx" href="https://github.com/mgipson/MenuWidget/tree/master/MenuWidget" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上的项目了解更多信息。</p></div></div>    
</body>
</html>