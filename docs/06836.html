<html>
<head>
<title>Django + Celery in Kubernetes for Scheduling Tasks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">django+Kubernetes 的芹菜，用于安排任务</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/django-celery-in-kubernetes-for-scheduling-tasks-12718ef38bce?source=collection_archive---------4-----------------------#2022-02-07">https://blog.devgenius.io/django-celery-in-kubernetes-for-scheduling-tasks-12718ef38bce?source=collection_archive---------4-----------------------#2022-02-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b12e352c1f5a80fc1f1666c2795c4717.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u1mk9-nZRfSyvZnu7xk8qQ.png"/></div></div></figure><p id="f92f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Django 是一个流行的 Python web 框架，我们大多数人都非常熟悉，Celery 是一个开源的分布式任务排队系统。结合这两者，我们可以为各种问题开发各种类型的解决方案，如预定通知、电子邮件发送、后台进程等。</p><p id="594c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Kubernetes 是一个开源的容器编排系统，它自动执行部署过程、伸缩和管理。最初，它是由谷歌设计的，但现在它由云本地计算基金会维护。Kubernetes 所做的是创建一个或多个 pod，每个 pod 包含一个或多个过程容器，这意味着 pod 是整个系统的最小单元。如果您已经了解 Kubernetes，您就会知道 Kubernetes 有一些工作负载资源，它们是:</p><ol class=""><li id="ea4d" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">克朗·乔布斯</li><li id="b076" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">守护进程集</li><li id="5bc7" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">部署</li><li id="f9c4" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">乔布斯</li><li id="dcd4" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">副本集</li><li id="74c3" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">复制控制器(它将被副本集取代)</li><li id="4c1a" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">有状态集合</li></ol><p id="f770" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我假设你已经知道 Django 和 Kubernetes，所以我继续前进。</p><h1 id="eeff" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated"><strong class="ak">将 Django 项目归档</strong></h1><p id="1f54" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">对 Django 项目进行 Dockerize 既简单又直接。首先，我们必须在 Django 项目的根目录下创建一个 Dockerfile。我选择了 Alpine 作为基础图像(python:3.8.10-alpine)来最小化图像大小。</p><figure class="mk ml mm mn gt jo"><div class="bz fp l di"><div class="mo mp l"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated"><strong class="ak"> Dockerfile </strong></figcaption></figure><p id="780c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里的一切都很平常，除了 Bash 脚本文件(<strong class="jx io"> services.sh </strong>)！所有的 shell 命令都放在这个 Bash 脚本文件中，以便在我们运行 docker 映像时执行它们。这些是我现在为我的应用程序运行的命令:</p><figure class="mk ml mm mn gt jo"><div class="bz fp l di"><div class="mo mp l"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated"><strong class="ak"> services.sh </strong></figcaption></figure><p id="394f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里，我运行芹菜殴打第一，然后芹菜工人，然后 Gunicorn。</p><p id="bc26" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">芹菜节拍是运行调度任务，这意味着如果你想在特定时间执行任务，那么你将不得不使用芹菜节拍。</p><p id="09a4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Celery Worker 将执行任务，对于生产服务器，我使用 Gunicorn，但出于测试目的，这可以替换为 Django 的默认<em class="mu"> runserver </em>命令。</p><p id="5083" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在从 Django 项目根构建映像:</p><pre class="mk ml mm mn gt mv mw mx my aw mz bi"><span id="35a6" class="na li in mw b gy nb nc l nd ne">docker build -t djangoproject:v1 .</span></pre><p id="fb37" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将需要一些时间来构建，并在构建映像后运行它来测试是否一切正常</p><pre class="mk ml mm mn gt mv mw mx my aw mz bi"><span id="5d56" class="na li in mw b gy nb nc l nd ne">docker run -it --rm -p 8080:8080 djangoproject:v1</span></pre><p id="36d5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在将这个映像放入容器注册中心，并将它部署到 Kubernetes 集群中。正如我所说，我假设您了解 Kubernetes，我跳过了与 Kubernetes 相关的大部分流程，但我仍然在这里展示了 YAML 的部署:</p><figure class="mk ml mm mn gt jo"><div class="bz fp l di"><div class="mo mp l"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">部署 YAML</figcaption></figure><p id="bf46" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将在这里创建 3 个部署单元。</p><h1 id="0ae3" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">库伯内特斯的芹菜问题</h1><p id="4676" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">我们知道 Kubernetes 自动秤应用程序通过按照说明创建多个 pod，其中我们提到了我们的容器化图像。在上一节中，我们写了一个 Bash 脚本文件(<strong class="jx io"> services.sh </strong>)，其中我们首先运行 Celery Beat，然后是 Celery Worker，然后是 Gunicorn。因此，如果 Kubernetes 在多个单元中部署这个容器，那么这些容器也将在多个单元中运行。</p><p id="2528" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="mu">但是这些吊舱的芹菜会从多个吊舱并行执行单个预定任务。</em> </strong></p><p id="031f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，如果您计划向系统的所有用户发送通知，那么如果您的集群在 N 个 pods 中运行容器，每个用户将会收到 N 次通知！这就是这里的问题所在，我们必须从<strong class="jx io"> services.sh </strong>文件中删除所有 Celery(Celery Workers &amp; Celery Beats)命令，并以不同的方式执行，以便它只在一个 pod 中运行。所以最终的 Bash 脚本文件将如下所示</p><figure class="mk ml mm mn gt jo"><div class="bz fp l di"><div class="mo mp l"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated"><strong class="ak"> services.sh </strong></figcaption></figure><h1 id="2637" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">在 Kubernetes 集群的一个豆荚中运行芹菜</h1><p id="7584" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">我们知道 Kubernetes 很少有定义的工作负载资源，这在本文的顶部提到过。<strong class="jx io"> <em class="mu">部署</em> </strong>就是其中之一，它用于自动创建、更新和管理<strong class="jx io"> <em class="mu"> ReplicaSets </em> </strong>和<strong class="jx io"> <em class="mu"> Pods </em> </strong>来运行我们的应用程序。</p><p id="85f5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我在上面写了关于我的应用程序的<strong class="jx io"> <em class="mu">部署</em> </strong> YAML。我可以将 shell 命令写入 YAML 或 docker file<strong class="jx io"><em class="mu"/></strong>中，而不是将它们写入单独的 Bash 脚本文件中。这完全取决于您和您想要将命令放在哪里以及如何放置的用例。</p><p id="50f9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于我们需要在一个 Pod 中运行 Celery，我们将在这里选择一个不同的工作负载资源，以便它与<strong class="jx io"> <em class="mu">部署</em> </strong>保持分离，并且它不会与许多 Pod 一起自动扩展，为此我选择了<strong class="jx io"> <em class="mu">复制</em> <em class="mu">控制器</em> </strong>。</p><p id="8370" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是我的芹菜<strong class="jx io"> <em class="mu">复制控制器</em> </strong> YAML</p><figure class="mk ml mm mn gt jo"><div class="bz fp l di"><div class="mo mp l"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">芹菜控制器. yaml</figcaption></figure><p id="f6d4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">相应地设置您的配置，但是<strong class="jx io">“副本”参数的值不应大于 1 </strong></p><p id="ee4a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以在 YAML 文件中看到<strong class="jx io">‘command’</strong>参数，在将此 YAML 应用到您的集群中后，此命令将在此特定 pod 中执行。</p><p id="8a53" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">也可以用 Kubernetes<strong class="jx io"><em class="mu">cron job</em></strong>和<strong class="jx io"><em class="mu">replication set</em></strong>代替<strong class="jx io"><em class="mu">replication controllers</em></strong>但是我个人更喜欢<strong class="jx io"><em class="mu">replication controllers</em></strong>。在某些意义上我可能错了，请纠正我</p></div></div>    
</body>
</html>