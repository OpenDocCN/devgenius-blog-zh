<html>
<head>
<title>Java Streams</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java流</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/java-streams-43e6361dbba3?source=collection_archive---------4-----------------------#2020-06-16">https://blog.devgenius.io/java-streams-43e6361dbba3?source=collection_archive---------4-----------------------#2020-06-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4d58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">“啊Sh** </strong>！<strong class="jp ir">又来了”</strong>这是我每次看到有人用流代替循环时的反应。</p><p id="4831" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Java 8有很多特性，其中最受欢迎的是lambdas和Java stream API。许多团队升级到Java 8只是为了利用甜蜜的lamdas。然而，我注意到自己和许多其他人使用Java 8或更高版本，不包括Streams API。<br/>让我们试着理解溪流。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/613c26a58b42baff26478973415cbe15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*NuTQrVQy9fcneItGLDvuhw.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">随机<a class="ae lb" href="http://memegenerator.net/" rel="noopener ugc nofollow" target="_blank">迷因</a>来自<a class="ae lb" href="http://memegenerator.net/" rel="noopener ugc nofollow" target="_blank">memegenerator.net</a></figcaption></figure><h1 id="8d05" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">什么是流？</h1><p id="6bd4" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">流表示从源派生的一系列对象，可以在这些对象上执行聚合操作。</p><p id="377c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好的，它们和收藏品有什么不同？</p><p id="2cf3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们开始在网飞或Youtube上观看视频时，视频的一小部分首先被加载，然后播放。我们不必下载完整的视频就可以开始观看。这被称为<em class="mf">流</em>。这个类比帮助我们区分Java流和Java集合。</p><p id="f4bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mf">集合</em> </strong>是内存中的数据结构。每个元素在添加到集合之前都需要计算。<strong class="jp ir"> <em class="mf">流</em> </strong>是一种固定的数据结构，其中的元素是按需计算的。</p><p id="7b67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">流的存在是为了从源提取数据，处理数据，并将数据推送到目的地。源可以是集合、阵列或I/O资源。</p><p id="d731" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">流的剖析定义为:</p><ol class=""><li id="25b9" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated">获取来源(source)</li><li id="9064" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">流程(中间操作)</li><li id="d29a" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">得到结果(终端操作)</li></ol><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mu"><img src="../Images/0b49432e4eac5e3b1c245862e0c016cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q8XxeNHLOti5BVODrzFH1w.png"/></div></div></figure></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="931c" class="lc ld iq bd le lf nc lh li lj nd ll lm ln ne lp lq lr nf lt lu lv ng lx ly lz bi translated">如何获取一个流？</h1><p id="77ff" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">嗯，有相当多的选择</p><ol class=""><li id="1cad" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated"><strong class="jp ir">(val 1，val2，…)</strong></li><li id="ab78" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><strong class="jp ir"> List.stream() </strong></li><li id="e5f7" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><strong class="jp ir">(arrayOfElements)</strong></li><li id="c31e" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><strong class="jp ir">字符串字符</strong>或<strong class="jp ir">字符串令牌</strong></li></ol><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">从源获取流</figcaption></figure></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="6a0d" class="lc ld iq bd le lf nc lh li lj nd ll lm ln ne lp lq lr nf lt lu lv ng lx ly lz bi translated">流操作</h1><ul class=""><li id="9a4a" class="mg mh iq jp b jq ma ju mb jy nj kc nk kg nl kk nm mm mn mo bi translated">中间操作是转换或过滤流中数据的操作。中间操作总是返回一个新的流。</li><li id="966e" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk nm mm mn mo bi translated">终端操作是返回单个值的操作。</li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mu"><img src="../Images/0b49432e4eac5e3b1c245862e0c016cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q8XxeNHLOti5BVODrzFH1w.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">流水管道</figcaption></figure></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><p id="a81e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们先构建一个集合，看看操作是如何进行的。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">初始收集(我们的来源)</figcaption></figure><h2 id="e6ff" class="nn ld iq bd le no np dn li nq nr dp lm jy ns nt lq kc nu nv lu kg nw nx ly ny bi translated"><strong class="ak">中间操作</strong></h2><ol class=""><li id="b152" class="mg mh iq jp b jq ma ju mb jy nj kc nk kg nl kk ml mm mn mo bi translated"><strong class="jp ir"> Stream.filter() </strong></li></ol><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">。过滤器()</figcaption></figure><p id="8268" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">。stream() </strong>从源(numbers list)获取流。<br/> <strong class="jp ir">。filter() </strong>提供了过滤掉所有长度超过3的字符串的条件。<br/> <em class="mf">作为一个中间操作，这使我们能够调用另一个流操作(本例中为forEach)</em><br/><strong class="jp ir">。forEach() </strong>也是一个中间操作，为流中的每个元素调用print函数。</p><blockquote class="nz oa ob"><p id="64b1" class="jn jo mf jp b jq jr js jt ju jv jw jx oc jz ka kb od kd ke kf oe kh ki kj kk ij bi translated"><strong class="jp ir">输出:<br/> </strong>三<br/>四<br/>五</p></blockquote><p id="abcb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.<strong class="jp ir"> Stream.map() </strong></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">。地图()</figcaption></figure><p id="abbc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">。map() </strong>使用给定的函数将每个元素转换成另一个对象。在这个例子中，它将每个字符串转换成大写的字符串。</p><blockquote class="nz oa ob"><p id="1143" class="jn jo mf jp b jq jr js jt ju jv jw jx oc jz ka kb od kd ke kf oe kh ki kj kk ij bi translated"><strong class="jp ir">输出:<br/>三</strong>四<br/>五<br/></p></blockquote><p id="11fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.<strong class="jp ir"> Stream.sorted() </strong></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">。已排序()</figcaption></figure><p id="bc3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">。sorted() </strong>创建一个排序的流。<strong class="jp ir"> <em class="mf">但是，它不对数字列表进行排序。</em> </strong></p><blockquote class="nz oa ob"><p id="e7ac" class="jn jo mf jp b jq jr js jt ju jv jw jx oc jz ka kb od kd ke kf oe kh ki kj kk ij bi translated"><strong class="jp ir">输出:<br/> </strong>五<br/>四<br/>三</p></blockquote><h2 id="10e2" class="nn ld iq bd le no np dn li nq nr dp lm jy ns nt lq kc nu nv lu kg nw nx ly ny bi translated"><strong class="ak"> <em class="of">终端操作</em> </strong></h2><p id="a1d1" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">终端操作返回一个值而不是一个流。</p><p id="2693" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1.<strong class="jp ir"> Stream.forEach() </strong></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">。过滤器()。forEach()</figcaption></figure><p id="2d23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">。forEach() </strong>遍历流中的所有元素，并对每个元素执行一些操作。该操作作为参数传递给函数。</p><blockquote class="nz oa ob"><p id="7aec" class="jn jo mf jp b jq jr js jt ju jv jw jx oc jz ka kb od kd ke kf oe kh ki kj kk ij bi translated"><strong class="jp ir">输出:<br/> </strong>三<br/>四<br/>五</p></blockquote><p id="9d1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.<strong class="jp ir"> Stream.collect() </strong></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">。收集()</figcaption></figure><p id="7612" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">。collect() </strong>方法是一个终端操作，它启动元素的内部迭代，并将流中的元素收集到任何数据类型的集合或对象中。</p><blockquote class="nz oa ob"><p id="828b" class="jn jo mf jp b jq jr js jt ju jv jw jx oc jz ka kb od kd ke kf oe kh ki kj kk ij bi translated"><strong class="jp ir">输出:<br/> </strong>【一、二、三、四、五】</p></blockquote><p id="fa8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.<strong class="jp ir"> Stream.match() </strong></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">。匹配()</figcaption></figure><blockquote class="nz oa ob"><p id="3dcf" class="jn jo mf jp b jq jr js jt ju jv jw jx oc jz ka kb od kd ke kf oe kh ki kj kk ij bi translated"><strong class="jp ir">输出:<br/> </strong>真<br/>假<br/>假</p></blockquote><p id="247f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更多流操作参考文件。</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="7447" class="lc ld iq bd le lf nc lh li lj nd ll lm ln ne lp lq lr nf lt lu lv ng lx ly lz bi translated">流的模式</h1><p id="2826" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">执行模式是流的一个属性。最初选择顺序或并行执行来创建流。<br/><em class="mf">collection . stream()</em>创建顺序流，<em class="mf">collection . parallel stream()</em>创建并行流。</p><p id="8fbd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们用一个例子来理解这个。让我们创建一个整数列表。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">流的模式</figcaption></figure><blockquote class="nz oa ob"><p id="a47e" class="jn jo mf jp b jq jr js jt ju jv jw jx oc jz ka kb od kd ke kf oe kh ki kj kk ij bi translated"><strong class="jp ir">输出:<br/> </strong>输入列表= [0，1，2，3，4，5，6，7，8，9]</p></blockquote><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nh ni l"/></div></figure><blockquote class="nz oa ob"><p id="fdf9" class="jn jo mf jp b jq jr js jt ju jv jw jx oc jz ka kb od kd ke kf oe kh ki kj kk ij bi translated"><strong class="jp ir">输出:<br/> </strong>线程=主<br/>线程=主<br/>线程=主<br/>线程=主<br/>线程=主<br/>串行流= [0，2，4，6，8]</p></blockquote><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nh ni l"/></div></figure><blockquote class="nz oa ob"><p id="8ada" class="jn jo mf jp b jq jr js jt ju jv jw jx oc jz ka kb od kd ke kf oe kh ki kj kk ij bi translated"><strong class="jp ir">输出:<br/></strong>Thread = main<br/>Thread = forkjoinpool . common pool-worker-19<br/>Thread = forkjoinpool . common pool-worker-27<br/>Thread = forkjoinpool . common pool-worker-5<br/>Thread = forkjoinpool . common pool-worker-9<br/>并行流= [6，2，0，8，4]</p></blockquote><p id="3903" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> BaseStream.isParallel() </strong>方法用于检查是否要执行一个终端操作，是否会并行执行？</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nh ni l"/></div></figure><blockquote class="nz oa ob"><p id="054f" class="jn jo mf jp b jq jr js jt ju jv jw jx oc jz ka kb od kd ke kf oe kh ki kj kk ij bi translated"><strong class="jp ir">输出:</strong> <br/>是串行流并行:假<br/>是并行流并行:真</p></blockquote><p id="a9fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果需要，稍后可以使用<strong class="jp ir"> sequential() </strong>将流转换为顺序模式，或者使用<strong class="jp ir"> parallel() </strong>方法将流转换为并行模式。</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="8993" class="lc ld iq bd le lf nc lh li lj nd ll lm ln ne lp lq lr nf lt lu lv ng lx ly lz bi translated">资源</h1><ul class=""><li id="c16d" class="mg mh iq jp b jq ma ju mb jy nj kc nk kg nl kk nm mm mn mo bi translated"><a class="ae lb" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html" rel="noopener ugc nofollow" target="_blank"> Java文档</a></li><li id="0658" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk nm mm mn mo bi translated">Baeldung博客</li><li id="61c6" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk nm mm mn mo bi translated"><a class="ae lb" href="http://tutorials.jenkov.com/java-functional-programming/streams.html#terminal-and-non-terminal-operations" rel="noopener ugc nofollow" target="_blank">詹科夫博客</a></li></ul></div></div>    
</body>
</html>