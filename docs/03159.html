<html>
<head>
<title>GoLang Monitoring 101: A journey for the perfect system</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GoLang监控101:完美系统之旅</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/golang-logging-101-a-journey-for-the-perfect-system-838fc466ecaa?source=collection_archive---------3-----------------------#2020-10-06">https://blog.devgenius.io/golang-logging-101-a-journey-for-the-perfect-system-838fc466ecaa?source=collection_archive---------3-----------------------#2020-10-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="1ab4" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">记录</h1><p id="e8e4" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">日志记录已经成为现代编码中最重要的方面之一，从帮助你在应用程序的运行时提供有用的信息到更容易地解决bug，在日志记录时有一个好的实践是很重要的。</p></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><p id="0adb" class="pw-post-body-paragraph kl km iq kn b ko lq kq kr ks lr ku kv kw ls ky kz la lt lc ld le lu lg lh li ij bi translated">几个月前，我负责在我们的go微服务(包括API和后端服务在内的10多种不同的应用程序)中重构我们的日志系统，在研究了实现它的最佳方法之后，我们开始动手，从stdout中的简单句子到JSON结构化日志，这些日志可以在Elasticsearch中解析，并使用它在Kibana中构建仪表板。在这篇博客中，我将指导你这个过程，并教你如何获得有用的信息(它将专注于纯GoLang，Elastic和Kibana将在不同的帖子中)。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi lv"><img src="../Images/42ecbbe1275bb4ce6f34d9d55765b818.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R9HqVPj7v5ND3_mawqXosw.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">当前由JSON日志支持的Kibana仪表板</figcaption></figure><h1 id="104e" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">第一步:检查你的源代码</h1><p id="a316" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在我们的领域中，大多数时候，我们没有对代码的完全控制权，因为不同的开发人员参与了每天的变更(除非你是唯一的维护者),或者甚至从老团队接手项目。这带来了问题，但没有什么是你不能处理的。在查看这方面的源代码时，您必须注意两件事，日志记录不足和日志记录过多。</p><p id="cb72" class="pw-post-body-paragraph kl km iq kn b ko lq kq kr ks lr ku kv kw ls ky kz la lt lc ld le lu lg lh li ij bi translated">当前最大的问题是日志记录不足，通常，这是因为开发人员忘记实现“额外的”行来提供额外的信息，因为我们(有时我属于这一类)知道它做什么，并且当它不是最好的做法时我们对此没有意见(类似于注释源代码)。过度日志记录更容易，因为它删除了无用的或不提供有意义信息的代码行。随着我们进行下去，事情会变得棘手，因为有了过度日志记录，每一行看起来都有意义，但它可能不会给我们的目标增加任何价值，我们的目标是从洞察中监控我们的应用程序。</p><p id="fb13" class="pw-post-body-paragraph kl km iq kn b ko lq kq kr ks lr ku kv kw ls ky kz la lt lc ld le lu lg lh li ij bi translated">两者都可以被认为是技术债务，因为它们不是好的实践。但我们是来解决这些问题的。有一个术语叫做<em class="ml">日志级别，</em>我们稍后会更深入地讨论它，但这是防止过度日志记录的基础。下一个技巧是回顾你的目标，哪些信息对你和你的团队有用。举个例子，处理函数是API世界中最重要的函数之一，一个好的实践是记录函数何时被触发，以及函数何时返回响应。这给了我们一些启示:</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">处理程序日志模板</figcaption></figure><ul class=""><li id="0277" class="mo mp iq kn b ko lq ks lr kw mq la mr le ms li mt mu mv mw bi translated">我们可以记录API调用的总持续时间，这有助于我们了解API的执行速度。</li><li id="5095" class="mo mp iq kn b ko mx ks my kw mz la na le nb li mt mu mv mw bi translated">重要的信息也可以从这里提取，比如HTTP方法、处理程序名、客户机名等等。</li></ul><p id="4961" class="pw-post-body-paragraph kl km iq kn b ko lq kq kr ks lr ku kv kw ls ky kz la lt lc ld le lu lg lh li ij bi translated">这种类型的分析必须对大部分代码进行，同时要记住你在寻找什么类型的信息，当你习惯后，这个过程会更容易。</p><h1 id="99c1" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">使用记录器的实例</h1><p id="ff09" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">正如你可能注意到的，我们没有使用fmt。大多数人用来“记录”的Printf。不同的库，如<a class="ae nc" href="https://github.com/sirupsen/logrus" rel="noopener ugc nofollow" target="_blank"> logrus </a>或<a class="ae nc" href="https://github.com/uber-go/zap" rel="noopener ugc nofollow" target="_blank"> zap </a>使用记录器的实例。这真的很重要，因为提供了很多功能，你可以根据自己的需要进行个性化设置。在本文中，我们将重点讨论logrus，因为它是我使用过的最有经验的包，并且它有很好的性能。</p><p id="d535" class="pw-post-body-paragraph kl km iq kn b ko lq kq kr ks lr ku kv kw ls ky kz la lt lc ld le lu lg lh li ij bi translated">在我的研究中，我发现了如何使用记录器实例的不同选择。最后，我给出了两种最好的方法，一种是全局记录器，另一种是每个包或函数的“本地”记录器。当您想要为一个包定制一个日志记录器时，本地选项是最好的。您可以实例化一个记录器并通过函数传递它，如下例所示:</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">特定于函数的记录器示例</figcaption></figure><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/2e29f66e6cb4e92136fddd5d2591b313.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*4cCoEsDxDXKhm2l4cWjQTw.png"/></div></figure><p id="cfe7" class="pw-post-body-paragraph kl km iq kn b ko lq kq kr ks lr ku kv kw ls ky kz la lt lc ld le lu lg lh li ij bi translated">尽管这可能不是最漂亮也不是最有效的方法，但它让您有可能多次使用这个日志记录器。第二种选择是创建一个日志包，使用一个全局变量来保存配置，并在您的服务中使用它。示例:</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="407e" class="pw-post-body-paragraph kl km iq kn b ko lq kq kr ks lr ku kv kw ls ky kz la lt lc ld le lu lg lh li ij bi translated">在您的主函数中，您使用日志记录。StartLogger()您就可以开始了！在NewLogger函数中，我使用一个简单的配置将日志输出到Stdout中，并在JSON中格式化它。这给了我们随时调用记录器的灵活性，而不用将它传递给函数。</p><h1 id="2bb3" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">标准化日志记录函数和JSON字段</h1><p id="1399" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这可能是博客最重要的部分，因为它将区分一种通常不被实现的日志记录方式。大多数时候，日志以这种格式出现在一行程序中:</p><pre class="lw lx ly lz gt ne nf ng nh aw ni bi"><span id="a7eb" class="nj jo iq nf b gy nk nl l nm nn">logger.Infof(“Something happened”)</span></pre><p id="6b53" class="pw-post-body-paragraph kl km iq kn b ko lq kq kr ks lr ku kv kw ls ky kz la lt lc ld le lu lg lh li ij bi translated">这很容易，但不方便，也不利于开发。在这种情况下，让你与众不同的想法如下。在您的API中，有不同的处理程序，并且不止一个开发人员一直在升级API。在每个处理程序的末尾，我们记录这个处理程序的结果。您会在控制台中看到两条不同的语句:</p><pre class="lw lx ly lz gt ne nf ng nh aw ni bi"><span id="d457" class="nj jo iq nf b gy nk nl l nm nn">{ “level”:”info”, “msg”: “Process completed, data returned for client Y”}</span><span id="337d" class="nj jo iq nf b gy no nl l nm nn">{ “level”:”info”, “msg”: “Handler completed, response sent back”}</span></pre><p id="e55b" class="pw-post-body-paragraph kl km iq kn b ko lq kq kr ks lr ku kv kw ls ky kz la lt lc ld le lu lg lh li ij bi translated">澄清一下，没有一个是完全错误的，但这不是我的偏好，还有很大的改进空间。为了突出问题，我们从它不能给我们很多信息这一事实开始。一条简单的消息不会帮助我们弄清楚应用程序的状态，也不会在某些东西不能正常工作的情况下提供帮助。即使日志是JSON格式的，它也没有充分利用它，因为我们无法用一行消息查看/查询日志消息。</p><p id="6a69" class="pw-post-body-paragraph kl km iq kn b ko lq kq kr ks lr ku kv kw ls ky kz la lt lc ld le lu lg lh li ij bi translated">那我们该如何改进呢？我发现了一种方法，我们可以为了相同的目的去除不同的消息，当团队需要一起协作时，这很有用。引入日志功能，它将作为日志实际含义的抽象/包装。例如，我们希望每次调用处理程序时都有一个日志。我们在日志包中创建了一个名为HandlerStart的函数，然后我们实现了实际的日志调用:</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="0692" class="pw-post-body-paragraph kl km iq kn b ko lq kq kr ks lr ku kv kw ls ky kz la lt lc ld le lu lg lh li ij bi translated">我们在应用程序的任何部分都是这样称呼它的:</p><pre class="lw lx ly lz gt ne nf ng nh aw ni bi"><span id="89a7" class="nj jo iq nf b gy nk nl l nm nn">log.HandlerStart(“Tutorial”, “Started”, “Handler”, time.Now())</span></pre><p id="3732" class="pw-post-body-paragraph kl km iq kn b ko lq kq kr ks lr ku kv kw ls ky kz la lt lc ld le lu lg lh li ij bi translated">输出给了我们关于内部情况的有意义的信息。</p><pre class="lw lx ly lz gt ne nf ng nh aw ni bi"><span id="3779" class="nj jo iq nf b gy nk nl l nm nn">{“Handler”:”Example Handler”,”Status”:”Started”,”Time”:”2020–10–05T20:55:05.982493–05:00",”client”:”Tutorial”,”level”:”info”,”msg”:”Handler Example started”,”time”:”2020–10–05T20:55:05–05:00"}</span></pre><p id="cd03" class="pw-post-body-paragraph kl km iq kn b ko lq kq kr ks lr ku kv kw ls ky kz la lt lc ld le lu lg lh li ij bi translated">一些可能有用的一般位置可能是初始化数据库之前和之后、根据函数的错误语句、重要函数发生之前和之后，例如路由器初始化或批处理创建。它有无限的可能性。我通常为每一个目的准备一个单独的go文件，并且我加入了具有相同思想的函数。如所有与连接相关的功能，位于connection.go下</p><p id="f9dd" class="pw-post-body-paragraph kl km iq kn b ko lq kq kr ks lr ku kv kw ls ky kz la lt lc ld le lu lg lh li ij bi translated">字段日志的想法是当您使用ELK stack或任何其他日志/度量系统时，使查询更容易并更快地聚集数据。id或traces等重要字段必须在日志中，以便进行调试，特定进程的名称也有助于了解日志来自何处。</p><h1 id="8beb" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">额外建议</h1><p id="d9a3" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我发现另一个有用的字段，尤其是在微服务下，是服务名或应用名。当你想在你的日志中重复一个字段而不需要重复的时候，钩子是你最好的选择，但是它需要更多的设置。</p><p id="6c4d" class="pw-post-body-paragraph kl km iq kn b ko lq kq kr ks lr ku kv kw ls ky kz la lt lc ld le lu lg lh li ij bi translated">为此，我们必须创建一个满足logrus中钩子接口的struct(它需要两个函数)。在我们设置记录器的文件中，让我们添加以下内容:</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="0623" class="pw-post-body-paragraph kl km iq kn b ko lq kq kr ks lr ku kv kw ls ky kz la lt lc ld le lu lg lh li ij bi translated">在Fire函数中，我们为日志添加了永久字段，即服务名。</p><p id="b1dc" class="pw-post-body-paragraph kl km iq kn b ko lq kq kr ks lr ku kv kw ls ky kz la lt lc ld le lu lg lh li ij bi translated">现在，在我们的StartLogger函数中，我们像这样添加AddHook函数:</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="91cd" class="pw-post-body-paragraph kl km iq kn b ko lq kq kr ks lr ku kv kw ls ky kz la lt lc ld le lu lg lh li ij bi translated">就是这样！</p><p id="8036" class="pw-post-body-paragraph kl km iq kn b ko lq kq kr ks lr ku kv kw ls ky kz la lt lc ld le lu lg lh li ij bi translated">希望在博客结束时，您对日志可以改进的方式有了更好的认识。自从我们迁移到这个新的“框架”后，它对我的团队非常有用。我将加入一个新的博客来建立ELK堆栈，并赋予我们的日志更多的意义。感谢任何反馈！谢谢你</p></div></div>    
</body>
</html>