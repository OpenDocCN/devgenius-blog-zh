# 福克西 JavaScript

> 原文：<https://blog.devgenius.io/foxy-javascript-a647f9a18dc2?source=collection_archive---------8----------------------->

如何战胜语言中一些最棘手的方面

![](img/b42c116314deefdaa75524af053dbbc4.png)

来自 [Pexels](https://www.pexels.com/photo/photo-of-fox-sitting-on-ground-2295744/) 的 Alex Andrews 的照片

众所周知，JavaScript 是一种非常微妙、快速和松散的编程语言，可能会导致一些令人摇头的结果。

根据我迄今为止对这门语言的了解，这是我观察到的**JavaScript 的 10 大最狡猾的怪癖。**

**#1 隐性强制**

值得注意的是，这种怪癖是语言中最臭名昭著的部分之一。简单来说，隐式强制是 JavaScript 的能力(或精神错乱的倾向？)将一种值类型强制转换为另一种类型。有些人可能会认为值被强制转换为*预期的*类型。我们得到这些有趣的小金块是隐性强制的结果:

```
1 < 2 < 3;    // --> true // but... 3 > 2 > 1;    // --> false9 + '1'       // --> '91'// but...91 - '1'      // --> 90
```

使用数组时，情况变得更加奇怪:

```
[] == ![];      // --> truetrue == [];     // --> false
true == ![];    // --> false

false == [];    // --> true
false == ![];   // --> true
```

肯定挠头了。这些强制背后实际上有一些有趣的逻辑(基于正在执行的操作和所涉及的操作数类型)，但对于语言新手来说，这很难理解。如果您得到一些令人惊讶的结果，请注意这一点(更好的是，在您方便的 REPL 中测试任何有问题的操作)。此外，在比较值或用关键字`typeof`检查变量类型时，要养成使用严格的等式运算符`===`的习惯。

**#2 分号**

这是一个敏感的话题，但是对于初学者来说，这不仅仅是一个烦恼。很难知道什么时候*而不是*使用它们会导致你的代码崩溃。所以，我们害怕上帝，我们只是虔诚地添加它们。明白了。

看一下这个例子:

```
let students = ''['Sam', 'Ari', 'Sharon', 'Steve'].forEach((name) => { if (name !== 'Steve') {
      name += ' & ';
    } students += name;});console.log(students);// expected: 'Sam & Ari & Sharon & Steve'
```

它抛出错误“*无法读取未定义*的属性‘forEach’”，而不是具有交替名称和&符号的字符串的预期输出因为第一行末尾缺少分号，所以无法正确解析代码，并且第一行实际上会进入第二行:

```
let students = ''['Sam', ... ].forEach(...)
```

为了避免这个问题，您需要养成用分号结束每个语句的习惯。句号。(或者我猜，分号？)

#3 **难以捉摸的返回值**

"*问题*:这个函数返回什么？"

“答:新阵？本身，只是变异了？数组的长度？未定义？”

一些方法，如 *Array.prototype.map()* 和*array . prototype . filter()*返回一个全新的元素数组，在新数组中实现了预期的更改。太好了！正如我们所料。

其他方法如 *Array.prototype.sort()* 和*array . prototype . reverse()*变异后返回原数组。作为一个 n00b，你怎么知道一个方法到底会返回什么？嗯，没有简单的方法知道一个方法将返回什么，除非你记住它或者查找它(或者在你的 REPL 中测试它)。老实说，当方法被添加到语言中时，这与*有更大的关系，而不是方法本身的基础，但是对于语言新手来说，一点一致性将是一种受欢迎的解脱。</抱怨>*

**# 4*array . prototype . foreach()*和*array . prototype . reduce()***

你知道那种尴尬的时刻吗？当你在聚会上提起某件事，会让之前很健谈的一群人安静下来。在当地的 JS 聚会上，对这些方法中的任何一种说一些措辞强硬的话，你就会明白我的意思了。

这是一个有趣的两难问题，如果开发者只是刚刚涉足其中，那么选择支持哪一方可能还为时过早。一些人认为 *forEach* 有问题，因为它主要依靠副作用来完成工作。举个例子，重要的是要注意(并记住) *forEach* 总是返回… undefined(惊喜！)而不是它本身，所以不能像其他很多数组方法那样链起来。这可能会在某个时候反咬你一口。从最佳实践的角度来看，其他不依赖于副作用的方法(例如，不直接依赖于函数输入的状态变化)更容易阅读和预测，因为它们具有清晰的语义。在这种情况下，少即是多。

```
let newArr **=** [];

[1, 2, 3].forEach((element) => {
  if(element > 1) {
    newArr.push(element);
  }
});

console.log(newArr); // [2, 3]
```

使用*array . prototype . filter()*将其与相同的任务进行比较:

```
let newArr = [1, 2, 3].filter((element) => element > 1);console.log(newArr); // [2, 3]
```

Array.prototype.reduce() 是一个有趣且强大的方法，但有些人会认为它使代码更难解析(对人类而言)。它本质上是将一个数组“简化”为一个输出值。这可以使计算总和或从数组中删除重复项变得非常简单，但代价是代码可读性更差。我认为熟悉这种方法是有价值的，但是要记住它的利弊。

**#5 传播算子(又名“…”)**

如果你想建立预期，这是最好的语法...

玩笑归玩笑，spread 操作符是有用的，但是何时使用它还不是很清楚。MDN 声明:

> **扩展语法**允许在需要零个或多个参数(用于函数调用)或元素(用于数组文字)的地方扩展一个可迭代对象，例如一个数组表达式或字符串，或者在需要零个或多个键值对(用于对象文字)的地方扩展一个对象表达式。

spread 运算符在不同的上下文中有不同的表现。这里只是一些你会发现 spread 语法有用的情况。

*   当在函数调用中使用时，它有效地将一个数组(或多个数组)分散到不同的参数中。例如，调用 *Math.max()或 Math.min()* 时:

```
let arr = [1, 3, 2, 0];Math.max(...arr);  // 3
```

*   对于多个阵列:

```
let arr1 = [-1, -2, -3, -4];
let arr2 = [10, 3, -8, 1, 9];

Math.max(...arr1, ...arr2) ); // 10
```

*   或者，它可以用来轻松复制数组:

```
let arr = [1, 2, 3];let newArr = [...arr];console.log(newArr); //  [1, 2, 3]arr === newArr; // false
```

*   它还可以用于快速地将字符串拆分成数组:

```
let string = "Hello!";

console.log( [...string] ); // [ 'H', 'e', 'l', 'l', 'o', '!']
```

区分*扩展操作符*和不同的构造 *rest 参数*很重要，因为它们都使用相同的语法`"..."`。

*   Rest 参数用在函数中，允许它们接受任意数量的参数。当声明一个函数时，如果 rest 参数用在函数参数的末尾，您可以发现它们。
*   在函数调用期间传入一个数组(或多个数组)时，会使用 Spread 语法。

**#6 隐含全局变量**

新程序员不断被警告不要“污染全局范围”，但是这到底意味着什么，隐含全局的概念是如何发挥作用的？当变量或函数无意中在全局范围内被命名为相同的东西时，我们将导致的问题称为*名称冲突*。当多个团队为同一个项目贡献代码时，就会发生这种情况。如果太多的变量和函数被添加到全局名称空间，项目很容易发生名称冲突，也称为“污染全局范围”

更糟糕的是，由于*隐含全局变量*的出现，您很容易无意中向全局范围添加变量。基本上，如果你没有遵循最佳实践并忘记显式声明你的变量，它会被你的语言解释为你的意思是把它声明为一个全局变量:

```
You type:sum = 10;JS interprets that as:const sum = 0;
```

或者另一个例子(链接变量赋值):

```
const findSum = (a, b) => { let sum = total = a + b; };
```

在本例中， *sum* 的作用域是局部变量，而 *total* 的作用域是全局变量。哎呀。

给聪明人的忠告:明确定义每个变量，保持全局范围整洁。

**#7 双 NOTs**

尽管有一个完全可以接受且*可读的*内置`Boolean`函数(将大部分内容转换为布尔值)，但双非或`!!`还是一清二楚。它还将一个值强制转换为布尔值:

```
!!0 
!!null
!!undefined...all return the boolean **false**. Nifty.
```

下面这个笑话有助于解释这一点:

> 一位语言学教授曾经说过“双重否定构成肯定，而在某些语言中，双重否定仍然是否定。然而，没有一种语言中双重肯定可以构成否定。”
> 
> 一个声音从房间后面传来，“是的，没错。”

总而言之，第一！将值转换为布尔值，然后返回相反的值。第二个！将反转布尔值，并以这种复杂的方式将值转换为布尔值。

我几乎找不到这方面的缺点。

**#8 变量遮蔽**

这种怪癖不是 JavaScript 独有的，但每次都会吸引新的程序员。我们知道应该尽可能选择最具描述性的变量名，但是如果这导致您使用同一个变量名在全局范围和局部范围内声明一个变量呢？这时候事情就变得一团糟了。局部作用域的变量实质上隐藏或覆盖了先前作用域的全局变量。这里有一个例子:

```
let num = 3;function example() {
    let num = 1;
    num += 10;
    return num;}console.log(num);  // 3
```

您是否期望看到 11 的输出？在变量隐藏中，如果在局部和全局范围内用相同的名称声明一个变量，那么在函数中使用该变量时，局部变量将优先。隐藏会使阅读代码变得混乱，也使得从函数范围内访问全局变量变得不可能。棉短绒通常有一个“无阴影”规则，理由很充分。当心潜伏的可变阴影。

**#9 吊装**

对我来说，这个词总是让人联想到一匹躺在轮床上的马(费西合唱团球迷？).这听起来并不优雅，但它是 JavaScript 语言的一个强大部分:无论变量在特定范围内的何处声明(局部或全局)，所有变量声明都被移动到其范围的顶部。就像《盗梦空间》中的一样，这意味着变量声明总是在任何代码执行之前被处理(只适用于声明，不适用于赋值)。

与上面的#8 相关，这可能会让一些开发人员措手不及。如果您没有意识到提升，它可能会导致您意想不到的行为:变量和函数可能会在代码中提前可用，而不是仅在声明后才可用，这可能会产生一些意想不到的后果(积极和消极的)。

出于这个原因，最好养成在变量作用域的顶部声明所有变量的习惯(对于全局作用域或局部函数作用域的顶部)。

**#10 对空值使用*类型的*导致“对象”**

smh…

老实说，这只是语言中的一个缺陷，但是如果你对它的历史感兴趣，你可以在这里找到更多的。