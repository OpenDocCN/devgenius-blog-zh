<html>
<head>
<title>Layouts in Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">颤振布局</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/layouts-in-flutter-c65b0dc6b356?source=collection_archive---------2-----------------------#2020-10-04">https://blog.devgenius.io/layouts-in-flutter-c65b0dc6b356?source=collection_archive---------2-----------------------#2020-10-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="f34b" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">第 4 部分:在 Flutter 中创建布局</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/4d4c9760ce0f23cd8591cdf33cd336ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JH7QfJC5xkJHGji3"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">潘卡杰·帕特尔在<a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><blockquote class="kt ku kv"><p id="6cfd" class="kw kx ky kz b la lb jo lc ld le jr lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">PS:这是我给初学者的扑系列的第四部分。如果你想看看剩下的部分，链接在文章的末尾。</p></blockquote><p id="483c" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">任何应用程序最重要的是应用程序的外观和感觉，以及用户如何与之交互。或者用更专业的术语来说，你的应用程序的用户界面(UI)和用户体验(UX)。虽然很多人可能会争论应用程序的后端或数据库设计或“功能”如何更重要，但让我们面对现实吧，没有人会使用你的应用程序，如果:</p><ol class=""><li id="a736" class="lw lx in kz b la lb ld le lt ly lu lz lv ma ls mb mc md me bi translated">这对眼睛是不容易的。</li><li id="6a64" class="lw lx in kz b la mf ld mg lt mh lu mi lv mj ls mb mc md me bi translated">不好用。如果用户必须执行很多步骤才能在你的应用程序中实现某些东西，他们可能不会这样做。</li><li id="0043" class="lw lx in kz b la mf ld mg lt mh lu mi lv mj ls mb mc md me bi translated">没有什么视觉上的东西能吸引他们的注意力。</li></ol><p id="b587" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">也就是说，让我们来看看 Flutter 中窗口小部件的布局和位置。</p><h1 id="ffb0" class="mk ml in bd mm mn mo mp mq mr ms mt mu jt mv ju mw jw mx jx my jz mz ka na nb bi translated">单个子部件</h1><p id="3b68" class="pw-post-body-paragraph kw kx in kz b la nc jo lc ld nd jr lf lt ne li lj lu nf lm ln lv ng lq lr ls ig bi translated">这个名字不言自明。这些小部件只能容纳一个子部件。</p><h2 id="3067" class="nh ml in bd mm ni nj dn mq nk nl dp mu lt nm nn mw lu no np my lv nq nr na ns bi translated">容器</h2><p id="84b0" class="pw-post-body-paragraph kw kx in kz b la nc jo lc ld nd jr lf lt ne li lj lu nf lm ln lv ng lq lr ls ig bi translated">容器是使用起来最方便的小部件。它有很多属性，比如子元素、装饰、颜色、填充、边距、变换等等。</p><p id="fa6a" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">如果容器没有子容器、高度、宽度或任何其他约束，并且被放置在具有无限约束的父容器中，那么它将试图占用尽可能少的空间。如果容器没有子级、高度、宽度或其他约束，但是它的父级是有界的，那么容器将扩展以适合父级。这是容器中的一个独特行为，很多开发人员都无法理解。</p><p id="6f81" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">当在屏幕上绘制时，容器将首先应用应用于它的任何转换，然后应用提供的任何装饰。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">容器的示例代码</figcaption></figure><h2 id="30a5" class="nh ml in bd mm ni nj dn mq nk nl dp mu lt nm nn mw lu no np my lv nq nr na ns bi translated">填料</h2><p id="cbd2" class="pw-post-body-paragraph kw kx in kz b la nc jo lc ld nd jr lf lt ne li lj lu nf lm ln lv ng lq lr ls ig bi translated">padding 小部件只是在孩子周围创建一个空白空间。如果您想知道填充小部件和带填充的容器之间有什么区别，其实没有太大区别。带有填充的容器只是为您构建一个填充小部件。你想用哪一个取决于上下文。如果你需要额外的装饰，如背景色或边框等。然后使用容器小部件。如果您只需要填充，那么就使用填充小部件。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">Flutter 中填充小部件的基本示例</figcaption></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">在颤振中沿各个侧面应用衬垫的示例</figcaption></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">颤振中沿轴应用的示例</figcaption></figure><h2 id="5671" class="nh ml in bd mm ni nj dn mq nk nl dp mu lt nm nn mw lu no np my lv nq nr na ns bi translated">中心</h2><p id="a794" class="pw-post-body-paragraph kw kx in kz b la nc jo lc ld nd jr lf lt ne li lj lu nf lm ln lv ng lq lr ls ig bi translated">我想这个名字本身就说明了一切。它基本上是一个小部件，将它的孩子放在它自己的中心。如果尺寸受到限制，这个部件将尽可能大。同样，这也可以通过使用带有对齐参数的容器来实现。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">中心部件的示例</figcaption></figure><h2 id="0f87" class="nh ml in bd mm ni nj dn mq nk nl dp mu lt nm nn mw lu no np my lv nq nr na ns bi translated">扩大</h2><p id="fd47" class="pw-post-body-paragraph kw kx in kz b la nc jo lc ld nd jr lf lt ne li lj lu nf lm ln lv ng lq lr ls ig bi translated">扩展的小部件扩展一个子部件，以便填充可用空间。扩展的小部件应该在行、列或 Flex 小部件中使用。它基本上扩展了子窗口，以填充父窗口小部件主轴上的可用空间。</p><p id="d947" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">在下面的例子中，你会看到一个<strong class="kz io"> <em class="ky"> flex </em> </strong>参数。这决定了子级可以展开的重要性顺序。例如，如果在一个 Row 小部件中有两个扩展的小部件，并且两个小部件的伸缩因子都是 1，那么它们将相等地扩展。然而，如果一个比另一个具有更高的伸缩因子，那么小部件将按照指定的伸缩因子的比率扩展。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">扩展小部件的示例</figcaption></figure><h2 id="b132" class="nh ml in bd mm ni nj dn mq nk nl dp mu lt nm nn mw lu no np my lv nq nr na ns bi translated">排列</h2><p id="134f" class="pw-post-body-paragraph kw kx in kz b la nc jo lc ld nd jr lf lt ne li lj lu nf lm ln lv ng lq lr ls ig bi translated">Align 小部件根据 alignment 参数中提到的内容在其内部对齐其子部件。您可以将内容居中，沿水平轴从头到尾放置，或沿垂直轴从上到下放置。Align 小部件还接受 heightFactor 和 widthFactor 参数，这两个参数分别乘以子元素的高度和宽度。</p><p id="2f94" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">这方面的一个例子可以在下面的堆栈概要中看到。</p><h2 id="d304" class="nh ml in bd mm ni nj dn mq nk nl dp mu lt nm nn mw lu no np my lv nq nr na ns bi translated">安置</h2><p id="0d91" class="pw-post-body-paragraph kw kx in kz b la nc jo lc ld nd jr lf lt ne li lj lu nf lm ln lv ng lq lr ls ig bi translated">这个是专门为书库做的。定位的小部件基本上控制子部件在堆栈中的位置。</p><p id="85be" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">这方面的一个例子可以在下面的堆栈概要中看到。</p><h1 id="57d3" class="mk ml in bd mm mn mo mp mq mr ms mt mu jt mv ju mw jw mx jx my jz mz ka na nb bi translated">多子部件</h1><p id="b08e" class="pw-post-body-paragraph kw kx in kz b la nc jo lc ld nd jr lf lt ne li lj lu nf lm ln lv ng lq lr ls ig bi translated">与单个子部件不同，多子部件可以在一个部件列表中包含一组部件。</p><h2 id="c50e" class="nh ml in bd mm ni nj dn mq nk nl dp mu lt nm nn mw lu no np my lv nq nr na ns bi translated">排</h2><p id="e011" class="pw-post-body-paragraph kw kx in kz b la nc jo lc ld nd jr lf lt ne li lj lu nf lm ln lv ng lq lr ls ig bi translated">用最简单的术语来说，Row 小部件在一个水平数组中显示它的所有子部件。如果您希望孩子有不同的尺寸，可以使用指定宽度的容器。如果您希望孩子填充水平空间，那么最好使用我们在本文前面讨论过的<strong class="kz io"> <em class="ky">扩展</em> </strong>小部件。</p><p id="709f" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">您可以让子对象沿两个轴排成一行。x 轴是主轴，y 轴是横轴。mainAxisSize 确定该行是应该占据整个可用的水平空间，还是只占据其子级所需的空间。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">行小部件的一个例子</figcaption></figure><h2 id="0273" class="nh ml in bd mm ni nj dn mq nk nl dp mu lt nm nn mw lu no np my lv nq nr na ns bi translated">圆柱</h2><p id="9158" class="pw-post-body-paragraph kw kx in kz b la nc jo lc ld nd jr lf lt ne li lj lu nf lm ln lv ng lq lr ls ig bi translated">与行完全相同，只是它在垂直数组中显示其子级。</p><p id="8ac8" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">在列的情况下，y 轴是主轴，x 轴是横轴。mainAxisSize 确定该列是应该占据整个可用的垂直空间，还是只占据其子列所需的空间。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">列小部件的一个例子</figcaption></figure><h2 id="524c" class="nh ml in bd mm ni nj dn mq nk nl dp mu lt nm nn mw lu no np my lv nq nr na ns bi translated">包装</h2><p id="8dd6" class="pw-post-body-paragraph kw kx in kz b la nc jo lc ld nd jr lf lt ne li lj lu nf lm ln lv ng lq lr ls ig bi translated">就功能而言，这是行和列的混合，但是提供了一个额外的特性。它可以沿着定义的轴显示多个子节点。</p><p id="38f3" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">Wrap 小部件接受一个方向参数，您可以将<strong class="kz io"> <em class="ky">轴</em> </strong>指定为水平(x 轴)或垂直(y 轴)。如果您碰巧在任一轴上用完了空间，小部件将简单地根据方向创建一个相邻的行或列。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">Wrap 小部件的示例</figcaption></figure><h2 id="1abf" class="nh ml in bd mm ni nj dn mq nk nl dp mu lt nm nn mw lu no np my lv nq nr na ns bi translated">堆</h2><p id="18fc" class="pw-post-body-paragraph kw kx in kz b la nc jo lc ld nd jr lf lt ne li lj lu nf lm ln lv ng lq lr ls ig bi translated">栈相对于它的边界定位它的子栈。您可以使用 Align 和 Positioned 之类的小部件将子部件放置在小部件的约束内。你甚至可以将孩子重叠在一起。顺序是根据数组中的顺序决定的。第一个孩子在底部，最后一个孩子在顶部。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">颤振中的堆栈示例</figcaption></figure><h1 id="2a62" class="mk ml in bd mm mn mo mp mq mr ms mt mu jt mv ju mw jw mx jx my jz mz ka na nb bi translated">包裹</h1><p id="cf74" class="pw-post-body-paragraph kw kx in kz b la nc jo lc ld nd jr lf lt ne li lj lu nf lm ln lv ng lq lr ls ig bi translated">在本文中，我们介绍了 Flutter 中的一些小部件。我们已经讨论了 Flutter 中一些常用的小部件，看看它们是如何工作的。为了使这篇文章简短扼要，我只指定了最需要的部分。如果你想更详细地了解如何使用这些小工具，请查看位于<a class="ae ks" href="http://flutter.dev" rel="noopener ugc nofollow" target="_blank"> flutter.dev </a>的文档。像往常一样，让我知道你想让我谈论什么话题，不要忘记通过鼓掌和与你的朋友分享来表达你的支持。在那之前，编码快乐！</p><p id="c8f8" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">PS。本文是系列文章的一部分。点击这里查看其他文章:</p><ol class=""><li id="751f" class="lw lx in kz b la lb ld le lt ly lu lz lv ma ls mb mc md me bi translated"><a class="ae ks" href="https://medium.com/dev-genius/flutter-for-beginners-c2fae3d4d540" rel="noopener">适合初学者的颤振</a></li><li id="074f" class="lw lx in kz b la mf ld mg lt mh lu mi lv mj ls mb mc md me bi translated"><a class="ae ks" href="https://medium.com/dev-genius/widgets-in-flutter-a53e3c671f13" rel="noopener">微件在颤动</a></li><li id="ba71" class="lw lx in kz b la mf ld mg lt mh lu mi lv mj ls mb mc md me bi translated"><a class="ae ks" href="https://medium.com/dev-genius/navigation-routing-in-flutter-655f08183084" rel="noopener">导航&amp;颤振中的路由</a></li><li id="c4d3" class="lw lx in kz b la mf ld mg lt mh lu mi lv mj ls mb mc md me bi translated"><a class="ae ks" href="https://medium.com/dev-genius/layouts-in-flutter-c65b0dc6b356" rel="noopener">颤振布局</a></li><li id="81f4" class="lw lx in kz b la mf ld mg lt mh lu mi lv mj ls mb mc md me bi translated"><a class="ae ks" href="https://medium.com/dev-genius/listviews-in-flutter-12bab3dccadc" rel="noopener">颤振中的列表视图</a></li></ol></div></div>    
</body>
</html>