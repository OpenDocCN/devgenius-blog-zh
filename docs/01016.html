<html>
<head>
<title>Finding Vertical Asymptotes With Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Python 寻找垂直渐近线</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/finding-vertical-asymptotes-with-python-aec002f73da?source=collection_archive---------4-----------------------#2020-06-22">https://blog.devgenius.io/finding-vertical-asymptotes-with-python-aec002f73da?source=collection_archive---------4-----------------------#2020-06-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/d652bb25c5cb535001b4fd2fb1c26842.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*-nwuFJWIAxjsdL-II1jBcw.png"/></div></figure><p id="8546" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">只是提醒一下，这个教程很大程度上依赖于我之前写的关于寻找函数根的教程，可以在这里找到。(强烈建议您在此之前阅读)</p><p id="7295" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">垂直渐近线是一个函数永远不会触及但会永远逼近但永远不会触及的垂直线。如果你想阅读垂直渐近线的简要描述，我写了一篇关于它的博文，可以在这里找到<a class="ae kp" href="https://bandzar.com/static/WhatAreVAs.html" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="bdcc" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">首先，我们将接受用户输入，在这个特定的教程中，我们将只使用有理函数，所以我们将把分子和分母作为单独的输入。</p><figure class="kr ks kt ku gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kq"><img src="../Images/b11b3e5a2ae12b0b150523c486d83c80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CQm3E6twGAbRVqgfxlVP2g.png"/></div></div></figure><p id="1ebd" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在我们要修改我们在上一节课中一起写的关于寻找函数根的程序，这个函数根可以在<a class="ae kp" href="https://medium.com/swlh/finding-a-functions-roots-with-python-590eca0d22a5" rel="noopener">这里</a>找到。我们将用 return 语句替换<em class="kz">循环</em>函数中的两个 print 语句，如下所示:</p><figure class="kr ks kt ku gt jo gh gi paragraph-image"><div class="gh gi la"><img src="../Images/f502c6308eaf0a18687d8764073ad9e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*8dMXlLIF-ssGlFkpPDamSA.png"/></div></figure><p id="af94" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们还将复制粘贴上一教程中编写的其余代码。</p><p id="87af" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在，我们将通过调用我们在上一教程中编写的函数来找到我们的函数分母的零点。</p><figure class="kr ks kt ku gt jo gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/22324036085033f225a1c26bc6c676d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*SNYq3Hx05EB6k0Pp_mOEHA.png"/></div></figure><p id="f945" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><em class="kz"> zeros </em>是所有 x 值的数组，它将使我们的分母等于零。现在我们将创建一个名为<em class="kz">渐近线</em>的新数组来保存我们尚未计算的解，然后遍历所有的零。</p><figure class="kr ks kt ku gt jo gh gi paragraph-image"><div class="gh gi lc"><img src="../Images/875db3b3a944f9b2ad1de9bab7d7be76.png" data-original-src="https://miro.medium.com/v2/resize:fit:528/format:webp/1*fbujvz0-B_GM8oy6qd8ZBA.png"/></div></figure><p id="48d8" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在 for 循环中，我们将使用坐标根来计算分子的 y 坐标。</p><figure class="kr ks kt ku gt jo gh gi paragraph-image"><div class="gh gi ld"><img src="../Images/ba11558f91448f2a5bf4911916c04c91.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*Hvt1Pf6KGnKxD3Qz3oVUsA.png"/></div></figure><p id="d663" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">请注意我们在这里如何使用<em class="kz"> eval </em>，这是一个内置函数，它将用户输入的字符串作为代码运行，使用我们在上面的行中为它设置的 x 值来有效地评估它。</p><p id="0269" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果<em class="kz">数字</em>不接近零，那么我们知道它是一条垂直渐近线，并将它附加到我们的<em class="kz">渐近线</em>列表中。(如果它非常接近零，那么我们可能会在函数中发现一个空洞，这将导致代数运算)</p><figure class="kr ks kt ku gt jo gh gi paragraph-image"><div class="gh gi le"><img src="../Images/6af666f05fca75976128162906f475bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*mzke3VzYv8GWk0gSiZi_ww.png"/></div></figure><p id="3125" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">剩下要做的就是打印我们的解决方案，最终代码应该如下所示:</p><figure class="kr ks kt ku gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi lf"><img src="../Images/c350f395a3d029e3994f10a3fbb93415.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1iJwHDr7qJDizJx3GVJB1g.png"/></div></div></figure><p id="5dd9" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们现在可以测试一下:</p><figure class="kr ks kt ku gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi lg"><img src="../Images/45fefeb8c2e01c417c7167ca5bdbebd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1md7-R88P0hAJqjLmJxRXQ.png"/></div></div></figure><p id="68bc" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">由于 sin(x)/cos(x)=tan(x)，我们有效地找到了有限域上 tan(x)的所有垂直渐近线。</p><figure class="kr ks kt ku gt jo gh gi paragraph-image"><div class="gh gi lh"><img src="../Images/3af0a2085891f8738ab14033b3cb9ff8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*Zqz-Er6chW_f8pIkPktLHw.png"/></div></figure><p id="bb5f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">请注意(x-3)是如何从我们的等式中被分解/抵消的，从而产生一个洞，导致我们只有一条垂直渐近线。</p><p id="b7a6" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">完整的代码，包括我以前写的关于寻找函数根的代码，可以在这里找到<a class="ae kp" href="https://medium.com/swlh/finding-a-functions-roots-with-python-590eca0d22a5" rel="noopener"/>附在下面:</p><pre class="kr ks kt ku gt li lj lk ll aw lm bi"><span id="e242" class="ln lo in lj b gy lp lq l lr ls">import math<br/>def derivative(f, x):<br/>    h=1e-8<br/>    return (f(x+h)-f(x))/h</span><span id="8d82" class="ln lo in lj b gy lt lq l lr ls">def solver(f, x0, epsilon, max_iter):<br/>    xn=x0<br/>    for n in range(0,max_iter):<br/>        y=f(xn)<br/>        if abs(y)&lt;epsilon:<br/>            return xn<br/>        slope=derivative(f,xn)<br/>        if(slope==0):<br/>            return None<br/>        xn=xn-y/slope<br/>    return None</span><span id="b734" class="ln lo in lj b gy lt lq l lr ls">def loop(f, L_bound, R_bound, increment):<br/>    solutions=[]<br/>    while L_bound&lt;=R_bound:<br/>        solution=solver(f, L_bound, 1e-10, 1000)<br/>        if solution is not None:<br/>            solution=round(solution,4)<br/>            if solution not in solutions:<br/>                solutions.append(solution)<br/>        L_bound+=increment<br/>    return sorted(solutions)</span><span id="f56c" class="ln lo in lj b gy lt lq l lr ls">equation=""<br/>def f(x):<br/>    try:<br/>        y=eval(equation)<br/>    except ZeroDivisionError:<br/>        y= 1e-10<br/>    return y</span><span id="60c2" class="ln lo in lj b gy lt lq l lr ls">numerator=input("Please input your numerator: ")<br/>denominator=input("Please input your denominator: ")<br/>equation=denominator<br/>zeros=loop(f,-100,100,0.5)<br/>asymptotes=[]<br/>for root in zeros:<br/>    x=root<br/>    numeratorY=eval(numerator)<br/>    if not (abs(numeratorY) &lt; 1e-10):<br/>        asymptotes.append(x)<br/>print(asymptotes)</span></pre><p id="3bcf" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">非常感谢您的阅读，如果您有任何问题/反馈，我会 100%回复您的留言！</p></div></div>    
</body>
</html>