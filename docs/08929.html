<html>
<head>
<title>Improving service performance by utilizing caching and parallelization in Spring boot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Spring boot 中利用缓存和并行化提高服务性能</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/improving-service-performance-by-utilizing-caching-and-parallelization-in-spring-boot-b154b0b3ba5e?source=collection_archive---------3-----------------------#2022-07-19">https://blog.devgenius.io/improving-service-performance-by-utilizing-caching-and-parallelization-in-spring-boot-b154b0b3ba5e?source=collection_archive---------3-----------------------#2022-07-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="d062" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">假设我们必须创建一个服务方法，它接受一个搜索关键字列表并返回一个对象列表。如果我们开始对每个搜索关键字进行循环数据库调用，然后聚合结果作为响应发送出去。无论您的数据库有多高效，从性能的角度来看，这显然是非常糟糕的。因此，在本文中，我们将探讨如何利用 Spring boot 的并行化和缓存特性来提高性能。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9336cdf30edffb68be5d26babeb3c3a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fls1gsuGJN8ABJsG"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@marvelous?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马文·迈耶</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="4496" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">解决方案概述</h1><p id="f342" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">因为我们在这里处理一个搜索关键字列表，所以很明显我们想到的第一件事是分批划分列表，然后进行并行数据库调用以获得响应。</p><p id="8bfa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但这还不够，我们可以进一步改进。在创建批处理和进行数据库调用之前，我们可以从在缓存中查找搜索关键字开始，如果存在，那么我们可以从列表中跳过这些搜索关键字，只对其他批处理进行异步数据库调用。一旦我们从数据库中获得响应，我们就可以缓存它并将其聚合到一个列表中，然后作为响应发送出去。这样，我们将利用 Spring boot 的并行化和缓存特性来提高性能。</p><h1 id="5623" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">让我们直接进入代码</h1><p id="3e8d" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">在这个例子中。我们正在创建一个服务，该服务将获得一个<code class="fe mc md me mf b">searchKeys</code>列表，并返回<code class="fe mc md me mf b">searchKey</code>和<code class="fe mc md me mf b">movie</code>细节的地图。</p><p id="0eba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个想法很简单。</p><ol class=""><li id="d575" class="mg mh in jm b jn jo jr js jv mi jz mj kd mk kh ml mm mn mo bi translated">首先，我们将获得不同的搜索关键字。</li><li id="075b" class="mg mh in jm b jn mp jr mq jv mr jz ms kd mt kh ml mm mn mo bi translated">然后，我们将尝试查找缓存中是否有这些键，如果有，我们将标记这些键，并将电影细节添加到列表中。</li><li id="b73c" class="mg mh in jm b jn mp jr mq jv mr jz ms kd mt kh ml mm mn mo bi translated">然后，我们将移除在上一步中标记的键。</li><li id="9ae9" class="mg mh in jm b jn mp jr mq jv mr jz ms kd mt kh ml mm mn mo bi translated">之后，我们将创建特定批量的批次。</li><li id="72c9" class="mg mh in jm b jn mp jr mq jv mr jz ms kd mt kh ml mm mn mo bi translated">然后我们将以异步方式为每个批处理调用助手服务。</li><li id="71fa" class="mg mh in jm b jn mp jr mq jv mr jz ms kd mt kh ml mm mn mo bi translated">一旦我们获得了数据，我们就可以设置缓存并将其聚集在一个列表中。</li><li id="c086" class="mg mh in jm b jn mp jr mq jv mr jz ms kd mt kh ml mm mn mo bi translated">最后我们会归还地图。</li></ol><p id="6ece" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意:这只是服务端的代码。</p><pre class="kj kk kl km gt mu mf mv mw aw mx bi"><span id="67e6" class="my la in mf b gy mz na l nb nc">private Map&lt;String, Movie&gt; getMovies(List&lt;String&gt; searchKeys) {</span><span id="56f7" class="my la in mf b gy nd na l nb nc">    List&lt;String&gt; uniqueSearchKeys = searchKeys.<br/>      stream().<br/>      distinct().collect(Collectors.toList());</span><span id="2d24" class="my la in mf b gy nd na l nb nc">    List&lt;Movie&gt; movies = new ArrayList&lt;&gt;();</span><span id="4110" class="my la in mf b gy nd na l nb nc">    // First, we will get the movies from cache if it is there.<br/>    // To use the jdkTemplate, you have to Autowire it like this.<br/>    // @Autowired<br/>    // @Qualifier("customJDKRedisTemplate")<br/>    // RedisTemplate&lt;String, Object&gt; jdkTemplate;</span><span id="16d6" class="my la in mf b gy nd na l nb nc">    List&lt;String&gt; foundInCache = new ArrayList&lt;&gt;();</span><span id="d2f3" class="my la in mf b gy nd na l nb nc">    for (String uniqueKey: uniqueSearchKeys) {<br/>      Movie movie = (Movie)jdkTemplate.opsForValue().<br/>        get("getMovieDetails" + "::" + uniqueKey.toUpperCase());<br/>      if (null != movie) {<br/>        foundInCache.add(uniqueKey);<br/>        movies.add(movie);<br/>      }<br/>    }</span><span id="c3f8" class="my la in mf b gy nd na l nb nc">    // Remove the keys which we have already found<br/>    uniqueSearchKeys.removeAll(foundInCache);</span><span id="ff0f" class="my la in mf b gy nd na l nb nc">    // For the rest of the keys we will divide it <br/>    // in batches of  {BATCH_SIZE} and <br/>    // then make Database call to get it.</span><span id="823e" class="my la in mf b gy nd na l nb nc">    int numberOfBatch = (uniqueSearchKeys.size() / BATCH_SIZE);<br/>    numberOfBatch = (numberOfBatch * BATCH_SIZE) <br/>      == uniqueSearchKeys.size() ? numberOfBatch : numberOfBatch+1;</span><span id="d6d1" class="my la in mf b gy nd na l nb nc">    List&lt;CompletableFuture&lt;List&lt;Movie&gt;&gt;&gt; taskList = <br/>      new ArrayList&lt;&gt;();</span><span id="9327" class="my la in mf b gy nd na l nb nc">    for (int i = 0; i &lt; numberOfBatch; i++) {<br/>      // here service is an helper service which <br/>      // calls the DAO layer to get the data in Async<br/>      taskList.add(<br/>        service.getMovieDetails(<br/>          uniqueSearchKeys.subList(i*BATCH_SIZE,<br/>          uniqueSearchKeys.size() &lt; (i+1)*BATCH_SIZE ? <br/>          uniqueSearchKeys.size() : (i+1)*BATCH_SIZE )<br/>      ));<br/>    }</span><span id="05c3" class="my la in mf b gy nd na l nb nc">    for (CompletableFuture&lt;List&lt;Movie&gt;&gt; task: taskList) {<br/>      try {<br/>        // You can add a timeout if you want here<br/>        List&lt;Movie&gt; moviesFromDB = task.get();<br/>        // We will set the cache for the searchKey <br/>        // which we are getting from the DB<br/>        for (Movie movie: moviesFromDB) {<br/>          jdkTemplate.opsForValue().<br/>          set("getMovieDetails" + "::" +<br/>               movie.getSearchKey().toUpperCase(),<br/>             movie);<br/>          movies.add(movie);<br/>        }<br/>      } catch (InterruptedException | ExecutionException e) { <br/>        log.error("Error while getting movie deatils {}", e);<br/>      }<br/>    }<br/> <br/>    // We will return the map of search key and movie details<br/>    return movies.stream().<br/>      filter(<br/>        movie -&gt; null != movie &amp;&amp; null != movie.getSearchKey()<br/>      ).<br/>      collect(<br/>        Collectors.toMap(<br/>          Movie::getSearchKey,<br/>          movie -&gt; movie,  (existingValue, newValue) -&gt; newValue)<br/>      );<br/>}</span></pre><p id="4fc8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要使用自定义的<code class="fe mc md me mf b">RedisTemplate</code>，您需要将其定义为一个 Bean。您可以在任何配置文件中定义它。你可以这样定义它。</p><pre class="kj kk kl km gt mu mf mv mw aw mx bi"><span id="aa35" class="my la in mf b gy mz na l nb nc">/**<br/> * This Bean is used for caching Java object<br/> * @return redis template<br/> */<br/><a class="ae ky" href="http://twitter.com/Bean" rel="noopener ugc nofollow" target="_blank">@Bean</a>(name="customJDKRedisTemplate")<br/>public RedisTemplate&lt;String, Object&gt; getCustomJDKRedisTemplate() {<br/> RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();<br/> template.setConnectionFactory(lettuceConnectionFactory());<br/> template.setKeySerializer(new StringRedisSerializer());<br/> template.setValueSerializer(new JdkSerializationRedisSerializer());<br/> return template;<br/>}</span></pre></div><div class="ab cl ne nf hr ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ig ih ii ij ik"><p id="85d6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你想了解更多关于异步和缓存的知识，你可以浏览 Spring boot 的文档。</p><ol class=""><li id="297a" class="mg mh in jm b jn jo jr js jv mi jz mj kd mk kh ml mm mn mo bi translated"><a class="ae ky" href="https://docs.spring.io/spring-data/redis/docs/current/api/org/springframework/data/redis/core/RedisTemplate.html" rel="noopener ugc nofollow" target="_blank">https://docs . spring . io/spring-data/redis/docs/current/API/org/spring framework/data/redis/core/redis template . html</a></li><li id="109a" class="mg mh in jm b jn mp jr mq jv mr jz ms kd mt kh ml mm mn mo bi translated">https://spring.io/guides/gs/async-method/<a class="ae ky" href="https://spring.io/guides/gs/async-method/" rel="noopener ugc nofollow" target="_blank"/></li></ol></div></div>    
</body>
</html>