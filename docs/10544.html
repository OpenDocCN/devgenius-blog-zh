<html>
<head>
<title>Docker Basic Interview Questions — How Many Can You Answer?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker 基本面试问题——你能回答几个？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/docker-interview-questions-how-many-can-you-answer-173437bb8d35?source=collection_archive---------1-----------------------#2022-11-10">https://blog.devgenius.io/docker-interview-questions-how-many-can-you-answer-173437bb8d35?source=collection_archive---------1-----------------------#2022-11-10</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="342d" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">有趣的基础码头工人面试问题</h2></div><figure class="kg kh ki kj gu kk gi gj paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gi gj gk"><img src="../Images/a115414118cbd703f8f8c9a40407d249.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NugLD0WBJH-7efXjr0YGpQ.png"/></div></div></figure><p id="fdac" class="pw-post-body-paragraph kr ks ir kt b ku kv js kw kx ky jv kz la lb lc ld le lf lg lh li lj lk ll lm ik bi translated">我收集的 Docker 有趣的面试问题，希望对你有帮助:)</p><h1 id="114f" class="ln lo ir bd lp lq lr ls lt lu lv lw lx jx ly jy lz ka ma kb mb kd mc ke md me bi translated">什么是 Docker</h1><p id="f1ba" class="pw-post-body-paragraph kr ks ir kt b ku mf js kw kx mg jv kz la mh lc ld le mi lg lh li mj lk ll lm ik bi translated">Docker 是一个开源应用容器引擎，基于<code class="fe mk ml mm mn b">Go</code>编程语言开发，在 Apache2.0 协议下开源。它允许企业创建、测试和部署各种应用程序和软件包到称为容器的单元中，使得为单个主机上的任何应用程序创建轻量级、可移植的自给自足的容器变得容易。</p><h1 id="8dbf" class="ln lo ir bd lp lq lr ls lt lu lv lw lx jx ly jy lz ka ma kb mb kd mc ke md me bi translated">Docker 常见用例？</h1><ul class=""><li id="76b1" class="mo mp ir kt b ku mf kx mg la mq le mr li ms lm mt mu mv mw bi translated">web 应用程序的自动化打包和发布。</li><li id="0859" class="mo mp ir kt b ku mx kx my la mz le na li nb lm mt mu mv mw bi translated">自动化测试和持续集成，发布。</li><li id="e926" class="mo mp ir kt b ku mx kx my la mz le na li nb lm mt mu mv mw bi translated">在基于服务的环境中部署和调整数据库或其他后台应用程序。</li><li id="294f" class="mo mp ir kt b ku mx kx my la mz le na li nb lm mt mu mv mw bi translated">从头开始编译或扩展现有的 OpenShift 或 Cloud Foundry 平台，构建自己的 PaaS 环境。</li></ul><h1 id="c780" class="ln lo ir bd lp lq lr ls lt lu lv lw lx jx ly jy lz ka ma kb mb kd mc ke md me bi translated">Docker 有什么优势？</h1><p id="afd1" class="pw-post-body-paragraph kr ks ir kt b ku mf js kw kx mg jv kz la mh lc ld le mi lg lh li mj lk ll lm ik bi translated">Docker 使您能够将应用程序从基础设施中分离出来，这样您就可以快速交付软件。通过利用 Docker 快速交付、测试和部署代码的方法，您可以大大减少编写代码和在生产中运行代码之间的延迟。</p><ul class=""><li id="d1db" class="mo mp ir kt b ku kv kx ky la nc le nd li ne lm mt mu mv mw bi translated"><strong class="kt is">灵活</strong>:即使是最复杂的应用程序也有可能被容器化。</li><li id="8d90" class="mo mp ir kt b ku mx kx my la mz le na li nb lm mt mu mv mw bi translated"><strong class="kt is">轻量级</strong>:容器利用并共享主机内核。</li><li id="fdf9" class="mo mp ir kt b ku mx kx my la mz le na li nb lm mt mu mv mw bi translated"><strong class="kt is">不可变</strong>:容器图像不可变。</li><li id="1686" class="mo mp ir kt b ku mx kx my la mz le na li nb lm mt mu mv mw bi translated"><strong class="kt is">可移植</strong>:可以本地构建，部署到云端，在任何地方运行。</li><li id="fc38" class="mo mp ir kt b ku mx kx my la mz le na li nb lm mt mu mv mw bi translated"><strong class="kt is">可伸缩</strong>:容器副本可以按需添加和分发。</li><li id="5589" class="mo mp ir kt b ku mx kx my la mz le na li nb lm mt mu mv mw bi translated"><strong class="kt is">可堆叠</strong>:服务可以垂直即时堆叠。</li></ul><h1 id="a650" class="ln lo ir bd lp lq lr ls lt lu lv lw lx jx ly jy lz ka ma kb mb kd mc ke md me bi translated">Docker 和 VM 有什么区别？</h1><p id="957b" class="pw-post-body-paragraph kr ks ir kt b ku mf js kw kx mg jv kz la mh lc ld le mi lg lh li mj lk ll lm ik bi translated">通过添加虚拟机管理程序层，虚拟机将虚拟硬件(如网卡、内存和 CPU)虚拟化，然后在其上构建虚拟机。每个虚拟机都有自己的系统内核。</p><p id="8d25" class="pw-post-body-paragraph kr ks ir kt b ku kv js kw kx ky jv kz la lb lc ld le lf lg lh li lj lk ll lm ik bi translated">Docker 容器则通过隔离(namesapce)的方式将文件系统、进程、设备、网络等资源隔离，进而控制权限、CPU 资源等。通过(cgroup)，这样容器就不会互相影响。</p><p id="f35a" class="pw-post-body-paragraph kr ks ir kt b ku kv js kw kx ky jv kz la lb lc ld le lf lg lh li lj lk ll lm ik bi translated">容器消耗的资源更少。在同一个主机下，可以创建的容器数量多于虚拟机数量。<br/>但是，虚拟机的安全性比容器稍好，docker 容器与主机共享内核和文件系统等资源，更容易受到其他容器对主机的影响。</p><h1 id="61b3" class="ln lo ir bd lp lq lr ls lt lu lv lw lx jx ly jy lz ka ma kb mb kd mc ke md me bi translated">解释 Docker 的三个核心特性？</h1><ul class=""><li id="94f1" class="mo mp ir kt b ku mf kx mg la mq le mr li ms lm mt mu mv mw bi translated"><strong class="kt is">镜像</strong> : Docker 的镜像是创建容器的基础，类似于虚拟机的快照，可以理解为 Docker 容器引擎的只读模板。</li><li id="2ea8" class="mo mp ir kt b ku mx kx my la mz le na li nb lm mt mu mv mw bi translated"><strong class="kt is">容器</strong>:从映像创建的运行实例，可以启动、停止和删除。创建的每个容器都是相互隔离和不可见的，以确保平台的安全性。</li><li id="ea69" class="mo mp ir kt b ku mx kx my la mz le na li nb lm mt mu mv mw bi translated"><strong class="kt is">注册表</strong>:docker 注册表是不同 Docker 图像的集合，这些图像具有相同的名称，但是具有不同的标签。标签就像 Docker 映像的一个版本，例如 v1、v2、v2.1 等。</li></ul><h1 id="90ce" class="ln lo ir bd lp lq lr ls lt lu lv lw lx jx ly jy lz ka ma kb mb kd mc ke md me bi translated">如何修改 Docker 的存放位置？</h1><p id="f0a3" class="pw-post-body-paragraph kr ks ir kt b ku mf js kw kx mg jv kz la mh lc ld le mi lg lh li mj lk ll lm ik bi translated">默认情况下，Docker 的存放位置为:<code class="fe mk ml mm mn b">/var/lib/docker</code>，要更新默认存放位置，需要停止 Docker 进程:</p><pre class="kg kh ki kj gu nf mn ng nh aw ni bi"><span id="9858" class="nj lo ir mn b gz nk nl l nm nn">$ systemctl stop docker</span></pre><p id="5504" class="pw-post-body-paragraph kr ks ir kt b ku kv js kw kx ky jv kz la lb lc ld le lf lg lh li lj lk ll lm ik bi translated">将<code class="fe mk ml mm mn b">/etc/docker/daemon.json</code>配置文件更新为以下内容:</p><pre class="kg kh ki kj gu nf mn ng nh aw ni bi"><span id="0e1e" class="nj lo ir mn b gz nk nl l nm nn">{<br/>  "data-root": "/new/docker/storage/location"<br/>}</span></pre><p id="243c" class="pw-post-body-paragraph kr ks ir kt b ku kv js kw kx ky jv kz la lb lc ld le lf lg lh li lj lk ll lm ik bi translated">然后重新启动守护程序:</p><pre class="kg kh ki kj gu nf mn ng nh aw ni bi"><span id="2657" class="nj lo ir mn b gz nk nl l nm nn">$ systemctl daemon-reload<br/>$ systemctl start docker</span></pre><h1 id="6e72" class="ln lo ir bd lp lq lr ls lt lu lv lw lx jx ly jy lz ka ma kb mb kd mc ke md me bi translated">常用的 Docker 命令有哪些？</h1><ul class=""><li id="7e6e" class="mo mp ir kt b ku mf kx mg la mq le mr li ms lm mt mu mv mw bi translated">码头工人拉动</li><li id="995c" class="mo mp ir kt b ku mx kx my la mz le na li nb lm mt mu mv mw bi translated">码头推送</li><li id="8625" class="mo mp ir kt b ku mx kx my la mz le na li nb lm mt mu mv mw bi translated">码头信息</li><li id="ea84" class="mo mp ir kt b ku mx kx my la mz le na li nb lm mt mu mv mw bi translated">码头工人检查</li><li id="b324" class="mo mp ir kt b ku mx kx my la mz le na li nb lm mt mu mv mw bi translated">码头停车</li><li id="48d7" class="mo mp ir kt b ku mx kx my la mz le na li nb lm mt mu mv mw bi translated">docker 启动/重启</li><li id="2617" class="mo mp ir kt b ku mx kx my la mz le na li nb lm mt mu mv mw bi translated">码头工人 rmi</li><li id="a76d" class="mo mp ir kt b ku mx kx my la mz le na li nb lm mt mu mv mw bi translated">码头工人室</li></ul><h1 id="f8ea" class="ln lo ir bd lp lq lr ls lt lu lv lw lx jx ly jy lz ka ma kb mb kd mc ke md me bi translated">如何创建 Nginx 容器？</h1><p id="c0c9" class="pw-post-body-paragraph kr ks ir kt b ku mf js kw kx mg jv kz la mh lc ld le mi lg lh li mj lk ll lm ik bi translated">使用<code class="fe mk ml mm mn b">docker run</code>命令:</p><pre class="kg kh ki kj gu nf mn ng nh aw ni bi"><span id="27b7" class="nj lo ir mn b gz nk nl l nm nn">$ docker run -d --name my-nginx -p 8080:80 nginx:latest<br/>1d24755e09ffdacc017f6a1d703bc098d24e56f3dc2cabe069b2551c2074ccd7</span></pre><h1 id="26ed" class="ln lo ir bd lp lq lr ls lt lu lv lw lx jx ly jy lz ka ma kb mb kd mc ke md me bi translated">如何进入运行容器？</h1><p id="369a" class="pw-post-body-paragraph kr ks ir kt b ku mf js kw kx mg jv kz la mh lc ld le mi lg lh li mj lk ll lm ik bi translated">你可以使用<code class="fe mk ml mm mn b">docker exec</code>命令，例如:</p><pre class="kg kh ki kj gu nf mn ng nh aw ni bi"><span id="85b4" class="nj lo ir mn b gz nk nl l nm nn">$ docker exec -it my-nginx bash</span></pre><h1 id="fcc6" class="ln lo ir bd lp lq lr ls lt lu lv lw lx jx ly jy lz ka ma kb mb kd mc ke md me bi translated">运行 Docker 容器的流程是什么？</h1><ul class=""><li id="cc93" class="mo mp ir kt b ku mf kx mg la mq le mr li ms lm mt mu mv mw bi translated">检查指定的图像是否存在于本地。当镜像不存在时，将从公共注册表下载；</li><li id="1eda" class="mo mp ir kt b ku mx kx my la mz le na li nb lm mt mu mv mw bi translated">使用映像创建并启动容器；</li><li id="b6e5" class="mo mp ir kt b ku mx kx my la mz le na li nb lm mt mu mv mw bi translated">给容器分配一个文件系统，在只读图像层外安装一个读写层；</li><li id="2640" class="mo mp ir kt b ku mx kx my la mz le na li nb lm mt mu mv mw bi translated">从主机配置网桥(默认模式)；</li><li id="312e" class="mo mp ir kt b ku mx kx my la mz le na li nb lm mt mu mv mw bi translated">将地址池中的 IP 地址分配给容器；</li><li id="5aa1" class="mo mp ir kt b ku mx kx my la mz le na li nb lm mt mu mv mw bi translated">执行用户指定的应用程序，执行后容器终止。</li></ul><h1 id="6cab" class="ln lo ir bd lp lq lr ls lt lu lv lw lx jx ly jy lz ka ma kb mb kd mc ke md me bi translated">Docker 网络模式有哪些？</h1><ul class=""><li id="970c" class="mo mp ir kt b ku mf kx mg la mq le mr li ms lm mt mu mv mw bi translated"><strong class="kt is">主机</strong>:如果你对一个容器使用<code class="fe mk ml mm mn b">host</code>网络模式，那么这个容器的网络栈不会与 Docker 主机隔离(容器共享主机的网络命名空间)，并且这个容器不会获得它自己分配的 IP 地址。</li><li id="0ef5" class="mo mp ir kt b ku mx kx my la mz le na li nb lm mt mu mv mw bi translated"><strong class="kt is">桥</strong>:它使用软件桥，允许连接到相同桥网络的容器进行通信，同时提供与未连接到该桥网络的容器的隔离。</li><li id="0258" class="mo mp ir kt b ku mx kx my la mz le na li nb lm mt mu mv mw bi translated"><strong class="kt is">容器</strong>:该模式指定新创建的容器与现有容器共享一个网络名称空间，而不是与主机共享。</li><li id="f5dd" class="mo mp ir kt b ku mx kx my la mz le na li nb lm mt mu mv mw bi translated"><strong class="kt is"> none </strong>:在 none 模式下，docker 容器拥有自己的网络名称空间，但不对 Docker 容器进行任何网络配置。也就是说这个 Docker 容器没有网卡、ip、路由等信息。在这种网络模式下，容器只有 lo 环回网络，没有其他网卡。这种类型的网络没有办法连接，但是封闭的网络可以保证容器的安全性。</li></ul><h1 id="d343" class="ln lo ir bd lp lq lr ls lt lu lv lw lx jx ly jy lz ka ma kb mb kd mc ke md me bi translated">Docker 的数据量是多少？</h1><p id="254b" class="pw-post-body-paragraph kr ks ir kt b ku mf js kw kx mg jv kz la mh lc ld le mi lg lh li mj lk ll lm ik bi translated">数据卷是容器使用的特殊目录，位于容器内。主机的目录可以挂载到数据卷上，数据卷的修改操作马上就能看到，更新的数据不会影响镜像，实现了数据在主机和容器之间的迁移。数据卷的使用类似于 Linux 下目录的挂载操作。</p><p id="3f5c" class="pw-post-body-paragraph kr ks ir kt b ku kv js kw kx ky jv kz la lb lc ld le lf lg lh li lj lk ll lm ik bi translated">如果需要在容器之间共享一些数据，最简单的方法是使用数据卷容器。数据卷容器是一种普通的容器，它提供数据卷供其他容器装载和使用。</p><h1 id="b353" class="ln lo ir bd lp lq lr ls lt lu lv lw lx jx ly jy lz ka ma kb mb kd mc ke md me bi translated">CMD 和 EntryPoint 有什么区别？</h1><p id="a82a" class="pw-post-body-paragraph kr ks ir kt b ku mf js kw kx mg jv kz la mh lc ld le mi lg lh li mj lk ll lm ik bi translated">它们都指定了在容器开始运行时执行的程序，区别如下:</p><ul class=""><li id="f9f6" class="mo mp ir kt b ku kv kx ky la nc le nd li ne lm mt mu mv mw bi translated"><strong class="kt is">当<code class="fe mk ml mm mn b">docker run</code>命令中有指定的参数时，Docker 守护程序会忽略 CMD </strong>命令。例如:</li></ul><pre class="kg kh ki kj gu nf mn ng nh aw ni bi"><span id="9a47" class="nj lo ir mn b gz nk nl l nm nn">$ docker run my-image echo Hello </span></pre><p id="ed8a" class="pw-post-body-paragraph kr ks ir kt b ku kv js kw kx ky jv kz la lb lc ld le lf lg lh li lj lk ll lm ik bi translated">将替换 Dockerfile 中的<code class="fe mk ml mm mn b">CMD</code>行</p><ul class=""><li id="7c11" class="mo mp ir kt b ku kv kx ky la nc le nd li ne lm mt mu mv mw bi translated"><strong class="kt is"> ENTRYPOINT </strong>指令不会被忽略，而是作为命令行参数追加，将其视为命令的参数。例如:</li></ul><pre class="kg kh ki kj gu nf mn ng nh aw ni bi"><span id="a331" class="nj lo ir mn b gz nk nl l nm nn"># Dockerfile<br/>From ubuntu:20.04ENTRYPOINT<br/>["echo", "Hello From ENTRYPOINT"]</span><span id="1344" class="nj lo ir mn b gz no nl l nm nn">$ docker build . -t my-ubuntu<br/>$ docker run my-ubuntu<br/>Hello From ENTRYPOINT</span></pre><p id="f6e3" class="pw-post-body-paragraph kr ks ir kt b ku kv js kw kx ky jv kz la lb lc ld le lf lg lh li lj lk ll lm ik bi translated">如果使用以下参数运行:</p><pre class="kg kh ki kj gu nf mn ng nh aw ni bi"><span id="573e" class="nj lo ir mn b gz nk nl l nm nn">$ docker run my-ubuntu echo hello Again<br/>Hello From ENTRYPOINT echo hello Again</span></pre><h1 id="4134" class="ln lo ir bd lp lq lr ls lt lu lv lw lx jx ly jy lz ka ma kb mb kd mc ke md me bi translated">添加和复制有什么区别？</h1><ul class=""><li id="e7eb" class="mo mp ir kt b ku mf kx mg la mq le mr li ms lm mt mu mv mw bi translated"><strong class="kt is"> ADD </strong>:从&lt; src &gt;复制新的文件、目录或远程 URL，并将其添加到&lt; dest &gt;的镜像文件系统中。它还可以做本地<code class="fe mk ml mm mn b">tar</code>提取。</li><li id="f12e" class="mo mp ir kt b ku mx kx my la mz le na li nb lm mt mu mv mw bi translated"><strong class="kt is"> COPY </strong>:从&lt; src &gt;中复制新的文件或目录，并添加到容器的文件系统中，路径为&lt; dest &gt;。</li></ul><p id="15cc" class="pw-post-body-paragraph kr ks ir kt b ku kv js kw kx ky jv kz la lb lc ld le lf lg lh li lj lk ll lm ik bi translated">一般首选<code class="fe mk ml mm mn b">COPY</code>，因为它比<code class="fe mk ml mm mn b">ADD</code>更透明。因为图像大小很重要，所以强烈建议不要使用<code class="fe mk ml mm mn b">ADD</code>从远程 URL 获取包，而应该使用<code class="fe mk ml mm mn b">curl</code>或<code class="fe mk ml mm mn b">wget</code>。</p></div></div>    
</body>
</html>