<html>
<head>
<title>MySkill Data Analysis Part 2: Python for Data Visualization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MySkill 数据分析第 2 部分:用于数据可视化的 Python</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/myskill-data-analysis-part-2-python-for-data-visualization-a2c514a3a9c7?source=collection_archive---------2-----------------------#2022-08-01">https://blog.devgenius.io/myskill-data-analysis-part-2-python-for-data-visualization-a2c514a3a9c7?source=collection_archive---------2-----------------------#2022-08-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/4d9dd8c100025af271851cf359b832a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vs-W_NwEhEj9_E5E.png"/></div></div></figure><p id="c883" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi kt translated">ython 是数据分析师和数据科学家世界中最流行的编程语言之一。Python 在用法上也非常灵活，你可以用它来做游戏开发，网页开发，甚至人工智能。对于编程新手来说，它也很容易学习。因此，学习 python 是一项非常好的技能，不管你是否对数据分析感兴趣，或者你只是一个普通的编程爱好者。</p><p id="b1bc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本文中，我们将使用 python 来分析来自电子商务数据集的数据，并将它们可视化。我们将要使用的平台是 Google Collab。Google Collab 是一个支持 python 编程的免费在线平台。该平台还为我们提供了 13 GB 的 RAM，如果你对数据科学也感兴趣，这是一个非常好的功能。</p><p id="1943" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本文中，我们要做的是 MySkill 已经提供的练习，这样我们就可以在数据分析和数据可视化方面磨练我们的 python 技能。</p></div><div class="ab cl lc ld hr le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ig ih ii ij ik"><p id="6569" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">本文是 MySkill 数据分析材料的第 2 部分，如果您想阅读其他部分，请点击此处:</p><ul class=""><li id="1f3f" class="lj lk in jx b jy jz kc kd kg ll kk lm ko ln ks lo lp lq lr bi translated"><a class="ae ls" href="https://medium.com/@miftahrafid/myskill-data-analysis-part-1-mysql-a8965e9f100" rel="noopener">第 1 部分:SQL </a></li><li id="cf9c" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated">第三部分:谷歌数据工作室</li></ul><p id="1765" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本练习中，我们将使用一个电子商务数据集。这个数据集有两个表:<em class="ly">电子商务事件</em>和<em class="ly">用户资料。</em>如果您想自己尝试数据集，请从这个<a class="ae ls" href="https://drive.google.com/file/d/1zSvtp3-iiw-ENwmZTZIY3JcWfumCNeeS/view?usp=sharing" rel="noopener ugc nofollow" target="_blank">下载链接</a>下载。</p><p id="76bd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你想看我的谷歌协作笔记本，你可以点击这个<a class="ae ls" href="https://colab.research.google.com/drive/1kVS2t0J_A3IWdhMJPgMOFUkLfGhO-dj7?usp=sharing" rel="noopener ugc nofollow" target="_blank">链接</a>。</p></div><div class="ab cl lc ld hr le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ig ih ii ij ik"><h1 id="35df" class="lz ma in bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">导入库和数据框架</h1><p id="cce8" class="pw-post-body-paragraph jv jw in jx b jy mx ka kb kc my ke kf kg mz ki kj kk na km kn ko nb kq kr ks ig bi translated">在我们解决练习任务之前，让我们先导入必要的库来做准备:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="7591" class="nl ma in nh b gy nm nn l no np">import pandas as pd<br/>import matplotlib.pyplot as plt<br/>import numpy as np<br/>import seaborn as sns</span></pre><p id="c941" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们一行一行地分解我们正在做的事情:</p><ul class=""><li id="3ffe" class="lj lk in jx b jy jz kc kd kg ll kk lm ko ln ks lo lp lq lr bi translated"><strong class="jx io">导入 pandas 作为 pd </strong>，我们导入 pandas 库并将变量缩短为‘PD’。Pandas 是一个用于分析数据的 python 库。</li><li id="619d" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">导入 matplotlib.pyplot 作为 plt，</strong>我们导入 Matplotlib.pyplot 库，将变量缩短为' plt '。Matplotlib 是一个用于 python 的数据可视化和图形绘图库。Pyplot 是使 Matplotlib 像<a class="ae ls" href="https://en.wikipedia.org/wiki/MATLAB" rel="noopener ugc nofollow" target="_blank"> MATLA </a> B 一样工作的函数集合</li><li id="a024" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">导入 numpy 为 np，</strong>我们导入 numpy 库，将变量缩短为‘NP’。Numpy 是一个 Python 库，可以执行各种数值计算。</li><li id="af44" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">导入 seaborn 作为 sns，</strong>我们导入 seaborn 库并将变量缩短为‘SNS’。Seaborn 也是一个 Python 库，用于借助 Matplotlib、Pandas 和 Numpy 绘制图形。但是使用 Seaborn 可视化数据更容易，因为它使用的语法更少。它专门研究统计可视化。</li></ul><p id="a704" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后让我们将数据导入 python</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="fbf5" class="nl ma in nh b gy nm nn l no np">df_ecomm = pd.read_csv("drive/MyDrive/MySkill/ecommerce_event.csv")<br/>df_user = pd.read_csv("drive/MyDrive/MySkill/user_profile.csv")</span></pre><p id="d206" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的 2 行代码中，我们使用 pandas 函数<strong class="jx io"> read_csv() </strong>读取 csv 文件，并将其转换成 data frame(python 中的 table)。该函数中的参数是 csv 文件的位置。我们将 ecommerce_event.csv 存储到<strong class="jx io"> df_ecomm </strong>变量，将 user_profile.csv 存储到<strong class="jx io"> df_user </strong>变量。</p><blockquote class="nq nr ns"><p id="8552" class="jv jw ly jx b jy jz ka kb kc kd ke kf nt kh ki kj nu kl km kn nv kp kq kr ks ig bi translated">如果你也像我一样使用 google colab，建议将你的数据存储在你的 Google Drive 中。Google Collab 只能将你的数据暂时存储在你的笔记本中，所以如果你失去了与笔记本的连接，你的数据就没有了，你必须再次上传你的数据，这很麻烦。通过将您的数据存储在您的 google drive 中，Google Collab 可以访问您的 Google Drive，这样您的数据就不会从笔记本中消失(只需再次运行 read_csv)。</p></blockquote><h1 id="1f70" class="lz ma in bd mb mc nw me mf mg nx mi mj mk ny mm mn mo nz mq mr ms oa mu mv mw bi translated">任务 1</h1><p id="571e" class="pw-post-body-paragraph jv jw in jx b jy mx ka kb kc my ke kf kg mz ki kj kk na km kn ko nb kq kr ks ig bi translated">使用条形图比较每个<strong class="jx io">类别</strong>的<strong class="jx io">收入</strong>，按最高收入排序</p><p id="c0fe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了回答上面的问题，我们用下面的代码来回答:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="9928" class="nl ma in nh b gy nm nn l no np">df_ecomm_category_revenue = df_ecomm[df_ecomm['event_type'] == 'purchase'][['category', 'price']].groupby('category', as_index = False).sum().sort_values('price', ascending = False)</span><span id="a6a0" class="nl ma in nh b gy ob nn l no np">plt.subplots(figsize=(10, 5))</span><span id="8306" class="nl ma in nh b gy ob nn l no np">sns.barplot(data = df_ecomm_category_revenue, x='category', y = 'price').set_title("Category revenue")</span></pre><p id="0b15" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们来分解一下上面的代码:</p><ul class=""><li id="86ef" class="lj lk in jx b jy jz kc kd kg ll kk lm ko ln ks lo lp lq lr bi translated"><strong class="jx io">df _ ecomm _ category _ revenue</strong>是我们用来存储新过滤数据帧的变量。</li><li id="7e3d" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">df_ecomm[df _ ecomm[' event _ type ']= ' purchase '][[' category '，' price']]，</strong>所以在这里我们调用我们的电子商务数据框架 df _ ecomm，并使用<strong class="jx io">first[]</strong>来过滤我们想要的列中的值。在这种情况下，<strong class="jx io">[df_ecomm[' event_type ']= ' purchase ']</strong>用于搜索 df _ ecomm 上 event _ type 列中的值，即“采购”。然后<strong class="jx io">第二个[] </strong>用来选择我们想要得到的列。在这种情况下，<strong class="jx io"> [['category '，' price']] </strong>意味着我们只想选择类别和价格列。<em class="ly">记住，如果你想得到 1 个以上的值，就用[]把它们分组，否则你就没有向 python 明确表示你想要 1 个以上的值。</em></li><li id="9dc4" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">。groupby('category '，as_index = False)，</strong>所以在这里我们使用<strong class="jx io"> groupby() </strong>函数使这个数据帧的聚集函数位于特定的列上。在这种情况下，<strong class="jx io">。groupby('category '，as_index = False) </strong>表示<strong class="jx io"> </strong>我们希望将此数据帧的聚合函数设置在类别列上(as_index = False 表示我们不想将列 id 设置为索引)。</li><li id="de2d" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">。sum()。sort_values('price '，ascending = False)，</strong>所以在这里 sum()用于对数值型列上的值求和。<strong class="jx io"> sort_values() </strong>是根据特定列对数据帧进行升序或降序排序的函数。在本例中，<strong class="jx io"> sort_values('price '，ascending = False) </strong>表示我们根据价格列以降序对值进行排序。</li><li id="9acf" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io"> plt.subplots(figsize=(10，5)) </strong>用于设置可视化的宽度和高度</li><li id="1982" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">SNS . bar plot(data = df _ ecomm _ category _ revenue，x='category '，y = 'price ')。set_title("类别收入")，</strong>表示我们用 sns 做一个条形图(条形图)。我们使用 df_ecomm_category_revenue 作为数据，类别列为 x，<strong class="jx io"> </strong>和价格列为 y，<strong class="jx io"> </strong>我们还使用<strong class="jx io">将标题设置为“类别收入”。set_title(“类别收入”)。</strong></li></ul><blockquote class="nq nr ns"><p id="37b2" class="jv jw ly jx b jy jz ka kb kc kd ke kf nt kh ki kj nu kl km kn nv kp kq kr ks ig bi translated">sns 的语法很容易理解。它几乎总是遵循这样的语法:<br/> sns。“图形”(“数据”，“x”，“y”)</p></blockquote><h2 id="f47d" class="nl ma in bd mb oc od dn mf oe of dp mj kg og oh mn kk oi oj mr ko ok ol mv om bi translated">输出</h2><figure class="nc nd ne nf gt jo gh gi paragraph-image"><div class="gh gi on"><img src="../Images/d0cc85876aeae173e78740a7197fc286.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*CpVbzyw0wg__LXGZaI0xNg.png"/></div></figure><p id="2774" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过可视化，我们可以看到电子产品在所有子类别中收入最高。</p><h1 id="a439" class="lz ma in bd mb mc nw me mf mg nx mi mj mk ny mm mn mo nz mq mr ms oa mu mv mw bi translated">任务 2</h1><p id="90a0" class="pw-post-body-paragraph jv jw in jx b jy mx ka kb kc my ke kf kg mz ki kj kk na km kn ko nb kq kr ks ig bi translated">使用条形图比较<em class="ly">智能手机</em> <strong class="jx io">子类别</strong>中每个<strong class="jx io">品牌</strong>的<strong class="jx io">收入</strong></p><p id="501b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了回答上面的问题，我们用下面的代码来回答:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="542c" class="nl ma in nh b gy nm nn l no np">df_ecomm_phone_brand = df_ecomm.loc[(df_ecomm['event_type'] == 'purchase') &amp; (df_ecomm['subcategory'] == 'smartphone')][['brand', 'price']].groupby('brand', as_index = False).sum().sort_values('price', ascending = False)</span><span id="a25a" class="nl ma in nh b gy ob nn l no np">plt.subplots(figsize=(10, 5))</span><span id="d3bb" class="nl ma in nh b gy ob nn l no np">sns.barplot(data = df_ecomm_phone_brand, x = 'brand', y = 'price').set_title("Smartphone brand revenue")</span></pre><p id="7e39" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们来分解一下上面的代码:</p><ul class=""><li id="122d" class="lj lk in jx b jy jz kc kd kg ll kk lm ko ln ks lo lp lq lr bi translated"><strong class="jx io"> df_ecomm_phone_brand </strong>是我们用来存储新过滤数据帧的变量。</li><li id="e8e4" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">df _ ecomm . loc[(df _ ecomm[' event _ type '] = ' purchase ')&amp;(df _ ecomm['子类别']= '智能手机')][['品牌'，'价格']]，</strong>所以在这里<strong class="jx io">。loc[] </strong>是一个 pandas 属性，拥有 1 个以上的过滤器(每个过滤器必须在()符号中)。在这种情况下，<strong class="jx io">df_ecomm . loc[(df _ ecomm[' event_type ']= ' purchase ')&amp;(df _ ecomm[' subcategory ']= ' smartphone ')]</strong>意味着我们搜索 df _ ecomm 上的 event _ type 列中的值，即' purchase '，我们还搜索子类别列中的值，即' smart phone '。我们还用<strong class="jx io"> ['品牌'，'价格']]选择品牌和价格列。</strong></li><li id="cf45" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io"> plt.subplots(figsize=(10，5)) </strong>用于设置可视化的宽度和高度</li><li id="e791" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">SNS . bar plot(data = df _ ecomm _ phone _ brand，x = 'brand '，y = 'price ')。set_title("智能手机品牌收入")</strong>，意思是我们用 sns 做一个柱状图(条形图)。我们使用 df_ecomm_phone_brand 作为数据，品牌列为 x，<strong class="jx io"> </strong>，价格列为 y. <strong class="jx io"> </strong>，我们还使用<strong class="jx io">将标题设置为“智能手机品牌收入”。set_title(“智能手机品牌收入”)。</strong></li></ul><h2 id="b9dc" class="nl ma in bd mb oc od dn mf oe of dp mj kg og oh mn kk oi oj mr ko ok ol mv om bi translated">输出</h2><figure class="nc nd ne nf gt jo gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/6b8262c45bae1ce07b63ecd4ec637b3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*9UsS8j3c8wYckKqSS-qsmw.png"/></div></figure><p id="f992" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过可视化，我们可以看到苹果在所有品牌中的收入最高。</p><h1 id="0299" class="lz ma in bd mb mc nw me mf mg nx mi mj mk ny mm mn mo nz mq mr ms oa mu mv mw bi translated">任务 3</h1><p id="28e6" class="pw-post-body-paragraph jv jw in jx b jy mx ka kb kc my ke kf kg mz ki kj kk na km kn ko nb kq kr ks ig bi translated">使用条形图比较每个<strong class="jx io">性别</strong>的<strong class="jx io">总会话</strong> <em class="ly">视图</em>，并将颜色更改为绿色</p><p id="575b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了回答上面的问题，我们用下面的代码来回答:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="0837" class="nl ma in nh b gy nm nn l no np">df_merge = pd.merge(df_ecomm, df_user, how = 'inner', on = 'user_id')</span><span id="8a5b" class="nl ma in nh b gy ob nn l no np">df_merge_view_gender = df_merge[df_merge['event_type'] == 'view'][['gender', 'user_session']].groupby('gender', as_index = False).nunique()</span><span id="82a2" class="nl ma in nh b gy ob nn l no np">df_merge_view_gender.columns = ['gender', 'total_session']</span><span id="def1" class="nl ma in nh b gy ob nn l no np">plt.subplots(figsize=(10, 5))</span><span id="e443" class="nl ma in nh b gy ob nn l no np">sns.barplot(data = df_merge_view_gender, x = 'gender', y = 'total_session', color = 'green').set_title("Total session per gender")</span><span id="2edd" class="nl ma in nh b gy ob nn l no np">plt.ylim(9000, 10000)</span></pre><p id="92b8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们来分解一下上面的代码:</p><ul class=""><li id="1788" class="lj lk in jx b jy jz kc kd kg ll kk lm ko ln ks lo lp lq lr bi translated"><strong class="jx io"> df_merge </strong>是存储合并数据帧的变量</li><li id="3455" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated">因为我们需要来自 df_user 的性别，所以需要将其与我们的 df_ecomm 合并。熊猫有一个 merge()函数来合并 2 个数据帧。在这种情况下，<strong class="jx io"> pd.merge(df_ecomm，df_user，how = 'inner '，on = 'user_id ')，</strong>意味着我们将合并 df_ecomm 和 df_user，并对两个表的 user_id 列进行内部连接。</li><li id="5cba" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io"> df_merge_view_gender </strong>是我们用来存储新过滤数据帧的变量。</li><li id="f4c3" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">df _ merge[df_ecomm[' event_type ']= ' purchase ']，</strong>表示我们在 df _ ecomm 上的 event _ type 列中搜索值，即' purchase '。</li><li id="d279" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io"> [['category '，' price']] </strong>表示我们只想选择类别和价格列。</li><li id="d554" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">。groupby('gender '，as_index = False)，</strong>表示<strong class="jx io"> </strong>我们希望此数据帧的聚合函数位于性别列上(as_index = False 表示我们不想将列 id 设置为索引)。</li><li id="25a9" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">。nunique()，</strong>表示<strong class="jx io"> </strong>我们希望计算每一列的唯一值</li><li id="a7dc" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">df_merge_view_gender . columns =[' gender '，' total_session']，</strong>表示我们在 df _ merge _ view _ gender 中更改列名</li><li id="3387" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io"> plt.subplots(figsize=(10，5)) </strong>用于设置可视化的宽度和高度。</li><li id="86d1" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">SNS . bar plot(data = df _ merge _ view _ gender，x = 'gender '，y = 'total_session '，color = 'green ')。set_title("每个性别的总会话数")，</strong>表示我们用 sns 制作一个条形图。我们使用 df_ecomm_phone_brand 作为数据，brand 列作为 x，<strong class="jx io"> </strong>价格列作为 y，我们还将条形图的颜色设置为绿色。我们还使用<strong class="jx io">将标题设置为“每个性别的总会话数”。set_title("每个性别的总会话数")。</strong></li><li id="9e8e" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io"> plt.ylim(9000，10000)，</strong>表示我们将 y 范围自定义为 9000–10000，我们希望这样可以使数据可视化更容易阅读(如果您好奇，可以尝试不使用该代码行，这样会更难阅读数据)</li></ul><h2 id="6ef4" class="nl ma in bd mb oc od dn mf oe of dp mj kg og oh mn kk oi oj mr ko ok ol mv om bi translated"><strong class="ak">输出</strong></h2><figure class="nc nd ne nf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi op"><img src="../Images/5045569faaef15c54f0b52eac095cc08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*riycfEegrnAMQkij34xPGw.png"/></div></div></figure><h1 id="98cb" class="lz ma in bd mb mc nw me mf mg nx mi mj mk ny mm mn mo nz mq mr ms oa mu mv mw bi translated">任务 4</h1><p id="174b" class="pw-post-body-paragraph jv jw in jx b jy mx ka kb kc my ke kf kg mz ki kj kk na km kn ko nb kq kr ks ig bi translated">使用直方图显示<em class="ly">电子产品类别</em> <strong class="jx io">价格</strong>的分布</p><p id="e308" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了回答上面的问题，我们用下面的代码来回答:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="f98b" class="nl ma in nh b gy nm nn l no np">df_ecomm_elec_distprice = df_ecomm[df_ecomm['category'] == 'electronics']</span><span id="2a8d" class="nl ma in nh b gy ob nn l no np">plt.subplots(figsize=(10, 5))</span><span id="7eb0" class="nl ma in nh b gy ob nn l no np">sns.histplot(data = df_ecomm_elec_distprice, x = 'price', bins=10, linewidth=2, edgecolor="black").set_title("Electronic category price distribution")</span></pre><p id="578a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们来分解一下上面的代码:</p><ul class=""><li id="6b00" class="lj lk in jx b jy jz kc kd kg ll kk lm ko ln ks lo lp lq lr bi translated"><strong class="jx io"> df_ecomm_elec_distprice </strong>是我们用来存储新过滤数据帧的变量。</li><li id="c77b" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">df_ecomm[df _ ecomm[' category ']= ' electronics ']，</strong>表示我们在属于' electronics '的 df _ ecomm 上的类别列中搜索值。</li><li id="fa6b" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io"> plt.subplots(figsize=(10，5)) </strong>用于设置可视化的宽度和高度。</li><li id="79f1" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">SNS . histplot(data = df _ ecomm _ elec _ dist price，x = 'price '，bins=10，linewidth=2，edgecolor="black ")。set_title("电子品类价格分布")，</strong>的意思是我们用 sns 做一个直方图。我们使用 df_ecomm_elec_distprice 作为数据，价格列作为 x，10 个箱，2 个线宽和黑色边缘颜色。我们也用<strong class="jx io">将标题设置为“电子品类价格分布”。set_title(“电子品类价格分布”)。</strong></li></ul><h2 id="9d06" class="nl ma in bd mb oc od dn mf oe of dp mj kg og oh mn kk oi oj mr ko ok ol mv om bi translated">输出</h2><figure class="nc nd ne nf gt jo gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/d6f39f5884942ba85b37d89af6270396.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*9eeohwpOQPv7YPylt_WwNA.png"/></div></figure><h1 id="edef" class="lz ma in bd mb mc nw me mf mg nx mi mj mk ny mm mn mo nz mq mr ms oa mu mv mw bi translated">任务 5</h1><p id="4d3b" class="pw-post-body-paragraph jv jw in jx b jy mx ka kb kc my ke kf kg mz ki kj kk na km kn ko nb kq kr ks ig bi translated">使用直方图显示苹果价格的分布</p><p id="7ea7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了回答上面的问题，我们用下面的代码来回答:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="22a3" class="nl ma in nh b gy nm nn l no np">df_ecomm_apple_distprice = df_ecomm.loc[df_ecomm['brand'] == 'apple']</span><span id="2ec6" class="nl ma in nh b gy ob nn l no np">plt.subplots(figsize=(10, 5))</span><span id="1816" class="nl ma in nh b gy ob nn l no np">sns.histplot(data = df_ecomm_apple_distprice, x = 'price', bins=10, linewidth=2, edgecolor="black").set_title("Apple price distribution")</span></pre><p id="fef5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们来分解一下上面的代码:</p><ul class=""><li id="8c2c" class="lj lk in jx b jy jz kc kd kg ll kk lm ko ln ks lo lp lq lr bi translated"><strong class="jx io">df _ ecomm _ apple _ dist price</strong>是我们用来存储新过滤数据帧的变量。</li><li id="432a" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">df_ecomm . loc[df _ ecomm[' brand ']= ' apple ']，</strong>表示我们在 df _ ecomm 上的 brand 列中搜索值，即' apple '。</li><li id="3ee0" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io"> plt.subplots(figsize=(10，5)) </strong>用于设置可视化的宽度和高度。</li><li id="05a3" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">SNS . histplot(data = df _ ecomm _ apple _ dist price，x = 'price '，bins=10，linewidth=2，edgecolor="black ")。set_title("苹果价格分布")，</strong>的意思是我们用 sns 做一个直方图。我们使用 df_ecomm_apple_distprice 作为数据，价格列作为 x，10 个箱，2 个线宽，黑色边缘颜色。我们也用<strong class="jx io">将标题设置为“苹果价格分布”。set_title(“苹果价格分布”)。</strong></li></ul><h2 id="0e0d" class="nl ma in bd mb oc od dn mf oe of dp mj kg og oh mn kk oi oj mr ko ok ol mv om bi translated"><strong class="ak">输出</strong></h2><figure class="nc nd ne nf gt jo gh gi paragraph-image"><div class="gh gi or"><img src="../Images/d3865f8b8d4b64d05994304ebe4ffaa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*9EIZK2RjPMBwuHT2rkSQiw.png"/></div></figure><h1 id="bf37" class="lz ma in bd mb mc nw me mf mg nx mi mj mk ny mm mn mo nz mq mr ms oa mu mv mw bi translated">任务 6</h1><p id="2ae4" class="pw-post-body-paragraph jv jw in jx b jy mx ka kb kc my ke kf kg mz ki kj kk na km kn ko nb kq kr ks ig bi translated">使用箱线图比较智能手机子类别中每个品牌的价格分布</p><p id="7288" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了回答上面的问题，我们用下面的代码来回答:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="f797" class="nl ma in nh b gy nm nn l no np">df_brand_distprice = df_ecomm.loc[df_ecomm['subcategory'] == 'smartphone']</span><span id="457a" class="nl ma in nh b gy ob nn l no np">plt.subplots(figsize=(25, 10))</span><span id="fcf3" class="nl ma in nh b gy ob nn l no np">sns.boxplot(data = df_brand_distprice, x='brand', y = 'price').set_title('Price distribution by each phone brand')</span></pre><p id="f179" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们来分解一下上面的代码:</p><ul class=""><li id="0c5b" class="lj lk in jx b jy jz kc kd kg ll kk lm ko ln ks lo lp lq lr bi translated"><strong class="jx io"> df_brand_distprice </strong>是我们用来存储新过滤数据帧的变量。</li><li id="159d" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io"> df_ecomm.loc[df_ecomm['子类别'] = '智能手机']，</strong>表示我们在 df_ecomm 上的子类别列中搜索值，df_ecomm 是一个'智能手机'。</li><li id="9e5e" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io"> plt.subplots(figsize=(10，5)) </strong>用于设置可视化的宽度和高度。</li><li id="377a" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">SNS . box plot(data = df _ brand _ dist price，x='brand '，y = 'price ')。set_title('每个手机品牌的价格分布')，</strong>表示我们用 sns 做一个箱线图。我们使用 df_brand_distprice 作为数据，品牌列为 x，<strong class="jx io"> </strong>和价格列为 y。我们还使用<strong class="jx io">将标题设置为每个手机品牌的价格分布。set_title(“各手机品牌的价格分布”)。</strong></li></ul><h2 id="97b8" class="nl ma in bd mb oc od dn mf oe of dp mj kg og oh mn kk oi oj mr ko ok ol mv om bi translated"><strong class="ak">输出</strong></h2><figure class="nc nd ne nf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi os"><img src="../Images/813164c60b76d34e68bfdf8ec48caa9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LzmfTgNLofRCQSgFTxqsXA.png"/></div></div></figure><h1 id="9fb4" class="lz ma in bd mb mc nw me mf mg nx mi mj mk ny mm mn mo nz mq mr ms oa mu mv mw bi translated">任务 7</h1><p id="51c5" class="pw-post-body-paragraph jv jw in jx b jy mx ka kb kc my ke kf kg mz ki kj kk na km kn ko nb kq kr ks ig bi translated">使用散点图显示年龄<strong class="jx io">和价格<strong class="jx io">之间的关系</strong></strong></p><p id="c887" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了回答上面的问题，我们用下面的代码来回答:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="3e9b" class="nl ma in nh b gy nm nn l no np">plt.subplots(figsize=(20, 5))</span><span id="289e" class="nl ma in nh b gy ob nn l no np">sns.scatterplot(data = df_merge, x = 'age', y = 'price').set_title('Relationship between age and price')</span></pre><ul class=""><li id="69dc" class="lj lk in jx b jy jz kc kd kg ll kk lm ko ln ks lo lp lq lr bi translated"><strong class="jx io"> plt.subplots(figsize=(10，5)) </strong>用于设置可视化的宽度和高度。</li><li id="a29d" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">SNS . scatter plot(data = df _ merge，x='age '，y = 'price ')。set_title('年龄与价格的关系')，</strong>表示我们用 sns 做散点图。我们使用 df_merge 作为数据，年龄列为 x，<strong class="jx io"> </strong>和价格列为 y。我们还使用<strong class="jx io">将标题设置为年龄和价格之间的关系。set_title(“年龄与价格的关系”)。</strong></li></ul><h2 id="5a85" class="nl ma in bd mb oc od dn mf oe of dp mj kg og oh mn kk oi oj mr ko ok ol mv om bi translated"><strong class="ak">输出</strong></h2><figure class="nc nd ne nf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ot"><img src="../Images/b95cb3754268725252a5d92747ec2b57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gykjz7-plqxAbbB9_fbfLA.png"/></div></div></figure><h1 id="27b6" class="lz ma in bd mb mc nw me mf mg nx mi mj mk ny mm mn mo nz mq mr ms oa mu mv mw bi translated">任务 8</h1><p id="f1ac" class="pw-post-body-paragraph jv jw in jx b jy mx ka kb kc my ke kf kg mz ki kj kk na km kn ko nb kq kr ks ig bi translated">使用折线图显示每天的转换率(<strong class="jx io">总时段购买量/总时段查看量</strong>)</p><p id="afdc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了回答上面的问题，我们用下面的代码来回答:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="1179" class="nl ma in nh b gy nm nn l no np">df_total_view = df_ecomm[df_ecomm['event_type'] == 'view'][['event_date', 'event_type']].groupby('event_date', as_index = False).count()<br/>df_total_view.columns = ['event_date', 'total_view']</span><span id="5cc6" class="nl ma in nh b gy ob nn l no np">df_total_purchase = df_ecomm[df_ecomm['event_type'] == 'purchase'][['event_date', 'event_type']].groupby('event_date', as_index = False).count()<br/>df_total_purchase.columns = ['event_date', 'total_purchase']</span><span id="43cd" class="nl ma in nh b gy ob nn l no np">df_conversion = pd.merge(df_total_purchase, df_total_view, how = 'inner', on = 'event_date')<br/>df_conversion['conversion_rate'] = df_conversion['total_purchase']/df_conversion['total_view']</span><span id="b36d" class="nl ma in nh b gy ob nn l no np">fig, ax = plt.subplots(figsize=(20, 5))<br/>sns.lineplot(data = df_conversion, x = 'event_date', y = 'conversion_rate').set_title("Conversion rate daily")<br/>ax.set_xticklabels(df_conversion['event_date'], rotation = 45, va = 'top')</span></pre><p id="b816" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，让我们制作一个每日总视图数据框架:</p><ul class=""><li id="0bfc" class="lj lk in jx b jy jz kc kd kg ll kk lm ko ln ks lo lp lq lr bi translated"><strong class="jx io"> df_total_view </strong>是我们用来存储新过滤数据帧(包含 total_view)的第一个变量。</li><li id="cbfc" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">df_ecomm[df _ ecomm[' event_type ']= ' view ']，</strong>表示我们在作为' view '的 df _ ecomm 上的 event _ type 列中搜索值。</li><li id="e0e6" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io"> [['event_date '，' event_type']] </strong>表示我们只想选择 event_date 和 event_typ <strong class="jx io"> e </strong>列。</li><li id="fa7c" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">。groupby('event_date '，as_index = False)，</strong>表示<strong class="jx io"> </strong>我们希望此数据帧的聚合函数位于 event_date 列上(as_index = False 表示我们不想将列 id 设置为索引)。</li><li id="ffdf" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">。count()，</strong>表示<strong class="jx io"> </strong>我们要对每一列的行数进行计数</li><li id="f817" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">df _ total _ view . columns =[' event _ date '，' total_view']，</strong>表示我们在<strong class="jx io"> </strong> df_total_view 中更改列名。</li></ul><p id="b693" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，让我们制作每日总购买量数据框架:</p><ul class=""><li id="b6be" class="lj lk in jx b jy jz kc kd kg ll kk lm ko ln ks lo lp lq lr bi translated"><strong class="jx io"> df_total_purchase </strong>是第二个变量，我们用它来存储新的过滤数据帧(包含 total_purchase)。</li><li id="37bd" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">df _ ecomm[df _ ecomm[' event_type ']= ' purchase ']，</strong>表示我们在 df_ecomm 上的 event _ type 列中搜索值，即' purchase。</li><li id="e6fb" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io"> [['事件日期'，'事件类型']] </strong>表示我们只想选择事件日期和事件类型列。</li><li id="50fa" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">。groupby('event_date '，as_index = False)，</strong>表示<strong class="jx io"> </strong>我们希望此数据帧的聚合函数位于 event_date 列上(as_index = False 表示我们不想将列 id 设置为索引)。</li><li id="abff" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">。count()，</strong>的意思是<strong class="jx io"> </strong>我们要对行列进行计数</li><li id="625d" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">df _ total _ purchase . columns =[' event _ date '，' total_purchase']，</strong>表示我们在<strong class="jx io"> </strong> df_total_view 中更改列名。</li></ul><p id="71a4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，我们合并两个数据帧，并将其可视化:</p><ul class=""><li id="6546" class="lj lk in jx b jy jz kc kd kg ll kk lm ko ln ks lo lp lq lr bi translated"><strong class="jx io"> df_conversion </strong>是我们用来存储新过滤数据帧的变量。</li><li id="5fe6" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io"> pd.merge(df_total_purchase，df_total_view，how = 'inner '，on = 'event_date ')，</strong>表示我们将使用两个表中的 user_id 列在内部联接上将 df_total_purchase 与 df_total_view 合并</li><li id="b188" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">df _ conversion[' conversion_rate ']= df _ conversion[' total_purchase ']/df _ conversion[' total_view ']，</strong>是指我们做一个新列叫做 conversion _ rate，计算是用 total _ purchase 列除以 total _ view 列。</li><li id="a379" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io"> fig，ax = plt.subplots(figsize=(20，5))，</strong>用于设置可视化的宽度和高度。</li><li id="c83a" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">SNS . line plot(data = df _ conversion，x = 'event_date '，y = 'conversion_rate ')。set_title("每日转化率")，</strong>表示我们用 sns 做一个线图。我们使用 df _ coversion 作为数据，event_date 列作为 x，<strong class="jx io"> </strong>和 conversion_rate 列作为 y .我们还使用<strong class="jx io">将标题设置为“每日转换率”<strong class="jx io"> </strong>。set_title("每日兑换率")。</strong></li><li id="ec02" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">ax . set _ xticklabels(df _ conversion[' event _ date ']，rotation = 45，va = 'top') </strong>，所以在这里我们让 x 标签比使用这段代码行之前更加可见</li></ul><h1 id="0ba1" class="lz ma in bd mb mc nw me mf mg nx mi mj mk ny mm mn mo nz mq mr ms oa mu mv mw bi translated">输出</h1><figure class="nc nd ne nf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ou"><img src="../Images/8a4da6908b5eeb7e7df294a3089f180d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a7ktaWzCuMjASmqLplV2vw.png"/></div></div></figure><h1 id="413f" class="lz ma in bd mb mc nw me mf mg nx mi mj mk ny mm mn mo nz mq mr ms oa mu mv mw bi translated">任务 9</h1><p id="e0b6" class="pw-post-body-paragraph jv jw in jx b jy mx ka kb kc my ke kf kg mz ki kj kk na km kn ko nb kq kr ks ig bi translated">显示有史以来转化率(<strong class="jx io">总购买量/总浏览量</strong>)最高的<strong class="jx io">类别</strong></p><p id="6ae9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了回答上面的问题，我们用下面的代码来回答:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="6d25" class="nl ma in nh b gy nm nn l no np">df_total_purchase_category = df_ecomm[df_ecomm['event_type'] == 'purchase'][['category', 'event_type']].groupby('category', as_index = False).count()</span><span id="3200" class="nl ma in nh b gy ob nn l no np">df_total_view_category = df_ecomm[df_ecomm['event_type'] == 'view'][['category', 'event_type']].groupby('category', as_index = False).count()</span><span id="5b97" class="nl ma in nh b gy ob nn l no np">df_conversion_category = pd.merge(df_total_purchase_category, df_total_view_category, how = 'inner', on = 'category')</span><span id="c69b" class="nl ma in nh b gy ob nn l no np">df_conversion_category.columns = ['category', 'total_purchase', 'total_view']</span><span id="e716" class="nl ma in nh b gy ob nn l no np">df_conversion_category['conversion'] = df_conversion_category['total_purchase']/df_conversion_category['total_view']</span><span id="c5d3" class="nl ma in nh b gy ob nn l no np">plt.subplots(figsize=(20, 5))</span><span id="37a3" class="nl ma in nh b gy ob nn l no np">sns.barplot(data = df_conversion_category, x = 'category', y = 'conversion').set_title('conversion rate per category')</span></pre><p id="f3da" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，让我们制作一个总购买类别数据框架:</p><ul class=""><li id="8bd3" class="lj lk in jx b jy jz kc kd kg ll kk lm ko ln ks lo lp lq lr bi translated"><strong class="jx io">df _ total_purchase _ category</strong>是我们用来存储新过滤数据帧(包含 total _ purchase)的第一个变量。</li><li id="7164" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">df_ecomm[df _ ecomm[' event_type ']= ' purchase ']，</strong>表示我们在属于' purchase '的 df _ ecomm 上的 event _ type 列中搜索值。</li><li id="196a" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io"> [['category '，' event_type']] </strong>表示我们只想选择类别和 event_type 列。</li><li id="5b99" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">。groupby('category '，as_index = False)，</strong>表示<strong class="jx io"> </strong>我们希望将此数据帧的聚合函数设置在类别列上(as_index = False 表示我们不想将列 id 设置为索引)。</li><li id="3039" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">。count()，</strong>表示<strong class="jx io"> </strong>我们要对每一列的行数进行计数</li></ul><p id="857a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，让我们制作一个总视图类别数据框架:</p><ul class=""><li id="d58c" class="lj lk in jx b jy jz kc kd kg ll kk lm ko ln ks lo lp lq lr bi translated"><strong class="jx io"> df_total_view_category </strong>是第二个变量，用于存储新的过滤数据帧(包含 total_view)。</li><li id="da34" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">df_ecomm[df _ ecomm[' event_type ']= ' view ']，</strong>表示我们在作为' view '的 df _ ecomm 上的 event _ type 列中搜索值。</li><li id="4325" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io"> [['category '，' event_type']] </strong>表示我们只想选择类别和 event_type 列。</li><li id="44cf" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">。groupby('category '，as_index = False)，</strong>表示<strong class="jx io"> </strong>我们希望此数据帧的聚合函数位于类别列上(as_index = False 表示我们不想将列 id 设置为索引)。</li><li id="e840" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">。count()，</strong>意为<strong class="jx io"> </strong>我们要计算每列的行数</li></ul><p id="96f4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，我们合并两个数据帧，并将其可视化:</p><ul class=""><li id="cce9" class="lj lk in jx b jy jz kc kd kg ll kk lm ko ln ks lo lp lq lr bi translated"><strong class="jx io"> df_conversion_category </strong>是我们用来存储新过滤数据帧的变量。</li><li id="9b1c" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">PD . merge(df_total_purchase_category，df_total_view_category，how = 'inner '，on = 'category ')，</strong>表示我们将使用两个表中的类别列在内部联接上将 df _ total _ purchase _ category 与 df_total_view_category 合并</li><li id="e4c6" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">df _ conversion _ category . columns =[' category '，' total_purchase '，' total_view']，</strong>表示我们将<strong class="jx io"/>df _ conversion _ category 中的列名改为' category '，' total_purchase '，' total_view '。</li><li id="c0c4" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">df_conversion_category[' conversion ']= df _ conversion _ category[' total_purchase ']/df _ conversion _ category[' total_view ']，</strong>是指我们在 df _ conversion _ category 上做一个名为 conversion 的新列，计算是用 total _ purchase 列除以 total _ view 列。</li><li id="d26e" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io"> fig，ax = plt.subplots(figsize=(20，5))，</strong>用于设置可视化的宽度和高度。</li><li id="fcc5" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">SNS . bar plot(data = df _ conversion _ category，x = 'category '，y = 'conversion ')。set_title('每个类别的转化率')，</strong>的意思是我们用 sns 做一个柱状图(条形图)。我们使用 df_conversion_category 作为数据，类别列为 x，<strong class="jx io"> </strong>和<strong class="jx io"> </strong>转换<strong class="jx io"> </strong>列为 y。我们还使用<strong class="jx io">将标题设置为每个类别的转换率<strong class="jx io"> </strong>。set_title(“每个类别的转换率”)。</strong></li></ul><h2 id="5e57" class="nl ma in bd mb oc od dn mf oe of dp mj kg og oh mn kk oi oj mr ko ok ol mv om bi translated">输出</h2><figure class="nc nd ne nf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ov"><img src="../Images/c6bc7dcc17bfba8ec844ffc81ef841e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G3WR4RBmqwoJkwnRyrJOvw.png"/></div></div></figure><h2 id="67e9" class="nl ma in bd mb oc od dn mf oe of dp mj kg og oh mn kk oi oj mr ko ok ol mv om bi translated">任务 10</h2><p id="d50f" class="pw-post-body-paragraph jv jw in jx b jy mx ka kb kc my ke kf kg mz ki kj kk na km kn ko nb kq kr ks ig bi translated">显示<em class="ly">智能手机</em> <strong class="jx io">子类别</strong>中转化率(<strong class="jx io">总购买量/总浏览量</strong>)最高的<strong class="jx io">品牌</strong></p><p id="c489" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了回答上面的问题，我们用下面的代码来回答:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="5ba9" class="nl ma in nh b gy nm nn l no np">df_total_purchase_phonebrand = df_ecomm.loc[(df_ecomm['event_type'] == 'purchase') &amp; (df_ecomm['subcategory'] == 'smartphone')][['brand', 'event_type']].groupby('brand', as_index = False).count()</span><span id="18dc" class="nl ma in nh b gy ob nn l no np">df_total_view_phonebrand = df_ecomm.loc[(df_ecomm[‘event_type’] == ‘view’) &amp; (df_ecomm[‘subcategory’] == ‘smartphone’)][[‘brand’, ‘event_type’]].groupby(‘brand’, as_index = False).count()</span><span id="076f" class="nl ma in nh b gy ob nn l no np">df_conversion_phonebrand = pd.merge(df_total_view_phonebrand, df_total_purchase_phonebrand, on = 'brand', how = 'inner')</span><span id="b599" class="nl ma in nh b gy ob nn l no np">df_conversion_phonebrand.columns = ['brand', 'total_view', 'total_purchase']</span><span id="db96" class="nl ma in nh b gy ob nn l no np">df_conversion_phonebrand['conversion'] = df_conversion_phonebrand['total_purchase']/df_conversion_phonebrand['total_view']</span><span id="fccf" class="nl ma in nh b gy ob nn l no np">plt.subplots(figsize=(20, 5))</span><span id="401a" class="nl ma in nh b gy ob nn l no np">sns.barplot(data = df_conversion_phonebrand, x = 'brand', y = 'conversion').set_title('conversion rate per phone brand')</span></pre><p id="b5ad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我们来做一个总购买手机品牌的数据框架:</p><ul class=""><li id="a79c" class="lj lk in jx b jy jz kc kd kg ll kk lm ko ln ks lo lp lq lr bi translated"><strong class="jx io">df _ total_purchase _ phone brand</strong>是我们用来存储新过滤数据框架(包含 total _ purchase)的第一个变量。</li><li id="1dcb" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">df_ecomm . loc[(df_ecomm[' event_type ']= ' purchase ')&amp;(df _ ecomm[' subcategory ']= ' smartphone ')]，</strong>表示我们在作为' purchase '的 df _ ecomm 上的 event _ type 列中搜索值，并且我们还在作为' smart phone '的 df _ ecomm 上的子类别列中搜索值。</li><li id="b4ef" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io"> [['brand '，' event_type']] </strong>表示我们只想选择品牌和事件类型列。</li><li id="a023" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">。groupby('brand '，as_index = False)，</strong>表示<strong class="jx io"> </strong>我们希望将此数据帧的聚合函数设置在类别列上(as_index = False 表示我们不想将列 id 设置为索引)。</li><li id="7fe0" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">。count()，</strong>意为<strong class="jx io"> </strong>我们要计算每列的行数</li></ul><p id="eef2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那我们就来做一个总观手机品牌数据框架:</p><ul class=""><li id="8489" class="lj lk in jx b jy jz kc kd kg ll kk lm ko ln ks lo lp lq lr bi translated"><strong class="jx io">df _ total_view _ phone brand</strong>是第二个变量，我们用它来存储新的过滤数据帧(包含 total _ view)。</li><li id="4ae2" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">df_ecomm . loc[(df_ecomm[' event_type ']= ' view ')&amp;(df _ ecomm[' subcategory ']= ' smartphone ')]，</strong>表示我们在作为' view '的 df _ ecomm 上的 event _ type 列中搜索值，并且还在作为' smart phone '的 df _ ecomm 上的 subcategory 列中搜索值。</li><li id="2f6c" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io"> [['brand '，' event_type']] </strong>表示我们只想选择品牌和事件类型列。</li><li id="1582" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">。groupby('brand '，as_index = False)，</strong>表示<strong class="jx io"> </strong>我们希望将此数据帧的聚合函数设置在类别列上(as_index = False 表示我们不想将列 id 设置为索引)。</li><li id="f447" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">。count()，</strong>表示<strong class="jx io"> </strong>我们要对每一列的行数进行计数</li></ul><p id="e109" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，我们合并两个数据帧，并将其可视化:</p><ul class=""><li id="fb5f" class="lj lk in jx b jy jz kc kd kg ll kk lm ko ln ks lo lp lq lr bi translated"><strong class="jx io">df _ conversion _ phone brand</strong>是我们用来存储新过滤数据帧的变量。</li><li id="8f6c" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">PD . merge(df_total_view_phonebrand，df_total_purchase_phonebrand，on = 'brand '，how = 'inner ')，</strong>表示我们将使用两个表中的 brand 列在内部联接上将 df _ total _ view _ phone brand 与 df_total_purchase_phonebrand 合并</li><li id="48fb" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">df _ conversion _ phone brand . columns =[' brand '，' total_view '，' total_purchase']，</strong>表示我们将<strong class="jx io"> </strong>中的列名改为' brand '，' total_view '，' total_purchase '。</li><li id="cec3" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">df_conversion_phonebrand[' conversion ']= df _ conversion _ phone brand[' total_purchase ']/df _ conversion _ phone brand[' total_view ']，</strong>表示我们在 df _ conversion _ phone brand 上生成名为 conversion 的新列，计算是用 total _ purchase 列除以 total _ view 列。</li><li id="201d" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io"> fig，ax = plt.subplots(figsize=(20，5))，</strong>用于设置可视化的宽度和高度。</li><li id="4b83" class="lj lk in jx b jy lt kc lu kg lv kk lw ko lx ks lo lp lq lr bi translated"><strong class="jx io">SNS . bar plot(data = df _ conversion _ phone brand，x = 'brand '，y = 'conversion ')。set_title('每个手机品牌的转化率')，</strong>的意思是我们用 sns 做一个柱状图(条形图)。我们使用 df_conversion_phonebrand 作为数据，brand 列为 x，<strong class="jx io"> </strong>和<strong class="jx io"> </strong> conversion <strong class="jx io"> </strong>列为 y，我们还使用<strong class="jx io">将标题设置为“每个手机品牌的转化率”<strong class="jx io"> </strong>。set_title(“每个手机品牌的转化率”)。</strong></li></ul><h2 id="241c" class="nl ma in bd mb oc od dn mf oe of dp mj kg og oh mn kk oi oj mr ko ok ol mv om bi translated">输出</h2><figure class="nc nd ne nf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ow"><img src="../Images/35ccae4bb50db9d1c88010e4b59fade1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UfpR0zuMXE5dCuiTVU9Ziw.png"/></div></div></figure><p id="e935" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这样就结束了这个练习任务的讲解，它是由 MySkill 提供的，用来磨练 python 中数据分析和数据可视化的能力。谢谢，希望每个解释都有用。</p></div></div>    
</body>
</html>