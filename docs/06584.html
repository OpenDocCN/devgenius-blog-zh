<html>
<head>
<title>How To Integrate Microservices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何整合微服务</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-integrate-microservices-a506fe2d1a48?source=collection_archive---------6-----------------------#2022-01-18">https://blog.devgenius.io/how-to-integrate-microservices-a506fe2d1a48?source=collection_archive---------6-----------------------#2022-01-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/6cdd7c839f2006512dc8f0b1b5c0054e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AER77SC4Zg-nmOWvU2Ankg.jpeg"/></div></div></figure><p id="e0d9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了了解<em class="kt">如何</em>，我们首先需要问一个问题，<em class="kt">为什么</em>我们要集成服务。<br/>我们集成服务是因为我们想要访问外部数据:<br/> <em class="kt">【获取当前钱包余额】</em> <br/>或者因为我们想要命令其他服务执行操作:<br/> <em class="kt">【向电子钱包转账】</em> <br/>其他服务也可以自行执行操作，当特定事件发生时:<br/> <em class="kt">【当个人帐户被禁止时，阻止其电子钱包】</em></p><p id="6a3e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">命令和事件在系统中产生动作，导致数据改变或副作用(如发送电子邮件/短信)。<br/>另一端的查询只是为了获取数据，无论如何不会改变服务的状态。</p><p id="b6b3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">区分查询和动作(命令和事件)很重要，不要把它们混在一起。我们马上就会知道这有什么关系。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="0da5" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">通过HTTP集成服务</h1><p id="b0e3" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">集成的第一种可能性是使用HTTP。我们向特定的端点发出HTTP请求，并得到响应。<br/> HTTP的强大之处在于马上得到反馈(响应)。</p><p id="3d7c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然而，HTTP集成有一些缺点:</p><ul class=""><li id="2900" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated">我们需要依赖正在运行的服务。万一服务中断，我们无法呼叫它</li><li id="b160" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated">服务可能超载或只是工作缓慢，这可能会造成我们这边的延迟问题</li><li id="7075" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated">它创建了服务之间的耦合</li></ul><p id="fbd5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">即使考虑到上述问题，立即获得响应的可能性使其非常适合查询集成。</p><blockquote class="ms mt mu"><p id="691c" class="jv jw kt jx b jy jz ka kb kc kd ke kf mv kh ki kj mw kl km kn mx kp kq kr ks ig bi translated">另一方面，动作的HTTP集成可能会在系统中产生不一致性。</p></blockquote><p id="ea64" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设注册用户后，我们调用另一个服务来发送电子邮件。当服务停止时，会发生什么？<br/>我们将无法调用，因此我们创建了一系列需要解决的问题:<br/> -如果我们想要保持注册，我们将需要消除错误。<br/> - <em class="kt"> I </em>如果我们无论如何都要发送电子邮件，我们将需要存储失败的数据，以便我们可以重试它<br/> - <em class="kt"> W </em> e将需要具有延迟的重试机制，因为服务可能在10秒或20分钟内启动并运行。</p><p id="12d7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设另一个场景，我们调用另一个服务，以便从钱包中扣除钱，请求超时。这对我们意味着什么？我们不可能真的知道，因为服务可以执行动作，但也可以不执行。如果系统不提供某种重复数据删除机制，如果我们重新发送请求，我们可能会扣除两次费用。而且，如果我们不这样做，我们可能会陷入钱根本没有被扣除的境地。嗯，现在的情况真的不太好，对吧？:)</p><blockquote class="ms mt mu"><p id="bd26" class="jv jw kt jx b jy jz ka kb kc kd ke kf mv kh ki kj mw kl km kn mx kp kq kr ks ig bi translated">HTTP非常适合查询，但是对于处理动作，有一个更健壮的解决方案，消息传递。</p></blockquote></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="c1bd" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">通过消息传递集成服务</h1><figure class="mz na nb nc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi my"><img src="../Images/a7b48b3e894a5a280c0a8b94fbd99d77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4gXigKdfiLD-LhzGPF1X-Q.jpeg"/></div></div></figure><p id="1b70" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">信息传递就像邮递员，我们就像发送信件(信息)的客户。信件包含标题和内容(在消息传递中，我们称之为内容——有效载荷)。<br/>我们正在给邮递员提供信件，邮递员将信件投递到收件人的信箱。<br/>当收信人准备好了，他就把信从盒子里拿出来，阅读信头和内容，然后采取行动。</p><p id="73a1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">把它推到编程层次，邮递员可以是<a class="ae nd" href="https://www.rabbitmq.com/" rel="noopener ugc nofollow" target="_blank"> RabbitMQ </a>，我们连接到它提供消息传递。RabbitMQ知道如何把它传递到给定的盒子(队列)。当它在接收者的队列中结束时，他可能会在对他最合适的时候消费掉它。</p><p id="ecbd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看看消息传递如何解决HTTP的缺点:</p><ul class=""><li id="b9ff" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated">HTTP问题#1:我们需要依赖正在运行的服务。万一服务中断，我们无法呼叫它</li></ul><p id="1e2a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们把信交给邮递员，收件人准备好了就从箱子里取出信。<br/>这允许我们向通知服务(收件人)发送说明“向X发送sms”的信件，即使该服务已关闭。当服务生起床时，他会挑选字母并执行动作。</p><blockquote class="ms mt mu"><p id="7201" class="jv jw kt jx b jy jz ka kb kc kd ke kf mv kh ki kj mw kl km kn mx kp kq kr ks ig bi translated">有了消息传递，我们变得独立于周围的服务状态</p></blockquote><ul class=""><li id="58cd" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated">HTTP问题#2:服务可能超载或者只是运行缓慢，这给我们造成了延迟问题</li></ul><p id="fc75" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们通过HTTP调用服务时，我们处于请求-响应模型中。<br/>这种模式会产生延迟，因为我们要等待收到响应。</p><blockquote class="ms mt mu"><p id="3784" class="jv jw kt jx b jy jz ka kb kc kd ke kf mv kh ki kj mw kl km kn mx kp kq kr ks ig bi translated">在信息传递方面，我们采用的是“一劳永逸”的模式。这意味着我们只连接到邮递员(消息代理)来发送消息，不管当前接收者的状态如何，消息流都会继续。<br/>这将我们从其他服务的响应时间中解放出来。</p></blockquote><ul class=""><li id="7092" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated">HTTP问题#3:与其他服务的耦合</li></ul><p id="0c4e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果客户端在我们的系统中注册，我们可能希望在其他服务中执行一些操作。<br/>如在钱包服务中创建钱包，使用通知服务发送电子邮件。<br/>如果我们通过HTTP进行集成，我们将需要调用这些服务来通知它们新的注册。这当然带来了所有HTTP的缺点，乘以我们调用的服务数量。<br/>在消息传递的情况下，我们只与Postman集成。我们将使用Postman发布事件消息，任何感兴趣的服务都可以订阅。<br/>收件人可以随时加入或退出订阅。邮递员将负责将消息传递给所有订阅服务。</p><blockquote class="ms mt mu"><p id="fcc0" class="jv jw kt jx b jy jz ka kb kc kd ke kf mv kh ki kj mw kl km kn mx kp kq kr ks ig bi translated">消息传递创建了解耦的解决方案，其中每个服务可以控制它们想要知道(订阅)的内容。</p></blockquote></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="ed76" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">作为命令或事件的操作</h1><p id="ce20" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">在信息传递中，我们发送的一切都是一条信息，然而，我们可以根据我们想如何使用它们来区分两种类型的信息。</p><blockquote class="ms mt mu"><p id="ce95" class="jv jw kt jx b jy jz ka kb kc kd ke kf mv kh ki kj mw kl km kn mx kp kq kr ks ig bi translated">命令是向具体服务发送消息以执行操作的方式。</p></blockquote><p id="1c2a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，当我们向通知服务发送命令“向张诗钟·布拉沃发送电子邮件”时，我们希望它仅被传递给该服务，因为其他服务可能不提供这样的动作。</p><blockquote class="ms mt mu"><p id="0beb" class="jv jw kt jx b jy jz ka kb kc kd ke kf mv kh ki kj mw kl km kn mx kp kq kr ks ig bi translated">事件是发布消息的方式，因此感兴趣的服务可以订阅它。</p></blockquote><p id="c7dc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，我们可以发布声明“订单已下”的事件。我们不是对任何具体的服务说，我们只是陈述刚刚发生的事实。任何它愿意基于该事实采取行动的服务都可以订阅它。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="cc5b" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">摘要</h1><p id="fad5" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">在消息传递中，我们不依赖于其他服务的可用性，因此很难期待响应。这产生了良好的解耦，但是使得消息传递很难用于查询。</p><blockquote class="ms mt mu"><p id="d2c6" class="jv jw kt jx b jy jz ka kb kc kd ke kf mv kh ki kj mw kl km kn mx kp kq kr ks ig bi translated">消息传递对于行动来说很棒，因为它可靠且稳定。它帮助我们保持服务之间的一致性。</p></blockquote><p id="db11" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在下一篇文章中，我们将看到如何使用PHP和<a class="ae nd" href="https://github.com/ecotoneFramework/ecotone" rel="noopener ugc nofollow" target="_blank">生态交错带框架</a>在实践中应用这一理论。<br/> <a class="ae nd" href="https://dariuszgafka.medium.com/starting-with-microservices-in-php-6e3c411f3d27" rel="noopener">点击这里进入下一篇文章。</a></p></div></div>    
</body>
</html>