<html>
<head>
<title>Importing Modules in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Python 中导入模块</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/importing-modules-in-python-ef4a514870bf?source=collection_archive---------0-----------------------#2020-09-03">https://blog.devgenius.io/importing-modules-in-python-ef4a514870bf?source=collection_archive---------0-----------------------#2020-09-03</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="0635" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">让我们了解一下在 python 中导入模块的不同方法。</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/52f67734545a4abba7e590d4659dcac0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*giKgaGTZOPyjWe6aSYi1RQ.jpeg"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated">来自<a class="ae kw" href="https://www.pexels.com/photo/birds-eye-view-photo-of-freight-containers-2226458/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae kw" href="https://www.pexels.com/@tomfisk?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">汤姆·菲斯克</a>的照片</figcaption></figure><h2 id="14f2" class="kx ky ir bd kz la lb dn lc ld le dp lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">在 Python 中导入模块</h2><h2 id="052b" class="kx ky ir bd kz la lb dn lc ld le dp lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">模块</h2><p id="79a1" class="pw-post-body-paragraph lt lu ir lv b lw lx js ly lz ma jv mb lg mc md me lk mf mg mh lo mi mj mk ml ik bi translated">模块是包含 Python 定义和语句的文件。文件名是模块名加上后缀<code class="fe mm mn mo mp b">.py</code>。模块提供了代码的可重用性。通过使用模块，我们可以对相关的代码进行分组。— <a class="ae kw" href="https://docs.python.org/3/tutorial/modules.html" rel="noopener ugc nofollow" target="_blank"> python 文档</a></p><h2 id="e9eb" class="kx ky ir bd kz la lb dn lc ld le dp lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated"><strong class="ak">本故事涵盖的主题</strong></h2><ol class=""><li id="eee1" class="mq mr ir lv b lw lx lz ma lg ms lk mt lo mu ml mv mw mx my bi translated"><strong class="lv is">导入模块的不同方式。</strong></li></ol><ul class=""><li id="6c32" class="mq mr ir lv b lw mz lz na lg nb lk nc lo nd ml ne mw mx my bi translated">使用 import 语句</li><li id="a56c" class="mq mr ir lv b lw nf lz ng lg nh lk ni lo nj ml ne mw mx my bi translated">使用 from 子句</li><li id="756e" class="mq mr ir lv b lw nf lz ng lg nh lk ni lo nj ml ne mw mx my bi translated">使用 from 子句和*</li></ul><p id="829d" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated">2.<strong class="lv is">模块搜索路径</strong></p><p id="4c9b" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated"><strong class="lv is"> 3。出现的错误</strong></p><ul class=""><li id="f3d2" class="mq mr ir lv b lw mz lz na lg nb lk nc lo nd ml ne mw mx my bi translated">ModuleNotFoundError</li><li id="f320" class="mq mr ir lv b lw nf lz ng lg nh lk ni lo nj ml ne mw mx my bi translated">属性错误</li><li id="0ee0" class="mq mr ir lv b lw nf lz ng lg nh lk ni lo nj ml ne mw mx my bi translated">导入错误</li><li id="8fd2" class="mq mr ir lv b lw nf lz ng lg nh lk ni lo nj ml ne mw mx my bi translated">名称错误</li></ul></div><div class="ab cl nn no hv np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ik il im in io"><h2 id="813f" class="kx ky ir bd kz la lb dn lc ld le dp lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">导入模块的不同方式。</h2><ol class=""><li id="91f8" class="mq mr ir lv b lw lx lz ma lg ms lk mt lo mu ml mv mw mx my bi translated"><strong class="lv is">使用导入语句</strong></li></ol><p id="e313" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated"><code class="fe mm mn mo mp b">import modulename</code></p><p id="3689" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated">导入语句分两步执行:</p><ol class=""><li id="2372" class="mq mr ir lv b lw mz lz na lg nb lk nc lo nd ml mv mw mx my bi translated">找到一个模块，加载并初始化它(如果需要的话)</li><li id="1083" class="mq mr ir lv b lw nf lz ng lg nh lk ni lo nj ml mv mw mx my bi translated">在本地命名空间中为 import 语句出现的范围定义一个或多个名称。</li></ol><p id="e98e" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated">导入的模块名放在导入模块的全局符号表中。只放置模块名，而不放置模块中的函数、变量或类名。所以，如果我们想从导入的模块中访问函数或变量，就必须通过提及<br/><code class="fe mm mn mo mp b">modname.fnname</code>-用于访问函数<br/><code class="fe mm mn mo mp b">modname.varname</code>-用于访问变量</p><p id="f740" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated"><strong class="lv is">例如:</strong></p><ul class=""><li id="2a7e" class="mq mr ir lv b lw mz lz na lg nb lk nc lo nd ml ne mw mx my bi translated">我已经创建了一个文件<strong class="lv is">“add . py”</strong>。它包含变量<code class="fe mm mn mo mp b"> a</code>、<code class="fe mm mn mo mp b">b</code>和函数<code class="fe mm mn mo mp b">a1</code>。</li></ul><pre class="kh ki kj kk gu nu mp nv nw aw nx bi"><span id="984e" class="kx ky ir mp b gz ny nz l oa ob">x=5<br/>y=10<br/><strong class="mp is">def </strong>a1(a,b):<br/>    <strong class="mp is">return </strong>(a+b)</span></pre><ul class=""><li id="5dc9" class="mq mr ir lv b lw mz lz na lg nb lk nc lo nd ml ne mw mx my bi translated">现在，必须将这个模块导入到另一个文件<strong class="lv is"> "calc.py" </strong></li></ul><p id="bc79" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated">导入的模块名(add.py)只放在导入模块的(calc.py)全局符号表中。</p><blockquote class="oc od oe"><p id="c6b6" class="lt lu of lv b lw mz js ly lz na jv mb og nk md me oh nl mg mh oi nm mj mk ml ik bi translated"><strong class="lv is">导入添加→导入</strong> <code class="fe mm mn mo mp b"><strong class="lv is">add</strong></code> <strong class="lv is">并有界</strong> <code class="fe mm mn mo mp b"><strong class="lv is">locally</strong></code></p></blockquote><p id="2286" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated">因此，访问函数 a1 为<br/> <code class="fe mm mn mo mp b">add.a1()</code></p><p id="edb1" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated">访问变量如<br/> <code class="fe mm mn mo mp b">add.x</code> <br/> <code class="fe mm mn mo mp b">add.y</code></p><pre class="kh ki kj kk gu nu mp nv nw aw nx bi"><span id="6bdc" class="kx ky ir mp b gz ny nz l oa ob"><strong class="mp is">import </strong>add<br/>print (add.a1(4,5))<br/><em class="of">#Output:9<br/><br/></em>print (add.x)<em class="of">#Output:5<br/></em>print (add.y)<em class="of">#Output:10</em></span></pre><h2 id="edd1" class="kx ky ir bd kz la lb dn lc ld le dp lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">分配一个本地名称</h2><p id="ccd4" class="pw-post-body-paragraph lt lu ir lv b lw lx js ly lz ma jv mb lg mc md me lk mf mg mh lo mi mj mk ml ik bi translated">我们可以为导入的模块或<code class="fe mm mn mo mp b">modname.fnname </code>指定一个本地名称，并在程序中使用它</p><p id="8b16" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated">为导入的模块指定本地名称，如</p><p id="1d10" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated"><code class="fe mm mn mo mp b">import add as a</code></p><blockquote class="oc od oe"><p id="08d1" class="lt lu of lv b lw mz js ly lz na jv mb og nk md me oh nl mg mh oi nm mj mk ml ik bi translated"><strong class="lv is">导入添加为 a →导入</strong> <code class="fe mm mn mo mp b"><strong class="lv is">add</strong></code> <strong class="lv is">并有界为</strong> <code class="fe mm mn mo mp b"><strong class="lv is">a</strong></code></p></blockquote><p id="ddb4" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated">示例:</p><p id="0a15" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated">在这个程序中，我们可以使用本地名称来引用导入的模块</p><pre class="kh ki kj kk gu nu mp nv nw aw nx bi"><span id="ad27" class="kx ky ir mp b gz ny nz l oa ob"><strong class="mp is">import </strong>add <strong class="mp is">as </strong>a<br/>print (a.a1(4,5))<br/><em class="of">#Output:9<br/><br/></em>print (a.x)<em class="of">#Output:5</em></span></pre><p id="653b" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated">为 modname.fnname 指定本地名称，如</p><p id="1ab3" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated">b=add.a1</p><p id="fdad" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated">我们可以使用本地名称从导入的模块中访问函数。</p><pre class="kh ki kj kk gu nu mp nv nw aw nx bi"><span id="2528" class="kx ky ir mp b gz ny nz l oa ob"><strong class="mp is">import </strong>add<br/>n=add.a1<br/>print (n(3,4))<br/><em class="of">#Output:7</em></span></pre></div><div class="ab cl nn no hv np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ik il im in io"><p id="95f1" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated"><strong class="lv is"> 2。使用 from 子句</strong></p><p id="a2c7" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated"><code class="fe mm mn mo mp b">from modname import fn1,fn2,var1</code></p><ol class=""><li id="f0b7" class="mq mr ir lv b lw mz lz na lg nb lk nc lo nd ml mv mw mx my bi translated">首先，它将找到在<code class="fe mm mn mo mp b"> from </code>子句中指定的模块，加载它，并在必要时初始化它。</li><li id="18a8" class="mq mr ir lv b lw nf lz ng lg nh lk ni lo nj ml mv mw mx my bi translated">对于在<code class="fe mm mn mo mp b">import</code>子句<br/> *中指定的每个标识符，检查导入的模块是否具有该名称的属性<br/> *如果没有，尝试导入具有该名称的子模块，然后再次检查导入的模块的属性<br/> *如果没有找到该属性，则引发<code class="fe mm mn mo mp b">ImportError</code>。<br/> *否则，对该值的引用存储在本地名称空间中，使用<code class="fe mm mn mo mp b">as</code>子句中的名称(如果存在的话)，否则使用属性名称</li></ol><p id="2d0d" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated"><strong class="lv is">例子</strong></p><p id="3132" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated">此 import 语句将模块中的名称直接导入到导入模块的符号表中。</p><p id="74cd" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated">所以我们可以直接访问函数和变量，而不用提到模块名。</p><blockquote class="oc od oe"><p id="5589" class="lt lu of lv b lw mz js ly lz na jv mb og nk md me oh nl mg mh oi nm mj mk ml ik bi translated">从添加导入 a1，x→导入<code class="fe mm mn mo mp b">add</code>和<code class="fe mm mn mo mp b">add.a1</code>有界为<code class="fe mm mn mo mp b">a1</code>，<code class="fe mm mn mo mp b">add.x</code>有界为<code class="fe mm mn mo mp b"> x</code></p></blockquote><pre class="kh ki kj kk gu nu mp nv nw aw nx bi"><span id="31f8" class="kx ky ir mp b gz ny nz l oa ob"><strong class="mp is">from </strong>add <strong class="mp is">import </strong>a1,x<br/>print (a1(2,3))<em class="of">#Output:5<br/></em>print (x)<em class="of">#Output:5</em></span></pre></div><div class="ab cl nn no hv np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ik il im in io"><p id="6e6a" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated"><strong class="lv is"> 3。使用 from 子句和* </strong></p><p id="b26e" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated">它将导入模块定义的所有名称。我们可以直接访问导入模块中的所有名称。</p><pre class="kh ki kj kk gu nu mp nv nw aw nx bi"><span id="7f22" class="kx ky ir mp b gz ny nz l oa ob"><strong class="mp is">from </strong>add <strong class="mp is">import </strong>*<br/>print (a1(2,3))<em class="of">#Output:5<br/></em>print (x)<em class="of">#Output:5</em></span></pre><p id="6ee5" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated"><strong class="lv is">注意:</strong>这将导入除下划线(<code class="fe mm mn mo mp b">_</code>)开头的名称之外的所有名称。在大多数情况下，Python 程序员不使用这个工具，因为它向解释器中引入了一组未知的名称，可能隐藏了一些您已经定义的内容。</p></div><div class="ab cl nn no hv np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ik il im in io"><h2 id="9392" class="kx ky ir bd kz la lb dn lc ld le dp lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">模块搜索路径</h2><p id="5fa2" class="pw-post-body-paragraph lt lu ir lv b lw lx js ly lz ma jv mb lg mc md me lk mf mg mh lo mi mj mk ml ik bi translated">第一次导入模块时</p><ol class=""><li id="427f" class="mq mr ir lv b lw mz lz na lg nb lk nc lo nd ml mv mw mx my bi translated">解释器首先搜索内置模块</li><li id="2b8e" class="mq mr ir lv b lw nf lz ng lg nh lk ni lo nj ml mv mw mx my bi translated">然后，它将在变量 sys.path 给出的目录列表中搜索该文件。</li></ol><p id="e7f2" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated"><code class="fe mm mn mo mp b">sys.path</code>从这些位置初始化</p><ol class=""><li id="1af9" class="mq mr ir lv b lw mz lz na lg nb lk nc lo nd ml mv mw mx my bi translated">当前目录(包含输入脚本的目录)</li><li id="3e01" class="mq mr ir lv b lw nf lz ng lg nh lk ni lo nj ml mv mw mx my bi translated">带有目录列表的环境变量</li><li id="9700" class="mq mr ir lv b lw nf lz ng lg nh lk ni lo nj ml mv mw mx my bi translated">安装相关目录</li></ol><pre class="kh ki kj kk gu nu mp nv nw aw nx bi"><span id="1d95" class="kx ky ir mp b gz ny nz l oa ob"><strong class="mp is">import </strong>sys<br/>print (sys.path)</span></pre><p id="248e" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated">它将列出所有模块的搜索路径</p><p id="8dba" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated">如果我们想在搜索路径中添加任何目录，我们可以使用<code class="fe mm mn mo mp b">sys.path.append()</code>来添加</p><pre class="kh ki kj kk gu nu mp nv nw aw nx bi"><span id="e017" class="kx ky ir mp b gz ny nz l oa ob"><strong class="mp is">import </strong>sys<br/>sys.path.append(<strong class="mp is">"C:\indhuProject"</strong>)</span></pre><p id="0834" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated">现在，导入的模块也将在这个路径中搜索。像这样，我们也可以从不同的目录导入模块。</p></div><div class="ab cl nn no hv np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ik il im in io"><h2 id="05cc" class="kx ky ir bd kz la lb dn lc ld le dp lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">引发的错误</h2><ol class=""><li id="145d" class="mq mr ir lv b lw lx lz ma lg ms lk mt lo mu ml mv mw mx my bi translated">ModuleNotFoundError</li><li id="1867" class="mq mr ir lv b lw nf lz ng lg nh lk ni lo nj ml mv mw mx my bi translated">属性错误</li><li id="9351" class="mq mr ir lv b lw nf lz ng lg nh lk ni lo nj ml mv mw mx my bi translated">导入错误</li><li id="487c" class="mq mr ir lv b lw nf lz ng lg nh lk ni lo nj ml mv mw mx my bi translated">名称错误</li></ol><p id="6758" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated">1.<strong class="lv is"> ModuleNotFoundError </strong></p><p id="e070" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated">如果导入的模块不存在，意味着它将引发<code class="fe mm mn mo mp b">ModuleNotFoundError</code></p><p id="693d" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated"><strong class="lv is">例 1 </strong></p><pre class="kh ki kj kk gu nu mp nv nw aw nx bi"><span id="f9ca" class="kx ky ir mp b gz ny nz l oa ob"><strong class="mp is">from </strong>sub <strong class="mp is">import </strong>a1,x<br/>print (x)<br/><em class="of">#Output:ModuleNotFoundError: No module named 'sub'</em></span></pre><p id="e9fc" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated">示例 2</p><pre class="kh ki kj kk gu nu mp nv nw aw nx bi"><span id="6e91" class="kx ky ir mp b gz ny nz l oa ob"><strong class="mp is">import </strong>sub<br/>print (x)<br/><em class="of">#Output:ModuleNotFoundError: No module named 'sub'</em></span></pre><p id="1776" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated"><strong class="lv is"> 2。属性错误</strong></p><p id="4c67" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated">当从导入的模块中访问函数/变量时，如果它不存在意味着，它将引发<code class="fe mm mn mo mp b">AttributeError</code>。</p><pre class="kh ki kj kk gu nu mp nv nw aw nx bi"><span id="9dff" class="kx ky ir mp b gz ny nz l oa ob"><strong class="mp is">import </strong>add<br/>print (add.a2(1,2))<br/><em class="of">#Output:AttributeError: module 'add' has no attribute 'a2'</em></span></pre><p id="9ba6" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated"><strong class="lv is"> 3。导入错误</strong></p><p id="5802" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated">使用 from 子句，当我们正在导入时，如果属性不可用意味着它将引发<code class="fe mm mn mo mp b">ImportError</code></p><pre class="kh ki kj kk gu nu mp nv nw aw nx bi"><span id="2a1b" class="kx ky ir mp b gz ny nz l oa ob"><strong class="mp is">from </strong>add <strong class="mp is">import </strong>s2,x<br/>print (x)<br/><em class="of">#Output:ImportError: cannot import name 's2' from 'add'</em></span></pre><p id="5cad" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated"><strong class="lv is"> 4。名称错误</strong></p><p id="6167" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated">如果我们使用 import 语句，如果我们直接访问函数名和变量名，就会引发<code class="fe mm mn mo mp b">NameError.</code></p><p id="4d74" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated">我们应该像<code class="fe mm mn mo mp b">modname.varname</code>一样访问</p><p id="a6f5" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated"><strong class="lv is">例 1: </strong></p><pre class="kh ki kj kk gu nu mp nv nw aw nx bi"><span id="6067" class="kx ky ir mp b gz ny nz l oa ob"><strong class="mp is">import </strong>add<br/>print (a1(4,5))<br/><em class="of">#Output:NameError: name 'a1' is not defined</em></span><span id="2f0c" class="kx ky ir mp b gz oj nz l oa ob">print (x)<em class="of">#Output:NameError: name 'x' is not defined</em></span></pre><p id="2f65" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated"><strong class="lv is">例二:</strong></p><p id="a8d6" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated">如果我们为模块创建一个本地名称，那么我们必须使用这个本地名称来引用导入的模块。否则它将引发 NameError</p><pre class="kh ki kj kk gu nu mp nv nw aw nx bi"><span id="9b45" class="kx ky ir mp b gz ny nz l oa ob"><strong class="mp is">import </strong>add <strong class="mp is">as </strong>a<br/>print (add.x)<br/><em class="of">#Output:NameError: name 'add' is not defined</em></span></pre><p id="1276" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated"><strong class="lv is">例 3: </strong></p><p id="ca3b" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated">如果我们使用 from 子句导入，它将把名字从模块直接导入到导入模块的符号表中。所以我们可以直接访问 import 语句中提到的函数名/变量名。</p><p id="d981" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated">如果我们提到 modname.fnname()，就会引发<strong class="lv is"> NameError </strong>。</p><pre class="kh ki kj kk gu nu mp nv nw aw nx bi"><span id="cb0d" class="kx ky ir mp b gz ny nz l oa ob"><strong class="mp is">from </strong>add <strong class="mp is">import </strong>a1<br/>print (add.a1(3,4))<br/><em class="of">#Output:NameError: name 'add' is not defined</em></span></pre></div><div class="ab cl nn no hv np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ik il im in io"><h2 id="557f" class="kx ky ir bd kz la lb dn lc ld le dp lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">结论:</h2><p id="84b2" class="pw-post-body-paragraph lt lu ir lv b lw lx js ly lz ma jv mb lg mc md me lk mf mg mh lo mi mj mk ml ik bi translated">import 语句将在<code class="fe mm mn mo mp b">sys.path</code>提到的路径中寻找模块。如果我们想从任何其他路径导入，使用命令<code class="fe mm mn mo mp b">sys.path.append()</code>将该路径包含在 sys.path 中</p><pre class="kh ki kj kk gu nu mp nv nw aw nx bi"><span id="fd0e" class="kx ky ir mp b gz ny nz l oa ob">import add →Imported <em class="of">add</em> and bounded <em class="of">locally<br/></em>import add as a → Imported <em class="of">add</em> and bounded as <em class="of">a<br/></em>from add import a1,x→ Imported <em class="of">add</em> and <em class="of">add.a1</em> bounded as <em class="of">a1</em>,<em class="of">add.x</em> bounded as<em class="of"> x</em></span></pre></div><div class="ab cl nn no hv np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ik il im in io"><h2 id="323f" class="kx ky ir bd kz la lb dn lc ld le dp lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated"><strong class="ak">资源(Python 文档):</strong></h2><p id="a37c" class="pw-post-body-paragraph lt lu ir lv b lw lx js ly lz ma jv mb lg mc md me lk mf mg mh lo mi mj mk ml ik bi translated"><a class="ae kw" href="https://docs.python.org/3/tutorial/modules.html" rel="noopener ugc nofollow" target="_blank">模块</a></p><p id="b3a1" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated"><a class="ae kw" href="https://docs.python.org/3/reference/simple_stmts.html#import" rel="noopener ugc nofollow" target="_blank">导入声明</a></p><h2 id="e42a" class="kx ky ir bd kz la lb dn lc ld le dp lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">延伸阅读:</h2><div class="ok ol gq gs om on"><a href="https://medium.com/dev-genius/importing-packages-in-python-fb3f4a64ed14" rel="noopener follow" target="_blank"><div class="oo ab fp"><div class="op ab oq cl cj or"><h2 class="bd is gz z fq os fs ft ot fv fx iq bi translated">在 Python 中导入包</h2><div class="ou l"><h3 class="bd b gz z fq os fs ft ot fv fx dk translated">探索用 python 导入包的不同方法</h3></div><div class="ov l"><p class="bd b dl z fq os fs ft ot fv fx dk translated">medium.com</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb kq on"/></div></div></a></div></div><div class="ab cl nn no hv np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ik il im in io"><p id="161d" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated">请关注此空间，了解更多关于 Python 和数据科学的文章。如果你喜欢看我的更多教程，就关注我的 <a class="ae kw" href="https://medium.com/@IndhumathyChelliah" rel="noopener"> <strong class="lv is"> <em class="of">中</em></strong></a><a class="ae kw" href="https://www.linkedin.com/in/indhumathy-chelliah/" rel="noopener ugc nofollow" target="_blank"><strong class="lv is"><em class="of">LinkedIn</em></strong></a><strong class="lv is"><em class="of"/></strong><a class="ae kw" href="https://twitter.com/IndhuChelliah" rel="noopener ugc nofollow" target="_blank"><strong class="lv is"><em class="of">Twitter</em></strong></a><strong class="lv is"><em class="of">。</em> </strong></p><p id="8416" class="pw-post-body-paragraph lt lu ir lv b lw mz js ly lz na jv mb lg nk md me lk nl mg mh lo nm mj mk ml ik bi translated">感谢阅读！</p></div></div>    
</body>
</html>