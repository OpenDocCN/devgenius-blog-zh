<html>
<head>
<title>The art of simplicity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简单的艺术</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/the-art-of-simplicity-c0b381cc2b7f?source=collection_archive---------0-----------------------#2021-06-05">https://blog.devgenius.io/the-art-of-simplicity-c0b381cc2b7f?source=collection_archive---------0-----------------------#2021-06-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1ba88d70ba91ae32b0507c6aaca6cc27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TehncaWgn2o1he_PCR_5Fg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://www.monkeyuser.com/2019/yagni/" rel="noopener ugc nofollow" target="_blank">https://www.monkeyuser.com/2019/yagni/</a></figcaption></figure><p id="66e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个人都在谈论简单，我们总是想创造简单的东西。但是简单就是为我们的实际问题创造最好的解决方案，而不是更多。找到真正要解决的问题通常是更复杂的事情。考虑到这一点，有些事情是我们无法改变的，我们无法针对要解决的问题的复杂程度做任何事情。所以我们的软件至少会和要解决的问题一样复杂。但是通常软件比试图解决的问题要复杂得多，这是因为我们不遵守YAGNI原则。</p><p id="ea12" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">软件设计很难定义，但在某种程度上，我们可以说它与我们创建的所有抽象相关，以支持解决我们认为我们拥有的问题的算法。这个设计更多的是针对人而不是编译器。所以事实上，我们试图以某种方式塑造我们的代码，只是为了让它对下一个开发人员(或未来的我们自己)来说更容易维护。但是我们通常混淆了可维护性和可扩展性。我们决定在这里添加一个接口，或者在那里添加这个模式，以防将来我们需要添加一个新特性来解决一个主要问题。根据我的经验，意外的复杂性依赖于可扩展性。</p><h2 id="cb9c" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated"><strong class="ak">偶然的复杂性</strong></h2><p id="a414" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">它是由Fred Brooks在他的论文“没有银弹——软件工程中的本质和意外”中定义的。基本上，它指的是我们刚刚在软件中引入的所有复杂性，因为我们作为开发人员、产品所有者、经理等都很糟糕。所有让一个问题变得更加复杂的事情都与问题本身无关，而是与我们的工作方式、公司文化以及我们对未来的看法有关。</p><p id="56c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一些例子:</p><ul class=""><li id="161f" class="lz ma iq kf b kg kh kk kl ko mb ks mc kw md la me mf mg mh bi translated">没有人使用的功能，但保留在系统中，因为我们不想删除一些我们不知道有多少人使用的功能。</li><li id="a594" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated">死代码，不再执行的东西。</li><li id="4b57" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated">代码优化不能解决我们面临的实际情况。</li><li id="fe47" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated"><a class="ae kc" href="https://en.wikipedia.org/wiki/Cargo_cult" rel="noopener ugc nofollow" target="_blank">货物崇拜</a>。</li></ul><p id="3ca6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我看来，对软件设计有一个基本的误解，当我们说我们的设计应该准备好容易地改变时，我们不是在谈论创建一个所有部分都是可插拔的设计。记住肯特·贝克简单设计的四条规则很重要:</p><ul class=""><li id="6618" class="lz ma iq kf b kg kh kk kl ko mb ks mc kw md la me mf mg mh bi translated">通过测试</li><li id="f947" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated">揭示意图(应该容易理解)</li><li id="ff0c" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated">无重复(干)</li><li id="0ea8" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated">最少的元素(删除任何不符合前面三个规则的元素)</li></ul><p id="08ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个元素更少的设计比另一个没有解决真正问题的设计要好。事实上，当我们谈论易于改变的设计时，我们谈论的是:</p><ul class=""><li id="deec" class="lz ma iq kf b kg kh kk kl ko mb ks mc kw md la me mf mg mh bi translated">当我们改变它时识别错误的能力→有一个好的测试套件来提醒我们错误。</li><li id="00df" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated">理解之前存在的内容以及如何添加新功能的能力→清理代码。</li><li id="9c4d" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated">引入快速变化和不重复概念的能力。→干燥原理</li><li id="af35" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated">成为简单可行的设计的能力。→ YAGNI原理</li></ul><p id="7fda" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">YAGNI原理是为了避免创造一个设计来解决一个你没有的问题，这是对抗意外复杂性的方法。</p><h2 id="6ffa" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">复杂的面孔</h2><p id="8177" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">YAGNI应该在我们设计软件时指导我们，同时也指导我们选择解决什么问题。一个问题通常有许多不同的子问题，找到这些子问题并定义它们给我们机会选择首先做什么，并看看我们需要付出多少努力来解决我们的实际问题。有时候我们会在开发过程中理解问题的局限性。例如，假设我们想要为backoffice应用程序创建一个登录页面。我们可以考虑登录后勤办公室的所有不同选项:</p><ul class=""><li id="310d" class="lz ma iq kf b kg kh kk kl ko mb ks mc kw md la me mf mg mh bi translated">谷歌账户</li><li id="2544" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated">用户名/密码</li><li id="15f4" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated">脸书账户</li></ul><p id="a773" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们决定实现所有的东西，我们需要等到所有的组件都准备好了，当我们开始收到反馈时(当代码在生产中时)，我们将冒险验证我们的大多数用户没有使用我们给他们的一些选项。</p><p id="4e10" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们选择只实现一种可能的情况，并且我们用这种情况评估结果，我们可以决定是否在下一种情况上投入更多，或者仅仅是足够了。</p><p id="b7d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第一个场景中，我们将不得不在将来维护为公司很少使用的东西创建的代码，但是他们的工作与最常用的工作是一样的。这也是偶然的复杂性，作为开发人员，我们需要给公司机会来做出更好的决定来解决什么问题。YAGNI在那里对抗偶然的复杂性，并遵循最后负责的时刻原则。</p><h2 id="93b1" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">什么时候考虑未来？</h2><p id="5d73" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">如果我们的代码遵循简单设计的四个规则，那么我们可以增量地改变它(为了下周)。我认为这是一种习惯，我们只需要根据我们的功能、我们新的非功能性需求以及改变当前环境的一切来改变我们的设计。一个重要的考虑是，YAGNI不是来制造混乱的，你需要一个可理解的设计来维护你已经创建的代码。软件设计成为YAGNI的唯一原因是因为系统一旦工作就不再需要维护。如果机器能够编写软件，它们将不再需要设计，设计是为人服务的。</p><p id="163d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以总结一下:</p><blockquote class="mn mo mp"><p id="ed23" class="kd ke mq kf b kg kh ki kj kk kl km kn mr kp kq kr ms kt ku kv mt kx ky kz la ij bi translated"><em class="iq">做好准备。但为了明天，而不是明年。太晚决定是危险的，但是在快速变化的软件开发世界中，太早决定可能更危险。让最后责任时刻的原则成为你的指南。杰夫·阿特伍德—</em><a class="ae kc" href="https://blog.codinghorror.com/the-last-responsible-moment/" rel="noopener ugc nofollow" target="_blank"><em class="iq">https://blog.codinghorror.com/the-last-responsible-moment/</em></a></p></blockquote></div></div>    
</body>
</html>