<html>
<head>
<title>How to use react clean-up function with example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">举例说明如何使用 react 清理功能</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-use-react-clean-up-function-with-example-7a073392e479?source=collection_archive---------0-----------------------#2022-03-17">https://blog.devgenius.io/how-to-use-react-clean-up-function-with-example-7a073392e479?source=collection_archive---------0-----------------------#2022-03-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/03eeec4afce4a60ff03bfec32c944b85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j1bX9qwta0oOPsF55uxU3w.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">图片来自<a class="ae jz" href="https://binarapps.com/clean-up-request-in-useeffect-react-hook/" rel="noopener ugc nofollow" target="_blank">https://binar apps . com/clean-up-request-in-use effect-react-hook/</a></figcaption></figure><p id="3b73" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">目的</strong></p><p id="19f0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">虽然我最近觉得在 react 中使用“生命周期方法”更舒服，这是从 React 组件的诞生到死亡发生的一系列事件。虽然在本文中我不会关注生命周期方法本身，因为有许多资料和文章解释这些方法，但我会关注 react 生命周期中使用的清理功能。</p><p id="b5f0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">什么是清理功能？</strong></p><p id="29d4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该清除功能用于清除旧副作用的影响。就功能组件而言，在 useEffect 中调用回调函数之前，必须调用该函数。说到类组件，“componentWillUnmount”相当于一个清理函数。</p><p id="40ce" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请看下图。这是生命周期方法的整个流程。我没有解释整个流程，这是“浏览器显示 DOM”和“运行副作用”之间的过程。</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ky"><img src="../Images/e0a1d15351fa7f3b6f5a527bcb0cfb7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WS75frWMrXMiF1hSMn2hgg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">图片来自<a class="ae jz" href="https://github.com/learn-co-curriculum/react-hooks-use-effect-cleanup" rel="noopener ugc nofollow" target="_blank">https://github . com/learn-co-course/react-hooks-use-effect-clean up</a></figcaption></figure><p id="c7e4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">为什么我们需要清理功能？</strong></p><p id="6b36" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">基本上，防止内存泄漏，这是使用一些不必要的空间，因为忘记清理功能或运行。它仍然在工作，所以有人(尤其是初学者)认为我们不需要关心内存泄漏，但它是必不可少的，以提高网站速度和计算机的性能进行优化。</p><p id="dbee" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">这种情况需要一个清除功能</strong></p><p id="982c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">数据获取(如果在组件消失后收到响应)</p><p id="6840" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">事件监听器(定时器、订阅)</p><p id="8c7c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您需要将此功能用于如上所述的“连续”或“异步”任务。</p><p id="f0a5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">清理函数的语法。</strong></p><p id="ae7e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">基本语法如下。返回之后，在回调函数内部，你需要放一个清理函数。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="643b" class="li lj in le b gy lk ll l lm ln">useEffect(() =&gt; {<br/> // some functions<br/>  return () =&gt; {<br/>    // cleanup function<br/>  }<br/>}, [])</span></pre><p id="9bad" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">一个清理功能的例子。</strong></p><p id="3393" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我刚刚使用“创建反应应用程序”创建了一个简单的反应计时器应用程序。“App.js”是通过点击按钮来显示一个可见或隐藏的计时器。</p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="4307" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">“Timer.js”是当一个定时器改变为显示可视时启动一个定时器。我创建了一个 countIncrement 函数来改变状态，并在 setinterval 中使用。</p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="bb67" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下图是实际应用。</p><p id="09dd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我点击左上方的“visible”按钮时，计时器可见并开始计时(控制台“动作”)。当我点击重置按钮时，计时器会立即停止并重新启动。然后，当我单击左上角的隐藏按钮(它取代了可见按钮)时，计时器将被隐藏，计时器也将被停止(并且控制台“删除”)。</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/d16c2e727d93ff1359673f23720ab905.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*wq4zdWQdMnGeMFWR02ksZA.gif"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">清理成功</figcaption></figure><p id="4ae2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我在代码中删除了一个清理函数，当我单击“隐藏”按钮时，将会出现如下错误。</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/f96c7f6275f38261091226d47707cfea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*DYAKFRyb5X7h3I6-kMOIAQ.gif"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">清除错误</figcaption></figure><figure class="kz la lb lc gt jo gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/3caf078004cdeaa3b57e951bdda3da90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*3k06CoyZONejQwo07TBfbw.png"/></div></figure><p id="82ce" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的错误警告为防止内存泄漏添加了一个清理功能。</p><p id="a804" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我去掉注释，添加一个清理函数，这个错误就会消失。</p><p id="d8ac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">结论</strong></p><p id="ab75" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当你一步一步熟悉 react 的时候，你应该更多地关注如何避免浪费计算机资源。这个清理功能是用于改进的，所以这是一个非常重要的实现良好实践的方法。</p><p id="2dff" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">参考</strong></p><p id="a421" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">了解 React 的 useEffect 清理功能:<a class="ae jz" href="https://blog.logrocket.com/understanding-react-useeffect-cleanup-function/#:~:text=The%20cleanup%20function%20prevents%20memory,cleanup%20%7D%20%7D%2C%20%5Binput%5D)" rel="noopener ugc nofollow" target="_blank">https://blog . log rocket . com/understanding-React-use effect-clean up-function/#:~:text = The % 20 clean up % 20 function % 20 prevents % 20 memory，clean up % 20% 7D % 20% 7D % 2C % 20% 5b input % 5D)</a></p><p id="23ef" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">React useEffect cleanup:如何以及何时使用:<a class="ae jz" href="https://dev.to/otamnitram/react-useeffect-cleanup-how-and-when-to-use-it-2hbm" rel="noopener ugc nofollow" target="_blank">https://dev . to/otamnitram/react-use effect-clean up-How-and-when-to-use-it-2hbm</a></p><p id="32eb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用效果挂钩:<a class="ae jz" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/hooks-effect.html</a></p><p id="3051" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi">【React】useEffectの基本的な使い方・活用術・注意点: <a class="ae jz" href="https://qiita.com/cheez921/items/f3ff76865f943345107c" rel="noopener ugc nofollow" target="_blank">https://qiita.com/cheez921/items/f3ff76865f943345107c</a></p><p id="0326" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi"><a class="ae jz" href="https://takamints.hatenablog.jp/entry/cleanup-an-async-use-effect-hook-of-react-function-componet" rel="noopener ugc nofollow" target="_blank">React：非同期の副作用フック(useEffect)で正しくクリーンアップする</a>: <a class="ae jz" href="https://takamints.hatenablog.jp/entry/cleanup-an-async-use-effect-hook-of-react-function-componet" rel="noopener ugc nofollow" target="_blank">https://takamints.hatenablog.jp/entry/cleanup-an-async-use-effect-hook-of-react-function-componet</a></p><p id="645c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">感谢您的阅读！！</p></div></div>    
</body>
</html>