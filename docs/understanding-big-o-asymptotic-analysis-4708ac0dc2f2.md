# 理解大 O 渐近分析

> 原文：<https://blog.devgenius.io/understanding-big-o-asymptotic-analysis-4708ac0dc2f2?source=collection_archive---------10----------------------->

![](img/7a12a0b85a5ba996b36bbfb2134295c0.png)

作为软件工程师，我们的使命是解决一些最困难的问题。随着截止日期的临近，我们倾向于将在截止日期前交付产品作为我们的首要任务，通常以此来换取编写好的代码。作为一名工程师，理解大 O 的概念有助于理解随着用户数量的增加，您发布的代码执行得有多好。

# 什么是好的代码？

好的代码是可读的、可重用的、可维护的和可伸缩的。今天，我们将更多地关注编写优秀代码的可伸缩性方面。代码的可伸缩性意味着什么？

有两个因素定义了可伸缩性这个词:

*   速度和
*   记忆

# 时间复杂度

在衡量代码可伸缩性时，时间是我们要注意的事情之一。执行代码需要多长时间——运行时？当你的输入量持续增长时呢？你的代码执行起来会慢很多吗？

# 空间复杂性

我们要注意的另一件事是你的代码为了执行需要使用多少额外的内存。随着输入大小的增加，执行代码需要多少内存？

通常，在分析代码时，我们必须在速度和内存或内存和速度之间做出权衡。为了测量我们代码的可伸缩性，我们使用了一个叫做**的概念，也叫做大 O 渐近分析。**

# 计算大 O

计算算法的大 O 值时，有两个主要因素需要注意:

1.  操作次数
2.  元素数量或输入大小

# 线性时间— O(n)

线性时间是你会遇到的最常见的复杂性之一。顾名思义，当时间**与输入大小**成正比时，我们说算法具有线性时间复杂度或 O(n)(读作 n 的大 O)。也就是说，执行代码的时间随着输入大小的增加而增加。为了进一步解释，请看下面的代码。

从上面的代码中，我们得到了一个只包含一项的数组——一个字符串，`findNemo`函数将一个数组作为输入，一个`for loop`函数遍历数组中的所有项并检查数组中的项是否严格等于字符串“nemo ”,并记录“found nemo！!'到控制台。

这意味着无论数组的大小如何，我们都要遍历每一项，这将耗费我们的时间。因此，执行该操作的时间完全取决于输入的大小。为了进一步解释这个概念，请考虑复制并执行下面的代码片段:

我们使用 JS 内置的性能对象来跟踪执行这段代码所花费的时间。预期的输出大约是`0.09999996423721313`毫秒。你使用的计算机类型和你的 CPU 速度可能会影响这个答案，但一般来说，你应该期待大约 0.x 毫秒。现在让我们尝试增加传递给 findNemo 函数的输入的大小。

现在将输入的大小从 1 增加到 100，我们得到了`4.700000047683716`和`9.200000047683716`之间的值；执行时间的显著变化。这是因为操作的数量，在这种情况下，`for loop`在每个项目上运行，从而随着输入大小的增加而增加执行时间。

# 常数时间— O(1)

当运算次数与输入大小无关时，我们说一个算法在恒定时间内运行。也就是说，无论输入大小，运算次数都不变。

例如，给定下面的代码:

我们有一个数字数组和一个名为 findFirstItem 的函数，它将数组中的第一项记录到控制台。

我们意识到，无论数组的大小如何，运算次数都不会增加。我们所做的就是获取第一个项目并将其记录到控制台。

因此，不依赖于输入大小的操作被称为以常数时间或 O(1)运行。

# 二次时间— O(n)

当运算次数根据输入增加两倍时，我们说算法以二次时间运行。输入大小每增加一次，计算时间就会增加输入大小的平方。

当有嵌套循环时，通常会出现这种情况。例如，如果我们想要打印一对数字，如下面的代码片段所示:

为了打印出这一对，我们循环遍历每个项目，对于每个第一个项目，我们循环遍历项目本身以及其他项目。

如果您仍然不明白这是如何工作的，请尝试在您的控制台中运行代码以查看其输出。

我们已经处理过 O(n ),现在我们有两个 O(n ),嵌套在它自身中，因此我们将 O(n)乘以 O(n ):

```
O(n) * O(n)  = O(n^2)
```

# 计算大 O 的规则

在经历了主要的大 O 复杂性之后，在计算时，当在技术面试中被问到关于大 O 的问题时，为了给出正确的答案，你必须注意某些规则。

# 规则 1

**看看最坏的情况。**

在计算时，我们会考虑代码可能发生的最坏情况，比如用户规模增长到大约 10 亿。你的代码还能伸缩吗？

# 规则 2

**删除常量**

在考虑了最坏的情况之后，从宏观的角度来看，常量被忽略了。

考虑一下这个:

当我们的函数被调用时，我们记录到控制台，“这个函数已经被调用”。然后我们让函数打印它的配对。

结论将是:

```
O(1) + O(n) * O(n) = O(1 + n^2)
```

当要求计算这个 printPair 函数的大 O 值时，我们忽略了常数，在这种情况下是 O(1 ),因此最终答案将是 O(n)。因为从大的方面来看，O(1)不会对我们代码的速度有任何显著的影响。

# 规则 3

**区别对待输入**

许多人在计算大 O 时忽略的一件事是，当他们有不同的输入时，他们将它们视为相同。

例如:

而不是最终的答案是:

```
O(n) + O(n) = O(2n)
```

它应该是:

```
O(a) + O(b) = O(a + b)
```

两个独立的输入应该有两个独立的变量。不用太担心这个答案里没有 n。是一个需要理解的概念。

# 规则 4

**放下非支配者**

就像我们在第二个规则中去掉常数一样，因为我们着眼于更大的图景，出于同样的原因，我们在这里也去掉了非支配者。

因此，如果我们有一个总计为 O(n + n)的计算，我们就去掉 O(n)。因此，我们的最终答案是 O(n)。因此，确保你的最终答案总是指向复杂性。

# 结论

总之，Big O 不仅仅是一个理论，而是一个工具，我们不仅可以利用它来构建有效的应用程序，还可以构建高效的应用程序。所以，下一次你写代码的时候，问问你自己，“当我有大约 76 亿人使用我的应用程序时，这些代码能有多好的伸缩性”？

*更多内容尽在*[*blog . dev genius . io*](http://blog.devgenius.io)*。*