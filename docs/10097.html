<html>
<head>
<title>Flask Blog tutorial with Hexagonal Architecture(part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">六边形架构的 Flask 博客教程(第 1 部分)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/flask-blog-tutorial-with-hexagonal-architecture-part-1-6446e7e9aaaa?source=collection_archive---------4-----------------------#2022-10-07">https://blog.devgenius.io/flask-blog-tutorial-with-hexagonal-architecture-part-1-6446e7e9aaaa?source=collection_archive---------4-----------------------#2022-10-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/5688fb3df07e18fc85641b31358a5003.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ebUHgG6JwawEifXlARgfzg.png"/></div></div></figure><p id="3ce7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">图片来自:<br/><a class="ae kt" href="http://thinkmicroservices.com/blog/2019/hexagonal-architecture.html" rel="noopener ugc nofollow" target="_blank">http://thinkmicroservices . com/blog/2019/hexagon-architecture . html</a></p><p id="3ad4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://github.com/ShahriyarR/hexagonal-flask-blog-tutorial" rel="noopener ugc nofollow" target="_blank">该项目的 GitHub 回购</a></p><p id="9f18" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">&gt;<a class="ae kt" href="https://rzayev-sehriyar.medium.com/flask-blog-tutorial-with-hexagonal-architecture-part-2-8930ca009c27" rel="noopener">本系列第二部</a></p><p id="de51" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">&gt;<a class="ae kt" href="https://rzayev-sehriyar.medium.com/flask-blog-tutorial-with-hexagonal-architecture-part-3-9a265f0c4b95" rel="noopener">本系列第三部</a></p><p id="c110" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">想法是借助依赖注入重写官方<a class="ae kt" href="https://flask.palletsprojects.com/en/2.2.x/tutorial/" rel="noopener ugc nofollow" target="_blank"> Flask 博客教程</a>，遵循六边形架构。</p><p id="9e60" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以从这里区分并查看原始代码库:<a class="ae kt" href="https://github.com/pallets/flask/tree/main/examples/tutorial/flaskr" rel="noopener ugc nofollow" target="_blank"> Flask 博客教程代码库</a></p><p id="8f02" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所有的静态数据和模板都是从最初的博客文章中抓取的。</p><p id="0fbc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个项目应该给出一个我们如何使用 Python、Flask 和 DI 实现端口和适配器(六角形)架构的想法。</p><p id="56a3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最终的项目结构如下所示:</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="ky kz l"/></div></figure><h1 id="05aa" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">关于六角形建筑</h1><p id="e26d" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">可以看原作者的:</p><p id="b9f9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://alistair.cockburn.us/hexagonal-architecture/" rel="noopener ugc nofollow" target="_blank">模式:端口和适配器</a></p><h1 id="b3c2" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">关于项目相关性</h1><p id="956d" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">该项目有两个主要依赖项:</p><p id="42af" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://github.com/ets-labs/python-dependency-injector" rel="noopener ugc nofollow" target="_blank">依赖注入器</a></p><p id="6997" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://github.com/pallets/flask" rel="noopener ugc nofollow" target="_blank">烧瓶</a></p><h1 id="23c1" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">入门指南</h1><p id="ee14" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">现在，让我们深入了解我们所拥有的，以及如何将这个原始的 flask 博客教程代码转换成一个干净的、可维护的六边形架构。</p><p id="bcda" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从概念上讲，我们需要通过将领域模型置于应用程序的核心来将领域模型与外部世界分离开来。这意味着我们需要首先考虑我们的领域模型。同样不是关于数据库，不是关于 flask，也不是关于 docker 等等，想想你的应用程序的核心是什么。</p><p id="a7b1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最好是提出问题:</p><ul class=""><li id="23ae" class="md me in jx b jy jz kc kd kg mf kk mg ko mh ks mi mj mk ml bi translated">问:这到底是什么应用程序？—至于官方的 Flask 教程，这是一个博客应用程序，它需要两件事情来工作:用户登录和博客被写。</li><li id="a539" class="md me in jx b jy mm kc mn kg mo kk mp ko mq ks mi mj mk ml bi translated">问:这个用户到底是谁？是什么让“某样东西”成为用户？——具有唯一 ID、用户名和密码的“某物”可以被视为我们的用户。</li><li id="2eec" class="md me in jx b jy mm kc mn kg mo kk mp ko mq ks mi mj mk ml bi translated">问:那么什么是博客文章呢？—博客文章将有作者 id、标题、正文，可能还有创建时间。带有该信息的“某些东西”将被视为博客帖子。</li></ul><p id="4f93" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">酷，我们已经定义了我们的模型，是时候实现它们了。</p><blockquote class="mr ms mt"><p id="26f7" class="jv jw mu jx b jy jz ka kb kc kd ke kf mv kh ki kj mw kl km kn mx kp kq kr ks ig bi translated">请记住，领域模型不是数据库模型，我们甚至不考虑数据库。数据库是一个细节。</p></blockquote><h1 id="13cb" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">实现领域模型</h1><p id="4718" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">我们的领域模型将停留在:<code class="fe my mz na nb b">/src/domain/model</code>路径。所以请创建这些文件夹。</p><p id="fce2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后创建<code class="fe my mz na nb b">user.py</code>和<code class="fe my mz na nb b">post.py</code>，分别代表用户和帖子。</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="ed3d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意创建用户模型并将其返回的工厂方法。理想情况下，在这个工厂方法中应该有一个很好的验证步骤，但是我们已经省略了它，因为原始的 Flask 教程也默默地遮蔽了它:)</p><p id="7c04" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的帖子模型:</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="8a90" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">很简单，也很整洁。</p><h1 id="0e35" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">关于端口的推理。</h1><p id="1b9f" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">由于我们将遵循端口和适配器架构，我们需要首先考虑端口，因为这是 REST API 将要实现和使用的地方。</p><p id="8fa9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我将端口代码放在域端口文件夹<code class="fe my mz na nb b">/src/domain/ports</code>中。</p><blockquote class="mr ms mt"><p id="1305" class="jv jw mu jx b jy jz ka kb kc kd ke kf mv kh ki kj mw kl km kn mx kp kq kr ks ig bi translated"><em class="in">端口是由适配器实现的接口，你马上就会看到。</em></p></blockquote><p id="03c5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">问题:</p><ul class=""><li id="0af6" class="md me in jx b jy jz kc kd kg mf kk mg ko mh ks mi mj mk ml bi translated">问:我们如何持久化我们的用户和发布数据？—好的，我们可以有一个简单的存储库模式，它是一个接受数据库连接的接口或抽象类。</li></ul><p id="6ffd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在端口内创建<code class="fe my mz na nb b">repository.py</code>文件，并放入以下代码:</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="c1cd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">基本上，我们的 Repo 将执行 SQL 语句，然后调用 DB commit。我们在这里没有使用任何形式的 ORM，因为最初的 Flask 博客教程也只使用原始 SQL 和 SQLite。</p><p id="d636" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">问:外界(CLI，REST，任何东西)将如何注册和登录用户？—我们可以拥有有史以来最简单的命令或服务模式，姑且称之为<code class="fe my mz na nb b">user_service.py</code>:</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="110a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，请注意，<code class="fe my mz na nb b">UserService</code>接受<code class="fe my mz na nb b">RepositoryInterface</code>作为参数，作为依赖项。</p><p id="f1ec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用<code class="fe my mz na nb b">user_repo</code>它将保存实际的用户数据。</p><p id="6e19" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另外，请注意用户模型是如何在 create 方法中使用 user_factory 创建的，只有在此之后，用户数据才会被构造并插入到数据库中。</p><p id="488a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是我们如何颠倒存储机制的依赖性，我们的用户模型不依赖于数据库生存，但是数据库动作需要我们的用户做它的工作。</p><ul class=""><li id="2038" class="md me in jx b jy jz kc kd kg mf kk mg ko mh ks mi mj mk ml bi translated">管理岗位怎么样？给你，<code class="fe my mz na nb b">post_service.py</code>:</li></ul><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="d881" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">PostService 再次接受抽象存储库来保存 post 数据。但是我们这里有更有趣的东西。</p><p id="ccb9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我来解释一下<code class="fe my mz na nb b">CreatePostInputDto</code>、<code class="fe my mz na nb b">UpdatePostInputDto</code>、<code class="fe my mz na nb b">DeletePostInputDto</code>背后的想法。</p><p id="2e86" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">同样的问题:</p><ul class=""><li id="c3f5" class="md me in jx b jy jz kc kd kg mf kk mg ko mh ks mi mj mk ml bi translated">我们需要什么样的信息来创建一个 Post 域模型—基本上，post_factory()需要 author_id、body 和 title，创建时间会自动实例化。<code class="fe my mz na nb b">CreatePostInputDto</code>(数据传输对象)只是封装并验证这些信息，post_factory 使用其数据创建 post，然后将其插入数据库。</li><li id="3d80" class="md me in jx b jy mm kc mn kg mo kk mp ko mq ks mi mj mk ml bi translated">我们需要什么样的信息来更新数据库中保存的帖子？— <code class="fe my mz na nb b">UpdatePostInputDto</code>封装并再次验证帖子 id、标题和正文</li><li id="51b2" class="md me in jx b jy mm kc mn kg mo kk mp ko mq ks mi mj mk ml bi translated">从数据库中删除保存的帖子需要什么样的信息？—我们可以通过 id 找到帖子，然后删除它。<code class="fe my mz na nb b">DeletePostInputDto</code>简单地为我们封装了 id。</li></ul><p id="971c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是，为什么我们需要这些 dto 呢？如果您从外部接受一些东西作为输入，如果您返回一些东西作为输出，那么限制、验证并赋予接受和返回的数据一些形状总是更好的。可以把它想象成 web 框架中的请求/响应模型。您接受一些数据作为请求对象的一部分，然后构造一些响应模型并将其返回给用户。</p><p id="140f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我将把这些 dto 放在<code class="fe my mz na nb b">/src/domain/ports/__init__.py</code>中:</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="6122" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第一部分总结:</p><ul class=""><li id="3712" class="md me in jx b jy jz kc kd kg mf kk mg ko mh ks mi mj mk ml bi translated">我们实现了简单的领域模型，没有任何领域事件或其他花哨的东西。</li><li id="7ef9" class="md me in jx b jy mm kc mn kg mo kk mp ko mq ks mi mj mk ml bi translated">我们已经实现了六边形架构的所有端口。</li></ul><blockquote class="mr ms mt"><p id="55c6" class="jv jw mu jx b jy jz ka kb kc kd ke kf mv kh ki kj mw kl km kn mx kp kq kr ks ig bi translated"><em class="in">我们也没有测试，因为最初的 Flask 博客教程残忍地将测试踢出了:D </em></p></blockquote></div></div>    
</body>
</html>