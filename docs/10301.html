<html>
<head>
<title>This in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript 中的这个</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/this-in-javascript-f66d1c8396f9?source=collection_archive---------3-----------------------#2022-10-22">https://blog.devgenius.io/this-in-javascript-f66d1c8396f9?source=collection_archive---------3-----------------------#2022-10-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/34dc0b43f14133ddd921032e6261319a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k5qqwzBC3ZpQ_OrFC2ih0A.png"/></div></div></figure><p id="6fbb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个关键字是最令人困惑的事情之一，它让 JavaScript 开发人员头疼不已。在我看来，大多数开发人员解释<strong class="jx io">这个</strong>关键字就像解释它在其他语言如 Java 中的行为一样。嗯，在 JavaScript 中，<strong class="jx io">这个</strong>在其他语言中的工作方式是它的一个用例。在这篇博文中，我将揭示 JavaScript 中与<strong class="jx io"> this </strong>关键字相关的所有规则。</p><p id="bbb9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在全局执行上下文中，<strong class="jx io">这个</strong>值等于窗口对象。这对于 JavaScript 中的严格和非严格模式是一样的。</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="a045" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然而，对于一个函数的执行上下文来说，<strong class="jx io">这个</strong>关键字的值取决于一个函数是如何被调用的。在 JavaScript 中，可以用 4 种不同的方式调用函数。</p><h2 id="bf64" class="kz la in bd lb lc ld dn le lf lg dp lh kg li lj lk kk ll lm ln ko lo lp lq lr bi translated"><strong class="ak">方法 1:普通函数调用</strong></h2><p id="3cf1" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">在这个场景中，<strong class="jx io">这个</strong>值等于<strong class="jx io">全局对象，</strong>哪个<strong class="jx io"> </strong>是浏览器中的<strong class="jx io">窗口</strong>，使用 NodeJS <strong class="jx io">时等于<strong class="jx io">全局</strong>。</strong></p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="78ae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是，如果我们使用<strong class="jx io">严格模式，未定义的</strong>会被记录到控制台。通过将指令<code class="fe lx ly lz ma b">"use strict"</code>放在文件或函数的开头来启用严格模式。</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><h2 id="85f5" class="kz la in bd lb lc ld dn le lf lg dp lh kg li lj lk kk ll lm ln ko lo lp lq lr bi translated"><strong class="ak">方法 2:方法调用</strong></h2><p id="ab48" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">当一个对象的方法被调用时，<strong class="jx io">这个</strong>等于拥有该方法的对象。在下面的例子中，<strong class="jx io">这个</strong>值等于用来调用它的对象，<strong class="jx io"> obj </strong>。</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><h2 id="ed2e" class="kz la in bd lb lc ld dn le lf lg dp lh kg li lj lk kk ll lm ln ko lo lp lq lr bi translated"><strong class="ak">方法 3:间接调用</strong></h2><p id="4e6d" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">JavaScript 中的函数就像对象一样。它们更具体地被称为<strong class="jx io">可调用对象</strong>。函数在其原型中定义了这两种方法；<strong class="jx io">调用</strong>和<strong class="jx io">应用</strong>。使用这些方法，我们可以设置<strong class="jx io">这个</strong>的值。当使用<strong class="jx io">调用</strong>和<strong class="jx io">应用</strong>方法调用函数时，<strong class="jx io">这个</strong>值等于提供给这些函数的第一个参数。在下面的例子中，<strong class="jx io">这个</strong>等于物体，<strong class="jx io"> obj，</strong>两种情况都是如此。</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><h2 id="6830" class="kz la in bd lb lc ld dn le lf lg dp lh kg li lj lk kk ll lm ln ko lo lp lq lr bi translated"><strong class="ak">方法 4:构造函数调用</strong></h2><p id="7fa2" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">当用<strong class="jx io"> new </strong>关键字调用构造函数时，在这种情况下，<strong class="jx io">这个</strong>值等于<strong class="jx io">新创建的实例。</strong></p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><h1 id="4e64" class="mb la in bd lb mc md me le mf mg mh lh mi mj mk lk ml mm mn ln mo mp mq lq mr bi translated"><strong class="ak">这在箭头功能中</strong></h1><p id="95ad" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">与常规函数相比，<strong class="jx io"> this </strong>关键字在箭头函数中的表现非常不同。箭头函数没有自己的<strong class="jx io">执行上下文。</strong>实际上，<strong class="jx io">这个</strong>是从外部封闭函数或上下文继承而来的。举个例子，</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="ee0a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的例子中，<strong class="jx io">这个</strong>继承自全局执行上下文。这个<strong class="jx io">值等于浏览器中全局执行上下文中的窗口对象。让我们看另一个例子。</strong></p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="38a2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">到目前为止，我们已经确定箭头函数没有自己的执行上下文。因此，在上面的例子中，<strong class="jx io">这个</strong>值等于封闭上下文，它是全局执行上下文。因此，<strong class="jx io">这个</strong>值等于窗口对象。window 对象没有任何<strong class="jx io"> name </strong>属性，导致上例中的输出为<strong class="jx io"> undefined </strong>。</p><h1 id="7322" class="mb la in bd lb mc md me le mf mg mh lh mi mj mk lk ml mm mn ln mo mp mq lq mr bi translated">修复绑定问题</h1><p id="c800" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">考虑这个例子，</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="68f0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为什么我们会得到未定义的输出？原来我们已经失去了这个到<strong class="jx io"> obj </strong>对象的绑定。注意在<strong class="jx io">第 8 行</strong>上，我们没有调用函数<strong class="jx io"> printName </strong>。我们将它的引用存储在一个变量中，供以后使用。调用一个函数和在变量中存储它的引用是两回事。所以当我们调用第 9 行<strong class="jx io">上的函数时，</strong>我们得到<strong class="jx io">未定义的</strong>作为输出。由于没有指定对象，绑定到<strong class="jx io"> obj </strong>对象的<strong class="jx io"> this </strong>丢失。导致<strong class="jx io">这个</strong>等于<strong class="jx io">全局对象</strong>。由于全局对象中没有<strong class="jx io"> name </strong>属性，我们在控制台上得到<strong class="jx io"> undefined </strong>。</p><p id="0d0e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们如何保留<strong class="jx io"> printName </strong>函数的<strong class="jx io"> this </strong>绑定，使得<strong class="jx io"> this </strong>的值总是<strong class="jx io"> obj </strong>对象，无论我们何时何地调用<strong class="jx io"> printName </strong>函数？</p><p id="02ec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在函数的原型中使用<strong class="jx io"> bind </strong>方法可以很容易地解决这个问题。<strong class="jx io"> bind </strong>方法返回一个新函数，其中<strong class="jx io"> this </strong>关键字设置为指定值。与<strong class="jx io">调用</strong>和<strong class="jx io">应用</strong>方法不同，该功能不会被立即调用。因此我们在后面使用由<strong class="jx io">绑定</strong>方法返回的函数。</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="2a64" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> bind </strong>方法固定<strong class="jx io">print name 函数到<strong class="jx io"> obj </strong>对象的这个</strong>绑定。</p><p id="fcab" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我希望这篇文章对你有所帮助。感谢阅读。:)</p><p id="c503" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们来连线:<br/><a class="ae ms" href="https://www.linkedin.com/in/rabi-siddique-b6b4971a0/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a><br/><a class="ae ms" href="https://twitter.com/rabisiddique234" rel="noopener ugc nofollow" target="_blank">Twitter</a></p></div></div>    
</body>
</html>