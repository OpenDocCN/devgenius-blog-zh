<html>
<head>
<title>How to Use Pub/Sub with NodeJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何对 NodeJS 使用发布/订阅</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-use-pub-sub-with-nodejs-b63a9119bf6d?source=collection_archive---------10-----------------------#2021-12-27">https://blog.devgenius.io/how-to-use-pub-sub-with-nodejs-b63a9119bf6d?source=collection_archive---------10-----------------------#2021-12-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="b08e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文中，我将展示如何在 NodeJS 应用程序中使用发布/订阅模式。我们将使用 Google Cloud 发布/订阅模块来构建这个示例应用程序。</p><h1 id="e1c0" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">什么是 Pub/Sub？</h1><p id="e7dd" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">以前大多数架构都是同步的。但是随着微服务的出现，异步通信是设计中平等的一部分。发布/订阅就是这样一种允许异步通信的模型。通常，在<a class="ae ll" href="https://betterjavacode.com/programming/microservices-event-driven-architecture" rel="noopener ugc nofollow" target="_blank">事件驱动架构</a>中，一个服务发布一个事件，另一个服务消费该事件。</p><p id="9032" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在发布和使用消息时，消息代理扮演了一个中继角色。谷歌云(Pub-Sub)和 AWS 都提供一种服务(SNS &amp; SQS ),允许应用程序使用 Pub-Sub 模式。发布/订阅的另一个优点是它允许建立一个重试策略，包括等幂。你可以在这里了解更多关于事件驱动架构<a class="ae ll" href="https://www.educative.io/path/scalability-system-design?aff=VRQq" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><h1 id="fa1e" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">推挽式</h1><p id="9330" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">在任何发布-订阅模型中，都有两种实现模式。一个是推，一个是拉。</p><p id="8344" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在拉动模式中</p><ul class=""><li id="4ff9" class="lm ln in jm b jn jo jr js jv lo jz lp kd lq kh lr ls lt lu bi translated">消费者发送一个请求来提取任何消息。</li><li id="91e1" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh lr ls lt lu bi translated">如果有任何可用的且先前未被使用的消息，则发布/订阅服务器用消息来响应。</li><li id="e243" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh lr ls lt lu bi translated">消费者发送确认。</li></ul><p id="4712" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在推送模式中</p><ul class=""><li id="c78a" class="lm ln in jm b jn jo jr js jv lo jz lp kd lq kh lr ls lt lu bi translated">发布者向发布/订阅服务器发布消息</li><li id="5b1f" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh lr ls lt lu bi translated">发布/订阅服务器将消息发送到消费者端的指定端点。</li><li id="e1ac" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh lr ls lt lu bi translated">消费者收到消息后，会发送一条确认消息。</li></ul><h1 id="a3cc" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">NodeJS 应用</h1><p id="9a53" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">作为文章的一部分，我们将创建一个使用发布订阅模型的 nodejs 应用程序。这个应用程序将发送简单的消息到谷歌云发布/订阅。我们将有另一个消费应用程序来消费这个消息。</p><p id="bc3b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，在我们编写应用程序之前，让我们确保您已经在您的环境中安装了 gcloud emulator。首先，根据你的操作系统安装<a class="ae ll" href="https://cloud.google.com/sdk/docs/install" rel="noopener ugc nofollow" target="_blank"> gcloud sdk </a>。</p><p id="b126" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，在您的环境中初始化 gcloud，您需要登录</p><p id="effb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ma mb mc md b">gcloud init</code></p><p id="ca80" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Gcloud 会问一堆问题来选择项目，配置云环境。</p><p id="7150" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们将在本地环境中为 gcloud 安装一个<code class="fe ma mb mc md b">pub-sub</code>组件模拟器。</p><p id="8fca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ma mb mc md b">gcloud components install pubsub-emulator</code></p><p id="1a35" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，要开始使用发布-订阅服务，请使用以下命令</p><p id="97d8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ma mb mc md b">gcloud beta emulators pubsub start --project=pubsubdemo --host-port=localhost:8085</code></p><p id="2732" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该命令将在本地主机 8085 上启动 pubsub 服务。因为我们将不得不在我们的应用程序中使用这个服务，所以我们需要知道服务位于哪里。因此，设置两个环境变量</p><p id="dc9b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ma mb mc md b">PUBSUB_EMULATOR_HOST=localhost:8085</code> <code class="fe ma mb mc md b">PUBSUB_PROJECT_ID=pubsubdemo</code></p><h1 id="19e4" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">Publisher 应用程序</h1><p id="2b6b" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">一般来说，我们有一个 Publisher 应用程序。这个应用程序检查主题是否存在于发布-订阅服务中，如果不存在，则创建该主题。一旦创建了主题，它就通过消息将数据发送到发布-订阅服务主题。</p><p id="252d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该应用程序的代码如下所示:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="a548" class="mm kj in md b gy mn mo l mp mq">const { PubSub } = require('@google-cloud/pubsub');<br/>require('dotenv').config();<br/><br/>const pubsubClient = new PubSub();<br/><br/>const data = JSON.stringify({<br/>  "userId": "50001",<br/>  "companyId": "acme",<br/>  "companyName": "Acme Company",<br/>  "firstName": "John",<br/>  "lastName": "Doe",<br/>  "email": "john.doe@acme.com",<br/>  "country": "US",<br/>  "city": "Austin",<br/>  "status": "Active",<br/>  "effectiveDate": "11/11/2021",<br/>  "department": "sales",<br/>  "title": "Sales Lead"<br/>});<br/>const topicName = "PubSubExample";<br/><br/>async function createTopic() {<br/>  // Creates a new topic<br/>  await pubsubClient.createTopic(topicName);<br/>  console.log(`Topic ${topicName} created.`);<br/>}<br/><br/>async function doesTopicExist() {<br/>  const topics = await pubsubClient.getTopics();<br/>  const topicExists = topics.find((topic) =&gt; topic.name === topicName);<br/>  return (topics &amp;&amp; topicExists);<br/>}<br/><br/>if(!doesTopicExist()) {<br/>  createTopic();<br/>}<br/><br/>async function publishMessage() {<br/>    const dataBuffer = Buffer.from(data);<br/><br/>    try {<br/>      const messageId = await pubsubClient.topic(topicName).publish(dataBuffer);<br/>      console.log(`Message ${messageId} published`);<br/>    } catch(error) {<br/>      console.error(`Received error while publishing: ${error.message}`);<br/>      process.exitCode = 1;<br/>    }<br/>}<br/><br/>publishMessage();</span></pre><p id="ef1b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">反过来，让我们看看消费者应用程序。</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="5a8c" class="mm kj in md b gy mn mo l mp mq">require('dotenv').config();<br/><br/>const { PubSub } = require(`@google-cloud/pubsub`);<br/><br/>const pubsubClient = new PubSub();<br/>const subscriptionName = 'consumeUserData';<br/>const timeout = 60;<br/>const topicName = 'PubSubExample';<br/><br/>async function createSubscription() {<br/>  // Creates a new subscription<br/>  await pubsubClient.topic(topicName).createSubscription(subscriptionName);<br/>  console.log(`Subscription ${subscriptionName} created.`);<br/>}<br/><br/>async function doesSubscriptionExist() {<br/>  const subscriptions = await pubsubClient.getSubscriptions();<br/>  const subscriptionExist = subscriptions.find((sub) =&gt; sub.name === subscriptionName);<br/>  return (subscriptions &amp;&amp; subscriptionExist);<br/>}<br/><br/>if(!doesSubscriptionExist()) {<br/>    createSubscription().catch(console.error);<br/>}<br/><br/>const subscription = pubsubClient.subscription(subscriptionName);<br/><br/>let messageCount = 0;<br/><br/>const messageHandler = message =&gt; {<br/>  console.log(`message received ${message.id}`);<br/>  console.log(`Data: ${message.data}`);<br/>  messageCount += 1;<br/><br/>  message.ack();<br/>};<br/><br/>subscription.on(`message`, messageHandler);<br/>setTimeout(() =&gt; {<br/>  subscription.removeListener('message', messageHandler);<br/>  console.log(`${messageCount} message(s) received`);<br/>}, timeout * 1000);</span></pre><p id="c5df" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">基本上，这个消费者应用程序验证订阅是否存在，如果不存在，它将根据发布者应用程序发送消息的主题创建一个订阅。一旦消息到达发布-订阅主题，消费者应用程序就会提取该消息。这个应用程序实现了发布-订阅的拉模型。</p><h1 id="4d6f" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">演示</h1><p id="b37b" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">在启动 pubsub 服务模拟器时，我们将看到如下所示的日志:</p><figure class="me mf mg mh gt ms gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/3917d03c024de0148277871ab8a6c4f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*CNdasfa35fuosQCA"/></div></figure><p id="0476" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，让我们执行 publisher 应用程序，我们将看到消息发布的控制台日志</p><figure class="me mf mg mh gt ms gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/878cf6fc02800c8c669c4a9226bbcc07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*puy3mULnVAN6KevE"/></div></figure><p id="68e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您执行相同的应用程序，您将不会看到消息<code class="fe ma mb mc md b">Topic PubSubExample created</code>。</p><p id="8d9e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，如果执行消费者应用程序，我们将把发布者发送的消息拉至主题。</p><figure class="me mf mg mh gt ms gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/4688772c66d858a38e9d8a77c5b25492.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*OvHN8WZwHWZ6A3pN"/></div></figure><p id="37c3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">同样的演示与一个简单的织机视频<a class="ae ll" href="https://www.loom.com/share/9ef8d58e418f46c0911ed612c21437d2" rel="noopener ugc nofollow" target="_blank">在这里</a>。</p><h1 id="2408" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">结论</h1><p id="8678" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">在这篇文章中，我展示了如何在 NodeJS 应用程序中使用 Pub Sub。发布-订阅是在企业应用程序中使用的强大模型。它允许我们构建可以异步通信的服务。如果你有更多关于这个话题的问题，请随时联系<a class="ae ll" href="https://betterjavacode.com/contact-us" rel="noopener ugc nofollow" target="_blank"> me </a>。</p></div><div class="ab cl mv mw hr mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ig ih ii ij ik"><p id="6bb3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="nc">原载于 2021 年 12 月 27 日 https://betterjavacode.com</em><em class="nc"/><a class="ae ll" href="https://betterjavacode.com/programming/how-to-use-pub-sub-with-nodejs" rel="noopener ugc nofollow" target="_blank"><em class="nc">。</em></a></p></div></div>    
</body>
</html>