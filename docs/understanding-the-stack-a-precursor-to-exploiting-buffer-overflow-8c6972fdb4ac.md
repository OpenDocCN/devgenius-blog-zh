# 了解堆栈——利用缓冲区溢出的前奏

> 原文：<https://blog.devgenius.io/understanding-the-stack-a-precursor-to-exploiting-buffer-overflow-8c6972fdb4ac?source=collection_archive---------1----------------------->

好吧，

我试图利用 C 程序中的缓冲区溢出，事实证明，理解堆栈对于在这一努力中取得有意义的进步是至关重要的。

许多课堂笔记很好地解释了缓冲区溢出，但不知何故，它们往往没有给出攻击期间 RAM 中发生了什么的整体视图。

因此，我决定写一篇文章来了解缓冲区溢出是如何工作的，以及内存中有什么。

在这篇文章中，我将根据我的理解讨论这三张图，希望有人能从这篇文章中受益！

![](img/945cd3af6297e5a11d7ca978aad8f031.png)

左边的图 1(橙色)展示了当程序被加载到内存中时，内存分配是如何完成的。

让我们假设我们在 32 位机器上的系统中有 4 GB 的 RAM。此后我们将把 RAM 称为存储器。在现代操作系统中，加载到内存中的每个程序都假设整个内存(在本例中为 4 GB)属于该进程。从程序的角度来看，它是这样的。这就是我们在这篇文章中讨论的记忆。

注意——(对于那些想知道这是如何工作的人来说——在现代操作系统中，内存位置的地址是范围 **0x00000000 到 0x ffffff**的虚拟地址，经过地址转换后映射到物理地址。这种映射是使用分页和分段机制来完成的。你可以在操作系统课程或网上了解更多，但对我们来说，你不需要关心这个。

现在，加载到存储器中的程序组件被分配到存储器中的各个部分。程序的代码(也称为文本)被加载到文本部分。这个部分的大小是固定的，在程序执行期间不会改变。

初始化的全局变量和静态变量被放入内存的数据区。

未初始化的全局变量和未初始化的静态局部变量放在内存的 BSS 部分。如果你想知道为什么这个部分被称为 BSS，那么让我告诉你，BSS 的完整形式是由符号开始的块，它被这样称呼是出于历史原因，你可以忽略它。

堆是在运行时用来动态分配内存的内存区域。像 C 语言中的 **Malloc()、Realloc()** 这样的函数用于分配这部分内存的空间。如图 1 所示，堆朝着更高的地址向上增长。

堆栈部分从内存中最高的地址开始，向下朝着较低的地址增长。一个函数的局部变量和另一个函数的参数存储在堆栈中。

堆栈是一种 LIFO 结构，这意味着— *后进先出*。推入堆栈的第一个元素是最后一个弹出堆栈的元素。

为什么堆栈和堆放在内存的两端？好吧，在古代，当内存很小的时候，那么 stack 和 heap 经常会耗尽空间并触及其他部分的边界。为了避免这种情况，我们采用了这种布局，并且现在仍在使用。

这就完成了内存的高级视图。在此阶段，我们继续前进，只关注堆栈。

现在，每个还没有返回的函数，在堆栈上都有一个堆栈框架。在下图中， ***last()*** 函数被调用并被执行的点，此时上图 2(绿色)显示了函数 ***last()*** 被执行时堆栈的状态。

![](img/11ec15a0568074deb4498e17c24a4a43.png)

为了返回到原始函数并继续正常执行，EIP ( *扩展指令指针寄存器，指向在任意时间点*要执行的下一条指令)自然必须指向调用函数(*，刚刚返回*)的下一行。

所以，在调用任何函数之前，我们将 EIP 的内容保存在堆栈中是很自然的。

同样，为了使用堆栈，我们需要两个非常重要的寄存器

1.EBP(扩展基本指针)

2.扩展堆栈指针

基址指针存储堆栈帧的基址地址。栈指针总是指向栈顶。(实际上，这是堆栈中地址最低的位置)。

另一个重要的寄存器是 EIP ( *扩展指令指针*)，它总是指向下一条要执行的指令。在将控制权转移给另一个函数之前，EIP 总是最后保存在给定函数的堆栈框架中。这样做是为了让被调用的函数在完成执行后能够将控制权返回给调用函数。这种控制转移是通过用旧值加载 EIP(它指向调用函数中的下一行代码)并将 ESP 和 EBP 设置为旧值来完成的，以便调用函数可以继续正常执行。

因此，EIP、ESP 和 EBP 使得一个函数调用另一个函数，然后在被调用的函数返回后继续正常执行成为可能。所有这些都是借助堆栈框架实现的。

![](img/35ee085d692f098eef878db95ffbd5c8.png)

如上图所示，EBP 和 ESP 指向当前正在执行的函数的堆栈框架的底部和顶部。所有其他堆栈帧在将控制转移到另一个函数之前保存 EBP 和 EIP 值。

现在，我们转到图 3(蓝色)。

![](img/56bd6dbe0aeea2d0922805ecbb77bdae.png)

关于这张图表最重要的事情如下:

1.推入函数堆栈框架的第一项是前一个函数堆栈框架的 EBP。这是**始终出现在堆栈框架上的**。

2.然后**可能有也可能没有**一些空间(是 4 字节的倍数)来存储返回值。

3.局部变量总是按照它们被声明的顺序排列(局部变量 1，局部变量 2)。这些变量**总是出现在堆栈上**。

4.**可能有也可能没有**任何保存的寄存器和临时寄存器。

5.下一个函数调用的**参数保存在**逆序** (arg 2，arg 1)中。如果**下一个函数需要参数，这些参数**总是存在。**

6.栈上的最后一个**是 EIP** ，也就是返回地址 ie。被调用函数返回后要执行的下一行代码的地址。

**这里重要的是要认识到**——尽管局部变量和自变量以它们在图中指定的顺序出现在堆栈上，但堆栈可能有其他临时值(s *可能返回值或在函数执行期间生成的其他值*),因此，当您比较两个程序的堆栈框架时，您可以预期局部变量和自变量以它们在图中指定的顺序在 EBP 和 ESP 之间浮动。

**缓冲区溢出攻击**的目的，就是在堆栈上覆盖这个值，这样当被调用的函数返回时，它就加载攻击者代码的地址并执行它。例如，下一个堆栈帧的局部变量 1 可能溢出，从而覆盖 EBP，然后覆盖 EIP(因为内存从较低的地址填充到较高的地址)。

尽情享受吧！