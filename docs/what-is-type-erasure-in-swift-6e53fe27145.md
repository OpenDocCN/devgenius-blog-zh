# Swift 中的类型擦除是什么

> 原文：<https://blog.devgenius.io/what-is-type-erasure-in-swift-6e53fe27145?source=collection_archive---------3----------------------->

![](img/1a38d52c34e505c9092054cb68545b08.png)

麦克斯韦·尼尔森在 T2 的照片

# 这么多问题？

*   Wtf 是类型擦除？
*   我为什么需要它？
*   这似乎很复杂？
*   没有更简单的方法吗？

这些只是我第一次开始探索类型擦除时，我发现自己问的一些问题。像许多其他开发人员一样，我一直在代码中使用协议来消除依赖性，使我的类易于单元测试。直到我开始将泛型添加到我的协议中，我才发现需要应用类型擦除。

读了许多关于类型擦除的博客文章和指南，我仍然困惑于它是什么，为什么需要它，为什么它似乎增加了这么多的复杂性。在我参与的一个项目中，通过尝试将泛型添加到协议中，我终于明白了！我将尝试用一个与我在项目中试图解决的问题相似的例子来引导你理解这个主题。希望这将有助于那些希望进一步理解这个话题的人，就像它帮助我一样。

# 泛型和关联类型

我假设您在这里，您对 Swift 有相当深入的了解，并且可能已经开始或一直在您的代码中使用带有泛型的协议。下面是一个名为 Fetchable 的简单协议。该协议的思想是从某个地方获取一些 FetchType 类型的对象，并在完成后调用完成处理程序的结果，无论它正在做什么。

现在我们有了协议，让我们创建几个结构来实现协议。

因此，我们在这里创建了一个虚拟数据类 User。我们的 fetch 结构已经实现了泛型协议，并使用 typealias 指定了将在协议中返回的对象的类型。这里的一切都很棒，我们可以随心所欲地多次实现这个协议，并返回我们想要的任何对象类型，而不需要为每个类型创建一个新的协议。

# 问题是

现在，问题就在这里。如果我们希望保存对实现了这个协议的对象的引用。我们怎么知道它会返回什么类型？请参见下面的示例:

您还会发现，您会看到一个错误，如下所示:

> 协议“Fetchable”只能用作一般约束，因为它具有自身或关联的类型要求

所以我们甚至不能使用这个类型作为对象的引用，因为它有一个关联的类型，我们在这一点上看不到，也没有办法指定。

现在我们可以像下面这样做，但是这会在 SomeStruct 和 userFetch 对象之间创建一个依赖关系。如果我们遵循坚实的原则，我们希望避免依赖和隐藏实现细节。

好了，让我们试着添加一个类型，就像我们添加其他泛型类型(如数组和字典)一样:

如果你尝试上面的方法，你可能会得到一个类似这样的错误:

> 无法专门化非泛型类型“可提取”

参见泛型协议，与泛型类型不同，泛型类型不能在类型声明中推断其类型。该类型仅在实现过程中指定。

# 打字擦除拯救

这就是类型擦除的用武之地。为了让我们知道返回的类型，我们需要实现一个新的类，它可以用来推断返回的对象的类型，这样我们就知道当我们调用 fetch 时会发生什么。

呜哇！这里发生了很多事情，所以让我们一点一点来解释发生了什么。

1.  这里我们的 AnyFetchable 类实现了 Fetchable 协议。但是我们也看到我们现在有了一个通用的类型规范。这意味着我们可以指定在存储对该结构的引用时使用什么类型。
2.  然后，我们在上面一行中指定的泛型类型 T 被用在 typealias 中，并映射到协议的 FetchType 关联值。
3.  这就是事情变得复杂的地方。为了删除注入类的类型，我们必须首先**创建一个属性，该属性是一个闭包，带有协议**中每个函数的匹配签名。在这个场景中，我们只有一个方法，即 fetch 方法。在这里，您可以看到 fetch 属性具有与协议中相同的方法签名。
4.  让我们稍微分解一下。首先，我们说这个 init 方法只适用于已经实现了 Fetchable 的对象，称为 U。行尾的 where 子句是一个通用类型限制，它声明 FetchType of Fetchable U 必须与这个类中使用的相同。这可能现在没有太多意义，但和我在一起。当可获取的类型 U 被传入时，我们在自己的内部变量中存储对其获取方法的引用。这有助于我们删除类型，我们存储对所有对象方法的引用，而不是实际存储对对象的引用。这样我们就不需要知道类型了。
5.  这是我们的可获取协议 fetch 方法的实现，但是我们所做的只是调用传入对象 fetch 方法的引用，而不是调用它。

希望有些是有意义的，有些可能是新的或令人困惑的，尤其是第 4 点。让我们在这个例子中展示如何使用我们的类。

1.  首先，我们创建前面示例中 UserFetch 对象的一个实例，该实例返回我们的示例用户。
2.  我们把它传递给我们的 AnyFetchable 对象。现在请记住，在前一个例子的第 4 点中，我们在 init 上有一个泛型类型约束。这是令人满意的，因为我们已经指定 AnyFetchable 应该返回一个用户类型，并且我们传入的 UserFetch 对象具有 FetchType 用户。
3.  现在，我们可以将 AnyFetchable 传递给我们的结构。

# 为什么？

现在你可能在想，为什么要做这一切？好吧，让我们试试另一个例子:

因此，我们在这里创建了一个新对象，它实现了 Fetchable 并返回一个名为 Dave 的用户。然后，我们可以使用类型擦除类将它传递给 SomeStruct，它的工作方式完全相同。SomeStruct 类不需要修改就可以使用新的 dave 类，因为它的类型已经被删除了。在生产应用中，我们可以注入任何我们想要的类，只要它获取用户，无论是来自 web、核心数据还是文件系统。没关系，我们可以在任何时候切换它，而无需对 SomeStruct 类进行更改。

# 最后

这里的最后一个例子是，我们可以将 Any 类用于其他类型，而不仅仅是 User。请参见下面的示例:

与我们的用户示例类似，我们创建了一个新的产品对象和一个返回产品对象的获取器。然而，我们可以在这里重用我们的 AnyFetchable，但是将返回类型指定为 Product。

这里有很多内容需要介绍和理解，希望这有助于理解类型擦除及其用途。更重要的是，如何为自己的协议实现自己的任意类型擦除类，以便在代码中引用它们。

[下载操场](https://pyartez.github.io/files/type-erasure.playground.zip)自己玩例子。