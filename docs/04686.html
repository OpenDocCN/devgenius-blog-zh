<html>
<head>
<title>Brute Force Approach to Algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法的强力方法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/brute-force-approach-to-algorithms-351dda5e3dc5?source=collection_archive---------0-----------------------#2021-04-20">https://blog.devgenius.io/brute-force-approach-to-algorithms-351dda5e3dc5?source=collection_archive---------0-----------------------#2021-04-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="17c9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在所有的算法设计策略中，蛮力是最简单的方法，它是实现基本运算的最直接的方法之一。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3cf5bab8c46879a3342dcb4c65d94c2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*laHYHfkojW6VLPuuqLrI3w.jpeg"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ku"><img src="../Images/26699c411f1f84a54261918be081fb5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*v62E8-MxXL8yMj-5qTMMvA.png"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">只是引用一句话，做好一件事在我看来往往是有回报的:)</figcaption></figure><blockquote class="kz la lb"><p id="1d3b" class="jk jl lc jm b jn jo jp jq jr js jt ju ld jw jx jy le ka kb kc lf ke kf kg kh ig bi translated">”<em class="in">“就这么办吧！“可以用另一种方式来描述强力方法的处方</em>”，Anany Levitin 在他的名为<strong class="jm io">的书《算法的设计和分析</strong>》中这样说道。</p></blockquote><ol class=""><li id="4356" class="lg lh in jm b jn jo jr js jv li jz lj kd lk kh ll lm ln lo bi translated">由于这种策略思想的简单性，蛮力可以应用于各种各样的问题，而大多数算法策略则以更具体的方式应用于问题。</li><li id="c87e" class="lg lh in jm b jn lp jr lq jv lr jz ls kd lt kh ll lm ln lo bi translated">效率相当低。即便如此，它对于解决小规模的问题仍然很有用。</li><li id="e1cc" class="lg lh in jm b jn lp jr lq jv lr jz ls kd lt kh ll lm ln lo bi translated">如果一个问题只有几个实例需要解决，强力可能会有用，而不是设计一个复杂而昂贵的算法。</li></ol></div><div class="ab cl lu lv hr lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ig ih ii ij ik"><p id="9e59" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们把理论放在一边，用一个例子来考虑这个策略。</p><h2 id="7153" class="mb mc in bd md me mf dn mg mh mi dp mj jv mk ml mm jz mn mo mp kd mq mr ms mt bi translated"><strong class="ak">寻找配对问题</strong></h2><p id="38d1" class="pw-post-body-paragraph jk jl in jm b jn mu jp jq jr mv jt ju jv mw jx jy jz mx kb kc kd my kf kg kh ig bi translated">这是一个非常著名的初学者问题，假设我们有一个数组，</p><p id="01bf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">int[] arr = {12，-1，5，8，3}带 5 个整数。</p><p id="f0fe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们想找到一个和等于 17 的对。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="e7b4" class="mb mc in na b gy ne nf l ng nh">public static void main(String[] args) { <br/> <br/>        int[] arr = {12, -1, 5, 8, 3}; <br/>        int target = 17; <br/> <br/>        for (int i = 0; i &lt; arr.length; i++) { <br/> <br/>            for (int j = i+1; j &lt; arr.length ; j++) { <br/>                if (arr[i] + arr[j] == target) { <br/>                    break; <br/>                }<br/>            }<br/>        }<br/>        System.out.println("first index:" + i +".element = "+ arr[i]);<br/>        System.out.println("second index:" + j +".element = "+ arr[j]);<br/>}</span></pre><p id="8d3e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这段代码是暴力破解的一个很好的例子。因为在寻找目标对的同时，这个算法需要<strong class="jm io"> <em class="lc">检查我们数组中每一个可能的对</em> </strong>。因此我们的时间复杂度是 O(n ) 。</p><h2 id="43d4" class="mb mc in bd md me mf dn mg mh mi dp mj jv mk ml mm jz mn mo mp kd mq mr ms mt bi translated"><strong class="ak">更省时的方法</strong></h2><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="f810" class="mb mc in na b gy ne nf l ng nh">public static void main(String[] args) { <br/>  <br/>    int[] arr = {12, -1, 5, 8, 3}; <br/>    Arrays.sort(arr); <br/>    int target = 17; <br/> <br/>    for (int i = 0; i &lt; arr.length; i++) { <br/>        int j = Arrays.binarySearch(arr, target - arr[i]); <br/>        if (j &gt;= 0) { <br/>            break; <br/>        } <br/>    } <br/>    System.out.println("first index:" + i +".element = "+ arr[i]);<br/>    System.out.println("second index:" + j +".element = "+ arr[j]);<br/>}</span></pre><p id="cd68" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里我们使用了数组。BinarySearch 方法找到满足我们目标的一对数字。正如我们所看到的，只有一个循环来执行我们的基本操作(寻找配对)。</p><p id="e8f5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">注意:</strong>循环次数少并不总是意味着更快，但这次很明显。</p><p id="2623" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个策略带给我们的是<strong class="jm io"> O(n*logn) </strong>时间复杂度，比<strong class="jm io"> O(n)略快。</strong></p></div><div class="ab cl lu lv hr lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ig ih ii ij ik"><h2 id="f000" class="mb mc in bd md me mf dn mg mh mi dp mj jv mk ml mm jz mn mo mp kd mq mr ms mt bi translated">强力字符串匹配</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/a3cad45c6372cdcb8e7e0a97a48215d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LIUSKkBiBUm2o0c9Lgu14A.png"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">暴力字符串匹配的伪代码</figcaption></figure><p id="e5ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如我们从上面给出的伪代码中看到的，这种方法通过从头到尾进行比较来测试要与包含所需单词的数组进行比较的数组。</p><p id="de2b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">时间复杂度= <strong class="jm io"> O(n*m) </strong> (m 是我们想要的单词的长度，n 是我们数组的长度)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/20b97dc22b15f53c1096e1ef614a06fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E-YIxOzwzcbRo0RjlpgoLQ.png"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">这个算法如何执行的例子</figcaption></figure><p id="2041" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你看到问题了吗？</p><p id="b227" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">是的。该算法将单词与整个数组进行比较，而不管它的第一个字母是什么。这是一种耗时的方式，但不是最糟糕的。</p><p id="11b5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">可以通过使用不同的方法(数组方法、字符串解析器等)来解决这个问题。)以便更快地达到目标。</p></div><div class="ab cl lu lv hr lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ig ih ii ij ik"><h2 id="aa5a" class="mb mc in bd md me mf dn mg mh mi dp mj jv mk ml mm jz mn mo mp kd mq mr ms mt bi translated">快速小结</h2><p id="521f" class="pw-post-body-paragraph jk jl in jm b jn mu jp jq jr mv jt ju jv mw jx jy jz mx kb kc kd my kf kg kh ig bi translated">强力方法依赖于测试每一种可能性，以确保期望输出的真实性。因此，这使得算法相当慢。此外，蛮力方法可以应用于各种各样的问题。</p><p id="761f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">一些暴力破解算法的例子，</strong></p><p id="39ad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">选择排序，冒泡排序，顺序搜索，最接近对问题，凸壳问题，深度优先搜索，广度优先搜索，等等…</p><p id="0d6f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="lc">注:</em> </strong> DFS 和 BFS 算法都是穷举搜索的例子。穷举搜索是一种简单的组合问题的强力方法。</p></div><div class="ab cl lu lv hr lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ig ih ii ij ik"><p id="bc67" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="lc">参考文献:</em></p><blockquote class="kz la lb"><p id="1aa9" class="jk jl lc jm b jn jo jp jq jr js jt ju ld jw jx jy le ka kb kc lf ke kf kg kh ig bi translated"><strong class="jm io">算法的设计与分析第三版，Anany Levitin </strong></p><p id="4a5b" class="jk jl lc jm b jn jo jp jq jr js jt ju ld jw jx jy le ka kb kc lf ke kf kg kh ig bi translated"><a class="ae nk" href="https://www.quora.com/What-is-the-brute-force-method" rel="noopener ugc nofollow" target="_blank">https://www.quora.com/What-is-the-brute-force-method</a></p></blockquote></div></div>    
</body>
</html>