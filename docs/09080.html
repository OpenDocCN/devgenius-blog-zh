<html>
<head>
<title>Big Tech Coding Interview Question — Two Sum Problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大技术编码面试问题——两个和问题</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/big-tech-coding-interview-question-two-sum-problem-6f8079aaf942?source=collection_archive---------6-----------------------#2022-07-28">https://blog.devgenius.io/big-tech-coding-interview-question-two-sum-problem-6f8079aaf942?source=collection_archive---------6-----------------------#2022-07-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="74ce" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">获得大型科技公司软件工程师职位的旅程</h2><div class=""/><div class=""><h2 id="11c1" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">作为软件工程师解决两个求和问题详细实现</h2></div><h1 id="5735" class="ko kp iq bd kq kr ks kt ku kv kw kx ky kf kz kg la ki lb kj lc kl ld km le lf bi translated">概观</h1><p id="29db" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">这是“大技术编码面试问题”系列中的一篇文章，这篇文章是关于两个和问题的。对于任何科技公司软件工程师来说，两个问题是一个非常常见的面试问题。这被归类为编码面试中的一个简单问题。一旦你很好地理解了这个两个和的问题，它对解决更困难的问题有很大的帮助，比如三个和，在某些方面是两个和问题的延续。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="ab gu cl mh"><img src="../Images/f89b0dfd4b8fbee8598ec38d1b599e2d.png" data-original-src="https://miro.medium.com/v2/0*btx7yLZPyfJcgQJ-"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">马库斯·斯皮斯克在<a class="ae mo" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="5b33" class="pw-post-body-paragraph lg lh iq li b lj mp ka ll lm mq kd lo lp mr lr ls lt ms lv lw lx mt lz ma mb ij bi translated"><strong class="li ja">问题</strong></p><blockquote class="mu mv mw"><p id="3ddf" class="lg lh mx li b lj mp ka ll lm mq kd lo my mr lr ls mz ms lv lw na mt lz ma mb ij bi translated">给定一个整数数组“nums”和一个整数数组“target ”,返回这两个数字的索引，使它们加起来等于 target。您可以假设每个输入只有一个解决方案，并且不能两次使用同一个元素。可以任意顺序返回答案。</p></blockquote><p id="9856" class="pw-post-body-paragraph lg lh iq li b lj mp ka ll lm mq kd lo lp mr lr ls lt ms lv lw lx mt lz ma mb ij bi translated"><strong class="li ja">例如</strong></p><pre class="mc md me mf gt nb nc nd ne aw nf bi"><span id="365b" class="ng kp iq nc b gy nh ni l nj nk"><br/>Input: nums = [2,7,11,15], target = 9<br/>Output: [0,1]<br/>Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].</span></pre><p id="f7d1" class="pw-post-body-paragraph lg lh iq li b lj mp ka ll lm mq kd lo lp mr lr ls lt ms lv lw lx mt lz ma mb ij bi translated"><strong class="li ja">约束条件</strong></p><pre class="mc md me mf gt nb nc nd ne aw nf bi"><span id="86ba" class="ng kp iq nc b gy nh ni l nj nk">2 &lt;= nums.length &lt;= 10⁴<br/>-10⁹ &lt;= nums[i] &lt;= 10⁹<br/>-10⁹ &lt;= target &lt;= 10⁹<br/>Only one valid answer exists.</span></pre></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><h1 id="d99a" class="ko kp iq bd kq kr ns kt ku kv nt kx ky kf nu kg la ki nv kj lc kl nw km le lf bi translated">解决两个和问题</h1><p id="69ad" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">首先，让我们试着理解这个问题。给我们一个整数元素数组和一个目标和。我们的工作是编写一个函数，返回数组中两个元素的索引，当我们将这两个元素相加时，它应该等于给定的目标和。这个问题有一个注解:</p><blockquote class="mu mv mw"><p id="9eb3" class="lg lh mx li b lj mp ka ll lm mq kd lo my mr lr ls mz ms lv lw na mt lz ma mb ij bi translated">如果有多个这样的对，我们需要返回从左边找到的第一个对的索引。</p></blockquote><p id="cfc0" class="pw-post-body-paragraph lg lh iq li b lj mp ka ll lm mq kd lo lp mr lr ls lt ms lv lw lx mt lz ma mb ij bi translated">这意味着我们不需要关心输出的顺序。例如，我们可以从上面的示例中返回[0，1]或[1，0]。</p><h2 id="e7cf" class="ng kp iq bd kq nx ny dn ku nz oa dp ky lp ob oc la lt od oe lc lx of og le iw bi translated">定义测试用例</h2><p id="3559" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">其次，我们为这个问题定义测试用例，以确保我们很好地理解这个问题。这是五个测试案例，包括快乐案例和边缘案例。以下测试案例涵盖了满意案例和边缘案例，如负值、正值、零值以及无法从输入数组中找到目标:</p><pre class="mc md me mf gt nb nc nd ne aw nf bi"><span id="5701" class="ng kp iq nc b gy nh ni l nj nk">testCase1nums[] = {5, 7, 12,1};<br/>testCase1Target = 12;<br/>expectedResult1 = [0, 1]</span><span id="2adf" class="ng kp iq nc b gy oh ni l nj nk">testCase2nums[] = {3, 5, 0};<br/>testCase2Target = 6;<br/>expectedResult2 = null</span><span id="e379" class="ng kp iq nc b gy oh ni l nj nk">testCase3nums[] = {0, 3};<br/>testCase3Target = 3;<br/>expectedResult3 = [0, 1]</span><span id="e58b" class="ng kp iq nc b gy oh ni l nj nk">testCase4nums[] = {0, -1, 2, -3, 1};<br/>testCase4Target = -2;<br/>expectedResult4 = [3, 4]</span><span id="09cc" class="ng kp iq nc b gy oh ni l nj nk">testCase5nums[] = {4, -11, 22, -23, 31};<br/>testCase5Target = -20;<br/>expectedResult5 = null</span></pre><p id="661d" class="pw-post-body-paragraph lg lh iq li b lj mp ka ll lm mq kd lo lp mr lr ls lt ms lv lw lx mt lz ma mb ij bi translated">你应该在编码前把这一步当作一个好的实践，因为它有助于确保你和面试官对问题有相同的理解。通过定义测试案例和每个案例的预期结果，如果您有误解，面试官可以帮助您纠正您的理解以解决问题，避免浪费时间。</p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><h2 id="2f7f" class="ng kp iq bd kq nx ny dn ku nz oa dp ky lp ob oc la lt od oe lc lx of og le iw bi translated">解决方案 1:暴力</h2><p id="f7a4" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">接下来，如何先用一个直截了当的方法解决这个问题？面试官关心你的想法，所以大声告诉他们你的想法。</p><p id="e9ce" class="pw-post-body-paragraph lg lh iq li b lj mp ka ll lm mq kd lo lp mr lr ls lt ms lv lw lx mt lz ma mb ij bi translated">真正强力的方法是使用两个嵌套的 for 循环搜索所有可能的数字对。尽管这种解决方案很慢，但是为了问题的完整性，最好先尝试一下暴力解决方案。正是从这些强力解决方案中，您可以在以后进行优化。</p><p id="512a" class="pw-post-body-paragraph lg lh iq li b lj mp ka ll lm mq kd lo lp mr lr ls lt ms lv lw lx mt lz ma mb ij bi translated"><em class="mx">对于给定的输入数组 nums[]，我们需要做这些步骤:</em></p><ol class=""><li id="fe51" class="oi oj iq li b lj mp lm mq lp ok lt ol lx om mb on oo op oq bi translated"><em class="mx">运行两个 for 循环，检查给定数组 nums[]中的每个组合。</em></li><li id="eba7" class="oi oj iq li b lj or lm os lp ot lt ou lx ov mb on oo op oq bi translated"><em class="mx">在特定的索引处按住外环，移动内环以获得所有可能的对。</em></li><li id="00dc" class="oi oj iq li b lj or lm os lp ot lt ou lx ov mb on oo op oq bi translated"><em class="mx">在内循环的每次迭代中，我们发现由外循环和内循环索引表示的数字相加是否达到目标和。</em></li><li id="26d4" class="oi oj iq li b lj or lm os lp ot lt ou lx ov mb on oo op oq bi translated"><em class="mx">如果 nums[outer index]+nums[inner index]等于输入目标变量，则返回数组{outerLoopIndex，innerLoopIndex}作为结果。否则，我们继续迭代以检查下一对。</em></li><li id="5ffb" class="oi oj iq li b lj or lm os lp ot lt ou lx ov mb on oo op oq bi translated"><em class="mx">重复上述步骤，直到找到符合给定目标变量的组合。</em></li></ol><p id="5893" class="pw-post-body-paragraph lg lh iq li b lj mp ka ll lm mq kd lo lp mr lr ls lt ms lv lw lx mt lz ma mb ij bi translated">这是遵循上述步骤的强力方法的 Java 代码:</p><p id="c544" class="pw-post-body-paragraph lg lh iq li b lj mp ka ll lm mq kd lo lp mr lr ls lt ms lv lw lx mt lz ma mb ij bi translated"><strong class="li ja">findtosumsolution 1 函数:</strong></p><pre class="mc md me mf gt nb nc nd ne aw nf bi"><span id="71b2" class="ng kp iq nc b gy nh ni l nj nk"><strong class="nc ja">static int</strong>[] findTwoSumSolution1(<strong class="nc ja">int </strong>nums[], <strong class="nc ja">int </strong>target) {<br/>    <strong class="nc ja">int </strong>length = nums.<strong class="nc ja">length</strong>;<br/>    <strong class="nc ja">for </strong>(<strong class="nc ja">int </strong>i = 0; i &lt; (length - 1); i++) {<br/>      <strong class="nc ja">for </strong>(<strong class="nc ja">int </strong>j = (i + 1); j &lt; length; j++) {<br/>        <strong class="nc ja">if </strong>(nums[i] + nums[j] == target) {<br/>          <strong class="nc ja">int </strong>result[] = { i, j };<br/>          <strong class="nc ja">return </strong>result;<br/>        }<br/>      }<br/>    }<br/>    <strong class="nc ja">return null</strong>;<br/>  }</span></pre><p id="6f32" class="pw-post-body-paragraph lg lh iq li b lj mp ka ll lm mq kd lo lp mr lr ls lt ms lv lw lx mt lz ma mb ij bi translated">在 main 方法中，您可以调用这个函数并用上面的测试用例来验证输出:</p><pre class="mc md me mf gt nb nc nd ne aw nf bi"><span id="0665" class="ng kp iq nc b gy nh ni l nj nk"><strong class="nc ja">public static void </strong>main(String [] args) {<br/>    <strong class="nc ja">int </strong>testCase1nums[] = {5, 7, 12,1};<br/>    <strong class="nc ja">int </strong>testCase1Target = 12;<br/><br/>    <strong class="nc ja">int </strong>testCase2nums[] = {3, 5, 0};<br/>    <strong class="nc ja">int </strong>testCase2Target = 6;<br/><br/>    <strong class="nc ja">int </strong>testCase3nums[] = {0, 3};<br/>    <strong class="nc ja">int </strong>testCase3Target = 3;<br/><br/>    <strong class="nc ja">int </strong>testCase4nums[] = {0, -1, 2, -3, 1};<br/>    <strong class="nc ja">int </strong>testCase4Target = -2;<br/><br/>    <strong class="nc ja">int </strong>testCase5nums[] = {4, -11, 22, -23, 31};<br/>    <strong class="nc ja">int </strong>testCase5Target = -20;<br/>    System.<strong class="nc ja"><em class="mx">out</em></strong>.println(Arrays.<em class="mx">toString</em>(<em class="mx">findTwoSumSolution1</em>(testCase1nums,testCase1Target)));<br/>    System.<strong class="nc ja"><em class="mx">out</em></strong>.println(Arrays.<em class="mx">toString</em>(<em class="mx">findTwoSumSolution1</em>(testCase2nums,testCase2Target)));<br/>    System.<strong class="nc ja"><em class="mx">out</em></strong>.println(Arrays.<em class="mx">toString</em>(<em class="mx">findTwoSumSolution1</em>(testCase3nums,testCase3Target)));<br/>    System.<strong class="nc ja"><em class="mx">out</em></strong>.println(Arrays.<em class="mx">toString</em>(<em class="mx">findTwoSumSolution1</em>(testCase4nums,testCase4Target)));<br/>    System.<strong class="nc ja"><em class="mx">out</em></strong>.println(Arrays.<em class="mx">toString</em>(<em class="mx">findTwoSumSolution1</em>(testCase5nums,testCase5Target)));<br/>  }</span></pre><p id="2b09" class="pw-post-body-paragraph lg lh iq li b lj mp ka ll lm mq kd lo lp mr lr ls lt ms lv lw lx mt lz ma mb ij bi translated"><strong class="li ja">时间复杂度:</strong> O(n ) <br/> <strong class="li ja">空间复杂度:</strong> <em class="mx"> </em> O(1)</p><p id="80e8" class="pw-post-body-paragraph lg lh iq li b lj mp ka ll lm mq kd lo lp mr lr ls lt ms lv lw lx mt lz ma mb ij bi translated">在最坏的情况下，上述函数的运行时间复杂度为 O(n)。最坏的情况什么时候会发生？当所需的组合是嵌套循环要检查的最后一个组合时，会出现最坏的情况。</p><p id="bfbe" class="pw-post-body-paragraph lg lh iq li b lj mp ka ll lm mq kd lo lp mr lr ls lt ms lv lw lx mt lz ma mb ij bi translated">你可以在<a class="ae mo" href="https://gist.github.com/techisbeautiful/1379f488ed471c3fd3ca8b53b3d96b5e" rel="noopener ugc nofollow" target="_blank"> Github </a>看到这个解决方案的完整代码。</p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><h2 id="4689" class="ng kp iq bd kq nx ny dn ku nz oa dp ky lp ob oc la lt od oe lc lx of og le iw bi translated">解决方案 2: HashMap</h2><p id="938a" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">在通过第一种方法解决问题后，你需要思考如何改进你的逻辑，使它能够更快更有效地运行，如果你想破解你的编码面试，尤其是当你面试 FAANG 公司时，这一点很重要。</p><p id="da98" class="pw-post-body-paragraph lg lh iq li b lj mp ka ll lm mq kd lo lp mr lr ls lt ms lv lw lx mt lz ma mb ij bi translated">使用哈希方法可以更好地解决这个问题。这个想法是使用 HashMap 来存储我们已经访问过的元素的索引:</p><ul class=""><li id="e0b0" class="oi oj iq li b lj mp lm mq lp ok lt ol lx om mb ow oo op oq bi translated">HashMap 的键是给定输入数组中的数字。</li><li id="bc3f" class="oi oj iq li b lj or lm os lp ot lt ou lx ov mb ow oo op oq bi translated">HashMap 的值是由 HashMap 键表示的数组中数字的索引。</li></ul><p id="b559" class="pw-post-body-paragraph lg lh iq li b lj mp ka ll lm mq kd lo lp mr lr ls lt ms lv lw lx mt lz ma mb ij bi translated"><em class="mx">以下是实现这一逻辑的步骤:</em></p><ol class=""><li id="6f7f" class="oi oj iq li b lj mp lm mq lp ok lt ol lx om mb on oo op oq bi translated">为键和值初始化一个整数散列表。</li><li id="1890" class="oi oj iq li b lj or lm os lp ot lt ou lx ov mb on oo op oq bi translated">从第一个元素开始，遍历给定数组 nums[]中的每个元素。</li><li id="8c76" class="oi oj iq li b lj or lm os lp ot lt ou lx ov mb on oo op oq bi translated">在每一次迭代中，我们发现临时号码是否出现在散列表中。temp number =(target-nums[I])，I 为迭代的当前索引。</li><li id="32d3" class="oi oj iq li b lj or lm os lp ot lt ou lx ov mb on oo op oq bi translated"><em class="mx">如果存在，返回{所需编号索引，当前编号索引}作为函数的结果。</em></li><li id="0c53" class="oi oj iq li b lj or lm os lp ot lt ou lx ov mb on oo op oq bi translated"><em class="mx">否则，将当前迭代编号作为键，将其索引作为值添加到 HashMap 中。</em></li><li id="d5c9" class="oi oj iq li b lj or lm os lp ot lt ou lx ov mb on oo op oq bi translated"><em class="mx">重复这个逻辑，直到找到要返回的结果。如果找不到结果，返回 null </em></li></ol><p id="08e5" class="pw-post-body-paragraph lg lh iq li b lj mp ka ll lm mq kd lo lp mr lr ls lt ms lv lw lx mt lz ma mb ij bi translated"><strong class="li ja">findtosumsolution 2 函数:</strong></p><pre class="mc md me mf gt nb nc nd ne aw nf bi"><span id="0da4" class="ng kp iq nc b gy nh ni l nj nk"><strong class="nc ja">static int</strong>[] findTwoSumSolution2(<strong class="nc ja">int</strong>[] nums, <strong class="nc ja">int </strong>target) {<br/>    HashMap&lt;Integer,Integer&gt; map = <strong class="nc ja">new </strong>HashMap&lt;&gt;();<br/>    <strong class="nc ja">for</strong>(<strong class="nc ja">int </strong>i = 0; i &lt; nums.<strong class="nc ja">length</strong>; i++){<br/>      Integer temp = (target - nums[i]);<br/>      <strong class="nc ja">if</strong>(map.containsKey(temp)){<br/>        <strong class="nc ja">int </strong>result [] = { map.get(temp), i };<br/>        <strong class="nc ja">return </strong>result;<br/>      }<br/>      map.put(nums[i], i);<br/>    }<br/>    <strong class="nc ja">return null</strong>;<br/>  }</span></pre><p id="b4ad" class="pw-post-body-paragraph lg lh iq li b lj mp ka ll lm mq kd lo lp mr lr ls lt ms lv lw lx mt lz ma mb ij bi translated">调用 main 方法中的函数:</p><pre class="mc md me mf gt nb nc nd ne aw nf bi"><span id="e69e" class="ng kp iq nc b gy nh ni l nj nk"><strong class="nc ja">public static void </strong>main(String [] args) {<br/>    <strong class="nc ja">int </strong>testCase1nums[] = {5, 7, 12,1};<br/>    <strong class="nc ja">int </strong>testCase1Target = 12;<br/><br/>    <strong class="nc ja">int </strong>testCase2nums[] = {3, 5, 0};<br/>    <strong class="nc ja">int </strong>testCase2Target = 6;<br/><br/>    <strong class="nc ja">int </strong>testCase3nums[] = {0, 3};<br/>    <strong class="nc ja">int </strong>testCase3Target = 3;<br/><br/>    <strong class="nc ja">int </strong>testCase4nums[] = {0, -1, 2, -3, 1};<br/>    <strong class="nc ja">int </strong>testCase4Target = -2;<br/><br/>    <strong class="nc ja">int </strong>testCase5nums[] = {4, -11, 22, -23, 31};<br/>    <strong class="nc ja">int </strong>testCase5Target = -20;<br/>    System.<strong class="nc ja"><em class="mx">out</em></strong>.println(Arrays.<em class="mx">toString</em>(<em class="mx">findTwoSumSolution2</em>(testCase1nums,testCase1Target)));<br/>    System.<strong class="nc ja"><em class="mx">out</em></strong>.println(Arrays.<em class="mx">toString</em>(<em class="mx">findTwoSumSolution2</em>(testCase2nums,testCase2Target)));<br/>    System.<strong class="nc ja"><em class="mx">out</em></strong>.println(Arrays.<em class="mx">toString</em>(<em class="mx">findTwoSumSolution2</em>(testCase3nums,testCase3Target)));<br/>    System.<strong class="nc ja"><em class="mx">out</em></strong>.println(Arrays.<em class="mx">toString</em>(<em class="mx">findTwoSumSolution2</em>(testCase4nums,testCase4Target)));<br/>    System.<strong class="nc ja"><em class="mx">out</em></strong>.println(Arrays.<em class="mx">toString</em>(<em class="mx">findTwoSumSolution2</em>(testCase5nums,testCase5Target)));<br/>  }<br/>}</span></pre><p id="5240" class="pw-post-body-paragraph lg lh iq li b lj mp ka ll lm mq kd lo lp mr lr ls lt ms lv lw lx mt lz ma mb ij bi translated"><strong class="li ja">时间复杂度:</strong> O(n) <br/> <strong class="li ja">空间复杂度:</strong> <em class="mx"> </em> O(n)</p><p id="f41e" class="pw-post-body-paragraph lg lh iq li b lj mp ka ll lm mq kd lo lp mr lr ls lt ms lv lw lx mt lz ma mb ij bi translated">由于我们必须访问数组 nums[]的所有元素，这种方法的时间复杂度是 O(n)。最糟糕的情况是当所需的组合是 for 循环中要检查的最后一个组合时。</p><p id="d3fb" class="pw-post-body-paragraph lg lh iq li b lj mp ka ll lm mq kd lo lp mr lr ls lt ms lv lw lx mt lz ma mb ij bi translated">你可以在<a class="ae mo" href="https://gist.github.com/techisbeautiful/f25b0451d30fd7258cb964af05be4eb9" rel="noopener ugc nofollow" target="_blank"> Github </a>看到这个解决方案的完整代码。</p><h1 id="ac68" class="ko kp iq bd kq kr ks kt ku kv kw kx ky kf kz kg la ki lb kj lc kl ld km le lf bi translated">摘要</h1><p id="c33e" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">在这篇文章中，我分享了一个软件工程师编码面试中的常见问题，以及如何用残酷的力量和最优的解决方案来解决它。感谢您的宝贵时间！</p><p id="64cb" class="pw-post-body-paragraph lg lh iq li b lj mp ka ll lm mq kd lo lp mr lr ls lt ms lv lw lx mt lz ma mb ij bi translated">如果你有任何挑战问题需要帮助，请在评论中告诉我。</p><h1 id="2062" class="ko kp iq bd kq kr ks kt ku kv kw kx ky kf kz kg la ki lb kj lc kl ld km le lf bi translated">参考</h1><p id="d7df" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">本文的问题来自 Leetcode。</p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><p id="86d4" class="pw-post-body-paragraph lg lh iq li b lj mp ka ll lm mq kd lo lp mr lr ls lt ms lv lw lx mt lz ma mb ij bi translated">如果你喜欢这个故事，你可以<a class="ae mo" href="https://medium.com/@techisbeautiful" rel="noopener">关注</a>，<a class="ae mo" href="https://medium.com/subscribe/@techisbeautiful" rel="noopener">订阅我</a>，这样你将是第一个收到我下一篇文章的人！</p><p id="6a88" class="pw-post-body-paragraph lg lh iq li b lj mp ka ll lm mq kd lo lp mr lr ls lt ms lv lw lx mt lz ma mb ij bi translated"><a class="ae mo" href="https://medium.com/@techisbeautiful/membership" rel="noopener">你可以在这里</a>成为媒介会员，拥有<strong class="li ja">无限访问</strong>媒介平台上的每一个故事。如果你使用上面的链接，它也支持我，因为我有一个来自 Medium 的小佣金。谢谢大家的支持！</p></div></div>    
</body>
</html>