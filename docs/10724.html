<html>
<head>
<title>K8s — ipvs Mode Introduction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">K8s — ipvs 模式介绍</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/k8s-ipvs-mode-introduction-6457a02cd91a?source=collection_archive---------2-----------------------#2022-11-25">https://blog.devgenius.io/k8s-ipvs-mode-introduction-6457a02cd91a?source=collection_archive---------2-----------------------#2022-11-25</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="9e0a" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">K8s ipvs 模式详细介绍</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj kg"><img src="../Images/fb64f06bff9f2954179d296702163842.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/0*3RktAlvhFOpBnWH7.png"/></div></figure><h1 id="116b" class="ko kp ir bd kq kr ks kt ku kv kw kx ky jx kz jy la ka lb kb lc kd ld ke le lf bi translated">什么是 ipvs</h1><p id="4304" class="pw-post-body-paragraph lg lh ir li b lj lk js ll lm ln jv lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated"><code class="fe mc md me mf b">ipvs</code>代表 IP 虚拟服务器，它构建在 Netfilter 之上，充当第 4 层(传输)Linux 连接负载平衡器。</p><p id="266f" class="pw-post-body-paragraph lg lh ir li b lj mg js ll lm mh jv lo lp mi lr ls lt mj lv lw lx mk lz ma mb ik bi translated"><code class="fe mc md me mf b">ipvs</code>集成在 LVS (Linux 虚拟服务器)中，它可以将基于 TCP 和 UDP 的服务请求定向到真实服务器，并使真实服务器的服务在单个 IP 地址上表现为虚拟服务。</p><h1 id="21fd" class="ko kp ir bd kq kr ks kt ku kv kw kx ky jx kz jy la ka lb kb lc kd ld ke le lf bi translated">ipvs 负载平衡模式</h1><p id="4275" class="pw-post-body-paragraph lg lh ir li b lj lk js ll lm ln jv lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated"><code class="fe mc md me mf b">ipvs</code>模式使用 IPVS 代替<code class="fe mc md me mf b">iptables</code>，用于连接负载平衡。<code class="fe mc md me mf b">ipvs</code>支持六种负载均衡模式，用<code class="fe mc md me mf b">--ipvs-scheduler</code>指定:</p><ul class=""><li id="17b5" class="ml mm ir li b lj mg lm mh lp mn lt mo lx mp mb mq mr ms mt bi translated"><strong class="li is"> rr </strong>:循环调度，向循环中的下一个主机发送请求</li><li id="0088" class="ml mm ir li b lj mu lm mv lp mw lt mx lx my mb mq mr ms mt bi translated"><strong class="li is"> lc </strong>:最小连接，向最小打开连接服务器发送请求</li><li id="f78a" class="ml mm ir li b lj mu lm mv lp mw lt mx lx my mb mq mr ms mt bi translated"><strong class="li is"> dh </strong>:目的散列，根据连接的目的地址发送请求。</li><li id="8816" class="ml mm ir li b lj mu lm mv lp mw lt mx lx my mb mq mr ms mt bi translated"><strong class="li is"> sh </strong>:源哈希，根据连接的源地址发送请求。</li><li id="0d1d" class="ml mm ir li b lj mu lm mv lp mw lt mx lx my mb mq mr ms mt bi translated"><strong class="li is"> sed </strong>:最短的预期延迟，向连接与权重比最低的主机发送请求。</li><li id="c170" class="ml mm ir li b lj mu lm mv lp mw lt mx lx my mb mq mr ms mt bi translated"><strong class="li is"> nq </strong>:从不排队，发送连接到任何没有现有连接的主机<br/>循环调度(rr)是默认的负载平衡模式。</li></ul><p id="eb47" class="pw-post-body-paragraph lg lh ir li b lj mg js ll lm mh jv lo lp mi lr ls lt mj lv lw lx mk lz ma mb ik bi translated">下图显示了 IPVS 在 Linux 数据包路由中的角色:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gi gj mz"><img src="../Images/4a6bc5c08291674b8fa926a9e0e2c1d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_EoooF5WBQ6ICFdOQs10Tg.png"/></div></div><figcaption class="ne nf gk gi gj ng nh bd b be z dk translated">图片来自詹姆斯·斯特朗</figcaption></figure><h1 id="2f74" class="ko kp ir bd kq kr ks kt ku kv kw kx ky jx kz jy la ka lb kb lc kd ld ke le lf bi translated">ipvs 数据包转发模式</h1><p id="40d7" class="pw-post-body-paragraph lg lh ir li b lj lk js ll lm ln jv lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">IPVS 支持以下三种数据包转发模式:</p><ul class=""><li id="008c" class="ml mm ir li b lj mg lm mh lp mn lt mo lx mp mb mq mr ms mt bi translated"><strong class="li is"> NAT </strong>重写源地址和目的地址。</li><li id="3a16" class="ml mm ir li b lj mu lm mv lp mw lt mx lx my mb mq mr ms mt bi translated">DR 将 IP 数据报封装在 IP 数据报中。</li><li id="560e" class="ml mm ir li b lj mu lm mv lp mw lt mx lx my mb mq mr ms mt bi translated"><strong class="li is"> IP </strong>隧道通过用所选后端服务器的 MAC 地址重写数据帧的 MAC 地址，将数据包直接路由到后端服务器。</li></ul><h1 id="ca23" class="ko kp ir bd kq kr ks kt ku kv kw kx ky jx kz jy la ka lb kb lc kd ld ke le lf bi translated">为什么使用 ipv 而不是 iptables？</h1><p id="616e" class="pw-post-body-paragraph lg lh ir li b lj lk js ll lm ln jv lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">您可能考虑从默认<code class="fe mc md me mf b">iptables</code>模式切换到<code class="fe mc md me mf b">ipvs</code>模式有三个原因:</p><ul class=""><li id="1404" class="ml mm ir li b lj mg lm mh lp mn lt mo lx mp mb mq mr ms mt bi translated"><strong class="li is">可伸缩性</strong>:使用 iptables 的 kube-proxy 是将 K8s 集群扩展到 5000 个节点的瓶颈。一个例子是，在一个 5，000 节点的集群中有一个 NodePort 服务，如果我们有 1，000 个服务，每个服务有 10 个 pods，这将导致每个 worker 节点上至少有 10，000 个 iptables 记录，这会使内核在刷新 iptables 时非常繁忙。</li><li id="4817" class="ml mm ir li b lj mu lm mv lp mw lt mx lx my mb mq mr ms mt bi translated"><strong class="li is">时间</strong>:当有 5000 个服务(40000 个规则)时，添加一个规则所花费的时间是 11 分钟。对于 20，000 个服务(160，000 条规则)，它是 5 个小时(参考:网络和 Kubernetes，詹姆斯·斯特朗)。</li><li id="4b5d" class="ml mm ir li b lj mu lm mv lp mw lt mx lx my mb mq mr ms mt bi translated"><strong class="li is">路由延迟</strong>:访问一个服务有延迟；每个数据包都必须遍历 iptables 列表，直到匹配成功。添加/删除规则会有延迟，在大量列表中插入和删除规则是大规模的密集操作。</li></ul><h1 id="1811" class="ko kp ir bd kq kr ks kt ku kv kw kx ky jx kz jy la ka lb kb lc kd ld ke le lf bi translated">IPVS 演示</h1><h2 id="cec1" class="ni kp ir bd kq nj nk dn ku nl nm dp ky lp nn no la lt np nq lc lx nr ns le nt bi translated">安装 ipvsadm</h2><p id="fc93" class="pw-post-body-paragraph lg lh ir li b lj lk js ll lm ln jv lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">首先我们需要安装<code class="fe mc md me mf b">ipvsadm</code>，这是一个与<code class="fe mc md me mf b">ipvs</code>交互的命令行工具。要安装它:</p><ul class=""><li id="539f" class="ml mm ir li b lj mg lm mh lp mn lt mo lx mp mb mq mr ms mt bi translated">Ubuntu:</li></ul><pre class="kh ki kj kk gu nu mf nv nw aw nx bi"><span id="3185" class="ni kp ir mf b gz ny nz l oa ob">$ apt-get install -y ipvsadm</span></pre><ul class=""><li id="d30f" class="ml mm ir li b lj mg lm mh lp mn lt mo lx mp mb mq mr ms mt bi translated">CentOS/亚马逊 Linux 2</li></ul><pre class="kh ki kj kk gu nu mf nv nw aw nx bi"><span id="aab4" class="ni kp ir mf b gz ny nz l oa ob">$ yum install -y ipvsadm</span></pre><p id="4d72" class="pw-post-body-paragraph lg lh ir li b lj mg js ll lm mh jv lo lp mi lr ls lt mj lv lw lx mk lz ma mb ik bi translated">安装后，您可以通过运行以下命令进行验证:</p><pre class="kh ki kj kk gu nu mf nv nw aw nx bi"><span id="a880" class="ni kp ir mf b gz ny nz l oa ob">$  ipvsadm -v<br/>ipvsadm v1.27 2008/5/15 (compiled with popt and IPVS v1.2.1)<br/>$ ipvsadm -L<br/>IP Virtual Server version 1.2.1 (size=4096)<br/>Prot LocalAddress:Port Scheduler Flags<br/>  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn</span></pre><h2 id="9e8d" class="ni kp ir bd kq nj nk dn ku nl nm dp ky lp nn no la lt np nq lc lx nr ns le nt bi translated">准备容器</h2><p id="23cf" class="pw-post-body-paragraph lg lh ir li b lj lk js ll lm ln jv lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">创建以下两个 HTML 文件，以便我们能够区分两个 Nginx 容器:</p><pre class="kh ki kj kk gu nu mf nv nw aw nx bi"><span id="a81e" class="ni kp ir mf b gz ny nz l oa ob">$ mkdir -p /tmp/nginx-{1,2}<br/>$ echo "nginx 1" &gt; /tmp/nginx-1/index.html<br/>$ echo "nginx 2" &gt; /tmp/nginx-2/index.html</span></pre><p id="ec8e" class="pw-post-body-paragraph lg lh ir li b lj mg js ll lm mh jv lo lp mi lr ls lt mj lv lw lx mk lz ma mb ik bi translated">运行两个容器:</p><pre class="kh ki kj kk gu nu mf nv nw aw nx bi"><span id="bedd" class="ni kp ir mf b gz ny nz l oa ob">$ docker run -d -v "/tmp/nginx-1:/usr/share/nginx/html" --name nginx-1 nginx:1.23.2<br/>ef894ee7a7a252db64e3f0ab89b31063d7471e601458dd182089ecd6a51a3981</span><span id="1868" class="ni kp ir mf b gz oc nz l oa ob">$ docker run -d -v "/tmp/nginx-2:/usr/share/nginx/html" --name nginx-2 nginx:1.23.2<br/>5749c75342cb29aa65d105c0719ec45fea8a200dab9ca69f792d944f070268f5</span></pre><p id="f4bc" class="pw-post-body-paragraph lg lh ir li b lj mg js ll lm mh jv lo lp mi lr ls lt mj lv lw lx mk lz ma mb ik bi translated">获取两个容器的 IP 地址:</p><pre class="kh ki kj kk gu nu mf nv nw aw nx bi"><span id="37a1" class="ni kp ir mf b gz ny nz l oa ob">$ docker inspect nginx-1 | jq ".[0].NetworkSettings.IPAddress"<br/>"172.17.0.2"<br/>$ docker inspect nginx-2 | jq ".[0].NetworkSettings.IPAddress"<br/>"172.17.0.3"</span></pre><p id="b605" class="pw-post-body-paragraph lg lh ir li b lj mg js ll lm mh jv lo lp mi lr ls lt mj lv lw lx mk lz ma mb ik bi translated">验证两个容器:</p><pre class="kh ki kj kk gu nu mf nv nw aw nx bi"><span id="8173" class="ni kp ir mf b gz ny nz l oa ob">$ curl 172.17.0.2<br/>nginx 1<br/> curl 172.17.0.3<br/>nginx 2</span></pre><h2 id="c07c" class="ni kp ir bd kq nj nk dn ku nl nm dp ky lp nn no la lt np nq lc lx nr ns le nt bi translated">创建 ipvs 服务</h2><p id="9461" class="pw-post-body-paragraph lg lh ir li b lj lk js ll lm ln jv lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">此时，我们有两个 Nginx 容器运行在同一台主机上，现在让我们创建一个新的<code class="fe mc md me mf b">ipvs</code>服务，出于演示目的，我们将使用默认的循环负载平衡方法:</p><pre class="kh ki kj kk gu nu mf nv nw aw nx bi"><span id="a333" class="ni kp ir mf b gz ny nz l oa ob">$ ipvsadm -A -t 10.229.36.106:80 -s rr<br/>$ ipvsadm -l -n<br/>IP Virtual Server version 1.2.1 (size=4096)<br/>Prot LocalAddress:Port Scheduler Flags<br/>  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn<br/>TCP  10.229.36.106:80 rr</span></pre><p id="72d1" class="pw-post-body-paragraph lg lh ir li b lj mg js ll lm mh jv lo lp mi lr ls lt mj lv lw lx mk lz ma mb ik bi translated">现在将两个 Nginx 容器与<code class="fe mc md me mf b">ipvs</code>服务关联起来:</p><pre class="kh ki kj kk gu nu mf nv nw aw nx bi"><span id="743c" class="ni kp ir mf b gz ny nz l oa ob">$ ipvsadm -a -t 10.229.36.106:80 -r 172.17.0.2 -m<br/>$ ipvsadm -a -t 10.229.36.106:80 -r 172.17.0.3 -m<br/>$ ipvsadm -L<br/>IP Virtual Server version 1.2.1 (size=4096)<br/>Prot LocalAddress:Port Scheduler Flags<br/>  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn<br/>TCP  ip-10-229-36-106.ec2.interna rr<br/>  -&gt; ip-172-17-0-2.ec2.internal:h Masq    1      0          3<br/>  -&gt; ip-172-17-0-3.ec2.internal:h Masq    1      0          3</span></pre><p id="fca4" class="pw-post-body-paragraph lg lh ir li b lj mg js ll lm mh jv lo lp mi lr ls lt mj lv lw lx mk lz ma mb ik bi translated">现在让我们向服务发送一些请求:</p><pre class="kh ki kj kk gu nu mf nv nw aw nx bi"><span id="0092" class="ni kp ir mf b gz ny nz l oa ob">$ curl 10.229.36.106<br/>nginx 2<br/>[root@ctcloud-ide ~]<em class="od"># curl 10.229.36.106</em><br/>nginx 1<br/>[root@ctcloud-ide ~]<em class="od"># curl 10.229.36.106</em><br/>nginx 2<br/>[root@ctcloud-ide ~]<em class="od"># curl 10.229.36.106</em><br/>nginx 1</span></pre><p id="b761" class="pw-post-body-paragraph lg lh ir li b lj mg js ll lm mh jv lo lp mi lr ls lt mj lv lw lx mk lz ma mb ik bi translated">您可以看到，在这一点上，我们成功地创建了一个<code class="fe mc md me mf b">ipvs</code>服务，它在 nginx-1 和 nginx-2 服务之前充当循环负载平衡器。</p></div></div>    
</body>
</html>