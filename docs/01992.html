<html>
<head>
<title>One Laravel Form Request Class, Multiple HTTP Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个 Laravel 表单请求类，多个 HTTP 方法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/one-laravel-form-request-class-multiple-http-methods-961740b7f630?source=collection_archive---------3-----------------------#2020-07-16">https://blog.devgenius.io/one-laravel-form-request-class-multiple-http-methods-961740b7f630?source=collection_archive---------3-----------------------#2020-07-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/62b96bb7518ca8076d1a5b247944a768.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C5XhH_g5pyHjKzRJjGg-9g.png"/></div></div></figure><p id="5c5b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Laravel 提供了开箱即用的请求验证，这使得在接收表单提交时验证用户输入变得更加容易。在这篇短文中，我将解释表单请求类、它的默认方法，以及如何利用这个表单请求来匹配多个 HTTP 方法。</p><p id="ae7d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">只是指出一点，Laravel 还有一个验证工厂(Illuminate\Validation\Factory)类，在我看来，这个类比表单请求类更常被开发人员使用。</p><p id="d9ed" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">验证工厂类似乎是 Laravel 随控制器提供的默认验证方法，用户无需设置即可通过以下方式在控制器中访问该验证工厂:</p><blockquote class="kt ku kv"><p id="e5d3" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">$this-&gt;validate($request，$rules，$messages，$customAttributes)。</p></blockquote><figure class="la lb lc ld gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/c8ae130846fd2d26065b299c8ce2f2d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hKs-p3BJhbW06UdgLncuxQ.png"/></div></div></figure><p id="a1ce" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">$messages 和$customAttributes 数组是可选的，可以在没有它们的情况下调用该函数，如下所示:</p><blockquote class="kt ku kv"><p id="3e70" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">$this-&gt;validate($request，$rules)。</p></blockquote><p id="8771" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种方法工作得很好，但是当验证逻辑增长时，通常建议将其移动到自己的类中，因此是表单请求类。</p><p id="a324" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">可以使用 Laravel 的 artisan 命令创建表单请求类:</p><blockquote class="kt ku kv"><p id="6fe6" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">php artisan make:请求 RequestClassName</p></blockquote><p id="a47f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个命令将在 Laravel 应用程序的 app\Http 目录中创建一个 Requests 文件夹，并使用创建 FormRequest 类时传递的类名创建一个 FormRequest 类，在我们的例子中是 requestClassName。</p><figure class="la lb lc ld gt jo gh gi paragraph-image"><div class="gh gi le"><img src="../Images/666a8772e6d119228049faaf67933a87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*b-jShBe7idGr5pZIbR60Pw.png"/></div></figure><p id="d093" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">简单解释一下 FormRequest 类的内容，该类附带了两个方法:authorize 和 rules。</p><pre class="la lb lc ld gt lf lg lh li aw lj bi"><span id="20e2" class="lk ll in lg b gy lm ln l lo lp">&lt;?php<br/><br/>namespace App\Http\Requests;<br/><br/>use Illuminate\Foundation\Http\FormRequest;<br/><br/>class CreateNewRequest extends FormRequest<br/>{<br/>    <em class="kw">/**<br/>     * Determine if the user is authorized to make this request.<br/>     *<br/>     * </em><strong class="lg io"><em class="kw">@return </em></strong><em class="kw">bool<br/>     */<br/>    </em>public function authorize()<br/>    {<br/>        return false;<br/>    }<br/><br/>    <em class="kw">/**<br/>     * Get the validation rules that apply to the request.<br/>     *<br/>     * </em><strong class="lg io"><em class="kw">@return </em></strong><em class="kw">array<br/>     */<br/>    </em>public function rules()<br/>    {<br/>        return [<br/>            //<br/>        ];<br/>    }<br/>}</span></pre><p id="6137" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">authorize 方法检查用户是否被授权发出请求，因此这里的一个示例用例可以是一个博客系统，其中只有帖子创建者可以编辑他/她的帖子。假设博客帖子有一个 user_id 列，用于跟踪哪个用户发布了该帖子，那么 authorize 函数可以如下所示:</p><pre class="la lb lc ld gt lf lg lh li aw lj bi"><span id="c607" class="lk ll in lg b gy lm ln l lo lp"><em class="kw">/**<br/> * Determine if the user is authorized to make this request.<br/> *<br/> * </em><strong class="lg io"><em class="kw">@return </em></strong><em class="kw">bool<br/> */<br/></em>public function authorize()<br/>{<br/>   return $blogPost-&gt;user_id === auth()-&gt;id();<br/>}</span></pre><p id="5ebb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，只有当博客帖子编辑请求是由博客帖子所有者发出时，它才返回 true，然后继续处理编辑请求，否则，它将返回 false，并向用户抛出一个异常，继续下一个方法。</p><p id="b26c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">rules 方法包含利用 FormRequest 类的任何表单的验证逻辑。</p><p id="5e7e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">FormRequest 类可以注入到您希望 FormRequest 验证逻辑为真的任何方法中，这将清理您的控制器。</p><figure class="la lb lc ld gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/9ec6099e1c8d7762d3f69b862bd9a06e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JGOPDQaYTcu03EksO9S0Tw.png"/></div></div></figure><p id="7ab0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在解释了围绕可用的 validate 方法和用户创建的表单请求类的概念之后，让我转到本文旨在阐明的主要问题。</p><p id="d56a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">理想情况下，创建和更新模型的记录可能需要对模型的列进行不同的验证，举个例子，让我们继续使用 blog 类比。</p><p id="8dfc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要创建一个博客，我们可能会决定需要一个图像，博客文章名称是必需的，与博客文章内容相同，但是在更新文章时，博客文章图像不一定是必需的，它变成了一个可选的验证。</p><pre class="la lb lc ld gt lf lg lh li aw lj bi"><span id="be0b" class="lk ll in lg b gy lm ln l lo lp"><em class="kw">/**<br/> * Get the validation rules that apply to the request.<br/> *<br/> * </em><strong class="lg io"><em class="kw">@return </em></strong><em class="kw">array<br/> */<br/></em>public function rules()<br/>{<br/>    //blog post creation rules<br/>    <br/>    return [<br/>        'name' =&gt; 'string | required',<br/>        'content' =&gt; 'string | required',<br/>        'image' =&gt; 'image | required'<br/>    ];<br/>}</span><span id="88a1" class="lk ll in lg b gy lq ln l lo lp"><em class="kw">/**<br/> * Get the validation rules that apply to the request.<br/> *<br/> * </em><strong class="lg io"><em class="kw">@return </em></strong><em class="kw">array<br/> */<br/></em>public function rules()<br/>{<br/>    //blog post update rules<br/>    <br/>    return [<br/>        'name' =&gt; 'string | required',<br/>        'content' =&gt; 'string | required',<br/>        'image' =&gt; 'image'<br/>    ];<br/>}</span></pre><p id="0a59" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面的两个规则是不同的，如果我想坚持表单请求类的验证方式，我可能必须创建更多的表单请求类，因为我对 POST、PUT、PATCH 和 DELETE 有不同的验证逻辑。要仅用一个表单类解决这个问题，可以编辑表单请求，使其更加通用，从而为不同的 HTTP 动词提供不同的规则。请参见下面的代码示例:</p><pre class="la lb lc ld gt lf lg lh li aw lj bi"><span id="1711" class="lk ll in lg b gy lm ln l lo lp">protected $rules = [<br/>    <br/>];</span><span id="09a8" class="lk ll in lg b gy lq ln l lo lp"><em class="kw">/**<br/> * Get the validation rules that apply to the request.<br/> *<br/> * </em><strong class="lg io"><em class="kw">@return </em></strong><em class="kw">array<br/> */<br/></em>public function rules()<br/>{<br/>    $method = $this-&gt;method();<br/>    if (null !== $this-&gt;get('_method', null)) {<br/>        $method = $this-&gt;get('_method');<br/>    }<br/>    $this-&gt;offsetUnset('_method');<br/>    switch ($method) {<br/>        case 'DELETE':<br/>        case 'GET':<br/>                $this-&gt;rules = [];<br/>            break;<br/><br/>        case 'POST':<br/><br/>            break;<br/>        // in case of edit<br/>        case 'PUT':<br/>        case 'PATCH':<br/><br/>            break;<br/>        default:<br/>            break;<br/>    }<br/><br/>    return $this-&gt;rules;<br/>}</span></pre><p id="20dc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">解释:</p><pre class="la lb lc ld gt lf lg lh li aw lj bi"><span id="a988" class="lk ll in lg b gy lm ln l lo lp">$method = $this-&gt;method();</span></pre><p id="9e9f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面的代码片段从请求对象中检索 HTTP 方法，并将其存储到变量$method，next 中。</p><pre class="la lb lc ld gt lf lg lh li aw lj bi"><span id="6744" class="lk ll in lg b gy lm ln l lo lp">if (null !== $this-&gt;get('_method', null)) {<br/>        $method = $this-&gt;get('_method');<br/>    }</span></pre><p id="d292" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">知道 Laravel 有办法使用@method()指令屏蔽或更改原始请求方法后，代码会测试是否在请求对象中指定了一个方法，如果是，它会用它更新方法变量。</p><pre class="la lb lc ld gt lf lg lh li aw lj bi"><span id="c1d9" class="lk ll in lg b gy lm ln l lo lp">$this-&gt;offsetUnset('_method');</span></pre><p id="6d94" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这从请求对象中删除了“_method”属性，这样我们就实现了发送到应用程序的 HTTP 请求的类型，然后可以为每种请求类型提供不同的规则。</p><pre class="la lb lc ld gt lf lg lh li aw lj bi"><span id="dc52" class="lk ll in lg b gy lm ln l lo lp">switch ($method) {<br/>        case 'DELETE':<br/>                $this-&gt;rules = [ //rules here for delete request];<br/>            break;</span><span id="24d7" class="lk ll in lg b gy lq ln l lo lp">        case 'GET':<br/>                $this-&gt;rules = [ //rules here for get request];<br/>            break;<br/><br/>        case 'POST':<br/>               $this-&gt;rules = [//rules here for post request];<br/>            break;</span><span id="8c50" class="lk ll in lg b gy lq ln l lo lp">        case 'PUT':<br/>               $this-&gt;rules = [//rules here for put request];<br/>            break;   <br/>     <br/>        case 'PATCH':<br/>               $this-&gt;rules = [//rules here for patch request];<br/>            break;</span><span id="a6ed" class="lk ll in lg b gy lq ln l lo lp">        default:<br/>            break;<br/>    }<br/><br/>    return $this-&gt;rules;</span></pre><p id="6b4f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面的 switch 语句用每个请求类型的适当验证逻辑更新规则数组，并帮助您将它们全部放在一个请求类中。</p><blockquote class="kt ku kv"><p id="3ec5" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">在推特上关注我:<a class="ae lr" href="https://twitter.com/drumzminister" rel="noopener ugc nofollow" target="_blank">https://twitter.com/drumzminister</a></p></blockquote></div></div>    
</body>
</html>