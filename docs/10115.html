<html>
<head>
<title>Service objects, ruby, OOP and FP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">服务对象，ruby，OOP 和 FP</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/moving-away-from-oop-towards-fp-in-ror-c453cdaaf456?source=collection_archive---------5-----------------------#2022-10-08">https://blog.devgenius.io/moving-away-from-oop-towards-fp-in-ror-c453cdaaf456?source=collection_archive---------5-----------------------#2022-10-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/bc7ea686a82024c0d7fc20b334572310.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2FfTtxjqAbXbYDLv.png"/></div></div></figure><p id="83a9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这篇笔记是我个人在多范例中实现 FP 方法的观察和旅程，但是非常倾向于 OOP，编程语言——Ruby(在这种情况下是在 Rails 上)。</p><p id="830b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你刚刚接触到软件工程，你可能会注意到 2022 年的今天的人们对函数式编程范式非常积极和热情。像 Elixir、JS &amp; TS、Rust、F#这样的语言变得越来越普遍，社区中越来越多的人开始接受<a class="ae kt" href="https://en.wikipedia.org/wiki/Functional_programming" rel="noopener ugc nofollow" target="_blank">函数式编程</a>的理念——数据不变性、缺乏共享状态、作为一等公民的函数等等。</p><p id="b4d8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但情况并非总是如此。事实上并不是这样(还没有？)要么，这只是朝着那个方向迈出的一步。大多数企业软件都是用一种占主导地位的编程范例——面向对象编程——来构建的，大多数软件工程书籍也是这样写的。我甚至不会试图给出我对每一个问题的赞成和反对意见，无论如何不会在这篇笔记中给出。相反，我要做的是从 RoR 的角度，给你们一些我个人对 OOP -&gt; FP 转变的经验。</p><p id="6690" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，让我们假设您正在构建 REST API 来支持您美妙的 SPA，并且已经意识到您的业务逻辑太大而不适合您的模型，但是还没有大到可以使用 DDD。无论如何，在典型的 RoR 应用程序中，你将最终编写<a class="ae kt" href="https://blog.appsignal.com/2020/06/17/using-service-objects-in-ruby-on-rails.html" rel="noopener ugc nofollow" target="_blank">服务对象</a>。</p><p id="6449" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通常情况下，它看起来像这样</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="da10" class="ld le in kz b gy lf lg l lh li"># For some reason, your business requires to take two params, increment first, double second, sum them and double this some.</span><span id="a27a" class="ld le in kz b gy lj lg l lh li"><br/>#app/services/my_service.rb</span><span id="7ce9" class="ld le in kz b gy lj lg l lh li">class <em class="lk">MyService<br/>  </em>def initialize(<em class="lk">param1</em>, <em class="lk">param2</em>)<br/>    @param1 = <em class="lk">param1<br/>    </em>@param2 = <em class="lk">param2<br/>  </em>end<br/><br/>  def call<br/>    <em class="lk">incremented_first_param </em>= @param1 + 1<br/>    <em class="lk">doubled_second_param </em>= @param2 * 2<br/>    <em class="lk">params_sum </em>= <em class="lk">incremented_first_param </em>+ <em class="lk">doubled_second_param<br/>    doubled_sum </em>= <em class="lk">params_sum </em>* 2<br/>    <em class="lk">doubled_sum<br/>  </em>end<br/>end</span><span id="ccc9" class="ld le in kz b gy lj lg l lh li"># Later in the controller<br/># app/controllers/my_controller.rb</span><span id="a359" class="ld le in kz b gy lj lg l lh li">class <em class="lk">MyController<br/>  </em>def my_controller_action<br/>    <em class="lk">param1 </em>= params[:param1]<br/>    <em class="lk">param2 </em>= params[:param2]<br/>    <em class="lk">service </em>= MyService.new(<em class="lk">param1</em>, <em class="lk">param2</em>)<br/>    <em class="lk">result </em>= <em class="lk">service</em>.call<br/><br/>    render json: { result: <em class="lk">result </em>}<br/>  end<br/>end</span></pre><p id="c223" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">太好了，你来了。它可以工作，并且它将业务逻辑从控制器和模型中移走——为了方便起见，我们假设有一些 ActiveRecord 模型正在进行一些持久性调用，并且您不想用我们“复杂”的业务逻辑来打扰它。</p><p id="fc2b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后你读了一两篇文章，决定不直接使用实例变量，而是用 attr_readers 替换它们，并使它们私有，以避免暴露它们和违反<a class="ae kt" href="https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)" rel="noopener ugc nofollow" target="_blank">封装</a>。此外，您可能希望将一些操作转移到它自己的方法中。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="78c0" class="ld le in kz b gy lf lg l lh li"><em class="lk">#app/services/my_service.rb<br/></em>class <em class="lk">MyService<br/>  </em>def initialize(<em class="lk">param1</em>, <em class="lk">param2</em>)<br/>    @param1 = <em class="lk">param1<br/>    </em>@param2 = <em class="lk">param2<br/>  </em>end<br/><br/>  def call<br/>    <em class="lk">incremented_first_param </em>= increment(param1)<br/>    <em class="lk">doubled_second_param </em>= double(param2)<br/>    <em class="lk">params_sum </em>= sum(<em class="lk">incremented_first_param</em>, <em class="lk">doubled_second_param</em>)<br/>    <em class="lk">doubled_sum </em>= double(<em class="lk">params_sum</em>)<br/>    <em class="lk">doubled_sum<br/>  </em>end<br/><br/>  private<br/><br/>  attr_reader :param1, :param2<br/><br/>  def increment(<em class="lk">param</em>)<br/>    <em class="lk">param </em>+ 1<br/>  end<br/><br/>  def double(<em class="lk">param</em>)<br/>    @param2 = @param2 * 2</span><span id="ec7c" class="ld le in kz b gy lj lg l lh li">    <em class="lk">param </em>* 2<br/>  end<br/><br/>  def sum(<em class="lk">param1</em>, <em class="lk">param2</em>)<br/>    <em class="lk">param1 </em>+ <em class="lk">param2<br/>  </em>end<br/>end</span></pre><p id="5a40" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一切都好了，对吧？但是等等，有一个 bug。在“double”方法中，我们意外地改变了 param2 的状态，它是 instance_variable。我们可以通过删除这一行来解决这个问题，但是我们能排除这种可能的错误吗？我们能不能去掉实例变量，所以去掉共享状态，只对参数进行操作？</p><p id="3fdc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以试试。如果我们不使用构造函数来设置服务和实例变量作为存储输入参数的地方，而是只接收输入参数并在其上运行操作，会怎么样？</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="a5dc" class="ld le in kz b gy lf lg l lh li"><em class="lk">#app/services/my_service.rb<br/></em>class <em class="lk">MyService<br/>  </em>def call(<em class="lk">param1</em>, <em class="lk">param2</em>)<br/>    <em class="lk">incremented_first_param </em>= increment(<em class="lk">param1</em>)<br/>    <em class="lk">doubled_second_param </em>= double(<em class="lk">param2</em>)<br/>    <em class="lk">params_sum </em>= sum(<em class="lk">incremented_first_param</em>, <em class="lk">doubled_second_param</em>)<br/>    <em class="lk">doubled_sum </em>= double(<em class="lk">params_sum</em>)<br/>    <em class="lk">doubled_sum<br/>  </em>end<br/><br/>  private<br/><br/>  def increment(<em class="lk">param</em>)<br/>    <em class="lk">param </em>+ 1<br/>  end<br/><br/>  def double(<em class="lk">param</em>)<br/>    <em class="lk">param </em>* 2<br/>  end<br/><br/>  def sum(<em class="lk">param1</em>, <em class="lk">param2</em>)<br/>    <em class="lk">param1 </em>+ <em class="lk">param2<br/>  </em>end<br/>end</span><span id="3c03" class="ld le in kz b gy lj lg l lh li"># Later in the controller or other service</span><span id="1e0f" class="ld le in kz b gy lj lg l lh li">service = MyService.new<br/>result = service.call(param1, param2)</span></pre><p id="06d1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每次都调用构造函数，只是为了用参数调用方法，这有点烦人。把那个也修好怎么样？我们想要某种“静态”方法，就像 Java 或 C#中的方法一样。而有这样的，就叫“类法”。我将向您展示实现它们两种常用方法。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="c281" class="ld le in kz b gy lf lg l lh li"><em class="lk">#app/services/my_service.rb</em></span><span id="8954" class="ld le in kz b gy lj lg l lh li"># Using class &lt;&lt; self<br/>module <em class="lk">MyService<br/>  </em>class &lt;&lt; self<br/>    def call(<em class="lk">param1</em>, <em class="lk">param2</em>)<br/>      <em class="lk">incremented_first_param </em>= increment(<em class="lk">param1</em>)<br/>      <em class="lk">doubled_second_param </em>= double(<em class="lk">param2</em>)<br/>      <em class="lk">params_sum </em>= sum(<em class="lk">incremented_first_param</em>, <em class="lk">doubled_second_param</em>)<br/>      <em class="lk">doubled_sum </em>= double(<em class="lk">params_sum</em>)<br/>      <em class="lk">doubled_sum<br/>    </em>end<br/><br/>    private<br/><br/>    def increment(<em class="lk">param</em>)<br/>      <em class="lk">param </em>+ 1<br/>    end<br/><br/>    def double(<em class="lk">param</em>)<br/>      <em class="lk">param </em>* 2<br/>    end<br/><br/>    def sum(<em class="lk">param1</em>, <em class="lk">param2</em>)<br/>      <em class="lk">param1 </em>+ <em class="lk">param2<br/>    </em>end<br/>  end<br/>end</span><span id="51b3" class="ld le in kz b gy lj lg l lh li"># Using private_class_method<br/>class <em class="lk">MyService<br/>  </em>def self.call(<em class="lk">param1</em>, <em class="lk">param2</em>)<br/>    <em class="lk">incremented_first_param </em>= increment(<em class="lk">param1</em>)<br/>    <em class="lk">doubled_second_param </em>= double(<em class="lk">param2</em>)<br/>    <em class="lk">params_sum </em>= sum(<em class="lk">incremented_first_param</em>, <em class="lk">doubled_second_param</em>)<br/>    <em class="lk">doubled_sum </em>= double(<em class="lk">params_sum</em>)<br/>    <em class="lk">doubled_sum<br/>  </em>end<br/>  <br/>  private_class_method def self.increment(<em class="lk">param</em>)<br/>    <em class="lk">param </em>+ 1<br/>  end<br/><br/>  private_class_method def self.double(<em class="lk">param</em>)<br/>    <em class="lk">param </em>* 2<br/>  end<br/><br/>  private_class_method def self.sum(<em class="lk">param1</em>, <em class="lk">param2</em>)<br/>    <em class="lk">param1 </em>+ <em class="lk">param2<br/>  </em>end<br/>end</span><span id="bbb3" class="ld le in kz b gy lj lg l lh li"># Later in your code<br/>result = MyService.call(param1, param2)</span></pre><p id="942b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在感觉好多了吧？</p><ul class=""><li id="8e82" class="ll lm in jx b jy jz kc kd kg ln kk lo ko lp ks lq lr ls lt bi translated">去掉烦人的 MyService.new.call，只使用它作为函数调用</li><li id="53d1" class="ll lm in jx b jy lu kc lv kg lw kk lx ko ly ks lq lr ls lt bi translated">去掉了实例变量和共享状态，这使得代码不容易出错</li></ul><p id="6c3e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有点烦人的是，在一个例子中，我们有一个带有奇怪的“<a class="ae kt" href="https://stackoverflow.com/questions/2505067/class-self-idiom-in-ruby" rel="noopener ugc nofollow" target="_blank">类&lt; &lt;自我</a>习语”的模块，而在另一个例子中，我们有一个长方法定义。</p><p id="7089" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对此我们能做些什么吗？当然有，是红宝石！就在最近，我的一位同事分享了这种方法</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="de97" class="ld le in kz b gy lf lg l lh li"><em class="lk">#app/services/my_service.rb<br/></em>module <em class="lk">MyService<br/>  </em>extend self<br/><br/>  def call(<em class="lk">param1</em>, <em class="lk">param2</em>)<br/>    <em class="lk">incremented_first_param </em>= increment(<em class="lk">param1</em>)<br/>    <em class="lk">doubled_second_param </em>= double(<em class="lk">param2</em>)<br/>    <em class="lk">params_sum </em>= sum(<em class="lk">incremented_first_param</em>, <em class="lk">doubled_second_param</em>)<br/>    <em class="lk">doubled_sum </em>= double(<em class="lk">params_sum</em>)<br/>    <em class="lk">doubled_sum<br/>  </em>end<br/><br/>  private<br/><br/>  def increment(<em class="lk">param</em>)<br/>    <em class="lk">param </em>+ 1<br/>  end<br/><br/>  def double(<em class="lk">param</em>)<br/>    <em class="lk">param </em>* 2<br/>  end<br/><br/>  def sum(<em class="lk">param1</em>, <em class="lk">param2</em>)<br/>    <em class="lk">param1 </em>+ <em class="lk">param2<br/>  </em>end<br/>end</span></pre><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lz"><img src="../Images/b6afd0441e5a90362dcc9fe5a17644cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZHeeGpJL0nuCNynAwCOAYg.png"/></div></div></figure><p id="cea8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在接下来的笔记中，我们将讨论函数式编程和 ruby 的其他部分。</p><p id="7a35" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你觉得这些怎么样？你喜欢哪一个？你不反对 FP 的概念和想法吗？请在评论中告诉我，感谢你花时间阅读这篇文章，希望你和我一样喜欢！</p></div></div>    
</body>
</html>