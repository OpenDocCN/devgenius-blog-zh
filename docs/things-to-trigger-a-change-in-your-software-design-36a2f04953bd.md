# 引发软件设计变化的事情

> 原文：<https://blog.devgenius.io/things-to-trigger-a-change-in-your-software-design-36a2f04953bd?source=collection_archive---------3----------------------->

软件设计是迭代的，唯一不会发生这种情况的是如果你不需要添加更多的功能并且没有错误。我还没见过这种情况。

![](img/333b0ac2343e1c2f24683c04cb5fad99.png)

我喜欢做[进化设计](/evolutionary-design-cfb1795e8f81?sk=b32e3f4396a3576ea88726d8ce8fc73b)而不是预先设计。此外，我试图遵循 [YAGNI](https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it) 原则，所以我喜欢思考我的代码的未来，但是我不会写任何我不需要的东西，直到我有证据证明我需要它。大多数时候，我发现一种与我的第一种方法非常不同的方法，即使我意识到我的第一种方法根本没有意义。

这听起来可能很奇怪，但我真的认为这对避免过度工程很有帮助。所以基本上我更喜欢在代码中制造一个小问题，在它还很小的时候解决它(重构)。我们不能等太久，因为如果问题太大，解决问题的成本将非常高，而且很难证明是合理的，但我们需要确定该做什么。你可以通过玩代码来理解它，并使用[代码气味来选择你的权衡](https://www.codurance.com/publications/2016/05/07/code-smells-part-ii)。我认为这是人们认为预先设计更好的原因之一，因为你可以在问题产生之前就预见到它。这是一个幻想，没有人能够预测未来。

## 小问题

代码的变化基于所做事情的历史(技术债务、架构、团队文化)，但也基于我们想要引入的新特性，所以一年前完成的设计在今天可能并不好。在我看来，第一次尝试编写完美的代码通常是当今开发的最大问题之一，因为团队通常不会重新审视这一点。设计是迭代的，你不可能在未来五年设计出完美的东西，没人能做到。
关键是代码中有小问题，而不是大问题，所以现在我们可以改变游戏，我们只需要在看到它们增长时修复它们。

在某种意义上，我认为这使软件设计民主化了。没有必要在公司里呆上一年又一年来决定如何塑造事物。你只需要阅读你的代码，学习如何识别小问题，然后你需要工具来修复这些问题。

根据你识别这些问题的能力，你可以冒更大的风险，尝试更早地应用解决方案。这可以在你有丰富经验的时候完成，如果你没有，就等到代码中的问题清楚了，再想办法解决它。学习如何解决这个问题大部分时候是一个记忆一些预定义步骤的问题([重构书](https://refactoring.guru/refactoring))，其他时候是一个测试不同方法并做出权衡的问题。

## 单元测试

对我来说，测试是我设计中的一大问题来源。[单元测试](/unit-tests-c70618dc1e25?sk=de16c7a7bec6fa068728441e55365c97)是我的部分代码的客户，他们需要处理产品代码。我更喜欢不回避我的设计在内部测试中的问题，隐藏它们，这是我不喜欢[建造者](/why-i-dont-like-the-builder-pattern-e05423698a9a?sk=ab3e214029e33109be6c2157f66b5dfa)的原因之一。
这就像扮演将要使用我的代码的开发人员的角色，设计使用我的代码的体验也是软件设计，可能是软件设计的最大部分之一。

我的测试反馈的一些例子:

*   为了创建一个测试场景，我必须创建几个复杂的类以及它们之间的交互。也许这种设置需要在被测试的类/模块内部完成，也许我可以简化这种体验。
*   在我的测试中有多个断言，这通常意味着我在测试的行为中有太多的责任。也许我们必须拆分所有被测试行为所做的事情。
*   大的[数据块](https://martinfowler.com/bliki/DataClump.html)有许多要创建的空值。对我来说，这意味着我们没有遵守接口分离原则。也许这个数据块与许多其他行为紧密相关，也许我们没有遵循德米特定律。
*   测试爆炸，如果你正在测试一个方法或者一个功能，并且你需要很多测试，其中一些测试关注方法的不同方面，那么你的方法可能没有遵守单一责任原则。尝试创建一个合作者，独立测试它，并在第一个中进行模拟，这将解决测试爆炸的问题。
*   构造函数中的空值，如果你需要创建一个有空值的类，因为一些合作者没有被使用也许你的类内聚性很低，这是需要创建一个新类的另一个征兆。这就是为什么我喜欢在测试中使用空值作为虚拟值，用于不使用的东西(来标记测试所需的真实数据)。

还有更多的东西，但我认为这些对我来说是更多的共同点。

## 生产代码

从设计的角度来看，当我必须添加一个行为时，我首先要做的是，我必须把代码放在哪里来解决问题。不是写代码，而是关注哪里是写代码的好地方。确定代码应该工作的部分是一个很好的调查练习。
我喜欢 [GOF 模式](https://refactoring.guru/design-patterns)我认为它们是很棒的解决方案，但我认为最好从[掌握](https://en.wikipedia.org/wiki/GRASP_(object-oriented_design))模式(责任模式)开始。试图理解谁负责做什么。他们可以给你一些为什么，而不是如何:

*   信息专家—行为带着行为管理的数据转到对象
*   创建者——谁负责创建对象？。让我们选择它最小化耦合和最大化内聚
*   控制器——控制器模式将处理系统事件的责任分配给代表整个系统或用例场景的非 UI 类。
*   间接性——软件工程的**基本定理** ( **FTSE** ) *“我们可以通过引入一个额外的层次* [*间接性*](https://en.wikipedia.org/wiki/Indirection) *来解决任何问题。”*
*   低耦合——我们系统的一个单元与我们系统的其他单元的关联程度。例如，如果一个类使用另一个类，那么这个类就是与另一个类耦合的。
*   高内聚——一个单元、模块或类与正在使用的数据的相关程度。例如，在一个有三个属性的类中，如果大多数方法只使用两个属性，并且只有一个方法使用另一个属性，那么这个信息和这个方法可能与这个类无关，这就是一个低内聚的例子。
*   多态——将逻辑移至您的类层次结构中决定行为的那些孩子。
*   受保护的变化——代码中的 if 可以被翻译成接口下的行为
*   纯粹的虚构——如果我不知道在哪里放一个方法或一个类，让我们把它放在一个与领域问题无关但能解决问题的类中。

## 重构

重构是一种很好的设计方式，如果你使用重构来解决代码中的小问题，并且不使它们变得太大，你将能够在代码库的每次变化中进行设计。不重构的结果是缓慢地尝试破解当前的设计。每一次添加新功能都会变得更加困难。
[马丁·福勒的《重构》一书](https://martinfowler.com/books/refactoring.html)还介绍了另一个伟大的工具:

*   许多小的重构可以创造一个大的重构。[很多小步骤让大改变变得容易](/a-lot-of-tiny-steps-16eaac27acb4?sk=3aaec6e2fd13f9710ecce4935c2189bc)。

在那本书里，你可以发现很多问题来改进设计，以及以安全和可测试的方式解决这些问题的步骤。

我不是说这是最好的设计方式，我认为这是更便宜的方式，但我没有数据来证明这一点。我想说的是，无论如何你都需要学习如何改进你的代码，那么为什么不尝试使用这些重构技术来设计呢？。