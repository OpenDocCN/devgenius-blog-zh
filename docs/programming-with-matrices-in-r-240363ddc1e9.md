# 用 R 语言中的矩阵编程

> 原文：<https://blog.devgenius.io/programming-with-matrices-in-r-240363ddc1e9?source=collection_archive---------8----------------------->

矩阵是 R 编程语言中非常重要的数据结构，和 vector 一样，它的所有值都是相同的数据类型。它们广泛用于机器学习模型，如线性回归、逻辑回归等。线性代数是机器学习和深度学习算法的主要组成部分。矩阵广泛用于优化和寻找回归的最佳拟合线。在本文中，我们将讨论以下主题。

*   用 R 编程语言创建矩阵
*   更新、访问和更改矩阵的维度
*   使用 ***cbind(V1，V2)*** 函数将向量 V1 和 V2 绑定到按列排列的矩阵中。
*   使用 ***rbind(V1，V2)*** 函数来将向量 V1 和 V2 按行绑定到行矩阵中
*   两个矩阵的逐元素乘法
*   M1 和 M2 的矩阵乘法
*   矩阵的转置
*   矩阵的行列式
*   使用 ***rowSums()*** 函数计算矩阵的行和。
*   使用 ***colSums()*** 函数计算矩阵的列和。
*   使用 ***colMeans()*** 函数计算矩阵的列平均值
*   使用 ***rowMeans()*** 函数计算矩阵的行平均值。

![](img/97555294081f029c9c95edc76eaee59d.png)

[亨利&公司](https://unsplash.com/@hngstrm?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

# 在 R 中创建矩阵

使用 ***matrix(V，ncol，nrow，byrow)*** 函数创建一个矩阵，该函数采用下面给出的三个参数

*   ***V*** 是数据元素的向量
*   ***ncol*** 表示矩阵的列数
*   ***nrow*** 表示矩阵的行数
*   如果 ***byrow*** 值为真，则行将按行排列，否则按列排列

```
V <- c(1:9)
M <- matrix(V, ncol = 3, nrow = 3)
M
##      [,1] [,2] [,3]
## [1,]    1    4    7
## [2,]    2    5    8
## [3,]    3    6    9M <- matrix(V, ncol = 3, nrow = 3, byrow = FALSE)
M
##      [,1] [,2] [,3]
## [1,]    1    4    7
## [2,]    2    5    8
## [3,]    3    6    9M <- matrix(V, ncol = 3, nrow = 3, byrow = TRUE)
M
##      [,1] [,2] [,3]
## [1,]    1    2    3
## [2,]    4    5    6
## [3,]    7    8    9
```

现在我们将使用 cbind()和 rbind()函数创建一个矩阵。

*   ***cbind(V1，V2)*** 将向量 V1 和 V2 绑定到按列的矩阵中。
*   ***rbind(V1，V2)*** 将向量 V1 和 V2 逐行绑定到逐行矩阵中

```
roll_no <- c(11, 12, 13, 14, 15)
marks <- c(98, 85, 96, 36, 89)M2 <- cbind(roll_no, marks)
M2
##      roll_no marks
## [1,]      11    98
## [2,]      12    85
## [3,]      13    96
## [4,]      14    36
## [5,]      15    89M3 <- rbind(roll_no, marks)
M3
##         [,1] [,2] [,3] [,4] [,5]
## roll_no   11   12   13   14   15
## marks     98   85   96   36   89
```

# 访问矩阵中的元素

我们可以使用方括号[行，列]来访问矩阵的元素

*   访问第三行的第二个条目
*   访问第二行的第一个条目

```
roll_no <- c(11, 12, 13, 14, 15)
marks <- c(98, 85, 96, 36, 89)
M <- cbind(roll_no, marks)
M
##      roll_no marks
## [1,]      11    98
## [2,]      12    85
## [3,]      13    96
## [4,]      14    36
## [5,]      15    89M[3, 2]
## marks 
##    96M[2, 1]
## roll_no 
##      12
```

*   访问矩阵的第 3 行

```
M[3, ]
## roll_no   marks 
##      13      96
```

*   访问矩阵的第二列

```
M[, 2]
## [1] 98 85 96 36 89
```

*   访问矩阵的第一列

```
M[, 1]
## [1] 11 12 13 14 15
```

*   移除矩阵的第一行并返回剩余的矩阵

```
M[-1, ]
##      roll_no marks
## [1,]      12    85
## [2,]      13    96
## [3,]      14    36
## [4,]      15    89
```

*   移除矩阵的第一列并返回

```
M[, -1]
## [1] 98 85 96 36 894
```

*   使用逻辑索引访问行

```
M[c(TRUE, FALSE,FALSE,TRUE, TRUE), ]
##      roll_no marks
## [1,]      11    98
## [2,]      14    36
## [3,]      15    89
```

*   通过给定向量作为索引值来访问矩阵的行和列

```
M[c(1, 3, 4), c('marks')]
## [1] 98 96 36M[c(1, 3, 4), c('marks', 'roll_no')]
##      marks roll_no
## [1,]    98      11
## [2,]    96      13
## [3,]    36      14
```

# 更新矩阵元素

要更改任何现有的矩阵元素，我们可以简单地通过索引访问元素，并重新分配新值

更新编号为 14 且分数为 36 到 96 的学生的分数。

```
roll_no <- c(11, 12, 13, 14, 15)
marks <- c(98, 85, 96, 36, 89)
M <- cbind(roll_no, marks)
M
##      roll_no marks
## [1,]      11    98
## [2,]      12    85
## [3,]      13    96
## [4,]      14    36
## [5,]      15    89M[4, 2] <- 96
M
##      roll_no marks
## [1,]      11    98
## [2,]      12    85
## [3,]      13    96
## [4,]      14    96
## [5,]      15    89
```

*   我们可以使用 ***rbind()*** 向现有矩阵添加额外的行
*   我们可以使用 ***cbind()*** 向现有矩阵添加额外的列
*   我们可以通过输入负数来删除一行。 ***M[-row，col]***
*   我们可以通过输入负数来删除一列。 ***M【行，-列】***

```
roll_no <- c(11, 12, 13, 14, 15)
marks <- c(98, 85, 96, 36, 89)
M <- cbind(roll_no, marks)
M
##      roll_no marks
## [1,]      11    98
## [2,]      12    85
## [3,]      13    96
## [4,]      14    36
## [5,]      15    89M[4, 2] <- 96
M
##      roll_no marks
## [1,]      11    98
## [2,]      12    85
## [3,]      13    96
## [4,]      14    96
## [5,]      15    89rbind(M, c(17, 80))
##      roll_no marks
## [1,]      11    98
## [2,]      12    85
## [3,]      13    96
## [4,]      14    96
## [5,]      15    89
## [6,]      17    80grade <- c(8, 9, 6, 5, 4, 8)
M <- cbind(M, grade)
M
##      roll_no marks grade
## [1,]      11    98     8
## [2,]      12    85     9
## [3,]      13    96     6
## [4,]      14    96     5
## [5,]      15    89     4M[-c(2, 3), ]
##      roll_no marks grade
## [1,]      11    98     8
## [2,]      14    96     5
## [3,]      15    89     4M[, c(2, 3)]
##      marks grade
## [1,]    98     8
## [2,]    85     9
## [3,]    96     6
## [4,]    96     5
## [5,]    89     4M[, c(2)]
## [1] 98 85 96 96 89
```

# 确定矩阵的属性

创建一个两列五行的矩阵，并完成以下任务

*   求矩阵的长度
*   找出矩阵的列数
*   找出矩阵的总列数
*   求矩阵的维数
*   找出矩阵的结构
*   查找矩阵的数据类型
*   查找对象属性，如维度和维度名称

```
roll_no <- c(11, 12, 13, 14, 15)
marks <- c(98, 85, 96, 36, 89)M <- cbind(roll_no, marks)
M
##      roll_no marks
## [1,]      11    98
## [2,]      12    85
## [3,]      13    96
## [4,]      14    36
## [5,]      15    89length(M)
## [1] 10nrow(M)
## [1] 5ncol(M)
## [1] 2dim(M)
## [1] 5 2str(M)
##  num [1:5, 1:2] 11 12 13 14 15 98 85 96 36 89
##  - attr(*, "dimnames")=List of 2
##   ..$ : NULL
##   ..$ : chr [1:2] "roll_no" "marks"class(M)
## [1] "matrix" "array"attributes(M)
## $dim
## [1] 5 2
## 
## $dimnames
## $dimnames[[1]]
## NULL
## 
## $dimnames[[2]]
## [1] "roll_no" "marks"
```

# 命名矩阵的行和列

用 dimnames 参数值创建一个矩阵 M。该值是两个向量的列表，第一个向量表示行名，第二个向量表示列名。

```
M <- matrix(c(1,2,3,4,91,98,95,97), nrow=4, 
   dimnames = list(c('Abdul Ahad','Anshrah','Hafsa', 'Abdul Rafay'),   c('RollNo','Marks')))M
##             RollNo Marks
## Abdul Ahad       1    91
## Anshrah          2    98
## Hafsa            3    95
## Abdul Rafay      4    97
```

现在将列名从 RollNo 和 Marks 更改为 col1 和 col2

```
colnames(M) <- c('Col1', 'Col2')
M
##             Col1 Col2
## Abdul Ahad     1   91
## Anshrah        2   98
## Hafsa          3   95
## Abdul Rafay    4   97
```

按照上面更改的列名来更改行

```
colnames(M) <- c('Col1', 'Col2')
row.names(M) <- c("Record 01", "Record 02", "Record 03", "Record 04")
M
##           Col1 Col2
## Record 01    1   91
## Record 02    2   98
## Record 03    3   95
## Record 04    4   97
```

# 更改矩阵的维度

我们可以通过给 dim()函数分配一个新的维度向量来改变矩阵的维度

```
M <- matrix(c(1,2,3,4,91,98,95,97), nrow = 2)
M
##      [,1] [,2] [,3] [,4]
## [1,]    1    3   91   95
## [2,]    2    4   98   97dim(M)
## [1] 2 4dim(M) <- c(8, 1)
M
##      [,1]
## [1,]    1
## [2,]    2
## [3,]    3
## [4,]    4
## [5,]   91
## [6,]   98
## [7,]   95
## [8,]   97dim(M) <- c(1, 8)
M
##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
## [1,]    1    2    3    4   91   98   95   97dim(M) <- c(2, 4)
M
##      [,1] [,2] [,3] [,4]
## [1,]    1    3   91   95
## [2,]    2    4   98   97dim(M) <- c(4, 2)
M
##      [,1] [,2]
## [1,]    1   91
## [2,]    2   98
## [3,]    3   95
## [4,]    4   97
```

# 对矩阵执行算术运算

*   向矩阵中添加常数值
*   从矩阵中减去常数值
*   用矩阵乘以常数值
*   将矩阵除以一个常数值

```
M <- matrix(c(3,27, 9, 18, 12, 24, 30, 36, 6), ncol = 2)
M
##      [,1] [,2]
## [1,]    3   24
## [2,]   27   30
## [3,]    9   36
## [4,]   18    6
## [5,]   12    3M+2
##      [,1] [,2]
## [1,]    5   26
## [2,]   29   32
## [3,]   11   38
## [4,]   20    8
## [5,]   14    5M-2
##      [,1] [,2]
## [1,]    1   22
## [2,]   25   28
## [3,]    7   34
## [4,]   16    4
## [5,]   10    1M*2
##      [,1] [,2]
## [1,]    6   48
## [2,]   54   60
## [3,]   18   72
## [4,]   36   12
## [5,]   24    6M/2
##      [,1] [,2]
## [1,]  1.5 12.0
## [2,] 13.5 15.0
## [3,]  4.5 18.0
## [4,]  9.0  3.0
## [5,]  6.0  1.5
```

## 添加两个矩阵

创建两个矩阵 M1 和 M2，并执行以下操作

*   添加两个矩阵
*   矩阵的逐元素乘法
*   M1 和 M2 的矩阵乘法
*   矩阵的转置
*   矩阵的行列式
*   使用 ***rowSums()*** 函数计算矩阵的行和。
*   使用 ***colSums()*** 函数计算矩阵的列和。
*   使用 ***colMeans()*** 函数计算矩阵的列平均值
*   使用 ***rowMeans()*** 函数计算矩阵的行平均值。

```
M1 <- matrix(c(3,27, 9, 18, 12, 24, 30, 36, 6), ncol = 3)
M1
##      [,1] [,2] [,3]
## [1,]    3   18   30
## [2,]   27   12   36
## [3,]    9   24    6M2 <- matrix(c(1:9), ncol = 3)
M2
##      [,1] [,2] [,3]
## [1,]    1    4    7
## [2,]    2    5    8
## [3,]    3    6    9M1+M2
##      [,1] [,2] [,3]
## [1,]    4   22   37
## [2,]   29   17   44
## [3,]   12   30   15M1*M2
##      [,1] [,2] [,3]
## [1,]    3   72  210
## [2,]   54   60  288
## [3,]   27  144   54M1 %*% M2
##      [,1] [,2] [,3]
## [1,]  129  282  435
## [2,]  159  384  609
## [3,]   75  192  309t(M1)
##      [,1] [,2] [,3]
## [1,]    3   27    9
## [2,]   18   12   24
## [3,]   30   36    6det(M1)
## [1] 16740rowSums(M1)
## [1] 51 75 39colSums(M1)
## [1] 39 54 72rowMeans(M1)
## [1] 17 25 13colMeans(M1)
## [1] 13 18 24
```

# 结论

在本文中，我们讨论了矩阵的主要主题，如何创建矩阵，如何计算行列式，如何计算列和与行和，如何将两个矩阵按元素相乘，矩阵乘法法则，以及更多运算。