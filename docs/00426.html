<html>
<head>
<title>Print Over the Air — On Your Old Printer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在旧打印机上无线打印</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/print-over-the-air-with-docker-7146d7d41272?source=collection_archive---------3-----------------------#2020-06-07">https://blog.devgenius.io/print-over-the-air-with-docker-7146d7d41272?source=collection_archive---------3-----------------------#2020-06-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/2c3bf5de072a83545c0e3376a989b80c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JDvWuCKUyN_uwrsosVermw.jpeg"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">照片由<a class="ae ja" href="https://unsplash.com/@clark_fransa?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">阿诺德·弗朗西斯卡</a>在<a class="ae ja" href="https://unsplash.com/s/photos/print-laptop?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><h2 id="0a30" class="jb jc jd bd b dl je jf jg jh ji jj dk jk translated" aria-label="kicker paragraph">air Print | Docker | CUPS | Print | Google 云打印| Multi-Arch</h2><div class=""/><div class=""><h2 id="3a53" class="pw-subtitle-paragraph kj jm jd bd b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dk translated">你有一台旧打印机仍然可以工作，但不支持 AirPrint？你在本地网络中也有一个 linux 盒子，你可以在那里运行 docker 容器？那么这本指南是给你的。</h2></div><blockquote class="lj lk ll"><p id="72b4" class="lm ln lo lp b lq lr kn ls lt lu kq lv lw lx ly lz ma mb mc md me mf mg mh mi ig bi translated"><strong class="lp jn">更新</strong>:由于反馈，docker 镜像现在可以用于多种架构</p><p id="2b91" class="lm ln lo lp b lq lr kn ls lt lu kq lv lw lx ly lz ma mb mc md me mf mg mh mi ig bi translated"><strong class="lp jn">更新:</strong>感谢更多反馈，Avahi 打印机名称可以配置为使用打印机的“描述”和“位置”。</p><p id="c202" class="lm ln lo lp b lq lr kn ls lt lu kq lv lw lx ly lz ma mb mc md me mf mg mh mi ig bi translated"><strong class="lp jn">更新:</strong>谷歌云打印不再包含在图片中，因为它已停产。</p><p id="0341" class="lm ln lo lp b lq lr kn ls lt lu kq lv lw lx ly lz ma mb mc md me mf mg mh mi ig bi translated"><strong class="lp jn">支持我</strong>:通过我的推荐链接加入 Medium<a class="ae ja" href="https://drpsychick.org/membership" rel="noopener ugc nofollow" target="_blank">https://drpsychick.org/membership</a></p></blockquote><p id="882e" class="pw-post-body-paragraph lm ln jd lp b lq lr kn ls lt lu kq lv mj lx ly lz mk mb mc md ml mf mg mh mi ig bi translated">这个解决方案和这个指南的起因是我的懒惰和我孩子的方便。我只是不想在他们需要打印东西的时候总是跑着去，因为现在——一切都是通过手机完成的……</p><p id="c2a4" class="pw-post-body-paragraph lm ln jd lp b lq lr kn ls lt lu kq lv mj lx ly lz mk mb mc md ml mf mg mh mi ig bi translated">长话短说，这就是你如何在你的本地网络中安装一个本地专用的 AirPrint 桥。它甚至支持添加你自己的 SSL 证书——全部通过环境变量，因为我相信<a class="ae ja" href="https://12factor.net/config" rel="noopener ugc nofollow" target="_blank">https://12factor.net/config</a></p><h2 id="49ae" class="mm mn jd bd mo mp mq dn mr ms mt dp mu mj mv mw mx mk my mz na ml nb nc nd jj bi translated"><span class="l lb lc ld bm le lf lg lh li di"> T </span>何棘手的部分</h2><p id="be4e" class="pw-post-body-paragraph lm ln jd lp b lq ne kn ls lt nf kq lv mj ng ly lz mk nh mc md ml ni mg mh mi ig bi translated">关于这个设置，我们将要运行的 CUPS 不喜欢 docker 的端口转发。此外，这个 docker 映像还运行一个 avahi 守护程序(Bonjour)来通告网络上的打印机，这很可能会与您的主机操作系统的端口发生冲突。</p><p id="beaa" class="pw-post-body-paragraph lm ln jd lp b lq lr kn ls lt lu kq lv mj lx ly lz mk mb mc md ml mf mg mh mi ig bi translated">好消息是 linux 上的 docker 附带了<code class="fe nj nk nl nm b">macvlan</code>驱动程序，并允许您在本地子网上为 docker 分配一个专用 IP，就像它是一台真实的机器一样。但稍后会有更多内容…</p><h1 id="6189" class="nn mn jd bd mo no np nq mr nr ns nt mu ks nu kt mx kv nv kw na ky nw kz nd nx bi translated">1.首先让我们玩 Docker 图像</h1><p id="828c" class="pw-post-body-paragraph lm ln jd lp b lq ne kn ls lt nf kq lv mj ng ly lz mk nh mc md ml ni mg mh mi ig bi translated">并查看您的打印机是否受支持。毕竟，当 CUPS 不能很好地支持您的打印机时，您不想在设置上投入时间。</p><p id="0151" class="pw-post-body-paragraph lm ln jd lp b lq lr kn ls lt lu kq lv mj lx ly lz mk mb mc md ml mf mg mh mi ig bi translated">以下命令启动一个名为<code class="fe nj nk nl nm b">cups-setup</code>的容器，并允许远程访问。<code class="fe nj nk nl nm b">lpinfo, lpadmin</code>和<code class="fe nj nk nl nm b">lpoptions</code>允许您在控制台的容器内搜索打印机的驱动程序。您也可以跟随 URL 并通过 web 界面设置您的打印机进行测试。</p><figure class="ny nz oa ob gt ip"><div class="bz fp l di"><div class="oc od l"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">一个可以玩的容器</figcaption></figure><p id="0516" class="pw-post-body-paragraph lm ln jd lp b lq lr kn ls lt lu kq lv mj lx ly lz mk mb mc md ml mf mg mh mi ig bi translated">有了这个设置，您可以进入 CUPS web 界面并打印一个测试页面，看看结果是否正确。如果一切顺利，现在您已经为本地网络配置了您的专用容器。</p></div><div class="ab cl oe of hr og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ig ih ii ij ik"><h1 id="7de0" class="nn mn jd bd mo no ol nq mr nr om nt mu ks on kt mx kv oo kw na ky op kz nd nx bi translated">2.准备桥接网络，</h1><p id="e079" class="pw-post-body-paragraph lm ln jd lp b lq ne kn ls lt nf kq lv mj ng ly lz mk nh mc md ml ni mg mh mi ig bi translated">因此，我们可以创建一个 docker 网络，它可以使用您本地网络的 IP 地址，从而将 docker 容器“直接”暴露给本地网络。</p><p id="0171" class="pw-post-body-paragraph lm ln jd lp b lq lr kn ls lt lu kq lv mj lx ly lz mk mb mc md ml mf mg mh mi ig bi translated">我们为 docker 网络创建一个<code class="fe nj nk nl nm b">macvlan</code>网桥接口，并将其连接到父网络接口——您的默认网络接口。这里棘手的部分是，我们还希望主机能够与 docker 容器对话，反之亦然，因此我们需要以下额外步骤。</p><p id="d807" class="pw-post-body-paragraph lm ln jd lp b lq lr kn ls lt lu kq lv mj lx ly lz mk mb mc md ml mf mg mh mi ig bi translated">如果不需要主机与容器对话，<strong class="lp jn">可以跳过这个！</strong></p><p id="4cd2" class="pw-post-body-paragraph lm ln jd lp b lq lr kn ls lt lu kq lv mj lx ly lz mk mb mc md ml mf mg mh mi ig bi translated">(关于<code class="fe nj nk nl nm b">macvlan</code>的教程，见<a class="ae ja" href="https://docs.docker.com/network/network-tutorial-macvlan/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/network/network-tutorial-macvlan/</a></p><p id="0a1a" class="pw-post-body-paragraph lm ln jd lp b lq lr kn ls lt lu kq lv mj lx ly lz mk mb mc md ml mf mg mh mi ig bi translated">我们要做的是:用<code class="fe nj nk nl nm b">mac0</code>替换<code class="fe nj nk nl nm b">eth1</code>，并将 DHCP IP 移动到<code class="fe nj nk nl nm b">mac0</code></p><blockquote class="lj lk ll"><p id="4890" class="lm ln lo lp b lq lr kn ls lt lu kq lv lw lx ly lz ma mb mc md me mf mg mh mi ig bi translated"><strong class="lp jn">重要</strong>:用你的接口替换<code class="fe nj nk nl nm b">eth1</code>，用你的接口的 MAC 替换<code class="fe nj nk nl nm b">00:1d:60:1d:ea:46</code>。</p></blockquote><pre class="ny nz oa ob gt oq nm or os aw ot bi"><span id="f2ad" class="mm mn jd nm b gy ou ov l ow ox"># enable promicious mode, required for multiple MACs<br/>sudo ifconfig eth1 promisc<br/># change MAC of eth1 (both interfaces must have different MACs)<br/>sudo ip link set eth1 address 00:1d:60:1d:ea:47</span><span id="247f" class="mm mn jd nm b gy oy ov l ow ox"># bridge mac0 interface to eth1 with original MAC<br/># -&gt; we want to keep our DHCP address<br/>sudo ip link add mac0 link eth1 address 00:1d:60:1d:ea:46 \<br/>  type macvlan mode bridge</span><span id="19f4" class="mm mn jd nm b gy oy ov l ow ox"># make sure the following runs in one command as <br/># it disconnects from the network shortly<br/>sudo -- bash -c '(<br/>dhclient -r eth1 &amp;&amp; ip addr flush dev eth1 &amp;&amp; ip neigh flush all;<br/>dhclient mac0 &amp;&amp; service resolvconf restart || dhclient eth1<br/>)'</span></pre><h2 id="b037" class="mm mn jd bd mo mp mq dn mr ms mt dp mu mj mv mw mx mk my mz na ml nb nc nd jj bi translated">这些命令的详细功能:</h2><ul class=""><li id="4ecf" class="oz pa jd lp b lq ne lt nf mj pb mk pc ml pd mi pe pf pg ph bi translated"><code class="fe nj nk nl nm b">sudo ip link set eth1 address 00:1d:60:1d:ea:47</code></li></ul><p id="2346" class="pw-post-body-paragraph lm ln jd lp b lq lr kn ls lt lu kq lv mj lx ly lz mk mb mc md ml mf mg mh mi ig bi translated">在物理设备上设置稍有不同的 MAC。如果(比如在 ubuntu 上)你的桌面保持 dhclient 运行，它会在某个时候为接口获取一个新的 IP。这应该不会干扰我们的<code class="fe nj nk nl nm b">mac0</code>接口。</p><ul class=""><li id="5a7b" class="oz pa jd lp b lq lr lt lu mj pi mk pj ml pk mi pe pf pg ph bi translated"><code class="fe nj nk nl nm b">sudo ip link add mac0 link eth1 address 00:1d:60:1d:ea:46 type macvlan mode bridge</code></li></ul><p id="922b" class="pw-post-body-paragraph lm ln jd lp b lq lr kn ls lt lu kq lv mj lx ly lz mk mb mc md ml mf mg mh mi ig bi translated">这将一个接口<code class="fe nj nk nl nm b">mac0</code>链接到父接口<code class="fe nj nk nl nm b">eth1</code>，其 MAC 与<code class="fe nj nk nl nm b">eth1</code>原来的 MAC 相同(这样 DHCP 将再次获得相同的地址)。这里有更多关于<code class="fe nj nk nl nm b">macvlan</code>的信息:<a class="ae ja" href="https://docs.docker.com/network/macvlan/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/network/macvlan/</a></p><ul class=""><li id="a41d" class="oz pa jd lp b lq lr lt lu mj pi mk pj ml pk mi pe pf pg ph bi translated"><code class="fe nj nk nl nm b">dhclient -r eth1 &amp;&amp; ip addr flush dev eth1 &amp;&amp; ip neigh flush all</code></li></ul><p id="229c" class="pw-post-body-paragraph lm ln jd lp b lq lr kn ls lt lu kq lv mj lx ly lz mk mb mc md ml mf mg mh mi ig bi translated">首先，它会丢弃<code class="fe nj nk nl nm b">eth1</code>的 DHCP 租约，然后删除与接口相关的所有地址，最后刷新整个 ARP 和 NDISC 缓存。</p><ul class=""><li id="031b" class="oz pa jd lp b lq lr lt lu mj pi mk pj ml pk mi pe pf pg ph bi translated"><code class="fe nj nk nl nm b">dhclient mac0 &amp;&amp; service resolvconf restart || dhclient eth1</code></li></ul><p id="93b2" class="pw-post-body-paragraph lm ln jd lp b lq lr kn ls lt lu kq lv mj lx ly lz mk mb mc md ml mf mg mh mi ig bi translated">这将为 mac0 启动一个 DHCP 客户端，如果成功，它将重启 resolvconf，如果失败，它将尝试让<code class="fe nj nk nl nm b">eth1</code>重新联机。</p><blockquote class="lj lk ll"><p id="4a2e" class="lm ln lo lp b lq lr kn ls lt lu kq lv lw lx ly lz ma mb mc md me mf mg mh mi ig bi translated">如果您希望<strong class="lp jn">在主机</strong>上保持这一点，将以下内容放入<code class="fe nj nk nl nm b">/etc/network/interfaces</code>并重启。<strong class="lp jn">尽管</strong>小心，这将使接口从 Ubuntu 网络管理器中消失，因为它们是预先配置的。</p></blockquote><pre class="ny nz oa ob gt oq nm or os aw ot bi"><span id="77cd" class="mm mn jd nm b gy ou ov l ow ox">auto eth1<br/>iface eth1 inet manual</span><span id="1abb" class="mm mn jd nm b gy oy ov l ow ox">auto mac0<br/>iface mac0 inet dhcp<br/>  pre-up   ip link add mac0 link eth1 address 00:1d:60:1d:ea:46 type macvlan mode bridge<br/>  pre-down ip link del mac0 link eth1 type macvlan mode bridge</span></pre><h2 id="9ba7" class="mm mn jd bd mo mp mq dn mr ms mt dp mu mj mv mw mx mk my mz na ml nb nc nd jj bi translated">取消</h2><p id="f5b0" class="pw-post-body-paragraph lm ln jd lp b lq ne kn ls lt nf kq lv mj ng ly lz mk nh mc md ml ni mg mh mi ig bi translated">此外，如果你对刚刚发生的事情不满意，这里有命令来撤销一切:</p><pre class="ny nz oa ob gt oq nm or os aw ot bi"><span id="05b1" class="mm mn jd nm b gy ou ov l ow ox"># reset MAC<br/>sudo ip link set eth1 address 00:1d:60:1d:ea:46</span><span id="bc7e" class="mm mn jd nm b gy oy ov l ow ox"># get eth1 up again<br/>sudo -- bash -c '(<br/>dhclient -r mac0 &amp;&amp; ip addr flush dev mac0 &amp;&amp; ip neigh flush all<br/>dhclient eth1 &amp;&amp; service resolvconf restart<br/>)'</span><span id="6230" class="mm mn jd nm b gy oy ov l ow ox"># delete mac0<br/>sudo ip link del mac0 link eth1 type macvlan mode bridge</span><span id="7973" class="mm mn jd nm b gy oy ov l ow ox"># disable promiscious mode on eth1<br/>sudo ifconfig eth1 -promisc</span></pre></div><div class="ab cl oe of hr og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ig ih ii ij ik"><h1 id="5dfb" class="nn mn jd bd mo no ol nq mr nr om nt mu ks on kt mx kv oo kw na ky op kz nd nx bi translated">3.现在网络设置已经就绪，</h1><p id="fd1b" class="pw-post-body-paragraph lm ln jd lp b lq ne kn ls lt nf kq lv mj ng ly lz mk nh mc md ml ni mg mh mi ig bi translated">我们创建了一个名为<code class="fe nj nk nl nm b">localnet</code>的 docker 网络，它与我们的本地网络具有相同的子网。作为父节点，我们必须使用<code class="fe nj nk nl nm b">mac0</code>，否则我们将无法从主机与容器对话。(如果你跳过了第 2 步，那么把这里的<code class="fe nj nk nl nm b">eth1</code>作为父接口)。</p><pre class="ny nz oa ob gt oq nm or os aw ot bi"><span id="15e0" class="mm mn jd nm b gy ou ov l ow ox">docker network create --driver macvlan --subnet 192.168.1.0/24 --gateway 192.168.1.1 -o parent=mac0 localnet</span></pre><p id="f255" class="pw-post-body-paragraph lm ln jd lp b lq lr kn ls lt lu kq lv mj lx ly lz mk mb mc md ml mf mg mh mi ig bi translated">…然后我们推出了一个有自己知识产权的容器，只是为了好玩</p><pre class="ny nz oa ob gt oq nm or os aw ot bi"><span id="6194" class="mm mn jd nm b gy ou ov l ow ox">docker run --rm -d --net localnet --ip 192.168.1.205 \<br/>  --name echo adfinissygroup/nginx-echo</span><span id="6d25" class="mm mn jd nm b gy oy ov l ow ox">curl <a class="ae ja" href="http://192.168.1.205" rel="noopener ugc nofollow" target="_blank">http://192.168.1.205</a></span><span id="4fe4" class="mm mn jd nm b gy oy ov l ow ox">docker stop echo</span></pre><p id="e76b" class="pw-post-body-paragraph lm ln jd lp b lq lr kn ls lt lu kq lv mj lx ly lz mk mb mc md ml mf mg mh mi ig bi translated">很好，现在我们有了一个网络，在这个网络中，我们可以在本地网络上启动容器。所以让我们用它来做我们的<code class="fe nj nk nl nm b">airprint-bridge</code>。</p></div><div class="ab cl oe of hr og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ig ih ii ij ik"><h1 id="4310" class="nn mn jd bd mo no ol nq mr nr om nt mu ks on kt mx kv oo kw na ky op kz nd nx bi translated">4.配置并启动 Airprint-Bridge</h1><p id="a48b" class="pw-post-body-paragraph lm ln jd lp b lq ne kn ls lt nf kq lv mj ng ly lz mk nh mc md ml ni mg mh mi ig bi translated">让我们创建一个名为<code class="fe nj nk nl nm b">cups.env</code>的配置文件(环境)。这只是一个例子，所有可用的变量都记录在回购协议中:<a class="ae ja" href="https://github.com/DrPsychick/docker-cups-airprint/" rel="noopener ugc nofollow" target="_blank">https://github.com/DrPsychick/docker-cups-airprint/</a></p><p id="1a97" class="pw-post-body-paragraph lm ln jd lp b lq lr kn ls lt lu kq lv mj lx ly lz mk mb mc md ml mf mg mh mi ig bi translated">当我们玩容器的时候，一定要用你在第一步<strong class="lp jn">中发现的东西替换<code class="fe nj nk nl nm b">CUPS_LPADMIN_PRINTERx</code>变量。这种设置最好的一点是，您可以简单地更改 ENV 并重新运行容器来应用它。</strong></p><figure class="ny nz oa ob gt ip"><div class="bz fp l di"><div class="oc od l"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">cups.env</figcaption></figure><p id="023a" class="pw-post-body-paragraph lm ln jd lp b lq lr kn ls lt lu kq lv mj lx ly lz mk mb mc md ml mf mg mh mi ig bi translated">现在让我们看看我们配置好的<code class="fe nj nk nl nm b">airprint-bridge</code>的运行情况:</p><pre class="ny nz oa ob gt oq nm or os aw ot bi"><span id="fa94" class="mm mn jd nm b gy ou ov l ow ox">docker run -d --name cups-home --net localnet --ip 192.168.1.205 \<br/>  -p 137:137/udp -p 139:139/tcp -p 445:445/tcp \<br/>  -p 631:631/tcp -p 5353:5353/udp \<br/>  --hostname cups.home --env-file cups.env \<br/>  drpsychick/airprint-bridge</span></pre><p id="4806" class="pw-post-body-paragraph lm ln jd lp b lq lr kn ls lt lu kq lv mj lx ly lz mk mb mc md ml mf mg mh mi ig bi translated">如果您启用了 web 界面，请通过<a class="ae ja" href="http://192.168.1.205:631/" rel="noopener ugc nofollow" target="_blank">http://192 . 168 . 1 . 205:631/</a>访问您的容器</p><p id="f7fd" class="pw-post-body-paragraph lm ln jd lp b lq lr kn ls lt lu kq lv mj lx ly lz mk mb mc md ml mf mg mh mi ig bi translated">一旦你设置了一台打印机，并将其连接到网络上的一台真正的打印机上，avahi-daemon 将花费几秒钟的时间挑选新的打印机，并在本地网络上将其作为 AirPrint 打印机进行广告。</p><h2 id="570c" class="mm mn jd bd mo mp mq dn mr ms mt dp mu mj mv mw mx mk my mz na ml nb nc nd jj bi translated">如果你来这里是为了谷歌云打印，</h2><p id="d5d8" class="pw-post-body-paragraph lm ln jd lp b lq ne kn ls lt nf kq lv mj ng ly lz mk nh mc md ml ni mg mh mi ig bi translated">不幸的是，谷歌云打印已经停止，所以它被从 docker 图像中删除。</p></div><div class="ab cl oe of hr og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ig ih ii ij ik"><h1 id="4b1c" class="nn mn jd bd mo no ol nq mr nr om nt mu ks on kt mx kv oo kw na ky op kz nd nx bi translated">5.看着集装箱</h1><p id="f9a7" class="pw-post-body-paragraph lm ln jd lp b lq ne kn ls lt nf kq lv mj ng ly lz mk nh mc md ml ni mg mh mi ig bi translated">下面是一些方便的命令，看看是否一切顺利:</p><p id="80c0" class="pw-post-body-paragraph lm ln jd lp b lq lr kn ls lt lu kq lv mj lx ly lz mk mb mc md ml mf mg mh mi ig bi translated"><code class="fe nj nk nl nm b">docker logs --tail 100 -f cups-home</code></p><p id="a2be" class="pw-post-body-paragraph lm ln jd lp b lq lr kn ls lt lu kq lv mj lx ly lz mk mb mc md ml mf mg mh mi ig bi translated">连接到 stdout/stderr，查看 cups 正在记录什么。</p><p id="1d0c" class="pw-post-body-paragraph lm ln jd lp b lq lr kn ls lt lu kq lv mj lx ly lz mk mb mc md ml mf mg mh mi ig bi translated"><code class="fe nj nk nl nm b">docker exec -it cups-home cupsctl</code></p><p id="558f" class="pw-post-body-paragraph lm ln jd lp b lq lr kn ls lt lu kq lv mj lx ly lz mk mb mc md ml mf mg mh mi ig bi translated">打印配置。</p><p id="5df5" class="pw-post-body-paragraph lm ln jd lp b lq lr kn ls lt lu kq lv mj lx ly lz mk mb mc md ml mf mg mh mi ig bi translated"><code class="fe nj nk nl nm b">docker exec -it cups-home cupsctl --[no-]debug-logging</code></p><p id="ae98" class="pw-post-body-paragraph lm ln jd lp b lq lr kn ls lt lu kq lv mj lx ly lz mk mb mc md ml mf mg mh mi ig bi translated">打开或关闭调试日志记录。</p><pre class="ny nz oa ob gt oq nm or os aw ot bi"><span id="4673" class="mm mn jd nm b gy ou ov l ow ox">docker exec -it cups-home cupsctl AccessLogLevel=access<br/>docker exec -it cups-home cupsctl LogLevel=debug</span></pre><p id="3298" class="pw-post-body-paragraph lm ln jd lp b lq lr kn ls lt lu kq lv mj lx ly lz mk mb mc md ml mf mg mh mi ig bi translated">更改访问或常规日志级别。</p><h1 id="aa9e" class="nn mn jd bd mo no np nq mr nr ns nt mu ks nu kt mx kv nv kw na ky nw kz nd nx bi translated">为您的 CUPS 设置有效的 SSL 证书</h1><p id="f676" class="pw-post-body-paragraph lm ln jd lp b lq ne kn ls lt nf kq lv mj ng ly lz mk nh mc md ml ni mg mh mi ig bi translated">是的，这是可能的，也很简单:</p><figure class="ny nz oa ob gt ip"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="bceb" class="pw-post-body-paragraph lm ln jd lp b lq lr kn ls lt lu kq lv mj lx ly lz mk mb mc md ml mf mg mh mi ig bi translated">就是这样！把你的<code class="fe nj nk nl nm b">RootCA.crt</code>放在一个安全的地方，这样就没有人能欺骗你，让你相信<code class="fe nj nk nl nm b">google.com</code>是他自己偷偷摸摸的主机的有效域名…</p><p id="c479" class="pw-post-body-paragraph lm ln jd lp b lq lr kn ls lt lu kq lv mj lx ly lz mk mb mc md ml mf mg mh mi ig bi translated">容器启动脚本<code class="fe nj nk nl nm b">start-cups.sh</code>会注意到你已经通过<code class="fe nj nk nl nm b">ENV</code>提供了自己的证书，并在 CUPS 配置中禁用<code class="fe nj nk nl nm b">CreateSelfSignedCerts</code>。</p><h1 id="017d" class="nn mn jd bd mo no np nq mr nr ns nt mu ks nu kt mx kv nv kw na ky nw kz nd nx bi translated">在活动</h1><p id="b17f" class="pw-post-body-paragraph lm ln jd lp b lq ne kn ls lt nf kq lv mj ng ly lz mk nh mc md ml ni mg mh mi ig bi translated">我不能给你看打印出来的，但我可以给你看它在我手机上的样子:</p><figure class="ny nz oa ob gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi pl"><img src="../Images/bf61fc51bee782b7810c6fc71aa54b19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FE6Jm9jgcoMUsj8KVR5mQg.png"/></div></div></figure><h1 id="1151" class="nn mn jd bd mo no np nq mr nr ns nt mu ks nu kt mx kv nv kw na ky nw kz nd nx bi translated">关闭</h1><p id="1cfd" class="pw-post-body-paragraph lm ln jd lp b lq ne kn ls lt nf kq lv mj ng ly lz mk nh mc md ml ni mg mh mi ig bi translated">好了，话不多说"<strong class="lp jn">感谢您的阅读！</strong>”。我真的很感激你花了这么多时间。请不要犹豫给我关于文章或 github 的反馈。</p><p id="c3e9" class="pw-post-body-paragraph lm ln jd lp b lq lr kn ls lt lu kq lv mj lx ly lz mk mb mc md ml mf mg mh mi ig bi translated">来源:<a class="ae ja" href="https://github.com/DrPsychick/docker-cups-airprint/" rel="noopener ugc nofollow" target="_blank">https://github.com/DrPsychick/docker-cups-airprint/</a></p><div class="im in gp gr io pm"><a href="https://github.com/DrPsychick/docker-cups-airprint/" rel="noopener  ugc nofollow" target="_blank"><div class="pn ab fo"><div class="po ab pp cl cj pq"><h2 class="bd jn gy z fp pr fr fs ps fu fw jm bi translated">DrPsychick/docker-cups-air print</h2><div class="pt l"><h3 class="bd b gy z fp pr fr fs ps fu fw dk translated">运行一个带有 CUPS 和 Avahi (mDNS/Bonjour)的容器，以便网络上的本地打印机可以通过 AirPrint 暴露给…</h3></div><div class="pu l"><p class="bd b dl z fp pr fr fs ps fu fw dk translated">github.com</p></div></div><div class="pv l"><div class="pw l px py pz pv qa iu pm"/></div></div></a></div><p id="8b83" class="pw-post-body-paragraph lm ln jd lp b lq lr kn ls lt lu kq lv mj lx ly lz mk mb mc md ml mf mg mh mi ig bi translated">https://hub.docker.com/r/drpsychick/airprint-bridge</p></div></div>    
</body>
</html>