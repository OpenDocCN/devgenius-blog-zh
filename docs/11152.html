<html>
<head>
<title>Kafka Guide: Part1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">卡夫卡指南:第一部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/kafka-guide-part1-85d8426e3004?source=collection_archive---------9-----------------------#2022-12-21">https://blog.devgenius.io/kafka-guide-part1-85d8426e3004?source=collection_archive---------9-----------------------#2022-12-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="e501" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Kafka 是作为 LinkedIn 实时处理大量数据的低延迟问题的解决方案开发的，然后作为开源继续开发。这是一个具有发布/订阅结构的消息传递系统。在这些系统中，消息被发送到一个主题，消费者通过订阅一个或多个主题来接收消息。这里聪明的是消费者。</p><h2 id="0c08" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">为什么是卡夫卡？</h2><ul class=""><li id="666d" class="lb lc in jm b jn ld jr le jv lf jz lg kd lh kh li lj lk ll bi translated"><strong class="jm io">可伸缩性</strong>:可以使用多个生产者。它可以轻松扩展，无需停机。</li><li id="c4e9" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated"><strong class="jm io">可靠性</strong> : Kafka 可用于分布式、复制和分区。多个消费者可以同时并行读取。</li><li id="f4e1" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated"><strong class="jm io">持久性</strong> : Kafka 使用分布式提交日志。有基于磁盘的保留。数据尽可能快地写入磁盘。</li><li id="d948" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated"><strong class="jm io">高性能</strong></li></ul><h2 id="49f9" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">用例</h2><ul class=""><li id="1792" class="lb lc in jm b jn ld jr le jv lf jz lg kd lh kh li lj lk ll bi translated">信息发送</li><li id="4297" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated">网站活动跟踪</li><li id="4b3a" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated">韵律学</li><li id="e4ca" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated">日志聚合</li><li id="01dc" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated">流处理</li><li id="6f88" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated">活动采购</li><li id="8e66" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated">提交日志</li></ul><h2 id="635c" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated"><strong class="ak">消息代理 vs 发布/订阅(Pub/Sub)消息系统</strong></h2><p id="fbfe" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh ig bi translated">消息代理通过某种协议在应用程序之间提供通信和信息交换，而不管它们是用什么语言编写的。验证、路由和转发给特定的收件人。</p><p id="1f9a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一方面，发布/订阅系统允许制作者按照他们的意愿发布每条消息。它在发布者和消费者之间提供了一对多的关系。</p><p id="ccf0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">像 RabbitMQ 这样的消息代理是聪明的代理-愚蠢的消费者，而 Kafka 有愚蠢的代理-聪明的消费者逻辑。</p><h2 id="f98d" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">基础</h2><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/322ac8544940d806a0baf0f4abaebbd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*1OnJIg4alDNry9YRIDb8Sw.png"/></div></figure><ul class=""><li id="d76f" class="lb lc in jm b jn jo jr js jv mc jz md kd me kh li lj lk ll bi translated"><strong class="jm io">经纪人</strong>:这些是我们发送给 Kafka 的数据存储和处理的服务器。数据存储在硬盘上。集群由多个相互协作的代理组成。</li><li id="a4ff" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated"><strong class="jm io">话题和分区</strong>:经纪人包含话题，话题包含分区。我们写数据的地方实际上是分区。</li><li id="7ff8" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated"><strong class="jm io">生产者</strong>:向卡夫卡发送数据。</li><li id="2022" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated"><strong class="jm io">消费者</strong>:从 Kafka 读取数据。</li><li id="e8c2" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated"><strong class="jm io"> Zookeeper </strong>:是 Kafka 用来管理经纪人的开源软件。他们负责协调代理，选择领导者分区，注意坏的和新的代理。2.8.0 版本之后，卡夫卡变成了 zookeeperless。</li></ul><h2 id="1a79" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">我们为什么要创建分区？</h2><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/07264fa57fa9dcb16490bc3ce373ce45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*MQN387q6eI1xgKRTHB4FtQ.png"/></div></figure><ul class=""><li id="f059" class="lb lc in jm b jn jo jr js jv mc jz md kd me kh li lj lk ll bi translated">根据所确定的特征收集生产者的数据(集合)</li><li id="a195" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated">数据的顺序收集(排序-事件源)</li><li id="b8b3" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated">读取速度更快(并行)</li><li id="3e88" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated">更高效地存储数据(效率)</li></ul><blockquote class="mg mh mi"><p id="3432" class="jk jl mj jm b jn jo jp jq jr js jt ju mk jw jx jy ml ka kb kc mm ke kf kg kh ig bi translated">！！！Kafka 在同一个分区中写入相同的键值</p></blockquote></div><div class="ab cl mn mo hr mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ig ih ii ij ik"><h2 id="b499" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">分身术</h2><p id="3144" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh ig bi translated">为了进行健康的复制，代理应该由单数组成(例如 3、5、7)。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="ab gu cl mu"><img src="../Images/75c23b259976b4f859a9327cd83863df.png" data-original-src="https://miro.medium.com/v2/format:webp/1*HVDrIZ_L2jPNIEVK1gOZ6Q.png"/></div></figure><p id="141b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们考虑一个复制因子= 3 的系统</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/975099aaa1554982b91498d44c2f9799.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*cRLwYdqT-dpgJe5mZpCuGQ.png"/></div></figure><p id="4437" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">考虑到代理 5 已经崩溃，这里保存的数据可以转移到代理 1 和代理 2。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/95d1babe5c2a4f20df720576c9bb2e76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*cpjz4PbU7rPhYqENZCpVsQ.png"/></div></figure><p id="b1ab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果代理 2 崩溃，这些数据也可以传输到代理 3 和代理 4。如果代理 3 崩溃，系统将失败。因为我们没有任何可以达到复制数量的代理。在这种情况下；</p><blockquote class="mg mh mi"><p id="d287" class="jk jl mj jm b jn jo jp jq jr js jt ju mk jw jx jy ml ka kb kc mm ke kf kg kh ig bi translated">代理&gt; =复制因子</p></blockquote><p id="1219" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每个分区的一个复制副本被指定为领导者。并且数据总是首先被写入这个主分区。主分区还将此数据发送并同步到其他副本。如果由于某种原因，主分区崩溃，Kafka 会立即选择一个新分区作为主分区。</p></div><div class="ab cl mn mo hr mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ig ih ii ij ik"><h2 id="3362" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">生产者确认</h2><p id="2ff5" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh ig bi translated">当我们向 Kafka 发送数据时，我们指定应该完成发送数据、将数据写入主分区和备份数据以进行复制的哪些阶段。这叫做承认。</p><ul class=""><li id="ae90" class="lb lc in jm b jn jo jr js jv mc jz md kd me kh li lj lk ll bi translated">ack = 0-&gt;它作为发送到 Kafka 并继续而不等待回复。这是最快也是最危险的方法，丢失消息的风险很高。</li><li id="9ee9" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated">acks=1 -&gt;发给卡夫卡，等到写好领导就行了。速度适中且安全，几乎没有丢失消息的风险。</li><li id="9ea2" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated">acks = all，-1 -&gt;发送给 Kafka，等它写到首领，等首领写到其他分区。最慢最安全，没有信息丢失的风险。</li></ul><h2 id="e792" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">消息传递语义</h2><ul class=""><li id="342d" class="lb lc in jm b jn ld jr le jv lf jz lg kd lh kh li lj lk ll bi translated"><strong class="jm io">最多一次</strong></li></ul><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi mx"><img src="../Images/cb4992854278fb21c08aa121ec2479b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kzeZz3_fFPQX1WEjTJ75hA.png"/></div></div></figure><p id="cc39" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们阅读了该消息，并在阅读后立即提交。然后，我们将此消息发送给 process。但是在处理过程中，出现了一个问题，我们的消费者崩溃了。由于我们再次运行消费者，我们继续下一个消息。所以我们读到的第一条信息现在丢失了。因为我们一读就犯了。</p><ul class=""><li id="036c" class="lb lc in jm b jn jo jr js jv mc jz md kd me kh li lj lk ll bi translated"><strong class="jm io">至少一次</strong></li></ul><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nc"><img src="../Images/7e3a7cad933ff07799742288f335a91c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rjfGzLep3LVPxRVveDUcrQ.png"/></div></div></figure><p id="df9f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们读取消息，调用流程并执行操作。最后，我们将它保存到数据库，并在这里提交。通过这种方式，我们可以确保处理的消息没有错误。如果在处理过程中出现错误，读取器将在重新启动时读取相同的消息。(最优选的方法)</p><ul class=""><li id="e55c" class="lb lc in jm b jn jo jr js jv mc jz md kd me kh li lj lk ll bi translated"><strong class="jm io">正好一次</strong></li></ul><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nd"><img src="../Images/243a3c5bcc9973452164b98f2524ed44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ESqYgF-ln4AUkRPSeQ-bjw.png"/></div></div></figure><p id="5239" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们阅读消息，并在阅读后立即启动事务。交易执行一次，不重复。即使消息没有了，它也没有丢失，因为它仍然在这个事务中。应该在真正必要的时候使用它，因为它会影响性能。</p><h2 id="b551" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">消费者群体</h2><p id="00bb" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh ig bi translated">消费者总是存在于一个消费群体中，并给自己起了一定的名字。所以卡夫卡知道是哪个读者，知道它的偏移位置。</p><blockquote class="mg mh mi"><p id="d49a" class="jk jl mj jm b jn jo jp jq jr js jt ju mk jw jx jy ml ka kb kc mm ke kf kg kh ig bi translated">！！！如果是单个消费者，可以同时读取所有分区，但是这样效率不是很高。Kafka 识别并随着消费者的添加自动分配。只有一个同名的使用者可以读取分区。所以消费者太多，就被动等待。如果其中一个用户崩溃，这个被动的用户会立即变为主动用户。如果我添加一个不同的消费者组，他们也可以从相同的分区中读取数据，并且不会因为名字不同而相互混淆。</p></blockquote><h2 id="a199" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">从 Kafka 删除数据</h2><p id="3f72" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh ig bi translated"><strong class="jm io">基于时间的保留</strong></p><ul class=""><li id="37c8" class="lb lc in jm b jn jo jr js jv mc jz md kd me kh li lj lk ll bi translated">基于时间—表示在特定时间段内删除数据。标准是 7 天，可以改。</li><li id="2499" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated">基于数据大小—确保数据在达到一定大小时得到清理。(100GB 等。)</li></ul><p id="624b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">主题压缩:基于关键字的保留</strong></p><pre class="lv lw lx ly gt ne nf ng bn nh ni bi"><span id="160f" class="nj kj in nf b be nk nl l nm nn">cleanup.policy: compact</span></pre><ul class=""><li id="c828" class="lb lc in jm b jn jo jr js jv mc jz md kd me kh li lj lk ll bi translated">Kafka 主题可以使用压缩清理策略进行配置。这告诉卡夫卡用同一个密钥删除旧消息。</li><li id="33ec" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated">必须是同一个分区。即使同一主题有不同的分区，记录也不会被删除。</li><li id="7945" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated">日志压缩不是即时的，它取决于主题设置、大小和处理能力。</li></ul></div><div class="ab cl mn mo hr mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ig ih ii ij ik"><h2 id="cd46" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">参考</h2><ul class=""><li id="ffa5" class="lb lc in jm b jn ld jr le jv lf jz lg kd lh kh li lj lk ll bi translated">【https://kafka.apache.org/documentation/ T4】</li><li id="ac12" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated"><a class="ae no" href="https://www.confluent.io/blog" rel="noopener ugc nofollow" target="_blank">https://www.confluent.io/blog</a></li><li id="9c96" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated">卡夫卡:权威指南——尼哈·纳克希德</li><li id="25b9" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated">巴尔·德雷——卡夫卡·埃蒂米(YouTube)</li><li id="2718" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated"><a class="ae no" href="https://www.tutorialspoint.com/apache_kafka" rel="noopener ugc nofollow" target="_blank">https://www.tutorialspoint.com/apache_kafka</a></li></ul></div></div>    
</body>
</html>