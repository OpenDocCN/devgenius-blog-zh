<html>
<head>
<title>Optimizing Pandas Data-Frame📁 Operations using Pandarallel (Parallel Processing)🚅</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化 Pandas 数据框架📁使用并行处理的操作🚅</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/optimizing-pandas-data-frame-operations-using-pandarallel-8824a599123?source=collection_archive---------3-----------------------#2022-12-28">https://blog.devgenius.io/optimizing-pandas-data-frame-operations-using-pandarallel-8824a599123?source=collection_archive---------3-----------------------#2022-12-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="a67a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">嘿，伙计们👋，让我们快速讨论一下 pandas 中的并行处理模块，它有助于将数据帧分成更小的部分并单独执行。</p><p id="8ab3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">目录:</p><ul class=""><li id="ca59" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated"><strong class="jm io"> <em class="kr">什么是 Pandarallel(并行处理)？</em>T5】</strong></li><li id="37aa" class="ki kj in jm b jn ks jr kt jv ku jz kv kd kw kh kn ko kp kq bi translated"><strong class="jm io"> <em class="kr">如何实现 Pandarallel？</em>T9】</strong></li><li id="569c" class="ki kj in jm b jn ks jr kt jv ku jz kv kd kw kh kn ko kp kq bi translated"><strong class="jm io"> <em class="kr">结论</em> </strong></li></ul><h2 id="ceb9" class="kx ky in bd kz la lb dn lc ld le dp lf jv lg lh li jz lj lk ll kd lm ln lo lp bi translated"><strong class="ak"> <em class="lq">什么是 Pandarallel？</em> </strong></h2><p id="7aa8" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated">在开始了解 pandarallel 之前，我们应该先了解一下“并行处理”。</p><ul class=""><li id="03d3" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated"><strong class="jm io">并行处理</strong>是一种操作模式，在这种模式下，任务被分成更小的部分，每个任务在连接到同一台计算机的不同处理器上同时执行</li></ul><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi lw"><img src="../Images/8e3a91d58567330e84466bd854ae9863.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rwEZzO7yGkLnOYXqyqkWZw.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">更多详情请访问:<a class="ae mm" href="https://hotcore.info/babki/parallel-processing-model.htm" rel="noopener ugc nofollow" target="_blank">https://hotcore.info/babki/parallel-processing-model.htm</a></figcaption></figure><p id="ad78" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们来谈谈 pandarallel，它是一个 python 模块，提供了一种简单的方法，只需更改一行代码就可以在所有 CPU 上并行处理 pandas 操作(它还显示进度条)。</p><p id="46e0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">只是为了展示使用和不使用 pandarallel 的情况:</p><ul class=""><li id="af80" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated">没有并行化</li></ul><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mn"><img src="../Images/f947ae24363373075a59a7874488b9ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kUXVQTwEHm-iJgQL.gif"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated"><a class="ae mm" href="https://raw.githubusercontent.com/nalepae/pandarallel/master/docs/progress_apply.gif" rel="noopener ugc nofollow" target="_blank">https://raw . githubusercontent . com/nale PAE/pandarallel/master/docs/progress _ apply . gif</a></figcaption></figure><ul class=""><li id="297e" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated">并行化</li></ul><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi gj"><img src="../Images/b301f9499c6bbe81991d7c445462c2f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QZSBObCgkiyTtQOA.gif"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated"><a class="ae mm" href="https://raw.githubusercontent.com/nalepae/pandarallel/master/docs/progress_parallel_apply.gif" rel="noopener ugc nofollow" target="_blank">https://raw . githubusercontent . com/nale PAE/pandarallel/master/docs/progress _ parallel _ apply . gif</a></figcaption></figure><p id="b4b5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要阅读更多关于 python 模块的内容，请访问 Github 页面。</p><h2 id="5118" class="kx ky in bd kz la lb dn lc ld le dp lf jv lg lh li jz lj lk ll kd lm ln lo lp bi translated"><strong class="ak"> <em class="lq">如何实现 Pandarallel？</em> </strong></h2><p id="54ed" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated">让我们来看一个数据集，看看 pandarallel 是如何工作的，</p><pre class="lx ly lz ma gt mo mp mq bn mr ms bi"><span id="0b8c" class="mt ky in mp b be mu mv l mw mx">## Importing pandas module<br/>import pandas as pd<br/><br/>## Reading and displaying the dataset<br/>df = pd.read_csv("Sales_Data.csv")<br/>display(df.head())</span></pre><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi my"><img src="../Images/7cea4bed851d35760efb1dc0742cc26c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_vZESCall-TaaOAwlrEHGw.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">数据框看起来像这样</figcaption></figure><p id="33f1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在下一个任务是导入 pandarallel 模块并初始化它。</p><pre class="lx ly lz ma gt mo mp mq bn mr ms bi"><span id="f737" class="mt ky in mp b be mu mv l mw mx">## Importing the module<br/>from pandarallel import pandarallel <br/><br/>## Initilze the pandarallel<br/>pandarallel.initialize(progress_bar = True)</span></pre><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mz"><img src="../Images/b74c2a35a0454fd971e80df2382fc3d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H73b_T3liPEvJ6h4xUKTzA.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">工作节点的数量</figcaption></figure><p id="20ce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了进行测试，我们创建了一个简单的函数，将“单位成本”和“单位价格”相乘(您可以给 python 函数起一个更好的名字😅).</p><pre class="lx ly lz ma gt mo mp mq bn mr ms bi"><span id="116d" class="mt ky in mp b be mu mv l mw mx">## Function defination <br/><br/>def add_column(df):<br/>    return (df['Unit Cost'] * df['Unit Price'])</span></pre><p id="eddb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们看看有无 pandarallel 的情况。</p><ul class=""><li id="b316" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated">没有 pandarallel</li></ul><p id="92b1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi">— — — — — — — — — — — — — — — — —</p><pre class="lx ly lz ma gt mo mp mq bn mr ms bi"><span id="3ac0" class="mt ky in mp b be mu mv l mw mx">df['Cal_cost'] = df.apply(add_column, axis=1)</span></pre><p id="99a6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了以进度条的形式看到这一点，我们可以使用另一个名为“<a class="ae mm" href="https://tqdm.github.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io">【tqdm】</strong></a><strong class="jm io">”的模块。</strong></p><pre class="lx ly lz ma gt mo mp mq bn mr ms bi"><span id="908c" class="mt ky in mp b be mu mv l mw mx">from tqdm import tqdm<br/>tqdm.pandas()<br/><br/>df['Cal_cost_tqdm'] = df.progress_apply(add_column, axis=1)</span></pre><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi na"><img src="../Images/ff25def04675042a29629792f4c05176.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Tl69cJklPOiNZ1e2ploDA.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">无 pandarallel:输出</figcaption></figure><p id="cd91" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi">— — — — — — — — — — — — — — — — —</p><ul class=""><li id="2ee5" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated">与 pandarallel</li></ul><p id="cc9d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi">— — — — — — — — — — — — — — — — —</p><pre class="lx ly lz ma gt mo mp mq bn mr ms bi"><span id="e26e" class="mt ky in mp b be mu mv l mw mx">df['Cal_cost_parallel'] = df.parallel_apply(add_column, axis=1)</span></pre><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/113058005e055ad97da277e8dffb4f1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*W_AHSZxN65rGmpZWzc0-Bg.png"/></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">带 pandarallel:输出</figcaption></figure><p id="b142" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">10，000 行在 4 个节点之间划分(每个节点 2500 行)。</p><p id="3486" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi">— — — — — — — — — — — — — — — — —</p><h2 id="e5da" class="kx ky in bd kz la lb dn lc ld le dp lf jv lg lh li jz lj lk ll kd lm ln lo lp bi translated">结论</h2><p id="898a" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated">在这篇文章中，我们了解了两个惊人的 python 模块 pandarallel 和 tqdm。</p><p id="2681" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">注意</strong> : <em class="kr">通常只有当你有一个非常大的数据集来显示这个模块的真正能力时，才使用 Pandarallel，否则普通方法和这个方法之间的时间差是可以忽略的。</em></p><p id="9d30" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae mm" href="https://linktr.ee/ravikumar10593" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">更多关于我:</strong> </a></p><p id="d1f6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我是一名数据科学爱好者🌺，学习和探索数学、商业和技术如何帮助我们在数据科学领域做出更好的决策。</p><p id="a00f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">想看更多</strong>:<a class="ae mm" href="https://medium.com/@ravikumar10593/" rel="noopener"><em class="kr">https://medium.com/@ravikumar10593/</em></a></p><p id="cd4c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">找到我的所有句柄</strong>:<a class="ae mm" href="https://linktr.ee/ravikumar10593" rel="noopener ugc nofollow" target="_blank"><em class="kr">https://linktr.ee/ravikumar10593</em></a></p><blockquote class="nc nd ne"><p id="ab87" class="jk jl kr jm b jn jo jp jq jr js jt ju nf jw jx jy ng ka kb kc nh ke kf kg kh ig bi translated">如果这篇文章对你有所帮助，别忘了关注、喜欢并分享给你的朋友👍快乐学习！！</p></blockquote></div></div>    
</body>
</html>