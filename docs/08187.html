<html>
<head>
<title>How to Create a Customized Sequence Class: Python OOP Complete Course — Part 18</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何创建定制的序列类:Python OOP 完整教程—第 18 部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-create-a-customized-sequence-class-python-oop-complete-course-part-18-8c47ac58b814?source=collection_archive---------3-----------------------#2022-05-24">https://blog.devgenius.io/how-to-create-a-customized-sequence-class-python-oop-complete-course-part-18-8c47ac58b814?source=collection_archive---------3-----------------------#2022-05-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ce87" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解 Python OOP 中的特殊方法序列以及如何覆盖它们。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6b3457c232e3400ffd6ec7c4bee8ccab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ty0-jxaYTcHo6goN3V8ltQ.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Artur Voznenko 在<a class="ae kv" href="https://unsplash.com/s/photos/sequences" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="ef44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们开始之前，让我告诉你:</p><ul class=""><li id="99a9" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">这篇文章是 Python 面向对象编程完整课程的一部分，你可以在这里找到它。</li><li id="fe41" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">所有资源都可以在下面的“资源”部分找到。</li></ul></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h2 id="35ca" class="mn mo iq bd mp mq mr dn ms mt mu dp mv lf mw mx my lj mz na nb ln nc nd ne nf bi translated">介绍</h2><p id="c789" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">你有没有尝试过定义一个类似于 Python 中常见序列的类，比如列表和字典，这些类的对象可能支持索引、切片或使用<code class="fe nl nm nn no b">for </code>循环的迭代？</p><p id="6a97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想学习如何做到这一点，你来对地方了。</p><p id="2e68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">目录</strong></p><ol class=""><li id="e88d" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr np ly lz ma bi translated"><a class="ae kv" href="#5028" rel="noopener ugc nofollow">什么是序列特殊方法？</a></li><li id="981d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr np ly lz ma bi translated"><a class="ae kv" href="#b0cd" rel="noopener ugc nofollow">可用序列特殊方法</a></li><li id="8061" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr np ly lz ma bi translated"><a class="ae kv" href="#625e" rel="noopener ugc nofollow">如何覆盖序列特殊方法？</a></li></ol></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h2 id="5028" class="mn mo iq bd mp mq mr dn ms mt mu dp mv lf mw mx my lj mz na nb ln nc nd ne nf bi translated">1.什么是序列特殊方法？</h2><p id="220d" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">它们<strong class="ky ir"> </strong>是让你的 Python 类表现得像<strong class="ky ir">内置</strong>序列(<code class="fe nl nm nn no b">dict</code>、<code class="fe nl nm nn no b">tuple</code>、<code class="fe nl nm nn no b">list</code>、<code class="fe nl nm nn no b">str</code>等)的方法..).</p><p id="c54b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些数据类型支持索引、迭代、成员运算符(in)和其他功能。为了让你的对象支持这些特性，你必须覆盖这些<strong class="ky ir">序列特殊方法</strong>。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h2 id="d399" class="mn mo iq bd mp mq mr dn ms mt mu dp mv lf mw mx my lj mz na nb ln nc nd ne nf bi translated">2.可用序列特殊方法</h2><p id="9b7c" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">让我们探索其中的一些功能。</p><ul class=""><li id="db51" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><code class="fe nl nm nn no b">__len__()</code>:是让你的类对象支持<code class="fe nl nm nn no b">len()</code>函数的方法。</li><li id="62c6" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe nl nm nn no b">__getitem__()</code>:是让你的类对象支持索引的方法。</li><li id="571c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe nl nm nn no b">__setitem__()</code>:这是一个让你的类对象可变的方法。</li></ul><p id="39c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了保持文章简洁明了，所有其他方法的定义都被移到了这个 pdf 文件中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/de7dd2a152be289eedd29af0359ea1e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*upCKe4DyflmfGbPDUZdl8Q.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@tassomitsarakis" rel="noopener ugc nofollow" target="_blank">塔索·米萨拉基斯</a>在<a class="ae kv" href="https://unsplash.com/s/photos/available-lights" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h2 id="625e" class="mn mo iq bd mp mq mr dn ms mt mu dp mv lf mw mx my lj mz na nb ln nc nd ne nf bi translated">3.如何重写序列特殊方法？</h2><p id="8919" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">首先假设您有一个包含多个文本文件的数据集，您需要一个类来帮助您方便快捷地访问这些文件(set 和 get)。</p><p id="ea9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从定义一个简单的类<code class="fe nl nm nn no b">Dataset</code>开始，它有两个实例属性<code class="fe nl nm nn no b">dataset_path</code>和<code class="fe nl nm nn no b">samples</code>。</p><pre class="kg kh ki kj gt nr no ns nt aw nu bi"><span id="63fd" class="mn mo iq no b gy nv nw l nx ny">import os</span><span id="4cb0" class="mn mo iq no b gy nz nw l nx ny">class Dataset:<br/>    def __init__(self, dataset_path):<br/>        self.dataset_path = dataset_path<br/>        self.samples = os.listdir(dataset_path)</span><span id="1b5d" class="mn mo iq no b gy nz nw l nx ny">dataset = Dataset(r'E:\new deeep team\python-oop\Sections\[3] Special Methods (Dunder Methods) in Python OOP\[8] Sequences Special Methods\Article\dataset')<br/>print(dataset.samples)</span></pre><p id="66ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nl nm nn no b">os.listdir()</code>已用于获取所选位置的可用文件和文件夹。</p><p id="a50b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个简单的例子中，如果你打印<code class="fe nl nm nn no b">dataset.samples</code>，你将得到<code class="fe nl nm nn no b">['Doc 0.txt', 'Doc 1.txt', 'Doc 2.txt']</code>。换句话说，我们的数据集有三个文本文件。</p><p id="9b34" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们检查数据集中有多少文件。</p><pre class="kg kh ki kj gt nr no ns nt aw nu bi"><span id="cd23" class="mn mo iq no b gy nv nw l nx ny"># Use len method<br/>print(len(dataset))</span></pre><p id="f9a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出:</p><pre class="kg kh ki kj gt nr no ns nt aw nu bi"><span id="c7bf" class="mn mo iq no b gy nv nw l nx ny"><strong class="no ir">TypeError</strong>                                 Traceback (most recent call last)<br/><strong class="no ir">&lt;ipython-input-6-78696a0140a2&gt;</strong> in &lt;module&gt;<br/>      1 <strong class="no ir"># Use len method</strong><br/><strong class="no ir">----&gt; 2 </strong>print<strong class="no ir">(</strong>len<strong class="no ir">(</strong>dataset<strong class="no ir">))</strong><br/><br/><strong class="no ir">TypeError</strong>: object of type 'Dataset' has no len()</span></pre><p id="8d74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为对象不支持方法<code class="fe nl nm nn no b">len()</code>，所以得到了<code class="fe nl nm nn no b">TypeError</code>。</p><p id="1b83" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们通过覆盖方法<code class="fe nl nm nn no b">__len__()</code>使<code class="fe nl nm nn no b">Dataset</code>对象支持该方法。(提醒一下，<code class="fe nl nm nn no b">samples</code>属性有一个数据集文件的列表)</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="7e9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出:</p><pre class="kg kh ki kj gt nr no ns nt aw nu bi"><span id="7a6d" class="mn mo iq no b gy nv nw l nx ny">3</span></pre><p id="5e10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，不再有错误，您得到了<strong class="ky ir"> 3 </strong>，因为它是文本文件的数量。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="018b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们尝试访问这个数据集中的第一个文件。</p><pre class="kg kh ki kj gt nr no ns nt aw nu bi"><span id="e8d2" class="mn mo iq no b gy nv nw l nx ny">print(dataset[0])</span></pre><p id="e9d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出:</p><pre class="kg kh ki kj gt nr no ns nt aw nu bi"><span id="7198" class="mn mo iq no b gy nv nw l nx ny"><strong class="no ir">TypeError</strong>                                 Traceback (most recent call last)<br/><strong class="no ir">&lt;ipython-input-10-458771d72ad1&gt;</strong> in &lt;module&gt;<br/><strong class="no ir">----&gt; 1 </strong>print<strong class="no ir">(</strong>dataset<strong class="no ir">[0])</strong><br/><br/><strong class="no ir">TypeError</strong>: 'Dataset' object does not support indexing</span></pre><p id="73b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您得到了<code class="fe nl nm nn no b">TypeError</code>,因为<code class="fe nl nm nn no b">Dataset</code>对象不支持索引。为了支持索引，您应该覆盖方法<code class="fe nl nm nn no b">__getitem__()</code>。</p><p id="e2fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们通过执行以下步骤来覆盖<code class="fe nl nm nn no b">__getitem__()</code>方法:</p><ul class=""><li id="cdeb" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">所有样品都有这种图案的名称<code class="fe nl nm nn no b">Doc {number}.txt</code>。因此，它将作为类属性添加。</li><li id="c46e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">下一个<code class="fe nl nm nn no b">__getitem__()</code>方法将被覆盖。该方法接受对象本身<code class="fe nl nm nn no b">self</code>和另一个参数来表示索引<code class="fe nl nm nn no b">index</code>，并返回所选择的值。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="d325" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出:</p><pre class="kg kh ki kj gt nr no ns nt aw nu bi"><span id="69e9" class="mn mo iq no b gy nv nw l nx ny">Hi, I am Doc 2</span></pre><p id="f339" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您获得了数据集中第三个文件的内容。</p><p id="b4a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">覆盖<code class="fe nl nm nn no b">__getitem__()</code>方法的另一个好处是类对象变得可迭代。下一个例子展示了如何在<code class="fe nl nm nn no b">for </code>循环中使用类对象。</p><pre class="kg kh ki kj gt nr no ns nt aw nu bi"><span id="01c1" class="mn mo iq no b gy nv nw l nx ny">for txt_file in dataset:<br/>    print(txt_file)</span></pre><p id="9c40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出:</p><pre class="kg kh ki kj gt nr no ns nt aw nu bi"><span id="2b94" class="mn mo iq no b gy nv nw l nx ny">Hi, I am Doc 0<br/>Hi, I am Doc 1<br/>Hi, I am Doc 2</span></pre></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="6e94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们看看如何使用我们的类来更新文件的内容。</p><p id="9b47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，让我们尝试下面的代码。</p><pre class="kg kh ki kj gt nr no ns nt aw nu bi"><span id="1d0d" class="mn mo iq no b gy nv nw l nx ny">dataset[2] = "Hello, new value!!"</span></pre><p id="ad59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出:</p><pre class="kg kh ki kj gt nr no ns nt aw nu bi"><span id="74e8" class="mn mo iq no b gy nv nw l nx ny"><strong class="no ir">TypeError</strong>                                 Traceback (most recent call last)<br/><strong class="no ir">&lt;ipython-input-34-dcffeaa6152f&gt;</strong> in &lt;module&gt;<br/><strong class="no ir">----&gt; 1 </strong>dataset<strong class="no ir">[2]</strong> <strong class="no ir">=</strong> <strong class="no ir">"Hello, new value!!"</strong><br/><br/><strong class="no ir">TypeError</strong>: 'Dataset' object does not support item assignment</span></pre><p id="f923" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您得到了一个<code class="fe nl nm nn no b">TypeError</code>,因为<code class="fe nl nm nn no b">Dataset</code>对象不支持项目分配。换句话说，<code class="fe nl nm nn no b">Dataset</code>类是<strong class="ky ir">不可变的</strong>。</p><p id="415c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要将其转换成一个<strong class="ky ir">可变的</strong>类，您应该覆盖方法<code class="fe nl nm nn no b">__setitem__()</code>。让我们在下面的代码片段中实现这一点。参考最后一个方法，看到我们打印了更新前后的值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="980f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出:</p><pre class="kg kh ki kj gt nr no ns nt aw nu bi"><span id="9525" class="mn mo iq no b gy nv nw l nx ny">Before update<br/>Hi, I am Doc 2<br/><br/>Updating a file<br/><br/>Afeter update<br/>Hi I am update Doc 2</span></pre><p id="d9dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您现在可以看到，第三个文件的内容已经更新。</p><p id="f00a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在前面的例子中，您可以看到<code class="fe nl nm nn no b">__set__()</code>已经被覆盖，如果它不存在，允许创建一个新项目。让我们试试。</p><pre class="kg kh ki kj gt nr no ns nt aw nu bi"><span id="a35e" class="mn mo iq no b gy nv nw l nx ny">print(dataset[4])</span></pre><p id="cd3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出:</p><pre class="kg kh ki kj gt nr no ns nt aw nu bi"><span id="c7fe" class="mn mo iq no b gy nv nw l nx ny"><strong class="no ir">FileNotFoundError</strong>                         Traceback (most recent call last)<br/><strong class="no ir">&lt;ipython-input-37-50f447d6a573&gt;</strong> in &lt;module&gt;<br/><strong class="no ir">----&gt; 1 </strong>print<strong class="no ir">(</strong>dataset<strong class="no ir">[4])</strong><br/><br/><strong class="no ir">&lt;ipython-input-35-6d0cd1f29eb1&gt;</strong> in __getitem__<strong class="no ir">(self, index)</strong><br/>     13         file_name <strong class="no ir">=</strong> self<strong class="no ir">.</strong>sample_name<strong class="no ir">.</strong>format<strong class="no ir">(</strong>index<strong class="no ir">)</strong><br/>     14         file_path <strong class="no ir">=</strong> os<strong class="no ir">.</strong>path<strong class="no ir">.</strong>join<strong class="no ir">(</strong>self<strong class="no ir">.</strong>dataset_path<strong class="no ir">,</strong> file_name<strong class="no ir">)</strong><br/><strong class="no ir">---&gt; 15         with</strong> open<strong class="no ir">(</strong>file_path<strong class="no ir">,</strong> <strong class="no ir">'r')</strong> <strong class="no ir">as</strong> f<strong class="no ir">:</strong><br/>     16             <strong class="no ir">return</strong> f<strong class="no ir">.</strong>read<strong class="no ir">()</strong><br/>     17 <br/><br/><strong class="no ir">FileNotFoundError</strong>: [Errno 2] No such file or directory: 'E:\\new deeep team\\python-oop\\Sections\\[3] Special Methods (Dunder Methods) in Python OOP\\[8] Sequences Special Methods\\Article\\dataset\\Doc 4.txt'</span></pre><p id="f836" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你得到了<code class="fe nl nm nn no b">FileNotFoundError</code>，因为没有一个文件叫做<code class="fe nl nm nn no b">Doc 4.txt</code>。</p><p id="8258" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们创建文档<code class="fe nl nm nn no b">Doc 4.txt</code></p><pre class="kg kh ki kj gt nr no ns nt aw nu bi"><span id="8873" class="mn mo iq no b gy nv nw l nx ny">dataset[4] = "Hi, I am Doc 4"<br/><br/>print(dataset[4])</span></pre><p id="7cfa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出:</p><pre class="kg kh ki kj gt nr no ns nt aw nu bi"><span id="6c39" class="mn mo iq no b gy nv nw l nx ny">Creating a new file<br/>Hi, I am Doc 4</span></pre><p id="e166" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，文件<code class="fe nl nm nn no b">Doc 4</code>已经创建，您已经获得了它的内容。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="6313" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们总结一下我们在这篇文章中学到了什么。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/ccb7fc677cd37fec2b5d19924bb08e77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WAm1cw8Ydb9c5mE-gv3CXA.jpeg"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://www.pexels.com/@ann-h-45017/" rel="noopener ugc nofollow" target="_blank">安 H </a>在<a class="ae kv" href="https://www.pexels.com/" rel="noopener ugc nofollow" target="_blank">像素</a>上拍摄</figcaption></figure><ul class=""><li id="2211" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><strong class="ky ir">序列特殊方法</strong>是让你的 Python 类像内置序列一样工作的方法(<code class="fe nl nm nn no b">dict</code>、<code class="fe nl nm nn no b">tuple</code>、<code class="fe nl nm nn no b">list</code>、<code class="fe nl nm nn no b">str</code>等等)..).</li><li id="4821" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">使用这样的方法将使你的类对象支持像<strong class="ky ir">索引、循环迭代、成员操作符……等等</strong>这样的特性。</li></ul></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="c4f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="od">附言</em> </strong> <em class="od">:万分感谢您花时间阅读我的故事。在你离开之前，让我快速地提两点</em></p><ul class=""><li id="06d5" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><em class="od">首先，要想直接在你的收件箱里看到我的帖子，请在这里订阅</em><a class="ae kv" href="https://medium.com/@samersallam92/subscribe" rel="noopener"><strong class="ky ir"><em class="od"/></strong></a><em class="od">，你可以在这里关注我</em><a class="ae kv" href="https://medium.com/@samersallam92" rel="noopener"><strong class="ky ir"><em class="od"/></strong></a><em class="od">。</em></li><li id="b33e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><em class="od">第二，作家在媒介上制造了数以千计的</em><strong class="ky ir"><em class="od">$</em></strong><em class="od">。为了无限制地访问媒体故事并开始赚钱，</em> <a class="ae kv" href="https://medium.com/@samersallam92/membership" rel="noopener"> <strong class="ky ir"> <em class="od">现在就注册成为媒体会员</em></strong></a><strong class="ky ir"><em class="od"/></strong><em class="od">其中</em> <strong class="ky ir"> <em class="od"> </em> </strong> <em class="od">每月只需花费 5 美元。通过此链接</em>   <em class="od">报名</em> <a class="ae kv" href="https://medium.com/@samersallam92/membership" rel="noopener"> <strong class="ky ir"> <em class="od">，可以直接支持我，不需要你额外付费。</em></strong></a></li></ul><div class="oe of gp gr og"><div role="button" tabindex="0" class="ab bv gv cb fp oh oi bn oj kp ex"><div class="ok l"><div class="ab q"><div class="l di"><img alt="Samer Sallam" class="l de bw ol om fe" src="../Images/7d756fa3da76843e747e5ecde71b84d0.png" width="20" height="20" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fill:40:40/1*4O9o5xxtyHdOvuDDgqPDiQ.jpeg"/><div class="fb bw l ol om fc n aw fd"/></div><div class="hh l fo"><p class="bd b dl z fp fq fr fs ft fu fv fw dk translated">萨梅尔·萨拉姆</p></div></div><div class="op oq gw l"><h2 class="bd ir tw ls fp tx fr fs ty fu fw ip bi translated">Python 面向对象编程的完整教程</h2></div><div class="ab q"><div class="l fo"><a class="bd b be z bi tz au ua ub uc qm ud an eh ei ue uf ug el em eo de bk ep" href="https://medium.com/@samersallam92/list/the-complete-course-in-objectoriented-programming-in-python-7b54126a7f4e?source=post_page-----8c47ac58b814--------------------------------" rel="noopener follow" target="_top">View list</a></div><div class="uh l fo"><span class="bd b dl z dk">24 stories</span></div></div></div><div class="pc dh pd fp ab pe fo di"><div class="di ou bv ov ow"><div class="dh l"><img alt="A magnifying glass with the Python logo and a set of objects and arrows connecting between them to indicate that everything in Python is an object" class="dh" src="../Images/ce97e46734c67f4f565df3877a88bd11.png" width="194" height="194" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/1*oEBVsGg3ZoemmQrO5XsEjg.png"/></div></div><div class="di ou bv ox oy oz"><div class="dh l"><img alt="A dummy image for better reading and navigation." class="dh" src="../Images/926249cc12e1f2c807e7711382599fb6.png" width="194" height="194" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/1*-3K07ESmZjOLyOJfQx79Og.jpeg"/></div></div><div class="di bv pa pb oz"><div class="dh l"><img alt="A dummy image for better reading and navigation." class="dh" src="../Images/2d5e5c2a38605b91a621b6b26d9ab546.png" width="194" height="194" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/1*v9F3xOiuKmEWZo37t0MuxQ.png"/></div></div></div></div></div></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="498e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要回到上一篇文章，您可以使用以下链接:</p><p id="70dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://levelup.gitconnected.com/what-happens-beyond-the-scene-when-you-get-set-or-delete-an-instance-attribute-d88be5610456" rel="noopener ugc nofollow" target="_blank">第 17 部分:当你获取、设置或删除一个实例属性时，场景之外会发生什么</a></p><p id="ac77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要阅读下一篇文章，您可以使用以下链接:</p><p id="ca98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第 19 部分:<a class="ae kv" href="https://medium.com/gitconnected/how-to-create-a-custom-context-manager-in-python-oop-python-oop-complete-course-part-19-6f6647a97f5c" rel="noopener">如何在 Python OOP 中创建自定义上下文管理器</a></p><h2 id="82bf" class="mn mo iq bd mp mq mr dn ms mt mu dp mv lf mw mx my lj mz na nb ln nc nd ne nf bi translated">资源:</h2><ul class=""><li id="2dd2" class="ls lt iq ky b kz ng lc nh lf pi lj pj ln pk lr lx ly lz ma bi translated">GitHub <strong class="ky ir">在这里。</strong></li><li id="c1cd" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">序列特殊方法<a class="ae kv" href="https://samersallam.gumroad.com/l/bewew" rel="noopener ugc nofollow" target="_blank"> pdf 文件</a>。</li></ul></div></div>    
</body>
</html>