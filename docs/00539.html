<html>
<head>
<title>Custom Method Decorators In Angular — A HTTP Cache Decorator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular中的自定义方法装饰器——一个HTTP缓存装饰器</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/custom-method-decorators-in-angular-a-http-cache-decorator-fb21d1e09932?source=collection_archive---------3-----------------------#2020-06-10">https://blog.devgenius.io/custom-method-decorators-in-angular-a-http-cache-decorator-fb21d1e09932?source=collection_archive---------3-----------------------#2020-06-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/bbb6aa4e92383f3297825e3a1774dadb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wFPqDQrhKOkaEnQK.jpg"/></div></div></figure><blockquote class="jv jw jx"><p id="2430" class="jy jz ka kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">有时，在我们的项目中，我们有一个在大多数方法中通用的需求，通常我们创建一个通用的帮助器方法，并在所有方法中手动调用它。但是调用这个方法需要修改代码，如果在后面的阶段我们不想对一个方法使用这个行为，我们必须再次从这个方法中移除这个调用。在某些情况下，应该选择自定义装饰器，而不是创建助手方法。</p></blockquote><p id="9804" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">今天，我们将讨论这样一个场景。如果我们去查看<a class="ae la" href="https://angular.io/guide/http#using-interceptors-for-caching" rel="noopener ugc nofollow" target="_blank"> Angular的官方文档</a>来缓存HTTP调用，它建议使用HTTP拦截器的机制。</p><p id="59b5" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">但是假设我有一些HTTP调用，为我的应用程序提供主数据，我只想缓存这些数据。在这种情况下，我需要修改我的拦截器来缓存特定URL的响应，或者为每个方法传递一个自定义头。</p><p id="cca1" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">如果我们可以通过使用自定义装饰器来决定这种行为，并在我们希望缓存来自API的响应的方法上添加自定义装饰器，会怎么样呢？或者，如果我们不希望缓存它，只需移除装饰器。</p><blockquote class="jv jw jx"><p id="145d" class="jy jz ka kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">所以让我们为我们的用例创建一个这样的装饰器。在Angular中，Decorators是普通的函数，它应该返回另一个被调用的函数。有几种类型的装饰器，如类装饰器、方法装饰器等。我们也一直在使用angular提供的许多内置装饰器，如@Input、@Component等。</p></blockquote><p id="6b5e" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">在我们的用例中，我们将使用方法装饰器。</p><p id="532f" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">一般来说，我们从服务方法中返回一个由HTTP客户端返回的可观察对象。所以我们的decorator函数应该存储结果并在每次后续调用时返回它，对吗？。让我们看看实现这一点的代码。</p><figure class="lb lc ld le gt jo"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="64be" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">因此，上面我们创建了一个名为<strong class="kb io"> CacheRes </strong>的函数，我们将其定义为<strong class="kb io"> MethodDecorator。</strong>该方法将在服务初始化时调用。在descriptor.value中，我们获得了应用这个装饰器的实际方法，并返回了修改后的描述符来应用我们的缓存。Decorator的调用由Angular自动处理。</p><p id="1126" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">这个装饰器可以像下面这样导入并正常使用。</p><figure class="lb lc ld le gt jo"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="934c" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">让我们看看装饰者的行为。</p><figure class="lb lc ld le gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lh"><img src="../Images/baff86ec0f6cd1ff470f00c73e758735.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*EQrOMKSjcB-GYmKCrZEJlw.gif"/></div></div></figure><p id="82a3" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">但是目前，我们的装饰器将缓存响应一次，并总是返回缓存的响应，如果我们希望它在从缓存返回特定次数的响应后从后端获取数据，该怎么办。让我们修改我们的<strong class="kb io"> CacheRes </strong> decorator来获得这种支持。</p><figure class="lb lc ld le gt jo"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="3e50" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">我们添加了一个refreshAfter计数，默认值为-1。所以如果我们像下面这样使用装饰器，它会保持之前的行为。</p><figure class="lb lc ld le gt jo"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="7d11" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">如果我们现在想使用最新添加的计数来决定它从缓存中服务的次数，我们可以像下面这样使用它。</p><figure class="lb lc ld le gt jo"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="672c" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">最后，让我们来看看新添加的功能是如何工作的。</p><figure class="lb lc ld le gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lh"><img src="../Images/1daf0d95c7aa3b31e77300427fad06bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*dQGc44EKpRiHUobtpXDc_g.gif"/></div></div></figure><p id="e49c" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">注意:-目前这个装饰器只适用于没有动态参数和请求体的API。用于获取国家列表、用户列表等场景。但是也可以扩展到处理这些情况。</p><blockquote class="jv jw jx"><p id="82c9" class="jy jz ka kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">一旦我们习惯于创建自定义装饰器，它们在处理这种场景时非常有用，并使我们的代码高度可配置，因为只需添加或删除一个装饰器来切换我们想要的功能，而不需要修改方法内部的主要逻辑。</p></blockquote></div></div>    
</body>
</html>