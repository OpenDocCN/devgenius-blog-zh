# Java 中的继承和多态

> 原文：<https://blog.devgenius.io/inheritance-and-polymorphism-in-java-7b3c42235aae?source=collection_archive---------3----------------------->

![](img/3ee095a1acbcd811f5f92de22cf5a596.png)

**子类和超类(父类和子类)**

如果我们有几个类，比如狗类、猫类、狼类、牛类和狮子类，我们可以看到所有这些类都有共同的行为和特征。所有这些类都应该有一个 eat 方法、sleep 方法、move 方法和 makenoise 方法。以及食物等共同特征。

因此，我们可以利用所有这些共同特征，创建一个名为 animal 的超类，并将所有这些共同特征包含在这个类中。因此，动物类将被称为超类，动物所属的类(例如，狗类、猫类)将被称为子类。

动物类看起来像这样，

![](img/841b3dfe478125956b6cf39b489bcc3a.png)

动物类的高级视图

既然我们创建了这个 Animal 类，我们就不需要在每个子类中都有这些公共方法。我们可以从子类中移除所有这些公共方法。现在，我们可以**从超类继承**这些方法，而不是在子类中拥有所有的公共方法。

![](img/8a03a27394c5eedf9de1cb2b28799ac2.png)

我们可以看到，cow 类必须实现的方法数量减少了。使用继承的一个原因是为了避免重复，我们可以减少编写相同方法的次数。如果我们没有使用继承，我们将不得不用完全相同的代码写 5 次 move 方法，但是现在我们有了一个可以被所有 5 个子类使用的方法。

继承类的实现如下所示。

```
public class Dog extends Animal{
```

我们使用 extends 关键字从超类继承。在这种情况下，Dog 类继承了 Animal 类

尽管如此，在 cow 类中还是有一些方法，尽管它们对所有动物都是通用的。

让我们假设这个例子中的所有动物都以同样的方式进食和睡觉。但是动物有一些不同的方法。例如，一头牛和一只狗吃的方式不同，发出的声音也不同。尽管 eat 方法对所有动物来说都是通用的，但有时您可能需要自己的实现，而不是采用超类中给出的方法。因此我们必须**覆盖**超类中给定的方法。

![](img/e971fae15a60644ed2d4790b3bfa10b7.png)

让我们假设动物而不是牛吃同样的东西，因此我们可以在超类(Animal)中有一个公共的吃的方法，并且我们可以在 cow 类中覆盖 eat 方法。其他类可以从 Animal 类继承 eat 方法，因为所有其他类的功能都是相同的。即使我们可以覆盖超类中的方法，我们也不能覆盖其中的实例变量。

重写一个方法看起来像这样。

```
@Override
public void eat() {
    // eat method specific to the subclass
}
```

我们可以使用@Override 关键字来覆盖超类的一个方法。

当我们查看类时，我们可以看到类的层次结构，我们可以进一步发现一些类中的共同行为，因此我们将这些类分组在一起，例如，狗和狼可以被分组为犬科动物，而猫和狮子可以被分组为猫科动物。

让我们认为猫科动物和犬科动物的运动方式彼此不同。

![](img/4a044a9a70d4a43a512b77f74c9f8a27.png)

当你调用一个类中的方法时，继承树中最慢的方法会被调用，比如说你调用 dog 类中的 makenoise 方法，那么 dog 类中的方法会被调用，因为它是继承树中最慢的方法。

如果你需要超类方法(例如 roam)并且你需要你自己的超类方法，我们可以像下面这样做。

```
public void roam() {
    super.roam();
    // continue with my method
}
```

我们可以使用 super 关键字来调用超类的方法，然后继续我们的方法

**是/有关系**

我们可以知道一个类是否应该通过使用 IS A 方法来继承，例如我们可以说狗是一种动物，我们可以通过使用这个方法来判断我们的设计是否正确。

当一个类有一个关系，例如，浴室有一个水槽。这意味着水槽应该是浴室的实例变量。

即使我们可以从超类继承方法和变量，如果它们被标记为私有，那么我们不能继承那些变量或方法。

当我们使用继承时，我们应该确保我们使用它是出于正确的原因。
我们不应该仅仅为了重用代码而使用继承。假设我们在 alarm 类中有一个特殊的 print 方法，现在你需要在 calculator 类中有一个 print 方法，我们不能只是从 Alarm 类中继承它，因为 calculator 不是 Alarm 的一个特定版本，你可以使用 IS A 方法(Alarm is a calculator 听起来不太合适)，作为一个解决方案，我们可以有一个单独的 print 类和 print 方法。

如果继承没有通过测试，我们就不应该使用它。

使用继承的好处是你可以重用代码，如果我们需要添加一个新的类(比如 Tiger 类)，你可以添加这个类而不影响其他类和其他代码。

它保证所有子类都由超类的方法组成，这就像是通过继承相关的类的一个公共协议。

在一般实践中，当我们创建一个继承树的时候，这个继承树是浅而宽的。

通常创建一只狗的新对象时，我们会使用

```
Dog dog = new Dog();
```

但是如果 Dog 类继承了 Animal 类，我们也可以用这种方式创建 Dog 对象

```
Animal dog = new Dog();
```

通过这样做，我们在堆中创建了一个新的 Dog 对象，但是引用对象的类型是 Animal。由于多态性，这是可以做到的

**多态**的意思是多种形式，它的意思是一个对象具有多种形式的能力。
在这种情况下，狗对象可以采取动物的形式。

这样做的好处是，假设我们有一个函数需要动物的 makenoise 方法。

```
public void talkingAnimal (Animal a){
    a.makenoise();
}
```

假设我们有一个如上所示的方法，如果我们需要对每个动物都使用这个方法，我们就必须为每个动物分别编写这个函数。但是现在我们可以使用多态，我们可以把狗作为动物来传递。然后方法 a.makenoise 将调用传递给函数的特定动物的方法

如果一个狗对象被传递给函数，那么狗的 makenoise 方法将被调用，如果一个猫对象被传递，那么猫的 makenoise 方法将被调用。

如果代码使用多态参数，将方法参数声明为超类类型，则可以在运行时传入任何子类对象。

当使用继承时，有些情况下你不能从一个类继承。

*   当类被标记为 final 时，不能从该类继承。
*   如果类只有私有构造函数，则不能从该类继承

如果一个类不是公共的，那么可以从该类继承的类是有限的。非公共类只能由同一个包中的子类继承。

我们不能将类标记为私有。

如果您不希望类中的方法被覆盖，那么将类设为 final 的原因可能是出于隐私考虑。
如果你不想只覆盖一个特定的方法，你可以让这个特定的方法成为最终方法。

当覆盖一个方法时，你必须确保遵循以下规则

*   确保方法的参数必须完全相同，不能更改类的参数，
*   方法的返回类型应该是相同的，或者是原始方法的返回类型的子类。
*   您不能降低方法的访问级别(例如，不能从 public 更改为 private)。

**重载一个方法** 重载一个方法与继承或多态无关。方法重载意味着我们和另一个方法有相同的方法名，但是我们有不同的参数。

```
//Perimeter of a square
public int perimeter(int a) {
    return a*4;
}
//Perimeter of a rectangle
public double perimeter(double a, double b) {
    return (2 * a) + (2 * b);
}
```

In 方法重载

*   我们可以改变方法的返回类型，但不能只改变返回类型而不改变参数。
*   我们还可以改变方法的访问级别

你可以通过查看我的 Java 入门列表，点击[这里](https://medium.com/@shashane.ranasinghe/list/introduction-to-java-9eb6c894d19c)来了解更多关于 Java 的知识

**参考文献**

1.  凯西·塞拉和伯特·贝茨。2005.第一版 Java，第二版。美国奥赖利&联合公司。