# 在 Rust 中实施合同设计

> 原文：<https://blog.devgenius.io/implement-design-by-contract-in-rust-3842ec9ba3c4?source=collection_archive---------4----------------------->

![](img/e702d5af2321ac1d4a5d84615be375a6.png)

来自[维基](https://en.wikipedia.org/wiki/Design_by_contract)

# 契约带来内置正确性

上次我写了一篇[的帖子](https://medium.com/me/stats/post/a06a7a49271f)，陈述了“**合同设计**的基本原理。这个概念在 1986 年首次被描述，当时开发了 Eiffel 编程语言。它为工程师提供了一种更好的方法来检查模块的功能是否可以根据预定义的合同照常工作，以便规范客户和供应商之间的责任和利益。一旦契约完成，我们就说模块遵守了规范，并将为彼此提供必要的正确性。

事实上，只有 [Eiffel 编程语言](https://en.wikipedia.org/wiki/Eiffel_(programming_language))提供了需要[前置条件](https://en.wikipedia.org/wiki/Precondition)、[后置条件](https://en.wikipedia.org/wiki/Postcondition)和[类不变量](https://en.wikipedia.org/wiki/Invariant_(mathematics)#Invariants_in_computer_science)的显式声明，而其他主流语言仍然需要额外的宏/插件支持，或者开发者应该自己实现这个逻辑。

幸运的是，尽管这些概念在主流编程语言中似乎不受欢迎，但我们仍然可以利用一些库来实现正确性，而无需编写多余的测试用例。比如 [Rust](https://docs.rs/contracts/latest/contracts/) 和 [Golang](https://github.com/Parquery/gocontracts) 都有自己的逻辑实现库。

# ATM 功能的真实合同

为了在真实案例中演示这个概念，我遇到了一个与我们日常生活相关的简单用例:ATM。我相信任何人都应该有在自动取款机上存钱或取钱的经历。用户应该将他们的借记卡插入 ATM，并输入他们要存/取多少钱。这个例子非常简单，我们不必考虑其他操作，如不同账户之间的电汇。我们关注的是存款/取款行为以及借记卡和 ATM 之间的交互。

![](img/5f5d28c941e62349635972776edf0a14.png)

试着想象一下借记卡和 ATM 的交互，双方之间存在什么样的契约？如果我们只关注存款/取款操作，我制作了一个描述条件的表格如下。

存款/提款合同

那么类不变量在哪里呢？Well class invariants 表明对于它的实例以及那些从父类继承的实例，什么必须为真。在这种情况下，我们必须考虑两种情况:借记卡和 ATM。两者都应该采用什么样的类不变量来保证它们始终有效。

借记卡和 ATM 的类不变量

当谈到**类不变量**时，我们应该记住这是一个限制自然属性和行为的规则。以月亮为例，什么样的属性在任何时候都必须是真的？我说:球体。那它的自然行为呢？我说:旋转。

作为一名开发人员，**重要的是找出对于一个类来说什么是永远正确的**。

在我们的例子中，类别**借记卡**和 **ATM** 有它们自己的字段；我们必须确保他们都遵守不变规则。

# **实现借记卡& ATM** 中的 DBC

在进入合同设计之前，我们应该先安装 DBC 防锈库。有一个箱子，[合同](https://docs.rs/contracts/latest/contracts/)，用于锈菌发展。它包含了足够的例子供你参考和模仿它的用法。

首先，我们可以使用 ***不变量*** 声明来获取两个实例，以维护它们自己的属性，因为我们已经在前一部分中规定了自然规则。因此，两者都编码如下:

此外，在上一节中，我们已经说明了两个组件的前置条件和后置条件。在这一部分中，我们将集中讨论两种情况:**存款&取款**，以了解契约在如何实现正确性方面的力量。

我从我的存储库中捕获了一段代码，展示了前置条件和后置条件如何作用于这两个函数。在 Rust 的[contract](https://docs.rs/contracts/latest/contracts/)t case 中，采用 ***需求/确保*** 声明分别表示前置条件/后置条件。以 ***存款&取款*** 功能为例，我们必须确定要存取的现金大于零，否则会发生异常。

> **#[要求(现金> 0，"存款应为正值")]
> #[要求(现金> 0，"取款应为正值")]**

如果我们想要验证契约是否如其被违反时那样工作，只需编写测试用例来检查异常是否如预期的那样发生，如下所示:

让我们运行这些测试案例，结果如下所示:

![](img/8bf5377cfea82b158113e5b56d06c4c4.png)![](img/71d6081a126d089b28ec5ecad7f2a803.png)

炸弹！！！异常发生了，我们的测试用例如预期的那样通过了，所以我们可以确定这两个组件将遵循输入现金应该大于 0 的规则。

更多的情况下，后置条件呢？正如我们所想象的，**在存款/取款操作**之后，自动柜员机的现金储备应该大于/小于之前的状态。因此，我们可以添加这两条规则来检查这两个组件是否可以正常工作。

> **#【确保(self . cash _ reserves>old(self . cash _ reserves)，【执行后现金储备应大于其前值】)】**
> 
> **#【确保(self . cash _ reserves<old(self . cash _ reserves)，“执行后现金储备应小于其前值”)]**

这些逻辑帮助我们检查我们的处理是否会产生意外的结果。理想情况下，这些异常不会发生，或者这意味着功能逻辑是不正确的，应该被细化。

好吧，上面的代码片段并不是完整的源代码，所以如果你想看看合同在**借记卡**和 **ATM** 组件上的完整实现，请访问[库](https://github.com/tsunghsiang/design-by-contract-tutorial)。此后将添加更多描述。

# 蔻驰杂音

***契约式设计*** 帮助我们维护模块的内置正确性。

事实上，契约的好处不仅仅局限于增强正确性。受文章长度的限制，我会花一些时间将它的内容分成几个帖子，描述它给软件工程带来了什么，以及我们应该如何在日常工作中利用它来提高我们的生产率。

有些人可能会质疑 DBC 似乎是另一种测试方法。然而，他们与我的观点不同。在我看来，DBC 为我们提供了一种确保内置正确性的方法，但没有教我们如何在违反合同时处理异常，这仍然留给开发人员来处理。然而，我们可以根据我们在客户和供应商之间起草的合同来添加或细化我们的测试用例，以尽可能地消除风险。

综上所述， ***合同设计*** 本身就是好事。

—

如果你认可我与你分享的价值，请做如下:
1。**鼓掌**文章
2。**订阅**我最新内容
3。**在其他平台关注**我了解更多信息
-IG:[@ ur _ Agile _ coach](https://www.instagram.com/ur_agile_coach/)
-播客(中文):[敏捷火箭](https://player.soundon.fm/p/7f7dc3df-d738-405c-8cf9-02157a92ec61)
- Youtube: [你的敏捷蔻驰](https://www.youtube.com/channel/UCzD0wQmD1n4MuTKk-JocACA)
- LinkedIn: [吴宗祥](https://www.linkedin.com/in/tsung-hsiang-wu-8542409b/)

如果您需要咨询或其他形式的合作，请发送邮件至:【urscrummaster@gmail.com】