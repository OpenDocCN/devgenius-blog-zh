<html>
<head>
<title>TypeScript Best Practices — Non-Null Assertions, Async, and Loops</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript 最佳实践—非空断言、异步和循环</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/typescript-best-practices-non-null-assertions-async-and-loops-2bb8e7376b18?source=collection_archive---------11-----------------------#2020-07-18">https://blog.devgenius.io/typescript-best-practices-non-null-assertions-async-and-loops-2bb8e7376b18?source=collection_archive---------11-----------------------#2020-07-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/222876f77ebb58fd242bc3cfeb268bdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*prGqMg-LYnrCCYYi"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@spdumb2025?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">陈彦蓉</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="6818" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使代码易于阅读和维护，我们应该遵循一些最佳实践。</p><p id="0f90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将看看我们应该遵循的一些最佳实践，以使每个人的生活更轻松。</p><h1 id="26ca" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">非空断言</h1><p id="82b0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以添加一个非空断言操作符来确保 sone 对象永远不会是<code class="fe me mf mg mh b">null</code>或<code class="fe me mf mg mh b">undefined</code>。</p><p id="cc66" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是用感叹号表示的。</p><p id="54b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a699" class="mq lc iq mh b gy mr ms l mt mu">function bar(foo: Foo | undefined) {<br/>  foo!.doSomething();<br/>}</span></pre><p id="52d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一个<code class="fe me mf mg mh b">foo</code>参数，可以是<code class="fe me mf mg mh b">undefined</code>。</p><p id="d6bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以为了确保它不是<code class="fe me mf mg mh b">undefined</code>，我们使用<code class="fe me mf mg mh b">!.</code>操作符来确保它不是<code class="fe me mf mg mh b">undefined</code>。</p><h1 id="2236" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有神奇的数字</h1><p id="5981" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该确保我们的代码中没有幻数。</p><p id="454c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们很难从代码中理解。</p><p id="8b65" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，如果我们必须改变它们，我们必须在多个地方进行改变。</p><p id="c96e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，与其写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5e3f" class="mq lc iq mh b gy mr ms l mt mu">const metersInFeet = meters * 3.28</span></pre><p id="2f9e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f7c9" class="mq lc iq mh b gy mr ms l mt mu">const METER_IN_FEET = 3.28;<br/>const metersInFeet = meters * METER_IN_FEET;</span></pre><p id="e309" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建一个常数，并使用它，这样每个人都知道它包含什么。</p><p id="1e2b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在任何地方引用它，所以如果需要，我们只需更改它一次。</p><h1 id="8e74" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有参数分配</h1><p id="38a8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">分配参数不是一个好主意。</p><p id="0eff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果它是一个对象，它会改变参数，因为它们是通过引用传递的/</p><p id="8296" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以与其写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a5e2" class="mq lc iq mh b gy mr ms l mt mu">function foo(x: number) {<br/>  x = 2;<br/>}</span></pre><p id="f12f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4f11" class="mq lc iq mh b gy mr ms l mt mu">function foo(x: number) {<br/>  const y = 2;<br/>}</span></pre><h1 id="99c7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有用于引用其他类型脚本文件的引用语法</h1><p id="5d06" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在 ES 模块并入 TypeScript 之前，我们使用了<code class="fe me mf mg mh b">reference</code>语法来引用其他 TypeScript 文件。</p><p id="4be6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，现在我们可以使用 ES6 模块来代替。</p><p id="c00c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ac86" class="mq lc iq mh b gy mr ms l mt mu">/// &lt;reference path='./foo'&gt;</span></pre><p id="d2b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将我们的 TypeScript 类型转换为模块，并编写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1d15" class="mq lc iq mh b gy mr ms l mt mu">import baz from foo;</span></pre><h1 id="2130" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不需要 var</h1><p id="e973" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">有了 TypeScript，我们可以使用<code class="fe me mf mg mh b">import</code>语法来要求 CommonJS 模块。</p><p id="db7b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以与其写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ecee" class="mq lc iq mh b gy mr ms l mt mu">var module = require("module");</span></pre><p id="f610" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7b4e" class="mq lc iq mh b gy mr ms l mt mu">import <!-- -->module <!-- -->= require('<!-- -->module<!-- -->');</span></pre><p id="3e69" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<code class="fe me mf mg mh b">require</code>，但是左侧有<code class="fe me mf mg mh b">import</code>。</p><p id="e469" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是语言的一部分，TypeScript 会正确地编译它。</p><h1 id="63ba" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">箭头功能</h1><p id="d283" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">每当我们的函数中不需要<code class="fe me mf mg mh b">this</code>时，我们就应该使用箭头函数。</p><p id="2378" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们更短，不会绑定到值<code class="fe me mf mg mh b">this</code>。</p><p id="90e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以与其写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7db5" class="mq lc iq mh b gy mr ms l mt mu">const foo = function() {<br/>  doWork();<br/>};</span></pre><p id="9cd1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0cbb" class="mq lc iq mh b gy mr ms l mt mu">const foo = () =&gt; {<br/>  doWork();<br/>};</span></pre><h1 id="68a6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用 for-of 循环</h1><p id="50d0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">for-of 循环是 javaScript 中最通用的一种循环。</p><p id="53e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它允许我们遍历任何类型的 JavaScript iterable 对象。</p><p id="969e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它唯一不能做的就是给我们索引。</p><p id="d56b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以当不需要索引时，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="67a5" class="mq lc iq mh b gy mr ms l mt mu">for (const a of arr) {<br/>  const(a);<br/>}</span></pre><h1 id="a974" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用带有承诺的异步</h1><p id="d4f4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">返回承诺的函数应该标记为<code class="fe me mf mg mh b">async</code>。</p><p id="c87a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过这种方式，我们确保他们返回一个带有解析值的承诺。</p><p id="d618" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4d45" class="mq lc iq mh b gy mr ms l mt mu">const foo = () =&gt; {<br/>  return mypromise<br/>    .then((val) =&gt; {<br/>      return val;<br/>    })<br/>}</span></pre><p id="a4cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e3bd" class="mq lc iq mh b gy mr ms l mt mu">const foo = async () =&gt; {<br/>  const val = await myPromise;<br/>  return val;<br/>}</span></pre><p id="09c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们都返回了一个具有确定值<code class="fe me mf mg mh b">val</code>的承诺。</p><h1 id="c82c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">向我们的代码中添加数据类型定义</h1><p id="8086" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该在代码中添加数据类型定义。</p><p id="3c3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们可以添加到变量、参数中，并作为返回类型。</p><p id="b27b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将让我们利用数据类型检查，并使它们更容易阅读。</p><p id="075a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ac9a" class="mq lc iq mh b gy mr ms l mt mu">function subtract(x, y) {<br/>  return x - y;<br/>}</span></pre><p id="940d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="01c5" class="mq lc iq mh b gy mr ms l mt mu">function subtract(x: number, y: number): number {<br/>  return x - y;<br/>}</span></pre><p id="093f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们指定了参数的数据类型和返回类型。</p><h1 id="bcef" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">统一签名</h1><p id="1bce" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们有两个函数签名重载可以用 union 或 rest 参数合并成一个，我们应该这样做。</p><p id="7804" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="fa4b" class="mq lc iq mh b gy mr ms l mt mu">function foo(a: number);</span><span id="688f" class="mq lc iq mh b gy mv ms l mt mu">function foo(a: string) {<br/>  console.log(a);<br/>}</span></pre><p id="a93c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1f52" class="mq lc iq mh b gy mr ms l mt mu">function foo(a: number | string) {<br/>  console.log(a);<br/>}</span></pre><p id="d5c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/a4a6d2434e0c7b4f4b7de6a4441267c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*km3XDFt8wzL4lL_e"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@philipmmacias?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">菲利普·马西亚斯</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><h1 id="23f9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="26f4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以添加非空断言来确保某些东西不是<code class="fe me mf mg mh b">null</code>或<code class="fe me mf mg mh b">undefined</code>。</p><p id="1342" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们不应该使用神奇的数字。</p><p id="3dd4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">async</code>和<code class="fe me mf mg mh b">await</code>、for-of 循环和组合签名来清理我们的代码。</p></div></div>    
</body>
</html>