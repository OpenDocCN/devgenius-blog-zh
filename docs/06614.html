<html>
<head>
<title>Simplified implementation of access and refresh tokens on a Node Express MongoDB backend server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node Express MongoDB后端服务器上访问和刷新令牌的简化实现</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/simplified-implementation-of-access-and-refresh-tokens-on-a-node-express-mongodb-backend-server-2b251975c21f?source=collection_archive---------1-----------------------#2022-01-20">https://blog.devgenius.io/simplified-implementation-of-access-and-refresh-tokens-on-a-node-express-mongodb-backend-server-2b251975c21f?source=collection_archive---------1-----------------------#2022-01-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/9a54c6ea3622dde2b6de6b1eb4a8ba81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IdHV5JYTpkLxLrMjRWeUIg.png"/></div></div></figure><p id="206b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本文中，我们将简化后端服务器上的访问和刷新令牌的实现，以验证和授权我们的用户访问服务上可用的端点</p><p id="1122" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">本演练的要求:</p><ul class=""><li id="1add" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">基本的节点和表达式知识</li><li id="b031" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">Mongoose ODM和MongoDB的基础知识</li><li id="1425" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">JSON Web令牌的基础知识</li></ul><p id="8ae6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将跳过设置服务器，直接跳到令牌实现，本演练的参考资源库可以通过以下链接在GitHub上找到:<a class="ae lh" href="https://github.com/Mulubwa17/Access_Refresh_tokens_Node_Express" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/mulubwa 17/Access _ Refresh _ tokens _ Node _ Express</a></p></div><div class="ab cl li lj hr lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ig ih ii ij ik"><p id="6b8b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">第一步</strong></p><p id="1f3e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">定义我们的模式以创建数据库文档并生成我们各自的令牌</strong></p><p id="3e8f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这一步中，我们在模型文档中定义了用户模式，并使用mongoose模式方法包含了令牌生成中间件，如下所示:</p><figure class="lq lr ls lt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lp"><img src="../Images/4322dca7c3e20708a31614b2aa51f5c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*29oVbwpaZBfqIdMi_SJx0Q.png"/></div></div></figure><p id="4758" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的代码中:</p><ul class=""><li id="5a7b" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">我们首先导入启动模式所需的必要包</li><li id="6444" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">我们从我们的<strong class="jx io"> <em class="lu">导入我们的访问和刷新令牌。env </em> </strong>文件在我们项目的根目录下</li><li id="f213" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">我们定义我们的用户模式(检查存储库中的字段)</li><li id="3faa" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">我们使用mongoose方法定义我们的访问令牌生成中间件，给它2分钟的到期时间</li><li id="dc53" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">我们使用mongoose方法定义我们的刷新令牌生成中间件，给它5分钟的到期时间</li><li id="952a" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">我们导出要创建的模型并保存在我们的mongo数据库中</li></ul><blockquote class="lv lw lx"><p id="d408" class="jv jw lu jx b jy jz ka kb kc kd ke kf ly kh ki kj lz kl km kn ma kp kq kr ks ig bi translated">访问令牌的到期时间总是比刷新令牌的到期时间短</p></blockquote></div><div class="ab cl li lj hr lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ig ih ii ij ik"><p id="ceb9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">第二步</strong></p><p id="0715" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">定义访问令牌验证逻辑</strong></p><p id="1a29" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这一步中，我们定义了通过检查访问令牌的到期日期来验证其有效性的逻辑。我们将它放在中间件文件夹中，因为我们需要将它导入到routes文件中来加密我们的端点。逻辑如下所示:</p><figure class="lq lr ls lt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mb"><img src="../Images/48540bfa02b9862cb19c1709baeefe93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vCl-vAZNPUabvLTMGizNtw.png"/></div></div></figure></div><div class="ab cl li lj hr lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ig ih ii ij ik"><p id="7105" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">第三步</strong></p><p id="343d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">在我们的认证/授权控制器中定义并导入我们的令牌中间件</strong></p><p id="86a8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这一步中，我们将把我们的模型中定义的令牌生成中间件导入到我们的控制器中，该控制器包含我们的身份验证/授权逻辑，如下所示:</p><figure class="lq lr ls lt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mc"><img src="../Images/fc45fde59cca467bd4c5610faf1641ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ymo5x94Cb80PhW-YIfi_6A.png"/></div></div></figure><p id="695b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们有如上所示的授权登录代码，并在其中突出显示:</p><ul class=""><li id="aa2d" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">当我们成功登录时，我们导入并使用我们的<strong class="jx io"> <em class="lu">访问令牌生成</em> </strong>中间件来返回一个访问令牌</li><li id="e950" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">当我们成功登录时，我们导入并使用我们的<strong class="jx io"> <em class="lu">刷新令牌生成</em> </strong>中间件来返回一个刷新令牌</li></ul></div><div class="ab cl li lj hr lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ig ih ii ij ik"><p id="646b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">第四步</strong></p><p id="5fba" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">在我们的授权/认证逻辑控制器</strong>中定义我们的刷新令牌登录</p><p id="3c1d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在此步骤中，我们将定义我们的刷新令牌逻辑，当当前令牌过期时，它允许我们生成新的访问令牌。我们定义了身份验证/授权控制器中的逻辑，如下所示:</p><figure class="lq lr ls lt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi md"><img src="../Images/d9b07f28a8a9dc1fef81e1763cf4e4ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2QSbO1AKIU00Xicz6oEedg.png"/></div></div></figure><p id="5fdf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的代码中:</p><ul class=""><li id="4823" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">我们要求在我们的请求体中从我们的登录获取一个刷新令牌</li><li id="175d" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">我们检查是否已经提供了<strong class="jx io"> <em class="lu">令牌串</em> </strong>，如果刷新令牌字段为空，则返回一个错误</li><li id="eba8" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">我们验证刷新令牌的有效性，并通过引用存储在令牌有效负载中的用户信息(在本例中是用户的id)来使用它找到拥有它的用户。</li><li id="86a2" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">一旦找到用户，我们使用我们的模型中定义的令牌生成中间件启动一个新的<strong class="jx io"> <em class="lu">访问令牌</em> </strong>，并将新令牌返回给用户</li></ul></div><div class="ab cl li lj hr lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ig ih ii ij ik"><p id="7df1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">第五步</strong></p><p id="6909" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">我们将授权/认证登录导出到我们的routes文件中</strong></p><p id="1302" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这一步中，我们将控制器的登录信息导入到routes文件中，并创建允许我们访问服务器的端点，如下所示:</p><figure class="lq lr ls lt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi me"><img src="../Images/593d340ee0613b526f0441ed0f96ef24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6MJRwTbcOFROQfJkPb2J-Q.png"/></div></div></figure><p id="cbce" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的代码中:</p><ul class=""><li id="0642" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">我们导入我们的控制器逻辑</li><li id="8018" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">我们从中间件文件夹中的<strong class="jx io"> <em class="lu"> auth </em> </strong>文件导入令牌验证逻辑</li><li id="1cd1" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">我们定义端点，将它们链接到控制器文件中的特定逻辑</li><li id="166c" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">我们使用访问令牌将我们的<strong class="jx io"> <em class="lu"> auth </em> </strong>中间件添加到我们想要消费的端点</li></ul></div><div class="ab cl li lj hr lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ig ih ii ij ik"><blockquote class="lv lw lx"><p id="5ebb" class="jv jw lu jx b jy jz ka kb kc kd ke kf ly kh ki kj lz kl km kn ma kp kq kr ks ig bi translated">在接下来的步骤中，我们将使用一个名为<strong class="jx io"><em class="in">【REST CLIENT】</em></strong>的Visual Studio代码扩展来运行Vs代码中的端点</p></blockquote><p id="eccf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">第六步</strong></p><p id="2e38" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">使用访问令牌</strong></p><p id="5c2b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这一步中，我们将尝试使用没有令牌的端点，然后通过登录并使用它来访问端点来生成令牌。</p><ul class=""><li id="e8c5" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">我们尝试列出服务器上没有访问令牌的所有用户，我们将返回一个错误，要求我们提供一个令牌，如下所示</li></ul><figure class="lq lr ls lt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mf"><img src="../Images/109025252ec97b2b285df7b86f06854e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ldUDM8-BQCyzfj0TpobwDw.png"/></div></div></figure><ul class=""><li id="1697" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">我们登录以检索我们的访问和刷新令牌，这些令牌将用于消费我们的其他端点，并在会话到期时进行刷新，如下所示:</li></ul><figure class="lq lr ls lt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mg"><img src="../Images/2b6b268f03e8ca0ff04b3ea7bd507bc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I_BC7-t4f3LFsu2IqFKo6g.png"/></div></div></figure><ul class=""><li id="af31" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">我们使用新获得的访问令牌来检索用户列表，如下所示:</li></ul><figure class="lq lr ls lt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mh"><img src="../Images/21650f20a04b14d4ed36add7f417e006.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8IqvBnSyuUoZlveZMlqceA.png"/></div></div></figure><ul class=""><li id="889e" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">2分钟后，我们注意到我们的访问令牌已过期，我们需要获取一个新的令牌，过期的令牌会返回一个错误，如下所示:</li></ul><figure class="lq lr ls lt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mi"><img src="../Images/2e6d32770b5996a4ffc1391335ff56ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ORnXddRLLCxRDctvzCqTsQ.png"/></div></div></figure><p id="f8ca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">第7步</strong></p><p id="bcf9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">使用刷新令牌生成新的访问令牌</strong></p><p id="629d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在最后一步中，我们将使用登录时收到的刷新令牌来生成新的访问令牌，并继续使用我们的服务器，而不结束我们的会话</p><ul class=""><li id="5abb" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">我们使用刷新令牌来生成新的访问令牌，如下所示:</li></ul><figure class="lq lr ls lt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mj"><img src="../Images/a0d2ac96fe3f63f6efdbd552dd57236a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0iqrckTgYuY2D2WXKVOl1Q.png"/></div></div></figure><ul class=""><li id="504c" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">我们使用新的访问令牌来使用我们的端点并继续我们的操作，如下所示:</li></ul><figure class="lq lr ls lt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mk"><img src="../Images/ea0559009b861a302d6ee7a29a380414.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_2C9QPw1dXF_baR0CCfqYQ.png"/></div></div></figure><h2 id="4551" class="ml mm in bd mn mo mp dn mq mr ms dp mt kg mu mv mw kk mx my mz ko na nb nc nd bi translated">现在，您已经成功地在服务器上实现了令牌认证。<strong class="ak"> <em class="ne">快乐编码！！！！</em>T3】</strong></h2></div></div>    
</body>
</html>