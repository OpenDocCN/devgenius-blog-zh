<html>
<head>
<title>The basics of immutable classes in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 中不可变类的基础知识</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/the-basics-of-immutable-classes-in-java-ebe533bab588?source=collection_archive---------2-----------------------#2021-12-02">https://blog.devgenius.io/the-basics-of-immutable-classes-in-java-ebe533bab588?source=collection_archive---------2-----------------------#2021-12-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e4bae0e63a9532fa6eea1545361b2d03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uhrRb0g_4KW065kN"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">一只塞特犬睡在一个人类婴儿旁边。瑞安·斯通在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="e421" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你不应该写 setters。至少目前的普遍观点是这样说的。二十年前，当 Java Beans 模型被公式化的时候，常识并不是这么说的。</p><p id="b9c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这并不是说今天的常识是错误的。只是常识通常无法解释这些声明背后的原因。或者解释简洁而隐晦。</p><p id="8ebe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在禁止 setter 的情况下，最初的程序员可能会被告知这是因为 setter 违反了不变性。这听起来可能像毫无意义的胡言乱语。</p><p id="bee2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者他们可能被告知类应该是不可变的。他们可能理解什么是不可变类，但是不理解为什么我们应该选择不可变类而不是可变类。</p><p id="a457" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者他们可能甚至不知道对于一个类来说不可变意味着什么。所以在这篇文章中，我的目的是解释在 Java 环境中一个类不可变意味着什么，以及为什么你通常更喜欢写不可变类而不是可变类。</p><p id="8be2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不可变类就是状态不变的类。这似乎是显而易见的。在实例化时，构造函数设置所有字段，这些字段保持不变，直到对象被丢弃。</p><p id="e8a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个不可变的类可能有 getters，但是没有很好的理由让它有 setters，因为字段不能被改变。</p><p id="c2eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Java 中最著名的类<code class="fe lb lc ld le b">String</code>，是不可变的。这意味着，正如您可能已经知道或已经明白的，一旦创建了一个<code class="fe lb lc ld le b">String</code>实例，就不能更改。当然，如果指针没有被标记为 final，那么它是可以改变的。</p><p id="9179" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个<code class="fe lb lc ld le b">String</code>实例上的任何计算结果几乎总是另一个<code class="fe lb lc ld le b">String</code>实例。例如，鉴于</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="2fda" class="ln lo iq le b gy lp lq l lr ls">String s = "Hello, World!";<br/>s = s.toLowerCase();<br/>System.out.println(s);</span></pre><p id="84de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">文本“你好，世界！”在<code class="fe lb lc ld le b">s</code>被重新分配指向“你好，世界！”后，很可能还会在系统中存在一段时间实例。如果我们有</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="8631" class="ln lo iq le b gy lp lq l lr ls">String s = "Hello, World!";<br/>s.toLowerCase(); <strong class="le ir">// Notice no "s = "</strong><br/>System.out.println(s);</span></pre><p id="f26f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们会看到“你好，世界！”而不是“你好，世界！”。您的集成开发环境(IDE)也可能建议您检查<code class="fe lb lc ld le b">toLowerCase()</code>的返回值。</p><p id="af0d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设小写计算仍然发生，但是我们的程序不能访问那个结果，因为<code class="fe lb lc ld le b">s</code>仍然指向初始化它的<code class="fe lb lc ld le b">String</code>实例。</p><p id="3218" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是我们实现<code class="fe lb lc ld le b">toLowerCase()</code>的一种方式:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="6cd0" class="ln lo iq le b gy lp lq l lr ls">    public String toLowerCase() {<br/>        char[] copy = (char[]) this.value.clone();<br/>        for (int i = 0; i &lt; copy.length; i++) {<br/>            copy[i] = Character.toLowerCase(copy[i]);<br/>        }<br/>        <strong class="le ir">return new String(copy);</strong><br/>    }</span></pre><p id="7e65" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这可能会创建一个新的<code class="fe lb lc ld le b">String</code>实例，即使当前的<code class="fe lb lc ld le b">String</code>实例已经是小写的。</p><p id="531e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我还没有彻底测试过，它可能无法通过一些特定于地区的测试，也可能无法通过涉及高低代理的测试。但是这里重要的是它不会改变它被调用的实例。</p><p id="7e78" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您不能改变一个<code class="fe lb lc ld le b">String</code>实例，因为它的所有实例字段都被标记为 final。最重要的字段只是一个包私有的<code class="fe lb lc ld le b">char</code>数组(包是<code class="fe lb lc ld le b">java.lang</code>)。</p><p id="bb42" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，获得具有不同状态的<code class="fe lb lc ld le b">String</code>实例的唯一方法是构造一个新的<code class="fe lb lc ld le b">String</code>实例。这是不可变类的定义特征。</p><p id="6408" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">String</code>类有大约二十个构造函数，有些是公共的，有些是包私有的，可能有些是完全私有的，这取决于你使用的 Java 开发工具包(JDK)的版本。</p><p id="b164" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个著名的 Java 类<code class="fe lb lc ld le b">Graphics</code>肯定是可变的。JDK 中的许多类是可变的。给定一个<code class="fe lb lc ld le b">Graphics</code>实例，你的程序可以调用<code class="fe lb lc ld le b">setColor()</code>和<code class="fe lb lc ld le b">setFont()</code>以及其他几个实例。</p><p id="2c22" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">理论上，<code class="fe lb lc ld le b">Graphics</code>可以作为一个不可变的类来实现。但是这实际上不会发生，因为今天仍在运行的许多 Java 软件都依赖于<code class="fe lb lc ld le b">Graphics</code>的可变性。</p><p id="c61d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果 Java 抽象窗口工具包(AWT)是今天发明的，<code class="fe lb lc ld le b">Graphics</code>可能仍然是一个可变类。但是更多的类，比如<code class="fe lb lc ld le b">Point</code>，将是不可变的。</p><p id="bf75" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不变性有很多好处。线程安全是一个经常被提到的好处，排在任何其他好处之前。</p><p id="4763" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Setters 意味着参数验证。一旦 setter 参数被验证，可能需要一到两个时钟周期来更新所有的对象状态。</p><p id="7c42" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果只有一个线程在访问一个对象，这不是问题。但是，即使只有两个不同的线程在访问同一个对象，当一个对象的状态不一致时，它也有可能被访问。这可能会导致意外的异常，例如对于不应该为空的空字段。</p><p id="b50b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果所有相关的对象都是由不可变的类定义的，那么当一个线程被中断而另一个线程访问同一个对象时，对象就不可能处于不一致的状态。</p><p id="038c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设<code class="fe lb lc ld le b">obj</code>是一个名为<code class="fe lb lc ld le b">SomeClass</code>的不可变类的实例。线程<code class="fe lb lc ld le b">t</code>有指向<code class="fe lb lc ld le b">obj</code>的指针<code class="fe lb lc ld le b">a</code>，线程<code class="fe lb lc ld le b">u</code>有指向<code class="fe lb lc ld le b">obj</code>的指针<code class="fe lb lc ld le b">b</code>。</p><p id="acce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果线程<code class="fe lb lc ld le b">u</code>需要改变<code class="fe lb lc ld le b">b</code>，那么<code class="fe lb lc ld le b">b</code>被改变指向<code class="fe lb lc ld le b">SomeClass</code>的一个新实例，或者指向<code class="fe lb lc ld le b">SomeClass</code>的一个不属于<code class="fe lb lc ld le b">obj</code>的现有实例。这不会以任何方式影响线程<code class="fe lb lc ld le b">t</code>，不管<code class="fe lb lc ld le b">a</code>是否仍然指向<code class="fe lb lc ld le b">obj</code>。</p><p id="9ef7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个更普遍的好处是不可变类更容易测试和调试。如果你接受测试驱动的开发方法，你测试你的不可变类，但是你几乎不需要调试它们。</p><p id="60b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果一个类是不可变的，那么就没有必要测试变化的状态。程序中更少的“活动部分”意味着测试程序时需要考虑的场景更少。</p><p id="2318" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一般来说，getters 和 setters 意味着更多的工作。例如，测试 getters 和 setters。我知道常识也说不要测试 getters 和 setters。</p><p id="96d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于测试 getters 和 setters，缺少的细微差别是，如果下列任一项为真，您应该实际测试它们:</p><ul class=""><li id="8232" class="lt lu iq kf b kg kh kk kl ko lv ks lw kw lx la ly lz ma mb bi translated">您希望 getters 不会泄漏可用于更改对象内部状态的引用。</li><li id="2359" class="lt lu iq kf b kg mc kk md ko me ks mf kw mg la ly lz ma mb bi translated">您希望 setters 执行任何验证。例如，如果参数中的数字被限制在特定的范围内。</li><li id="83a3" class="lt lu iq kf b kg mc kk md ko me ks mf kw mg la ly lz ma mb bi translated">这个类甚至只有一个显式定义的构造函数。构造函数越多，编写初始化时出错的可能性就越大。</li></ul><p id="5684" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，关于 getters，考虑这个函数，它说明了两个不同的问题:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="cb79" class="ln lo iq le b gy lp lq l lr ls">public ArrayList&lt;Transaction&gt; getTransactions() {<br/>    return this.transactions;<br/>}</span></pre><p id="0c94" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">理论上，返回值可能被用来在没有必要的事务验证的情况下不恰当地添加或删除事务。所以现在你需要测试<code class="fe lb lc ld le b">getTransactions()</code>没有泄露那一点状态。额外加分:用<code class="fe lb lc ld le b">getTransactions()</code>识别其他潜在问题。</p><p id="3c5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个<code class="fe lb lc ld le b">getTransactions()</code>函数来自一个表示银行账户的抽象类。理论上，<code class="fe lb lc ld le b">Account</code>可能是一个不可变的类。每当账户上发生交易时，整个<code class="fe lb lc ld le b">Account</code>对象的交易列表将被复制到一个新的<code class="fe lb lc ld le b">Account</code>对象，新的交易将覆盖新的交易列表，否则新的交易列表只包含旧的交易。</p><p id="1ae1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也许这可以很快完成，因为只需要复制指向<code class="fe lb lc ld le b">Transaction</code>对象的指针，而不是一个接一个地复制每个<code class="fe lb lc ld le b">Transaction</code>对象。</p><p id="17a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大概<code class="fe lb lc ld le b">Transaction</code>及其子类(比如<code class="fe lb lc ld le b">Deposit</code>和<code class="fe lb lc ld le b">Withdrawal</code>)应该是不可变的。这仍然允许未决交易的概念:<code class="fe lb lc ld le b">Account</code>将保存一个已完成交易的列表，这些交易的金额加起来就是“官方”余额，以及一个未决交易的列表。待处理交易的总数将被添加到官方余额中，以给出可用余额。</p><p id="3e0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">毫无疑问，表示金额的类应该是不可变的，并且您应该使用专门设计来表示金额的类，而不是使用<code class="fe lb lc ld le b">BigDecimal</code>。为此使用浮点原语是一个非常糟糕的主意。</p><p id="083b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">表示金额的类可能使用<code class="fe lb lc ld le b">java.util.Currency</code>来表示货币单位(例如，美元、欧元、法郎等)。).该类不仅是不可变的，而且是最终的，没有公共构造函数。</p><p id="f5d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我认为有可能创建一个可变的枚举类型(用<code class="fe lb lc ld le b">enum</code>)。但这可能不是个好主意。枚举类型应该总是不可变的。</p><h1 id="2eaf" class="mh lo iq bd mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd bi translated">摘要</h1><p id="4ac0" class="pw-post-body-paragraph kd ke iq kf b kg ne ki kj kk nf km kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">一个类是不可变的意味着它的内部状态在构造后不能改变。这样的类可以有 getters，但是不应该有 setters，因为那样的话它将是可变的而不是不可变的。</p><p id="a5f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">随着 Java 吸收 Scala 特性，它也吸收了标准库中对不变性的普遍偏好。然而，这不是必需的，Scala 的标准库自带可变类(也许还有可变特征)。</p><p id="92c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管我们应该更喜欢不可变的类，但是我们也应该认识到可变的类有它们的用途。如果你想成为一个绝对主义者，那么也许你应该用 Haskell 而不是 Java 编程。</p><p id="a4c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最好让常识来决定一个新类什么时候应该是不可变的，什么时候应该是可变的，最好是不可变的类。</p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><p id="a245" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nq">更多内容尽在</em><a class="ae kc" href="http://blog.devgenius.io" rel="noopener ugc nofollow" target="_blank"><em class="nq">blog . dev genius . io</em></a><em class="nq">。</em></p></div></div>    
</body>
</html>