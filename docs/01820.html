<html>
<head>
<title>Closures with examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带示例的闭包</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/closures-with-examples-189d0ed41de4?source=collection_archive---------27-----------------------#2020-07-12">https://blog.devgenius.io/closures-with-examples-189d0ed41de4?source=collection_archive---------27-----------------------#2020-07-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/79ccf8c3fe602438f94e002b3372024c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*i1rvoDphz-t26LXq"/></div></div></figure><p id="84c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Javascipt中，闭包是最漂亮的部分，有时也是最复杂的部分。简而言之，闭包允许您从内部函数访问外部函数的范围。</p><p id="a5ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">闭包允许我们在封闭函数之外调用内部函数，同时保持对封闭函数词法范围(即封闭函数中的标识符)的访问。</p><p id="84a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看这个例子可以更好地理解:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="0f23" class="lf lg iq lb b gy lh li l lj lk">function outer(){ <br/>    let value =10;<br/>    return function(){<br/>        console.log(value);<br/>    }<br/>}</span><span id="247b" class="lf lg iq lb b gy ll li l lj lk">const innerFunction = outer();</span><span id="4cc5" class="lf lg iq lb b gy ll li l lj lk">innerFunction();// 10</span></pre><p id="3bef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们定义了一个<strong class="ka ir">外部</strong>函数，并从中返回一个函数。这里返回的函数是一个高阶函数。</p><p id="eb83" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们调用外部函数并将其存储在<strong class="ka ir"> innerFunction </strong>变量中。即使在外部函数返回后，innerFunction仍保留该值。这是闭包在起作用。</p><blockquote class="lm"><p id="9e8c" class="ln lo iq bd lp lq lr ls lt lu lv kv dk translated">函数是javascript中的一等公民。对其他函数进行操作的函数，无论是将它们作为参数还是返回它们，都被称为高阶函数。</p></blockquote><p id="c4a9" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">让我们通过例子来看看闭包的作用。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h2 id="56e5" class="lf lg iq bd mi mj mk dn ml mm mn dp mo kj mp mq mr kn ms mt mu kr mv mw mx my bi translated">1.一个函数被调用多少次？</h2><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="0480" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">检查<code class="fe nb nc nd lb b">outer</code>函数的代码。请注意，我们正在返回一个函数，而该函数正在使用超出其作用域的<code class="fe nb nc nd lb b">counter</code>变量。闭包是我们从外部作用域访问变量的方式。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h2 id="c10a" class="lf lg iq bd mi mj mk dn ml mm mn dp mo kj mp mq mr kn ms mt mu kr mv mw mx my bi translated">2.循环迭代器</h2><p id="b079" class="pw-post-body-paragraph jy jz iq ka b kb ne kd ke kf nf kh ki kj ng kl km kn nh kp kq kr ni kt ku kv ij bi translated">不要将它与生成器迭代器函数混淆。我们只是创建了一个函数，以循环的方式打印数组的值。</p><p id="e53f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是它的代码:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="b6d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">断开<code class="fe nb nc nd lb b">cyclicIterator</code>功能:</p><ul class=""><li id="e962" class="nj nk iq ka b kb kc kf kg kj nl kn nm kr nn kv no np nq nr bi translated">接受数组</li><li id="b143" class="nj nk iq ka b kb ns kf nt kj nu kn nv kr nw kv no np nq nr bi translated">有一个初始化为0的变量<code class="fe nb nc nd lb b">index</code>,它将被用来在不同的函数调用中跟踪数组的索引。</li><li id="93df" class="nj nk iq ka b kb ns kf nt kj nu kn nv kr nw kv no np nq nr bi translated">返回内部函数。内部函数返回特定索引处的数组值，如果该索引是最后一个数组值；我们将索引重置为0，以实现循环行为。</li><li id="e01d" class="nj nk iq ka b kb ns kf nt kj nu kn nv kr nw kv no np nq nr bi translated">在第11行，我们用传入的数组调用<code class="fe nb nc nd lb b">cyclicIterator</code>。这将运行函数并返回给我们内部函数。</li><li id="c9f1" class="nj nk iq ka b kb ns kf nt kj nu kn nv kr nw kv no np nq nr bi translated">内部函数的引用存储为<code class="fe nb nc nd lb b">getDay</code>，这就是我们用来获取值的调用。</li></ul></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h2 id="174b" class="lf lg iq bd mi mj mk dn ml mm mn dp mo kj mp mq mr kn ms mt mu kr mv mw mx my bi translated">3.只调用一次函数</h2><p id="feba" class="pw-post-body-paragraph jy jz iq ka b kb ne kd ke kf nf kh ki kj ng kl km kn nh kp kq kr ni kt ku kv ij bi translated">在这个例子中，我们将定义一个只被调用一次的函数。在任何进一步的调用中，我们将简单地返回先前的结果。</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="71c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们来分解一下上面的<code class="fe nb nc nd lb b">once</code>功能:</p><ul class=""><li id="16eb" class="nj nk iq ka b kb kc kf kg kj nl kn nm kr nn kv no np nq nr bi translated">接受函数<code class="fe nb nc nd lb b">func</code>，该函数是在调用<code class="fe nb nc nd lb b">once</code>时传递的匿名函数。</li><li id="c7f7" class="nj nk iq ka b kb ns kf nt kj nu kn nv kr nw kv no np nq nr bi translated">我们定义了一个<code class="fe nb nc nd lb b">counter</code>变量来跟踪传入的函数是否被调用。我们还定义了一个<code class="fe nb nc nd lb b">res</code>变量来存储函数<code class="fe nb nc nd lb b">func</code>的响应。</li><li id="a155" class="nj nk iq ka b kb ns kf nt kj nu kn nv kr nw kv no np nq nr bi translated">在内部函数中，我们接受参数为<code class="fe nb nc nd lb b">params</code>。然后我们检查这个函数是否被计数器变量调用过一次。如果是，我们简单地返回先前的结果，而不调用它，否则我们递增计数器，调用函数，并将结果发送回来。</li><li id="2940" class="nj nk iq ka b kb ns kf nt kj nu kn nv kr nw kv no np nq nr bi translated">我们通过调用<code class="fe nb nc nd lb b">once</code>在第14行传递回调。它运行这个函数，并以<code class="fe nb nc nd lb b">onceFunc</code>的形式返回给我们一个内部函数的引用。然后我们调用<code class="fe nb nc nd lb b">onceFunc</code>来获得结果。</li></ul></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h2 id="1c35" class="lf lg iq bd mi mj mk dn ml mm mn dp mo kj mp mq mr kn ms mt mu kr mv mw mx my bi translated"><strong class="ak"> 4。记忆</strong></h2><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/9781b8633488e4958f38c2c516a8372e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4pI2cjAD7XRmfc8G"/></div></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk translated">特雷弗·麦金农在<a class="ae oc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="3fd0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">记忆化</strong>是一种优化技术，通过存储昂贵的函数调用的结果并在相同的输入再次出现时返回缓存的结果来加速应用程序。</p><p id="ef92" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们编写一个例子来更好地理解这一点。我们将举一个简单的例子，我们将把传入的值乘以5。</p><p id="c6d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">函数如下:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="99f1" class="lf lg iq lb b gy lh li l lj lk">function multiplyBy5(num){<br/>    //we can think of this function to be doing some heavy computations<br/>    console.log('Calculate');<br/>    return num * 5;<br/>}</span></pre><p id="d264" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在如果我们调用这个函数，它会一直执行。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="b41f" class="lf lg iq lb b gy lh li l lj lk">multiplyBy5(4);// 20<br/>multiplyBy5(7);// 35<br/>multiplyBy5(4);// 20</span></pre><p id="2d2a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们希望处理第三个调用，其中再次传递与第一个调用相同的输入。通过记忆化，我们希望通过不再调用函数来减少计算量。</p><p id="49c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们写一个记忆函数:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="b28a" class="lf lg iq lb b gy lh li l lj lk">function memoize(fn){<br/>    let map = new Map();<br/>    return function(param){<br/>        if(map.get(param)){<br/>            console.log(‘Cached’);<br/>            return map.get(param); <br/>         }else{<br/>            const result = fn(param);<br/>            map.set(param, result);<br/>            return result;<br/>         }<br/>    }<br/>}</span></pre><p id="fb2b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是<code class="fe nb nc nd lb b">memoize</code>函数正在做的事情:</p><ul class=""><li id="a8e7" class="nj nk iq ka b kb kc kf kg kj nl kn nm kr nn kv no np nq nr bi translated">接受先前定义为<code class="fe nb nc nd lb b">multiplyBy5</code>功能的功能。</li><li id="3cfb" class="nj nk iq ka b kb ns kf nt kj nu kn nv kr nw kv no np nq nr bi translated">创建一个<code class="fe nb nc nd lb b">Map</code>，它将存储任何先前计算值的结果并返回结果。</li><li id="c0c9" class="nj nk iq ka b kb ns kf nt kj nu kn nv kr nw kv no np nq nr bi translated">返回一个接受参数的函数。内部函数在执行时检查map是否有传递的参数值的结果；如果有，我们返回结果并且不计算。否则我们调用函数<code class="fe nb nc nd lb b">fn</code>并在map中设置结果，最后返回结果。</li></ul><p id="b71d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是完整的代码:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="c5a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">观察上面的最后一个日志。它返回第一次<code class="fe nb nc nd lb b">multiply</code>调用的缓存结果(在第23行),并且不再调用该函数。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="d279" class="od lg iq bd mi oe of og ml oh oi oj mo ok ol om mr on oo op mu oq or os mx ot bi translated">结束语</h1><p id="2684" class="pw-post-body-paragraph jy jz iq ka b kb ne kd ke kf nf kh ki kj ng kl km kn nh kp kq kr ni kt ku kv ij bi translated">在这篇文章中，我试图用例子解释闭包的一些用例。</p><p id="3dd7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你需要任何进一步的澄清，请在评论中告诉我。我很乐意帮忙。</p><h1 id="d928" class="od lg iq bd mi oe ou og ml oh ov oj mo ok ow om mr on ox op mu oq oy os mx ot bi translated">资源</h1><div class="oz pa gp gr pb pc"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" rel="noopener  ugc nofollow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd ir gy z fp ph fr fs pi fu fw ip bi translated">关闭</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">闭包是捆绑在一起(封闭的)的函数与对其周围状态的引用的组合</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">developer.mozilla.org</p></div></div><div class="pl l"><div class="pm l pn po pp pl pq jw pc"/></div></div></a></div><div class="oz pa gp gr pb pc"><a href="https://medium.com/javascript-scene/higher-order-functions-composing-software-5365cf2cbe99" rel="noopener follow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd ir gy z fp ph fr fs pi fu fw ip bi translated">高阶函数(构成软件)</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">注:这是“作曲软件”系列的一部分(现在是一本书！)关于学习函数式编程和…</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">medium.com</p></div></div><div class="pl l"><div class="pr l pn po pp pl pq jw pc"/></div></div></a></div></div></div>    
</body>
</html>