<html>
<head>
<title>Boost Your Web App’s Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提升您的Web应用程序的性能</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/boost-your-web-apps-performance-4c73b3a43b77?source=collection_archive---------25-----------------------#2020-07-19">https://blog.devgenius.io/boost-your-web-apps-performance-4c73b3a43b77?source=collection_archive---------25-----------------------#2020-07-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="2dfb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi ki translated">如今，越来越多的软件产品由于其无与伦比的优势:免安装、免升级和无处不在，正从桌面原生应用过渡到web应用。最著名的例子包括Gmail、iCloud和FB Messenger。</p><p id="5e38" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，随着开发人员加入更多的功能，web应用程序很难摆脱臃肿的大小和增加的加载时间等问题。一旦这些问题积累起来，它将逐渐从用户的情绪得分反映到顶线参与度指标(如DAP)。</p><p id="2626" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我花了将近一年的时间来提高脸书广告管理器的性能，这可能是ReactJS有史以来最大的应用程序。在这次旅程中，我发现以下4点对最终结果起着关键作用。在这篇笔记中，我将揭开前半部分:</p><ul class=""><li id="35b8" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">找到正确的成功标准</li><li id="1521" class="kr ks in jm b jn la jr lb jv lc jz ld kd le kh kw kx ky kz bi translated">通过预算系统限制初始包装尺寸</li><li id="0f20" class="kr ks in jm b jn la jr lb jv lc jz ld kd le kh kw kx ky kz bi translated">利用先进技术减少渲染时间</li><li id="6bbc" class="kr ks in jm b jn la jr lb jv lc jz ld kd le kh kw kx ky kz bi translated">持续保持和提高绩效</li></ul><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/6b974d19e42c1438c614a05392256568.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*a87_yGrv-uRgk7lL"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">由<a class="ae lv" href="https://unsplash.com/@rockthechaos?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Kolleen Gladden </a>在<a class="ae lv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="be73" class="lw lx in bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">#1找到北极星</h1><p id="3549" class="pw-post-body-paragraph jk jl in jm b jn mu jp jq jr mv jt ju jv mw jx jy jz mx kb kc kd my kf kg kh ig bi translated">这可能是修复任何性能问题的最关键的一步。通常，一个业余团队会以平均加载速度为目标，比如“平均4秒完成整个网站的加载”。这对于一个简单的web应用程序可能有用，但对于FB规模的应用程序来说，这将是一场灾难:</p><ol class=""><li id="06d9" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh mz kx ky kz bi translated">它没有考虑到一些连接性非常差的长尾用户和较低端的设备。</li><li id="7400" class="kr ks in jm b jn la jr lb jv lc jz ld kd le kh mz kx ky kz bi translated">“加载整个站点”是动态的，不切实际的。当人们在修复性能的时候，新的特性每天都在发布。加载性能可能会不断被新代码阻碍。</li></ol><p id="0fe0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了解决这个问题，我建议将指标目标定义为:</p><blockquote class="na nb nc"><p id="b5a6" class="jk jl nd jm b jn jo jp jq jr js jt ju ne jw jx jy nf ka kb kc ng ke kf kg kh ig bi translated"><strong class="jm io">80%的目标用户启用了所有核心交互，响应延迟为&lt;500毫秒。</strong></p></blockquote><p id="ca10" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该定义明确了:</p><ul class=""><li id="7792" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">仅限于“核心交互”，如在选项卡间导航、滚动、编辑文本等..</li><li id="d4a7" class="kr ks in jm b jn la jr lb jv lc jz ld kd le kh kw kx ky kz bi translated">关注P80目标用户，这样团队就可以通过其他难以改变的因素看到进展，比如网络基础设施</li><li id="1bac" class="kr ks in jm b jn la jr lb jv lc jz ld kd le kh kw kx ky kz bi translated">考虑到响应性，流体相互作用与快速加载一样重要</li></ul><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nh"><img src="../Images/4ed5ef4d16c3a83a81133603929280b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AFc2NsTkMZRevR6FR2qXCQ.png"/></div></div></figure><p id="db96" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦我们设定了目标，不要忘记与更广泛的受众分享，以便达成一致并让所有合作伙伴团队负起责任。</p><h1 id="60f7" class="lw lx in bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">#2所有资源的预算</h1><p id="002b" class="pw-post-body-paragraph jk jl in jm b jn mu jp jq jr mv jt ju jv mw jx jy jz mx kb kc kd my kf kg kh ig bi translated">如上所述，初始的应用程序包大小在现实世界中从来不是一个常数。许多团队希望每天添加新功能，并在登录页面上推广它们。因此，即使保持最初的封装尺寸也是一项“不可能完成的任务”，更不用说缩小它了。</p><p id="32ca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种情况下，在主要资源上实施预算是防止衰退和消除cruft累积的唯一解决方案。</p><h2 id="c637" class="ni lx in bd ly nj nk dn mc nl nm dp mg jv nn no mk jz np nq mo kd nr ns ms nt bi translated">可视化预算并启用警报</h2><p id="7c0c" class="pw-post-body-paragraph jk jl in jm b jn mu jp jq jr mv jt ju jv mw jx jy jz mx kb kc kd my kf kg kh ig bi translated">在我们砍掉文件之前，让我们构建:</p><ul class=""><li id="9f09" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">一个可视化文件大小及其与预算差异的工具。这应该作为交流的基本原则。</li><li id="5a53" class="kr ks in jm b jn la jr lb jv lc jz ld kd le kh kw kx ky kz bi translated">集成到所有代码提交审查工具中并配置为“提交阻止级别”的自动“预算超出警报”</li></ul><p id="899b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以没有人可以未经许可偷偷进入初始文件包，我们可以系统地阻止包大小回归。</p><h2 id="700b" class="ni lx in bd ly nj nk dn mc nl nm dp mg jv nn no mk jz np nq mo kd nr ns ms nt bi translated">每个产品的预算</h2><p id="af3e" class="pw-post-body-paragraph jk jl in jm b jn mu jp jq jr mv jt ju jv mw jx jy jz mx kb kc kd my kf kg kh ig bi translated">准备好工具后，下一步是计算总预算并在产品间分配。</p><p id="33b1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">可以很容易地计算出理想的总包装尺寸。网上有各种各样的公式，其中一个快捷键是:(<strong class="jm io">loading _ time _ goal * avg _ network _ speed)</strong>。</p><p id="9b64" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有了这个数字后，为核心文件留出一些空间，以保持应用程序的启动和导航交互。然后在初始化阶段需要呈现的不同产品之间分配剩余的内容。</p><p id="c6d7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请记住，每个产品应该只保留在初始包中呈现的最少代码。一旦被用户使用，大部分“特性代码”仍然应该是引导加载的。</p><h2 id="482f" class="ni lx in bd ly nj nk dn mc nl nm dp mg jv nn no mk jz np nq mo kd nr ns ms nt bi translated">超出JS规模的预算</h2><p id="d875" class="pw-post-body-paragraph jk jl in jm b jn mu jp jq jr mv jt ju jv mw jx jy jz mx kb kc kd my kf kg kh ig bi translated">初始包装尺寸只是预算系统的应用之一。一旦它在公司运行并被广泛接受，我们应该探索为以下关键资源建立预算:</p><ul class=""><li id="481d" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">JS CPU</li><li id="3933" class="kr ks in jm b jn la jr lb jv lc jz ld kd le kh kw kx ky kz bi translated">数据提取延迟</li><li id="b1da" class="kr ks in jm b jn la jr lb jv lc jz ld kd le kh kw kx ky kz bi translated">其他资源(图片..)尺寸</li></ul><h1 id="11ba" class="lw lx in bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">#3减少渲染时间</h1><p id="6c1e" class="pw-post-body-paragraph jk jl in jm b jn mu jp jq jr mv jt ju jv mw jx jy jz mx kb kc kd my kf kg kh ig bi translated">在我们尽一切努力来精简初始包之后，长时间的渲染可能是阻止我们获得最终改进的最后一个瓶颈。渲染时间是本地JS/CSS处理的结果，有几个因素对此有影响:</p><ol class=""><li id="e66e" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh mz kx ky kz bi translated">硬件性能，如CPU、内存</li><li id="6d8b" class="kr ks in jm b jn la jr lb jv lc jz ld kd le kh mz kx ky kz bi translated">浏览器Javascript引擎的性能</li><li id="0ab0" class="kr ks in jm b jn la jr lb jv lc jz ld kd le kh mz kx ky kz bi translated">代码是如何实现的，比如使用ReactJS或其他框架</li></ol><p id="0fd8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以上所有因素中，我们对第3个因素(switch framework ~=重写整个app)的控制力有限，对其他因素无能为力。那么，如果我们的目标用户使用中低端设备，如何确保他们也获得类似的高性能呢？</p><blockquote class="na nb nc"><p id="ce09" class="jk jl nd jm b jn jo jp jq jr js jt ju ne jw jx jy nf ka kb kc ng ke kf kg kh ig bi translated">答案是“<strong class="jm io">前置器</strong>”。</p></blockquote><p id="cd62" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">“Prerender”是一个概念，web应用程序在服务器端生成初始页面的HTML代码，并将其直接推送到客户端。由于我们跳过了处理JS/CSS包，并且在浏览器中呈现HTML的速度很快，“Prerender”可以显著提高初始页面的“感知加载速度”。用户可以立即在屏幕上看到主要特性的静态UI，而客户端则专注于下载JS代码来实现交互。</p><p id="4062" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">网上有几种不同的开源“Prerender”框架。你可以根据你的应用程序的技术堆栈，选择或构建你自己的内部应用程序。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nu"><img src="../Images/3ec67986fa0a5b646f9028e844971e9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_WE-M-m8Si-wavi-RT9xOA.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">在其他人添加功能时维护性能</figcaption></figure><h1 id="742a" class="lw lx in bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">#4保持进步</h1><p id="9f38" class="pw-post-body-paragraph jk jl in jm b jn mu jp jq jr mv jt ju jv mw jx jy jz mx kb kc kd my kf kg kh ig bi translated">提高性能是一场持久战。敌人不仅包括遗留代码和废弃的框架，还包括每天新提交引入的回归。</p><p id="8bc6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了帮助我们的工程师守住前线，我们需要创建一套工具来帮助我们快速找到并消除任何回归。具体来说，我们需要:</p><ol class=""><li id="6539" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh mz kx ky kz bi translated">显示初始装载的每一步的装载时间的仪表板</li><li id="5949" class="kr ks in jm b jn la jr lb jv lc jz ld kd le kh mz kx ky kz bi translated">报告回归和可疑提交的警报系统</li><li id="fb2f" class="kr ks in jm b jn la jr lb jv lc jz ld kd le kh mz kx ky kz bi translated">一个标签/任务工具，要求每个回归所有者输入影响、根本原因以及最重要的预防措施。</li><li id="4d15" class="kr ks in jm b jn la jr lb jv lc jz ld kd le kh mz kx ky kz bi translated">一个正式的评审过程，让每个回归所有者对修复和预防负责。</li></ol><p id="bcf6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面提到的构建工具和过程与其他工程工作一样重要，因为它系统地消除了回归的可能性，一次一个。一旦我们有了这些，工程师们再也不会因为反复的回归而沮丧了。</p></div></div>    
</body>
</html>