<html>
<head>
<title>Publishing Custom Events to Spring Boot Instances via Cloud Bus</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过云总线将自定义事件发布到Spring Boot实例</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/publishing-custom-events-to-spring-boot-instances-via-cloud-bus-79baf962a96e?source=collection_archive---------4-----------------------#2020-06-29">https://blog.devgenius.io/publishing-custom-events-to-spring-boot-instances-via-cloud-bus-79baf962a96e?source=collection_archive---------4-----------------------#2020-06-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/8ca6db8e60311220f725749f2f3b5d06.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*qzjTDWxzO1SV0vbEe5U5ag.png"/></div></figure><p id="7d65" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在上一篇<a class="ae ks" href="https://medium.com/dev-genius/load-balancing-a-spring-boot-application-with-nginx-and-docker-e701f74c011d" rel="noopener">文章</a>中，我们介绍了如何在负载平衡器后面部署同一个Spring Boot应用程序的多个实例。在这个例子中，我们能够修改单个实例的状态，并观察响应的变化。</p><p id="7201" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">尽管这种方法可以适用于我们知道实例的精确坐标的简单情况；这在规模上是不方便。在大规模生产环境中:</p><ul class=""><li id="5ff7" class="kt ku iq jw b jx jy kb kc kf kv kj kw kn kx kr ky kz la lb bi translated">同一服务可能有10s个实例，向每个实例发送命令可能并不实际。此外，实例的数量可能会根据负载动态变化。</li><li id="790b" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">如果实例部署在Mesos Kubernetes中，我们甚至可能不知道它们的确切坐标(IPs、端口)。</li></ul><p id="9124" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">通常<a class="ae ks" href="https://cloud.spring.io/spring-cloud-config/reference/html/" rel="noopener ugc nofollow" target="_blank">配置服务器</a>是被认可的管理Spring Boot实例配置的解决方案。然而，在某些情况下，我们可能希望向实例发出事件/命令，而这些命令与应用程序配置无关。</p><p id="fd9f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">使用情形示例可能包括:</p><ul class=""><li id="a312" class="kt ku iq jw b jx jy kb kc kf kv kj kw kn kx kr ky kz la lb bi translated">使实例的本地缓存无效</li><li id="d9e7" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">清除本地队列</li><li id="8871" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">收集一些临时指标</li></ul><p id="0bad" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对于这些情况，我们可以将<a class="ae ks" href="https://spring.io/projects/spring-cloud-bus" rel="noopener ugc nofollow" target="_blank"> Spring Cloud Bus </a>与消息代理一起使用，以便将事件/命令分发到应用程序的每个实例。</p><p id="d100" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在本文中，我们将浏览一个示例，演示为Docker环境部署Spring Cloud Bus以及向应用程序发送自定义事件的步骤。</p><h1 id="48c4" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">春云巴士</h1><p id="585a" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">Spring Cloud Bus旨在通过消息代理链接应用程序的分布式节点，以便广播状态/配置更改和管理指令(这将是我们示例的主题)。Spring Cloud Bus的功能相当于一个分布式的Actuator a，同时也是应用程序之间的通信通道。在这个例子中，我们将使用Spring Cloud Bus为我们的应用程序创建和处理自定义事件。</p><p id="fb5b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">消息代理是这种集成的重要部分。Kafka任何符合AMQP标准的经纪人，比如RabbitMQ，都是由Spring Cloud Bus现成支持的。在这个例子中，我们将使用RabbitMQ作为我们的消息代理。</p><h1 id="edd0" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">投资机会:RabbitMQ</h1><p id="2eb9" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">RabbitMQ是一个轻量级的开源消息代理，它实现了AMQP协议。RabbitMQ在分布式系统和微服务中非常流行，以便于呈现可伸缩性和易用性的应用之间的异步通信。</p><p id="4211" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在我们的示例中，RabbitMQ将作为我们的代理，在我们的实例之间传递事件。</p><h1 id="5f01" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">示例的范围</h1><p id="afd2" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">这个例子是我们之前的负载均衡器的扩展版本。这一次，我们将在Docker Compose环境中执行以下操作:</p><ul class=""><li id="3b0a" class="kt ku iq jw b jx jy kb kc kf kv kj kw kn kx kr ky kz la lb bi translated">部署RabbitMQ消息代理</li><li id="0687" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">配置一个负载平衡器，向我们的应用程序发送读取和更新请求</li><li id="13ec" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">通过Spring Cloud Bus创建一个与RabbitMQ集成的简单Spring Boot应用程序，并将其扩展到3个实例</li><li id="7955" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">通过一个HTTP请求更新应用程序状态，并观察到更改被发布到所有的应用程序实例</li></ul><h1 id="ad73" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">RabbitMQ部署</h1><p id="0b18" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">您可以在下面的docker-compose代码片段中看到我们的RabbitMQ配置。</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="e1cd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们已经部署了一个RabbitMQ实例。RabbitMQ映像还包含用于管理和监控的管理控制台。我们已经暴露了端口5672和15672。5672是RabbitMQ使用的端口，部署在Docker环境中的应用程序不需要这个端口，但是在本地机器上进行开发时可能会很方便。15672是运行管理控制台的端口。我们已经暴露了那个来监视我们本地的经纪人。</p><h1 id="bd4a" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">负载平衡器配置</h1><p id="e848" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">这与我们的负载平衡器示例的配置大致相同，只是增加了一项。这次我们为3台服务器配置Nginx。为了示例的完整性，您可以找到下面的配置。</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="6ca2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们的负载平衡器将监听端口9090，并将流量转发到端口8080上的服务器。</p><h1 id="cad1" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">我们的Spring Boot应用程序</h1><h1 id="ff56" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">属国</h1><p id="277d" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">下面你可以看到out <em class="mq"> build.gradle.kts. </em>中的依赖部分</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="0a33" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们为应用程序添加了三个依赖项:</p><ul class=""><li id="03ba" class="kt ku iq jw b jx jy kb kc kf kv kj kw kn kx kr ky kz la lb bi translated"><em class="mq">Spring-boot-starter-actuator</em>用于监控和管理，Spring Cloud Bus非常依赖。</li><li id="a64a" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><em class="mq">spring-cloud-starter-bus-amqps</em>是我们这里的关键依赖。它通过AMQP(例如RabbitMQ)实现了云总线集成。</li><li id="82ba" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">最后，我们增加了<em class="mq">杰克逊模块-科特林</em>。春云事件发布为JSON。Jackson Kotlin模块用于JSON序列化/反序列化。</li></ul><h1 id="642d" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">云总线和事件相关代码</h1><p id="cc6d" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">看了一堆无聊的配置后，现在是实际代码运行的时候了。在下面的代码片段中，您可以看到我们的云总线相关代码。</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="8519" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">首先我们添加了一个<em class="mq"> BusConfig </em>。这是一个标记组件，用于放置类似于<em class="mq">@ RemoteApplicationEventScan</em>的注释。<em class="mq">@ RemoteApplicationEventScan</em>是一个注释，表示要扫描事件的包。默认情况下，它递归地检查当前包(及其子包);但是可以定制。</p><p id="ba1e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后，我们将自定义事件类定义为<em class="mq"> UpdateDataEvent </em>。这是一个类似POJO的类，扩展了Spring Cloud Bus的<em class="mq"> RemoteApplicationEvent </em>。请将整数<em class="mq">字段<em class="mq">新数据</em>作为节点，这是我们将通过事件分发的实际有效载荷。远程应用程序事件的关键点是使数据JSON可序列化。</em></p><p id="d496" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在底部，您可以看到<em class="mq"> ApplicationListener </em>实现<em class="mq"> </em>，它处理我们的自定义<em class="mq"> UpdateDataEvent </em>。在接收到<em class="mq"> UpdateDataEvent后，</em>会打印一个日志行，并更新名为<em class="mq"> State </em>的组件的数据。</p><p id="7b6a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="mq"> State </em>顾名思义是一个有状态组件，定义如下。</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="bb89" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我想提醒的是，在Spring Beans中存储状态并不是一个好的做法；但我们将仅用于演示目的。</p><h1 id="e63f" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">REST控制器和发布事件。</h1><p id="1ffc" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">最后，我们的应用程序通过REST控制器公开了它的API，并公开了两个方法。</p><p id="d0f0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae ks" href="https://gist.github.com/itasyurt/d00bbb1e74c48e91fa2ee3fdfba34373" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/itasyurt/d 00 BBB 1 e 74 c 48 e 91 fa 2 ee 3 fdfba 34373</a></p><p id="ec3f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="mq"> getResult </em>方法返回存储在<em class="mq"> State </em>组件中的数据，没有什么太花哨的地方。</p><p id="b550" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然而，updateData 有点棘手。它通过put请求获取客户端输入。但是它不是直接更新状态，而是创建一个<em class="mq"> UpdateDataEvent </em>并将其发布到应用程序上下文。</p><p id="1228" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在创建事件时，我们需要在事件中包含id originService这样应用程序实例就能够检测出来源是否是它自己。仅当事件的来源与实例相同时，事件才会发布到总线。可以从自动连接到REST控制器bean的BusProperties的id中检索实例的唯一id。</p><h1 id="3f1d" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">应用程序属性</h1><p id="0e20" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">下面您可以看到我们的应用程序属性:</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="e66a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">前三行是配置执行器端点，与我们的示例没有太大关系，云总线配置行在最后两行。</p><ul class=""><li id="d675" class="kt ku iq jw b jx jy kb kc kf kv kj kw kn kx kr ky kz la lb bi translated"><em class="mq">spring . cloud . bus . destination</em>是RabbitMQ上的交易所名称。默认情况下，它的名称是样本交换；但是对于我们的用例来说，覆盖它是很好的。</li><li id="0030" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">spring.rabbitmq.host是我们rabbitmq居住的地方。因为我们已经在docker组合中将RabbitMQ服务定义为<em class="mq"> rabbit </em>，所以我们必须将该属性设置为<em class="mq"> rabbit </em>。</li></ul><h1 id="0ca7" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">Docker配置</h1><p id="a060" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">你可以在下面看到我们的应用文档。那里没什么有趣的事。</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="e3c8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在docker组合中，我们可以如下配置我们的三个应用服务器:</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="f87b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请注意，我们没有向主机公开端口8080。与应用程序的所有通信都将通过端口9090上的负载平衡器。</p><h1 id="b496" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">运行示例</h1><h1 id="f25a" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">重述我们的docker-compose.yml</h1><p id="d917" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">在上面的部分中，docker组合的各个部分显示在相关部分中。下面你可以看到完整的docker-compose.yml</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="eada" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这里，您可以在一个地方看到负载平衡器、rabbit和应用程序服务。</p><h1 id="d4d4" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">构建和运行Docker环境</h1><pre class="mk ml mm mn gt mr ms mt mu aw mv bi"><span id="48f4" class="mw li iq ms b gy mx my l mz na">docker-compose build</span><span id="a414" class="mw li iq ms b gy nb my l mz na">docker-compose up</span></pre><p id="4440" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">完成我们的docker作文后；您可以看到我们的Docker环境有5个容器(3个应用程序实例、1个负载平衡器和1个RabbitMQ)。</p><h1 id="11cb" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">RabbitMQ管理控制台</h1><p id="28da" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">我们的RabbitMQ容器提供了一个web管理UI，可以通过我们的web浏览器在<a class="ae ks" href="http://localhost:15672" rel="noopener ugc nofollow" target="_blank"> http://localhost:15672 </a>上访问。我们可以使用用户名/密码组合<em class="mq"> guest/guest </em>登录。</p><p id="8263" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在“交换”选项卡中，我们将看到我们为应用程序属性设置的目的地<em class="mq"> someBus </em>:</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nc"><img src="../Images/3af84a53131fb6261652894ca8ac476f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7xb1dQeup5rq42tAI52FpQ.png"/></div></div></figure><h1 id="53c1" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">访问我们的应用程序</h1><p id="f93a" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">我们可以通过负载平衡器配置中定义的<a class="ae ks" href="http://localhost:9090" rel="noopener ugc nofollow" target="_blank"> http://localhost:9090 </a>访问我们的应用程序。</p><p id="fbff" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe nh ni nj ms b">curl -XGET localhost:9090/api</code></p><p id="d206" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">将返回<em class="mq"> 10 </em>作为响应。</p><p id="31fb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，我们可以通过以下命令更新数据</p><p id="8910" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe nh ni nj ms b">curl -XPUT localhost:9090/api?newData=34</code></p><p id="0d86" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这将启动UpdateDataEvent并在总线上发布。</p><p id="10a8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们将看到每个应用程序的以下日志行:</p><pre class="mk ml mm mn gt mr ms mt mu aw mv bi"><span id="0cbd" class="mw li iq ms b gy mx my l mz na">service1_1  | 2020-06-28 21:56:39.211  INFO 1 --- [nio-8080-exec-2] o.i.lbsandbox.UpdateDataEventListener    : event received<br/>service3_1  | 2020-06-28 21:56:39.214  INFO 1 --- [dmTIOj1L6CsEQ-1] o.i.lbsandbox.UpdateDataEventListener    : event received<br/>service2_1  | 2020-06-28 21:56:39.219  INFO 1 --- [8SvK26XvYyeAg-1] o.i.lbsandbox.UpdateDataEventListener    : event received</span></pre><p id="0764" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这意味着我们发布的事件被每个实例接收。现在我们可以通过相同的旋度再次检查我们的数据。</p><p id="2c18" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe nh ni nj ms b">curl -XGET localhost:9090/api</code></p><p id="d41f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这里我们将看到响应为<em class="mq"> 34 </em></p><h1 id="345b" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">结论</h1><p id="c98b" class="pw-post-body-paragraph ju jv iq jw b jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">在这个例子中，我们已经为Spring Cloud Bus配置了我们的应用程序，并与RabbitMQ消息代理进行了集成。通过这种集成，我们能够向应用程序实例发送定制事件，并更新实例。你可以在这里访问源代码<a class="ae ks" href="https://github.com/itasyurt/lbsandbox/tree/cloud-bus-example" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="7312" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请注意，自定义事件对于特别管理操作来说非常方便，但是尝试管理应用程序配置，这不是最好的方法。Spring的Config Server为应用配置管理提供了更方便的媒介。</p></div></div>    
</body>
</html>