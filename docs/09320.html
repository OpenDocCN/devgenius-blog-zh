<html>
<head>
<title>SwiftUI Tutorial: Creating Full Screen Modal</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI 教程:创建全屏模式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/swiftui-tutorial-creating-full-screen-modal-ada38f6360ae?source=collection_archive---------5-----------------------#2022-08-14">https://blog.devgenius.io/swiftui-tutorial-creating-full-screen-modal-ada38f6360ae?source=collection_archive---------5-----------------------#2022-08-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7fc3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何在 SwiftUI 中使用 fullScreenCover</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/175a0e54022a49b3ae0a9b473a3c6393.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tAcw6RPzL60DrnCsGeSgAQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图一。</figcaption></figure><p id="d509" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">模态是在当前视图上显示为覆盖或弹出的视图。在 SwiftUI 中，我们基本上为模态使用了一个<a class="ae lr" href="https://medium.com/dev-genius/swiftui-tutorial-working-with-sheet-6c9b97822e10" rel="noopener"> sheet </a>修饰符，这实际上提供了开发人员需要的一般功能。</p><p id="f46f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是对于覆盖整个屏幕的模态，有一个为它构建的修改器，叫做<em class="ls"> fullScreenCover </em>，可以在<strong class="kx ir"> iOS14 </strong>和更高版本上获得。</p><p id="465a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本教程中，我们将创建一个简单的应用程序，当按钮被按下时，它将弹出一个全屏模式视图。新视图接受也出现在主视图中的文本。用户界面类似于下面的图 2 和图 3。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/657c0d558672d3afedc10a0668074054.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/format:webp/1*zw1auaR16-9JykxtWNrP0A.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图二。主视图</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/6d5f8fae3b1644fbae52c54da0aa5941.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/1*mmvRU_IZq7aicSkN1JrNWw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图 3。全屏模式</figcaption></figure><p id="c45e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以让我们开始创建一个<a class="ae lr" href="https://medium.com/dev-genius/introduction-to-swiftui-creating-new-project-9adc502e1804" rel="noopener">新的</a> SwiftUI 项目。</p><p id="68aa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，让我们设置主视图。像这样编辑内容视图:</p><pre class="kg kh ki kj gt lv lw lx ly aw lz bi"><span id="e38e" class="ma mb iq lw b gy mc md l me mf">struct ContentView: View {<br/><br/>    @State private var mainText: String = ""<br/><br/>    var body: some View {<br/><br/>        ZStack {<br/><br/>            ScrollView {<br/>                <br/>                Text(mainText)<br/>                    .padding()<br/>                <br/>            } // ScrollView<br/><br/>        } // ZStack<br/><br/>    } // body<br/><br/>} // ContentView</span></pre><p id="7cbe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，主视图将保存一个从 modal 编写的可滚动的<a class="ae lr" rel="noopener ugc nofollow" target="_blank" href="/swiftui-tutorial-working-with-text-15de81494a07">文本</a>。</p><p id="c3fe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来我们需要的是一个<a class="ae lr" rel="noopener ugc nofollow" target="_blank" href="/swiftui-tutorial-working-with-text-15de81494a07">浮动动作按钮</a>,点击它会让全屏模式出现。在 ContentView 之外编写以下代码:</p><pre class="kg kh ki kj gt lv lw lx ly aw lz bi"><span id="8cab" class="ma mb iq lw b gy mc md l me mf">struct NewNoteButton: View {<br/>    <br/>    var action: () -&gt; Void<br/>    <br/>    var body: some View {<br/>        <br/>        Button(action: action) {<br/>            Image(systemName: "square.and.pencil")<br/>                .resizable()<br/>                .scaledToFill()<br/>                .frame(width: 50, height: 50)<br/>                .padding(30)<br/>        }<br/>        .background(.blue)<br/>        .foregroundColor(.white)<br/>        .cornerRadius(.infinity)<br/>        .padding()<br/>        <br/>    } // body<br/>    <br/>} // newNoteButton</span></pre><p id="794f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后将新创建的按钮放在 ZStack 内的 ContentView 中，就在 ScrollView 的下面，如下所示:</p><pre class="kg kh ki kj gt lv lw lx ly aw lz bi"><span id="fb27" class="ma mb iq lw b gy mc md l me mf">struct ContentView: View {<br/><br/>    @State private var mainText: String = ""<br/><br/>    var body: some View {<br/><br/>        ZStack {<br/><br/>            ScrollView {<br/>                <br/>                Text(mainText)<br/>                    .padding()<br/>                <br/>            } // ScrollView<br/>            <br/>            NewNoteButton {}<br/><br/>        } // ZStack<br/><br/>    } // body<br/><br/>} // ContentView</span></pre><p id="e65a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">查看 canvass，您会注意到按钮位于中间，看起来不像图 2 中所示的按钮。我们可以通过修改 ZStack 的对齐方式快速解决这个问题，如下所示:</p><pre class="kg kh ki kj gt lv lw lx ly aw lz bi"><span id="f49c" class="ma mb iq lw b gy mc md l me mf">ZStack(alignment: .bottom)</span></pre><p id="7777" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在看起来和设计上的一模一样。</p><h1 id="ed09" class="mg mb iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">使用全屏覆盖</h1><p id="2306" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">fullScreenCover 修改器的工作原理与 sheet 相同。它需要一个绑定的状态变量，这样你就可以控制它是否存在。在 ContentView 中添加此变量:</p><pre class="kg kh ki kj gt lv lw lx ly aw lz bi"><span id="3741" class="ma mb iq lw b gy mc md l me mf">@State private var isPresented: Bool = false</span></pre><p id="61fa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后将修改器附着到视图。将 fullScreenCover 修饰符放置到 ContentView 的 ZStack，如下所示:</p><pre class="kg kh ki kj gt lv lw lx ly aw lz bi"><span id="5837" class="ma mb iq lw b gy mc md l me mf">.fullScreenCover(isPresented: $isPresented) {}</span></pre><p id="f7e9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在修改器已经准备好了，是时候创建外部全屏模式视图了。在 ContentView 之外编写以下代码:</p><pre class="kg kh ki kj gt lv lw lx ly aw lz bi"><span id="93a1" class="ma mb iq lw b gy mc md l me mf">struct FullScreenModalView: View {<br/>    <br/>    @Binding var mainText: String<br/>    <br/>    var body: some View {<br/>        <br/>        VStack {<br/>            <br/>            TextEditor(text: $mainText)<br/>                .padding(.horizontal)<br/>            <br/>        } // VStack<br/>        <br/>    } // body<br/>    <br/>} // FullScreenModalView</span></pre><p id="c2d8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以上面的视图有一个<a class="ae lr" rel="noopener ugc nofollow" target="_blank" href="/swiftui-tutorial-working-with-texteditor-a059eb899084">文本编辑器</a>，我们将<a class="ae lr" href="https://medium.com/geekculture/swiftui-tutorial-state-and-binding-b7e80b4de622" rel="noopener">把它的字符串</a>绑定到内容视图。</p><p id="5485" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">将新视图作为 fullScreenCover 的内容，如下所示:</p><pre class="kg kh ki kj gt lv lw lx ly aw lz bi"><span id="d9b8" class="ma mb iq lw b gy mc md l me mf">.fullScreenCover(isPresented: $isPresented) {<br/>    FullScreenModalView(mainText: $mainText)<br/>}</span></pre><p id="d39d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">剩下要做的事情是改变 isPresented 的状态，使全屏模式出现。将此操作放在 NewNoteButton 中，如下所示:</p><pre class="kg kh ki kj gt lv lw lx ly aw lz bi"><span id="5d4d" class="ma mb iq lw b gy mc md l me mf">NewNoteButton {<br/>    isPresented.toggle()<br/>}</span></pre><p id="1749" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你迷路了，这里有一个代码截图:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/c676f39f6b0e46c703d91aacefccee66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qz6gCF-48MONlmPXacccgw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图 4。内容视图源代码</figcaption></figure><p id="e66f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们通过运行程序并点击浮动操作按钮来进行测试。轻按时，应该会出现一个新视图。</p><h1 id="1351" class="mg mb iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">画龙点睛</h1><p id="a23f" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">好吧，我知道 UI 看起来不完全像图 3 中的那个，我们没有办法关闭弹出的模态。那是因为我们还没有完成。</p><p id="1bfc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在 FullScreenModalView 上添加带有“完成”按钮的标题。像这样编辑它:</p><pre class="kg kh ki kj gt lv lw lx ly aw lz bi"><span id="f29d" class="ma mb iq lw b gy mc md l me mf">struct FullScreenModalView: View {<br/>    <br/>    @Binding var mainText: String<br/>    <br/>    var body: some View {<br/>        <br/>        VStack {<br/>            <br/>            HStack {<br/>                <br/>                Spacer()<br/>                <br/>                Button(action: {<br/>                    <br/>                }) {<br/>                    Text("Done")<br/>                        .foregroundColor(Color.white)<br/>                }<br/>                .padding()<br/>                <br/>            } // HStack<br/>            .background(Color.blue)<br/>            <br/>            TextEditor(text: $mainText)<br/>                .padding(.horizontal)<br/>            <br/>        } // VStack<br/>        <br/>    } // body<br/>    <br/>} // FullScreenModalView</span></pre><p id="7bbe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在视图看起来如图 3 所示。</p><p id="4dbd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于 Done 按钮，我们将在它上面放置一个解除动作，点击它将关闭整个视图。首先创建一个包装在解散属性中的变量，如下所示:</p><pre class="kg kh ki kj gt lv lw lx ly aw lz bi"><span id="fec2" class="ma mb iq lw b gy mc md l me mf">@Environment(\.dismiss) var dismiss</span></pre><p id="af17" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后简单地将消除功能放在按钮动作上，如下所示:</p><pre class="kg kh ki kj gt lv lw lx ly aw lz bi"><span id="0093" class="ma mb iq lw b gy mc md l me mf">Button(action: {<br/>    dismiss()<br/>}) {<br/>    Text("Done")<br/>        .foregroundColor(Color.white)<br/>}<br/>.padding()</span></pre><p id="d721" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是全部源代码的截图，以防你迷路。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/95f71fa8aeca7d4cd8ff6bd74d98bf58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jfMUeoIXhbBWmDa8Do46JA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图 5。FullScreenModalView 源代码</figcaption></figure><p id="f01a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">注:</strong> \。解除仅适用于 iOS15 及以上版本。这里有一个替代方案。</p><pre class="kg kh ki kj gt lv lw lx ly aw lz bi"><span id="b126" class="ma mb iq lw b gy mc md l me mf">@Environment(\.presentationMode) var presentationMode</span></pre><p id="e974" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后你需要像这样调用整个 wrappedValue。</p><pre class="kg kh ki kj gt lv lw lx ly aw lz bi"><span id="f823" class="ma mb iq lw b gy mc md l me mf">Button(action: {<br/>    presentationMode.wrappedValue.dismiss()<br/>}) {<br/>    Text("Done")<br/>        .foregroundColor(Color.white)<br/>}<br/>.padding()</span></pre><p id="5cd8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是使用<em class="ls">演示模式</em>的截图。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/b83eaf9e17e478016bb2f6365ad2ee7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qB2_D9GwKo3WsMoRJcs3eg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图 6。iOS14 及以下版本的 FullScreenModalView 源代码</figcaption></figure><p id="d013" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们期待已久的时刻。运行应用程序，并尝试在模式中键入语句。它应该会出现在主视图上。干得好。</p><p id="8cfb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里是源代码的 github <a class="ae lr" href="https://github.com/athurion/SwiftUI-Tutorial-Creating-Full-Screen-Modal/blob/main/ContentViewFullScreenCover.swift" rel="noopener ugc nofollow" target="_blank">链接</a>。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="530c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">愿法典与你同在，</p><p id="b86b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">-电弧</p></div></div>    
</body>
</html>