<html>
<head>
<title>React Performance Optimization Tips</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应性能优化技巧</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/react-performance-optimization-tips-6f93715b9515?source=collection_archive---------23-----------------------#2022-07-04">https://blog.devgenius.io/react-performance-optimization-tips-6f93715b9515?source=collection_archive---------23-----------------------#2022-07-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="6e87" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi ki translated">更好的用户体验是你第一眼看到 web 应用时所期望的第一件事。因此，优化应用程序在提高用户体验和性能方面取得了巨大的进步。</p><p id="5b5e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本指南将详细介绍在 react profiler 的帮助下优化 React 应用程序的技巧。React Developer tools 是我们添加到浏览器中的一个扩展，用于记录 React 组件是如何加载的。您可以从这些链接中添加适合您的浏览器的扩展名。</p><ul class=""><li id="807d" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated"><a class="ae la" href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en" rel="noopener ugc nofollow" target="_blank"> React 谷歌浏览器开发工具(链接)</a></li><li id="8c60" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">【Firefox 的 React 开发工具(链接)</li></ul><h1 id="1c69" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">提示 1:确定父组件中子组件的优先级</h1><p id="22aa" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">理想情况下，在 react 应用程序中，如果父组件的状态发生变化，父组件及其子组件都将被重新呈现，但有时，如果我们考虑它的使用和它所花费的时间，这并不是一件好事。</p><p id="5025" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们举一个简单的例子，如果父组件由两个子组件组成，但是您只对父组件进行了更改。在这里，所有的子组件都将与任何后端 API 调用一起被重新呈现。这将增加延迟，需要一些时间来加载屏幕。看一下下面的示例代码，</p><figure class="mj mk ml mm gt mn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/693e777a5cf624ff4551707e0cb9361c.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*38AbtCi7E3clal4wt6i3WQ.png"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">图 1:用户界面</figcaption></figure><div class="mj mk ml mm gt ab cb"><figure class="mx mn my mz na nb nc paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><img src="../Images/9359a95a31bfc725b5c9a897ae3ffc20.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/1*9seiTBHmOVLHn6E3Sg8k4w.png"/></div></figure><figure class="mx mn nh mz na nb nc paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><img src="../Images/5efef75e38596f05f749ea9cee09ba67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*NrYk65anvCOfuu3a06oOtg.png"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk ni di nj nk translated">图 2:控制台日志-第一次加载应用程序时(左)|在输入框中键入文本时(右)</figcaption></figure></div><p id="e7d7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，你可以看到每次在文本框中输入一个字母时，父组件都会被渲染，同时子组件也会被重新渲染。</p><p id="e721" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们看看如何使用 React Profiler 以一种详细的方式可视化这个场景。</p><p id="bccb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">转到浏览器开发工具中的 Profiler 选项卡。您可以使用以下命令在 React 探查器中开始探查🔵图标，开始在文本框中键入一个字母，然后单击🔴图标停止分析。</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nl"><img src="../Images/a0886349eb0b39b484861249c19123ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*chXRW1Ut58Np52IlMvu_6g.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">图 3:反应分析器结果</figcaption></figure><p id="ca1f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，我们可以清楚地看到在右边，这个应用程序的总渲染持续时间为 13 毫秒。但是这也包括加载两个子组件所花费的时间。所以基于加载的优先级，我们可以如下重构应用程序中的组件。</p><figure class="mj mk ml mm gt mn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="9f57" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，当我们隔离代码中的三个组件并移除不需要的重新渲染时，我们可以看到应用程序的性能显著提高。</p><p id="402c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">react 探查器确认如下，</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nm"><img src="../Images/3aed049d4d3045a6ce83a3cf0e6fec5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1T35iwVTu5ImUvZ-noKGEA.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">图 3:重构后的 React Profiler 结果</figcaption></figure><p id="5a71" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">与前面代码的 13 毫秒相比，现在的总渲染持续时间是 3 毫秒。这里最有趣的部分是子组件没有用父组件重新渲染，但用户界面与前面的示例相同。</p><p id="a85a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们在子组件中有非常耗时的后端 API 调用，我们可以使用这个简单的技术节省很多时间。</p><p id="82c0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，通过以这种方式对组件进行优先级排序和重构，我们可以在不损害用户界面的情况下获得更好的性能，如上例所述。</p></div></div>    
</body>
</html>