<html>
<head>
<title>Clean Architecture — C. Martin (Uncle Bob)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">干净的建筑——c·马丁(鲍勃叔叔)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/clean-architecture-c-martin-uncle-bob-5a7a17e4fadb?source=collection_archive---------2-----------------------#2022-01-27">https://blog.devgenius.io/clean-architecture-c-martin-uncle-bob-5a7a17e4fadb?source=collection_archive---------2-----------------------#2022-01-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0c99" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">#初学者架构指南</h2></div><p id="3b22" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">架构是一种系统设计，它将组件分解成独立的部分。工程师可以轻松实现他们的目标。</p><p id="b1b4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">clean architecture 的目标是找到更好的软件，如可维护的、可测试的、易于使用的、可伸缩的等等——这是工程师的准确指南。</p><p id="4aa6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">干净架构的目标是得到更好的软件，比如可维护的、可测试的、易于使用的、可伸缩的等等。建筑是工程师的正确指南。如果你是初学者，会帮助你找到目标，你可以有一个基本的思路。</p><h1 id="59df" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">洁净建筑的解释？</h1><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lt"><img src="../Images/76080b31c8b1ffed64f29a6d4e392e0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B7LkQDyDqLN3rRSrNYkETA.jpeg"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">图片来源:<a class="ae mj" href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html" rel="noopener ugc nofollow" target="_blank">罗伯特·c·马丁的博客</a></figcaption></figure><p id="df95" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种错觉非常好地覆盖了建筑，我们来看看解释。清洁建筑是由罗伯特·c·马丁的博客在 2012 年创建的。</p><p id="4f1f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里是我们的领域和实体的中心。这是我们生意的规则。</p><p id="5b18" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是在外部案例中使用的应用程序，以及它如何被称为实体。<br/>然后在下一个层面，如果你正在做一些像 MVC 或网关或用户界面演示器，我们有一个控制器。在顶层，如果你创建一个 web 应用程序，它在这里和 UI 框架。</p><h1 id="2c8b" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">依赖性规则</h1><p id="541b" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">在这个架构中，主要的规则是依赖规则。你可以在这个错觉中看到这些箭头。这里，这些箭头指向内部，这意味着外层可以指向层的内部，而内层不能指向外层。而内层对外层一无所知。</p><h1 id="3afb" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">它是如何工作的？</h1><p id="a907" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">干净的架构把核心放在中心。这意味着业务逻辑和应用程序模型都处于中心位置。</p><p id="27aa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是核心必须独立于附加数据，所以我们颠倒了依赖关系。<br/>这是通过添加核心接口和应用它的外层实现的。</p><h1 id="f8d7" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">为什么我们需要干净的架构:</h1><ul class=""><li id="c66e" class="mp mq iq kh b ki mk kl ml ko mr ks ms kw mt la mu mv mw mx bi translated">独立于框架。</li><li id="331e" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated">独立于数据库。</li><li id="6c23" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated">独立于 Ui。</li><li id="5170" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated">可测试。</li><li id="5125" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated">独立于任何外部机构。</li><li id="88b1" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated">最佳结果</li></ul><h1 id="edf8" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">关于图层的说明:</h1><p id="3650" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">你的应用程序主要有三层:</p><ul class=""><li id="1acf" class="mp mq iq kh b ki kj kl km ko nd ks ne kw nf la mu mv mw mx bi translated">表示层:视图模型、表示器实现、适配器。</li><li id="18e4" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated">领域层:用例或回调和存储库的接口。</li><li id="0ccf" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated">数据层:数据库、UI、存储和网络。实体存储库实现和业务逻辑。</li></ul><p id="b486" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">现在让我讨论一下三层。</strong></p><h2 id="041d" class="ng lc iq bd ld nh ni dn lh nj nk dp ll ko nl nm ln ks nn no lp kw np nq lr nr bi translated">演示文稿:</h2><p id="3521" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">该层应用不带参数的 UI。这一层在内部应用架构，它连接到一切。</p><h2 id="dc22" class="ng lc iq bd ld nh ni dn lh nj nk dp ll ko nl nm ln ks nn no lp kw np nq lr nr bi translated">数据层:</h2><p id="76cc" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">在数据层，我们有一个实体存储室改造其他业务项目</p><p id="38c8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但我见过一些人认为实体是在域级别下创建的。但是不要因为我们的 MVVM 而跟它走，因为它可能会在后面发生逆转。</p><p id="0b87" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，每当您实施存储或使用其他东西时，您都会创建它。</p><h2 id="7868" class="ng lc iq bd ld nh ni dn lh nj nk dp ll ko nl nm ln ks nn no lp kw np nq lr nr bi translated">域层:</h2><p id="5c07" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">在这个层面上，你的业务是有逻辑的。顶层代码停留在核心层。由于类和对象是在应用程序中运行的，因此不了解这一级别的类和对象。这一层将数据层连接到表示层。</p><p id="4179" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">领域层将是存储库的用例回调和接口。所以我们可以称之为特定的储存库。</p><h1 id="3294" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">使用案例:</h1><p id="7bec" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">这一层包含特定的应用程序业务规则。这一层实现了所有的用途。这一层改变时不能影响实体层，外层也不能影响。但是如果这个用例改变了，那么这一层的一些代码就会受到影响。</p><h1 id="5ead" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">清洁建筑的另外两个概念:</h1><p id="7c20" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">干净架构的许多特性共同决定了什么是干净架构。但是在这里我要和你们分享两个概念:</p><ul class=""><li id="e8d6" class="mp mq iq kh b ki kj kl km ko nd ks ne kw nf la mu mv mw mx bi translated">易测性</li><li id="ef78" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated">关注点分离</li></ul><p id="6f5c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可测试性是分离部分的一个关注点。因为为了可测试，你想把事情分开。</p><p id="0d49" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们利用了对分离的关注，所以你这样做是为了让它可以测试。这两件事是不可抗拒的最重要的事情。</p><p id="387a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">分离是指将应用程序的不同部分分离成自给自足的元素。</p><p id="ae4d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里的基本思想是自给自足。如果我们看建筑，它会像一个轻的例子。</p><p id="35be" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 UI 中，有一些业务逻辑，将信息从存储库移动到活动或片段中，这就是视图模型。然后，您有了自己的存储，它指的是您的远程数据源。</p><p id="d8a8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些都被定义为不同的应用程序组件，您可以将它们换成不同的东西。在您换出之后，您只需运行所有的测试，所有的测试都会通过，即使您换出了其中的一个组件。</p><h1 id="4566" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">最后的话</h1><p id="5051" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">能看到<a class="ae mj" href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir">鲍勃大叔的干净建筑</strong> </a>就好了。稍微注意一下，就会得到基础知识。干净的架构是好的应用程序的基础。如果您不了解任何体系结构，那么您的应用程序就没有好的计划。</p><p id="8d71" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，干净的架构给你一个实现高质量应用程序的清晰思路。所以不熟悉的就去看看吧。</p><p id="c729" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>