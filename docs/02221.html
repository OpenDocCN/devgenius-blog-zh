<html>
<head>
<title>Nude Models — Part II : Getters</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">裸体模特第二部分:吸气剂</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/nude-models-part-ii-getters-b039e5ad3427?source=collection_archive---------3-----------------------#2020-07-24">https://blog.devgenius.io/nude-models-part-ii-getters-b039e5ad3427?source=collection_archive---------3-----------------------#2020-07-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="42f7" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">可靠的数据结构及其有争议的(读)访问。</h2></div><p id="c169" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用对象作为数据结构是一种已确立的实践，它产生了许多与软件的可维护性和发展相关的问题。它误用了 50 年前提出的杰出概念。在这第二部分我们将反思对 <strong class="ke io"> <em class="ky">阅读</em> </strong> <em class="ky">这些对象的访问。</em></p><p id="12f8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本文的第一部分中，我们展示了从数据结构中的隐藏信息到活动对象职责(本质的<strong class="ke io">什么</strong>)隐藏实现(偶然的<strong class="ke io">如何</strong>)的转换。</p><div class="kz la gp gr lb lc"><a href="https://medium.com/dev-genius/nude-models-part-i-setters-77ac784a91f3" rel="noopener follow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd io gy z fp lh fr fs li fu fw im bi translated">裸体模特第一部分:模特</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">旧的可靠数据结构及其有争议的(写)访问。</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">medium.com</p></div></div><div class="ll l"><div class="lm l ln lo lp ll lq lr lc"/></div></div></a></div><p id="0458" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在第二部分中，我们将展示使用<em class="ky"> getters </em>的缺点。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="ab gu cl lx"><img src="../Images/6d573769821198e360beeab658509352.png" data-original-src="https://miro.medium.com/v2/format:webp/1*Op8H4yaK4L_DfwGua5jfWA.jpeg"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">照片由<a class="ae md" href="https://unsplash.com/@dominik_photography?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">张秀坤·万尼</a>在<a class="ae md" href="https://unsplash.com/s/photos/mining?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="c41c" class="me mf in bd mg mh mi mj mk ml mm mn mo jt mp ju mq jw mr jx ms jz mt ka mu mv bi translated">现实世界中不存在的名字(重复)</h1><p id="04e9" class="pw-post-body-paragraph kc kd in ke b kf mw jo kh ki mx jr kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated">程序员习惯上使用<strong class="ke io"><em class="ky">get attribute……()</em></strong>形式的名称来公开(并失去对)一个先前私有的属性。由于 setter 的<a class="ae md" href="https://medium.com/dise%C3%B1o-de-software/information-showing-chapter-i-setters-138deb558e5d" rel="noopener">文章</a>中陈述的相同论点，这个名字不能通过<a class="ae md" href="https://codeburst.io/the-one-and-only-software-design-principle-5328420712af" rel="noopener" target="_blank"><strong class="ke io"/></a>双射<a class="ae md" href="https://codeburst.io/what-is-software-9a78c1172cf9" rel="noopener" target="_blank"> <strong class="ke io">映射</strong> </a> <strong class="ke io"> </strong>到现实世界中的对等物。</p><p id="4eb6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">关于这些名字的最终结论是:</p><blockquote class="nb"><p id="be42" class="nc nd in bd ne nf ng nh ni nj nk kx dk translated">不应有 setAttribute…()或 getAttribute…()形式的方法</p></blockquote><h1 id="696d" class="me mf in bd mg mh mi mj mk ml mm mn mo jt nl ju mq jw nm jx ms jz nn ka mu mv bi translated">不要公开集合</h1><p id="91a6" class="pw-post-body-paragraph kc kd in ke b kf mw jo kh ki mx jr kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated">许多对象管理集合。内容管理、不变量或遍历方法应该是这些对象的唯一职责。</p><p id="5cf6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设我们想在画布上绘制第一部分中呈现的多边形<a class="ae md" href="https://medium.com/dev-genius/nude-models-part-i-setters-77ac784a91f3" rel="noopener">。我们将用下面的代码来实现它:</a></p><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">绘制多边形</figcaption></figure><p id="2da1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通过暴露顶点集合(因为在大多数语言中集合是通过引用传递的<a class="ae md" href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_reference" rel="noopener ugc nofollow" target="_blank">),我们失去了对集合的控制。</a></p><p id="6b0b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">没有什么可以阻止其他代码运行:</p><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">array_shift()从数组中移除第一个值</figcaption></figure><p id="cd7b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这导致三角形变异，产生不一致的真实世界双射。双面多边形会违反闭合图形的原则。</p><p id="8d96" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个缺陷会在很久以后才被注意到，因为没有被及时发现，因此违反了 fail fast 原则。</p><div class="kz la gp gr lb lc"><a href="https://codeburst.io/fail-fast-3f3f036032b0" rel="noopener follow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd io gy z fp lh fr fs li fu fw im bi translated">快速失败</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">失败是时尚。制造比思考容易得多，失败不是耻辱，让我们把这个想法带到我们的…</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">codeburst.io</p></div></div><div class="ll l"><div class="nq l ln lo lp ll lq lr lc"/></div></div></a></div><blockquote class="nr ns nt"><p id="a5ce" class="kc kd ky ke b kf kg jo kh ki kj jr kk nu km kn ko nv kq kr ks nw ku kv kw kx ig bi translated">在任何情况下，这些物品都不应该暴露它们的收藏，因此执行<a class="ae md" href="https://en.wikipedia.org/wiki/Law_of_Demeter" rel="noopener ugc nofollow" target="_blank">得墨忒耳定律。</a></p></blockquote><p id="d3fd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">万一需要归还收集到的元素，要用副本(<a class="ae md" href="https://en.wikipedia.org/wiki/Object_copying" rel="noopener ugc nofollow" target="_blank">浅</a>)来回答，以免失控。以目前的技术水平，复制收藏品的速度非常快。如果它们是非常大的集合，那么可以使用迭代器、代理和游标来设计解决方案，以避免执行完全复制操作。</p><h2 id="26df" class="nx mf in bd mg ny nz dn mk oa ob dp mo kl oc od mq kp oe of ms kt og oh mu oi bi translated">迭代集合</h2><p id="26a7" class="pw-post-body-paragraph kc kd in ke b kf mw jo kh ki mx jr kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated">我们如何解决多边形绘制操作？</p><p id="7d7f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在使用设计模式时，迭代集合是一个众所周知的主题:</p><div class="kz la gp gr lb lc"><a href="https://en.wikipedia.org/wiki/Iterator_pattern" rel="noopener  ugc nofollow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd io gy z fp lh fr fs li fu fw im bi translated">迭代器模式</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">在面向对象编程中，迭代器模式是一种设计模式，其中迭代器用于遍历一个</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">en.wikipedia.org</p></div></div><div class="ll l"><div class="oj l ln lo lp ll lq lr lc"/></div></div></a></div><p id="ee83" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们想要遍历我们的多边形，我们可以返回一个迭代器(指示<strong class="ke io">我们需要做什么</strong>而不暴露我们的底层数据结构(<strong class="ke io">如何</strong>遍历它)。</p><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">返回迭代器允许对象改变它的表示</figcaption></figure><p id="d902" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在语言支持<a class="ae md" href="https://en.wikipedia.org/wiki/Anonymous_function" rel="noopener ugc nofollow" target="_blank">匿名函数</a>或<a class="ae md" href="https://en.wikipedia.org/wiki/Closure_(computer_programming)" rel="noopener ugc nofollow" target="_blank">闭包</a>的情况下，我们可以承担迭代元素的责任，而无需向外暴露迭代器:</p><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="2a4e" class="nx mf in bd mg ny nz dn mk oa ob dp mo kl oc od mq kp oe of ms kt og oh mu oi bi translated">变异集合</h2><p id="6b01" class="pw-post-body-paragraph kc kd in ke b kf mw jo kh ki mx jr kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated">多边形不能变异，因为顶点是它们的最小本质<strong class="ke io">的一部分</strong>:如果我们移除它们的任何顶点，它们就不再是使它们<strong class="ke io">独特的那个多边形</strong>。</p><p id="4a6b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有许多业务对象可能在其意外集合中发生变异，并且有管理这种变异的机制。</p><p id="11f5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们想要建立一个<em class="ky"> Twitter </em>账户并保留它的追随者，了解商业规则，那么这个账户是在没有追随者的情况下创建的。</p><p id="fc27" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在创建新账户时，让我们忽略它给我们的建议。</p><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="574c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用<em class="ky">设置器</em>和<em class="ky">获取器</em>，一个初学编程的人可能会想以这种方式添加一个追随者:</p><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="5137" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由业务规则指导的正确的责任分配表明，添加新的关注者、执行验证(例如，它以前没有被关注)以及保持集合完整性是帐户的责任。</p><p id="e26e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，更好的解决方案是:</p><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="acf6" class="nx mf in bd mg ny nz dn mk oa ob dp mo kl oc od mq kp oe of ms kt og oh mu oi bi translated">双重封装</h2><p id="0a53" class="pw-post-body-paragraph kc kd in ke b kf mw jo kh ki mx jr kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated">在 90 年代，有一种趋势是创建属性的双重封装作为隐私的极端方法。这意味着，即使是从一个对象的私有方法，也要避免直接访问变量。</p><p id="621f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种做法不会产生任何好处。添加不必要的间接寻址，并在没有区分<strong class="ke io">公共</strong>和<strong class="ke io">私有</strong>方法的语言中公开 setters 和 getters。</p><p id="f2f6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此外，它隐藏了属性和引用它的直接方法之间的<strong class="ke io">耦合</strong>，避免了可能的重构。</p><div class="kz la gp gr lb lc"><a href="https://codeburst.io/coupling-the-one-and-only-software-design-problem-869e293a9f04" rel="noopener follow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd io gy z fp lh fr fs li fu fw im bi translated">耦合:唯一的软件设计问题</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">对我们软件的所有故障进行根本原因分析，会发现一个有多种伪装的单一罪魁祸首。</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">codeburst.io</p></div></div><div class="ll l"><div class="ok l ln lo lp ll lq lr lc"/></div></div></a></div><h2 id="5b54" class="nx mf in bd mg ny nz dn mk oa ob dp mo kl oc od mq kp oe of ms kt og oh mu oi bi translated">告诉，不要问</h2><p id="40fb" class="pw-post-body-paragraph kc kd in ke b kf mw jo kh ki mx jr kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated">有一条<a class="ae md" href="https://www.infoworld.com/article/2073723/why-getter-and-setter-methods-are-evil.html" rel="noopener ugc nofollow" target="_blank">原则</a>规定:</p><blockquote class="nb"><p id="cfc2" class="nc nd in bd ne nf ng nh ni nj nk kx dk translated">不要询问你完成工作所需的信息；请拥有信息的对象为您工作</p></blockquote><p id="6078" class="pw-post-body-paragraph kc kd in ke b kf ol jo kh ki om jr kk kl on kn ko kp oo kr ks kt op kv kw kx ig bi translated">这个原理被称为:<a class="ae md" href="https://martinfowler.com/bliki/TellDontAsk.html" rel="noopener ugc nofollow" target="_blank">告诉，不要问</a>。</p><p id="fa65" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它提醒我们，我们应该告诉一个对象<strong class="ke io">做什么</strong>，而不是从一个对象那里请求<strong class="ke io">数据</strong>并对这些数据采取行动。这鼓励了对象负责管理的<strong class="ke io">行为</strong>和<strong class="ke io">知识</strong>的移动。</p><h2 id="81ba" class="nx mf in bd mg ny nz dn mk oa ob dp mo kl oc od mq kp oe of ms kt og oh mu oi bi translated">太多的信息会害死我们</h2><p id="0f91" class="pw-post-body-paragraph kc kd in ke b kf mw jo kh ki mx jr kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated">解释德米特里定律和最小耦合和最大内聚力定律:</p><ul class=""><li id="1264" class="oq or in ke b kf kg ki kj kl os kp ot kt ou kx ov ow ox oy bi translated">每个单元对其他单元的了解应该是有限的，只知道那些与自己密切相关的单元。</li><li id="4eb9" class="oq or in ke b kf oz ki pa kl pb kp pc kt pd kx ov ow ox oy bi translated">每个单位应该只和自己的朋友说话，不要和陌生人说话。</li><li id="d8fe" class="oq or in ke b kf oz ki pa kl pb kp pc kt pd kx ov ow ox oy bi translated">只要和你最亲近的朋友谈谈。</li></ul><p id="547e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">用<em class="ky">设置器</em>和<em class="ky">获取器</em>添加<strong class="ke io">偶然</strong>复杂性意味着产生耦合，违反这些规则，并在可能发生变化的情况下产生更大的涟漪效应。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="ab gu cl lx"><img src="../Images/86e1304a4ac82bc58d4628795870bdaf.png" data-original-src="https://miro.medium.com/v2/format:webp/1*OlyLzDB7F7LjxZr_JHqzMg.jpeg"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated"><a class="ae md" href="https://unsplash.com/@macauphotoagency?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">澳门图片社</a>在<a class="ae md" href="https://unsplash.com/s/photos/crime-scene?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h2 id="6f05" class="nx mf in bd mg ny nz dn mk oa ob dp mo kl oc od mq kp oe of ms kt og oh mu oi bi translated">Setters 和 getters 违反了拟人论</h2><p id="8e11" class="pw-post-body-paragraph kc kd in ke b kf mw jo kh ki mx jr kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated">让我们回到我们唯一的设计规则，它要求我们正在构建的模型和现实世界之间有一个<a class="ae md" href="https://codeburst.io/the-one-and-only-software-design-principle-5328420712af" rel="noopener" target="_blank">双投影</a>，并尊重<a class="ae md" href="https://en.wikipedia.org/wiki/Anthropomorphism" rel="noopener ugc nofollow" target="_blank">拟人化</a>的原则(给每个对象一个活的实体)。</p><div class="kz la gp gr lb lc"><a href="https://codeburst.io/the-one-and-only-software-design-principle-5328420712af" rel="noopener follow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd io gy z fp lh fr fs li fu fw im bi translated">唯一的软件设计原则</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">如果我们在一个单一的规则上建立我们的整个范式，我们可以保持它的简单并做出优秀的模型。</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">codeburst.io</p></div></div><div class="ll l"><div class="pe l ln lo lp ll lq lr lc"/></div></div></a></div><p id="d5b5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这样做的时候，我们会发现在对象被返回一个<em class="ky"> getter </em>后，我们赋予对象的<strong class="ke io">职责</strong>并没有<strong class="ke io">映射</strong>与现实世界中违反<a class="ae md" href="https://codeburst.io/the-one-and-only-software-design-principle-5328420712af" rel="noopener" target="_blank">双映射</a>。</p><p id="9a6a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这个<a class="ae md" href="https://www.yegor256.com/2014/09/16/getters-and-setters-are-evil.html#a-ball-and-a-dog" rel="noopener ugc nofollow" target="_blank">页面上</a>有一个使用<em class="ky"> getters </em>时不尊重拟人化的极好例子。</p><h2 id="44c6" class="nx mf in bd mg ny nz dn mk oa ob dp mo kl oc od mq kp oe of ms kt og oh mu oi bi translated">改变我们的思维方式</h2><p id="3b8a" class="pw-post-body-paragraph kc kd in ke b kf mw jo kh ki mx jr kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated">当我们开始对忘记了它们的<strong class="ke io">偶然</strong>表示的对象建模时，我们将能够避免<a class="ae md" href="https://en.wikipedia.org/wiki/Anemic_domain_model" rel="noopener ugc nofollow" target="_blank">贫血类</a>(它们只完成保存数据的功能，导致了众所周知的<a class="ae md" href="https://en.wikipedia.org/wiki/Anti-pattern" rel="noopener ugc nofollow" target="_blank">反模式</a>)。</p><p id="d3fe" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">与数据结构一样，一个贫血的类无法保证数据和关系的完整性。</p><p id="68b6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于贫血类的操作在贫血类边界的之外<strong class="ke io">，因此没有<strong class="ke io">单点控制</strong>。因此，我们将生成<strong class="ke io">重复代码</strong>和存在于我们模型中的这些属性的访问点。我们将永远追求模仿像<strong class="ke io">黑盒</strong>这样的对象的行为，得到更加真实和声明性的双射。</strong></p><div class="kz la gp gr lb lc"><a href="https://medium.com/dev-genius/code-smell-01-anemic-models-f9fb5a1323b3" rel="noopener follow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd io gy z fp lh fr fs li fu fw im bi translated">代码气味 01——贫血模型</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">你的对象是一堆没有行为的公共属性。</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">medium.com</p></div></div><div class="ll l"><div class="pf l ln lo lp ll lq lr lc"/></div></div></a></div><h1 id="21b0" class="me mf in bd mg mh mi mj mk ml mm mn mo jt mp ju mq jw mr jx ms jz mt ka mu mv bi translated">推荐</h1><ul class=""><li id="6af0" class="oq or in ke b kf mw ki mx kl pg kp ph kt pi kx ov ow ox oy bi translated">不要使用<em class="ky">设定器</em>。这样做没有充分的理由。</li><li id="2c4e" class="oq or in ke b kf oz ki pa kl pb kp pc kt pd kx ov ow ox oy bi translated">不要使用<em class="ky">吸气剂</em>。如果一个对象的任何职责与响应一个匹配属性的消息有关，那么如果我们没有<strong class="ke io">破坏封装，就要事先考虑好。</strong></li><li id="492a" class="oq or in ke b kf oz ki pa kl pb kp pc kt pd kx ov ow ox oy bi translated">不要在函数名前面加上 get 这个词。如果现实世界中的一个多边形能回答它的顶点是什么，那就用现实世界的名字(<strong class="ke io"><em class="ky">)vertices()</em></strong>)。</li><li id="9beb" class="oq or in ke b kf oz ki pa kl pb kp pc kt pd kx ov ow ox oy bi translated">在返回集合的情况下，返回一个<strong class="ke io">副本</strong>或一个<strong class="ke io">代理</strong>，以免失去控制，有利于迭代器的使用。</li><li id="fef5" class="oq or in ke b kf oz ki pa kl pb kp pc kt pd kx ov ow ox oy bi translated">没有<strong class="ke io">公共</strong>属性。实际上，它就像有<em class="ky">设置器</em>和<em class="ky">获取器</em>。这也是一个<em class="ky">码闻</em>的要死不活的对象。</li><li id="16b8" class="oq or in ke b kf oz ki pa kl pb kp pc kt pd kx ov ow ox oy bi translated">没有<strong class="ke io">公共静态</strong>属性。除了上面列出的之外，类应该是无状态的，这是一个代码气味，表明一个类正被用作全局变量。</li></ul><div class="kz la gp gr lb lc"><a href="https://codeburst.io/singleton-the-root-of-all-evil-8e59ca966243" rel="noopener follow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd io gy z fp lh fr fs li fu fw im bi translated">辛格尔顿:万恶之源</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">允许的全局变量和假定的内存节省</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">codeburst.io</p></div></div><div class="ll l"><div class="pj l ln lo lp ll lq lr lc"/></div></div></a></div><h2 id="f3a6" class="nx mf in bd mg ny nz dn mk oa ob dp mo kl oc od mq kp oe of ms kt og oh mu oi bi translated">从传统代码系统过渡</h2><p id="9e2d" class="pw-post-body-paragraph kc kd in ke b kf mw jo kh ki mx jr kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated">并非都是坏消息。通过正确的<strong class="ke io">职责重新分配，</strong>以及适当重构的帮助，将一个坏模型转换成一个好模型是可能的。</p><p id="9d3b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们有机会用<strong class="ke io">良好的覆盖率</strong>来改进系统，我们可以逐步封装对象，以一种<strong class="ke io">增量迭代的方式限制它们的访问。</strong></p><p id="0757" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在没有足够覆盖的情况下，我们将面对一个<a class="ae md" href="https://en.wikipedia.org/wiki/Legacy_code" rel="noopener ugc nofollow" target="_blank">遗留代码系统</a>，根据<a class="ae md" href="https://twitter.com/mfeathers" rel="noopener ugc nofollow" target="_blank"> Michael Feathers </a>的出色定义:</p><blockquote class="nb"><p id="8eb8" class="nc nd in bd ne nf ng nh ni nj nk kx dk translated">遗留代码系统是没有覆盖的系统。</p></blockquote><p id="8c8f" class="pw-post-body-paragraph kc kd in ke b kf ol jo kh ki om jr kk kl on kn ko kp oo kr ks kt op kv kw kx ig bi translated">如果是这种情况，我们必须<strong class="ke io">首先覆盖</strong>现有的功能，然后我们可以执行必要的转换。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="ab gu cl lx"><img src="../Images/43fb95820c36477a6a42be8a07dfb185.png" data-original-src="https://miro.medium.com/v2/format:webp/1*w2UZKkYJ6H_pzrreU4EOLg.jpeg"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">照片由<a class="ae md" href="https://unsplash.com/@greg_nunes?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">格雷格·努内斯</a>在<a class="ae md" href="https://unsplash.com/s/photos/rainbow?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="fbe4" class="me mf in bd mg mh mi mj mk ml mm mn mo jt mp ju mq jw mr jx ms jz mt ka mu mv bi translated">结论</h1><p id="ef19" class="pw-post-body-paragraph kc kd in ke b kf mw jo kh ki mx jr kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated">使用<em class="ky">设置器</em>和<em class="ky">获取器</em>的良好惯例产生<strong class="ke io">耦合</strong>并防止我们的计算机系统的<strong class="ke io">增量进化</strong>。</p><p id="7359" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">根据这篇文章中陈述的论点，我们应该尽可能地限制它们的使用。</p></div><div class="ab cl pk pl hr pm" role="separator"><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp"/></div><div class="ig ih ii ij ik"><p id="f2ee" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这一系列文章的部分目标是为软件设计的辩论和讨论提供空间。</p><div class="kz la gp gr lb lc"><a href="https://medium.com/@mcsee/object-design-checklist-47c63d351352" rel="noopener follow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd io gy z fp lh fr fs li fu fw im bi translated">目标设计清单</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">这是已经发表的软件设计文章的索引。</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">medium.com</p></div></div><div class="ll l"><div class="pr l ln lo lp ll lq lr lc"/></div></div></a></div><p id="7af8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们期待着对这篇文章的评论和建议。</p><p id="9f68" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这篇文章还有西班牙语版本<a class="ae md" href="https://medium.com/dise%C3%B1o-de-software/modelos-desnudos-parte-ii-getters-8432b8c6e4f3" rel="noopener">点击这里</a>。</p></div></div>    
</body>
</html>