<html>
<head>
<title>Software scalability from android perspective</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从 android 角度看软件可扩展性</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/software-scalability-from-android-perspective-c6ff8551b574?source=collection_archive---------27-----------------------#2020-06-11">https://blog.devgenius.io/software-scalability-from-android-perspective-c6ff8551b574?source=collection_archive---------27-----------------------#2020-06-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/05246ad71ad7eae3a2796d7230a7ceec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JaAuiT__QX0NGARYpBz3AQ.jpeg"/></div></div></figure><p id="710a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们每天都要处理成千上万行代码。而每一行都改变了我们一个个写代码的视角。在我们将代码转化为产品之前，编写代码没有任何意义。产品是可以持续很长时间的东西。为此，我们努力使我们的产品高效且可扩展。</p><p id="2e99" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从全新的角度开始编写代码。</p><blockquote class="kw kx ky"><p id="230c" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><em class="iq">为了更好地理解，我们将参考一个</em> <a class="ae ld" href="https://github.com/ashujhaji/Kotlin-MVVM-LiveData-Room" rel="noopener ugc nofollow" target="_blank"> <em class="iq">新闻应用</em> </a> <em class="iq">，还将看到一些知名应用的范例。</em></p></blockquote><p id="4e2a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的项目中有几件事应该说清楚:</p><ol class=""><li id="35f9" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated">数据加载问题。</li><li id="9791" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">数据呈现问题。</li><li id="1679" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">内存利用率。</li></ol><p id="8794" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">大多数社交网络应用程序，如脸书、Instagram、Twitter，在编写软件时很少使用 pro 方式，这使其更加可靠、易于使用和更具可扩展性。</p><p id="0ff1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下是编写代码时需要记住的几个步骤:</p><h1 id="c03b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">记忆效率</h1><p id="5ee3" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">对于面向对象的编程，我们需要创建新的对象实例，并引用它。但是在这个过程中，我们也有必要在需要的时候重用已经创建的对象。一些解决方案是单例类(Java)或对象类(Kotlin)。</p><p id="6bd7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">再来说说项目层面的同一个问题。我们不想创建一个以上的活动或片段(Android)对象的实例。为此，我们使用<a class="ae ld" href="https://developer.android.com/training/dependency-injection" rel="noopener ugc nofollow" target="_blank">依赖注入(DI) </a>。在模块化代码编写中，依赖注入扮演着重要的角色。简而言之，我们创建一个对象的实例，并在需要时注入它，而无需再次创建实例。</p><p id="cfe5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在 android 中有许多 DI 库，如<a class="ae ld" href="https://insert-koin.io/" rel="noopener ugc nofollow" target="_blank"><em class="kz">Koin</em></a><em class="kz"/>(Kotlin)<em class="kz">、</em> <a class="ae ld" href="https://square.github.io/dagger/" rel="noopener ugc nofollow" target="_blank"> <em class="kz">匕首</em> </a> <em class="kz"> </em> (Java)等<em class="kz">。</em> <a class="ae ld" href="https://github.com/ashujhaji/Kotlin-MVVM-LiveData-Room/tree/master/app/src/main/java/com/pixerapps/assignment/di" rel="noopener ugc nofollow" target="_blank">这里的</a>是我们项目中 Koin 的简单实现。</p><h1 id="96ef" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated"><strong class="ak">数据持久性</strong></h1><p id="0289" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">尽量不要等待网络响应来显示在你的应用程序中。为了解决这个问题，我们使用了一种叫做数据持久化的技术，或者更简单地说，叫做缓存。缓存是一种用来提高速度、平衡负载、提高数据检索性能等的技术。一些常用的工具有<a class="ae ld" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>等。</p><p id="4879" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">说到移动，我们称之为数据持久性。android 中有多个库，如<a class="ae ld" href="https://realm.io/" rel="noopener ugc nofollow" target="_blank"> <em class="kz">境界</em></a><em class="kz"/><a class="ae ld" href="https://developer.android.com/topic/libraries/architecture/room?gclid=EAIaIQobChMIqozwtd356QIVkH8rCh1PhQvvEAAYASAAEgJP0PD_BwE&amp;gclsrc=aw.ds" rel="noopener ugc nofollow" target="_blank"><em class="kz">房间</em> </a> <em class="kz">等。</em>我们在<a class="ae ld" href="https://github.com/ashujhaji/Kotlin-MVVM-LiveData-Room" rel="noopener ugc nofollow" target="_blank">项目</a>中使用了 Room，因为它具有生命周期意识且易于使用。对于图像缓存我们可以使用<a class="ae ld" href="https://bumptech.github.io/glide/" rel="noopener ugc nofollow" target="_blank"><em class="kz"/></a><em class="kz"/>或者<a class="ae ld" href="https://frescolib.org/" rel="noopener ugc nofollow" target="_blank"> <em class="kz">壁画</em> </a> <em class="kz">。</em></p><h1 id="bb90" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">线程安全</h1><p id="9d4b" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">让我们将操作分成两个线程，即<em class="kz">主线程</em>和<em class="kz">后台线程。</em>所有繁重的操作，如网络通话、媒体下载、长时间计算等。应该总是在后台线程上。以及诸如数据呈现、图像呈现等 UI 呈现部分。应该在主线程上。通过这样做，我们可以利用我们的 CPU，防止我们的应用程序出现 ANR(应用程序不响应)问题。</p><p id="44e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在科特林图书馆，我们有<a class="ae ld" href="https://kotlinlang.org/docs/reference/coroutines-overview.html" rel="noopener ugc nofollow" target="_blank">协同例程</a>来处理它。协同例程处理 IO 线程上的所有异步或非阻塞操作，以及主线程上的同步或阻塞操作。</p><h1 id="b8d8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">生命周期意识</h1><p id="ec45" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">对于一个应用程序来说，重要的是要有生命周期意识，以防止在旋转屏幕或在后台运行应用程序时崩溃。假设在慢速互联网上，您发送了一个网络呼叫，但由于慢速互联网，它需要一些时间来发送响应。在此期间，你退出应用程序，它现在在后台。一段时间后，应用程序得到网络响应，并试图在用户界面上呈现它。但我们的应用程序无法执行此操作，因为它目前不可见，并且已经崩溃。</p><p id="6fd5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为此，有一个 android 的生命周期感知架构组件，<a class="ae ld" href="https://developer.android.com/topic/libraries/architecture/livedata" rel="noopener ugc nofollow" target="_blank"><em class="kz"/></a><em class="kz">。</em>实时数据有一个观察器，当且仅当可以呈现时，它观察变化并将其呈现在 UI 上。</p><h1 id="a36c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">让我们编码吧——新闻应用</h1><p id="ee50" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">通过记住以上所有要点，我们为一个新闻应用程序编写了一个项目。在深入之前，我们先了解一下流程。</p><p id="0329" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在服务器上有一个数据源。我们获取它并将其存储到持久数据库(房间)中。有一个观察者在房间里观察数据。并将其呈现在屏幕上。</p><p id="bd62" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae ld" href="https://github.com/ashujhaji/Kotlin-MVVM-LiveData-Room" rel="noopener ugc nofollow" target="_blank"> <em class="kz">点击此处进入项目</em> </a></p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/14b68def3ad7f0d1170ed56509e8658b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*6eWEPyLTG4OkCbYqfSr-wA.png"/></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">建筑理解</figcaption></figure><p id="0707" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">需要理解的几点:</p><ol class=""><li id="9d5b" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated">UI 与房间交互，而不是直接与服务器交互。</li><li id="2380" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">服务器响应最初存储在 Room db 中，而不是任何列表中。</li><li id="eb0d" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">房间发出由 UI 观察的 LiveData 对象。</li><li id="f948" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">我们最初显示来自我们的持久数据库的数据，它阻止了网络调用上的应用程序的可靠性。</li></ol><p id="9e98" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢阅读这篇文章。随时询问任何问题或建议。</p><p id="98c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另请参阅:</p><p id="c93f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae ld" href="https://medium.com/@ashujha.1996/i-%EF%B8%8F-eventbus-878c8aa93662" rel="noopener"> <em class="kz">我♥️事件</em> </a></p><p id="cfd7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae ld" href="https://medium.com/@ashujha.1996/response-handler-retrofit-co-routine-378b306aa1b" rel="noopener"> <em class="kz">响应处理器(改型+协同程序)</em> </a></p></div></div>    
</body>
</html>