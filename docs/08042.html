<html>
<head>
<title>MERN Auth with Session — Part 3: Register/Login form with Auth</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MERN 会话认证第 3 部分:注册/登录表单认证</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/mern-auth-with-session-part-3-register-login-form-with-auth-af4a1f314dd1?source=collection_archive---------0-----------------------#2022-05-13">https://blog.devgenius.io/mern-auth-with-session-part-3-register-login-form-with-auth-af4a1f314dd1?source=collection_archive---------0-----------------------#2022-05-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ed0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">TL；在本教程中，我们将使用 Expressjs、Session Auth、Reactjs 和 Material UI 构建一个登录/注册表单。</strong></p><p id="c927" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是三部分中的第三部分，在这一部分中，我们将构建一个注册和登录表单，向 API 发送数据，并使用 session 对象从后端获取用户数据。</p><p id="364e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是最终代码:<a class="ae kl" href="https://github.com/gsambrotta/auth-session-mern-boilerplate" rel="noopener ugc nofollow" target="_blank">https://github.com/gsambrotta/auth-session-mern-boilerplate</a></p><p id="7d46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是第 1 部分:<a class="ae kl" href="https://medium.com/@designbygio/mern-auth-with-session-part-1-express-login-api-922cd29336a8" rel="noopener">https://medium . com/@ design bygio/mern-auth-with-session-part-1-express-log in-API-922 CD 29336 A8</a></p><p id="cf81" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是第二部分:<a class="ae kl" href="https://medium.com/@designbygio/mern-auth-with-session-part-2-session-with-mongodb-and-express-b185c17ad6f0" rel="noopener">https://medium . com/@ design bygio/mern-auth-with-session-part-2-session-with-MongoDB-and-express-b 185 c 17 ad 6 f 0</a></p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="88b6" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">会话登录是如何工作的？</h1><p id="2e9a" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">我们将构建两个表单:一个注册表单和一个登录表单。<br/>我们将使用注册表单创建一个新用户。<br/>当用户登录时，我们将调用<code class="fe lw lx ly lz b">/api/login</code>端点，这将创建一个会话对象。然后，我们将创建另一个端点<code class="fe lw lx ly lz b">/api/isAuth</code>来检查会话对象是否存在。<br/>当 React 应用程序渲染时，我们将调用这个端点。如果会话存在，我们将为用户显示一个带有欢迎消息的页面。如果没有，将显示登录和注册表单。</p><h1 id="a4fb" class="kt ku iq bd kv kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq bi translated">设置客户端</h1><p id="aace" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">我们开始建立前端项目。首先，我们转到客户端文件夹，创建一个 react 应用程序。我不是<code class="fe lw lx ly lz b"><a class="ae kl" href="https://create-react-app.dev/" rel="noopener ugc nofollow" target="_blank">create-react-app</a></code>的忠实粉丝，但对于演示和小型项目来说，我认为它真的很棒，所以我要继续使用它。</p><h2 id="1b1d" class="mf ku iq bd kv mg mh dn kz mi mj dp ld jy mk ml lh kc mm mn ll kg mo mp lp mq bi translated">代理人</h2><p id="0582" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">我们需要对我们的<code class="fe lw lx ly lz b">package.json</code> <br/>做一个小的修改。让我们添加一个<code class="fe lw lx ly lz b">proxy</code>配置，它将告诉前端后端的地址。</p><pre class="mr ms mt mu gt mv lz mw mx aw my bi"><span id="638d" class="mf ku iq lz b gy mz na l nb nc">"proxy": "http://localhost:5000"</span></pre><p id="03f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样，当我们获取 API 端点时，我们可以简单地执行<code class="fe lw lx ly lz b">/api/login</code>或<code class="fe lw lx ly lz b">api/signup</code>而不包括域。这有助于避免 CORS 警告，但我们更需要它来查看前端的 cookie。如果我们不这样做，来自后端的 cookie 将为<code class="fe lw lx ly lz b">localhost:5000</code>而不是<code class="fe lw lx ly lz b">localhost:3000</code>建立。</p><h2 id="4d4e" class="mf ku iq bd kv mg mh dn kz mi mj dp ld jy mk ml lh kc mm mn ll kg mo mp lp mq bi translated">材料用户界面设置</h2><p id="2fc6" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">我安装了<a class="ae kl" href="https://mui.com/" rel="noopener ugc nofollow" target="_blank">材质 UI </a>来更快地设计表单样式。<br/>我也安装了 MUI(材质 UI)图标，因为我想使用一些时尚的图标。如果你不在乎让你的表单漂亮或者添加图标，可以跳过这一步。</p><figure class="mr ms mt mu gt nd"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">App.js</figcaption></figure><p id="9901" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从 MUI 开始，不需要实际的设置。<br/>您可以简单地按照文档开始安装软件包，然后需要您想要使用的任何 MUI 组件。就是这样。尽管如此，还有一系列其他基本的东西可以让你的生活更轻松。</p><ul class=""><li id="2a5e" class="nk nl iq jp b jq jr ju jv jy nm kc nn kg no kk np nq nr ns bi translated">添加<strong class="jp ir"> CssBaseline </strong>。这就像一个重置的 css，它将帮助你以一个干净的风格开始</li><li id="b68e" class="nk nl iq jp b jq nt ju nu jy nv kc nw kg nx kk np nq nr ns bi translated">加一个<strong class="jp ir">主题</strong>。虽然不强制使用主题，但如果您计划更改一些样式，从颜色到小间距，强烈建议使用主题。这只会让你的生活更轻松。</li><li id="a041" class="nk nl iq jp b jq nt ju nu jy nv kc nw kg nx kk np nq nr ns bi translated">添加一个<strong class="jp ir">字体</strong>样式。</li></ul><p id="2a94" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe lw lx ly lz b">public/index.html</code>中，我将<strong class="jp ir"> Roboto </strong>字体样式包含在文档头中:</p><pre class="mr ms mt mu gt mv lz mw mx aw my bi"><span id="a84a" class="mf ku iq lz b gy mz na l nb nc">&lt;link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&amp;display=swap" /&gt;</span></pre><p id="b8d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您决定添加自己的主题，您将需要在一个对象中编写主题配置，然后在<code class="fe lw lx ly lz b">ThemeProvider</code>中使用该对象。然后你将整个应用程序包装在<code class="fe lw lx ly lz b">ThemeProvider</code>中，这样你就可以在每个子组件中使用这个主题。</p><p id="1726" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我在<code class="fe lw lx ly lz b">styles/theme.js</code>的一个单独的文件中添加了我的主题对象，然后我在<code class="fe lw lx ly lz b">app.js</code>中将它导入为<code class="fe lw lx ly lz b">theme</code>。<br/>这是我的<code class="fe lw lx ly lz b">theme.js</code>:</p><figure class="mr ms mt mu gt nd"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">主题. js</figcaption></figure><p id="c236" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在可以开始在组件中导入 MUI 组件，并查看应用的样式。</p><h2 id="677f" class="mf ku iq bd kv mg mh dn kz mi mj dp ld jy mk ml lh kc mm mn ll kg mo mp lp mq bi translated">路线设置</h2><p id="c138" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">您可能已经注意到，在<code class="fe lw lx ly lz b">app.js</code>中，我们导入了<code class="fe lw lx ly lz b">Routers</code>。让我们看看它们是什么。</p><figure class="mr ms mt mu gt nd"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">路由器. js</figcaption></figure><p id="1674" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简单地说，我们为显示登录组件的索引页面创建一个路由，然后为显示注册组件的注册页面创建另一个路由器。记得确保在<code class="fe lw lx ly lz b">App.js</code>中包含并使用 Routers.js 文件。</p><p id="f86e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，我们都设置好了，现在我们可以继续编写两个组件了。</p><h1 id="8ae6" class="kt ku iq bd kv kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq bi translated">登记表</h1><p id="b78b" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">我们前往<code class="fe lw lx ly lz b">components</code>并创建一个<code class="fe lw lx ly lz b">Signup.js</code>文件。这里是我们将要编写注册组件的地方。<br/>最终代码相当冗长，因为我添加了几个 MUI 组件来对其进行样式化，我为密码字段添加了显示/隐藏功能，并且添加了验证来对错误进行样式化。</p><p id="2aa7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我想先展示一个更精简的代码版本，只显示重要的部分，这样你就可以更容易地集成到你自己的组件中或者改变风格。该组件的完整版本将在稍后推出。</p><figure class="mr ms mt mu gt nd"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">signup.js —更精简的版本</figcaption></figure><p id="d3a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">重要零件:</p><ul class=""><li id="be02" class="nk nl iq jp b jq jr ju jv jy nm kc nn kg no kk np nq nr ns bi translated"><strong class="jp ir">堆栈组件</strong>:堆栈组件是一个 MUI 组件，其作用类似于一个表单。它有一个<code class="fe lw lx ly lz b">onSubmit</code>函数，指向自定义编写的<code class="fe lw lx ly lz b">handleSubmit</code>函数。每次提交表单时，它都会调用<code class="fe lw lx ly lz b">handleSubmit</code>函数。<br/>确保您的表单也是一个带有<code class="fe lw lx ly lz b">type="submit"</code>的提交按钮，否则表单中的数据将不会被发送。</li><li id="e90d" class="nk nl iq jp b jq nt ju nu jy nv kc nw kg nx kk np nq nr ns bi translated"><strong class="jp ir"> handleSubmit 函数</strong>:这是这个组件的核心。在这里，我们从表单中收集值，这些值之前保存在 React 状态中，我们向我们的 Express 后端<code class="fe lw lx ly lz b">/api/registration</code>发出一个 fetch <code class="fe lw lx ly lz b">POST</code>请求。然后，Express 会将新用户保存在我们的 MongoDB 上。(本教程的第 1 部分)</li><li id="42c8" class="nk nl iq jp b jq nt ju nu jy nv kc nw kg nx kk np nq nr ns bi translated"><strong class="jp ir"> handleChange 函数:</strong>这是更新输入字段所必需的。如果没有这个，我们在输入字段中写的时候将看不到变化。</li></ul><p id="6caa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是带有验证、错误消息、更多 MUI 组件和更好风格的完整代码。</p><figure class="mr ms mt mu gt nd"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">sign up . js-完整版</figcaption></figure><p id="d01e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了测试它，我们需要运行应用程序，服务器和客户端。<br/>因此，转到您的终端，在一个终端窗口中键入:</p><pre class="mr ms mt mu gt mv lz mw mx aw my bi"><span id="864b" class="mf ku iq lz b gy mz na l nb nc">$ cd client <br/>$ npm start</span></pre><p id="bd54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">而在另一个终端窗口类型中:</p><pre class="mr ms mt mu gt mv lz mw mx aw my bi"><span id="570f" class="mf ku iq lz b gy mz na l nb nc">$ cd server<br/>$ npm start</span></pre><p id="6a3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您现在应该能够在浏览器中转到<code class="fe lw lx ly lz b">localhost:3000/signup</code>并看到一个表单。如果是，请填写表单并测试它是否成功地将数据发送到后端。如果一切正常，您应该会在 MongoDb Atlas 文档中看到一个新用户。</p><h1 id="4a2a" class="kt ku iq bd kv kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq bi translated">登录表单</h1><p id="8ef1" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">像注册组件一样，我们转到<code class="fe lw lx ly lz b">components</code>并创建一个新文件:<code class="fe lw lx ly lz b">Login.js</code>。<br/>这个文件与前一个非常相似。主要区别在于我们向用户请求的信息(这里只有电子邮件和密码)以及我们将这些信息发送到的端点。<br/>同样，我将首先发布组件的精简版本，只包含重要的代码片段(表单、字段、提交按钮、获取函数和更改函数)，然后是完整的代码。</p><figure class="mr ms mt mu gt nd"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">Login.js —更精简的代码</figcaption></figure><p id="9bdc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与注册组件完全一样，这里的主要部分是:</p><ul class=""><li id="1ade" class="nk nl iq jp b jq jr ju jv jy nm kc nn kg no kk np nq nr ns bi translated">堆栈或表单组件+提交类型的按钮。当点击提交按钮时，我们在这里调用<code class="fe lw lx ly lz b">hanldeSubmit</code>函数</li><li id="6c48" class="nk nl iq jp b jq nt ju nu jy nv kc nw kg nx kk np nq nr ns bi translated">HandleSubmit 函数:这里完成了对<code class="fe lw lx ly lz b">/api/login</code>的<code class="fe lw lx ly lz b">POST</code>请求。在 Express 中，我们在数据库中搜索用户，创建用户会话并将这些信息返回给客户端。</li><li id="21c0" class="nk nl iq jp b jq nt ju nu jy nv kc nw kg nx kk np nq nr ns bi translated">HandleChange 函数:保持输入值随着用户输入的内容而更新。</li></ul><p id="f17c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里是登录组件的完整代码:</p><figure class="mr ms mt mu gt nd"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">login.js —完整版</figcaption></figure><p id="9724" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了测试它，请记住运行两个应用程序，然后打开一个浏览器窗口到<code class="fe lw lx ly lz b">localhost:3000</code>，您应该会看到登录表单。<br/>使用您之前通过注册表单创建用户时使用的相同凭证登录(确保凭证在 MongoDB 数据库中)。<br/>为了确保用户成功登录并创建会话，您应该在 web 控制台的 storage &gt; cookie 部分看到包含用户信息的<code class="fe lw lx ly lz b">session-id</code>。</p><h1 id="dccd" class="kt ku iq bd kv kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq bi translated">具有反应上下文的验证端点</h1><p id="49a0" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">这个 cookie 是<strong class="jp ir"> httpOnly </strong>，也就是说前端是看不到的。<br/>所以我们不能用它来检查用户是否登录。<br/>我们需要创建另一个端点，将会话对象返回给客户端(如果有的话)。</p><p id="a933" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们回到我们的服务器文件夹，在登录路由中，创建另一个端点来检查用户是否经过身份验证。</p><pre class="mr ms mt mu gt mv lz mw mx aw my bi"><span id="011e" class="mf ku iq lz b gy mz na l nb nc">$ cd server</span></pre><p id="ad8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后在<code class="fe lw lx ly lz b">loginRoutes.js</code>中，我们添加以下端点。<br/>这里我们检查<code class="fe lw lx ly lz b">req.session.user</code>是否存在。如果是，我们将它返回给客户端，否则我们返回一个错误。</p><figure class="mr ms mt mu gt nd"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">log in routers . js-is auth 端点</figcaption></figure><p id="1247" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了。现在我们需要在 React 应用程序中使用这条路线。<br/>我们返回<code class="fe lw lx ly lz b">client/src/App.js</code>，我们补充:</p><figure class="mr ms mt mu gt nd"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">App.js —完整文件</figcaption></figure><p id="d51f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们添加了两个主要部分:</p><ul class=""><li id="82b8" class="nk nl iq jp b jq jr ju jv jy nm kc nn kg no kk np nq nr ns bi translated">创建一个用户状态，然后获取<code class="fe lw lx ly lz b">/api/isAuth</code>并将结果保存在用户状态中。<br/>结果可以是用户的会话对象，也可以是<code class="fe lw lx ly lz b">undefined</code></li><li id="0f66" class="nk nl iq jp b jq nt ju nu jy nv kc nw kg nx kk np nq nr ns bi translated">我们添加反应上下文。我们创建一个上下文，用上下文提供者包装我们的应用程序，然后将用户会话对象作为值赋予上下文。<br/>通过这种方式我们可以很容易地从每个子组件中访问用户信息。</li></ul><p id="4db0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们可以使用<code class="fe lw lx ly lz b">routers</code>中的上下文来有条件地显示登录表单或经过验证的路由(即用户仪表板)。<br/>为了使用上下文，我们使用了<code class="fe lw lx ly lz b">useContext</code>钩子，并传入了在<code class="fe lw lx ly lz b">App.js</code>中创建的<code class="fe lw lx ly lz b">UserContext</code>。<br/>然后我们简单检查<code class="fe lw lx ly lz b">userContext</code>是否未定义。如果是，我们将显示登录/注册表单，否则我们将向用户显示欢迎消息。</p><figure class="mr ms mt mu gt nd"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">Routers.js —完整版</figcaption></figure><h1 id="fb9b" class="kt ku iq bd kv kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq bi translated">包裹</h1><p id="633b" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">现在我们终于可以使用带有持久身份验证的登录表单了。正如我们所见，认证需要几个步骤才能正常工作和有效实施。<br/>显然，对于生产产品，我们需要考虑更多细节，但我认为这是一个使用 MERN 堆栈的典型会话认证应用的良好起点。</p><p id="5429" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你觉得要做的事情太多，记得把大任务分开。确切地说，我是如何将本教程分为三个部分的，如果有必要，还可以进一步划分。慢慢来，摆弄一下代码，所有的过程很快就会清楚了。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><figure class="mr ms mt mu gt nd gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/e9d3774c03fc8200a0fb4ca3afda21ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:274/format:webp/0*4R80kL4V1jCZau_R.jpeg"/></div></figure><p id="7907" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你的学习之路需要支持吗？<a class="ae kl" href="https://www.codementor.io/@giorgiasambrotta?refer=badge" rel="noopener ugc nofollow" target="_blank">我们来聊聊导师</a></p></div></div>    
</body>
</html>