<html>
<head>
<title>How we should handle errors in NodeJS?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们应该如何处理 NodeJS 中的错误？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-we-should-handle-errors-in-nodejs-e855a32b7604?source=collection_archive---------6-----------------------#2022-01-02">https://blog.devgenius.io/how-we-should-handle-errors-in-nodejs-e855a32b7604?source=collection_archive---------6-----------------------#2022-01-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="5f24" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有时错误是可怕的，但实际上，当它们不在的时候，它们让我们的应用程序变得更好。如果我们正确处理错误，我们的前端队友会非常感激。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/c7e8d3044d9b841aba90cb5b8dd43d61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*QqjYq5Ithe_UJF1u4Dw4kA.png"/></div></figure></div><div class="ab cl kq kr hr ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="ig ih ii ij ik"><blockquote class="kx ky kz"><p id="7954" class="jk jl la jm b jn jo jp jq jr js jt ju lb jw jx jy lc ka kb kc ld ke kf kg kh ig bi translated">“今天你可以采取什么简单的行动来为你的生活带来走向成功的新动力？”托尼·罗宾斯</p></blockquote></div><div class="ab cl kq kr hr ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="ig ih ii ij ik"><h1 id="5a2d" class="le lf in bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">错误</h1><p id="787b" class="pw-post-body-paragraph jk jl in jm b jn mc jp jq jr md jt ju jv me jx jy jz mf kb kc kd mg kf kg kh ig bi translated">在 Node.js 中运行的应用程序通常会遇到四类错误:</p><ul class=""><li id="b2b0" class="mh mi in jm b jn jo jr js jv mj jz mk kd ml kh mm mn mo mp bi translated">标准 JavaScript 错误，如语法、引用、类型等。</li><li id="3b02" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated">系统错误由底层操作系统约束触发，例如试图打开不存在的文件或试图通过关闭的套接字发送数据。</li><li id="6801" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated">应用程序代码触发的用户指定的错误。</li><li id="fe46" class="mh mi in jm b jn mq jr mr jv ms jz mt kd mu kh mm mn mo mp bi translated"><code class="fe mv mw mx my b">AssertionError</code> s 是一类特殊的错误，当 Node.js 检测到不应该发生的异常逻辑违规时会触发。这些通常由<code class="fe mv mw mx my b">assert</code>模块引发。</li></ul><p id="2ea3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Node.js 引发的所有 JavaScript 和系统错误都继承自标准 JavaScript <a class="ae mz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" rel="noopener ugc nofollow" target="_blank"> &lt; Error &gt; </a>类或者是该类的实例，并且保证至少为<em class="la">提供该类上可用的属性。</em></p><p id="06a0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们的 API 中，我们将 JSON 结果返回给 process。但是当我们的应用程序出现错误时，它会返回错误消息和应用程序的堆栈树等信息。在这种情况下，用户可以了解我们的应用程序的私人信息，并将其用于不良目的。另一方面，我们的队友不明白发生了什么。因此，当错误发生时，最好发送 JSON 结果，就像我们成功的结果一样。</p><p id="2911" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在以前的文章中，我们看到了如何创建节点应用程序和文件夹结构。我们在它上面建造东西。所以如果你还没有读，是时候了。</p><p id="d0fb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们说我们的应用程序返回了成功的 JSON 结果；</p><pre class="kj kk kl km gt na my nb nc aw nd bi"><span id="5140" class="ne lf in my b gy nf ng l nh ni">{<br/>    "code": "0",<br/>    "msg": "Success",<br/>    "records": [<br/>        {<br/>            "key": "rXOajnqt",<br/>            "value": "QFKmpxRhmPPm",<br/>            "count": 2169<br/>        }<br/>    ]<br/>}</span></pre><p id="f539" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们有三把钥匙。</p><p id="5c4c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">代码；结果代码。0 表示成功。其他代码将用于错误。</p><p id="fcf7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">味精；结果的简短描述</p><p id="0a26" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">记录；该键仅出现在成功的结果中。它包含结果数据。</p><p id="466c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">细节；它发生错误情况。给出了详细的错误信息。</p><p id="ba52" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">错误示例；</p><pre class="kj kk kl km gt na my nb nc aw nd bi"><span id="1b4f" class="ne lf in my b gy nf ng l nh ni">{</span><span id="a027" class="ne lf in my b gy nj ng l nh ni">    "code": "4",</span><span id="d7e8" class="ne lf in my b gy nj ng l nh ni">    "msg": "fail",</span><span id="6f7d" class="ne lf in my b gy nj ng l nh ni">    "details": "No data found"</span><span id="1a1b" class="ne lf in my b gy nj ng l nh ni">}</span></pre><p id="884e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如你所见；code 和 msg 属性是相互的。这使我们更容易理解我们的结果，在错误的情况下，我们可以查看细节，我们可以修复问题。</p><p id="849b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们开始编码吧！</p><p id="a42b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先创建一个名为 errorHandler.js 的中间件文件</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="20db" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将触发每一个错误情况。这意味着我们可以控制错误。我们有 4 个参数；错误，请求，结果，下一个。</p><p id="3e93" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">错误参数获取我们发送的错误。这还有另一个目的，我将在本文后面提到。</p><p id="8166" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我还集成了一个记录器。记录是最重要的事情之一。然而，那是另一天的话题。</p><p id="a1af" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在第九行，我们用错误的状态指定了响应状态，如果为空，则指定默认值。在类似状态之后，给 JSON 分配一个错误消息。</p><p id="2983" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么什么会触发中间件呢？</p><p id="a187" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">两件事。未指定的终点和其他错误。</p><p id="34cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于另一个错误，<strong class="jm io"> </strong>我创建了一个名为 errors 的文件夹和 ApiError.js 文件。如果你愿意，你可以把这个文件放在脚本/实用程序中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="ba23" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们必须继承 javascript 错误类。这样，我们可以访问所有的错误。在访问错误之后，我们将使用<strong class="jm io">这个</strong>关键字来操作它。如果你不明白这些行是怎么回事，你必须学习<a class="ae mz" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object-oriented_JS" rel="noopener ugc nofollow" target="_blank"> OOP </a>。</p><p id="1ae8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们最终可以调用这个函数并返回错误。</p><p id="aad0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">用法举例；</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="4819" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个例子中；验证数据时，如果<strong class="jm io"> joi </strong>抛出错误，用 next 调用错误类。</p><p id="a757" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">对于未指定的端点</strong>返回 app.js 文件。在所有端点之后，通过使用 app.use()将应用程序级中间件绑定到 app 对象的一个实例。如果用户发送的请求与任何端点都不匹配，它将捕获请求。之后，就像任何其他错误一样，只需调用错误类。</p><pre class="kj kk kl km gt na my nb nc aw nd bi"><span id="e7a3" class="ne lf in my b gy nf ng l nh ni">//this runs if the EP is not found</span><span id="9414" class="ne lf in my b gy nj ng l nh ni">app.use((<em class="la">req</em>, <em class="la">res</em>, <em class="la">next</em>) =&gt; {</span><span id="6ae0" class="ne lf in my b gy nj ng l nh ni">next(<strong class="my io">new </strong>ApiError(`${<em class="la">req</em>.method} ${<em class="la">req</em>.path} endpoint not avaiable`, 404));</span><span id="73b6" class="ne lf in my b gy nj ng l nh ni">});</span></pre><p id="52db" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，我们必须调用 app.js 文件的错误处理程序中间件端。如果应用程序中有错误，触发错误处理器中间件，我们可以返回响应。</p><pre class="kj kk kl km gt na my nb nc aw nd bi"><span id="efed" class="ne lf in my b gy nf ng l nh ni">app.use(errorHandler);</span></pre><p id="7c73" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="la">希望你喜欢并学到了！</em>T13】</strong></p></div></div>    
</body>
</html>