<html>
<head>
<title>Custom Types Using Enums and the Factory Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用枚举和工厂模式的自定义类型</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/custom-types-using-enums-and-the-factory-pattern-2a5ee16b0f26?source=collection_archive---------1-----------------------#2021-05-14">https://blog.devgenius.io/custom-types-using-enums-and-the-factory-pattern-2a5ee16b0f26?source=collection_archive---------1-----------------------#2021-05-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="7a33" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">工厂模式让你的代码保持干净。枚举保持数据的灵活性</h2><div class=""/><p id="2f99" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">封装静态初始化数据——保持调用点和对象干净</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi ku"><img src="../Images/94137b36297178449faeeb1d7ebe6ed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SZ8bAYY8tW9UIRByQFjvsQ.jpeg"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">它们都是盒子，但是它们可能有不同的标签。你如何处理这种情况？</figcaption></figure><h1 id="e334" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">一种类型，不同的属性值</h1><p id="8b10" class="pw-post-body-paragraph jw jx iq jy b jz mi kb kc kd mj kf kg kh mk kj kk kl ml kn ko kp mm kr ks kt ij bi translated">当创建一个自定义类型时，您通常会希望创建该类型的许多实例，这些实例具有不同的初始化值。例如，如果你正在建模一辆车，你可能希望不同的车有不同数量的轮子，不同的颜色，不同的车身风格，等等…</p><p id="f30c" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">为了实现这一点，我们经常让我们的初始化器变得灵活，能够为我们正在初始化的每个属性传递我们想要的任何值。虽然这种解决方案没有任何问题，但它可能会在调用点产生大量样板代码。为了克服这一点，许多开发人员发现他们自己在初始化器中子类化并提供默认值。但这其实是个问题。你不应该仅仅为了改变一个对象的状态而子类化，这就是你通过改变那些值所做的一切。这就是工厂模式的用武之地。</p><h1 id="5cbc" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">工厂模式是什么？</h1><p id="b9cd" class="pw-post-body-paragraph jw jx iq jy b jz mi kb kc kd mj kf kg kh mk kj kk kl ml kn ko kp mm kr ks kt ij bi translated">工厂模式使用静态属性和/或方法来创建自定义类型。因此，不是创建一个完整的子类，即<code class="fe mn mo mp mq b">MyLabel: UILabel</code>,而是在主类上创建一个静态属性。</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h1 id="86e2" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">制作一个对象</h1><p id="6018" class="pw-post-body-paragraph jw jx iq jy b jz mi kb kc kd mj kf kg kh mk kj kk kl ml kn ko kp mm kr ks kt ij bi translated">让我们做一个非常简单的交通工具。您将向车辆添加功能并管理状态，因此使其成为一个类而不是一个结构。首先，继续用传统的方式。我们只是从一种类型的车辆开始，所以给init缺省值来保持调用位置的整洁。</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h2 id="0137" class="mt ll iq bd lm mu mv dn lq mw mx dp lu kh my mz ly kl na nb mc kp nc nd mg iw bi translated">启动你的引擎！🏁</h2><p id="a6f8" class="pw-post-body-paragraph jw jx iq jy b jz mi kb kc kd mj kf kg kh mk kj kk kl ml kn ko kp mm kr ks kt ij bi translated">什么都不做的交通工具是什么？让我们至少启动它！</p><p id="506a" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">为此，创建一个状态变量(<code class="fe mn mo mp mq b">isStarted</code>)、一个改变状态的简单方法<code class="fe mn mo mp mq b">turnOver</code>和一个告诉您引擎是否启动的描述(<code class="fe mn mo mp mq b">runningDescription</code>):</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="7c83" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">现在你面临的是一个非常传统的问题，它有许多解决方案。如果我想要做同样事情的不同类型的车辆呢？</p><h2 id="6b30" class="mt ll iq bd lm mu mv dn lq mw mx dp lu kh my mz ly kl na nb mc kp nc nd mg iw bi translated">添加另一辆车</h2><p id="cfca" class="pw-post-body-paragraph jw jx iq jy b jz mi kb kc kd mj kf kg kh mk kj kk kl ml kn ko kp mm kr ks kt ij bi translated">你如何处理这个问题并保持你的初始化器干净？嗯，有很多方法，但大多数都违背了这样或那样的原则…</p><p id="6ad3" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">我们可以子类化，这样我们就有了一个新的默认初始化器，用于我们新类型的车辆——但是这个车辆除了由什么组成(属性值)之外，与我们的第一个没有任何不同。我们根本没有改变功能。如果我们遵循好的实践，那么我们可能不应该选择这条路。</p><p id="229c" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">你可以改变你的初始化器，使它更加灵活。这通常是一个好的选择，但是如果你想保持你的调用位置干净，你不希望必须传递默认值来初始化一个公共对象。</p><p id="b2be" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">我们可以创建像<code class="fe mn mo mp mq b">func makeRaceCar</code>和<code class="fe mn mo mp mq b">func makeJunker</code>这样的方法，在用默认值创建实例后修改它的值，但是这很浪费。</p><h1 id="1e27" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">这就是工厂模式发挥作用的地方</h1><p id="2d46" class="pw-post-body-paragraph jw jx iq jy b jz mi kb kc kd mj kf kg kh mk kj kk kl ml kn ko kp mm kr ks kt ij bi translated">传统上处理工厂模式的方式是使用静态变量和方法来构造对象。这解决了这个问题，而不需要在初始化后子类化或(潜在地)修改实例的属性值来给它默认值。这是一个很好的模式，也是处理它的好方法，但是会产生很多样板代码，很快使我们的类变得混乱。我更喜欢另一层抽象，并且已经开始使用枚举来代替静态属性。</p><h2 id="e747" class="mt ll iq bd lm mu mv dn lq mw mx dp lu kh my mz ly kl na nb mc kp nc nd mg iw bi translated">传统的工厂模式</h2><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="0ec7" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">这开始说明使用工厂模式和许多不同静态实例的对象是如何变得拥挤的。这只是一个非常简单的类，有几个属性和两个实例。想象一下，如果这是一辆真实的汽车，有它所有的部件和基本特征，还有几个实例。</p><p id="b65c" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">通过使用枚举，我们实质上可以列出我们的类型、它们的属性和值。让我们看看如何使用枚举来减少初始化类型所需的样板代码，给你一个很好的地方来抽象你的数据，并保持你的调用点非常干净。</p><h2 id="cc48" class="mt ll iq bd lm mu mv dn lq mw mx dp lu kh my mz ly kl na nb mc kp nc nd mg iw bi translated">使用枚举的工厂模式</h2><p id="b0d9" class="pw-post-body-paragraph jw jx iq jy b jz mi kb kc kd mj kf kg kh mk kj kk kl ml kn ko kp mm kr ks kt ij bi translated">在创建第一种情况时，使用枚举比创建静态属性/方法要复杂一些。之后，它几乎和传统方法一样是样板文件，但确实给了你一些简洁的特性。</p><p id="58a4" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">我们的enum要做的第一件事是拥有rawValue类型的<code class="fe mn mo mp mq b">String</code>。您将使用该值作为车辆的名称。然后，您将使用计算的属性来确定初始化所需的其余属性的值，1个用于车轮，1个用于车身。enum中计算属性的酷之处在于，我们可以打开<code class="fe mn mo mp mq b">self</code>来决定使用什么值。</p><p id="6285" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">您可以使用default为所有(或大多数)情况提供相同的值。为<code class="fe mn mo mp mq b">wheels</code>这样做，这样以后你可以添加一辆半卡车(或任何你喜欢的东西)并给它8个轮子，而不用为剩下的情况指定4个。</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="9a14" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">现在，我们只是使用这个枚举来创建一个初始化器，我们都准备好了。您可以保留默认的初始化器，并根据您的需要创建其他的初始化器，或者您可以去掉默认的初始化器。</p><p id="fee9" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">下面是一个示例，其中保留了默认设置:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="4afe" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">当一个类型有许多公共的修改组时，工厂模式是很好的。它减少了调用点实现这些修改所需的代码量。通过使用枚举作为你的工厂，而不是静态方法/属性，你可以给你的代码提供枚举所提供的灵活性和封装性，同时保持你的调用点干净。</p><p id="679e" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">如果您仍然想要使用静态属性的好处，您也可以在您的枚举中使用静态属性:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="dba7" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">评论里见！⏬</p></div></div>    
</body>
</html>