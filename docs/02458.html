<html>
<head>
<title>Docker for Devs and Security Professionals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向开发人员和安全专业人员的 Docker</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/docker-for-devs-and-security-professionals-67fd14a75078?source=collection_archive---------11-----------------------#2020-08-05">https://blog.devgenius.io/docker-for-devs-and-security-professionals-67fd14a75078?source=collection_archive---------11-----------------------#2020-08-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/914b18270d997daf3868e69e4d51a738.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*smIF8nYZoi6VgLPc"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">卢卡·布拉沃在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="9119" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Docker 和它使之成为可能的容器已经彻底改变了软件行业，在几年内，它们作为一种工具和平台的受欢迎程度飙升，Docker 容器已经成为一种非常受欢迎的技术。在这篇博文中，我将带您了解 docker 的基本组件、架构和基本命令。</p><p id="a1bf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 1。DOCKER 是什么？</strong></p><p id="aab8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Docker 是一个基于容器的开源项目，用于将应用程序自动部署为可移植的、自给自足的容器，可以在任何类型的服务器上的任何地方运行。</p><p id="f31b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Docker 技术使用 Linux 内核和内核的特性，如 Cgroups 和 namespaces，来隔离进程，以便它们可以独立运行。</p><p id="ee11" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种独立性正是 containers 的目的所在——能够独立运行多个流程和应用，以更好地利用您的基础设施，同时保持独立系统的安全性。</p><p id="82a2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 2。什么是 DOCKER 容器？</strong></p><p id="13c7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Docker 容器映像是一个轻量级的、独立的、可执行的软件包，包括运行应用程序所需的一切:代码、运行时、系统工具、系统库和设置。</p><p id="d4d4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">容器映像在运行时成为容器，对于 Docker 容器，映像在 Docker 引擎上运行时成为容器。</p><p id="56ec" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">容器将软件从它的环境中隔离出来，并确保它统一地工作，尽管存在差异，例如在开发和阶段之间。</p><p id="0612" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 3。为什么使用容器？</strong></p><p id="2674" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">容器提供了一种逻辑打包机制，应用程序可以从运行环境中抽象出来。这种分离使得基于容器的应用程序可以轻松、一致地部署，无论目标环境是私有数据中心、公共云，甚至是开发人员的个人笔记本电脑。这使得开发人员能够创建可预测的环境，这些环境与应用程序的其余部分相隔离，并且可以在任何地方运行。</p><p id="e8ec" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从操作的角度来看，除了可移植性之外，容器还可以对资源进行更细粒度的控制，从而提高基础设施的效率，从而更好地利用计算资源。</p><p id="da39" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 4。码头工人的历史</strong></p><p id="52d2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种新的容器化方法的有趣之处在于它并不新鲜。自从 Unix 早期使用 chroot 命令以来，容器的概念就一直存在。</p><p id="5068" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">集装箱远非新品；谷歌多年来一直在使用他们自己的容器技术。其他 Linux 容器技术包括 Solaris Zones、BSD Jails 和 LXC，这些技术已经存在很多年了。</p><p id="c4bf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">1979 年:Unix V7 —引入了 chroot 系统调用，将进程及其子进程的根目录更改到文件系统中的新位置。这一进步是进程隔离的开始。</p><p id="6076" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2000 年:FreeBSD Jails——FreeBSD Jails 允许管理员将一个 FreeBSD 计算机系统划分成几个独立的较小系统——称为“Jails”</p><p id="977d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2001 年:Linux VServer —引入了一种 jail 机制，可以对计算机系统上的容器资源(文件系统、网络地址、内存)的 Linux_VS 历史进行分区。</p><p id="eded" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2004: Solaris 容器—由区域提供的系统资源控制和边界分隔</p><p id="18f1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2005 年:开放 VZ(Open Virtuozzo)——操作系统级虚拟化技术</p><p id="11a9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2006 年:流程容器——流程容器(由 Google 于 2006 年推出)旨在限制、统计和隔离一组流程的资源使用。</p><p id="925d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2008 年:LXC- LXC (Linux 容器)是第一个使用 cgroups 和 Linux 名称空间的最完整的 Linux 容器管理器实现。</p><p id="6c4e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2011 年:Warden — Warden 可以隔离任何操作系统上的环境，作为守护程序运行，并为容器管理提供 API。</p><p id="1b60" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2013 年:LMCTFY——让我为你包容它(LMC tfy)于 2013 年启动，作为谷歌容器栈的开源版本，提供 Linux 应用程序容器。</p><ul class=""><li id="c955" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">2013 年:Docker——当 Docker 在 2013 年出现时，容器大受欢迎。</li></ul><figure class="li lj lk ll gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lh"><img src="../Images/7b1074bd6673b9f1736b535919fb776e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WpPThnUEn2zfG-muz8tTLw.png"/></div></div></figure><p id="2985" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 5。容器与虚拟机</strong></p><p id="241d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">虚拟机和容器在几个方面有所不同，但主要区别是容器提供了一种虚拟化操作系统的方法，以便多个工作负载可以在单个操作系统实例上运行。通过虚拟机，硬件被虚拟化以运行多个操作系统实例。容器的速度、灵活性和可移植性使它们成为另一种帮助简化软件开发的工具。</p><figure class="li lj lk ll gt jo gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/a2b8ac730cb1e3daa5a70e979c7cb9c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*MtgbON10VYxbn7-XlJzVCA.png"/></div></figure><figure class="li lj lk ll gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ln"><img src="../Images/d0fd6103266a8d869e71610100f6d6be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LfhZXnpkYa1rhI11XI72GA.jpeg"/></div></div></figure><p id="74c6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 6。DOCKER 架构</strong></p><p id="62de" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Docker 使用客户机-服务器架构。Docker Engine 是一个客户端-服务器应用程序，具有以下主要组件:</p><p id="7669" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">服务器是一种长期运行的程序，称为守护进程(dockerd 命令)。</p><p id="91f3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一个 REST API，它指定了程序可以用来与守护进程对话并指示它做什么的接口。</p><p id="1761" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">命令行界面(CLI)客户端(docker 命令)。</p><p id="0ddd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Docker 客户机与 Docker 守护进程对话，后者负责构建、运行和分发 Docker 容器。Docker 客户机和守护进程可以在同一个系统上运行，或者您可以将 Docker 客户机连接到远程 Docker 守护进程。Docker 客户机和守护进程使用 REST API 通过 UNIX 套接字或网络接口进行通信。</p><figure class="li lj lk ll gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lo"><img src="../Images/81217522beb98c4a5cf25b2a6be862b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D5tB8CXUVHKU0mMJoq9SXg.png"/></div></div></figure><p id="5e8e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 7。码头术语</strong></p><p id="16a9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在深入研究 Docker 之前，您应该熟悉一些术语和定义</p><ul class=""><li id="40f1" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated"><strong class="kc io">容器映像</strong>包含创建容器所需的所有依赖项和信息的包。</li><li id="08dc" class="ky kz in kc b kd lp kh lq kl lr kp ls kt lt kx ld le lf lg bi translated"><strong class="kc io">容器</strong>一个 Docker 图像的实例。容器代表单个应用程序、流程或服务的运行时。</li><li id="e541" class="ky kz in kc b kd lp kh lq kl lr kp ls kt lt kx ld le lf lg bi translated"><strong class="kc io"> Dockerfile </strong>一个包含如何构建 Docker 映像的说明的文本文件。</li><li id="5a60" class="ky kz in kc b kd lp kh lq kl lr kp ls kt lt kx ld le lf lg bi translated"><strong class="kc io">存储库</strong>相关 Docker 图像的集合，用一个标记来表示图像版本。</li><li id="ace9" class="ky kz in kc b kd lp kh lq kl lr kp ls kt lt kx ld le lf lg bi translated"><strong class="kc io"> Registry </strong>提供对存储库访问的服务。</li><li id="9374" class="ky kz in kc b kd lp kh lq kl lr kp ls kt lt kx ld le lf lg bi translated">Docker Hub 一个公共注册中心，用于上传图片和使用图片。</li><li id="b730" class="ky kz in kc b kd lp kh lq kl lr kp ls kt lt kx ld le lf lg bi translated"><strong class="kc io">Docker Trusted Registry(DTR)</strong>一种 Docker 注册表服务(来自 Docker)，您可以在内部安装，以便驻留在组织的数据中心和网络中。</li><li id="9e8e" class="ky kz in kc b kd lp kh lq kl lr kp ls kt lt kx ld le lf lg bi translated"><strong class="kc io">使用元数据编写一个命令行工具和 YAML 文件格式，用于定义和运行多容器应用程序。</strong></li></ul><p id="1b4e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 8。对接命令</strong></p><p id="a48c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每个 Docker 命令都有一个基本结构</p><figure class="li lj lk ll gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lu"><img src="../Images/71f0b25ac21ca1a88c7ee21ac9d12912.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gAsT-kbdaxA0JjWCyTYeEA.png"/></div></div></figure><p id="7816" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">8.1 docker 搜索</p><p id="9032" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">用于在 Docker Hub 中搜索图像</p><ul class=""><li id="2922" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">以下示例显示名称包含“hello-world”的图像，并使用不同的搜索过滤器来调整搜索命令的输出</li></ul><pre class="li lj lk ll gt lv lw lx ly aw lz bi"><span id="5650" class="ma mb in lw b gy mc md l me mf">docker search hello-world<br/>docker search --filter stars=10 hello-world<br/>docker search --filter stars=10 --filter is-official=true hello-world</span></pre><figure class="li lj lk ll gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mg"><img src="../Images/5851fae67421ac73d40385f0b9deac7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_QDaimagX0heZemwXUfKyg.png"/></div></div></figure><p id="3153" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">8.2 码头工人拉动</p><p id="7eca" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">用于从 Docker Hub 提取图像。以下示例从 docker hub 中提取“hello-world”、ubuntu 和 alpine 图像</p><pre class="li lj lk ll gt lv lw lx ly aw lz bi"><span id="3143" class="ma mb in lw b gy mc md l me mf">docker pull hello-world<br/>docker pull ubuntu<br/>docker pull alpine:3.6</span></pre><figure class="li lj lk ll gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mh"><img src="../Images/67d05b6e8cedbac3ad65f33b8c4e466c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s9h12jc-C9DNwxDZy6Hd1w.png"/></div></div></figure><p id="5407" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">8.3 docker 图像</p><p id="8260" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">用于列出 docker 图像。以下示例列出了 docker 图像。</p><pre class="li lj lk ll gt lv lw lx ly aw lz bi"><span id="5310" class="ma mb in lw b gy mc md l me mf">docker images<br/>docker image ls</span></pre><figure class="li lj lk ll gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mh"><img src="../Images/2e034f8078f881bd2f40eb497bf83c1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zb-mx04t0NGjFReXxI12jA.png"/></div></div></figure><p id="545a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">8.4 码头运行</p><p id="47e0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">用于根据图像旋转 docker 容器。以下示例基于“Ubuntu:latest”docker 映像构建了一个名为“firstcontainer”的新容器。然后——它指示 Docker 分配一个连接到容器的 stdin 的伪 TTY；在容器中创建交互式 bash shell。</p><figure class="li lj lk ll gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mh"><img src="../Images/5239f1e10f5847ca6507d3da2f29c377.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RgLic3Hbgg1xORhT9Rw1oA.png"/></div></div></figure><p id="0286" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">8.5 docker exec</p><p id="d9e8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">用于在正在运行的容器中运行命令下面的示例旋转一个容器，并使用转义序列在不退出 shell 的情况下分离 tty，并在分离的容器上执行一个命令，以在该正在运行的容器中创建一个文件。</p><pre class="li lj lk ll gt lv lw lx ly aw lz bi"><span id="fa21" class="ma mb in lw b gy mc md l me mf">docker run -it --name exectest ubuntu:latest /bin/bash<br/>docker exec -e VAR=1 exectest bash<br/>docker exec -w /root exectest pwd<br/>docker exec exectest cat /etc/passwd</span></pre><figure class="li lj lk ll gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mh"><img src="../Images/722cf75ddcb639278bfcab3951dff1bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zdjg_w2-As7vSVYaqFecIA.png"/></div></div></figure><p id="6649" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">8.6 docker 卷</p><p id="b7e8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">用于创建、列出、删除和检查卷。以下示例显示了如何创建一个新卷，并将其挂载到新容器中的某个位置。</p><pre class="li lj lk ll gt lv lw lx ly aw lz bi"><span id="8641" class="ma mb in lw b gy mc md l me mf">docker volume create hello<br/>docker run -it --rm –name volumetest -v hello:/world alpine ash<br/>docker run -it --rm --name volumetest -v $PWD:/tmp alpine /bin/ash</span></pre><figure class="li lj lk ll gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mh"><img src="../Images/7c37b75fc57a8e8bde4fc1de005f0d1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YbwYnKX7xMl2kG49qkf1pA.png"/></div></div></figure><p id="0b59" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">8.6 docker 网络</p><p id="b7b4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">用于创建、连接、断开、列出和管理网络</p><ul class=""><li id="905c" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">以下示例显示了如何创建新网络并将其附加到容器</li></ul><pre class="li lj lk ll gt lv lw lx ly aw lz bi"><span id="ac8b" class="ma mb in lw b gy mc md l me mf">docker network create \<br/>--driver=bridge \<br/>--subnet=172.28.0.0/16 \<br/>--ip-range=172.28.5.0/24 \<br/>--gateway=172.28.5.254 \<br/>Mynetwork</span><span id="8693" class="ma mb in lw b gy mi md l me mf">docker run --rm -it --name NetworkTest --network Mynetwork alpine /bin/ash</span></pre><figure class="li lj lk ll gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mj"><img src="../Images/c4f5455a815bd768a7d553b0d2728667.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xi8Pyttj0dJvJ8cuovPOkA.png"/></div></div></figure><figure class="li lj lk ll gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mj"><img src="../Images/22d78804e667c1204014ddc4794e235f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o3Y7oGWJTcAB3AXHtNBahg.png"/></div></div></figure><p id="b380" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">8.7 码头注册</p><p id="fc77" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注册中心是一个存储和内容交付系统，包含命名的 Docker 映像，有不同的标记版本。</p><ul class=""><li id="6051" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">下面的例子显示了如何启动一个注册表容器，从我们的本地注册表推和拉图像。</li></ul><pre class="li lj lk ll gt lv lw lx ly aw lz bi"><span id="c567" class="ma mb in lw b gy mc md l me mf">docker run -d -p 5000:5000 --name registry registry:latest<br/>docker image tag alpine:3.6 localhost:5000/myfirstimage<br/>docker push localhost:5000/myfirstimage<br/>docker pull localhost:5000/myfirstimage</span></pre><figure class="li lj lk ll gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mj"><img src="../Images/a55eb9179dbb1b7d2fb2da41f4113185.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G9QsrjkCArQda2YhR5GFpQ.png"/></div></div></figure><p id="9761" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">8.8 码头建造</p><p id="df3b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">用于从 docker 文件构建映像什么是 docker 文件？</p><p id="9b97" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Dockerfile 是一个文本文档，它包含用户可以在命令行上调用的所有命令来组合一个图像。Dockerfile 本质上是带有构建指令的模板，用于构建映像。</p><figure class="li lj lk ll gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mk"><img src="../Images/c10ed8fec08adb701814afaf580e6cdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HtPAqaiAyW2t-JE1RdqUBw.png"/></div></div></figure><p id="21c0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面的例子显示了如何从我们刚刚建立的图像旋转一个容器。我们旋转容器，将端口 8080 映射到容器上的端口 80</p><figure class="li lj lk ll gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mg"><img src="../Images/0022c90be1d2b4dac033d3b45f2a6ab0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0y2rzxTbLS8k7h8JYhjUpw.png"/></div></div></figure><p id="8638" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">8.9 docker-撰写</p><p id="92e4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Compose 是一个定义和运行多容器 Docker 应用程序的工具。使用 Compose，您可以使用 YAML 文件来配置应用程序的服务。然后，只需一个命令，您就可以从您的配置中创建并启动所有服务。</p><ul class=""><li id="5def" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">以下示例显示了我们如何使用 docker-compose.yml 文件中定义的启动服务(映像、网络、卷和网络),并验证这些服务是否启动并运行。</li></ul><pre class="li lj lk ll gt lv lw lx ly aw lz bi"><span id="4931" class="ma mb in lw b gy mc md l me mf">docker-compose up -d<br/>docker ps -a<br/>docker-compose down -d</span></pre><figure class="li lj lk ll gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ml"><img src="../Images/019b6426a09ad7f12f8c93ddbb7967d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ASSlyXZRYz3ZuSmDu1Klmw.png"/></div></div></figure><figure class="li lj lk ll gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mm"><img src="../Images/b518b137009a4f0097c9dee7027b9f7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*95Baa_wiDvgHfFnjHbXQjA.png"/></div></div></figure><p id="41f6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 9。干燥</strong></p><p id="e1e5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Dry 是一个管理 Docker 容器和图像的终端应用程序。它旨在当需要在现有容器和映像上重复执行命令时，作为官方 Docker CLI 的替代，并作为从终端监控 Docker 容器的工具。</p><pre class="li lj lk ll gt lv lw lx ly aw lz bi"><span id="92b5" class="ma mb in lw b gy mc md l me mf"><strong class="lw io">Installation</strong><br/>curl -sSf https://moncho.github.io/dry/dryup.sh | sudo sh<br/>sudo chmod 755 /usr/local/bin/dry<br/>dry</span></pre><figure class="li lj lk ll gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mn"><img src="../Images/11fbf75ebb369e79ca07b800819bde56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e5sUR_dAqXNa7c9b2Dzo-g.png"/></div></div></figure><p id="b390" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 10。搬运工</strong></p><p id="8845" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Portainer 是 Docker 的开源轻量级简单管理解决方案。它允许您通过 Portainer web 用户界面轻松管理您的 Docker 主机和 Docker Swarm 集群。</p><ul class=""><li id="8c2e" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">下面的例子显示了我们如何拉动和旋转集装箱</li></ul><pre class="li lj lk ll gt lv lw lx ly aw lz bi"><span id="3a3b" class="ma mb in lw b gy mc md l me mf">docker volume create portainer_data<br/>docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data portainer/portainer</span></pre><figure class="li lj lk ll gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mj"><img src="../Images/18c8d0f15a1177ad77672ded08a2d3a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rpbOT8mtCOAJXmO1HXIkcA.png"/></div></div></figure><figure class="li lj lk ll gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mk"><img src="../Images/c3dcfd8bd19b6481085c8328bd35e998.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f25U5r2xD5qwUvDSAmgyPg.png"/></div></div></figure></div><div class="ab cl mo mp hr mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ig ih ii ij ik"><p id="1f23" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">作为这篇博文的继续，在第 2 系列中，我将讨论如何使用开源工具扫描和保护您的容器免受攻击，这些工具也可以集成到 CICD 管道中。</p></div></div>    
</body>
</html>