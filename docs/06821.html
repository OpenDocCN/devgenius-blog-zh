<html>
<head>
<title>A Curious Tale of Late Initialisation Options — Part I</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个关于后期初始化选项的奇怪故事——第一部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/a-curious-tale-of-late-initialisation-options-part-i-44da6ca94068?source=collection_archive---------15-----------------------#2022-02-05">https://blog.devgenius.io/a-curious-tale-of-late-initialisation-options-part-i-44da6ca94068?source=collection_archive---------15-----------------------#2022-02-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="abc8" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">使用 Kotlin 的后期初始化选项导航内存泄漏和线程安全</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/cbf353f396d9cf57eaaf44c2014df24c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qgqvFchFoB2c8Ajs"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">在<a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae ks" href="https://unsplash.com/@towfiqu999999?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Towfiqu barbhuiya </a>拍摄的照片</figcaption></figure><p id="a92d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我真的很喜欢科特林中的修饰语。这是一个很小的词，却给我们提供了如此多的方便。简而言之，<code class="fe lp lq lr ls b">lateinit</code>修饰符使我们能够告诉 Kotlin 一个属性将在以后被初始化。因此，在利用这种属性时，我们不需要担心空检查。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lt lu l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">` ＄{ item . name } '在第 20 行被直接访问，而不检查` item '是否为空。</figcaption></figure><p id="9bc4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">多方便啊？</p><p id="7392" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是等等，有个小问题。我想清除<code class="fe lp lq lr ls b">onDetach()</code>方法中的<code class="fe lp lq lr ls b">item</code>属性。我可以简单地在这个方法上添加一个<code class="fe lp lq lr ls b">this.item = null</code>行来实现这个，对吗？不对！Kotlin 编译器不允许这样做。您将得到类似于以下内容的错误:</p><pre class="kd ke kf kg gt lv ls lw lx aw ly bi"><span id="b615" class="lz ma in ls b gy mb mc l md me">Null can not be a value of a non-null type Item</span></pre><p id="3a4e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">使用<code class="fe lp lq lr ls b">lateinit</code>修饰符编写这段代码会导致内存泄漏，因为无论何时调用<code class="fe lp lq lr ls b">onDetach()</code>都不会清除<code class="fe lp lq lr ls b">item</code>属性。</p><h2 id="38e1" class="lz ma in bd mf mg mh dn mi mj mk dp ml lc mm mn mo lg mp mq mr lk ms mt mu mv bi translated">捕捉:依赖注入</h2><p id="288b" class="pw-post-body-paragraph kt ku in kv b kw mw jo ky kz mx jr lb lc my le lf lg mz li lj lk na lm ln lo ig bi translated">我会让事情变得更复杂。让我们假设我们已经在我们的项目中设置了 DI，并且我们想要使用一个<code class="fe lp lq lr ls b">DefaultBehaviour</code>的<strong class="kv io">单例</strong>实例，以便每当我需要一个<code class="fe lp lq lr ls b">Behaviour</code>时总是被注入。为了简洁，我将使用这个准系统<code class="fe lp lq lr ls b">DependencyInjection</code>对象作为我的 DI 框架。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lt lu l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">对“DependencyInjection.behavior”的每次调用都将返回相同的实例。</figcaption></figure><p id="97ba" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">您会注意到，在长时间运行的应用程序中，<code class="fe lp lq lr ls b">DefaultBehaviour</code>中的<code class="fe lp lq lr ls b">item</code>会在第一个<code class="fe lp lq lr ls b">onAttach(item)</code>被调用后保留在内存中，即使在<code class="fe lp lq lr ls b">onDetach()</code>被调用后也不会被释放。</p><h2 id="2bf4" class="lz ma in bd mf mg mh dn mi mj mk dp ml lc mm mn mo lg mp mq mr lk ms mt mu mv bi translated">解决方案 1:自定义延迟初始化</h2><p id="ef91" class="pw-post-body-paragraph kt ku in kv b kw mw jo ky kz mx jr lb lc my le lf lg mz li lj lk na lm ln lo ig bi translated">我真的希望能够使用<code class="fe lp lq lr ls b">item</code>属性而不检查它是否是<code class="fe lp lq lr ls b">null</code>。也许有一种方法我可以欺骗 Kotlin 编译器并模仿一个<code class="fe lp lq lr ls b">lazy-lateinit</code>？下面是更新后的代码:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lt lu l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">这么🎉。我也在清理第 12 行的“项目”。第 13 行将为我证实这一点。</figcaption></figure><p id="e8b9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这种方法中，我创建了一个可空属性<code class="fe lp lq lr ls b">_item</code>，它保存在<code class="fe lp lq lr ls b">onAttach(item)</code>方法中接收到的<code class="fe lp lq lr ls b">Item</code>。然后，我将我的<code class="fe lp lq lr ls b">item</code>属性设为非空的<strong class="kv io"/><code class="fe lp lq lr ls b">val</code>，并使用可空的<code class="fe lp lq lr ls b">_item</code>进行惰性初始化。</p><pre class="kd ke kf kg gt lv ls lw lx aw ly bi"><span id="0920" class="lz ma in ls b gy mb mc l md me">private val item by <em class="nb">lazy </em><strong class="ls io">{ </strong><em class="nb">requireNotNull</em>(_item) <strong class="ls io">}</strong></span></pre><p id="9026" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我不使<code class="fe lp lq lr ls b">item</code>成为<a class="ae ks" href="https://kotlinlang.org/docs/delegated-properties.html#lazy-properties" rel="noopener ugc nofollow" target="_blank">惰性属性</a>，每当创建这个对象时，我的应用程序就会崩溃。原因是，我还没有调用<code class="fe lp lq lr ls b">onAttach(item)</code>方法，所以后台属性<code class="fe lp lq lr ls b">_item</code>还没有设置。</p><p id="0d92" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">by lazy {...}</code>延迟了<code class="fe lp lq lr ls b">item</code>属性的初始化，直到我第一次访问它，希望那时我已经调用了初始化后台<code class="fe lp lq lr ls b">_item</code>属性的<code class="fe lp lq lr ls b">onAttach(item)</code>方法。另外，<code class="fe lp lq lr ls b">item</code>属性实际上是非空的，因为<code class="fe lp lq lr ls b">requireNotNull(_item)</code>将总是返回一个非空值。</p><p id="8a54" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们运行程序:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lt lu l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">手指交叉…🤞🏾</figcaption></figure><p id="715a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当它编译的时候，我已经知道我期望看到什么了。控制台输出应在第一行显示“正在连接，机器人手臂”,然后在第二行显示“正在分离 null ”,因为支持属性<code class="fe lp lq lr ls b">_item</code>已被设置为 null。让我们看看输出结果是什么。</p><pre class="kd ke kf kg gt lv ls lw lx aw ly bi"><span id="3f45" class="lz ma in ls b gy mb mc l md me">Attaching, Robot arm<br/>Detaching Item(name=Robot arm)</span></pre><p id="96b0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">等等。什么？</p><p id="5b11" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为什么不是<code class="fe lp lq lr ls b">null</code>？我将后台属性<code class="fe lp lq lr ls b">_item</code>设置为<code class="fe lp lq lr ls b">null</code>。<code class="fe lp lq lr ls b">item</code>不也应该有效地变成 null 吗？</p><p id="e8f6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">不，文件上说:</p><blockquote class="nc nd ne"><p id="4006" class="kt ku nb kv b kw kx jo ky kz la jr lb nf ld le lf ng lh li lj nh ll lm ln lo ig bi translated">…对 get()的第一次调用执行传递给 lazy()的 lambda 并记住结果。对 get()的后续调用只是返回记忆的结果。— <a class="ae ks" href="https://kotlinlang.org/docs/delegated-properties.html#lazy-properties" rel="noopener ugc nofollow" target="_blank">懒惰属性</a>。</p></blockquote><p id="a92f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">啊，它记得结果！显然，这次“阅读文件”的人是对的。</p><p id="82a1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以我们又回到了起点。我们的 DI 图保存了我们的单例实例，该实例保存了延迟初始化的<code class="fe lp lq lr ls b">item</code>，在第一个<code class="fe lp lq lr ls b">onAttach(item)</code>被调用后，它将永远保留在内存中。</p><h2 id="4381" class="lz ma in bd mf mg mh dn mi mj mk dp ml lc mm mn mo lg mp mq mr lk ms mt mu mv bi translated">解决方案二:接受失败，使用可选属性</h2><p id="6298" class="pw-post-body-paragraph kt ku in kv b kw mw jo ky kz mx jr lb lc my le lf lg mz li lj lk na lm ln lo ig bi translated">我想我必须接受<code class="fe lp lq lr ls b">item</code>必须是可选属性，我才能正确释放该属性。以下是我更新的代码:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lt lu l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">“item”属性现在可为空。这意味着我需要在访问第 16 行的‘item . name’时使用安全调用。</figcaption></figure><p id="1a9c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在我们投入精力庆祝找到解决方案之前，让我们先快速地看看结果。祈求好运🤞🏾。</p><pre class="kd ke kf kg gt lv ls lw lx aw ly bi"><span id="bf42" class="lz ma in ls b gy mb mc l md me">Attaching, Robot arm<br/>Detaching null</span></pre><p id="0e5c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">哇，这就是我们想要的。<code class="fe lp lq lr ls b">onDetach()</code>方法现在工作正常🎉。</p><p id="b4fe" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">唯一让我恼火的是，每当我想访问项目名称时，我总是不得不使用安全调用<code class="fe lp lq lr ls b">item?.name</code>。我想知道为什么我需要这样做，当我确信只要我调用了<code class="fe lp lq lr ls b">onAttach(Item)</code>，那么<code class="fe lp lq lr ls b">item</code>的值就永远不会是<code class="fe lp lq lr ls b">null</code>。</p><p id="985c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但这总是真的吗？🤔。</p><p id="9a3f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们把事情复杂化一点。我们将在<a class="ae ks" href="https://bendaniel10.medium.com/a-curious-tale-of-late-initialisation-options-part-ii-339a85e08961" rel="noopener">第二部</a>继续。</p></div></div>    
</body>
</html>