<html>
<head>
<title>Remote Heart Rate Detection using Webcam and 50 Lines of Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用网络摄像头和 50 行代码进行远程心率检测</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/remote-heart-rate-detection-using-webcam-and-50-lines-of-code-2326f6431149?source=collection_archive---------0-----------------------#2020-09-02">https://blog.devgenius.io/remote-heart-rate-detection-using-webcam-and-50-lines-of-code-2326f6431149?source=collection_archive---------0-----------------------#2020-09-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="0607" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有一次，我看到了一个 Android 应用程序的描述，它通过智能手机的摄像头远程测量心率。有趣的一点是，Google Play 的审核人员不相信这种测量的可能性，因此该应用程序被拒绝。我不知道这个故事的结局，但检查这是否可能变得很有趣。没有必要制作一个 Android 应用程序，用 Python 测试这个想法要容易得多。</p><p id="a598" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们开始吧。</p><h1 id="5986" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">获取相机流</h1><p id="4020" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">首先，我们需要从网络摄像头获取一个流，为此我将使用 OpenCV。代码是跨平台的，可以在 Windows 和 Linux/OSX 上运行。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="e356" class="lx km iq lt b gy ly lz l ma mb">import cv2<br/>import io<br/>import time<br/></span><span id="bc0e" class="lx km iq lt b gy mc lz l ma mb">cap = cv2.VideoCapture(0)<br/>cap.set(cv2.CAP_PROP_FRAME_WIDTH, 1920)<br/>cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 1080)<br/>cap.set(cv2.CAP_PROP_FPS, 30)</span><span id="ada4" class="lx km iq lt b gy mc lz l ma mb">while True:<br/>    ret, frame = cap.read()<br/>    img = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</span><span id="cd69" class="lx km iq lt b gy mc lz l ma mb">    <em class="md"># Display the frame</em><br/>    cv2.imshow('Crop', crop_img)<br/>    if cv2.waitKey(1) &amp; 0xFF == ord('q'):<br/>        break</span><span id="0b3b" class="lx km iq lt b gy mc lz l ma mb">cap.release()<br/>cv2.destroyAllWindows()</span></pre><p id="991a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">确定心率的想法是，由于血管中的流动，肤色会发生轻微变化。所以我们需要一个图片裁剪，它只包含皮肤的一个片段:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="0fdc" class="lx km iq lt b gy ly lz l ma mb">x, y, w, h = 800, 500, 100, 100<br/>crop_img = img[y:y + h, x:x + w]</span><span id="6191" class="lx km iq lt b gy mc lz l ma mb">cv2.imshow('Crop', crop_img)</span></pre><p id="39fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果一切都做得正确，我们应该得到相机图像(出于隐私原因模糊)并裁剪:</p><figure class="lo lp lq lr gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi me"><img src="../Images/e928052e7a6beb941ef9df1ddb7e95b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KstNWRWRR2y1I-P-.png"/></div></div></figure><h1 id="860d" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">图像处理</h1><p id="a3cf" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">一旦我们有了摄像机流，这就很简单了。对于选定的图像片段，我们获得平均亮度值，并将其与测量时间戳一起添加到数组中。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="ce16" class="lx km iq lt b gy ly lz l ma mb">heartbeat_count = 128<br/>heartbeat_values = [0]*heartbeat_count<br/>heartbeat_times = [time.time()]*heartbeat_count</span><span id="97c6" class="lx km iq lt b gy mc lz l ma mb">while True:<br/>    ...<br/>    <em class="md"># Update the data and timestamps</em><br/>    heartbeat_values = heartbeat_values[1:] + [np.average(crop_img)]<br/>    heartbeat_times = heartbeat_times[1:] + [time.time()]</span></pre><p id="fe4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">函数计算一个二维数组的平均值，在输出端，我们得到一个数字，这是我们 100x100 平方帧的平均亮度。</p><p id="6be1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用<a class="ae mm" href="https://matplotlib.org/gallery/index.html" rel="noopener ugc nofollow" target="_blank"> matplotlib </a>库实时显示图形:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="8453" class="lx km iq lt b gy ly lz l ma mb">fig = plt.figure()<br/>ax = fig.add_subplot(111)<br/>while True:<br/>    ...</span><span id="f534" class="lx km iq lt b gy mc lz l ma mb">    ax.plot(heartbeat_times, heartbeat_values)<br/>    fig.canvas.draw()<br/>    plot_img_np = np.fromstring(fig.canvas.tostring_rgb(),<br/>                                dtype=np.uint8, sep='')<br/>    plot_img_np = plot_img_np.reshape(fig.canvas.get_width_height()[::-1] + (3,))<br/>    plt.cla()<br/>    <br/>    cv2.imshow('Graph', plot_img_np)</span></pre><p id="2e61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">OpenCV 处理 numpy 格式的图像，所以我必须使用<em class="md"> numpy.fromstring </em>函数来转换图像。</p><p id="7abd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">仅此而已。</p><p id="e667" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我已经运行了程序，选择了这样一个位置，这样在相机裁剪区域只有一个皮肤碎片是可见的，采取了<a class="ae mm" href="https://en.wikipedia.org/wiki/The_Thinker" rel="noopener ugc nofollow" target="_blank">思考者姿势</a>头部放在手上——图像应该尽可能不动。瞧，它真的有用！</p><figure class="lo lp lq lr gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mn"><img src="../Images/6b782b97f3d742978735cbddc7a8ecd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sgbMGUUcs8vWXn3yOoZopw.png"/></div></div></figure><p id="d9e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">值得再次重申的是，相机不是应用于皮肤，我们只是简单地分析人的整体画面。而且很神奇的是，即使在这个距离，肤色的细微变化都被相机自信地捕捉到了！正如我们从图表中看到的，亮度的实际差异小于 0.5%，当然，“肉眼”是看不到的，但在图表上是可以清楚地区分的。大约每分钟 75 次。作为比较，脉搏血氧计的 BPM 结果如下:</p><figure class="lo lp lq lr gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mo"><img src="../Images/cd24d0e15fa3f82933e1c5aada9c8e7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*ZF01M54roOI9Pla6.png"/></div></div></figure><p id="a660" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了验证我们得到的是真实的心率，而不是任何虚假信号，如闪烁的灯泡，检查心率是否随体育锻炼而变化也很有趣。事实上，如果我将两张图放在同一个图像中，我就能看到它——第一张图是在锻炼前拍摄的，第二张是在锻炼后拍摄的。</p><figure class="lo lp lq lr gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mp"><img src="../Images/e8c3b327ac597cf341b06d090070af60.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/format:webp/1*_57v599N3qnsBKNpKJ7JbA.png"/></div></div></figure><p id="083b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很容易看出，在第二种情况下，心率更高。</p><h1 id="4f89" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">结论</h1><p id="c672" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">奇怪的是，它真的有效——老实说，我不确定结果。它可以与智能手机摄像头配合使用吗？嗯，这取决于很多因素。如果手机放在三脚架上，而人保持不动，这是可行的。但是如果手机拿在手里，我强烈怀疑结果会比一个随机数生成器好；)另一方面，如果在处理之前将运动稳定算法应用于相机流，则理论上可能是可能的，因此该问题仍然是开放的。对于网络摄像头，一般来说，更容易。</p><p id="e0fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于我们正在分析视频流，可能会出现一个单独的问题——这是否适用于压缩视频数据，是否有可能看到电影或电视演员的心率？我不知道答案，愿意的人可以自己试试。为此，只需替换行<em class="md"> cap = cv2 即可。VideoCapture(0) </em>中带有<em class="md"> cap = cv2 的代码。VideoCapture("video.mp4") </em>，其他代码不变。</p><p id="fe48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于那些希望进行更多测试的人，源代码附在下面:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="7fdb" class="lx km iq lt b gy ly lz l ma mb">import numpy as np<br/>from matplotlib import pyplot as plt<br/>import cv2<br/>import io<br/>import time<br/></span><span id="5d2a" class="lx km iq lt b gy mc lz l ma mb"># Camera stream<br/>cap = cv2.VideoCapture(0)<br/>cap.set(cv2.CAP_PROP_FRAME_WIDTH, 1920)<br/>cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 1280)<br/>cap.set(cv2.CAP_PROP_FPS, 30)<br/># Video stream (optional, not tested)<br/># cap = cv2.VideoCapture("video.mp4")</span><span id="d767" class="lx km iq lt b gy mc lz l ma mb"># Image crop<br/>x, y, w, h = 800, 500, 100, 100<br/>x, y, w, h = 950, 300, 100, 100<br/>heartbeat_count = 128<br/>heartbeat_values = [0]*heartbeat_count<br/>heartbeat_times = [time.time()]*heartbeat_count</span><span id="3650" class="lx km iq lt b gy mc lz l ma mb"># Matplotlib graph surface<br/>fig = plt.figure()<br/>ax = fig.add_subplot(111)</span><span id="68f6" class="lx km iq lt b gy mc lz l ma mb">while True:<br/>    # Capture frame-by-frame<br/>    ret, frame = cap.read()</span><span id="5ffc" class="lx km iq lt b gy mc lz l ma mb">    img = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)<br/>    crop_img = img[y:y + h, x:x + w]</span><span id="18f7" class="lx km iq lt b gy mc lz l ma mb">    # Update the data<br/>    heartbeat_values = heartbeat_values[1:] + [np.average(crop_img)]<br/>    heartbeat_times = heartbeat_times[1:] + [time.time()]</span><span id="e72a" class="lx km iq lt b gy mc lz l ma mb">    # Draw matplotlib graph to numpy array<br/>    ax.plot(heartbeat_times, heartbeat_values)<br/>    fig.canvas.draw()<br/>    plot_img_np = np.fromstring(fig.canvas.tostring_rgb(),<br/>                                dtype=np.uint8, sep='')<br/>    plot_img_np = plot_img_np.reshape(fig.canvas.get_width_height()[::-1] + (3,))<br/>    plt.cla()</span><span id="ac53" class="lx km iq lt b gy mc lz l ma mb">    # Display the frames<br/>    cv2.imshow('Crop', crop_img)<br/>    cv2.imshow('Graph', plot_img_np)<br/>    if cv2.waitKey(1) &amp; 0xFF == ord('q'):<br/>        break</span><span id="7d79" class="lx km iq lt b gy mc lz l ma mb">cap.release()<br/>cv2.destroyAllWindows()</span></pre><p id="16b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读。</p></div></div>    
</body>
</html>