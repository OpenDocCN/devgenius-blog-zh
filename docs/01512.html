<html>
<head>
<title>Vue Problems — Mixins, Slots, and Computed Properties</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Vue 问题—混合、插槽和计算属性</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/vue-problems-mixins-slots-and-computed-properties-5280990d2f04?source=collection_archive---------11-----------------------#2020-07-05">https://blog.devgenius.io/vue-problems-mixins-slots-and-computed-properties-5280990d2f04?source=collection_archive---------11-----------------------#2020-07-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/079b6b48d45f2bf7319ed34da2f044ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1zcn1g4vBBF3YmYv"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">劳尔·popadineți 在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="8c2f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Vue.js 让开发前端应用变得简单。然而，我们仍有可能遇到问题。</p><p id="0df2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将看看一些常见的问题，并看看如何解决它们。</p><h1 id="fc18" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用 Webpack 导入 Vue 组件</h1><p id="4613" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">要在另一个组件中使用一个组件，我们必须导入该组件并注册它。</p><p id="a2f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以在组件中使用它。</p><p id="7f40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b99a" class="mn lc iq mj b gy mo mp l mq mr">&lt;template&gt;<br/>  &lt;top-bar&gt;&lt;/top-bar&gt;<br/>&lt;/template&gt;</span><span id="7dd6" class="mn lc iq mj b gy ms mp l mq mr">&lt;script&gt;<br/>import TopBar from './top-bar.vue'<br/>export default {<br/>  components: {<br/>    TopBar<br/>  }<br/>}<br/>&lt;/script&gt;</span></pre><p id="7af7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们导入了<code class="fe mt mu mv mj b">TopBar</code>组件，然后通过将它放入<code class="fe mt mu mv mj b">components</code>对象中来注册它。</p><p id="f321" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以参考烤肉串盒或它所在的原始盒。</p><p id="5aa4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Vue 会自动将上面的骆驼盒映射到烤肉串盒。</p><h1 id="cf1a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对不同的路线使用相同的组件</h1><p id="83c6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们把<code class="fe mt mu mv mj b">key</code>道具放入<code class="fe mt mu mv mj b">router-view</code>，那么我们可以为不同的路线使用相同的组件。</p><p id="e5b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为 Vue 路由器会完全重载组件，而不是重载它认为需要重载的部分。</p><p id="fead" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="fea1" class="mn lc iq mj b gy mo mp l mq mr">&lt;router-view :key="$route.path"&gt;&lt;/router-view&gt;</span></pre><h1 id="147e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将所有道具和监听器从父传递给子</h1><p id="1903" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过使用<code class="fe mt mu mv mj b">v-bind</code>和<code class="fe mt mu mv mj b">v-on</code>指令将所有的道具和监听器从父节点传递给子节点。</p><p id="e836" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">v-bind</code>通过所有道具。<code class="fe mt mu mv mj b">v-on</code>通过所有监听器。</p><p id="c483" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="cec0" class="mn lc iq mj b gy mo mp l mq mr">&lt;child v-bind="$attrs" v-on="$listeners"&gt;&lt;/child&gt;</span></pre><p id="6abb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用<code class="fe mt mu mv mj b">$attrs</code>把传递给父节点的所有道具传递给<code class="fe mt mu mv mj b">child</code>。</p><p id="bad5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将传递给父节点的所有事件传递给带有<code class="fe mt mu mv mj b">$listeners</code>值的子节点。</p><h1 id="fc62" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">继承带有混合的模板</h1><p id="c63a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以让组件模板与插槽一起重用。</p><p id="9e5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5b35" class="mn lc iq mj b gy mo mp l mq mr">Vue.component('not-found', {<br/>  template: '#not-found'<br/>});</span></pre><p id="879c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在我们的模板中，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2d0b" class="mn lc iq mj b gy mo mp l mq mr">&lt;template id="not-found"&gt;<br/>  &lt;div&gt;<br/>    &lt;h1&gt;404 Not Found&lt;/h1&gt;<br/>    &lt;slot&gt;&lt;/slot&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;</span></pre><p id="806b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以容纳我们想要的任何东西。</p><p id="37a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们把东西放在<code class="fe mt mu mv mj b">not-found</code>的标签之间。</p><p id="bbf1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要使用它，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="93a4" class="mn lc iq mj b gy mo mp l mq mr">&lt;not-found&gt;<br/>  &lt;p&gt;hello&lt;/p&gt;<br/>&lt;/not-found&gt;</span></pre><p id="dbb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后<code class="fe mt mu mv mj b">&lt;p&gt;hello&lt;/p&gt;</code>将被放置在<code class="fe mt mu mv mj b">slot</code>组件的位置。</p><h1 id="1a5a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将类应用于父组件中的 Vue 功能组件</h1><p id="b0d9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们有一个功能性的 Vue 组件，我们可以使用<code class="fe mt mu mv mj b">data.staticClass</code>从父组件中获取类。</p><p id="f545" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以编写的 Gir 实例:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3a84" class="mn lc iq mj b gy mo mp l mq mr">&lt;template functional&gt;<br/>  &lt;div class="my-class" :class="data.staticClass || ''" v-bind="data.attrs"&gt;<br/>    //...<br/>  &lt;/div&gt;<br/>&lt;/template&gt;</span></pre><p id="63ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们对<code class="fe mt mu mv mj b">data.attrs</code>做同样的事情来获得其他属性。</p><p id="a1b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们可以从父组件中获取所有的类，并将它们应用到子组件中。</p><h1 id="56f8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在 Vue 组件中重用来自外部资源的方法</h1><p id="317c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">通过使用 mixins，我们可以在 Vue 组件中重用来自外部资源的方法。</p><p id="4877" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f2ec" class="mn lc iq mj b gy mo mp l mq mr">import mixin from './mixin.js'</span><span id="9e82" class="mn lc iq mj b gy ms mp l mq mr">export default {<br/>  mixins: [mixin]<br/>}</span></pre><p id="9a7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Vue mixin 只是一个具有与组件相同的方法和属性的对象。</p><p id="3854" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它也以同样的方式引用<code class="fe mt mu mv mj b">this</code>。</p><p id="2e60" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为如果我们将它合并进来，这些方法将会被合并到组件本身中。</p><h1 id="c0cc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将 JSON 数据传递给 Vue 实例</h1><p id="7ba4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以将 JSON 传递给 Vue 实例。我们只是把它们作为一个普通的对象来解析。</p><p id="862f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只是使用<code class="fe mt mu mv mj b">JSON.parse</code>将一个 JSON 字符串解析成一个普通的 JavaScript 对象。</p><p id="9594" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a3f7" class="mn lc iq mj b gy mo mp l mq mr">import json from 'data.json';</span><span id="988f" class="mn lc iq mj b gy ms mp l mq mr">new Vue({<br/>  el: '#app',<br/>  data: {<br/>    json<br/>  },<br/>  methods: {<br/>    setJson(payload) {<br/>      this.json = payload<br/>    },<br/>  }<br/>})</span></pre><p id="23b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8044" class="mn lc iq mj b gy mo mp l mq mr">&lt;div id="app"&gt;<br/>  &lt;pre&gt;{{ json }}&lt;/pre&gt;<br/>&lt;/div&gt;</span></pre><p id="86a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Vue 将按原样显示解析后的对象。</p><h1 id="8c33" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">搜索过滤</h1><p id="6919" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了显示过滤后的搜索结果，我们将创建一个计算属性。</p><p id="265f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0e59" class="mn lc iq mj b gy mo mp l mq mr">computed: {<br/>  resultQuery(){<br/>    if(this.query){<br/>      return this.resources.filter((item) =&gt; {<br/>        return item.name.toLowerCase().includes(this.query)<br/>      })<br/>    }<br/>    else {<br/>      return this.resources;<br/>    }<br/>  }<br/>}</span></pre><p id="6230" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们检查<code class="fe mt mu mv mj b">this.query</code>的价值。如果它被定义了，那么我们用它来检查<code class="fe mt mu mv mj b">this.resources</code>中的任何东西是否与列出的条目相匹配。</p><p id="84a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用使<code class="fe mt mu mv mj b">item.name.toLowerCase().includes(this.query)</code>返回<code class="fe mt mu mv mj b">true</code>的条目返回一个数组。</p><p id="d99c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们可以这样写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="52e0" class="mn lc iq mj b gy mo mp l mq mr">...<br/>&lt;tr v-for="item in <!-- -->resultQuery<!-- -->"&gt;<br/>  &lt;td&gt;&lt;a&gt;{{item.title}}&lt;/a&gt;&lt;/td&gt;<br/>&lt;/tr&gt;<br/>...</span></pre><p id="0f0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们呈现的结果具有包含<code class="fe mt mu mv mj b">this.query</code>的<code class="fe mt mu mv mj b">name</code>属性。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/411dc77b5550e3b5d09b514ccefee5d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LSGzlMhKRDfD9m4T"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@thinkdeep?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">捷尔吉·巴科斯</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="5692" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="7bd3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以导入和注册组件来使用它们。</p><p id="3bc9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，如果我们想要过滤掉项目，我们可以创建一个计算属性来返回项目。</p><p id="1112" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Mixins 和 slots 对于创建可重用代码非常有用。</p></div></div>    
</body>
</html>