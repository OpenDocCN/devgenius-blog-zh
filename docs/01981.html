<html>
<head>
<title>JavaScript Best Practices — Newer Syntax, Formatting, and Promise Rejections</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践—更新的语法、格式和承诺拒绝</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/javascript-best-practices-newer-syntax-formatting-and-promise-rejections-f0c85c19c115?source=collection_archive---------32-----------------------#2020-07-15">https://blog.devgenius.io/javascript-best-practices-newer-syntax-formatting-and-promise-rejections-f0c85c19c115?source=collection_archive---------32-----------------------#2020-07-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/cd3f533b828c36308a3ddcdd17e5e472.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BTarITmzZWrQ9_w6"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@brandgreen?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布兰登·格林</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="90ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使代码易于阅读和维护，我们应该遵循一些最佳实践。</p><p id="0f90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将看看我们应该遵循的一些最佳实践，以使每个人的生活更轻松。</p><h1 id="53dc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将对象属性放在单独的行上</h1><p id="4800" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们有很多对象属性，我们应该把它们放在单独的行上。</p><p id="36a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="cfcb" class="mn lc iq mj b gy mo mp l mq mr">const obj = {a: 1, b: [2, {c: 3, b: 4}]};</span></pre><p id="a059" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5946" class="mn lc iq mj b gy mo mp l mq mr">const obj = {<br/>  a: 1,<br/>  b: [2, {<br/>    c: 3,<br/>    b: 4<br/>  }]<br/>};</span></pre><p id="8607" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在不会溢出页面了。</p><h1 id="70fd" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对象文字速记语法</h1><p id="7c89" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该使用简单的速记语法来节省打字和空间。</p><p id="4a23" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:“</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9723" class="mn lc iq mj b gy mo mp l mq mr">const bar = {<br/>  x: x,<br/>  y: y,<br/>  z: z,<br/>};</span></pre><p id="6912" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9ae5" class="mn lc iq mj b gy mo mp l mq mr">const bar = {<br/>  x,<br/>  y,<br/>  z,<br/>};</span></pre><p id="b42b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于方法，不要写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="624f" class="mn lc iq mj b gy mo mp l mq mr">const bar = {<br/>  x: function(){},<br/>  y: function(){}<br/>};</span></pre><p id="b8fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5a6d" class="mn lc iq mj b gy mo mp l mq mr">const bar = {<br/>  x(){},<br/>  y(){}<br/>};</span></pre><h1 id="10f6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">变量声明的换行符</h1><p id="ac5c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果变量声明很长，我们希望在声明中添加新的行。</p><p id="9a1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b63c" class="mn lc iq mj b gy mo mp l mq mr">var a, b;</span></pre><p id="21d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以离开它。</p><p id="e9d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果更长，我们就把它们分成各自的行。</p><h1 id="50a6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">运算符的换行符样式</h1><p id="22fa" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">只要我们保持一致，我们可以把换行符放在我们想要的地方。</p><p id="b362" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5eab" class="mn lc iq mj b gy mo mp l mq mr">const fullHeight = paddingTop +<br/>  innerHeight +<br/>  paddingBottom;</span></pre><p id="1352" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="bef0" class="mn lc iq mj b gy mo mp l mq mr">const fullHeight = paddingTop<br/>  + innerHeight<br/>  + borderBottom;</span></pre><h1 id="ccc2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">块内无填充</h1><p id="54f5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以跳过街区内的停车场。</p><p id="bcb5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="de85" class="mn lc iq mj b gy mo mp l mq mr">if (a) {</span><span id="4ccd" class="mn lc iq mj b gy ms mp l mq mr">  b();</span><span id="f0d0" class="mn lc iq mj b gy ms mp l mq mr">}</span></pre><p id="c14d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2410" class="mn lc iq mj b gy mo mp l mq mr">if (a) {<br/>  b();<br/>}</span></pre><h1 id="fb07" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">语句之间的填充行</h1><p id="ef7e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以在语句之间添加填充线来对它们进行分组。</p><p id="814a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="edde" class="mn lc iq mj b gy mo mp l mq mr">function foo() {<br/>  let a = 1;</span><span id="c862" class="mn lc iq mj b gy ms mp l mq mr">  return a;<br/>}</span></pre><h1 id="ec31" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">为回调使用箭头函数</h1><p id="06cd" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们不需要在回调中引用它们自己的<code class="fe mt mu mv mj b">this</code>，那么我们应该使用箭头函数进行回调。</p><p id="844c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3d0a" class="mn lc iq mj b gy mo mp l mq mr">foo(function(a) { return a; });</span></pre><p id="3036" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5e13" class="mn lc iq mj b gy mo mp l mq mr">foo(a =&gt; a);</span></pre><h1 id="72c6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用<code class="fe mt mu mv mj b">const</code></h1><p id="18ef" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe mt mu mv mj b">const</code>声明常量。</p><p id="3717" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们定义了一个新值，我们就不能给它们赋值。</p><p id="b146" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="07a6" class="mn lc iq mj b gy mo mp l mq mr">const a = 0;</span></pre><p id="2a58" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="fed4" class="mn lc iq mj b gy mo mp l mq mr">for (const a of [1, 2, 3]) {<br/>  console.log(a);<br/>}</span></pre><h1 id="3c29" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">更喜欢从数组和对象析构</h1><p id="540c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以对对象数组使用析构赋值语法。</p><p id="bf9f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们让我们把他们的条目分解成变量。</p><p id="aaaf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="cd98" class="mn lc iq mj b gy mo mp l mq mr">const foo = array[0];</span></pre><p id="efb6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5220" class="mn lc iq mj b gy mo mp l mq mr">const [foo] = array;</span></pre><p id="aedd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1e58" class="mn lc iq mj b gy mo mp l mq mr">const foo = object.foo;</span></pre><p id="3c4b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9fea" class="mn lc iq mj b gy mo mp l mq mr">const { foo } = object;</span></pre><h1 id="f866" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">更换<code class="fe mt mu mv mj b">Math.pow</code>以利于<code class="fe mt mu mv mj b">**</code>操作员</h1><p id="27eb" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe mt mu mv mj b">**</code>运算符代替<code class="fe mt mu mv mj b">Math.pow</code>来做取幂运算。</p><p id="76d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它更短，我们不必调用方法。</p><p id="4989" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0052" class="mn lc iq mj b gy mo mp l mq mr">const foo = Math.pow(2, 8);</span></pre><p id="b0f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="750d" class="mn lc iq mj b gy mo mp l mq mr">const foo = 2 ** 8;</span></pre><h1 id="46c6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在正则表达式中使用命名捕获组</h1><p id="78a6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">从ES2018开始，我们可以命名我们的捕获组。</p><p id="fa7b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这使得模式对每个人来说都更清楚。</p><p id="9cf8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d974" class="mn lc iq mj b gy mo mp l mq mr">const regex = /(?\d{4})/;</span></pre><p id="079f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6b6b" class="mn lc iq mj b gy mo mp l mq mr">const regex = /(?&lt;year&gt;\d{4})/;</span></pre><p id="ad2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们知道我们在寻找年份。</p><h1 id="1afb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe mt mu mv mj b">Replace parseInt()</code>和<code class="fe mt mu mv mj b">Number.parseInt()</code>带有二进制、八进制和十六进制文字</h1><p id="6176" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用数字文字代替<code class="fe mt mu mv mj b">parseInt</code>和<code class="fe mt mu mv mj b">Number.parseInt</code>调用。</p><p id="b07e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b5fe" class="mn lc iq mj b gy mo mp l mq mr">parseInt("1010101", 2)</span></pre><p id="e9e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9ded" class="mn lc iq mj b gy mo mp l mq mr">Number.parseInt("1010101", 2)</span></pre><p id="5a42" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="67ee" class="mn lc iq mj b gy mo mp l mq mr">0b1010101</span></pre><p id="0492" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它要短得多。</p><h1 id="e23a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用对象遍布<code class="fe mt mu mv mj b">Object.assign</code></h1><p id="dd12" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以对对象使用spread运算符，</p><p id="9b9c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们应该使用它们，因为它更短。</p><p id="8c21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9064" class="mn lc iq mj b gy mo mp l mq mr">Object.assign({}, {foo: 'bar'})</span></pre><p id="c949" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="decf" class="mn lc iq mj b gy mo mp l mq mr">const obj = {foo: 'bar'};<br/>const copy = {...obj};</span></pre><h1 id="2260" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用错误对象作为承诺拒绝原因</h1><p id="8e76" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">对于承诺拒绝原因，我们应该使用<code class="fe mt mu mv mj b">Error</code>实例。</p><p id="33e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们包括堆栈跟踪，告诉我们调试的有用信息。</p><p id="88ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要它来找出错误的来源。</p><p id="9b92" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="da05" class="mn lc iq mj b gy mo mp l mq mr">Promise.reject('error');</span></pre><p id="b723" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7f17" class="mn lc iq mj b gy mo mp l mq mr">Promise.reject(new Error("error"));</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/11c882207e18aa6d9d612f1d153840c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UsgbZ3-L4aD0HAd0"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@dariuscotoi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Darius Cotoi </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="3b22" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="ac11" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe mt mu mv mj b">Error</code>实例告诉我们比其他对象更多的错误信息。</p><p id="030d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以用换行符和空格来格式化我们的代码。</p><p id="0527" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了新语法，我们可以编写更少的代码。</p><p id="9f99" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们包括对象扩展、取幂和析构赋值语法。</p><p id="d06f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以对正则表达式使用命名捕获组。</p></div></div>    
</body>
</html>