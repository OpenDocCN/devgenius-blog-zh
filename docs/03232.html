<html>
<head>
<title>Estimate time complexity of Java and SQL query.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">估算Java和SQL查询的时间复杂度。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/estimate-time-complexity-of-java-and-sql-query-afa13a88a981?source=collection_archive---------0-----------------------#2020-10-15">https://blog.devgenius.io/estimate-time-complexity-of-java-and-sql-query-afa13a88a981?source=collection_archive---------0-----------------------#2020-10-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="02b2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在性能和复杂性之间艰难抉择的Java和SQL示例。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/079eba9b974634b4faa4e27480218183.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PKMHABvuyg8JEObjKSVbPw.png"/></div></div></figure><p id="3848" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">大O符号着眼于算法性能的上限来定义其最坏情况下的行为。它着眼于算法的渐近行为，并描述了由n表示的输入的大小。</p><p id="6df9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我喜欢使用T-SQL，所以我结合了不同的时间复杂度。</p><p id="9b4c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当然，我们可以使用SQL表的索引来提高速度。</p><p id="ddcd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">聚集索引在磁盘上进行物理排序，每个表只能有一个聚集索引。简单索引是按逻辑排序的，一个表可以有许多这样的索引(对于重要字段)。</p><p id="c168" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种符号的理论逻辑很简单:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ku"><img src="../Images/9a0ab482ae128fee71727f53f8bddb49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*TNbGjgeVq2569IVnixaIPA.png"/></div></figure><p id="548e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我们有两个SQL表:User和Post。</p><p id="3b14" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">常数时间复杂度O(1) </strong></p><p id="4818" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kv kw kx ky b">SELECT TOP 1 u.Name FROM User u</code></p><p id="a213" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果随着输入大小的增加，算法所花费的时间不变并且保持恒定，则该算法具有O(1)性能的复杂度。该算法不依赖于输入的大小。</p><p id="0788" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kv kw kx ky b">SELECT COUNT(*) FROM User</code></p><p id="4b45" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">a)基于计数统计，它具有O(1)</p><p id="3b7a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">b)但是在使用主键的情况下，复杂度是O(log(n))</p><p id="2a78" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">c)或O(n)复杂性，没有主键</p><p id="506b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">或O(1)的Java实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kz la l"/></div></figure><p id="1d6d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">线性时间复杂度O(n) </strong> — <strong class="jm io"> </strong>随其输入的大小线性增长。</p><p id="c2c4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kv kw kx ky b">SELECT u.Name FROM User u</code></p><p id="bc40" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">O(n)的Java示例:</p><p id="a3aa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kv kw kx ky b">for (int i = 0; i &lt; arr.length; i++) System.out.println( arr[i]);</code></p><p id="51f9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">其中<code class="fe kv kw kx ky b">arr.length </code>是循环的(n)大小。</p><p id="d0d8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">也有很多不同的组合，基于O(n): </strong></p><p id="bdb8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">A)哈希连接的复杂度为O(M + N)，其中N是哈希表，M是查找表。</p><p id="638f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kv kw kx ky b">SELECT u.Name, p.Comment, p.Date FROM User u JOIN Post p<br/> ON u.Id = p.UserId WHERE u.Status=True and u.Name LIKE ‘Donald Trump%’</code></p><p id="5d83" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">哈希联接首先扫描或计算整个构建输入，然后在内存中构建一个哈希表(如果它符合内存授权)。</p><p id="ad60" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">b)合并连接通常具有O(M+N)的复杂度，但是它取决于索引的使用。</p><p id="227a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果两个表在连接的列上都没有索引，那么首先需要对两个表进行排序，这样复杂度看起来更像O(M log M + N log N)。它是对两个表进行排序的时间加上扫描它们的时间的总和。</p><p id="bd2c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kv kw kx ky b">SELECT u.Name, p.Comment, p.Date FROM User u, Post p<br/> WHERE u.Id = p.UserId and u.Status=True and p.NumAnswers &gt;0</code></p><p id="502b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果只有一个表在连接的列上有索引，那么只有一个没有索引的表需要在合并步骤发生之前进行排序，这样复杂度看起来就像O(M + N log N)。</p><p id="6070" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">c)嵌套连接的复杂度通常为O(M * N)。当一个或两个表都很小，少于10条记录时，这种连接是有效的。</p><p id="dbaa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kv kw kx ky b">SELECT u.Id, u.Name, p.Id, p.Comment FROM User u<br/> LEFT OUTER JOIN Post p ON u.Id = p.UserId</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/aca5d4c07d4e9c0cff68cf1019ce7bbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*sI1LG4so6JB-xVsi4jJTsQ.png"/></div></figure><p id="e36c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">基于对数和指数逻辑的下一级复杂性:</strong></p><p id="1251" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对数语法是:<strong class="jm io"> log x(z) = y. </strong>举例:log2(8) = 3</p><p id="7c77" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">把这个读作“z的对数底x等于y”。看看这些变量与之前的方程相比如何。如果我们以此为基数，把它提高到结果，我们就得到想要取对数的数字。它基本上是指数的反义词。</p><p id="8bec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将某物提升到指数的语法是:<strong class="jm io"> x^y = z </strong></p><p id="df4d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们通常把它理解为“x的y次方等于z”。变量z是x乘以自身的y倍。</p><p id="8ce7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">对数时间复杂度O(log(n)) — </strong>时间执行与输入大小的对数成正比。</p><p id="5da6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kv kw kx ky b">SELECT u.Name FROM User u WHERE u.Id = N</code></p><p id="12ed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kv kw kx ky b">for (int i = 0; i &lt; arr.length; i=i*2) System.out.println( arr[i]);</code></p><p id="ed5e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">线性时间复杂度O(n log(n)) — </strong>嵌套循环:<strong class="jm io"> </strong>运行时间与输入的n log n成正比增长。</p><p id="9ddf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种运行时间经常出现在“分治算法”中，该算法递归地将问题分成子问题，然后在n个时间内将它们合并，例如:合并排序算法。</p><p id="90cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果使用aggregation with GROUP BY或sort with ORDER BY，则复杂度为O(n log(n))。</p><p id="d58f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kv kw kx ky b">SELECT * FROM User u, Post p WHERE u.Id = p.UserId and u.Id = N</code></p><p id="2018" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要执行GROUP BY，您必须遍历所有项目，因此这意味着O(n)。<br/>数据排序的时候，你已经花了O(n log(n))的时间来排序了。</p><p id="470f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kv kw kx ky b">SELECT p.Date, COUNT(p.PostId) FROM Post p<br/> GROUP BY p.Date ORDER BY p.Date DESC</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kz la l"/></div></figure><h1 id="64fa" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">更极端的是:</h1><p id="6db9" class="pw-post-body-paragraph jk jl in jm b jn ma jp jq jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh ig bi translated"><strong class="jm io">多项式时间复杂度O(n^m) </strong> —计算取决于附加循环的数量。</p><p id="dfd6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">二次时间复杂度O(n ) — </strong>交叉连接也称为笛卡尔连接</p><p id="3e4e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">用于输入大小n的算法执行几乎两倍(n)的步骤，并且该算法所用的时间随着输入大小的增加而二次变化，该算法被认为具有O(n)的复杂度。</p><p id="80f3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kv kw kx ky b">SELECT u.Name, p.Comment FROM User u, Post p WHERE u.id = p.UserId</code></p><p id="74c2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Java的典型例子是经典的冒泡排序:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kz la l"/></div></figure><p id="d728" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> O(n ) </strong> —立方时间与O(n⁴)…的O(n)等原理相同</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kz la l"/></div></figure><p id="fad8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">指数时间复杂度O(m^n) </strong> — <strong class="jm io"> </strong>与输入大小的某个指数因子成比例增长。</p><p id="4abb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通常，它们将是O(m^n)，其中n是涉及的每个表的记录数量，m是被连接的表的数量。</p><p id="e7cc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一个<em class="mf"> O(2^n) </em>时间算法的Java例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kz la l"/></div></figure><p id="6448" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">阶乘时间复杂度O(n！)</strong> <br/>算法必须极其缓慢。运行缓慢的算法的一个最简单的例子是在旅行推销员问题的一串著名算法中找到每个排列，或者查找<a class="ae mg" href="https://en.wikipedia.org/wiki/Gamma_function" rel="noopener ugc nofollow" target="_blank">伽马函数</a>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kz la l"/></div></figure><p id="6943" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">或者只是为了模拟，MSSQL如何将行显示为计算阶乘5: <br/> 1，2，6，24，120</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kz la l"/></div></figure><p id="6ebd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">结论:</strong></p><p id="e00c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">SQL语言从70年代开始为人所知，并在编程世界的任何地方使用。我们编写SQL查询，并尝试预测各种查询特性的性能。Big O理论允许我们在将自己的SQL查询发布到产品中之前进行深入思考。</p><p id="9362" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">参考文献:</strong></p><div class="mh mi gp gr mj mk"><a href="https://en.wikipedia.org/wiki/Time_complexity" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd io gy z fp mp fr fs mq fu fw im bi translated">时间复杂度</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">在计算机科学中，时间复杂度是计算复杂度，它描述了…</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">en.wikipedia.org</p></div></div><div class="mt l"><div class="mu l mv mw mx mt my ks mk"/></div></div></a></div><div class="mh mi gp gr mj mk"><a href="https://www.bigocheatsheet.com/" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd io gy z fp mp fr fs mq fu fw im bi translated">了解你的复杂性！</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">你好。这个网页涵盖了计算机科学中常用算法的空间和时间复杂性。当…</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">www.bigocheatsheet.com</p></div></div><div class="mt l"><div class="mz l mv mw mx mt my ks mk"/></div></div></a></div><div class="mh mi gp gr mj mk"><a href="https://www.lavivienpost.com/big-o-notation-interview-questions/" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd io gy z fp mp fr fs mq fu fw im bi translated">大O符号和面试问题</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">大O符号面试问题为顶级面试问题提供了扩展的大O符号。什么是大O…</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">www.lavivienpost.com</p></div></div><div class="mt l"><div class="na l mv mw mx mt my ks mk"/></div></div></a></div></div></div>    
</body>
</html>