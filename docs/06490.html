<html>
<head>
<title>How to create an abstract model class in Django</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在 Django 中创建抽象模型类</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-create-an-abstract-model-class-in-django-e1e77048b3b7?source=collection_archive---------4-----------------------#2022-01-12">https://blog.devgenius.io/how-to-create-an-abstract-model-class-in-django-e1e77048b3b7?source=collection_archive---------4-----------------------#2022-01-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="418f" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">介绍</h1><p id="f76d" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">Django 定义的抽象基类是什么:</p><blockquote class="lg lh li"><p id="335c" class="ki kj lj kk b kl lk kn ko kp ll kr ks lm ln kv kw lo lp kz la lq lr ld le lf ig bi translated"><em class="in">“当你想把一些公共信息放入许多其他模型时，抽象基类是有用的。你写你的基类，把 abstract=True 放在元类里。这个模型将不会被用来创建任何数据库表。相反，当它被用作其他模型的基类时，它的字段将被添加到子类的字段中。</em></p></blockquote><p id="ee8b" class="pw-post-body-paragraph ki kj in kk b kl lk kn ko kp ll kr ks kt ln kv kw kx lp kz la lb lr ld le lf ig bi translated"><a class="ae ls" href="https://docs.djangoproject.com/en/4.0/topics/db/models/#abstract-base-classes" rel="noopener ugc nofollow" target="_blank">参观现场</a></p><p id="9f18" class="pw-post-body-paragraph ki kj in kk b kl lk kn ko kp ll kr ks kt ln kv kw kx lp kz la lb lr ld le lf ig bi translated">换句话说，抽象类是拥有公共属性(参数)的类，这些属性可以被其他类继承。</p><h1 id="7806" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">密码</h1><p id="c046" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在 Django 中创建抽象模型类相当容易！让我们看看下面的例子:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/485220c7d168610d64097ffcce4392e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/1*NEDEjpij3NtxL4b8-S0oEw.png"/></div></figure><pre class="lu lv lw lx gt mb mc md me aw mf bi"><span id="2f3f" class="mg jl in mc b gy mh mi l mj mk">from django.db import models</span><span id="6612" class="mg jl in mc b gy ml mi l mj mk">class Car(models.Model):<br/>    brand = models.CharField(max_length=100)<br/>    doors = models.PositiveIntegerField()</span><span id="1707" class="mg jl in mc b gy ml mi l mj mk">class Jet(models.Model):<br/>    brand = models.CharField(max_length=100)<br/>    wing_type = models.CharField(max_length=30)</span><span id="f763" class="mg jl in mc b gy ml mi l mj mk">class Bike(models.Model):<br/>    brand = models.CharField(max_length=100)</span></pre><h1 id="4262" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">说明</h1><p id="6fa4" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在上面的代码中，我们声明了同一个属性<code class="fe mm mn mo mc b">"brand"</code>三次。多次声明同一个属性在这里没什么大不了的，但是在更大的项目中，这可能会非常繁琐。</p><h1 id="7878" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">解决办法</h1><p id="e8d0" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">我们可以使用下面的代码来代替:</p><pre class="lu lv lw lx gt mb mc md me aw mf bi"><span id="25f9" class="mg jl in mc b gy mh mi l mj mk">class Common(models.Model):<br/>    brand = models.CharField(max_length=100)</span><span id="9798" class="mg jl in mc b gy ml mi l mj mk">    class Meta:<br/>        abstract = True</span></pre><p id="bcb3" class="pw-post-body-paragraph ki kj in kk b kl lk kn ko kp ll kr ks kt ln kv kw kx lp kz la lb lr ld le lf ig bi translated">然后，我们可以相应地缩短课程:</p><pre class="lu lv lw lx gt mb mc md me aw mf bi"><span id="30bb" class="mg jl in mc b gy mh mi l mj mk">class Car(Common):<br/>    doors = models.PositiveIntegerField()</span><span id="1e23" class="mg jl in mc b gy ml mi l mj mk">class Jet(Common):<br/>    wing_type = models.CharField(max_length=30)</span><span id="5179" class="mg jl in mc b gy ml mi l mj mk">class Motorbike(Common):<br/>    pass</span></pre><p id="f9e1" class="pw-post-body-paragraph ki kj in kk b kl lk kn ko kp ll kr ks kt ln kv kw kx lp kz la lb lr ld le lf ig bi translated"><strong class="kk io">注意，我们在</strong> <code class="fe mm mn mo mc b"><strong class="kk io">"Jet"</strong></code> <strong class="kk io">类中添加了</strong> <code class="fe mm mn mo mc b"><strong class="kk io">"pass"</strong></code> <strong class="kk io">，因为没有属性需要声明。</strong></p><p id="29c8" class="pw-post-body-paragraph ki kj in kk b kl lk kn ko kp ll kr ks kt ln kv kw kx lp kz la lb lr ld le lf ig bi translated">现在假设我们想要改变一个继承属性的某个特征，比如<code class="fe mm mn mo mc b">"max_length"</code>。</p><p id="c0c8" class="pw-post-body-paragraph ki kj in kk b kl lk kn ko kp ll kr ks kt ln kv kw kx lp kz la lb lr ld le lf ig bi translated">我们只需覆盖继承的属性:</p><pre class="lu lv lw lx gt mb mc md me aw mf bi"><span id="ba6c" class="mg jl in mc b gy mh mi l mj mk">class Car(Common):<br/>    doors = models.PositiveIntegerField()<br/>    models.CharField(max_length=30)</span></pre><h1 id="f51d" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">结果</h1><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/970b5bf4185fe5a314c4aabb4bb50ec0.png" data-original-src="https://miro.medium.com/v2/resize:fit:534/format:webp/1*NcoOfxVeGIWXG94Rhp-MQg.png"/></div></figure><pre class="lu lv lw lx gt mb mc md me aw mf bi"><span id="4e1d" class="mg jl in mc b gy mh mi l mj mk">class Common(models.Model):<br/>    brand = models.CharField(max_length=100)</span><span id="b93c" class="mg jl in mc b gy ml mi l mj mk">    class Meta:<br/>        abstract = True</span><span id="6c80" class="mg jl in mc b gy ml mi l mj mk">class Car(Common):<br/>    doors = models.PositiveIntegerField()<br/>    brand = models.CharField(max_length=30)</span><span id="b94b" class="mg jl in mc b gy ml mi l mj mk">class Jet(Common):<br/>    wing_type = models.CharField(max_length=30)</span><span id="f6df" class="mg jl in mc b gy ml mi l mj mk">class Bike(Common):<br/>    pass</span></pre><h1 id="c246" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">结论</h1><p id="4c69" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">抽象类非常强大，可以节省我们很多时间，</p><p id="43a8" class="pw-post-body-paragraph ki kj in kk b kl lk kn ko kp ll kr ks kt ln kv kw kx lp kz la lb lr ld le lf ig bi translated">我们现在已经在 Django 中实现了一个抽象模型类，并且可以在任何需要的地方填充它。</p><p id="acea" class="pw-post-body-paragraph ki kj in kk b kl lk kn ko kp ll kr ks kt ln kv kw kx lp kz la lb lr ld le lf ig bi translated">快乐的生产编码！: )</p></div></div>    
</body>
</html>