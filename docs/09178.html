<html>
<head>
<title>Go: Call option that can be used with multiple methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go:可用于多种方法的看涨期权</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/go-call-option-that-can-be-used-with-multiple-methods-6c81734f3dbe?source=collection_archive---------2-----------------------#2022-08-04">https://blog.devgenius.io/go-call-option-that-can-be-used-with-multiple-methods-6c81734f3dbe?source=collection_archive---------2-----------------------#2022-08-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="b3cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">允许在函数和方法调用中共享选项，现在有了类型安全！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9fe8c838c51ed2daf71030acc984cb6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fwI3kDLammQS1cVt"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@pankajpatel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Pankaj Patel </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="1467" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">无耻宣传片:想知道如何提高你的围棋开发能力，请查看我的新书:<a class="ae ky" href="https://www.amazon.com/Go-DevOps-language-Kubernetes-Terraform/dp/1801818894/ref=sr_1_1?crid=3UJVTH5WHIGI8&amp;keywords=go+for+devops&amp;qid=1656568378&amp;sprefix=go+for+devops%2Caps%2C126&amp;sr=8-1" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> Go For DevOps </strong> </a></p><h1 id="e026" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">背景</h1><p id="1d93" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">几年前，Google 的 Go devs 提出了函数或方法调用的选项，这些选项使用函数调用来设置选项值。</p><p id="2bfe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Rob Pike 有一个版本，你可以在这里阅读:<a class="ae ky" href="https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html" rel="noopener ugc nofollow" target="_blank">https://command center . blogspot . com/2014/01/self-referential-functions-and-design . html</a></p><p id="7dd6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">举个例子，某个服务的客户端构造函数有一个设定的端点。当 99%的情况是“<strong class="jm io">https://myclientendpoint . com”</strong>时，也许我们不想给用户设置那个端点增加负担。但是我们偶尔需要覆盖它。我们可能会这样做:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="b78b" class="mh la in md b gy mi mj l mk ml">type SomeClient struct {<br/>  http *http.Client<br/>  endpoint string<br/>}</span><span id="c12d" class="mh la in md b gy mm mj l mk ml">// Option is an optional argument to New().<br/>type Option func(c *SomeClient)</span><span id="4f09" class="mh la in md b gy mm mj l mk ml">// WithEndpoint is an option that makes the client use the <br/>// endpoint passed.<br/>func WithEndpoint(endpoint string) Option {<br/>  return func(c *SomeClient) {<br/>    c.endpoint = endpoint<br/>  }<br/>}</span><span id="670d" class="mh la in md b gy mm mj l mk ml">func New(*httpClient *http.Client, options ...Options) *SomeClient { <br/>  c := &amp;SomeClient{<br/>    http: httpClient,<br/>    endpoint: "https://myclientendpoint.com",<br/>  }<br/><br/>  for _, o := range options {<br/>    o(c)<br/>  }<br/>  return c<br/>}</span></pre><p id="7dd3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们可以使用<code class="fe mn mo mp md b">WithEndpoint()</code>来设置一个超过默认值的自定义端点:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="4e84" class="mh la in md b gy mi mj l mk ml">c := New(&amp;http.Client{}, WithEndpoint("https://newendpoint.com"))</span></pre><p id="8201" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是最常见的用例，构造函数选项。</p><p id="eae7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mn mo mp md b">WithEndpoint()</code>返回函数闭包。也就是说，它返回一个可以访问其外部环境的函数，比如<code class="fe mn mo mp md b">endpoint</code>，即使它没有在内部定义。使用一个函数返回一个函数经常让人们感到困惑，因为不是所有的语言都有一级函数(可以是赋给变量的类型的函数)。</p><h1 id="66ff" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">方法调用选项</h1><p id="8045" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">另一个用例是为方法调用提供可选设置。大概是这样的:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="c89e" class="mh la in md b gy mi mj l mk ml">// tokenOpts holds all our optional token values.<br/>type tokenOpts struct {<br/>  account string<br/>}</span><span id="a01e" class="mh la in md b gy mm mj l mk ml">// TokenOption is an optional argument to ByToken().<br/>type TokenOption func(t *tokenOpts)</span><span id="409b" class="mh la in md b gy mm mj l mk ml">// WithAccount sets the account to name. For use with ByToken().<br/>func WithAccount(name string) TokenOption {<br/>  return func(t *tokenOpts) {<br/>    t.account = name<br/>  }<br/>}</span><span id="b4c0" class="mh la in md b gy mm mj l mk ml">// ByToken does something with tokens.<br/>func (a *Auth) ByToken(token string, options ...TokenOption) (string, error) {<br/>  opts := tokenOpts{account: "default"}<br/>  for _, o := range options {<br/>    o(&amp;opts)<br/>  }<br/>  // Do whatever the method does below here<br/>}</span></pre><p id="d3fd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这给出了类似的语义，只是在方法级别。这非常有效，直到有多个方法可以使用同一个选项。</p><p id="77cd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的场景中，如果我们想要使用<code class="fe mn mo mp md b">WithAccount()</code>作为一个名为<code class="fe mn mo mp md b">ByUserPass()</code>的新方法的选项，而这个新方法没有所有相同的选项，会发生什么呢？</p><p id="29b4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">大多数解决这个问题的方法都不太好。例如，我们可以有一个共享的可选选项<code class="fe mn mo mp md b">struct</code>,里面有所有方法的选项。但是这样我们就失去了编译器类型的安全保护，因为你可以在方法<code class="fe mn mo mp md b">X()</code>上使用一个<code class="fe mn mo mp md b">OptionB()</code>，而这个方法只能在方法<code class="fe mn mo mp md b">K()</code>上使用。</p><p id="70eb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以有两个(或者更多)方法来设置相同的值，但是类型不同，比如<code class="fe mn mo mp md b">WithAccountToken()</code>和<code class="fe mn mo mp md b">WithAccountUserPass().</code>是的，这对我们来说是行不通的。</p><h1 id="ca59" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">要解决的场景</h1><p id="49de" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">我想出了一种方法来解决这个问题，并保持 Go 开发人员希望他们的调用选项的语义。这个方法<strong class="jm io">滥用了</strong>一些不常使用的语言特性，而且冗长。但是对于最终用户来说，它仍然易于使用。</p><p id="bcaa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这不适合胆小的人。</p><p id="57b6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们从一个示例场景开始:</p><ul class=""><li id="1d9f" class="mq mr in jm b jn jo jr js jv ms jz mt kd mu kh mv mw mx my bi translated">方法 ByToken()</li><li id="fd30" class="mq mr in jm b jn mz jr na jv nb jz nc kd nd kh mv mw mx my bi translated">方法 ByUserPass()</li><li id="ea0b" class="mq mr in jm b jn mz jr na jv nb jz nc kd nd kh mv mw mx my bi translated">一个带有 Account()的选项，这两种方法都可以使用</li><li id="b38b" class="mq mr in jm b jn mz jr na jv nb jz nc kd nd kh mv mw mx my bi translated">一个选项，带有只能由 Token()使用的 Verifier()</li></ul><p id="27cd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为此，我们将使用一些不常使用的功能:</p><ul class=""><li id="73fb" class="mq mr in jm b jn jo jr js jv ms jz mt kd mu kh mv mw mx my bi translated"><code class="fe mn mo mp md b">interface</code>嵌入在<code class="fe mn mo mp md b">struct</code>型中</li><li id="acb3" class="mq mr in jm b jn mz jr na jv nb jz nc kd nd kh mv mw mx my bi translated">未命名的<code class="fe mn mo mp md b">struct</code>类型</li><li id="70f6" class="mq mr in jm b jn mz jr na jv nb jz nc kd nd kh mv mw mx my bi translated">未命名的<code class="fe mn mo mp md b">interface</code>类型</li></ul><p id="2549" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<code class="fe mn mo mp md b">struct</code>中嵌入一个<code class="fe mn mo mp md b">interface</code>允许<code class="fe mn mo mp md b">struct</code>满足那个<code class="fe mn mo mp md b">interface</code>，即使它没有实现这些方法。</p><p id="fc5c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以我们可以让一些<code class="fe mn mo mp md b">struct</code>像这样实现<code class="fe mn mo mp md b">io.Reader</code>:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="9e0f" class="mh la in md b gy mi mj l mk ml">type myStruct struct {<br/>  io.Reader<br/>}</span></pre><p id="ed1c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，你可能会问，如果有人在<code class="fe mn mo mp md b">myStruct</code>上调用<code class="fe mn mo mp md b">Read()</code>会发生什么？嗯，它会恐慌的。然而，我们这样做主要是为了加强类型检查，所以我们不必担心这个问题。</p><p id="9be2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">未命名的<code class="fe mn mo mp md b">struct</code>类型在表驱动测试中一直被使用，但是你很少在其他代码中看到它。使用这种方法，您可以设计<code class="fe mn mo mp md b">struct</code>，然后一次性实现所有功能，如下所示:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="a18f" class="mh la in md b gy mi mj l mk ml">myVar := struct{<br/>  name string<br/>}{<br/>  name: "John Doak",<br/>}</span></pre><p id="8ba7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，我们创建一个具有<code class="fe mn mo mp md b">name</code>属性的<code class="fe mn mo mp md b">struct</code>，它是一个<code class="fe mn mo mp md b">string</code>类型，并用设置为“John Doak”的<code class="fe mn mo mp md b">name</code>实例化它。同样，这不是你经常在考试之外看到的。</p><p id="948c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">未命名<code class="fe mn mo mp md b">interface</code>与未命名<code class="fe mn mo mp md b">struct</code>类型相似:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="2791" class="mh la in md b gy mi mj l mk ml">var myInter interface{<br/>  someMethod() error<br/>}</span></pre><p id="8739" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这创建了一个变量<code class="fe mn mo mp md b">myInter</code>，它只能由具有<code class="fe mn mo mp md b">someMethod() error</code>方法的类型来满足。同样，你很少在野外看到这种情况。</p><h1 id="6a08" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">解决方案</h1><p id="d16a" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">我已经为您打包了一个助手解决方案，但是该解决方案的 99%将在您的代码中实现该方法。我们要进口的包裹在 https://github.com/johnsiilver/calloptions。</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="cd54" class="mh la in md b gy mi mj l mk ml">type tokenOptions struct {<br/>  account string<br/>  verifier string<br/>}</span><span id="e0ce" class="mh la in md b gy mm mj l mk ml">// tokenOption is an optional argument for ByToken().<br/>// I've chosen to keep it private, but that is not required.<br/>type tokenOption interface {<br/>  token() // This must be kept private.<br/>}</span><span id="b54d" class="mh la in md b gy mm mj l mk ml">func (c *Client) ByToken(token string, options ...tokenOption) (string, error) {<br/>  opts := tokenOptions{account: "default"} <br/>  if err := calloptions.ApplyOptions(&amp;opts, options); err != nil {<br/>    return "", err<br/>  }<br/>  // Put the rest of your code here.<br/>}</span><span id="5bb4" class="mh la in md b gy mm mj l mk ml">type userPassOptions struct {<br/>  account string<br/>}</span><span id="501b" class="mh la in md b gy mm mj l mk ml">type userPassOption interface {<br/>  userPass()<br/>}</span><span id="e340" class="mh la in md b gy mm mj l mk ml">func (c *Client) ByUserPass(user, pass string, options ...userPassOption) (string, error) {<br/>  opts := userPassOptions{account: "default"}<br/>  if err := calloptions.ApplyOptions(&amp;opts, options); err != nil {<br/>    return "", err<br/>  }<br/>  // Put the rest of your code here.<br/>}</span></pre><p id="a45e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们已经设置了两个方法。每个方法都有一个名为<code class="fe mn mo mp md b">options</code>的变量参数，它有一个特定于该方法的<code class="fe mn mo mp md b">interface</code>类型。</p><p id="8d1c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mn mo mp md b">calloptions.ApplyOptions()</code>执行一个<code class="fe mn mo mp md b">for</code>循环，并应用传递给代表该方法选项的<code class="fe mn mo mp md b">struct</code>的每个选项。</p><p id="cb24" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为此，传递的选项还必须满足<code class="fe mn mo mp md b">calloptions.CallOption</code> <code class="fe mn mo mp md b">interface</code>。</p><p id="b79e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mn mo mp md b">interface</code>定义为:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="9ec9" class="mh la in md b gy mi mj l mk ml">type CallOption interface {<br/>  Do(a any) error <br/>  callOption()<br/>}</span></pre><p id="0f74" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过向<code class="fe mn mo mp md b">calloptions.New()</code>构造函数传递一个<code class="fe mn mo mp md b">func(a any) error</code>来创建一个<code class="fe mn mo mp md b">CallOption</code>。我们马上就会看到。</p><p id="ed62" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用您定义的函数，您将 assert <code class="fe mn mo mp md b">a</code>键入您期望的类型，然后设置值。因此，func 可能看起来像:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="57f2" class="mh la in md b gy mi mj l mk ml">func(a any) error {<br/>  t := a.(*tokenOptions)<br/>  t.account = account<br/>  return nil<br/>}</span></pre><p id="c4e8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将包含在一个闭包里，我们马上会展示它。我们可以扩展它，使其涵盖两种情况:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="e818" class="mh la in md b gy mi mj l mk ml">func(a any) error {<br/>  switch t := a.(type) {<br/>  case *tokenOptions:<br/>    t.account = account<br/>  case *userPassOptions:<br/>    t.account = account<br/>  default:<br/>    panic("not implemented bug")<br/>  }<br/>  return nil<br/>}</span></pre><p id="be12" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们展示一下当我们想要创建一个共享选项时的情况:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="ad7c" class="mh la in md b gy mi mj l mk ml">func WithAccount(name string) interface{<br/>  tokenOption<br/>  userPassOption<br/>  calloptions.CallOption<br/>}{<br/>  return struct{<br/>    tokenOption<br/>    userPassOption<br/>    calloptions.CallOption<br/>  }{<br/>    CallOption: calloptions.New(<br/>      func(a any) error {<br/>        switch t := a.(type) {<br/>        case *tokenOptions:<br/>          t.account = name<br/>        case *userPassOptions:<br/>          t.account = name<br/>        default:<br/>          panic("not implemented bug")<br/>        }<br/>        return nil<br/>      },<br/>    ),<br/>  }<br/>}</span></pre><p id="4400" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">哇…所以是时候打开这个了…</p><p id="4b50" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mn mo mp md b">WithAccount()</code>将要返回一个未命名的<code class="fe mn mo mp md b">interface</code>。那个<code class="fe mn mo mp md b">interface</code>嵌入了<code class="fe mn mo mp md b">tokenOption</code>、<code class="fe mn mo mp md b">userPassOption</code>和<code class="fe mn mo mp md b">CallOption</code>。这让我们可以在<code class="fe mn mo mp md b">ByToken()</code>和<code class="fe mn mo mp md b">ByUserPass()</code>中使用它。</p><p id="28c2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它是一个闭包，所以它从外部方法获取“account”变量。我们定义的<code class="fe mn mo mp md b">CallOption</code>将被调用来设置我们的可选<code class="fe mn mo mp md b">struct</code>，你可以看到它将设置<code class="fe mn mo mp md b">*tokenOptions</code>和<code class="fe mn mo mp md b">*userPassOptions</code>。</p><p id="7aef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们实现只能和<code class="fe mn mo mp md b">ByToken()</code>一起使用的<code class="fe mn mo mp md b">WithVerifier()</code>。</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="2906" class="mh la in md b gy mi mj l mk ml">func WithVerifier(endpoint string) interface {<br/>  tokenOption<br/>  calloptions.CallOption<br/>} {<br/>  return struct {<br/>    tokenOption<br/>    calloptions.CallOption<br/>  }{<br/>    CallOption: calloptions.New(<br/>      func(a any) error {<br/>        t := a.(*tokenOptions)<br/>        t.verifier = endpoint<br/>        return nil<br/>      },<br/>    ),<br/>  }<br/>}</span></pre><p id="7f14" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因为<code class="fe mn mo mp md b">WithVerifier</code>返回一个只实现<code class="fe mn mo mp md b">tokenOption</code>的<code class="fe mn mo mp md b">interface</code>，所以只能和<code class="fe mn mo mp md b">ByToken()</code>一起使用。</p><p id="503f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，当用户想要使用这些选项时，它看起来就像他们使用过的所有其他选项一样:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="7f29" class="mh la in md b gy mi mj l mk ml">c := Client{}<br/>c.ByToken("token", WithAccount("subID"), WithVerifier(" address"))<br/>c.ByUserPass("user", "pass", WithAccount("subscriptionID"))</span><span id="ebaf" class="mh la in md b gy mm mj l mk ml">// Uncommenting the next line will give a compiler error<br/>// c.ByUserPass("user", "pass", WithVerifier("some address"))</span></pre><p id="b06d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这符合所有标准。坦率地说，如果您在没有实际扩展支持的情况下扩展该选项支持的方法，确实有可能导致混乱。但这是非常低的风险。我很想消除这种情况，但目前还没有找到办法。</p><p id="67a7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以在这里看到这个例子:【https://go.dev/play/p/2Z3S6qv5xi7】T4</p><p id="ae49" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在多个方法调用中支持一个调用选项并不经常出现，但是一旦出现，解决起来会很痛苦。希望这能给你一个工具，当这个问题出现时，你可以用它来解决。</p><p id="55bd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你想看这个东西的运行，使用 git 来检查<a class="ae ky" href="https://github.com/johnsiilver/calloptions" rel="noopener ugc nofollow" target="_blank">https://github.com/johnsiilver/calloptions</a>并运行 example/中的代码。</p><p id="e6b8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你已经做到了这一步，并且正在做 DevOps、SRE 或 NoOps，请查看我的书:<a class="ae ky" href="https://www.amazon.com/Go-DevOps-language-Kubernetes-Terraform/dp/1801818894/ref=sr_1_1?crid=3UJVTH5WHIGI8&amp;keywords=go+for+devops&amp;qid=1656568378&amp;sprefix=go+for+devops%2Caps%2C126&amp;sr=8-1" rel="noopener ugc nofollow" target="_blank"> Go For DevOps </a>。我们从一开始就教你如何构建平台提供者、GitHub 操作、扩展 Packer、使用开放式遥测技术实现可见性、设计 ChatOps 系统以及使用策略服务器构建自己的工作流引擎等等。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/561c94d018534c8ee9df0ca580a1ca93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QF1HcVcmXjXMrd9MRiGVsQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Go For DevOps，在你最喜欢的书店有售</figcaption></figure><p id="1e0f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你也可以在 www.gophersre.com<a class="ae ky" href="http://www.gophersre.com" rel="noopener ugc nofollow" target="_blank">找到更多我写的东西</a></p></div></div>    
</body>
</html>