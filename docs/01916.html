<html>
<head>
<title>Node.js Tips — Promises, Socket.io, and Passing Data in Express</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js 提示—承诺、Socket.io 和在 Express 中传递数据</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/node-js-tips-promises-socket-io-and-passing-data-in-express-db98d4b14105?source=collection_archive---------9-----------------------#2020-07-14">https://blog.devgenius.io/node-js-tips-promises-socket-io-and-passing-data-in-express-db98d4b14105?source=collection_archive---------9-----------------------#2020-07-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a4675deb089d632c0d0b58b726a6c7c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1YTnFXWTXQ1-EeXC"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">戴夫·弗朗西斯在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="709a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，当我们编写节点应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些编写节点应用程序时常见问题的解决方案。</p><h1 id="b3a1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在 NodeJS 模块中共享常量</h1><p id="89bb" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过导出一个冻结的对象来共享节点模块中的常量。</p><p id="25a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><p id="1d40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">constants.js</code></p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b1ff" class="mq lc iq mh b gy mr ms l mt mu">module.exports = Object.freeze({<br/>  FOO: 'foo',<br/>  BAR: '123'<br/>});</span></pre><p id="cb88" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe me mf mg mh b">Object.freeze</code>方法来冻结带有常量的对象。</p><p id="8294" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在另一个模块中，我们可以通过编写来要求:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="eb61" class="mq lc iq mh b gy mr ms l mt mu">const constants = require('./constants');</span></pre><h1 id="3aa1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用 Socket.io 向除发送方以外的所有客户端发送响应</h1><p id="79f1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">有多种方法可以用 Socket.io 向除发送方以外的所有客户端发送响应。</p><p id="6c47" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">哟只发给发件人，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4278" class="mq lc iq mh b gy mr ms l mt mu">socket.emit('message', "hello");</span></pre><p id="45d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要发送给除发送者之外的所有客户端，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b520" class="mq lc iq mh b gy mr ms l mt mu">socket.broadcast.emit('message', "hello");</span></pre><p id="9099" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要发送给房间中除发送者之外的所有客户端，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e0dd" class="mq lc iq mh b gy mr ms l mt mu">socket.broadcast.to('chatRoom').emit('message', 'hello');</span></pre><p id="f63c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要发送给包括发件人在内的所有客户，我们写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="27d5" class="mq lc iq mh b gy mr ms l mt mu">io.emit('message', "hello");</span></pre><p id="eeef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要发送给房间中的所有客户，包括发送者，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="911a" class="mq lc iq mh b gy mr ms l mt mu">io.in('chatRoom').emit('message', 'hello');</span></pre><p id="608f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要发送给只在一个房间里的发送者，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7265" class="mq lc iq mh b gy mr ms l mt mu">socket.to('<!-- -->chatRoom<!-- -->').emit('message', 'hello');</span></pre><p id="c67d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要发送给名称空间中的所有客户端，我们可以编写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a210" class="mq lc iq mh b gy mr ms l mt mu">io.of('namespace').emit('message', 'hello');</span></pre><p id="e09e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要发送一个套接字 ID，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="71d2" class="mq lc iq mh b gy mr ms l mt mu">socket.broadcast.to(socketId).emit('message', 'hello');</span></pre><h1 id="eeb4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用像 Q 或蓝鸟这样的 Promise 库的理由</h1><p id="708c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用像 Q 或 Bluebird 这样的 promise 库将现有的异步函数转换为返回 promise。</p><p id="5415" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8a8a" class="mq lc iq mh b gy mr ms l mt mu">const Promise = require('bluebird');<br/>const fs = Promise.promisifyAll(require('fs'));</span><span id="3742" class="mq lc iq mh b gy mv ms l mt mu">fs.readFileAsync('foo.text').then((data) =&gt; {<br/>   //...<br/>});</span></pre><p id="0e32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用蓝鸟将<code class="fe me mf mg mh b">fs</code>模块中的一切转换成承诺。</p><p id="5966" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以使用<code class="fe me mf mg mh b">readFileAsync</code>这样的方法来异步读取文件。</p><p id="c425" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有一些方法是蓝鸟独有的，ES6 <code class="fe me mf mg mh b">Promise</code>构造函数没有这些方法。</p><p id="30b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Promise.promisify()</code>将节点回调转换为承诺。</p><p id="e4d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将数组映射到承诺。</p><p id="b36f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Promise.reduce()</code>让我们将值映射到承诺，然后依次调用它们，并将解析后的值缩减为一个值。</p><p id="4e57" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Promise.mapSeries()</code>获取值，将它们映射到承诺，并连续运行它们。</p><p id="ac1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后我们得到它们的值。</p><p id="e2c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们在给定的毫秒数内完成一个承诺。</p><h1 id="5f0e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Node.js 全局变量</h1><p id="ece6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以给<code class="fe me mf mg mh b">global</code>添加一个属性来添加一个全局变量。</p><p id="7b67" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="082d" class="mq lc iq mh b gy mr ms l mt mu">global._ = <!-- -->require('underscore');</span></pre><h1 id="fa31" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Node.js 获取文件扩展名</h1><p id="128e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">extname</code>方法得到一个文件名的文件扩展名。</p><p id="9f93" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8f69" class="mq lc iq mh b gy mr ms l mt mu">const path = require('path');<br/><br/>path.extname('index.html');</span></pre><h1 id="c242" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">从命令行运行脚本中的函数</h1><p id="ef5b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">node -e</code>从命令行运行脚本中的函数。</p><p id="aa12" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们有一个模块，我们可以写:</p><p id="3f67" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">hi.js</code></p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8298" class="mq lc iq mh b gy mr ms l mt mu">module.exports.hello = () =&gt; {<br/>  console.log('hello');<br/>};</span></pre><p id="fee3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a2ca" class="mq lc iq mh b gy mr ms l mt mu">node -e 'require("./hi").hello()'</span></pre><h1 id="7be0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Express.js 中 res.send 和 res.json 的区别</h1><p id="ebf6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当数组或对象被传入时，<code class="fe me mf mg mh b">res.send</code>和<code class="fe me mf mg mh b">res.json</code>是相同的。</p><p id="b83e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，如果传入的是非对象，那么<code class="fe me mf mg mh b">res.json</code>也会将这些值转换成可以返回的值。</p><p id="ea7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">res.json</code>最后调用<code class="fe me mf mg mh b">res.send</code>。</p><h1 id="0cc2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用 Express.js 中的 Next()将变量传递给下一个中间件</h1><p id="0efd" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们向<code class="fe me mf mg mh b">req</code>变量添加一个属性，将数据传递给下一个中间件。</p><p id="2f41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="48f8" class="mq lc iq mh b gy mr ms l mt mu">req.foo = 'bar';</span></pre><p id="736c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以在下一个中间件中访问<code class="fe me mf mg mh b">req.foo</code>。</p><p id="534e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以向<code class="fe me mf mg mh b">res.locals</code>属性添加一个属性来做同样的事情。</p><h1 id="3057" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用 Node.js 加密创建 HMAC-SHA1 散列</h1><p id="1cd5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用节点加密模块来创建 HMAC-SHA1 散列。</p><p id="3d8b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="88e6" class="mq lc iq mh b gy mr ms l mt mu">const crypto = require('crypto')<br/><br/>const text = 'hello world';<br/>const key = 'secret';<br/><br/>crypto.createHmac('sha1', key)<br/>  .update(text)<br/>  .digest('hex')</span></pre><p id="2035" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe me mf mg mh b">createHmac</code>方法从<code class="fe me mf mg mh b">key</code>创建一个散列。</p><p id="c42f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用<code class="fe me mf mg mh b">update</code>把<code class="fe me mf mg mh b">text</code>和它散列，用<code class="fe me mf mg mh b">update</code>把它转换成十六进制。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/7aef631ca32d901ed5d3144a9539a7a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vXIGT95yyxFPVVNl"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@judithprins?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">朱迪思·普林斯</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><h1 id="c18c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="2a61" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">crypto</code>模块来散列文本。</p><p id="7753" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用 socket.io 发送数据有很多种方法。</p><p id="4cdd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">path</code>模块得到一个文件的扩展名。</p><p id="2786" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Promise 库还是有用的。</p><p id="c8eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">global</code>是节点中的全局对象。</p></div></div>    
</body>
</html>