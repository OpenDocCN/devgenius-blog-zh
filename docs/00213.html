<html>
<head>
<title>Time Complexity with Big-O-notation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大O符号的时间复杂度</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/big-o-notation-f178bcbdaab0?source=collection_archive---------2-----------------------#2020-05-14">https://blog.devgenius.io/big-o-notation-f178bcbdaab0?source=collection_archive---------2-----------------------#2020-05-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="deba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">表达每个算法的时间复杂度。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d8b88c012c9c329fca0c2ae820115fbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fv2ZyDTpaBChRB-LvMPogg.png"/></div></div></figure><p id="38ea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个故事中，我将深入浅出地解释<em class="ku">算法和数据结构</em>中最重要的概念之一。</p></div><div class="ab cl kv kw hr kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ig ih ii ij ik"><p id="5a3f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">什么是时间复杂性？</strong></p><p id="5c57" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">很‘简单’，<em class="ku"> </em> <strong class="jm io"> <em class="ku">时间复杂度就是一个任务执行的次数。</em> </strong> <em class="ku"> </em>非常明确的是，它不是一项任务完成所花费的时间。</p><p id="24ce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们举个例子来了解一下。假设你有100个房间，你需要找到其中一个房间里的人。那你是做什么的？</p><p id="d913" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">简单地说，你在每个房间里一个接一个地寻找，直到你找到那个人。在这种情况下，你可能要搜索所有的100个房间才能找到那个人。这意味着你需要执行100次搜索，这就是我们所说的这项任务的“时间复杂度”。再说一次，这和搜索那个人的时间没有任何关系。</p><p id="1eae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"><em class="ku">Big-O-notation</em></strong>用于表示这个时间复杂度，所以在这种情况下，搜索人的时间复杂度将是O(100)</p></div><div class="ab cl kv kw hr kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ig ih ii ij ik"><p id="e4a0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">为什么大O符号很重要？</strong></p><p id="a1d8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它有助于了解你对问题的解决方案(算法)的效率。它帮助您比较解决方案的效率。并做出决定。</p><p id="3ad8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">计算时间复杂度是非常容易的。只要遵循这些经验法则:</p><ul class=""><li id="9a44" class="lc ld in jm b jn jo jr js jv le jz lf kd lg kh lh li lj lk bi translated"><strong class="jm io">增加个别发言的时间复杂性</strong></li></ul><pre class="kj kk kl km gt ll lm ln lo aw lp bi"><span id="0007" class="lq lr in lm b gy ls lt l lu lv"><strong class="lm io">for(0...n){...} // O(n)<br/>for(0...m){...} // O(n+m)<br/>for(0...i){...} // O(n+m+i)</strong></span></pre><p id="426b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个例子中，我们有三个<em class="ku">用于</em>循环，这意味着第一个循环将执行某个东西<em class="ku"> n </em>次，第二个循环<em class="ku"> m </em>次，第三个循环<em class="ku"> i </em>次，但它们都是单独的循环。因此，我们将增加时间复杂性。</p><ul class=""><li id="66c2" class="lc ld in jm b jn jo jr js jv le jz lf kd lg kh lh li lj lk bi translated"><strong class="jm io">增加嵌套语句的时间复杂度</strong></li></ul><pre class="kj kk kl km gt ll lm ln lo aw lp bi"><span id="cd97" class="lq lr in lm b gy ls lt l lu lv"><strong class="lm io">for(0...n){              // O(n)<br/>   for(0...m){           // O(n*m)<br/>       for(0...i){       // O(n*m*i)<br/>          ......<br/>       }<br/>   }<br/>}</strong></span></pre><p id="98d8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本例中，我们为循环嵌套了<em class="ku">，这意味着第一个循环将执行第二个循环<em class="ku"> n次</em>次，同样，第二个循环将执行第三个循环<em class="ku"> m次</em>次，最后第三个循环将执行<em class="ku"> i </em>次。所以，我们将分别乘以所有的时间复杂度。</em></p><ul class=""><li id="94b8" class="lc ld in jm b jn jo jr js jv le jz lf kd lg kh lh li lj lk bi translated"><strong class="jm io">移除系数</strong></li></ul><pre class="kj kk kl km gt ll lm ln lo aw lp bi"><span id="cce0" class="lq lr in lm b gy ls lt l lu lv"><strong class="lm io">for(0...n){...} // O(n)<br/>for(0...n){...} // O(n+n)<br/>for(0...n){...} // O(n+n+n) = O(3n) = O(n)</strong></span></pre><p id="0e23" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个例子中，我们有<em class="ku">用于具有相同迭代的</em>循环。我们可以简化这样的表达式。所以，<em class="ku"> O(n+n+n) </em>可以表示为<em class="ku"> O(3n) </em>最后<em class="ku"> O(n) </em>去掉系数。</p><ul class=""><li id="e214" class="lc ld in jm b jn jo jr js jv le jz lf kd lg kh lh li lj lk bi translated"><strong class="jm io">去除较小的时间复杂度</strong></li></ul><pre class="kj kk kl km gt ll lm ln lo aw lp bi"><span id="ee31" class="lq lr in lm b gy ls lt l lu lv"><strong class="lm io">for(0...n){...} //                  O(n)<br/>for(0...m){...} // note : m &lt; n/2   O(n)<br/>for(0...p){...} // note : p &lt; m/2   O(n)</strong></span></pre><p id="f133" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个例子中，对于循环，我们有不同的<em class="ku">，但是对于某些关系，例如第二循环将迭代少于第一循环的一半时间(m &lt; n/2)，第三循环将迭代少于第二循环的一半时间(p &lt; m/2)。因此，在这种情况下，我们可以删除较小的复杂性，因为它们小于最大复杂性的一半。</em></p><p id="c72b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ku">注意:只有当你知道复杂度小于最大复杂度的一半时，才移除复杂度。</em></p><ul class=""><li id="bed9" class="lc ld in jm b jn jo jr js jv le jz lf kd lg kh lh li lj lk bi translated"><strong class="jm io">删除常量</strong></li></ul><pre class="kj kk kl km gt ll lm ln lo aw lp bi"><span id="3233" class="lq lr in lm b gy ls lt l lu lv"><strong class="lm io">for(0..10) {...} // O(10)<br/>for(0...n) {     // O(10 + n)<br/>   for(0...m) {  // O(10 + n*m) = O(n*m)<br/>        ...<br/>   }<br/>}</strong></span></pre><p id="a46c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个例子中，我们有一个执行10次的循环的<em class="ku">,然后有一个执行n * m次的</em>循环的嵌套<em class="ku">。如果您有像本例中这样的非常量复杂性，您可以删除常量复杂性。你可能想知道为什么我们能做到这一点？</em>因为n和m都是变量。它们可以有从0到无穷大的值，考虑到这种开放的可能性，常量复杂性可以忽略。</p></div><div class="ab cl kv kw hr kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ig ih ii ij ik"><p id="4bfa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">常见的复杂性</strong></p><p id="a5c5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">尽管不同的问题和算法有不同的复杂性，但都有其独特的大O符号表达式。但是，几乎每个算法都有一定的复杂性。</p><ul class=""><li id="2b29" class="lc ld in jm b jn jo jr js jv le jz lf kd lg kh lh li lj lk bi translated"><strong class="jm io"> O(1) constant，</strong>其中执行次数为常数且已知，类似于数组中的随机存取。</li></ul><p id="fdba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ku">注意:这里的</em> <strong class="jm io"> <em class="ku"> 1 </em> </strong> <em class="ku">只代表一个常数，它可能是</em><strong class="jm io"><em class="ku">O(2)</em></strong><em class="ku">或</em><strong class="jm io"><em class="ku">O(99)</em></strong><em class="ku">取决于你的执行次数。</em></p><ul class=""><li id="303f" class="lc ld in jm b jn jo jr js jv le jz lf kd lg kh lh li lj lk bi translated"><strong class="jm io"> O(n)线性，</strong>数组、链表中的线性搜索。</li><li id="4618" class="lc ld in jm b jn lw jr lx jv ly jz lz kd ma kh lh li lj lk bi translated">O(log n)对数，当你只需要遍历一半的元素就可以执行操作时，比如在二叉查找树中搜索，在有序数组中搜索等等，你就得到这个时间复杂度。</li><li id="524f" class="lc ld in jm b jn lw jr lx jv ly jz lz kd ma kh lh li lj lk bi translated"><strong class="jm io"> O(n log n) linearithmic，</strong>合并、快速排序等排序算法。在这些排序算法中，你每次都将列表分成两半，这是一个<em class="ku"> O(log n)复杂度</em>，但是然后你在合并时将数字相互比较，这是一个<em class="ku"> O(n)复杂度</em>。这就是为什么整体复杂度是<em class="ku"> O(n log n) </em></li><li id="616c" class="lc ld in jm b jn lw jr lx jv ly jz lz kd ma kh lh li lj lk bi translated"><strong class="jm io"> O(n)二次，</strong>遍历矩阵(二维数组)，冒泡排序。让我们借助矩阵遍历来理解二次复杂度。考虑一个矩阵，每行有<em class="ku"> n行</em>和<em class="ku"> n列</em>。我必须访问矩阵的每个元素。对于每一行，我必须通过n列，总共有n行<em class="ku"/>。那么，<em class="ku">“访问一个元素”执行了多少次？</em>它的<em class="ku"> n*n </em>那就是'<em class="ku">二次复杂度'</em>。</li><li id="9587" class="lc ld in jm b jn lw jr lx jv ly jz lz kd ma kh lh li lj lk bi translated"><strong class="jm io"> O(2^n)指数，</strong>识别给定集合中的所有组合。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/7d801d7113c5180ae4d338c0a004791e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*jzFzw9jD6AAZdoph8zIVBQ.png"/></div></figure></div><div class="ab cl kv kw hr kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ig ih ii ij ik"><p id="cd1c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，<strong class="jm io">您认为哪种解决方案更高效？公平地说，这要视情况而定，对于复杂的问题，你会有更复杂的解决方案；对于简单的问题，你会有简单的解决方案。知道它们的时间复杂性是好的，但是比较这两种解决方案来看哪一种更有效是没有意义的。当同一问题有多个不同时间复杂度的解决方案，而您想要选择其中一个时，确定效率是有意义的。</strong></p></div></div>    
</body>
</html>