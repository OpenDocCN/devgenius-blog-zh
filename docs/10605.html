<html>
<head>
<title>Day 125 of Unity Dev: Simple Callback System using Delegates &amp; Coroutines— Unity/C#!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Unity 开发的第 125 天:使用委托和协程的简单回调系统——Unity/c#！</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/day-125-ofunity-dev-simple-callback-system-using-delegates-coroutines-unity-c-8b83219577ea?source=collection_archive---------5-----------------------#2022-11-15">https://blog.devgenius.io/day-125-ofunity-dev-simple-callback-system-using-delegates-coroutines-unity-c-8b83219577ea?source=collection_archive---------5-----------------------#2022-11-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="ea3b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">目标:使用代理和协程创建一个系统，当事情结束时通知其他人。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/be6a024637a6d409cef68fa4ee3ab568.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*EfSTumfv3knX_5SXr6z48g.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated"><a class="ae ku" href="https://www.avenga.com/magazine/future-csharp-programming-language/" rel="noopener ugc nofollow" target="_blank">图片来源</a></figcaption></figure><p id="6800" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将是一个简单的演示，可以很好地推断，为您的程序提供灵活性。虽然这是一个简单的演示，但是如果你不熟悉委托、动作、协程或 lambdas，请不要觉得太难了。如果你想熟悉这些话题，我会把它们链接到这里</p><p id="ac5b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/day-94-of-game-dev-how-do-coroutines-work-behind-the-curtains-507f11b4d6a7">协程</a>篇</p><p id="515a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/day-122-of-game-dev-delegates-events-unity-c-44225f250ffc">代表们</a>条</p><p id="d1f5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/day-123-of-game-dev-action-and-function-type-delegates-unity-c-6eb832d0c21c">动作和 Func 类型委托</a>条</p><p id="2b91" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/day-124-of-unity-dev-lambda-expressions-unity-c-524dd467c2"> Lambdas </a>文章</p><p id="c145" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">假设在我们的项目中，我们想在一个协程完成后调用一些代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi kv"><img src="../Images/c14b4c017cc495fead0dd7fc242275e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*tYW8PnT6IzQE5NZh2d00Bg.png"/></div></figure><p id="12c3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果需要，我们还可以加入一个或两个自定义方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi kw"><img src="../Images/39f63601219a0031d83c22742f262c9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*appta3MsdaWZ6FwG_pOnVw.png"/></div></figure><p id="c3e8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是，如果我们只需要一个在协程完成后运行的简单函数，并且我们不想创建一个像 ExampleMethod()这样的自定义方法来执行这个简单函数，但是我们也不想将所有代码都塞进协程中，那该怎么办呢？我们可以用一个动作+一个匿名方法(lambda 表达式)。</p><p id="e852" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，在协程中，我们可以添加一个 Action 类型的参数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi kx"><img src="../Images/fdac2bb5c20ad007b53d549cad8b3823.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*Uj6dWhpUMOOWjByD_pLUyg.png"/></div></figure><p id="49d8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如你在这里看到的，我们得到了一个错误，因为当我调用协程时，我没有向它传递任何东西，这意味着我没有填充参数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ky"><img src="../Images/a511a8cfc2bbcd3eff6579899aab27f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*NsnWXzD3jNTq1T469Z_tNg.png"/></div></figure><p id="4567" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我在参数中将 onComplete 动作设置为 null，它就变成了一个选项。现在我可以调用协程，不管有没有传入那个参数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi kz"><img src="../Images/439088b773fca58aae1a5ad99b03fd41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*Fmag6rOEBeaszU0AoWf-4g.png"/></div></figure><p id="b4c6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">附注:确保从协程中实际调用 onComplete 操作，并且在调用时对其进行空检查。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi la"><img src="../Images/4d081e112afc93f49d3afe7945b99d8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*g6_qfoLESHVYjCZOI5CGXA.png"/></div></figure><p id="04f6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">回到 Start()，当我调用协程时，我可以用两种不同的方式使用 lambda 创建一个匿名方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi lb"><img src="../Images/6cafaabe0f30999cdc696805351b590e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e5u_3vML6ryJ616oShfNIg.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">单线方式</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lg"><img src="../Images/09584506357478314129aa84c2a340ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*J4lozxJBCI8WqhKkxEKmLA.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">多线方式</figcaption></figure><p id="fda0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用它，我不必为这些简单函数(或其他简单函数)创建一个带有名称的定制方法，也不必在我的协程中包含所有内容。虽然在大多数情况下，对于这样一个小例子来说，这并不是一个很大的改进。当你试图构建你的程序时，试着保持这种可能性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lh"><img src="../Images/77c7f7e985e1aef635570be81140ff95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*JkCUyIVyT_XUczbZUWnDHg.png"/></div></figure><p id="5afa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我的协程易于阅读，代码被分离出来。现在，当我在 Unity 编辑器中按下 play 时，5 秒钟后，传入的动作委托中的代码将被调用</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi li"><img src="../Images/e50feee56b3c9467a0a9dec1dc28520f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Z7FbbdMXwdWN_xQfenPnww.gif"/></div></div></figure><p id="4001" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="lj">如有任何想法或问题，欢迎评论。让我们制作一些令人敬畏的游戏！</em>T3】</strong></p></div></div>    
</body>
</html>