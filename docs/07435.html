<html>
<head>
<title>Asynchronous Javascript Practical Explanation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步 Javascript 实用解释</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/asynchronous-javascript-practical-explanation-c9613f97f2ca?source=collection_archive---------2-----------------------#2022-03-25">https://blog.devgenius.io/asynchronous-javascript-practical-explanation-c9613f97f2ca?source=collection_archive---------2-----------------------#2022-03-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/275daa39782478b94c50c09d0bbd5e69.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*fWRqdnc06MFxMQorAzzrBA.png"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk translated">java 描述语言</figcaption></figure><p id="7d82" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可能听说过 Javascript 天生就是异步的。那么，什么是异步呢？我们如何在 Javascript 代码中实现或利用它呢？我会尽量用 Javascript 解释异步。这是一个<strong class="jx io">中级</strong>主题，我希望读者对 Javascript 或一般编程有一个基本的了解。</p><h2 id="32b9" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">同步与异步</h2><p id="2c01" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">我将只从实用的角度解释同步(<strong class="jx io"> sync </strong>)和异步(<strong class="jx io"> async </strong>)。在同步过程中，我们一次做一个任务<strong class="jx io"/>。我们只做下一个任务，直到前一个任务完成，即使这个任务只是一个等待的任务。在异步过程中，如果我们遇到不需要我们全神贯注的长任务，我们不是等待任务完成，而是先做其他事情。如果长任务完成了，我们得到它的结果并处理它。</p><p id="2712" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">想象一下，如果你有以下任务:<strong class="jx io">烧水</strong>，<strong class="jx io">扫地</strong>，<strong class="jx io">洗碗</strong>，<strong class="jx io">泡茶</strong>。在同步过程中，我们打开暖气把水烧开，等几分钟让水烧开，然后关火，扫地，洗碗，然后沏茶。然而，在异步过程中，我们打开暖气烧水，然后立即扫地，洗碗，只有当水烧开时，我们才关掉暖气，然后泡茶。请看下图，以便更容易理解。</p><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi lr"><img src="../Images/e9b82ffd0135c22b39321b76ecace592.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hRDfyiYqOCh_-N0t8E-9PA.png"/></div></div><figcaption class="jr js gj gh gi jt ju bd b be z dk translated">同步与异步流程</figcaption></figure><p id="f3bd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">大多数时候，我们程序中的代码是以同步的方式运行的。常见的例子有数学/字符串运算、变量声明/赋值、解析或转换对象、编码等等。我们经常遇到的异步进程是 I/O 操作，如<strong class="jx io">查询数据库</strong>、<strong class="jx io"> HTTP 请求</strong>和<strong class="jx io">读取文件</strong>。</p><h1 id="d2dc" class="ma ku in bd kv mb mc md ky me mf mg lb mh mi mj le mk ml mm lh mn mo mp lk mq bi translated">让我们开始编码吧！</h1><p id="d04d" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">在这个故事中，我将使用<a class="ae mr" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> NodeJS </a>运行 Javascript 作为示例。然而，所解释的异步概念也可以在浏览器中运行的 Javascript 代码中实现。你可以在这里安装 NodeJS <a class="ae mr" href="https://nodejs.org/en/download/" rel="noopener ugc nofollow" target="_blank">如果你还没有的话。</a></p><p id="6043" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将把<strong class="jx io"> HTTP 请求</strong>作为异步流程示例。HTTP 请求是我前面提到的长时间等待任务的一个例子。我不会像其他教程一样使用设置超时或睡眠功能，因为它根本不实用，我们不会在实际应用中使用它们。</p><p id="23b5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建一个名为<strong class="jx io"> async-demo </strong>的新文件夹，并在其中创建名为<strong class="jx io"> index.js </strong>的文件。我们将使用<a class="ae mr" href="https://www.npmjs.com/package/axios" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> axios </strong> </a> <strong class="jx io"> </strong>包来处理 HTTP 请求。让我们用 npm 安装它。打开 async-demo 文件夹中的终端或命令提示符，键入以下命令。</p><pre class="ls lt lu lv gt ms mt mu mv aw mw bi"><span id="7228" class="kt ku in mt b gy mx my l mz na">npm install axios</span></pre><p id="51cb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们从我发现的一个<a class="ae mr" href="https://aakhilv.notion.site/aakhilv/api-aakhilv-me-a57b3dc3e4e2449ba4dcce5ddee1c684" rel="noopener ugc nofollow" target="_blank">公共 api </a>中获得一些有趣的事实。</p><h2 id="a61b" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">索引. js</h2><pre class="ls lt lu lv gt ms mt mu mv aw mw bi"><span id="7030" class="kt ku in mt b gy mx my l mz na">const axios = require('axios');</span><span id="4297" class="kt ku in mt b gy nb my l mz na">function main() {<br/>  console.log('Begin');<br/>  const result = axios.get('<a class="ae mr" href="https://api.aakhilv.me/fun/facts'" rel="noopener ugc nofollow" target="_blank">https://api.aakhilv.me/fun/facts'</a>);<br/>  console.log('End');<br/>}</span><span id="7840" class="kt ku in mt b gy nb my l mz na">main();</span></pre><p id="4012" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里，我们有一个主要功能。我们在主函数的开头和结尾使用 console.log 编写 Begin 和 End。在这之间，我们使用 axios.get 向<a class="ae mr" href="https://api.aakhilv.me/fun/facts" rel="noopener ugc nofollow" target="_blank"> fun fact 公共 api </a>发出 HTTP 请求。让我们用<strong class="jx io"> node index.js </strong>命令运行它。</p><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/2ff8647a10f05bf51c03e05079aa8964.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*3fUFhQSnJWnHuE4Sr02ANQ.png"/></div></figure><p id="3bc1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里没什么特别的。你可能会注意到在我们的节目结束前有一点延迟。这是 HTTP 请求所需的时间。让我们试着记录结果</p><pre class="ls lt lu lv gt ms mt mu mv aw mw bi"><span id="57c3" class="kt ku in mt b gy mx my l mz na">function main() {<br/>  console.log('Begin');<br/>  const result = axios.get('<a class="ae mr" href="https://api.aakhilv.me/fun/facts'" rel="noopener ugc nofollow" target="_blank">https://api.aakhilv.me/fun/facts'</a>);<br/>  console.log('result:', result);<br/>  console.log('End');<br/>}</span></pre><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/c88ae08c8357212d2e85dd03d7de08df.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*cSl1W8E4OsELrSwHKRt80A.png"/></div></figure><p id="2d53" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们看到的不是 HTTP 请求结果，而是一些奇怪的东西。<strong class="jx io">承诺{ &lt;待定&gt; } </strong>。这是什么？Javascript 中的一个<a class="ae mr" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">承诺</strong> </a>是一个尚未兑现的值。该值应该由长时间等待的任务(即 HTTP 请求)返回。然而，我们没有等待 HTTP 请求，而是立即记录结果。这种行为称为<strong class="jx io">非阻塞</strong>函数调用。</p><blockquote class="nd ne nf"><p id="ccd6" class="jv jw ng jx b jy jz ka kb kc kd ke kf nh kh ki kj ni kl km kn nj kp kq kr ks ig bi translated">Javascript 中的一个<strong class="jx io">异步函数</strong>是一个长时间等待的任务，它返回一个<strong class="jx io">承诺</strong>。</p></blockquote><p id="897c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那么我们实际上如何记录 HTTP 请求结果呢？我们可以使用<strong class="jx io"> then </strong>语法编写一个<strong class="jx io">回调</strong>函数，在 axios.get 中的 HTTP 请求之后运行。</p><pre class="ls lt lu lv gt ms mt mu mv aw mw bi"><span id="4a77" class="kt ku in mt b gy mx my l mz na">function main() {<br/>  console.log('Begin');<br/>  const url = '<a class="ae mr" href="https://api.aakhilv.me/fun/facts'" rel="noopener ugc nofollow" target="_blank">https://api.aakhilv.me/fun/facts'</a>;<br/>  axios.get(url).then(function (result) {<br/>    console.log('result:', result.data);<br/>  });<br/>  console.log('End');<br/>}</span></pre><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/c5adc37a13b4973d76bee25860401043.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*UYVc1nnKNBPZPD8uBq8p8g.png"/></div></figure><p id="453a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们已经记录了结果。但是等等！你注意到什么奇怪的事情了吗？如果您查看输出，Begin 和 End 在结果之前首先被记录。这是个 bug 吗？<strong class="jx io">不，不是</strong>。你还记得异步过程的解释吗？我们的程序没有等待 axios.get 结果，而是先转移到下一个任务，即记录“End”。那么，在记录 HTTP 请求结果之后，我们如何记录 End 呢？简单，我们把它放在回调函数里面。</p><pre class="ls lt lu lv gt ms mt mu mv aw mw bi"><span id="5b40" class="kt ku in mt b gy mx my l mz na">function main() {<br/>  console.log('Begin');<br/>  const url = '<a class="ae mr" href="https://api.aakhilv.me/fun/facts'" rel="noopener ugc nofollow" target="_blank">https://api.aakhilv.me/fun/facts'</a>;<br/>  axios.get(url).then(function (result) {<br/>    console.log('result:', result.data);<br/>    console.log('End');<br/>  });<br/>}</span></pre><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/5c1e2a3739e65e150cb287c3f6ac835d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/1*XOgypogXG7oO7jiG5sPyAA.png"/></div></figure><p id="106a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在它如我们所愿地工作了。暂时如此。在实际的生产应用程序中，我们会将 HTTP 请求包装在某个函数中(在我们的主函数之外)。在函数内部，我们会做一些操作，或者只是解析或转换 HTTP 响应。在前面的输出中，我们注意到 HTTP 请求的结果在数组中，所以我们只需要结果的第一个元素。让我们重写代码，并将 HTTP 请求包装在一个<strong class="jx io"> getFact </strong>函数中。</p><pre class="ls lt lu lv gt ms mt mu mv aw mw bi"><span id="8b1b" class="kt ku in mt b gy mx my l mz na">function getFact() {<br/>  const url = '<a class="ae mr" href="https://api.aakhilv.me/fun/facts'" rel="noopener ugc nofollow" target="_blank">https://api.aakhilv.me/fun/facts'</a>;<br/>  return axios.get(url).then(function (result) {<br/>    return result.data[0];<br/>  });<br/>}</span><span id="50dd" class="kt ku in mt b gy nb my l mz na">function main() {<br/>  console.log('Begin');<br/>  getFact().then(function (result) {<br/>    console.log('result:', result);<br/>    console.log('End');<br/>  });<br/>}</span></pre><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/b409ad7853e79ae94296a4ef66830c8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*0JMAUOYX3emHpJ7DwvW5pQ.png"/></div></figure><p id="a01f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是现实生活中的应用程序代码的样子。<strong class="jx io">或者是？</strong>让我们提高复杂度。比方说，如果我们想让<strong class="jx io">得到两个</strong>有趣的事实，而不是一个。我们该怎么办？我们将在第一个 getFact 的回调函数中再次调用 getFact。它看起来会像这样。</p><pre class="ls lt lu lv gt ms mt mu mv aw mw bi"><span id="bd57" class="kt ku in mt b gy mx my l mz na">function main() {<br/>  console.log('Begin');<br/>  getFact().then(function (result) {<br/>    console.log('result:', result);<br/>    getFact().then(function (secondResult) {<br/>      console.log('second result:', secondResult);<br/>      console.log('End');<br/>    });<br/>  });<br/>}</span></pre><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi nn"><img src="../Images/19054e1b91389bbeea29a1d5d6b27719.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ECxyhyFkS-H5FMF2NBJZNg.png"/></div></div></figure><p id="0f95" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这应该行得通。然而，你注意到我们的代码变得越来越乱了吗？在真实的场景中，我们会有更多的异步流程。比方说，如果我们想得到五个有趣的事实，我们的代码会变得非常快。</p><pre class="ls lt lu lv gt ms mt mu mv aw mw bi"><span id="ec14" class="kt ku in mt b gy mx my l mz na">function main() {<br/>  console.log('Begin');<br/>  getFact().then(function (result) {<br/>    console.log('result:', result);<br/>    getFact().then(function (secondResult) {<br/>      console.log('second result:', secondResult);<br/>      getFact().then(function (thirdResult) {<br/>        console.log('third result:', thirdResult);<br/>        getFact().then(function (fourthResult) {<br/>          console.log('fourth result:', fourthResult);<br/>          getFact().then(function (fifthResult) {<br/>            console.log('fifth result:', fifthResult);<br/>            console.log('End');<br/>          });<br/>        });<br/>      });<br/>    });<br/>  });<br/>}</span></pre><p id="b21e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不要担心！对这个问题有一个更好的解决方法。</p><h1 id="74e8" class="ma ku in bd kv mb mc md ky me mf mg lb mh mi mj le mk ml mm lh mn mo mp lk mq bi translated">异步/等待</h1><p id="7083" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">异步和等待语法来拯救！带有<strong class="jx io"> async </strong>关键字的函数将<strong class="jx io">将其任何返回值转换为<strong class="jx io">承诺</strong>。显然，具有异步语法的函数在 Javascript 中被称为<strong class="jx io">异步函数</strong>。<strong class="jx io">wait</strong>语法让我们暂停执行并获得异步函数的结果。注意<strong class="jx io"> await 语法只能在异步函数</strong>中使用。例如，让我们重写 getFact 函数。</strong></p><pre class="ls lt lu lv gt ms mt mu mv aw mw bi"><span id="b9bc" class="kt ku in mt b gy mx my l mz na">async function getFact() {<br/>  const url = '<a class="ae mr" href="https://api.aakhilv.me/fun/facts'" rel="noopener ugc nofollow" target="_blank">https://api.aakhilv.me/fun/facts'</a>;<br/>  const result = await axios.get(url);<br/>  return result.data[0];<br/>}</span></pre><p id="564c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们所做的只是在 function 关键字前面添加 async 关键字，并使用 await 关键字将 HTTP 请求结果存储在一个变量中，而不是使用讨厌的回调函数语法。即使我们不显式返回一个承诺，<strong class="jx io"> result.data[0] </strong>也会转换成一个承诺作为这个函数的返回值。现在，让我们重写我们的主函数。为了简单起见，让我们先做两个有趣的事实。</p><pre class="ls lt lu lv gt ms mt mu mv aw mw bi"><span id="4b31" class="kt ku in mt b gy mx my l mz na">async function main() {<br/>  console.log('Begin');<br/>  const result = await getFact();<br/>  console.log('result:', result);<br/>  const secondResult = await getFact();<br/>  console.log('second result:', secondResult);<br/>  console.log('End');<br/>}</span></pre><p id="c985" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们还为 getFact 函数调用使用了 await 语法，而不是嵌套回调。请注意，我们需要用 async 关键字更改 main 函数，因为我们使用的是 await 语法。现在，这个程序应该仍然工作。</p><p id="aa13" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们回到五个有趣的事实。这次使用 for 循环。</p><pre class="ls lt lu lv gt ms mt mu mv aw mw bi"><span id="91cf" class="kt ku in mt b gy mx my l mz na">async function main() {<br/>  console.log('Begin');<br/>  for (let i = 1; i &lt;= 5; i++) {<br/>    const result = await getFact();<br/>    console.log(`result no.${i}:`, result);<br/>  }<br/>  console.log('End');<br/>}</span></pre><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi no"><img src="../Images/6395fd8721d27b5a5d1b8e15ae4d8d0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r_3ax3oR8ZKfau32HdmhNA.png"/></div></div></figure><p id="2233" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">应该能正常工作吧？但似乎效率不高。你注意到我们的程序已经运行了相当长的时间了吗？事实上，让我们计算一下执行的时间。我们将用 console.time 替换开始和结束日志记录。</p><pre class="ls lt lu lv gt ms mt mu mv aw mw bi"><span id="14cc" class="kt ku in mt b gy mx my l mz na">async function main() {<br/>  console.time('getFactTimer');<br/>  for (let i = 1; i &lt;= 5; i++) {<br/>    const result = await getFact();<br/>    console.log(`result no.${i}:`, result);<br/>  }<br/>  console.timeEnd('getFactTimer');<br/>}</span></pre><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div class="gh gi np"><img src="../Images/2eef7d30fc7bf05c3d601f63977081df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*eDRmj7MOOlHf_SmFCYkMsg.png"/></div></figure><p id="4fca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以看到总的执行时间是 2.965 秒。根据您的网络速度，结果可能会有所不同。这个结果可以改进。让我们来谈谈我们刚刚做的异步函数调用。我们实现的是:<strong class="jx io">在每个循环中，做 HTTP 请求并等待结果并记录</strong>。你明白效率低下吗？</p><p id="6f49" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们知道，每个 HTTP 请求都是一个长时间等待的任务。我们不是在 HTTP 请求后立即执行下一个任务，而是等待每个 HTTP 请求完成并获得结果。这基本上是一个同步的过程！是的，即使在 async/await 语法之后，我们最终还是编码了一个同步程序。事实上，没有经验的程序员可能会在现实世界中犯这种错误。</p><h1 id="e7d2" class="ma ku in bd kv mb mc md ky me mf mg lb mh mi mj le mk ml mm lh mn mo mp lk mq bi translated">承诺。所有</h1><p id="b6f0" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">我们如何解决前面例子中的低效问题？在每个 HTTP 请求之后，我们应该立即继续下一个 HTTP 请求，并且最终我们希望得到所有的结果。Javascript 为我们提供了完成这项任务的合适功能。</p><p id="d3f8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我们需要在一个数组中收集从 getFact 函数调用返回的所有承诺，然后我们使用<strong class="jx io"> Promise.all </strong>语法返回一个解析为一个值数组的承诺。因此，我们不是等待每个 getFact 结果，而是同时等待所有结果。让我们将主函数重写如下。</p><pre class="ls lt lu lv gt ms mt mu mv aw mw bi"><span id="8ced" class="kt ku in mt b gy mx my l mz na">async function main() {<br/>  console.time('getFactTimer');<br/>  const promises = [];<br/>  for (let i = 0; i &lt; 5; i++) {<br/>    promises.push(getFact());<br/>  }<br/>  const results = await Promise.all(promises);<br/>  for (let i = 0; i &lt; 5; i++) {<br/>    console.log(`result no.${i + 1}:`, results[i]);<br/>  }<br/>  console.timeEnd('getFactTimer');<br/>}</span></pre><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi nq"><img src="../Images/b6414092203da149787c9bd40c88e86a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aCCVylvG0HhFRhdht_4P2Q.png"/></div></div></figure><p id="ff1c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以看到执行时间显著减少到 600 毫秒左右。这大约是原来执行时间的 1/5。请注意，每次程序运行的结果可能仍然不同。这种 Promise.all 方法在实际生产应用程序中很常见。有时，我们需要对数据库进行多次查询，并同时进行 HTTP 请求。</p></div><div class="ab cl nr ns hr nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ig ih ii ij ik"><p id="60bb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">目前就这些。我觉得足以覆盖大部分实际的真实应用场景。更多参考，请查看 mozilla 开发者<a class="ae mr" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="ff16" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你遇到任何问题，你可以在我的 Github 库<a class="ae mr" href="https://github.com/bitsizelearning/async-demo/blob/main/index.js" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">这里</strong> </a> <strong class="jx io"> </strong>交叉检查完整的代码。</p><p id="3258" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我遗漏了什么或者有任何错误的解释，请不要犹豫回答这个故事。<strong class="jx io"> CMIIW </strong>。</p><p id="4a07" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你喜欢这个教程，请留下一些掌声来帮助频道成长:)</p></div></div>    
</body>
</html>