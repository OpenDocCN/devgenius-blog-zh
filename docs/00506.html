<html>
<head>
<title>A tool to estimate time and memory complexities of algorithms with minimum efforts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个以最小努力估计算法的时间和内存复杂性的工具</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/a-tool-to-estimate-time-and-space-complexities-of-algorithms-with-minimum-efforts-8d9a5c1e96ae?source=collection_archive---------10-----------------------#2020-06-09">https://blog.devgenius.io/a-tool-to-estimate-time-and-space-complexities-of-algorithms-with-minimum-efforts-8d9a5c1e96ae?source=collection_archive---------10-----------------------#2020-06-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/cfe1c0f18091a24e90e43294d4afc01a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zB_qRieL9zIYTeA9"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">马库斯·斯皮斯克在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="9391" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">介绍<em class="ky"> GuessCompx </em>工具，根据经验估算复杂性</p><blockquote class="kz la lb"><p id="f578" class="ka kb ky kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><strong class="kc io">功能:</strong></p><p id="73da" class="ka kb ky kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><em class="in"> GuessCompx，</em>一个R包介绍</p><p id="3a18" class="ka kb ky kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><em class="in">根据经验</em>估算算法的时间和内存复杂度的工具<em class="in"/></p></blockquote><h1 id="d0c5" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">背景</h1><p id="32b8" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">当算法或程序在计算机上运行时，它需要一些资源。对于某些输入，算法的复杂度是资源的度量。这些资源通常是空间和时间。因此，复杂性有两种类型:空间复杂性和时间复杂性。时间复杂度定义了算法完成其执行所需的时间。这可能因算法的输入而异。例如，如果所考虑的算法是冒泡排序，并且输入是排序的数组，那么时间复杂度会更低。这被称为最佳情况复杂性。当输入数组反转时，该算法需要更多的时间来对数组进行排序。这是最坏情况的复杂性。当输入数组既没有排序也没有反转时，时间复杂度介于最好情况和最坏情况的复杂度之间。这被称为平均情况复杂性。算法完成执行所需的确切时间因计算机而异。因此，我们实际上关注的是当输入大小增加时复杂性的行为。这是复杂性的渐近行为。有各种各样的符号用来表示的渐近复杂性，如大O，大ω，大θ等。在最坏的情况下，冒泡排序算法的复杂度是O( <em class="ky"> n2 </em>)。由于运行时间不能大于最坏情况，通常考虑最坏情况的复杂性。复杂度较低的算法比复杂度较高的算法更有效。所以，在开发新算法的时候，开发者需要检查它的复杂度。这个过程相当耗时。在全面运行一段新代码之前，知道它的大致执行时间可以节省很多时间。使用各种手动方法(如主定理)计算复杂度是一个繁琐的过程，并且更容易出错。这些方法正受到经验方法的挑战，这些方法试图通过观察代码运行几次来估计复杂性。</p><h1 id="c4bd" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">介绍<em class="mi"> GuessCompx </em>，一个R包</strong></h1><p id="7f15" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">软件包<a class="ae jz" href="https://CRAN.R-project.org/package=GuessCompx" rel="noopener ugc nofollow" target="_blank"> <em class="ky"> GuessCompx </em> </a>的目的是在算法最终实现之前，估计所需的计算时间和内存。复杂性受到各种因素的影响，例如数据的维度、递归预测的时间范围、特征的数量、并行计算等。但是这个包只估计了数据中行数的复杂性。其他因素不在包的范围内。该算法在数据的子集上运行，在每次运行中增加大小，如果需要，使用抽样或分层抽样。拟合各种复杂函数，并选择数据的最佳拟合。使用均方误差作为指标，通过LOO(留一法)程序实现不同模型之间的比较。内存分析使用<em class="ky"> memory.size() </em>函数，该函数只能在windows机器上运行。该软件包可以从CRAN存储库安装:</p><blockquote class="kz la lb"><p id="a54c" class="ka kb ky kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">install.packages("GuessCompx ")</p></blockquote><p id="44e4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> CompEst() </strong></p><p id="786c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个包的主要函数和唯一入口点是<em class="ky"> CompEst() </em>函数。该函数接受各种输入格式，如数据帧、矩阵、时间序列等。用户可以根据自己的需要，使用各种参数来配置函数。该函数创建一个数据大小的向量，用作输入长度。参数max.time用作循环遍历数据大小时的停止条件。max.time表示完成一次迭代的最长时间。该函数通过评估样本输入上目标函数的每次迭代所使用的时间和内存来工作。为此，在双垃圾回收前后分别使用了<em class="ky"> system.time() </em>和<em class="ky"> memory.size() </em>函数，<em class="ky"> gc() </em>。这些结果和数据一起作为复杂性模型的输入。<em class="ky"> cv.glm() </em>函数计算每个模型的LOO误差，最终选出最佳模型。数据的抽样不包括在时间和记忆的评估中。该函数返回最佳模型列表、整个数据集的计算时间、时间和内存复杂性，以及两个突出显示最佳模型曲线的图。下面给出了完整的函数调用，</p><blockquote class="kz la lb"><p id="84c6" class="ka kb ky kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">CompEst(d，f，random.sampling=FALSE，max.time=30，start.size=NULL，replicates = 4，strata=NULL，power.factor=2，alpha.value = 0.005，plot.result=TRUE)</p></blockquote><p id="a53f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mj mk ml mm b">d</code>:测试算法的数据帧</p><p id="8c7e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mj mk ml mm b">f</code>:实现算法的函数</p><p id="c571" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mj mk ml mm b">random.sampling</code>:布尔值，指定是否在每一步随机取样</p><p id="056a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mj mk ml mm b">max.time</code>:分析每一步的最大允许时间(秒)。</p><p id="70dc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mj mk ml mm b">start.size</code>:运行算法的第一个样本的大小。默认值为<em class="ky"> floor(log2(nrow(d))) </em></p><p id="e755" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mj mk ml mm b">replicates</code>:相同样本量的重复运行次数。</p><p id="f27b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mj mk ml mm b">strata</code>:包含不同类别的列名的字符串。</p><p id="c28d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mj mk ml mm b">power.factor</code>:样本量增加的数量。默认值为2，表示大小在每一步中都加倍。</p><p id="8866" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mj mk ml mm b">alpha.value</code>:检验模型是否显著不同于常数关系的alpha风险</p><p id="36c4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mj mk ml mm b">plot.results</code>:布尔值，表示是否要显示汇总图。</p><p id="49ee" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> CompEstBenchmark()和CompEstplot() </strong></p><p id="18e8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个函数提供了一个适合所有复杂性模型的基准程序。该函数接收由CompEst()函数返回的数据帧(to.model ),并返回所有拟合复杂度模型的列表。用户还需要指定函数是处理时间还是内存数据(使用)。</p><blockquote class="kz la lb"><p id="da15" class="ka kb ky kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">CompEstBenchmark(to.model，use="time ")</p></blockquote><p id="92e1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky"> CompEstplot() </em>函数绘制<em class="ky"> CompEst() </em>函数的结果。该函数的输入是由<em class="ky"> CompEst() </em> (to.plot)产生的数据帧。其他参数是<em class="ky"> element_title </em>，一个添加到情节和用途的副标题的字符串，一个指定函数是处理时间还是内存数据的字符串。该函数返回一个ggplot对象。</p><p id="e5e7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> CompEstPred() </strong></p><p id="c81b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该函数预测整个数据集的计算时间。该函数的参数是:</p><p id="a82c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mj mk ml mm b">model.list</code> <em class="ky"> model.list </em>:包含拟合复杂度函数的列表。</p><p id="7d90" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mj mk ml mm b">benchmark</code>:复杂度函数的100个误差的向量。</p><p id="793e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mj mk ml mm b">N</code>:整个数据集使用的行数，表示函数处理的是“时间”还是“内存”数据的字符串。</p><p id="d293" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">groupedsamplefracatleastosample()和head() </strong></p><p id="5e57" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">groupedsamplefracatleastosample()</em>对输入数据的随机比例进行采样。输入以数据帧的形式给出，函数返回数据的一个小样本。返回的样本包含至少1个观察值。也可以指定样本是否随机抽取。</p><p id="4e5a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky"> rhead() </em>函数用于从给定的向量或数据帧中生成小的随机样本。除了<em class="ky"> CompEst() </em>功能之外的所有功能都在内部使用，以完成不同的任务，用户不能直接访问。</p><h1 id="bd05" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">它是如何工作的？</h1><p id="d7cc" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">这个包使R用户能够在完全运行任何算法之前，凭经验估计它的计算时间和内存使用量。用户的算法是在他的数据集的一组大小不断增加的小部分上运行的。然后拟合各种模型以捕捉可能最适合算法的计算复杂性趋势(独立o(1)、线性o(n)、二次o(n2)等)。)，一个为了时间，另一个为了记忆。该模型最终会预测完整数据的时间和内存使用情况。</p><p id="9f95" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">关于算法复杂性的细节可以在维基百科页面上找到。请注意，复杂性仅与数据大小(行数)有关，而不是其他可能的参数，如特征数量、调整参数等。在软件包的未来版本中，可以研究与这些参数的相互作用。</p><p id="f398" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">已经实现的复杂度函数如下:<em class="ky"> O(1)，O(N)，O(N)，O(N)，O(N^0.5)，O(log(N))，O(N*log(N)) </em></p><p id="2de4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">大多数算法具有不随时间变化的复杂性行为:一些算法与行数无关(想想<code class="fe mj mk ml mm b">length</code>函数)，一些算法是线性的，一些算法是二次的(通常是距离计算)，等等。我们跟踪算法运行的计算时间&amp;存储数据子集的增加，如果需要，使用抽样或分层抽样。我们用一个简单的<code class="fe mj mk ml mm b">glm()</code>程序和一个<code class="fe mj mk ml mm b">glm(time ~ log(nb_rows))</code>类型的公式来拟合各种复杂函数，然后找到最适合数据的。使用均方误差作为指标，通过LOO ( <strong class="kc io">留一法</strong>)程序实现模型之间的比较。</p><p id="c688" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mj mk ml mm b">GuessCompx</code>包有一个单一的入口点:接受不同输入格式(数据、帧、矩阵、时间序列)的<code class="fe mj mk ml mm b">CompEst()</code>函数，并且完全可配置以适应大多数用例:从多大的数据开始，你需要花多长时间进行审计(通常1分钟就能给出一个好的结果)，你希望每个测试的大小有多少个重复(如果可变性很高)，你是否需要分层抽样(如果每次运行都必须包括一个变量的所有可能类别)，每次运行增加多少大小，等等。</p><p id="1749" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">关于内存复杂性的说明:内存分析依赖于<code class="fe mj mk ml mm b">memory.size()</code>函数来估计趋势，该函数仅在Windows机器上有效。如果检测到另一个操作系统，算法将跳过内存部分。</p><h1 id="d26b" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">例子</h1><p id="2c02" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">这里，<code class="fe mj mk ml mm b">CompEst()</code>用于显示<code class="fe mj mk ml mm b">dist()</code>函数的二次复杂度:</p><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="d5b8" class="mv lg in mm b gy mw mx l my mz"><strong class="mm io">CompEst</strong>(d = ggplot2::diamonds[, 5:10], f = dist, replicates = 10,       max.time = 10)</span></pre><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div class="gh gi na"><img src="../Images/4240360ae361b9b7cb0bd5e280888283.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*Aaw7LF-JqtnSGh1AF5CK7g.png"/></div></figure><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div class="gh gi na"><img src="../Images/61b35f56c33ab2fbbfc07882925a8da6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*q_1JUo2r0fCyfJ0dqfVb0A.png"/></div></figure><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="ba04" class="mv lg in mm b gy mw mx l my mz">#&gt; $sample.sizes<br/>#&gt; [1]    15    15   15    15   15    15    15    15    15    15  30<br/>#&gt; [12]   30    30   30    30   30    30    30    30    30    60  60<br/>#&gt; [23]   60    60   60    60   60    60    60    60   120   120 120<br/>#&gt; [34]  120   120  120   120   120   120   120   240  240   240 240<br/>#&gt; [45]  240   240  240   240   240   240   480   480  480   480 480<br/>#&gt; [56]  480   480  480   480   480   960   960   960  960   960 960<br/>#&gt; [67] 960   960  960   960  1920  1920  1920  1920  1920 1920 1920<br/>#&gt; [78] 1920 1920 1920  3840  3840  3840  3840  3840  3840 3840 3840<br/>#&gt; [89] 3840 3840 7680  7680  7680  7680  7680  7680  7680 7680 7680<br/>#&gt; [100] 7680 15360 15360 15360 15360 15360 15360 15360 15360 15360 <br/>#&gt; [110] 15360 30720 30720 30720 30720 30720 30720 30720 30720 30720 <br/>#&gt; [120] 30720 53940 53940 53940 53940 53940 53940 53940 53940 53940   #&gt; [130] 53940<br/>#&gt; <br/>#&gt; $`TIME COMPLEXITY RESULTS`<br/>#&gt; $`TIME COMPLEXITY RESULTS`$best.model<br/>#&gt; [1] "QUADRATIC"<br/>#&gt; <br/>#&gt; $`TIME COMPLEXITY RESULTS`$computation.time.on.full.dataset<br/>#&gt; [1] "41.53S"<br/>#&gt; <br/>#&gt; $`TIME COMPLEXITY RESULTS`$p.value.model.significance<br/>#&gt; [1] 7.988636e-102<br/>#&gt; <br/>#&gt; <br/>#&gt; $`MEMORY COMPLEXITY RESULTS`<br/>#&gt; $`MEMORY COMPLEXITY RESULTS`$best.model<br/>#&gt; [1] "QUADRATIC"<br/>#&gt; <br/>#&gt; $`MEMORY COMPLEXITY RESULTS`$memory.usage.on.full.dataset<br/>#&gt; [1] "11121 Mb"<br/>#&gt; <br/>#&gt; $`MEMORY COMPLEXITY RESULTS`$system.memory.limit<br/>#&gt; [1] "8064 Mb"<br/>#&gt; <br/>#&gt; $`MEMORY COMPLEXITY RESULTS`$p.value.model.significance<br/>#&gt; [1] 2.05865e-259</span></pre><p id="7262" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这些结果表明，经验估计的时间和记忆复杂性本质上都是二次的。在<a class="ae jz" href="https://arxiv.org/pdf/1911.01420.pdf" rel="noopener ugc nofollow" target="_blank">出版物</a>中详细讨论了已知标准复杂性的各种众所周知的计算方法的GuessCompx验证。</p><h1 id="8cc7" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">摘要</h1><p id="fa34" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">这个帖子是对<em class="ky"> GuessCompx </em> R包的一个彻底的描述。该软件包用于对算法或函数的时间和内存复杂性进行经验估计。它测试用户数据的多个大小不断增加的样本，并尝试拟合七个复杂性函数中的一个:O(N)、O(Nˇ2)、O(log(N))等。基于使用LOO-MSE(留出一个均方误差)的最佳拟合过程，它还可以预测整个数据集的完整计算时间和内存使用情况。这里建议的方法和包被认为是R用户群体的新内容；然而，在自动化和各种复杂功能方面，还有很大的改进空间。读者的建议是受欢迎的，更多的细节，请随意评论这篇文章。</p><blockquote class="kz la lb"><p id="151c" class="ka kb ky kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><strong class="kc io"> <em class="in">作者:</em> </strong></p><p id="3980" class="ka kb ky kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><em class="in">尼拉杰·丹拉杰·博克德博士</em></p><p id="597e" class="ka kb ky kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><em class="in">博士后研究员，</em></p><p id="fcbb" class="ka kb ky kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><em class="in">丹麦奥尔胡斯大学</em></p><p id="77d4" class="ka kb ky kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><a class="ae jz" href="https://www.researchgate.net/profile/Neeraj_Bokde" rel="noopener ugc nofollow" target="_blank"><em class="in">https://www.researchgate.net/profile/Neeraj_Bokde</em></a></p></blockquote></div></div>    
</body>
</html>