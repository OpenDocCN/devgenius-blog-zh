<html>
<head>
<title>Writing a Coroutine in C Language</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 C 语言编写协程</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/writing-a-coroutine-in-c-language-6a537275ddc3?source=collection_archive---------2-----------------------#2021-04-26">https://blog.devgenius.io/writing-a-coroutine-in-c-language-6a537275ddc3?source=collection_archive---------2-----------------------#2021-04-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/36966dbe2e60f865a97831995a52fb79.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/1*66AobQM0UmyJuLf7T3x3Zg.png"/></div></figure><p id="103e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我已经很久没有在博客上发表任何东西了。但那是因为工作变动。我希望你明白，在保持陡峭的技术学习曲线的同时，与新的人重新适应新的环境从来都不是一件容易的事情。相应地调整自己是需要时间的。不管怎样，我写了“C 语言中的协同程序”作为我即将发布的关于 C++20 协同程序的文章的预备。今天我们将看到“协程如何在内部工作？”。</p><blockquote class="kq kr ks"><p id="ddc1" class="jr js kt jt b ju jv jw jx jy jz ka kb ku kd ke kf kv kh ki kj kw kl km kn ko ig bi translated"><em class="in"> /！\:这篇文章最初发表在我的博客上。如果你有兴趣接收我的最新文章，</em> <a class="ae kp" href="http://eepurl.com/gDNybv" rel="noopener ugc nofollow" target="_blank"> <em class="in">请注册我的简讯</em> </a> <em class="in">。</em></p></blockquote><h1 id="0d03" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">先决条件</h1><p id="15f7" class="pw-post-body-paragraph jr js in jt b ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ig bi translated">如果你是一个绝对的初学者，你可以通过下面的先决条件。如果你不是初学者，你最好知道该跳过什么！</p><ul class=""><li id="a2b4" class="ma mb in jt b ju jv jy jz kc mc kg md kk me ko mf mg mh mi bi translated"><a class="ae kp" href="http://www.vishalchovatiya.com/how-c-program-convert-into-assembly/" rel="noopener ugc nofollow" target="_blank">C 程序如何转换成汇编！</a></li><li id="ea2d" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mf mg mh mi bi translated"><a class="ae kp" href="http://www.vishalchovatiya.com/how-c-program-stored-in-ram-memory/" rel="noopener ugc nofollow" target="_blank">C 程序的内存布局</a></li></ul><h1 id="5817" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">协程基础</h1><h1 id="6518" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">什么是协程？</h1><ul class=""><li id="4273" class="ma mb in jt b ju lv jy lw kc mo kg mp kk mq ko mf mg mh mi bi translated">协程是一个可以暂停和恢复的功能/子程序(确切地说是合作子程序)。</li><li id="7ffa" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mf mg mh mi bi translated">换句话说，您可以将协程视为普通函数&amp;线程的中间解决方案。因为，一旦函数/子程序被调用，它就会执行到最后。另一方面，线程可能会被同步原语(如互斥、信号量等)阻塞，或者被操作系统调度程序挂起。但是你也不能决定暂停还是恢复。因为它是由 OS 调度程序完成的。</li><li id="cdc0" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mf mg mh mi bi translated">而另一方面，协程可以在一个预定义的点暂停&amp;以后由程序员根据需要恢复。因此，程序员将完全控制执行流程。与线程相比，开销也很小。</li><li id="fcf8" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mf mg mh mi bi translated">协程也称为本机线程、纤程(在 windows 中)、轻量级线程、绿色线程(在 java 中)等。</li></ul><h1 id="4fdf" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">为什么我们需要协程？</h1><ul class=""><li id="7c44" class="ma mb in jt b ju lv jy lw kc mo kg mp kk mq ko mf mg mh mi bi translated">正如我通常所做的，在学习任何新东西之前，你应该问自己这个问题。但是，让我来回答一下:</li><li id="e05d" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mf mg mh mi bi translated">协程可以用很少的开销提供很高水平的并发性。因为它不需要操作系统干预调度。在线程环境中，您必须承担操作系统调度开销。</li><li id="9598" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mf mg mh mi bi translated">协程可以在预先确定的点上挂起，因此也可以避免锁定共享数据结构。因为您永远不会告诉您的代码在临界区中间切换到另一个协程。</li><li id="2495" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mf mg mh mi bi translated">对于线程来说，每个线程都需要自己的线程本地存储栈和其他东西。因此，内存使用量随着线程数量的增加而线性增长。而对于协同例程，您拥有的例程数量与您的内存使用没有直接关系。</li><li id="7710" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mf mg mh mi bi translated">对于大多数用例，协程是更好的选择，因为它比线程更快。</li><li id="1fd5" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mf mg mh mi bi translated">如果你仍然不相信，那就等着看我的<a class="ae kp" href="https://dev.totodo/" rel="noopener ugc nofollow" target="_blank"> C++协程</a>帖子吧。</li></ul><h1 id="0a8a" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">点对点上下文切换 API 理论</h1><ul class=""><li id="8b81" class="ma mb in jt b ju lv jy lw kc mo kg mp kk mq ko mf mg mh mi bi translated">在我们深入研究协程之前，我们需要理解以下用于上下文切换的基础函数/API。当然，正如我们所做的，用更少的、中肯的理论&amp;用更多的代码例子。</li></ul><ol class=""><li id="0014" class="ma mb in jt b ju jv jy jz kc mc kg md kk me ko mr mg mh mi bi translated"><code class="fe ms mt mu mv b">setcontext</code></li><li id="8ce3" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mr mg mh mi bi translated"><code class="fe ms mt mu mv b">getcontext</code></li><li id="2624" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mr mg mh mi bi translated"><code class="fe ms mt mu mv b">makecontext</code></li><li id="1967" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mr mg mh mi bi translated"><code class="fe ms mt mu mv b">swapcontext</code></li></ol><ul class=""><li id="2ed0" class="ma mb in jt b ju jv jy jz kc mc kg md kk me ko mf mg mh mi bi translated">如果你已经熟悉了<code class="fe ms mt mu mv b"><a class="ae kp" href="http://www.vishalchovatiya.com/error-handling-setjmp-longjmp/" rel="noopener ugc nofollow" target="_blank">setjmp</a></code> <a class="ae kp" href="http://www.vishalchovatiya.com/error-handling-setjmp-longjmp/" rel="noopener ugc nofollow" target="_blank"> / </a> <code class="fe ms mt mu mv b"><a class="ae kp" href="http://www.vishalchovatiya.com/error-handling-setjmp-longjmp/" rel="noopener ugc nofollow" target="_blank">longjmp</a></code>，那么你可能会很容易理解这些功能。你可以把这些函数看作是<code class="fe ms mt mu mv b"><a class="ae kp" href="http://www.vishalchovatiya.com/error-handling-setjmp-longjmp/" rel="noopener ugc nofollow" target="_blank">setjmp</a></code> <a class="ae kp" href="http://www.vishalchovatiya.com/error-handling-setjmp-longjmp/" rel="noopener ugc nofollow" target="_blank"> / </a> <code class="fe ms mt mu mv b"><a class="ae kp" href="http://www.vishalchovatiya.com/error-handling-setjmp-longjmp/" rel="noopener ugc nofollow" target="_blank">longjmp</a></code>的高级版本。</li><li id="12ee" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mf mg mh mi bi translated">唯一的区别是<code class="fe ms mt mu mv b"><a class="ae kp" href="http://www.vishalchovatiya.com/error-handling-setjmp-longjmp/" rel="noopener ugc nofollow" target="_blank">setjmp</a></code><a class="ae kp" href="http://www.vishalchovatiya.com/error-handling-setjmp-longjmp/" rel="noopener ugc nofollow" target="_blank">/</a>/<code class="fe ms mt mu mv b"><a class="ae kp" href="http://www.vishalchovatiya.com/error-handling-setjmp-longjmp/" rel="noopener ugc nofollow" target="_blank">longjmp</a></code>只允许单个非局部向上跳栈。然而，这些 API 允许创建多个协作的控制线程，每个线程都有自己的堆栈或入口点。</li></ul><h1 id="1b25" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">存储执行上下文的数据结构</h1><ul class=""><li id="f8ac" class="ma mb in jt b ju lv jy lw kc mo kg mp kk mq ko mf mg mh mi bi translated"><code class="fe ms mt mu mv b">ucontext_t</code>如下定义的类型结构用于存储执行上下文。</li><li id="3009" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mf mg mh mi bi translated">所有四个(<code class="fe ms mt mu mv b">setcontext</code>、<code class="fe ms mt mu mv b">getcontext</code>、<code class="fe ms mt mu mv b">makecontext</code>、&amp;、<code class="fe ms mt mu mv b">swapcontext</code>)控制流功能都在这个结构上运行。</li></ul><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="5a5e" class="ne ky in mv b gy nf ng l nh ni">typedef struct {<br/>    ucontext_t *uc_link;    <br/>    stack_t     uc_stack;<br/>    mcontext_t  uc_mcontext;<br/>    sigset_t    uc_sigmask;<br/>    ...<br/>} ucontext_t;</span></pre><ul class=""><li id="2bfe" class="ma mb in jt b ju jv jy jz kc mc kg md kk me ko mf mg mh mi bi translated"><code class="fe ms mt mu mv b">uc_link</code>指向当前上下文退出时将恢复的上下文，如果该上下文是用<code class="fe ms mt mu mv b">makecontext</code>(二级上下文)创建的。</li><li id="2d50" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mf mg mh mi bi translated"><code class="fe ms mt mu mv b">uc_stack</code>是上下文使用的堆栈。</li><li id="b32d" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mf mg mh mi bi translated"><code class="fe ms mt mu mv b">uc_mcontext</code>存储执行状态，包括所有寄存器和 CPU 标志、帧/基指针(即指示当前执行帧)、指令指针(即程序计数器)、链接寄存器(即存储返回地址)和堆栈指针(即指示当前堆栈限制或当前帧结束)。<code class="fe ms mt mu mv b">mcontext_t</code>是一个<a class="ae kp" href="https://en.wikipedia.org/wiki/Opaque_data_type" rel="noopener ugc nofollow" target="_blank">不透明类型</a>。</li><li id="a1b2" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mf mg mh mi bi translated"><code class="fe ms mt mu mv b">uc_sigmask</code>用于存储上下文中阻塞的信号集。这不是今天的重点。</li></ul><h1 id="7943" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><code class="fe ms mt mu mv b">int setcontext(const ucontext_t *ucp)</code></h1><ul class=""><li id="804c" class="ma mb in jt b ju lv jy lw kc mo kg mp kk mq ko mf mg mh mi bi translated">该功能将控制转移到<code class="fe ms mt mu mv b">ucp</code>中的上下文。从上下文存储在<code class="fe ms mt mu mv b">ucp</code>的点继续执行。<code class="fe ms mt mu mv b">setcontext</code>不归。</li></ul><h1 id="72fc" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><code class="fe ms mt mu mv b">int getcontext(ucontext_t *ucp)</code></h1><ul class=""><li id="696b" class="ma mb in jt b ju lv jy lw kc mo kg mp kk mq ko mf mg mh mi bi translated">将当前上下文保存到<code class="fe ms mt mu mv b">ucp</code>。该函数在两种可能的情况下返回:</li></ul><ol class=""><li id="60fa" class="ma mb in jt b ju jv jy jz kc mc kg md kk me ko mr mg mh mi bi translated">在初始呼叫之后，</li><li id="3236" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mr mg mh mi bi translated">或者当线程通过<code class="fe ms mt mu mv b">setcontext</code>或<code class="fe ms mt mu mv b">swapcontext</code>切换到<code class="fe ms mt mu mv b">ucp</code>中的上下文时。</li></ol><ul class=""><li id="7128" class="ma mb in jt b ju jv jy jz kc mc kg md kk me ko mf mg mh mi bi translated"><code class="fe ms mt mu mv b">getcontext</code>函数不提供区分情况的返回值(其返回值仅用于指示错误)，因此程序员必须使用显式标志变量，该变量不能是寄存器变量，并且必须声明为<code class="fe ms mt mu mv b">volatile</code>以避免常量传播或其他编译器优化。</li></ul><h1 id="ff58" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><code class="fe ms mt mu mv b">void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...)</code></h1><ul class=""><li id="1c12" class="ma mb in jt b ju lv jy lw kc mo kg mp kk mq ko mf mg mh mi bi translated"><code class="fe ms mt mu mv b">makecontext</code>功能在<code class="fe ms mt mu mv b">ucp</code>中设置一个备用控制线程，该线程之前已使用<code class="fe ms mt mu mv b">getcontext</code>初始化。</li><li id="f7db" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mf mg mh mi bi translated"><code class="fe ms mt mu mv b">ucp.uc_stack</code>成员应指向适当大小的堆栈；通常使用常量 SIGSTKSZ 或 MINSIGSTKSZ。</li><li id="328a" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mf mg mh mi bi translated">当使用<code class="fe ms mt mu mv b">setcontext</code>或<code class="fe ms mt mu mv b">swapcontext</code>跳转到<code class="fe ms mt mu mv b">ucp</code>时，将在<code class="fe ms mt mu mv b">func</code>指向的函数的入口点开始执行，使用指定的<code class="fe ms mt mu mv b">argc</code>参数。当<code class="fe ms mt mu mv b">func</code>终止时，控制返回到<code class="fe ms mt mu mv b">ucp.uc_link</code>中指定的上下文。</li></ul><h1 id="3f5d" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><code class="fe ms mt mu mv b">int swapcontext(ucontext_t *oucp, ucontext_t *ucp)</code></h1><ul class=""><li id="cffc" class="ma mb in jt b ju lv jy lw kc mo kg mp kk mq ko mf mg mh mi bi translated">将当前执行状态保存到<code class="fe ms mt mu mv b">oucp</code>，然后将执行控制转移到<code class="fe ms mt mu mv b">ucp</code>。</li></ul><h1 id="4e40" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">【例 1】:用<code class="fe ms mt mu mv b">setcontext</code> &amp; <code class="fe ms mt mu mv b">getcontext</code>函数理解上下文切换</h1><ul class=""><li id="4388" class="ma mb in jt b ju lv jy lw kc mo kg mp kk mq ko mf mg mh mi bi translated">我们已经阅读了很多理论。让我们从中创造有意义的东西。</li><li id="c2f1" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mf mg mh mi bi translated">考虑下面这个实现每秒打印“Hello world”的普通无限循环的程序。</li></ul><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="d430" class="ne ky in mv b gy nf ng l nh ni">#include &lt;stdio.h&gt;<br/>#include &lt;ucontext.h&gt;<br/>#include &lt;unistd.h&gt;<br/>#include &lt;stdlib.h&gt;</span><span id="b4bc" class="ne ky in mv b gy nj ng l nh ni">int main( ) {<br/>    ucontext_t ctx = {0};</span><span id="3380" class="ne ky in mv b gy nj ng l nh ni">    getcontext(&amp;ctx);   // Loop start<br/>    puts("Hello world");<br/>    sleep(1);<br/>    setcontext(&amp;ctx);   // Loop end </span><span id="dd7b" class="ne ky in mv b gy nj ng l nh ni">    return EXIT_SUCCESS;<br/>}</span></pre><ul class=""><li id="3649" class="ma mb in jt b ju jv jy jz kc mc kg md kk me ko mf mg mh mi bi translated">这里，<code class="fe ms mt mu mv b">getcontext</code>返回了我们之前提到的两种可能的情况，即:</li></ul><ol class=""><li id="e807" class="ma mb in jt b ju jv jy jz kc mc kg md kk me ko mr mg mh mi bi translated">在初始呼叫之后，</li><li id="28e5" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mr mg mh mi bi translated">当线程通过<code class="fe ms mt mu mv b">setcontext</code>切换到上下文时。</li></ol><ul class=""><li id="5a7c" class="ma mb in jt b ju jv jy jz kc mc kg md kk me ko mf mg mh mi bi translated">其余的我认为不言自明。</li></ul><h1 id="0ce6" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">【例 2】:用<code class="fe ms mt mu mv b">makecontext</code> &amp; <code class="fe ms mt mu mv b">swapcontext</code>函数理解控制流程</h1><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="48d6" class="ne ky in mv b gy nf ng l nh ni">#include &lt;stdio.h&gt;<br/>#include &lt;stdint.h&gt;<br/>#include &lt;stdlib.h&gt;<br/>#include &lt;signal.h&gt;<br/>#include &lt;ucontext.h&gt;</span><span id="e2d8" class="ne ky in mv b gy nj ng l nh ni">void assign(uint32_t *var, uint32_t val) { <br/>    *var = val; <br/>}</span><span id="68e7" class="ne ky in mv b gy nj ng l nh ni">int main( ) {<br/>    uint32_t var = 0;<br/>    ucontext_t ctx = {0}, back = {0};</span><span id="c0d4" class="ne ky in mv b gy nj ng l nh ni">    getcontext(&amp;ctx);</span><span id="5b25" class="ne ky in mv b gy nj ng l nh ni">    ctx.uc_stack.ss_sp = calloc(1, MINSIGSTKSZ);<br/>    ctx.uc_stack.ss_size = MINSIGSTKSZ;<br/>    ctx.uc_stack.ss_flags = 0;</span><span id="7cb0" class="ne ky in mv b gy nj ng l nh ni">    ctx.uc_link = &amp;back; // Will get back to main as `swapcontext` call will populate `back` with current context<br/>    // ctx.uc_link = 0;  // Will exit directly after `swapcontext` call</span><span id="c7de" class="ne ky in mv b gy nj ng l nh ni">    makecontext(&amp;ctx, (void (*)())assign, 2, &amp;var, 100);<br/>    swapcontext(&amp;back, &amp;ctx);    // Calling `assign` by switching context</span><span id="4808" class="ne ky in mv b gy nj ng l nh ni">    printf("var = %d\n", var);</span><span id="0501" class="ne ky in mv b gy nj ng l nh ni">    return EXIT_SUCCESS;<br/>}</span></pre><ul class=""><li id="c15e" class="ma mb in jt b ju jv jy jz kc mc kg md kk me ko mf mg mh mi bi translated">这里，<code class="fe ms mt mu mv b">makecontext</code>功能在<code class="fe ms mt mu mv b">ctx</code>中设置一个控制的替代线程。当通过使用<code class="fe ms mt mu mv b">swapcontext</code>使用<code class="fe ms mt mu mv b">ctx</code>跳转时，将从<code class="fe ms mt mu mv b">assign</code>开始执行，指定各自的参数。</li><li id="ee81" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mf mg mh mi bi translated">当<code class="fe ms mt mu mv b">assign</code>终止时，控制将切换到<code class="fe ms mt mu mv b">ctx.uc_link</code>。指向<code class="fe ms mt mu mv b">back</code>的 T33 将在跳转/上下文切换前由<code class="fe ms mt mu mv b">swapcontext</code>填充。</li><li id="b29f" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mf mg mh mi bi translated">如果<code class="fe ms mt mu mv b">ctx.uc_link</code>置 0，则当前执行上下文被认为是主上下文，当<code class="fe ms mt mu mv b">assign</code>上下文结束时线程将退出。</li><li id="4c7a" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mf mg mh mi bi translated">在调用<code class="fe ms mt mu mv b">makecontext</code>之前，应用程序/开发人员需要确保被修改的上下文具有预分配的堆栈。并且<code class="fe ms mt mu mv b">argc</code>匹配传递给<code class="fe ms mt mu mv b">func</code>的类型<code class="fe ms mt mu mv b">int</code>的参数数量。否则，行为是未定义的。</li></ul><h1 id="0d16" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">C 语言中的协同程序</h1><ul class=""><li id="0789" class="ma mb in jt b ju lv jy lw kc mo kg mp kk mq ko mf mg mh mi bi translated">最初，我创建了单个文件示例。但后来我意识到，这将是太多的东西塞进一个文件。因此，我将实现和使用示例拆分到不同的文件中，这将使示例更容易理解。##协程实现</li><li id="6ee6" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mf mg mh mi bi translated">下面是 c 语言中最简单的协程:</li></ul><h1 id="be71" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><code class="fe ms mt mu mv b"><strong class="ak">coroutine.h</strong></code></h1><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="59bd" class="ne ky in mv b gy nf ng l nh ni">#pragma once</span><span id="bc76" class="ne ky in mv b gy nj ng l nh ni">#include &lt;stdint.h&gt;<br/>#include &lt;stdlib.h&gt;<br/>#include &lt;ucontext.h&gt;<br/>#include &lt;stdbool.h&gt;</span><span id="3061" class="ne ky in mv b gy nj ng l nh ni">typedef struct coro_t_ coro_t;<br/>typedef int (*coro_function_t)(coro_t *coro);</span><span id="fff5" class="ne ky in mv b gy nj ng l nh ni">/* <br/>    Coroutine handler<br/>*/<br/>struct coro_t_ {<br/>    coro_function_t     function;           // Actual co-routine function<br/>    ucontext_t          suspend_context;    // Stores context previous to coroutine jump<br/>    ucontext_t          resume_context;     // Stores coroutine context<br/>    int                 yield_value;        // Coroutine return/yield value<br/>    bool                is_coro_finished;   // To indicate the current coroutine status<br/>};</span><span id="f050" class="ne ky in mv b gy nj ng l nh ni">/* <br/>    Coroutine APIs for users<br/>*/<br/>coro_t *coro_new(coro_function_t function);<br/>int coro_resume(coro_t *coro);    <br/>void coro_yield(coro_t *coro, int value);<br/>void coro_free(coro_t *coro);</span></pre><ul class=""><li id="495d" class="ma mb in jt b ju jv jy jz kc mc kg md kk me ko mf mg mh mi bi translated">现在只需忽略协程 API。</li><li id="9b24" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mf mg mh mi bi translated">这里主要关注的是协程处理程序，它有以下字段</li><li id="c437" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mf mg mh mi bi translated"><code class="fe ms mt mu mv b">function</code>:保存用户提供的实际协程函数的地址。</li><li id="b0ff" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mf mg mh mi bi translated"><code class="fe ms mt mu mv b">suspend_context</code>:用于暂停协程功能。</li><li id="f2a5" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mf mg mh mi bi translated"><code class="fe ms mt mu mv b">resume_context</code>:保存实际协程函数的上下文。</li><li id="4e8b" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mf mg mh mi bi translated"><code class="fe ms mt mu mv b">yield_value</code>:存储中间暂停点&amp;之间的返回值，也是最终返回值。</li><li id="1794" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mf mg mh mi bi translated"><code class="fe ms mt mu mv b">is_coro_finished</code>:检查协程寿命状态的指示器。</li></ul><h1 id="ee6e" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><code class="fe ms mt mu mv b"><strong class="ak">coroutine.c</strong></code></h1><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="9696" class="ne ky in mv b gy nf ng l nh ni">#include &lt;signal.h&gt;<br/>#include "coroutine.h"</span><span id="9323" class="ne ky in mv b gy nj ng l nh ni">static void _coro_entry_point(coro_t *coro) {<br/>    int return_value = coro-&gt;function(coro);<br/>    coro-&gt;is_coro_finished = true;<br/>    coro_yield(coro, return_value);<br/>}</span><span id="372d" class="ne ky in mv b gy nj ng l nh ni">coro_t *coro_new(coro_function_t function) {<br/>    coro_t *coro = calloc(1, sizeof(*coro));</span><span id="1c71" class="ne ky in mv b gy nj ng l nh ni">    coro-&gt;is_coro_finished = false;<br/>    coro-&gt;function = function;<br/>    coro-&gt;resume_context.uc_stack.ss_sp = calloc(1, MINSIGSTKSZ);<br/>    coro-&gt;resume_context.uc_stack.ss_size = MINSIGSTKSZ;<br/>    coro-&gt;resume_context.uc_link = 0;</span><span id="fd4c" class="ne ky in mv b gy nj ng l nh ni">    getcontext(&amp;coro-&gt;resume_context);<br/>    makecontext(&amp;coro-&gt;resume_context, (void (*)())_coro_entry_point, 1, coro);<br/>    return coro;<br/>}</span><span id="79ac" class="ne ky in mv b gy nj ng l nh ni">int coro_resume(coro_t *coro) {    <br/>    if (coro-&gt;is_coro_finished) return -1;<br/>    swapcontext(&amp;coro-&gt;suspend_context, &amp;coro-&gt;resume_context);<br/>    return coro-&gt;yield_value;<br/>}</span><span id="4ee3" class="ne ky in mv b gy nj ng l nh ni">void coro_yield(coro_t *coro, int value) {<br/>    coro-&gt;yield_value = value;<br/>    swapcontext(&amp;coro-&gt;resume_context, &amp;coro-&gt;suspend_context);<br/>}</span><span id="3230" class="ne ky in mv b gy nj ng l nh ni">void coro_free(coro_t *coro) {<br/>    free(coro-&gt;resume_context.uc_stack.ss_sp);<br/>    free(coro);<br/>}</span></pre><ul class=""><li id="9131" class="ma mb in jt b ju jv jy jz kc mc kg md kk me ko mf mg mh mi bi translated">协程使用最多的 API 是<code class="fe ms mt mu mv b">coro_resume</code> &amp; <code class="fe ms mt mu mv b">coro_yield</code>，它拖动挂起&amp;恢复的实际工作。</li><li id="a082" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mf mg mh mi bi translated">如果你已经有意识地浏览了上面的上下文切换 API 例子，那么我不认为<code class="fe ms mt mu mv b">coro_resume</code> &amp; <code class="fe ms mt mu mv b">coro_yield</code>有什么好解释的。它只是<code class="fe ms mt mu mv b">coro_yield</code>跳到<code class="fe ms mt mu mv b">coro_resume</code>T25，反之亦然。除了跳转到<code class="fe ms mt mu mv b">_coro_entry_point</code>的对<code class="fe ms mt mu mv b">coro_resume</code>的第一次调用。</li><li id="ee13" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mf mg mh mi bi translated"><code class="fe ms mt mu mv b">coro_new</code>函数为处理程序和堆栈&amp;分配内存，然后填充处理程序成员。再次<code class="fe ms mt mu mv b">getcontext</code> &amp; <code class="fe ms mt mu mv b">makecontext</code>这一点应该很清楚。如果没有，那么请重新阅读上面关于上下文切换 API 示例的部分。</li><li id="7c55" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mf mg mh mi bi translated">如果你真正理解上面的协同 API 实现，那么很明显的问题是为什么我们甚至需要<code class="fe ms mt mu mv b">_coro_entry_point</code>？为什么不能直接跳转到实际的协程函数？。</li><li id="ad42" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mf mg mh mi bi translated">但是我的论点将是“你如何确保协程的生存期？”。</li><li id="2d9a" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mf mg mh mi bi translated">这在技术上意味着，调用<code class="fe ms mt mu mv b">coro_resume</code>的次数应该类似于/有效于调用<code class="fe ms mt mu mv b">coro_yield</code>的次数加 1(实际返回)。</li><li id="42a3" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mf mg mh mi bi translated">否则你就无法跟踪产量。行为将变得不确定。</li><li id="d347" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mf mg mh mi bi translated">然而，<code class="fe ms mt mu mv b">_coro_entry_point</code>函数是必需的，否则你无法推断出 corotine 执行完全完成。并且对<code class="fe ms mt mu mv b">coro_resume</code>的下一个/后续调用不再有效。</li></ul><h1 id="4828" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">协程寿命</h1><ul class=""><li id="f3f1" class="ma mb in jt b ju lv jy lw kc mo kg mp kk mq ko mf mg mh mi bi translated">通过上面的实现，<strong class="jt io">使用协程处理程序</strong>，在整个程序/应用程序生命周期中，您应该只能完整地执行一次协程函数。</li><li id="3593" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mf mg mh mi bi translated">如果你想再次调用协程函数，那么你需要创建新的协程处理程序。其余的过程将保持不变。</li></ul><h1 id="110c" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">协程用法示例</h1><h1 id="48a7" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><code class="fe ms mt mu mv b"><strong class="ak">coroutine_example.c</strong></code></h1><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="3645" class="ne ky in mv b gy nf ng l nh ni">#include &lt;stdio.h&gt;<br/>#include &lt;assert.h&gt;<br/>#include "coroutine.h"</span><span id="9437" class="ne ky in mv b gy nj ng l nh ni">int hello_world(coro_t *coro) {    <br/>    puts("Hello");<br/>    coro_yield(coro, 1);    // Suspension point that returns the value `1`<br/>    puts("World");<br/>    return 2;<br/>}</span><span id="72db" class="ne ky in mv b gy nj ng l nh ni">int main() {<br/>    coro_t *coro = coro_new(hello_world);<br/>    assert(coro_resume(coro) == 1);     // Verifying return value<br/>    assert(coro_resume(coro) == 2);     // Verifying return value<br/>    assert(coro_resume(coro) == -1);    // Invalid call<br/>    coro_free(coro);<br/>    return EXIT_SUCCESS;<br/>}</span></pre><ul class=""><li id="c977" class="ma mb in jt b ju jv jy jz kc mc kg md kk me ko mf mg mh mi bi translated">用例非常简单:</li><li id="0ac0" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mf mg mh mi bi translated">首先，创建一个协程处理程序。</li><li id="3392" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mf mg mh mi bi translated">然后，在同一个协程处理程序的帮助下，启动/恢复实际的协程函数。</li><li id="1e12" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mf mg mh mi bi translated">而且，每当您的实际协程函数遇到调用<code class="fe ms mt mu mv b">coro_yield</code>，它将暂停执行&amp;，返回在<code class="fe ms mt mu mv b">coro_yield</code>的第二个参数中传递的值。</li><li id="eb6c" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mf mg mh mi bi translated">以及当实际的协程函数执行完全完成时。对<code class="fe ms mt mu mv b">coro_resume</code>的调用将返回<code class="fe ms mt mu mv b">-1</code>以指示协程处理程序对象不再有效&amp;生命周期已到期。</li><li id="0a3e" class="ma mb in jt b ju mj jy mk kc ml kg mm kk mn ko mf mg mh mi bi translated">所以，你可以看到<code class="fe ms mt mu mv b">coro_resume</code>是我们的协程<code class="fe ms mt mu mv b">hello_world</code>的包装器，它部分地执行<code class="fe ms mt mu mv b">hello_world</code>(显然是通过上下文切换)。</li></ul><h1 id="638b" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">编译</strong></h1><ul class=""><li id="1b78" class="ma mb in jt b ju lv jy lw kc mo kg mp kk mq ko mf mg mh mi bi translated">我已经用 gcc 9.3.0 和 glibc 2.31 在 WSL 中测试了这个例子。</li></ul><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="cd13" class="ne ky in mv b gy nf ng l nh ni">$ gcc -I./ coroutine_example.c coroutine.c  -o myapp &amp;&amp; ./myapp <br/>Hello<br/>World</span></pre><h1 id="fde8" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">离别赠言</h1><p id="c01c" class="pw-post-body-paragraph jr js in jt b ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ig bi translated">如果你理解“CPU 如何执行代码”,你会发现这并不神奇..!"良好的 Glibc 提供了一组丰富的上下文切换 API。而且，从低级开发人员的角度来看，这仅仅是一个精心安排的&amp;难以组织/维护(如果使用原始的)上下文切换函数调用。我在这里的意图是为 C++20 协程打下基础。因为我相信，如果你从 CPU &amp;编译器的角度来看代码，那么在 C++中一切都变得容易推理了。下次在我的<a class="ae kp" href="https://dev.totodo/" rel="noopener ugc nofollow" target="_blank"> C++20 协程</a>帖子中再见。</p></div></div>    
</body>
</html>