<html>
<head>
<title>Backup, Restore and Migrate Kubernetes Cluster resources using Velero.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Velero 备份、恢复和迁移 Kubernetes 集群资源。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/backup-restore-and-migrate-kubernetes-cluster-resources-using-velero-a9b6997e4b54?source=collection_archive---------4-----------------------#2022-10-03">https://blog.devgenius.io/backup-restore-and-migrate-kubernetes-cluster-resources-using-velero-a9b6997e4b54?source=collection_archive---------4-----------------------#2022-10-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="4f43" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">介绍</h1><p id="3617" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">Kubernetes 已经成为每个组织处理微服务的事实上的选择。组织将它用于任务关键型应用程序，并且迫切需要备份应用程序及其相关数据。</p><p id="d8b3" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">数据的备份和恢复是非常重要的一部分。如果有备份，您可以从任何灾难中快速恢复。在这篇博文中，我们将讨论使用 Velero 备份和恢复 Kubernetes 资源。</p><p id="0bca" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">Velero 是一个开源工具，用于备份和恢复 Kubernetes 集群中运行的资源。Velero 使用 Kubernetes API 发现功能来收集要备份的数据。Velero 可以执行手动备份和自动备份、恢复、灾难恢复，将资源和 PV 从一个集群迁移到另一个 Kubernetes 集群。</p><p id="e8bc" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">在本教程中，我们将指导您备份在源 Kubernetes 集群中运行的资源，还将指导您将该备份迁移到目标集群。</p><h1 id="000a" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">先决条件</h1><ul class=""><li id="3b03" class="ll lm in kk b kl km kp kq kt ln kx lo lb lp lf lq lr ls lt bi translated">2 个版本相同的 Kubernetes 集群已经启动并运行，我们在本教程中也会解释迁移。</li><li id="533d" class="ll lm in kk b kl lu kp lv kt lw kx lx lb ly lf lq lr ls lt bi translated">您可以对这两个 Kubernetes 集群运行 kubectl 命令。</li><li id="d1e4" class="ll lm in kk b kl lu kp lv kt lw kx lx lb ly lf lq lr ls lt bi translated">一个 AWS IAM 用户，拥有访问密钥和秘密密钥，并拥有在 AWS S3 存储桶中放置和获取对象的权限。</li><li id="3f2c" class="ll lm in kk b kl lu kp lv kt lw kx lx lb ly lf lq lr ls lt bi translated">在 AWS S3 上创建一个存储桶来存储备份。</li><li id="3244" class="ll lm in kk b kl lu kp lv kt lw kx lx lb ly lf lq lr ls lt bi translated">迁移前，清除源集群中的异常 pod 资源。如果 pod 处于异常状态，并且安装了 PVC，则在群集迁移后，PVC 将保持挂起状态。</li></ul><p id="44df" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">对于本教程，我们已经创建了两个 Kubernetes 集群(源和目标)。在源集群上，我们的 WordPress 应用程序正在运行，在目标集群上，我们将移动并恢复 WordPress 应用程序的备份。</p><h1 id="0575" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">韦莱罗建筑</h1><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/fb7d7aa8a79079e0259e515d42f79b83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iQjKIoHK0tK75grj"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">韦莱罗的建筑表现。</figcaption></figure><p id="0ed5" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">在上面的架构图中，有两个 Kubernetes 集群源和目标。velero 控制器部署在两个集群上。Velero CLI 安装在可以访问源和目标 Kubernetes 集群的本地机器上。因此，我们可以从本地机器访问 velero 控制器。AWS S3 是存储位置，用于存储从源 Kubernetes 集群获取的备份。备份以 tar 格式存储在 S3 上。</p><h2 id="35fb" class="mp jl in bd jm mq mr dn jq ms mt dp ju kt mu mv jy kx mw mx kc lb my mz kg na bi translated"><strong class="ak"> Velero 安装:</strong></h2><p id="ddd4" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">Velero 使用备份位置来执行备份和恢复集群。备份位置可以是 AWS S3、Azure Blob 存储或任何 S3 兼容存储。在本教程中，我们将使用<strong class="kk io"> AWS S3 </strong>来备份和恢复集群数据。</p><p id="dc33" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">在您当前的工作目录中创建一个名为“<em class="nb">凭证</em>的文件，并将 AWS 访问密钥和密码粘贴到该文件中。确保使用先决条件中提到的可以访问 AWS S3 的凭据。</p><pre class="ma mb mc md gt nc nd ne nf aw ng bi"><span id="c64f" class="mp jl in nd b gy nh ni l nj nk">[default]<br/>aws_access_key_id = AKXXXXXXXXXXXXXXXT<br/>aws_secret_access_key = bXXXXXXXXXXXXXXXXXXXXz</span></pre><p id="5634" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">现在我们的凭证文件已经创建，让我们在本地机器上安装 Velero CLI。首先，我们需要下载 Velero 的 tar 文件。</p><pre class="ma mb mc md gt nc nd ne nf aw ng bi"><span id="41c3" class="mp jl in nd b gy nh ni l nj nk">wget <a class="ae nl" href="https://github.com/vmware-tanzu/velero/releases/download/v1.9.2/velero-v1.9.2-linux-amd64.tar.gz" rel="noopener ugc nofollow" target="_blank">https://github.com/vmware-tanzu/velero/releases/download/v1.9.2/velero-v1.9.2-linux-amd64.tar.gz</a></span></pre><p id="b60b" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">成功运行上述命令后，Velero 将下载到您当前的目录中。正如您所看到的，下载的文件是 tar 格式的，让我们来解压缩 tar 文件。</p><pre class="ma mb mc md gt nc nd ne nf aw ng bi"><span id="6f85" class="mp jl in nd b gy nh ni l nj nk">tar -xvf velero-v1.9.2-linux-amd64.tar.gz</span></pre><p id="19b7" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">一旦您的文件被解压缩，将 Velero 移动到“/usr/local/bin/”目录。</p><pre class="ma mb mc md gt nc nd ne nf aw ng bi"><span id="dddd" class="mp jl in nd b gy nh ni l nj nk">sudo mv velero-v1.9.2-linux-amd64/velero /usr/local/bin/</span></pre><p id="6980" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">要检查 velero 版本，请运行以下命令。</p><pre class="ma mb mc md gt nc nd ne nf aw ng bi"><span id="6d41" class="mp jl in nd b gy nh ni l nj nk">velero version client-only</span></pre><p id="81ea" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">您将得到这样的输出。</p><pre class="ma mb mc md gt nc nd ne nf aw ng bi"><span id="8712" class="mp jl in nd b gy nh ni l nj nk">Client:<br/> Version: v1.9.2<br/> Git commit: 82a100981cc66d119cf9b1d121f45c5c9dcf99e1</span></pre><p id="e21e" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">现在，velero 安装在我们的本地机器上。让我们在 Kubernetes 集群中部署 velero，为此运行以下命令。</p><pre class="ma mb mc md gt nc nd ne nf aw ng bi"><span id="0521" class="mp jl in nd b gy nh ni l nj nk">velero install \<br/> — provider aws \<br/> — plugins velero/velero-plugin-for-aws:v1.4.1 \<br/> — bucket sagar-backup-pv \<br/> — secret-file ./credentials \<br/> — use-volume-snapshots=false \<br/> — use-restic \<br/> — backup-location-config region=us-west-2</span></pre><p id="42db" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">在上面的命令中，“<strong class="kk io">Sagar-backup-PV</strong>”<strong class="kk io"/>是我们为本教程创建的 AWS S3 存储桶的名称，“<strong class="kk io">凭证</strong>”是我们存储 AWS 凭证以访问 AWS S3 存储桶的文件的名称，“<strong class="kk io"> us-west-2 </strong>”是 AWS 存储桶的位置。该命令将在 Kubernetes 集群上安装所有 velero 组件。</p><p id="dc87" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io"><em class="nb">#确保针对两个集群运行该命令。</em>T11】</strong></p><h2 id="6a6d" class="mp jl in bd jm mq mr dn jq ms mt dp ju kt mu mv jy kx mw mx kc lb my mz kg na bi translated">注释:</h2><p id="15b2" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">如果您需要备份 pod 中存储卷的数据，请向 pod 添加注释。注释模板如下所示:</p><pre class="ma mb mc md gt nc nd ne nf aw ng bi"><span id="8a9a" class="mp jl in nd b gy nh ni l nj nk">kubectl annotate &lt;pod/pod_name&gt; backup.velero.io/backup-volumes=&lt;volume_name&gt;  -n &lt;namespace&gt;</span></pre><p id="fa3b" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">如果有多个卷连接到 pod，您可以像这样添加注释，并且只有在命令中指定的卷名将被用于备份。</p><pre class="ma mb mc md gt nc nd ne nf aw ng bi"><span id="d6a6" class="mp jl in nd b gy nh ni l nj nk">kubectl -n &lt;namespace&gt; annotate &lt;pod/pod_name&gt; backup.velero.io/backup-volumes=&lt;volume_name_1&gt;,&lt;volume_name_2&gt;,…</span></pre><ul class=""><li id="9926" class="ll lm in kk b kl lg kp lh kt nm kx nn lb no lf lq lr ls lt bi translated"><strong class="kk io"> &lt;名称空间&gt;</strong>:pod 所在的名称空间。</li><li id="03ea" class="ll lm in kk b kl lu kp lv kt lw kx lx lb ly lf lq lr ls lt bi translated"><strong class="kk io">&lt;pod _ name&gt;</strong>:pod 名称。</li><li id="b951" class="ll lm in kk b kl lu kp lv kt lw kx lx lb ly lf lq lr ls lt bi translated"><strong class="kk io"> &lt;卷名&gt; </strong>:挂载到 pod 的永久卷的名称。</li></ul><p id="2b8c" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">您可以运行 describe 语句来查询 pod 信息。卷字段指示附加到 pod 的所有永久卷的名称。</p><p id="30dd" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">您可以通过运行 pod describe 命令来检查卷名。</p><pre class="ma mb mc md gt nc nd ne nf aw ng bi"><span id="2a24" class="mp jl in nd b gy nh ni l nj nk">kubectl  describe &lt;pod/pod_name&gt; -n &lt;namespace&gt;</span></pre><h2 id="c516" class="mp jl in bd jm mq mr dn jq ms mt dp ju kt mu mv jy kx mw mx kc lb my mz kg na bi translated">备份源群集中的应用程序:</h2><p id="0bd6" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">我们已经在我们的源 Kubernetes 集群上部署了 WordPress 作为演示应用程序。我们在这次部署中使用了 bitnami 掌舵图。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi np"><img src="../Images/32791c6e1ece45294a9ce65d1154543e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xFUJLTR20NEA5Zl0"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">在源 Kubernetes 集群上运行的应用程序的屏幕截图。</figcaption></figure><p id="a7e3" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">正如您在屏幕截图中看到的，我们在源群集上使用 longhorn 存储。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi nq"><img src="../Images/5278635fee0d1a5ba7ee0ffb27c32908.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JjepC1qwOLNpWfrKNdIJ-A.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">源 Kubernetes 集群中使用的存储类的屏幕截图。</figcaption></figure><p id="1d3a" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">我们将把 PVC 从<strong class="kk io"> longhorn </strong>仓库转移到<strong class="kk io"> Rook CEPH </strong>仓库。</p><p id="9609" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">我们对 WordPress 网站做了一些改动，如截图所示。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi nr"><img src="../Images/5e03e6cabfdb12231f1bc9fc23b342c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qRdbGkcIt6woDq-J"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">源 Kubernetes 集群上应用程序的屏幕截图。</figcaption></figure><h2 id="b92c" class="mp jl in bd jm mq mr dn jq ms mt dp ju kt mu mv jy kx mw mx kc lb my mz kg na bi translated">更改 PVC 存储类别:</h2><p id="0030" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><strong class="kk io"> <em class="nb"> #注意:-如果在源和目标 Kubernetes 集群上使用相同的存储解决方案，可以忽略此步骤。</em>T25】</strong></p><p id="afbd" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">在我们的例子中，我们使用源集群上的存储类 longhorn 将带有 PVC 的应用程序迁移到安装了 rook-cephfs 的目标集群。</p><p id="0e4f" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">有两种方法可以做到这一点</p><ol class=""><li id="9384" class="ll lm in kk b kl lg kp lh kt nm kx nn lb no lf ns lr ls lt bi translated"><em class="nb">通过更改存储类的名称。</em></li><li id="9aa6" class="ll lm in kk b kl lu kp lv kt lw kx lx lb ly lf ns lr ls lt bi translated"><em class="nb">通过在恢复期间更改 PV 中存储类的名称。</em></li></ol><p id="23a7" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">这两种方法解释如下，你可以选择其中任何一种。</p><ol class=""><li id="12e7" class="ll lm in kk b kl lg kp lh kt nm kx nn lb no lf ns lr ls lt bi translated"><strong class="kk io">更改存储类的名称。</strong></li></ol><p id="33d4" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">在这种方法中，我们需要使用源集群中可用的存储解决方案的名称来创建存储类。</p><p id="d347" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">在下面的例子中，我们为<strong class="kk io"> Rook-ceph </strong>创建了一个存储类清单，在元数据部分，我们将其命名为<strong class="kk io"> longhorn </strong>。</p><pre class="ma mb mc md gt nc nd ne nf aw ng bi"><span id="1d97" class="mp jl in nd b gy nh ni l nj nk">apiVersion: storage.k8s.io/v1<br/>kind: StorageClass<br/>metadata:<br/>  name: longhorn<br/># Change "rook-ceph" provisioner prefix to match the operator namespace if needed<br/>provisioner: rook-ceph.cephfs.csi.ceph.com # driver:namespace:operator<br/>parameters:<br/>  # clusterID is the namespace where the rook cluster is running<br/>  # If you change this namespace, also change the namespace below where the secret namespaces are defined<br/>  clusterID: rook-ceph # namespace:cluster<br/><br/>  # CephFS filesystem name into which the volume shall be created<br/>  fsName: k8sfs<br/><br/>  # Ceph pool into which the volume shall be created<br/>  # Required for provisionVolume: "true"<br/>  pool: k8sfs-replicated<br/><br/>  # The secrets contain Ceph admin credentials. These are generated automatically by the operator<br/>  # in the same namespace as the cluster.<br/>  csi.storage.k8s.io/provisioner-secret-name: rook-csi-cephfs-provisioner<br/>  csi.storage.k8s.io/provisioner-secret-namespace: rook-ceph # namespace:cluster<br/>  csi.storage.k8s.io/controller-expand-secret-name: rook-csi-cephfs-provisioner<br/>  csi.storage.k8s.io/controller-expand-secret-namespace: rook-ceph # namespace:cluster<br/>  csi.storage.k8s.io/node-stage-secret-name: rook-csi-cephfs-node<br/>  csi.storage.k8s.io/node-stage-secret-namespace: rook-ceph # namespace:cluster<br/><br/>  # (optional) The driver can use either ceph-fuse (fuse) or ceph kernel client (kernel)<br/>  # If omitted, default volume mounter will be used - this is determined by probing for ceph-fuse<br/>  # or by setting the default mounter explicitly via --volumemounter command-line argument.<br/>  # mounter: kernel<br/>reclaimPolicy: Delete<br/>allowVolumeExpansion: true<br/>mountOptions:<br/>  # uncomment the following line for debugging<br/>  #- debug</span></pre><p id="be2e" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io"> <em class="nb"> #请注意，我们只更改了存储类的名称。</em>T13】</strong></p><p id="c678" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">创建存储类清单，并将该清单应用于目标群集。完成后，您可以通过运行以下命令来验证是否创建了存储类。</p><pre class="ma mb mc md gt nc nd ne nf aw ng bi"><span id="8829" class="mp jl in nd b gy nh ni l nj nk">kubectl get storageclass</span></pre><p id="d8f4" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">它会给出这样的输出。在下面的屏幕截图中，您可以看到我们已经创建了名为 longhorn 的存储类。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi nt"><img src="../Images/c0e8804de12c647bfdad5cf4128077a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-f_zgE7t9Uwd2FLJn_l6QQ.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">目标 Kubernetes 集群上存储类的屏幕截图。</figcaption></figure><p id="08f7" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io"> 2。通过在恢复期间更改 PV 中存储类的名称。</strong></p><p id="8ff9" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">更改存储类的另一种方法是，在 Velero 名称空间下的目标集群上创建 configmap。然后 velero 将在迁移过程中更改 PVC 的存储类别。下面是可用于在迁移期间更改存储类名称的配置映射清单。</p><pre class="ma mb mc md gt nc nd ne nf aw ng bi"><span id="36e0" class="mp jl in nd b gy nh ni l nj nk">apiVersion: v1<br/>kind: ConfigMap<br/>metadata:<br/>  # any name can be used; Velero uses the labels (below)<br/>  # to identify it rather than the name<br/>  name: change-storage-class-config<br/>  # must be in the velero namespace<br/>  namespace: velero<br/>  # the below labels should be used verbatim in your<br/>  # ConfigMap.<br/>  labels:<br/>    # this value-less label identifies the ConfigMap as<br/>    # config for a plugin (i.e. the built-in restore item action plugin)<br/>    velero.io/plugin-config: ""<br/>    # this label identifies the name and kind of plugin<br/>    # that this ConfigMap is for.<br/>    velero.io/change-storage-class: RestoreItemAction<br/>data:<br/>  # add 1+ key-value pairs here, where the key is the old<br/>  # storage class name and the value is the new storage<br/>  # class name.<br/>  # &lt;old-storage-class&gt;: &lt;new-storage-class&gt;<br/>  <strong class="nd io">longhorn: rook-cephfs</strong></span></pre><p id="5376" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">在上面的代码中，我们提到了旧的存储类名<strong class="kk io"> longhorn </strong>和新的存储类名<strong class="kk io"> rook-cephfs </strong>。</p><p id="32b3" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">您可以使用下面提到的命令创建配置映射:-</p><pre class="ma mb mc md gt nc nd ne nf aw ng bi"><span id="123d" class="mp jl in nd b gy nh ni l nj nk">kubectl apply -f &lt;name-of-configmap&gt;</span></pre><p id="b7e8" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">在目标 Kubernetes 集群上创建配置映射。部署完成后，我们将进入下一步。</p><blockquote class="nu nv nw"><p id="3e22" class="ki kj nb kk b kl lg kn ko kp lh kr ks nx li kv kw ny lj kz la nz lk ld le lf ig bi translated"><strong class="kk io">在本教程中，我们使用了第二种方法，即在目标 kubernetes 集群上的 velero 名称空间中创建 configmap。</strong></p></blockquote><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/68e4bc830a2c4e81ce0131553b4b4c49.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/0*SHQdlacKmCEclf1X"/></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">velero 命名空间中部署的 configmap 的屏幕截图。</figcaption></figure><h2 id="16f7" class="mp jl in bd jm mq mr dn jq ms mt dp ju kt mu mv jy kx mw mx kc lb my mz kg na bi translated">备份:</h2><p id="2d01" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">假设您已经完成了本文档中提到的所有必要步骤，并准备好进行备份和迁移应用程序。</p><p id="9fa0" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">现在，让我们备份这个部署。使用下面提到的命令进行备份。</p><p id="f70b" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io"><em class="nb">#对源 Kubernetes 集群运行这些备份命令。</em>T25】</strong></p><pre class="ma mb mc md gt nc nd ne nf aw ng bi"><span id="30c3" class="mp jl in nd b gy nh ni l nj nk">velero backup create &lt;backup-name&gt; --include-namespaces &lt;namespace&gt;</span></pre><p id="dd0b" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">您可以通过运行以下命令来检查备份的状态。</p><pre class="ma mb mc md gt nc nd ne nf aw ng bi"><span id="82f9" class="mp jl in nd b gy nh ni l nj nk">velero backup describe &lt;backup-name&gt;</span></pre><p id="d0d9" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">假设您的备份现在已完成，让我们转到目标群集。</p><h2 id="6f33" class="mp jl in bd jm mq mr dn jq ms mt dp ju kt mu mv jy kx mw mx kc lb my mz kg na bi translated">恢复</h2><p id="bcb0" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在恢复备份之前，请验证您可以访问存储在 S3 上的备份。使用以下命令进行检查。</p><p id="f8d5" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io"><em class="nb">#在目标 Kubernetes 集群上运行这些备份命令。</em>T3】</strong></p><pre class="ma mb mc md gt nc nd ne nf aw ng bi"><span id="6ad6" class="mp jl in nd b gy nh ni l nj nk">velero backup get</span></pre><p id="a603" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">上述命令的输出将是:-</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi ob"><img src="../Images/6b9745f5f433cc314e881a205a75d2bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DKC6QyhZGOx4sIMF"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">velero backup 命令的屏幕截图。</figcaption></figure><p id="37e5" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">备份是我们备份的名字。您还可以在您创建的 S3 存储桶上检查备份。</p><p id="7c9f" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">要在目标 Kubernetes 集群上恢复备份，请在目标集群上运行下面提到的命令。</p><pre class="ma mb mc md gt nc nd ne nf aw ng bi"><span id="8a41" class="mp jl in nd b gy nh ni l nj nk">velero restore create --from-backup &lt;backup-name&gt; --include-namespaces &lt;namespace-name&gt;</span></pre><p id="f6fe" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">您可以通过运行命令来检查备份的状态。</p><pre class="ma mb mc md gt nc nd ne nf aw ng bi"><span id="4c04" class="mp jl in nd b gy nh ni l nj nk">velero restore describe &lt;backup-name&gt;</span></pre><p id="499b" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">恢复完成后，您可以检查目标 Kubernetes 集群上的部署。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi oc"><img src="../Images/aa7de2b76381927efe1b0419249aae38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pg-7Hv333olPazbG"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">目标 Kubernetes 集群上恢复的应用程序的屏幕截图。</figcaption></figure><p id="2b3c" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">正如您在上面的屏幕截图中看到的，PVC 是使用存储类“rook-cephfs”创建的。</p><p id="3777" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">下面是目标类中使用的存储类的屏幕截图。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi od"><img src="../Images/cca240f3452897bd8ee309cc79f6a20a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9zV_QNbPy_osrDzASs8fhw.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">目标 Kubernetes 集群中使用的存储类的屏幕截图。</figcaption></figure><p id="89a4" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">让我们在浏览器上检查一下 WordPress 站点。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi oe"><img src="../Images/9a478981ae13e9cc486537ffbab68eac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yOLk7nf2oMt__UhV"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">在目标 Kubernetes 集群上运行的应用程序的屏幕截图。</figcaption></figure><p id="073e" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">正如您在上面的截图中看到的，我们的应用程序随着 PVC 中的数据一起迁移。</p><h2 id="7eae" class="mp jl in bd jm mq mr dn jq ms mt dp ju kt mu mv jy kx mw mx kc lb my mz kg na bi translated"><strong class="ak">自动化备份</strong></h2><p id="3dfc" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">我们还可以自动备份我们的群集资源。这样我们就可以在发生灾难时恢复数据。</p><p id="0b6b" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">对于自动化备份作业，我们使用 corn expression。这个计划操作允许我们在 cron 表达式中提到的时间创建数据的备份。</p><pre class="ma mb mc md gt nc nd ne nf aw ng bi"><span id="0003" class="mp jl in nd b gy nh ni l nj nk">velero schedule create NAME --schedule=”* * * * *” [flags]</span></pre><p id="29bf" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">Cron 计划使用下面提到的格式:</p><pre class="ma mb mc md gt nc nd ne nf aw ng bi"><span id="c874" class="mp jl in nd b gy nh ni l nj nk"># ┌───────────── minute (0 - 59)<br/># │ ┌───────────── hour (0 - 23)<br/># │ │ ┌───────────── day of the month (1 - 31)<br/># │ │ │ ┌───────────── month (1 - 12)<br/># │ │ │ │ ┌───────────── day of the week (0 - 6) (Sunday to Saturday;<br/># │ │ │ │ │                                   7 is also Sunday on some systems)<br/># │ │ │ │ │<br/># │ │ │ │ │<br/># * * * * *</span></pre><p id="daa0" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">例如:</p><pre class="ma mb mc md gt nc nd ne nf aw ng bi"><span id="0198" class="mp jl in nd b gy nh ni l nj nk">velero schedule create demo-schedule --schedule=”0 9* * *”</span></pre><p id="4cc1" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">该命令将在 Velero 中创建备份 demo-schedule，但是该备份直到下一个预定时间上午 9 点才会执行。由计划创建的备份以名称<strong class="kk io"> &lt;计划名称&gt; - &lt;时间戳&gt;，</strong>保存，其中<strong class="kk io"> &lt;计划名称&gt; </strong>是我们在命令中提到的名称，而<strong class="kk io"> &lt;时间戳&gt; </strong>的格式为 YYYYMMDDhhmmss。</p><p id="9ee2" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">要检查可用配置的完整列表，flags 使用 Velero CLI help 命令。</p><pre class="ma mb mc md gt nc nd ne nf aw ng bi"><span id="6e86" class="mp jl in nd b gy nh ni l nj nk">velero schedule create --help</span></pre></div></div>    
</body>
</html>