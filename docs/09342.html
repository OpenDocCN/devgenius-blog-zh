<html>
<head>
<title>SQL Practice questions — #4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL 练习问题— #4</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/sql-practice-questions-4-e24a6bdb32d4?source=collection_archive---------17-----------------------#2022-08-15">https://blog.devgenius.io/sql-practice-questions-4-e24a6bdb32d4?source=collection_archive---------17-----------------------#2022-08-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="2138" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第四部分 SQL 实践问题</p><p id="8cf6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">点击此处查看<a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/sql-practice-questions-1-800ed65d99b2">第一部分</a> <a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/sql-practice-questions-2-f1116b1f5402">第二部分</a> <a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/sql-practice-questions-3-9fd3d6e56058">第三部分</a> <a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/sql-practice-questions-5-456cfb41757a">第五部分</a></p><h1 id="db6f" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">问题 1</h1><p id="ab02" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">写一个 SQL 查询来交换每两个连续学生的座位号。如果学生人数是奇数，则不会交换最后一名学生的 id。返回按<code class="fe lm ln lo lp b">id</code> <strong class="jm io">排序的结果表，升序为</strong>。</p><p id="3611" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">示例:</strong></p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="09b7" class="ly kk in lp b gy lz ma l mb mc"><strong class="lp io">Input:</strong> <br/>Seat table:<br/>+----+---------+<br/>| id | student |<br/>+----+---------+<br/>| 1  | Abbot   |<br/>| 2  | Doris   |<br/>| 3  | Emerson |<br/>| 4  | Green   |<br/>| 5  | Jeames  |<br/>+----+---------+<br/><strong class="lp io">Output:</strong> <br/>+----+---------+<br/>| id | student |<br/>+----+---------+<br/>| 1  | Doris   |<br/>| 2  | Abbot   |<br/>| 3  | Green   |<br/>| 4  | Emerson |<br/>| 5  | Jeames  |<br/>+----+---------+<br/><strong class="lp io">Explanation:</strong> <br/>Note that if the number of students is odd, there is no need to change the last one's seat.</span></pre><p id="f31a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">方法:</strong>交换用例时，根据 id 是奇数还是偶数来选择上一个的值。T</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="250e" class="ly kk in lp b gy lz ma l mb mc">SELECT <br/>    CASE <br/>      WHEN MOD(id, 2)=1 AND id != (SELECT COUNT(*) FROM seat) THEN id+1<br/>      WHEN MOD(id, 2)=0 THEN id-1<br/>      ELSE id <br/>    END as id, <br/>    student<br/>FROM seat<br/>ORDER BY id</span></pre><p id="ba26" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的查询中，我们正在评估每行的座位数，如果我们使用自连接，我们可以改进这一点。</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="3772" class="ly kk in lp b gy lz ma l mb mc">SELECT s1.id as id, coalesce(s2.student, s1.student) as student<br/>FROM Seat as s1<br/>LEFT join Seat as s2<br/>ON (s1.id%2=0 AND s1.id = s2.id+1) OR (s1.id%2=1 AND s1.id=s2.id-1)</span></pre><h1 id="939c" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">问题 2</h1><p id="6004" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">编写一个 SQL 查询来查找<code class="fe lm ln lo lp b">2019-08-16</code>上所有产品的价格。假设所有产品变更前的价格为<code class="fe lm ln lo lp b">10</code>。按<strong class="jm io">任意顺序返回结果表</strong>。</p><p id="33ba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">例:</strong></p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="2669" class="ly kk in lp b gy lz ma l mb mc"><strong class="lp io">Input:</strong> <br/>Products table:<br/>+------------+-----------+-------------+<br/>| product_id | new_price | change_date |<br/>+------------+-----------+-------------+<br/>| 1          | 20        | 2019-08-14  |<br/>| 2          | 50        | 2019-08-14  |<br/>| 1          | 30        | 2019-08-15  |<br/>| 1          | 35        | 2019-08-16  |<br/>| 2          | 65        | 2019-08-17  |<br/>| 3          | 20        | 2019-08-18  |<br/>+------------+-----------+-------------+<br/><strong class="lp io">Output:</strong> <br/>+------------+-------+<br/>| product_id | price |<br/>+------------+-------+<br/>| 2          | 50    |<br/>| 1          | 35    |<br/>| 3          | 10    |<br/>+------------+-------+</span></pre><p id="773c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">方式:</strong>通过排名来选择产品的最后一次变更日期。如果是最后一个<code class="fe lm ln lo lp b">change_date &lt; 2019–08–16</code>我们就接受这个价格。我们对所有产品进行联合，并将它们的价格表示为 10，这在最后一次查询(cte)中没有出现</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="5ef1" class="ly kk in lp b gy lz ma l mb mc">WITH cte as (<br/>    select product_id, new_price, <br/>    rank() over(<br/>          PARTITION BY product_id ORDER BY change_date desc<br/>        ) as rnk from Products<br/>    WHERE change_date &lt;= '2019-08-16'<br/>)<br/>SELECT product_id, new_price as price <br/>FROM cte <br/>WHERE rnk = 1</span><span id="b464" class="ly kk in lp b gy md ma l mb mc">UNION</span><span id="b48b" class="ly kk in lp b gy md ma l mb mc">SELECT product_id, 10  <br/>FROM Products <br/>WHERE product_id NOT IN (SELECT product_id from cte)</span></pre><h1 id="d039" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">问题 3</h1><p id="4a3b" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">编写一个 SQL 查询来报告每个玩家赢得的大满贯锦标赛的数量。不包括未赢得任何锦标赛的球员。按<strong class="jm io">任意顺序返回结果表</strong>。</p><p id="99da" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">例:</strong></p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="733c" class="ly kk in lp b gy lz ma l mb mc"><strong class="lp io">Input:</strong> <br/>Players table:<br/>+-----------+-------------+<br/>| player_id | player_name |<br/>+-----------+-------------+<br/>| 1         | Nadal       |<br/>| 2         | Federer     |<br/>| 3         | Novak       |<br/>+-----------+-------------+<br/>Championships table:<br/>+------+-----------+---------+---------+---------+<br/>| year | Wimbledon | Fr_open | US_open | Au_open |<br/>+------+-----------+---------+---------+---------+<br/>| 2018 | 1         | 1       | 1       | 1       |<br/>| 2019 | 1         | 1       | 2       | 2       |<br/>| 2020 | 2         | 1       | 2       | 2       |<br/>+------+-----------+---------+---------+---------+<br/><strong class="lp io">Output:</strong> <br/>+-----------+-------------+-------------------+<br/>| player_id | player_name | grand_slams_count |<br/>+-----------+-------------+-------------------+<br/>| 2         | Federer     | 5                 |<br/>| 1         | Nadal       | 7                 |</span></pre><p id="4265" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">方法</p><p id="c6fc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这与 UNPIVOT 类似。但是 MySQL 没有 UNPIVOT 命令。我们采用了与 PIVOT 类似的方法。我们可以创建四个结果集，每个结果集都属于锦标赛类型，然后根据获胜者标识将它们组合起来，以获得获胜次数。</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="c944" class="ly kk in lp b gy lz ma l mb mc">WITH CTE AS<br/>(<br/>    SELECT Wimbledon as won<br/>    FROM Championships<br/>        <br/>    UNION ALL<br/>    <br/>    SELECT Fr_open as won<br/>    FROM Championships<br/>    <br/>    UNION ALL<br/>    <br/>    SELECT US_open as won<br/>    FROM Championships<br/>    <br/>    UNION ALL<br/>    <br/>    SELECT Au_open as won<br/>    FROM Championships<br/>)<br/>SELECT player_id, player_name, <br/>    COUNT(won) as grand_slams_count<br/>FROM Players P<br/>INNER JOIN CTE <br/>ON P.player_id = CTE.won<br/>group by player_id</span></pre><p id="feb5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的查询中，我们对表扫描了 4 次才得到结果，我们能做得更好吗？是的。我们可以使用 when 子句，并在一次扫描中获得相同的结果。</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="7e1e" class="ly kk in lp b gy lz ma l mb mc">WITH cte as (<br/>  SELECT player_id, player_name,<br/>   (SUM(case when wimbledon = player_id then 1 else 0 end ))+<br/>    (SUM(case when Fr_open = player_id then 1 else 0 end ))+<br/>    (SUM(case when US_open = player_id then 1 else 0 end ))+<br/>    (SUM(case when Au_open = player_id then 1 else 0 end ))<br/>    as grand_slams_count<br/>  FROM championships, players<br/>  GROUP BY player_id<br/>  HAVING grand_slams_count !=0<br/>)<br/>select * from cte</span></pre><h1 id="833a" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">问题 4</h1><p id="0f72" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">你正在经营一个电子商务网站，寻找<strong class="jm io">不平衡订单</strong>。<strong class="jm io">不平衡订单</strong>是指每张订单(包括其本身)的<strong class="jm io">最大</strong>数量严格大于的<strong class="jm io">平均</strong>数量。</p><p id="9e1f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">订单的<strong class="jm io">平均</strong>数量计算为<code class="fe lm ln lo lp b">(total quantity of all products in the order) / (number of different products in the order)</code>。订单的<strong class="jm io">最大</strong>数量是订单中任一单个产品的最大<code class="fe lm ln lo lp b">quantity</code>。</p><p id="f9e3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">编写一个 SQL 查询来查找所有不平衡订单的<code class="fe lm ln lo lp b">order_id</code>。返回<strong class="jm io">任意顺序</strong>的结果表。</p><p id="f4c0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">例 1: </strong></p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="1d36" class="ly kk in lp b gy lz ma l mb mc"><strong class="lp io">Input:</strong> <br/>OrdersDetails table:<br/>+----------+------------+----------+<br/>| order_id | product_id | quantity |<br/>+----------+------------+----------+<br/>| 1        | 1          | 12       |<br/>| 1        | 2          | 10       |<br/>| 1        | 3          | 15       |<br/>| 2        | 1          | 8        |<br/>| 2        | 4          | 4        |<br/>| 2        | 5          | 6        |<br/>| 3        | 3          | 5        |<br/>| 3        | 4          | 18       |<br/>| 4        | 5          | 2        |<br/>| 4        | 6          | 8        |<br/>| 5        | 7          | 9        |<br/>| 5        | 8          | 9        |<br/>| 3        | 9          | 20       |<br/>| 2        | 9          | 4        |<br/>+----------+------------+----------+<br/><strong class="lp io">Output:</strong> <br/>+----------+<br/>| order_id |<br/>+----------+<br/>| 1        |<br/>| 3        |<br/>+----------+</span></pre><p id="d6d4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">方法:我们需要首先计算每个订单 id 的平均订单数量。然后我们找到最大订货量大于所有平均订货量的订单。</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="0f68" class="ly kk in lp b gy lz ma l mb mc">SELECT order_id<br/>FROM OrdersDetails <br/>GROUP BY order_id<br/>HAVING max(quantity) &gt; ALL(<br/>   SELECT avg(quantity) FROM OrdersDetails group by order_id<br/>)</span></pre><p id="204c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的查询很慢，因为 Having 子句中的子查询是针对每个 order_id 执行的，并且所有关键字都检查所有平均值。在当前示例中，比较进行了 5 * 5 次。我们可以通过使用 CTE 方法来减少这种调用。</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="de31" class="ly kk in lp b gy lz ma l mb mc">WITH temp as <br/>(<br/>    SELECT order_id, avg(quantity) as avg_q, max(quantity) as max_q<br/>    FROM OrdersDetails<br/>    GROUP BY order_id<br/>)</span><span id="cac6" class="ly kk in lp b gy md ma l mb mc">SELECT order_id <br/>from temp<br/>where max_q &gt; (select max(avg_q) from temp )</span></pre><p id="727a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">查询愉快！！！</p></div></div>    
</body>
</html>