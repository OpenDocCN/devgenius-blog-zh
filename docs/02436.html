<html>
<head>
<title>Cracking the DFS and BFS in FAANG Interview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在FAANG访谈中破解DFS和BFS</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/cracking-the-dfs-and-bfs-in-faang-interview-5589127c3f76?source=collection_archive---------1-----------------------#2020-08-04">https://blog.devgenius.io/cracking-the-dfs-and-bfs-in-faang-interview-5589127c3f76?source=collection_archive---------1-----------------------#2020-08-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6a5cfefa5aa50224cb2f842ed7eaf178.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*J58kDmynJDQCSbla"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">克里斯·莱佩尔特在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="c1a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在大多数<a class="ae kc" href="https://en.wikipedia.org/wiki/Big_Tech" rel="noopener ugc nofollow" target="_blank"> FAANG </a>公司的编码测试中。考生总是会遇到图形问题。与此同时，随着我们生活在一个没有孤立信息的互联世界，图表的使用变得越来越普遍。如果Linkedin想推荐你可能感兴趣的人，它必须通过你的朋友图表找到最有可能的人。如果系统想要推荐停车场中的最短位置，它必须尝试所有不同的路径来找到正确的路径。</p><blockquote class="lb"><p id="7ec9" class="lc ld iq bd le lf lg lh li lj lk la dk translated">图形无处不在。</p></blockquote><h1 id="9202" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">什么是图形？</h1><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/8bc1c3e3704effc24141c24f69321c78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SNeqOwzT8tvGwsVS"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kc" href="https://unsplash.com/@jannerboy62?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">刻痕</a>拍摄</figcaption></figure><p id="15bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们生活在构成世界的图表中。我们的高速公路，地铁是相互交叉的。我们从一个地点出发，驾车穿过高速公路，到达目标地点。与此同时，成千上万的人开车通过不同的方式前往不同的地点。有了这些，我们就有了高速公路的图表。在这种情况下，位置是一个顶点，公路是一条边。</p><p id="afb6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正常的图表如下所示:</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/52645a246871045d3421a5ee19efe214.png" data-original-src="https://miro.medium.com/v2/resize:fit:458/0*MLGpyPjliRIEoy9L"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">单向图</figcaption></figure><h1 id="f406" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw mp ly lz ma mq mc md me mr mg mh mi bi translated">表示图形的三种方式</h1><p id="9bd5" class="pw-post-body-paragraph kd ke iq kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated"><strong class="kf ir">顶点和边:</strong></p><p id="f610" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下面的二维数组中，数组中的每个数组都是由两个顶点组合而成的边。</p><p id="b8d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如:[0，1]表示从顶点0到顶点1的单向边</p><pre class="mk ml mm mn gt mx my mz na aw nb bi"><span id="5daf" class="nc lm iq my b gy nd ne l nf ng">[ [0,1], [0,6], [0,8], [1,4], [1,6], [1,9], [2,4], [2,6], [3,4], [3,5],[3,8], [4,5], [4,9], [7,8], [7,9] ]</span></pre><p id="7883" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">邻接矩阵:</strong></p><ul class=""><li id="df42" class="nh ni iq kf b kg kh kk kl ko nj ks nk kw nl la nm nn no np bi translated">邻接矩阵是一种顺序表示。</li><li id="c1ae" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated">它表示彼此相邻的节点。</li><li id="3885" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated">在这个表示中，我们要构造一个n*n的矩阵A，如果从一个顶点I到顶点j有一条边，则A的对应元素Ai，j = 1，否则Ai，j= 0。</li></ul><pre class="mk ml mm mn gt mx my mz na aw nb bi"><span id="0b0d" class="nc lm iq my b gy nd ne l nf ng">[  A  B  C  D  E  F  G  H  I  J<br/> A[0, 1, 0, 0, 0, 0, 1, 0, 1, 0],<br/> B[1, 0, 0, 0, 1, 0, 1, 0, 0, 1],<br/> C[0, 0, 0, 0, 1, 0, 1, 0, 0, 0],<br/> D[0, 0, 0, 0, 1, 1, 0, 0, 1, 0],<br/> E[0, 1, 1, 1, 0, 1, 0, 0, 0, 1],<br/> F[0, 0, 0, 1, 1, 0, 0, 0, 0, 0],<br/> G[1, 1, 1, 0, 0, 0, 0, 0, 0, 0],<br/> H[0, 0, 0, 0, 0, 0, 0, 0, 1, 1],<br/> I[1, 0, 0, 1, 0, 0, 0, 1, 0, 0],<br/> J[0, 1, 0, 0, 1, 0, 0, 1, 0, 0] ]</span></pre><p id="f3c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">邻接表:</strong></p><ul class=""><li id="1aa6" class="nh ni iq kf b kg kh kk kl ko nj ks nk kw nl la nm nn no np bi translated">邻接表是一种链接的表示。</li><li id="ae1e" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated">在这种表示中，对于图中的每个顶点，我们维护其邻居的列表。这意味着，图的每个顶点都包含其相邻顶点的列表。</li><li id="6ffa" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated">HashMap是维护这种结构的好选择。我们可以把顶点作为关键字，邻居列表作为值。</li></ul><pre class="mk ml mm mn gt mx my mz na aw nb bi"><span id="dfda" class="nc lm iq my b gy nd ne l nf ng">  vertice    Adjacency array<br/>{  <br/>     1    :  [1, 6, 8],<br/>     2    :  [0, 4, 6, 9],<br/>     3    :  [4, 6],<br/>     4    :  [4, 5, 8],<br/>     5    :  [1, 2, 3, 5, 9],<br/>     6    :  [3, 4],<br/>     7    :  [0, 1, 2],<br/>     8    :  [8, 9],<br/>     9    :  [0, 3, 7],<br/>     0    :  [1, 4, 7] <br/>}</span></pre><h1 id="6ebb" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw mp ly lz ma mq mc md me mr mg mh mi bi translated">在图表中搜索</h1><p id="a00e" class="pw-post-body-paragraph kd ke iq kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated"><strong class="kf ir">深度优先搜索:</strong></p><p id="672a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">顾名思义，我们选择一个起始顶点，然后一个接一个地遍历，直到找到目标顶点。</p><p id="c7bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们发现一个死胡同，这意味着这不是正确的道路。我们返回原路。然后，我们检查已访问顶点中的未访问邻居，并从那里开始探索其他路径。</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图形-dfs</figcaption></figure><p id="6223" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基本上我们只是尝试所有可能的方法来找到目标。为了提高效率，我们不重复访问过的顶点。因此我们需要一个<em class="nx">访问过的</em>数组。</p><p id="e015" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在迷宫游戏中，我们必须找到目标。此外，在不同的路径上有一些块。所以我们可能需要设计一个不同的函数来寻找邻居。</p><p id="c33d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">DFS的用途包括:</p><ul class=""><li id="13ed" class="nh ni iq kf b kg kh kk kl ko nj ks nk kw nl la nm nn no np bi translated">在大型图中搜索连通区域的数量</li><li id="bbaf" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated">搜索图形中的任何圆</li><li id="d6ac" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated">检查并获得图中两个顶点之间的路径</li></ul><p id="779a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">深度优先搜索访问每个顶点一次，检查图中的每个边一次。因此，DFS的时间复杂度为O(|V| + |E|)。但是，在递归搜索时，它占用O(|V|)空间。</p><p id="4efb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">远大第一搜索:</strong></p><p id="293e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于BFS，除了访问过的数组，我们需要一个<em class="nx">队列</em>来管理顶点。</p><blockquote class="ny nz oa"><p id="037a" class="kd ke nx kf b kg kh ki kj kk kl km kn ob kp kq kr oc kt ku kv od kx ky kz la ij bi translated">队列是一种线性结构，它遵循操作执行的特定顺序。顺序是先进先出(FIFO)。</p></blockquote><p id="9e0d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基本上，我们一层一层地遍历顶点，如下所示:</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/b45b20f15b620a5d2c944bfdc875d500.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/format:webp/0*WkVm2bqjqwLjIORD.jpg"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">bfs</figcaption></figure><ul class=""><li id="1dbf" class="nh ni iq kf b kg kh kk kl ko nj ks nk kw nl la nm nn no np bi translated">从第一个顶点开始，我们将顶点的邻居添加到队列中。</li><li id="6818" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated">如果队列不为空，我们从队列中弹出元素。这个时候，我们可以做一些工作。</li><li id="7d5a" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated">我们将poped vertice的未访问邻居推入队列。此外，我们将顶点标记为已访问。</li></ul><p id="59da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代码如下:</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="97fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">BFS的用法:</p><ul class=""><li id="344f" class="nh ni iq kf b kg kh kk kl ko nj ks nk kw nl la nm nn no np bi translated">在图中寻找最短路径</li><li id="d375" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated">在社交网络中，我们可以使用广度优先搜索直到“k”级来找到与一个人相距给定距离“k”以内的人。</li><li id="1684" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated">在像<a class="ae kc" href="https://www.geeksforgeeks.org/how-bittorrent-works/" rel="noopener ugc nofollow" target="_blank"> BitTorrent </a>这样的对等网络中，广度优先搜索用于查找所有邻居节点。</li></ul><p id="9a8b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">BFS的复杂性:</p><p id="2765" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">广度优先搜索的时间复杂度是O(|V| + |E|)，因为我们只检查每个顶点和边一次。因为我们可以遍历顶点，所以不需要额外的空间。</p><h1 id="b087" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw mp ly lz ma mq mc md me mr mg mh mi bi translated">BFS和DFS的比较:</h1><ul class=""><li id="8140" class="nh ni iq kf b kg ms kk mt ko of ks og kw oh la nm nn no np bi translated">BFS首先检查所有邻居，这不适合游戏或谜题中使用的路径搜索规则。DFS是解决游戏或难题的一个很好的选择。它探索所有可能的路径，如果它到达目标时停止，否则它就继续尝试。</li><li id="f2ea" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated">BFS适合搜索离给定源更近的顶点。当目标远离源时，DFS是合适的。</li><li id="6714" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated">在BFS中，我们从一个源顶点到达一个边数最少的顶点。在DFS中，我们可能会遍历并重复许多顶点，从一个源到达一个目的地。</li></ul><h1 id="5e50" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw mp ly lz ma mq mc md me mr mg mh mi bi translated">最后的话</h1><p id="c265" class="pw-post-body-paragraph kd ke iq kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">如果你知道树数据结构和学习图形。你会看到树是一个只有两个孩子的特殊图形。因此，BFS和DFS可以应用于树和图。大型科技公司确实喜欢问图表类型的问题，因为他们的数据和关系更加复杂。</p><p id="222c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">希望你能从这篇文章中学到一些东西。如果你有兴趣阅读我的其他文章，欢迎查看我的个人资料。你也可以通过媒体或邮件联系我。</p></div></div>    
</body>
</html>