<html>
<head>
<title>Virtual Column and Computed Column solutions for TypeORM in Nestjs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Nestjs 中 TypeORM 的虚拟列和计算列解决方案</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/virtual-column-and-computer-column-solutions-for-typeorm-in-nestjs-7a4d44b34923?source=collection_archive---------0-----------------------#2022-08-08">https://blog.devgenius.io/virtual-column-and-computer-column-solutions-for-typeorm-in-nestjs-7a4d44b34923?source=collection_archive---------0-----------------------#2022-08-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b543332bdfa692264e51a97603b112bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4qVhZqm3Tk3HE9Wefi-i1Q.png"/></div></div></figure><p id="85c2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你完全欣赏前端的<strong class="jx io"> <em class="kt">计算属性</em> </strong>的技术，那么你肯定也想在后端实现它。在大多数情况下，您有足够的信息来计算要显示的项目，所以您不想增加保存这种数据的难度。</p><p id="7fe8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，您手上已经有了名字和姓氏，您不需要浪费一个字节来保存全名，或者您已经有了关于长度和宽度的数据，您不喜欢将区域数据放在您的数据库中。</p><p id="1e57" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我确信<em class="kt">虚拟列</em>或<em class="kt">计算列</em>术语应该会出现在您的脑海中。如果我错了请纠正我，这个要求到目前为止还没有正式实现。</p><p id="3db9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，让我们来谈谈来自开发人员世界的提示和技巧，我知道有一位开发人员写了一篇关于这个主题的文章，谢谢 Adrian Pietrzak，他激励我们更好地解决这个问题。</p><p id="be39" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有些开发者使用<em class="kt">非可选列</em>、<em class="kt"> getRaw()方法</em>、<em class="kt">订阅者方法</em>和<em class="kt">loadRelationCountAndMap()</em>等。对于实现，我想在这里介绍两个与 decorator 相关的食谱，因为我是 decorator 的忠实粉丝:)。</p><h1 id="9ef2" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">I .装饰方法</h1><p id="be56" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">我真的很喜欢使用装饰者来保持我的代码整洁，以一种更符合逻辑和更有表现力的方式可读。坦率地说，Java Spring Boot 的注释用法给了我很大的启发。</p><p id="50cd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在 Nestjs 中，您可以在几秒钟内轻松构建自己的装饰器，如果我们在模型中声明一个内置的<code class="fe lx ly lz ma b"><strong class="jx io">@VirtualColumn()</strong></code>装饰器，并且当我们使用<code class="fe lx ly lz ma b"><strong class="jx io">.addSelect()</strong></code>时，结果将被分配给那个键，这将是非常理想的。所以我们来编程吧。</p><p id="61a5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们从创建一个装饰器开始:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="5ee1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们可以将它导入到我们的实体中，并将其分配给一个新的字段:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="1e99" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">装饰者只为我们添加了元数据，但我们仍然需要编写逻辑来告诉 TypeORM 我们需要为这些元数据做什么，所以现在我们需要以一种体面的方式覆盖核心 TypeORM 函数<code class="fe lx ly lz ma b"><strong class="jx io">.getOne()</strong></code>和<code class="fe lx ly lz ma b"><strong class="jx io">.getMany()</strong></code>。我们想把这个逻辑添加到一个名为<strong class="jx io"> <em class="kt">的文件中</em></strong></p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="fd09" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您需要在正确的位置实现我们的代码以便编译，只需在<strong class="jx io"><em class="kt">app . module . ts</em></strong>中导入<strong class="jx io"> <em class="kt"> pollyfill </em> </strong></p><pre class="mb mc md me gt mh ma mi mj aw mk bi"><span id="5cc5" class="ml kv in ma b gy mm mn l mo mp"><strong class="ma io">import './polyfill';</strong></span></pre><p id="a591" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我扩展了用户服务，添加了一个返回多个用户的额外方法，并添加了<code class="fe lx ly lz ma b"><strong class="jx io">.addSelect()</strong></code>函数:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="485c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我创建了一个额外的控制器来运行我的功能:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="6d28" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，当我添加<code class="fe lx ly lz ma b"><strong class="jx io">.addSelect()</strong></code>并将结果分配给虚拟列名时，应用程序将执行以下 SQL 操作:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="bacb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它将返回<code class="fe lx ly lz ma b"><strong class="jx io">.getOne()</strong></code>和<code class="fe lx ly lz ma b"><strong class="jx io">.getMany()</strong></code>函数的映射模型，就像你一直想要的那样。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="2d08" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">形式上，这个食谱已经达到了目的，如果你喜欢 QueryBuilder 的话。不幸的是，我对此不太感兴趣，您可能已经注意到了，并准备张嘴大喊:<em class="kt">如果我使用存储库或活动记录，我该怎么办？</em>或者不使用<code class="fe lx ly lz ma b"><strong class="jx io">.getOne()</strong></code>和<code class="fe lx ly lz ma b"><strong class="jx io">.getMany() </strong></code>功能如何生存。例如，您正在使用<code class="fe lx ly lz ma b"><strong class="jx io">.getManyAndCount()</strong></code>，那么您必须在 pollyfill.ts 中覆盖更多的函数，如下所示:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="dcba" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有没有一种方法可以更简单，适用于大多数场景？让我们回到订阅者选项，订阅者解决方案是开发人员最常选择的。它使用订阅者<code class="fe lx ly lz ma b"><strong class="jx io">.AfterLoad()</strong></code>将每次给定的结果添加到加载的模型中。但是缺点是显而易见的，您的业务逻辑现在将在您每次尝试加载实体时被执行。</p><h1 id="a234" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">二。订户装饰者</h1><p id="25f8" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">让我们从第一个配方中的所有修改回滚，我们只需要修改 user.entity.ts，如下所示:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="0e2e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">瞧啊。结束了。我只是在实体中定义了一个具有任意名称的方法(在本例中为<code class="fe lx ly lz ma b"><strong class="jx io">generateFullname()</strong></code>)并用<code class="fe lx ly lz ma b"><strong class="jx io">.AfterLoad()</strong></code>、<code class="fe lx ly lz ma b"><strong class="jx io">.AfterInsert()</strong></code>和<code class="fe lx ly lz ma b"><strong class="jx io">.AfterUpdate()</strong></code>标记它，TypeORM 将在每次使用 QueryBuilder 或 repository/manager find 方法加载实体时调用它。我想这个食谱会让我的生活更轻松。</p><h1 id="85f8" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结论</h1><p id="0dc2" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">没有什么是完美的，没有什么是不完美的。完美和不完美存在于你的用例中。第一种方法为大量的关联搜索提供了高效率，但是为每个虚拟列编写逻辑并覆盖几个类型方法并不容易。第二种更简单，基本上适合不复杂的用例，但是它会影响你的效率。</p><p id="6c69" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你也可以在我的<a class="ae mq" href="https://medium.com/@joosepwong" rel="noopener">medium.com</a>上看到这篇文章，在那里我分享了我在软件工程师职业生涯中遇到的问题的解决方案。</p><p id="3a9d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您还有其他问题，请随时通过<a class="ae mq" href="https://www.linkedin.com/in/joosepwong/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>联系我。</p><p id="69a6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">科图米塞尼！</p></div></div>    
</body>
</html>