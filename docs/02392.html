<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://blog.devgenius.io/hello-and-welcome-to-the-spiral-matrix-523b1d14573b?source=collection_archive---------6-----------------------#2020-08-01">https://blog.devgenius.io/hello-and-welcome-to-the-spiral-matrix-523b1d14573b?source=collection_archive---------6-----------------------#2020-08-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div class="gh gi il"><img src="../Images/2388066a1f9c571424643acd83e834fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*gU6ZXKzUvwq8oiE5dj_JUw.jpeg"/></div><figcaption class="is it gj gh gi iu iv bd b be z dk translated">倒置螺旋矩阵</figcaption></figure><p id="995b" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">螺旋形</p><p id="c3f2" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">你好，欢迎来到螺旋矩阵</p><p id="d5b3" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">螺旋矩阵是最广为人知的代码挑战之一，因为这个问题伴随着复杂的逻辑。</p><p id="9627" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">让我们看一下说明。</p><figure class="jw jx jy jz gt ip gh gi paragraph-image"><div class="gh gi jv"><img src="../Images/ab5f6035ecf36ea5ace507acd209d919.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*j2zQF4oDbYmDhcVBhb0Eiw.png"/></div><figcaption class="is it gj gh gi iu iv bd b be z dk translated">方向</figcaption></figure><p id="f182" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">因此，给定一个数字 n，我们想返回一个 n*n 矩阵，其中的值遵循一个螺旋模式，从左上角开始，在中间的某个地方结束。</p><p id="ddef" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">本质上，我们将创建一个子数组的数组来保存我们的螺旋值。</p><h1 id="819f" class="ka kb iy bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">那么我们从哪里开始呢？</h1><p id="d527" class="pw-post-body-paragraph iw ix iy iz b ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq lc js jt ju ig bi translated">如果我们研究一下螺旋矩阵，我们会注意到它遵循一种模式。</p><p id="b9e7" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">它向右、向下、向左、向上，并再次重新开始循环。复制这种模式的关键是知道<strong class="iz ld"> <em class="le">何时</em> </strong>我们已经到达行/列的末尾，当我们到达末尾时，我们将需要<strong class="iz ld"> <em class="le">改变方向</em> </strong>。</p><p id="e319" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">实现这个逻辑的一个重要部分是，我们希望确保一旦我们遍历了整个行或列，我们就不想再担心那个行/列了。我们玩完了。</p><p id="2481" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">所以你可以想象，我们从左到右做第一行，一旦我们完成了第一行，它需要消失。</p><p id="cf71" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我们可以通过创建表示开始行、结束行、开始列和结束列的索引的全局变量来跟踪我们在矩阵中的位置。</p><p id="2faa" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">这些变量会像这样初始化-</p><figure class="jw jx jy jz gt ip gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/3496cad4ccf7fa156d3a8ef3c582b229.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*-Ie6sc8J6_JLhHkUNqgahQ.png"/></div><figcaption class="is it gj gh gi iu iv bd b be z dk translated">暂时忽略 for 循环</figcaption></figure><p id="5d18" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">因此，在我们进行的过程中，我们将更改这些值，以便我们可以删除以前的行和列，我们不再需要担心这些。我们也将使用这些变量来知道<strong class="iz ld"><em class="le"/></strong>我们在哪里，这样我们就可以知道<strong class="iz ld"> <em class="le">何时</em> </strong>改变方向。</p><p id="7872" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我们将使用的另一个东西是一个全局计数器变量，当我们沿着矩阵向下时，它将用于放置每个子数组中的值。</p><p id="2dc9" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">该变量将从 1 开始，因为螺旋矩阵的值从 1 开始。</p><h1 id="f721" class="ka kb iy bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">我们来谈谈代码-</h1><p id="9e00" class="pw-post-body-paragraph iw ix iy iz b ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq lc js jt ju ig bi translated">那么…这段代码会是什么样子呢？有几种不同的方法可以知道我们什么时候完全完成了螺旋矩阵。</p><p id="5fd8" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">一种方法是设定条件，使计数器变量永远不会超过 n*n 的值，因为最终值将总是 n*n，最终计数器值也是如此。</p><p id="d5c2" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我解决这个问题的方法是创建一个 while 循环，其中有 4 个 for 循环，负责遍历矩阵的每个方向。</p><p id="a575" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">将每个值放入子数组将通过<strong class="iz ld"> <em class="le">索引</em> </strong>每个值的<strong class="iz ld"> <em class="le">位置</em> </strong>来完成。这样，当我们添加新值时，我们可以确保它们将停留在数组中的预期索引中。</p><p id="3a2c" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">只要起始行值不超过结束行值，并且起始列值不超过结束列值，这个 while 循环就会运行。</p><h1 id="04a0" class="ka kb iy bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">呼吸者</h1><p id="a1b4" class="pw-post-body-paragraph iw ix iy iz b ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq lc js jt ju ig bi translated">好吧，这是很多信息。在我们开始编码之前，我只是想让你看一下整个事情，这样你就不会对我们为什么以某种方式编码感到困惑。</p><p id="ac28" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">所以在这篇博客的编码部分，我要做的是分解每一步，这样就不会一次吞下太多东西。</p><h1 id="7497" class="ka kb iy bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">第一步。创建空数组</h1><p id="cee7" class="pw-post-body-paragraph iw ix iy iz b ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq lc js jt ju ig bi translated">首先，我们要初始化一个空数组。(最终)</p><p id="5822" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">接下来，我们将编写一个 for 循环，在最终数组中放置 n 个空数组。</p><p id="0b5c" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">因此，如果传递给函数的数字是 4，我们应该在最终数组中初始化 4 个空数组。</p><p id="ca74" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">让我们继续创建全局变量，这将有助于我们遍历螺旋矩阵。</p><figure class="jw jx jy jz gt ip gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/3496cad4ccf7fa156d3a8ef3c582b229.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*-Ie6sc8J6_JLhHkUNqgahQ.png"/></div><figcaption class="is it gj gh gi iu iv bd b be z dk translated"><strong class="bd kc"> [ []，[]，[]，[] ] </strong></figcaption></figure><h1 id="7751" class="ka kb iy bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">第二步。启动 while 循环</h1><p id="0410" class="pw-post-body-paragraph iw ix iy iz b ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq lc js jt ju ig bi translated">是时候创建我们的 while 循环了。条件是这样的-</p><figure class="jw jx jy jz gt ip gh gi paragraph-image"><div class="gh gi lg"><img src="../Images/f46f6fe620ab92506654888757db5d4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*Rae5mW4VubXgU_uVoYU7Xg.png"/></div></figure><h1 id="a6c3" class="ka kb iy bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">循环的方向-</h1><p id="174d" class="pw-post-body-paragraph iw ix iy iz b ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq lc js jt ju ig bi translated">运行的每个 for 循环将遵循相似的模式，但方向不同。如前所述，我们将遵循右、下、左、上的模式。</p><p id="0f7d" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">这个第一个 for 循环将负责第一行的右移。</p><h1 id="f07b" class="ka kb iy bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">第一个 for 循环(第一行从左到右)-</h1><p id="4f47" class="pw-post-body-paragraph iw ix iy iz b ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq lc js jt ju ig bi translated">这个 for 循环中的条件将从起始列(0)开始启动<strong class="iz ld"> i </strong>，并将迭代到结束列(结束索引)直到结束。变量<strong class="iz ld"> i </strong>将在每次迭代中增加 1。</p><figure class="jw jx jy jz gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lh"><img src="../Images/3386b0f4bf9cd72af1b35d8d19c1c776.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hYWzNQVhEEIKlbEjfFLJGw.png"/></div></div></figure><p id="7148" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">当放置每个值时，我们将在<strong class="iz ld"> startRow </strong>的索引处查看结果数组。然后我们将把这个值放在子数组的索引 I 处。</p><p id="bc56" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">同样，<strong class="iz ld">产生[startRow][i] </strong>，在这种情况下，它转化为第一个索引处的第一个<strong class="iz ld">子数组</strong>(0，因为这是第一次迭代。)</p><p id="5d6b" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">记住每次迭代都要增加计数器变量。</p><p id="82db" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">当条件满足并且 for 循环结束时，我们要确保将<strong class="iz ld"> startRow </strong>变量加 1，这样我们就不会再处理这个特定的子数组了。</p><h1 id="4373" class="ka kb iy bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">第二个 for 循环(右列从上到下)-</h1><p id="eba2" class="pw-post-body-paragraph iw ix iy iz b ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq lc js jt ju ig bi translated">除了我们将从<strong class="iz ld"> startRow </strong>迭代到<strong class="iz ld"> endRow </strong>之外，这种情况与第一种情况类似，其中<strong class="iz ld"> i </strong>仍然递增 1。</p><figure class="jw jx jy jz gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lm"><img src="../Images/c6455932b7ef560b8509465c322b0dfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fAFBj9Ur1XuTiQsTJB9nDg.png"/></div></div><figcaption class="is it gj gh gi iu iv bd b be z dk translated">(右栏)</figcaption></figure><p id="84cf" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">这一次，当我们索引我们的结果数组时，我们将查看<strong class="iz ld">结果[i] </strong>数组，并将值放在<strong class="iz ld">结果[i][endColumn] </strong></p><p id="390a" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">记住增加<strong class="iz ld">计数器</strong>变量</p><p id="d42e" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">类似于前面的 for 循环，当条件满足时，我们的<strong class="iz ld"> endColumn </strong>变量将发生变化，但这次我们将<strong class="iz ld"> <em class="le">递减</em> </strong>值，以将该列从我们遵循的模式中排除。</p><h1 id="c547" class="ka kb iy bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">第三个 For 循环(底行从右到左)-</h1><p id="3cfd" class="pw-post-body-paragraph iw ix iy iz b ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq lc js jt ju ig bi translated">该循环中的条件将在<strong class="iz ld"> endColumn </strong>的值处启动<strong class="iz ld"> i </strong>，并且只要<strong class="iz ld">I</strong>T50】=<strong class="iz ld">start column</strong>，循环就会运行，其中<strong class="iz ld"> i </strong>每次迭代都会递减。</p><figure class="jw jx jy jz gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi ln"><img src="../Images/d3f442a56376339f1710965ad09a775e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iey4a7BMAT13leIc3_u7dA.png"/></div></div><figcaption class="is it gj gh gi iu iv bd b be z dk translated">(最下面一行)</figcaption></figure><p id="6061" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">当索引数组时，我们将查看<strong class="iz ld">结果【endRow】</strong>，并每次将值放在<strong class="iz ld">结果【endRow】【I】</strong>。</p><p id="b5e5" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">记得增加计数器变量</p><p id="a90d" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">当条件满足并且 for 循环结束时，我们将把<strong class="iz ld"> endRow </strong>减 1。</p><h1 id="6e36" class="ka kb iy bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">第四个 For 循环(左列从下到上)-</h1><p id="3d51" class="pw-post-body-paragraph iw ix iy iz b ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq lc js jt ju ig bi translated">该循环中的条件将在<strong class="iz ld"> endRow </strong>的值处启动<strong class="iz ld"> i </strong>，并且只要<strong class="iz ld">I</strong>&gt;=<strong class="iz ld">startRow</strong>随着每次迭代而递减<strong class="iz ld"> i </strong>，该循环就会运行。</p><figure class="jw jx jy jz gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lo"><img src="../Images/b5ff08e975ede4a65a625e3d13a6edc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IvHY__fxh6GD0F7XBmvlRw.png"/></div></div><figcaption class="is it gj gh gi iu iv bd b be z dk translated">(左列向上)</figcaption></figure><p id="6ead" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">当索引数组时，我们将查看<strong class="iz ld">结果[i] </strong>以了解我们正在处理哪个子数组，并且我们将在每次迭代中将值放置在<strong class="iz ld">结果[i][startColumn] </strong>处。</p><p id="f6bc" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">同样，请记住，这些被放置的值直接来自我们的<strong class="iz ld">计数器</strong>变量，所以重要的是要记住，每当我们在 for 循环 中迭代一次，计数器值就加 1。</p><p id="3e84" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">当 for 循环结束时，我们需要将<strong class="iz ld"> startColumn </strong>加 1。</p><h1 id="58f8" class="ka kb iy bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">打破 while 循环-</h1><p id="5c06" class="pw-post-body-paragraph iw ix iy iz b ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq lc js jt ju ig bi translated">这个 while 循环将一直运行，直到满足其中一个条件。要么<strong class="iz ld"> startRow </strong>的值将超过<strong class="iz ld"> endRow </strong>的值，要么<strong class="iz ld"> startColumn </strong>将超过<strong class="iz ld"> endColumn </strong>的值。当这一切发生时，while 循环将会中断，我们将会知道我们的螺旋矩阵已经完成了它的进程。</p><p id="0b77" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我们需要做的最后一件事是<strong class="iz ld">返回结果数组</strong>。</p><p id="b9e5" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">原来如此！这是一个令人讨厌的问题，并且伴随着一个相当令人讨厌的解决方案。我希望我很好地解释了解决这个挑战背后的逻辑。</p><p id="06d8" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">这个概念一开始有点难以理解，但是当你进入遍历数组的节奏时，解决方案就变得更容易了。</p><p id="d2b8" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我希望这篇技术博客文章对你有所帮助，不要太混乱。感谢阅读！</p><p id="f333" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">这里是 git 存储库，可以看到所有的代码。<a class="ae lp" href="https://github.com/StephenGrider/AlgoCasts/blob/master/completed_exercises/matrix/index.js" rel="noopener ugc nofollow" target="_blank">https://github . com/Stephen grider/algo casts/blob/master/completed _ exercises/matrix/index . js</a></p></div></div>    
</body>
</html>