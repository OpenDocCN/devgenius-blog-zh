<html>
<head>
<title>Document DB’s Data Modeling: 101</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">文档数据库的数据建模:101</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/document-dbs-data-modeling-101-7df06a6da21e?source=collection_archive---------2-----------------------#2022-07-03">https://blog.devgenius.io/document-dbs-data-modeling-101-7df06a6da21e?source=collection_archive---------2-----------------------#2022-07-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="7e17" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这篇博客是我们从零开始讨论 101 个<strong class="jm io"> </strong>概念的系列文章的一部分，读者的入门知识有限。这篇文章属于<strong class="jm io"> <em class="ki">中级</em> </strong>系列，因为它涉及到对<strong class="jm io"> </strong>文档数据库<strong class="jm io">中<strong class="jm io">数据建模</strong>的理解。</strong>与传统的 SQL 数据库相比，文档数据库为开发人员提供了更大的灵活性和可伸缩性，已经成为分布式应用程序的流行选择。</p><p id="e46c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">101 系列中的一些早期博客如下:</p><p id="bdc0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/database-replication-101-d148514598a7"> <strong class="jm io">数据库复制 101 </strong> <br/> </a> <a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/database-sharding-101-4ef36046c29c"> <strong class="jm io">数据库分片 101 </strong> <br/> </a> <a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/caching-strategy-101-3bc974d2a6cd"> <strong class="jm io">缓存策略 101</strong></a><strong class="jm io"/><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/circuit-breaker-pattern-101-be2d7fdb656"><strong class="jm io">断路器 101 </strong> <br/> </a> <a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/async-communication-101-b04d5c95333a"> <strong class="jm io">异步通信 101</strong></a><strong class="jm io"><br/></strong><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/database-design-101-7c019d69b97f"><strong class="jm io">数据库设计</strong></a></p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/2b62758e4e981e83469c5d70f383eb8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UiY2qSQf8jW46jjm7ks5Og.png"/></div></div></figure><h1 id="2b37" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">什么是文档数据库？</h1><p id="1b49" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">文档数据库是<a class="ae kj" href="https://en.wikipedia.org/wiki/NoSQL" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> NoSQL </strong> </a>数据库的子集，它以<em class="ki"> json 类文档</em>的形式存储数据，不像表格行和列的定义模式。与 SQL 数据库不同，DB 实例中的不同文档在存储字段上可能有所不同，因此很容易满足业务需求的新数据需求。</p><p id="dd1a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每个文档都由一个唯一的关键字引用，通常是系统生成的值。此外，给定的应用程序代码可以围绕文档中的字段建模，而不是使用复杂的 SQL 查询，这有助于提高开发人员的整体生产力。</p><h1 id="31d7" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">什么是数据建模？</h1><p id="a1d2" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated"><strong class="jm io">数据建模</strong>决策主要围绕应用程序的访问模式，即<em class="ki">需要一起访问的字段需要存储在单个文档中</em>。</p><p id="efd7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">与关系数据库不同，在将文档存储到集合中之前，固定的数据模型不是强制性的。但是，建议添加每个文档类型所需的最少字段的数据验证。不经常访问的字段可以使用<a class="ae kj" href="https://www.mongodb.com/docs/manual/reference/database-references/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">数据库引用</strong> </a> <strong class="jm io">链接到单独的文档中。</strong></p><h2 id="ebef" class="lz kx in bd ky ma mb dn lc mc md dp lg jv me mf lk jz mg mh lo kd mi mj ls mk bi translated">逻辑数据建模</h2><p id="609c" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">该步骤包括定义文档的逻辑元素，即<strong class="jm io">实体键、实体属性和实体关系</strong>。</p><ul class=""><li id="7dbb" class="ml mm in jm b jn jo jr js jv mn jz mo kd mp kh mq mr ms mt bi translated">实体键是引用文档的唯一键/键集。例如:<em class="ki"> _id 是 mongodb </em>中默认的主键。</li><li id="c2a3" class="ml mm in jm b jn mu jr mv jv mw jz mx kd my kh mq mr ms mt bi translated">实体属性可以是数据类型的组合，如<em class="ki">字符串、布尔值、数组等</em></li><li id="6b80" class="ml mm in jm b jn mu jr mv jv mw jz mx kd my kh mq mr ms mt bi translated">根据文档之间的关系，实体关系可以是<strong class="jm io">一对一、一对多或多对多关系</strong></li></ul><h2 id="91e9" class="lz kx in bd ky ma mb dn lc mc md dp lg jv me mf lk jz mg mh lo kd mi mj ls mk bi translated">物理数据建模</h2><p id="fe6b" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">这一步涉及物理容器的定义，以存储被定义为逻辑建模一部分的实体和文档。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi mz"><img src="../Images/32d3f46a7fff1fc33581e038de0c54aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gJ9wUPmwauVpbYdRFtD35w.png"/></div></div></figure><h1 id="dec2" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">文档设计—实体关系</h1><p id="4ba2" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">文档的 JSON 结构允许使用<strong class="jm io">嵌入</strong>(嵌套结构)或使用主键创建相关文档的<strong class="jm io">引用</strong>来定义关系。</p><ul class=""><li id="ce6e" class="ml mm in jm b jn jo jr js jv mn jz mo kd mp kh mq mr ms mt bi translated">一个完全<a class="ae kj" href="https://hevodata.com/learn/mongodb-data-modeling/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">规范化的数据模型</strong> </a> <strong class="jm io"> </strong>将每个实体存储为一个单独的文档，实体关系使用引用来定义。这类似于关系数据库模式，使用这种模式妨碍了固有的灵活性。</li><li id="ba3a" class="ml mm in jm b jn mu jr mv jv mw jz mx kd my kh mq mr ms mt bi translated">在另一个极端<strong class="jm io">反规范化</strong>端，所有相关的实体都可以存储在一个大文档中。然而，这将导致实体重复以及扩展的存储需求。</li></ul><h2 id="e8bd" class="lz kx in bd ky ma mb dn lc mc md dp lg jv me mf lk jz mg mh lo kd mi mj ls mk bi translated">一对一的关系</h2><p id="8f10" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">一对一关系是整体数据建模中两个不同实体之间的单一关联。对于这种模式，最好是<strong class="jm io">在同一个文档中嵌入实体</strong>。</p><p id="ee55" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="ki">员工与身份证的前关系。</em> </strong></p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="na nb l"/></div></figure><h2 id="e8a7" class="lz kx in bd ky ma mb dn lc mc md dp lg jv me mf lk jz mg mh lo kd mi mj ls mk bi translated">一对多关系</h2><p id="836a" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">一对多关系是指一种类型的实体与另一种类型的多个实体相关。为了决定是引用还是嵌入</p><ul class=""><li id="795e" class="ml mm in jm b jn jo jr js jv mn jz mo kd mp kh mq mr ms mt bi translated">如果关系的基数较小，并且需要一起访问数据，那么最好将实体嵌入到单个文档中。<strong class="jm io"> <em class="ki">前任——员工和工作项目。</em> </strong></li><li id="c0cb" class="ml mm in jm b jn mu jr mv jv mw jz mx kd my kh mq mr ms mt bi translated">但是，如果数据访问不频繁或者基数随时间变化，那么引用相关实体是首选。</li></ul><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="na nb l"/></div></figure><h2 id="e3f0" class="lz kx in bd ky ma mb dn lc mc md dp lg jv me mf lk jz mg mh lo kd mi mj ls mk bi translated">多对多关系</h2><p id="e47a" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">在多对多关系中，关键的决策指南是相关实体的上限基数/界限</p><ul class=""><li id="d419" class="ml mm in jm b jn jo jr js jv mn jz mo kd mp kh mq mr ms mt bi translated">当被引用实体的基数是静态的时，<a class="ae kj" href="https://www.mongodb.com/docs/manual/tutorial/model-tree-structures-with-child-references/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">子引用</strong> </a>是首选。父文档本身可以引用其父文档中的所有相关子文档。</li><li id="d798" class="ml mm in jm b jn mu jr mv jv mw jz mx kd my kh mq mr ms mt bi translated"><a class="ae kj" href="https://www.mongodb.com/docs/manual/tutorial/model-tree-structures-with-parent-references/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">当被引用实体的基数增长时，建议使用父引用</strong> </a>。每个新的子文档都可以添加对父文档主键的引用。</li></ul><h1 id="eaad" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">摘要</h1><p id="03fd" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">NoSQL 数据库中的数据建模决策通常是基于从客户流量中观察到的数据访问模式而发展的。json 数据结构的<em class="ki">灵活性加上文档的版本控制</em>可以作为关系数据库中模式设计的一个很好的进步。然而，它们的主要缺点是不支持数据库事务的 ACID 规则。</p><p id="8865" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">大多数云产品，如<strong class="jm io"> AWS、Azure</strong>T16】等，都以 PAAS 的形式提供文档数据库。<a class="ae kj" href="https://aws.amazon.com/documentdb/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io">AWS document db</strong></a><strong class="jm io">，</strong><a class="ae kj" href="https://azure.microsoft.com/en-in/services/cosmos-db/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io">Azure Cosmos</strong></a><strong class="jm io">等是工程团队常用的数据库选择</strong>。</p><p id="30df" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">如需反馈，请留言至</em><strong class="jm io"><em class="ki">Amit[dot]894[at]Gmail[dot]com</em></strong><em class="ki">或联系</em><a class="ae kj" href="https://about.me/amit_raj" rel="noopener ugc nofollow" target="_blank"><em class="ki">https://about.me/amit_raj</em></a><em class="ki">的任何链接。</em></p></div></div>    
</body>
</html>