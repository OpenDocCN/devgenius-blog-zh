<html>
<head>
<title>Monotonic stack — Algorithm Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单调堆栈—算法模式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/monotonic-stack-algorithm-pattern-7bfac59157c2?source=collection_archive---------3-----------------------#2022-10-04">https://blog.devgenius.io/monotonic-stack-algorithm-pattern-7bfac59157c2?source=collection_archive---------3-----------------------#2022-10-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/f1a1648765e4cf1c3c507704fdc848af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L7t1f2nJlQs-q0VgEjeiAQ.jpeg"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">图片来源 google.com</figcaption></figure><div class=""/><p id="9aba" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">幸福的秘密在于找到相投的单调。</p><p id="9216" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">单调堆栈是堆栈数据结构的一种变体，其中的元素总是以特定的顺序排序。关键的区别仅在于推送操作:在我们将一个新元素推送到堆栈上之前，我们首先验证是否保持了单调性。如果是，那么我们从堆栈中弹出顶部的元素，直到推新元素不再打破单调性。</p><p id="2c80" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">对于单调增加的<strong class="kb jd">堆栈:</strong></p><ul class=""><li id="a9f5" class="kx ky jc kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated">我们按顺序遍历数组</li><li id="a741" class="kx ky jc kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">在推动之前，我们继续弹出更大的元素。</li><li id="67c6" class="kx ky jc kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">因为我们不断弹出更大的元素，保留更小的元素，所以它会给我们一个尽可能小的结果。</li></ul><blockquote class="ll"><p id="1785" class="lm ln jc bd lo lp lq lr ls lt lu kw dk translated">当一个元素从单调堆栈中弹出时，它将不再被使用。</p></blockquote><p id="d42a" class="pw-post-body-paragraph jz ka jc kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">对于单调递减的<strong class="kb jd">堆栈:</strong></p><ul class=""><li id="2fce" class="kx ky jc kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated">我们以相反的顺序遍历数组</li><li id="b87e" class="kx ky jc kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">我们继续弹出<strong class="kb jd">更小的</strong>元素。</li><li id="1ec5" class="kx ky jc kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">因为我们不断弹出较小的元素，保留较大的元素，所以它会给我们一个在字典上尽可能大于的结果。</li></ul><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="7bb0" class="mj mk jc mf b gy ml mm l mn mo">def <strong class="mf jd">monotonic_increasing_stack</strong>(nums):<br/>    n = len(nums)<br/>    stack = []<br/>    for i in range(n):<br/>        while len(stack) &gt; 0 and stack[-1] &gt;= nums[i]:<br/>            stack.pop()<br/>        stack.append(nums[i])<br/>    return stack</span><span id="d2a6" class="mj mk jc mf b gy mp mm l mn mo"># flip the array. <br/>def <strong class="mf jd">monotonic_decreasing_stack</strong>(nums):<br/>    n = len(nums)<br/>    stack = []<br/>    for i in range(n):<br/>        while len(stack) &gt; 0 and stack[-1] &lt; nums[i]:<br/>            stack.pop()<br/>        stack.append(nums[i])<br/>    return stack<br/>    <br/>nums = [2, 3, 7, 11, 5, 17, 19]<br/>print(monotonic_increasing_stack(nums)) <br/># [2, 3, 5, 17, 19]<br/>print(monotonic_decreasing_stack(nums))<br/># [19]</span></pre><p id="e3dd" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">单调堆栈为数组问题中的多个<strong class="kb jd"> <em class="mq">范围查询提供了最佳的时间复杂度解决方案。更准确地说，单调堆栈帮助我们维护范围内的最大和最小元素，并保持范围内元素的顺序。我们只根据添加的最新元素来更新堆栈。因为数组中的每个元素只能进入单调堆栈一次，所以时间复杂度为 O(N)。</em></strong></p><h2 id="3470" class="mj mk jc bd mr ms mt dn mu mv mw dp mx kk my mz na ko nb nc nd ks ne nf ng nh bi translated">可以看到海景的建筑</h2><p id="a823" class="pw-post-body-paragraph jz ka jc kb b kc ni ke kf kg nj ki kj kk nk km kn ko nl kq kr ks nm ku kv kw ig bi translated">一条线上有<code class="fe nn no np mf b">n</code>栋建筑。给你一个大小为<code class="fe nn no np mf b">n</code>的整数数组<code class="fe nn no np mf b">heights</code>,它代表该行中建筑物的高度。</p><p id="48df" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">海洋在建筑的右边。如果一个建筑可以无障碍地看到大海，那么这个建筑就是海景。从形式上来说，如果一栋建筑右边的所有建筑都有一个更小的高度，那么它就有海景。</p><p id="366d" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">返回有海景的建筑的索引列表<strong class="kb jd"> (0 索引)</strong>，按升序排序。</p><p id="6a1d" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在这个问题中，我们可以使用单调递减的堆栈。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="8eba" class="mj mk jc mf b gy ml mm l mn mo">def find_buildings(heights):<br/>    n = len(heights)<br/>    stack = []<br/>    for i in range(n):<br/>        curr_height = heights[i]<br/>        while stack and heights[stack[-1]] &lt;= curr_height:<br/>            stack.pop()<br/>        stack.append(i)<br/>    return stack</span></pre><h2 id="70aa" class="mj mk jc bd mr ms mt dn mu mv mw dp mx kk my mz na ko nb nc nd ks ne nf ng nh bi translated">删除重复的字母</h2><p id="43db" class="pw-post-body-paragraph jz ka jc kb b kc ni ke kf kg nj ki kj kk nk km kn ko nl kq kr ks nm ku kv kw ig bi translated">给定一个字符串<code class="fe nn no np mf b">s</code>，删除重复的字母，使每个字母出现一次，并且只出现一次。你必须确保你的结果是所有可能结果中按字典顺序最小的。</p><p id="b9fa" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们使用单调递增的堆栈概念。但是在推送任何项目之前，如果项目不在堆栈中，并且它小于堆栈中的前一个元素，并且这些元素是重复的，那么我们需要弹出这些元素。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="184f" class="mj mk jc mf b gy ml mm l mn mo">def remove_duplicate_letters(s):<br/>    stack = []<br/>    seen = set()<br/>    last_occurrence = {c: i for i, c in enumerate(s)}<br/>    <br/>    for i, c in enumerate(s):<br/>        if c not in seen:<br/>            while stack and stack [-1] &gt; c and i &lt; last_occurrence[stack[-1]]:<br/>                seen.discard(stack.pop())<br/>            seen.add(c)<br/>            stack.append(c)<br/>    return ''.join(stack)<br/>    <br/>s = "cbacdcbc"<br/>print(remove_duplicate_letters(s))<br/># acdb</span></pre><h2 id="a27b" class="mj mk jc bd mr ms mt dn mu mv mw dp mx kk my mz na ko nb nc nd ks ne nf ng nh bi translated">删除 k 位数字</h2><p id="d23a" class="pw-post-body-paragraph jz ka jc kb b kc ni ke kf kg nj ki kj kk nk km kn ko nl kq kr ks nm ku kv kw ig bi translated">给定代表非负整数<code class="fe nn no np mf b">num</code>和整数<code class="fe nn no np mf b">k</code>的字符串 num，返回从 <code class="fe nn no np mf b">num</code>中移除 <code class="fe nn no np mf b">k</code> <em class="mq">位后的最小可能整数<em class="mq">。</em></em></p><p id="d7a1" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在这个问题中，我们使用单调递增堆栈来删除大数字。当添加一个新的数字时，我们检查先前的数字是否大于当前的数字，并将其弹出。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="a50c" class="mj mk jc mf b gy ml mm l mn mo">def remove_k_digits(num, k):<br/>    if k &gt;= len(num):<br/>        return '0'<br/>    stack = []<br/>    for digit in num:<br/>        while(k and stack and stack[-1] &gt; digit):<br/>            stack.pop()<br/>            k -= 1<br/>        stack.append(digit)<br/>        <br/>    stack = stack[:-k] if k else stack<br/>    <br/>    return "".join(stack).lstrip('0') or '0'<br/>    <br/>num = "1432219"<br/>k = 3<br/>print(remove_k_digits(num, k))<br/># 1219</span></pre><h2 id="1edc" class="mj mk jc bd mr ms mt dn mu mv mw dp mx kk my mz na ko nb nc nd ks ne nf ng nh bi translated">下一个更大的元素 0</h2><p id="07fa" class="pw-post-body-paragraph jz ka jc kb b kc ni ke kf kg nj ki kj kk nk km kn ko nl kq kr ks nm ku kv kw ig bi translated">数组中某元素<code class="fe nn no np mf b">x</code>的<strong class="kb jd">下一个更大的元素</strong>是同一数组中<code class="fe nn no np mf b">x</code>右边<strong class="kb jd">的<strong class="kb jd">第一个更大的</strong>元素。获取每个数组元素的下一个更大的元素。</strong></p><p id="1de7" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在这个问题中，我们使用单调递减堆栈。</p><p id="f4aa" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb jd">代码实现</strong></p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="f7b7" class="mj mk jc mf b gy ml mm l mn mo">def get_next_greater_element(nums):<br/>    n = len(nums)<br/>    stack = []<br/>    result = [-1] * n<br/>    <br/>    for i in range(n):<br/>        while len(stack) &gt; 0 and nums[stack[-1]] &lt; nums[i]:<br/>            result[stack[-1]] = nums[i]<br/>            stack.pop()<br/>        stack.append(i)<br/>    return result<br/>            <br/>    <br/>nums = [2, 7, 3, 5, 4, 6, 8]</span><span id="c82a" class="mj mk jc mf b gy mp mm l mn mo">print(get_next_greater_element(nums))<br/># [7, 8, 5, 6, 6, 8, -1]</span></pre><h2 id="b1cf" class="mj mk jc bd mr ms mt dn mu mv mw dp mx kk my mz na ko nb nc nd ks ne nf ng nh bi translated">下一个更大的元素 1</h2><p id="a979" class="pw-post-body-paragraph jz ka jc kb b kc ni ke kf kg nj ki kj kk nk km kn ko nl kq kr ks nm ku kv kw ig bi translated">给定一个循环整数数组<code class="fe nn no np mf b">nums</code>(即<code class="fe nn no np mf b">nums[nums.length - 1]</code>的下一个元素是<code class="fe nn no np mf b">nums[0]</code>)，为 <code class="fe nn no np mf b">nums</code>中的每个元素返回<em class="mq"/><strong class="kb jd"><em class="mq">下一个更大的数字</em> </strong> <em class="mq">。</em></p><p id="af6d" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">数字<code class="fe nn no np mf b">x</code>的<strong class="kb jd">下一个更大的数字</strong>是数组中下一个遍历顺序的第一个更大的数字，这意味着您可以循环搜索以找到它的下一个更大的数字。如果不存在，返回该号码的<code class="fe nn no np mf b">-1</code>。</p><blockquote class="nq nr ns"><p id="96c5" class="jz ka mq kb b kc kd ke kf kg kh ki kj nt kl km kn nu kp kq kr nv kt ku kv kw ig bi translated">一个<strong class="kb jd">循环</strong>列表的问题，我们需要遍历列表<strong class="kb jd">两次</strong></p></blockquote><p id="a6fc" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb jd">代码实现</strong></p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="f1a3" class="mj mk jc mf b gy ml mm l mn mo">def next_greater_elements_cycle(nums):<br/>    n = len(nums)<br/>    result = [-1] * n<br/>    stack = []<br/>    <br/>    for idx, val in enumerate(nums): <br/>        while stack and val &gt; nums[stack[-1]]:<br/>            result[stack.pop()] = val   <br/>        stack.append(idx)<br/>        <br/>    for idx, val in enumerate(nums):  <br/>        while stack and val &gt; nums[stack[-1]]:<br/>            result[stack.pop()] = val</span><span id="fd0f" class="mj mk jc mf b gy mp mm l mn mo">return result<br/>            <br/>    <br/>nums = [1,2,3,4,3]<br/>print(next_greater_elements_cycle(nums)) <br/># [2, 3, 4, -1, 4]</span></pre><h2 id="a43d" class="mj mk jc bd mr ms mt dn mu mv mw dp mx kk my mz na ko nb nc nd ks ne nf ng nh bi translated">下一个更大的元素 2</h2><p id="3107" class="pw-post-body-paragraph jz ka jc kb b kc ni ke kf kg nj ki kj kk nk km kn ko nl kq kr ks nm ku kv kw ig bi translated">数组中某个元素<code class="fe nn no np mf b">x</code>的下一个更大的元素是同一数组中<code class="fe nn no np mf b">x</code>右边的第一个更大的元素。给你两个不同的 0 索引整数数组<code class="fe nn no np mf b">nums1</code>和<code class="fe nn no np mf b">nums2</code>，其中<code class="fe nn no np mf b">nums1</code>是<code class="fe nn no np mf b">nums2</code>的子集。</p><p id="71c7" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">对于每个<code class="fe nn no np mf b">0 &lt;= i &lt; nums1.length</code>，找到索引<code class="fe nn no np mf b">j</code>使得<code class="fe nn no np mf b">nums1[i] == nums2[j]</code>和确定<code class="fe nn no np mf b">nums2[j]</code>在<code class="fe nn no np mf b">nums2</code>中的下一个更大的元素。如果没有下一个更大的元素，那么这个查询的答案是<code class="fe nn no np mf b">-1</code>。</p><p id="226d" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">返回长度为 <code class="fe nn no np mf b">nums1.length</code> <em class="mq">的<em class="mq">数组</em> <code class="fe nn no np mf b">ans</code> <em class="mq">使得</em> <code class="fe nn no np mf b">ans[i]</code> <em class="mq">是如上所述的</em> <strong class="kb jd"> <em class="mq">下一个更大的元素</em> </strong> <em class="mq">。</em></em></p><p id="72a4" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb jd">代码实现</strong></p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="b760" class="mj mk jc mf b gy ml mm l mn mo">def next_greater_elements_2(nums1, nums2):<br/>    mapping = {}<br/>    result = []<br/>    <br/>    for item in nums2:<br/>        while result and item &gt; result[-1]:<br/>            mapping[result.pop()] = item<br/>        result.append(item)<br/>        <br/>    while result:<br/>        mapping[result.pop()] = -1<br/>    <br/>    for item in nums1:<br/>        result.append(mapping[item])<br/>    <br/>    return result<br/>            <br/>    <br/>nums1 = [4,1,2]<br/>nums2 = [1,3,4,2]<br/>print(next_greater_elements_2(nums1, nums2))</span></pre><h2 id="e36b" class="mj mk jc bd mr ms mt dn mu mv mw dp mx kk my mz na ko nb nc nd ks ne nf ng nh bi translated">要排序的最大块</h2><p id="38e6" class="pw-post-body-paragraph jz ka jc kb b kc ni ke kf kg nj ki kj kk nk km kn ko nl kq kr ks nm ku kv kw ig bi translated">给定一个长度为<code class="fe nn no np mf b">n</code>的整数数组<code class="fe nn no np mf b">nums</code>，它表示范围<code class="fe nn no np mf b">[0, n - 1]</code>中整数的排列。我们将<code class="fe nn no np mf b">nums</code>分割成一定数量的<strong class="kb jd">块</strong>(即分区)，并单独对每个块进行排序。将它们连接起来后，结果应该等于排序后的数组。</p><p id="83e8" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">返回我们可以对数组进行排序的最大块数。</p><p id="a11f" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">对于给定的数组，最大数量的块发生在它增加并且每个元素都已经在正确的位置的时候。因此，只要我们看到一个顺序递增的数组，我们就继续。当我们看到一个元素的位置混乱时，我们希望找到它的正确位置，因为在当前位置和应该位置之间的任何东西都需要排序，因此会成为它自己的一部分。</p><p id="e486" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb jd">代码实现</strong></p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="c8fb" class="mj mk jc mf b gy ml mm l mn mo">def max_chunks_to_sorted(nums):<br/>    <!-- -->stack = []<br/>    for num in arr:<br/>        largest = num<br/>        while stack and stack[-1] &gt; num:<br/>            largest = max(largest, stack.pop())<br/>        stack.append(largest)<br/>        <br/>    return len(stack)<br/>    <br/>nums = [1,0,2,3,4]<br/>print(max_chunks_to_sorted(nums))<br/># 4</span></pre><h2 id="9ffd" class="mj mk jc bd mr ms mt dn mu mv mw dp mx kk my mz na ko nb nc nd ks ne nf ng nh bi translated">使数组非递减的步骤</h2><p id="b9a2" class="pw-post-body-paragraph jz ka jc kb b kc ni ke kf kg nj ki kj kk nk km kn ko nl kq kr ks nm ku kv kw ig bi translated">给你一个<strong class="kb jd"> 0 索引</strong>整数数组<code class="fe nn no np mf b">nums</code>。在一个步骤中，<strong class="kb jd">移除</strong>所有元件<code class="fe nn no np mf b">nums[i]</code>，其中<code class="fe nn no np mf b">nums[i - 1] &gt; nums[i]</code>用于所有<code class="fe nn no np mf b">0 &lt; i &lt; nums.length</code>。</p><p id="9d6c" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">返回<em class="mq">执行的步数，直到</em> <code class="fe nn no np mf b">nums</code> <em class="mq">变成</em> <strong class="kb jd"> <em class="mq">非递减</em> </strong> <em class="mq">数组</em>。</p><p id="97cf" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">从右到左反向扫描，保持递增堆叠。</p><p id="f1a0" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb jd">代码实现</strong></p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="94f3" class="mj mk jc mf b gy ml mm l mn mo">def total_steps(nums):<br/>    ans = 0<br/>    nums.reverse()<br/>    stack = [[nums[0], 0]]<br/>    for i in range(1, len(nums)):<br/>        cnt = 0<br/>        while stack and stack[-1][0] &lt; nums[i]:<br/>            cnt = max(cnt + 1, stack[-1][1])<br/>            stack.pop()<br/>        stack.append([nums[i], cnt])<br/>        ans = max(ans, cnt)<br/>    return ans<br/>    <br/>nums = [5,3,4,4,7,3,6,11,8,5,11]<br/>print(total_steps(nums))</span></pre><h2 id="a04b" class="mj mk jc bd mr ms mt dn mu mv mw dp mx kk my mz na ko nb nc nd ks ne nf ng nh bi translated">子阵列最小值之和</h2><p id="d3c9" class="pw-post-body-paragraph jz ka jc kb b kc ni ke kf kg nj ki kj kk nk km kn ko nl kq kr ks nm ku kv kw ig bi translated">给定一个整数数组 arr，求<code class="fe nn no np mf b">min(b)</code>的和，其中<code class="fe nn no np mf b">b</code>覆盖<code class="fe nn no np mf b">arr</code>的每个(相邻)子数组。由于答案可能较大，返回答案<strong class="kb jd">模</strong>T3】。</p><p id="899b" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb jd">代码实现</strong></p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="95ac" class="mj mk jc mf b gy ml mm l mn mo">def get_previous_large_element(nums):<br/>    n = len(nums)<br/>    left, stack = [-1] * n, []<br/>    for i in range(n):<br/>        while stack and nums[i] &lt; nums[stack[-1]]: <br/>            stack.pop()<br/>        left[i] = stack[-1] if stack else -1<br/>        stack.append(i)<br/>    for i in range(n):<br/>        left[i] =  i+1 if left[i] == -1 else i - left[i]<br/>    return left</span><span id="56e7" class="mj mk jc mf b gy mp mm l mn mo">def get_next_large_element(nums):<br/>    n = len(nums)<br/>    right, stack = [-1] * n, []<br/>    for i in range(n):<br/>        while stack and nums[i] &lt; nums[stack[-1]]: <br/>            right[stack.pop()] = i<br/>        stack.append(i)<br/>    for i in range(n):<br/>        right[i] =  n - i if right[i] == -1 else right[i] - i<br/>    return right</span><span id="3af5" class="mj mk jc mf b gy mp mm l mn mo">def sum_subarray_mins(nums):<br/>    mod = (10**9) + 7<br/>    left = get_previous_large_element(nums)<br/>    right = get_next_large_element(nums)<br/>    <br/>    return sum(a*l*r for a, l, r in zip(nums, left, right)) % mod</span><span id="fca1" class="mj mk jc mf b gy mp mm l mn mo">nums = [3,1,2,4]<br/>print(sum_subarray_mins(nums))</span></pre><p id="eba2" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb jd">优化的代码实现</strong></p><p id="f470" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们使用一个单调的非递减堆栈来存储左边界和右边界，其中一个数是子数组中的最小数</p><p id="93f7" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">一个数作为最小值出现的次数是<code class="fe nn no np mf b">|left_bounday-indexof(num)| * |right_bounday-indexof(num)|</code>。总和是<code class="fe nn no np mf b">sum([n * |left_bounday - indexof(n)| * |right_bounday - indexof(n)| for n in array])</code></p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="613a" class="mj mk jc mf b gy ml mm l mn mo">def sum_subarray_mins(nums):<br/>    n = len(nums)<br/>    nums.append(0)<br/>    res = 0<br/>    mod = 1000000007<br/>    stack = [-1]<br/>    <br/>    for i, num in enumerate(nums):<br/>        while stack and nums[stack[-1]] &gt; num: # (i)<br/>            idx = stack.pop()<br/>            res += nums[idx] * (i - idx) * (idx - stack[-1])<br/>            <br/>        stack.append(i)<br/>        <br/>    return res % (mod)<br/>    <br/>nums = [3,1,2,4]</span><span id="b023" class="mj mk jc mf b gy mp mm l mn mo">print(sum_subarray_mins(nums))</span></pre><h2 id="c3b3" class="mj mk jc bd mr ms mt dn mu mv mw dp mx kk my mz na ko nb nc nd ks ne nf ng nh bi translated">用全 1 计数子矩阵</h2><p id="5b77" class="pw-post-body-paragraph jz ka jc kb b kc ni ke kf kg nj ki kj kk nk km kn ko nl kq kr ks nm ku kv kw ig bi translated">给定一个<code class="fe nn no np mf b">m x n</code>二进制矩阵<code class="fe nn no np mf b">mat</code>，<em class="mq">返回具有全 1</em>的 <strong class="kb jd"> <em class="mq">子矩阵</em> </strong> <em class="mq">的个数。</em></p><p id="17bc" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在第一步中，我们逐行排列<code class="fe nn no np mf b">mat</code>以获得 1 的直方图。然后，我们对每一行使用一个单调堆栈，以找到每个 I，j 位置上全为 1 的子矩阵的最大数量。堆栈存储非递减高度的索引。每当新的高度出现时，弹出堆栈中高于新高度的高度，同时删除由额外高度贡献的配额(在弹出高度和新高度之间)。</p><p id="6db9" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb jd">代码实现</strong></p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="4018" class="mj mk jc mf b gy ml mm l mn mo">def num_sub_matrices(mat):<br/>    m, n = len(mat), len(mat[0])</span><span id="b742" class="mj mk jc mf b gy mp mm l mn mo">    for i in range(m):<br/>        for j in range(n):<br/>            if mat[i][j] and i &gt; 0: <br/>                mat[i][j] += mat[i-1][j]<br/>    <br/>    res = 0<br/>    for i in range(m):<br/>        stack = []<br/>        cnt = 0<br/>        for j in range(n):<br/>            while stack and mat[i][stack[-1]] &gt; mat[i][j]: <br/>                jj = stack.pop()<br/>                kk = stack[-1] if stack else -1<br/>                cnt -= (mat[i][jj] - mat[i][j])*(jj - kk)</span><span id="347e" class="mj mk jc mf b gy mp mm l mn mo">            cnt += mat[i][j]<br/>            res += cnt<br/>            stack.append(j)</span><span id="e851" class="mj mk jc mf b gy mp mm l mn mo">    return res</span></pre><h2 id="2984" class="mj mk jc bd mr ms mt dn mu mv mw dp mx kk my mz na ko nb nc nd ks ne nf ng nh bi translated">直方图中最大的矩形</h2><p id="7fc6" class="pw-post-body-paragraph jz ka jc kb b kc ni ke kf kg nj ki kj kk nk km kn ko nl kq kr ks nm ku kv kw ig bi translated">给定一个整数数组<code class="fe nn no np mf b">heights</code>表示直方图的条形高度，其中每个条形的宽度为<code class="fe nn no np mf b">1</code>，返回<em class="mq">直方图</em>中最大矩形的面积。</p><p id="e2c7" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">堆栈以递增的高度维护条形的索引。在添加新的条形之前，我们弹出比新条形高的条形。弹出的条代表一个矩形的高度，新条作为右边界，当前栈顶作为左边界。正如我们所知，一旦弹出，该元素将永远不会被再次使用，所以当弹出一个项目时，我们计算它可以生成的最大可能矩形，并更新<code class="fe nn no np mf b">max_area</code>值。</p><p id="f187" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb jd">代码实现</strong></p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="4b6a" class="mj mk jc mf b gy ml mm l mn mo">def largest_rectangle_area(heights):<br/>    max_area = 0<br/>    stack = []<br/>    for idx, ht in enumerate(heights):<br/>        start = idx<br/>        while stack and stack[-1][1]&gt; ht:<br/>            i, h = stack.pop()<br/>            max_area = max(max_area, h * (idx-i))<br/>            start = i<br/>        stack.append((start, ht))<br/>    <br/>    for i, h in stack:<br/>        max_area = max(max_area, h*(len(heights)-i))<br/>    <br/>    return max_area<br/>    <br/>heights = [2,1,5,6,2,3]</span><span id="0e11" class="mj mk jc mf b gy mp mm l mn mo">print(largest_rectangle_area(heights)) # 10</span></pre><h2 id="d131" class="mj mk jc bd mr ms mt dn mu mv mw dp mx kk my mz na ko nb nc nd ks ne nf ng nh bi translated">收集雨水</h2><p id="278f" class="pw-post-body-paragraph jz ka jc kb b kc ni ke kf kg nj ki kj kk nk km kn ko nl kq kr ks nm ku kv kw ig bi translated">给定代表高程图的非负整数<code class="fe nn no np mf b">n</code>，其中每个条形的宽度为<code class="fe nn no np mf b">1</code>，计算雨后它可以收集多少水。</p><p id="fe68" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">高度 x 处的长度将是 x 的(下一个较小的索引-前一个较小的索引-1)</p><p id="6ae1" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb jd">代码实现</strong></p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="3a96" class="mj mk jc mf b gy ml mm l mn mo">def trap_rain_water(height):<br/>    stack = []<br/>    total = 0<br/>    <br/>    for i in range(len(height)):<br/>        while len(stack) &gt; 0 and height[stack[-1]] &lt; height[i]:<br/>            poppedIdx = stack.pop()<br/>            <br/>            if len(stack) == 0:<br/>                break<br/>                <br/>            heightVal = min(height[stack[-1]], height[i]) - height[poppedIdx]<br/>            length = i - stack[-1] - 1<br/>            total += heightVal * length<br/>        <br/>        stack.append(i)<br/>    <br/>    return total<br/>    <br/>height = [0,1,0,2,1,0,1,3,2,1,2,1]</span><span id="b54d" class="mj mk jc mf b gy mp mm l mn mo">print(trap_rain_water(height))<br/># 6</span></pre><p id="f9bf" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">编码快乐！！</p></div></div>    
</body>
</html>