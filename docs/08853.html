<html>
<head>
<title>Building Objects with Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建具有功能的对象</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/making-oop-out-of-functions-1f107295b320?source=collection_archive---------17-----------------------#2022-07-14">https://blog.devgenius.io/making-oop-out-of-functions-1f107295b320?source=collection_archive---------17-----------------------#2022-07-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="303d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用闭包通过函数式编程范式构建对象</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/c5120a62f686cdd22fe1097860f8773e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/0*Q_8Hu3QpiZ5Gdn-d"/></div></figure><h1 id="787d" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">关闭</h1><p id="1e99" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">闭包是由一组不同的变量作用域规则产生的功能模式。在 C 和许多其他语言中，变量只在定义它的代码块中有效。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="9ffc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因为变量只在括号内有效，它的生命周期由屏幕上的文本决定，所以我们称之为词法范围。</p><p id="3f99" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一种类型的作用域——动态作用域——允许我们在定义函数的上下文中捕获变量。代码对局部变量的访问取决于定义上下文，而不是纯文本。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="1e63" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">再次在计划(球拍)</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="d183" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以这种方式返回另一个函数的函数称为闭包。它封装(封闭)当前作用域的局部变量，并允许返回的函数有效地访问它们，即使在调用函数已经返回之后。</p><p id="0c7d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们把局部变量看作一个属性，把返回的函数看作一个方法，把外部函数看作一个构造函数，那么这些闭包看起来就像是对象！我们实际上可以使用对象获得计数闭包的相同行为。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lt lu l"/></div></figure><h1 id="0844" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">构建一个功能堆栈类</h1><p id="6aa4" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">栈是一种数据结构，可以很容易地用一个类来表示，这个类具有在列表上操作的方法。在这里，我将继续使用 c#作为我们的面向对象语言。C#的集合库中已经有了一个栈，但是我们将在这里使用数组列表来滚动我们自己的栈。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="fc56" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是一个非常简单的类，并没有涵盖所有的错误情况，但它将作为一个概念的证明。让我们从功能上实现相同的概念。首先，我们将使用纯函数实现 scheme，然后是 javascript，我们可以使用一些技巧使它完全像类一样工作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="5a70" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我们在外部函数中创建一个列表，只要需要，内部函数将保持对该列表的引用。内部函数有两个参数:一个操作和一个可选的数字。操作告诉函数调用哪个方法，如果那个方法(在这个例子中是 push)需要一个参数，你可以给它一个。这与我们的 c#类的用法和功能非常相似。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="15d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">javascript 方法与此类似，只是我们可以访问 javascript 对象。这些允许我们创建键/值对的集合，并使用点符号来访问它们。使用堆栈闭包的符号与使用类的方式完全相同，只是在功能上有所定义。javascript 中的类实际上只是这种闭包的语法糖。</p></div><div class="ab cl lv lw hr lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ig ih ii ij ik"><p id="83c0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">仅使用函数和一些不同的作用域规则，我们就能够创建类和对象。我认为很多时候我们首先被教导面向对象编程，并且是“最好的”风格。然而，它经常被用作拐杖，有时功能性或过程性的方法可能更简单、更强大。重要的是，在我们盲目地对这个问题进行说教和无止境的抽象之前，要思考这个问题。</p></div><div class="ab cl lv lw hr lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ig ih ii ij ik"><h1 id="ee2b" class="kq kr in bd ks kt mc kv kw kx md kz la lb me ld le lf mf lh li lj mg ll lm ln bi translated">关于作者</h1><p id="7848" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">Eric Breyer 是莱斯大学的计算机科学本科生。你可以在他的<a class="ae mh" href="http://www.ericbreyer.com/" rel="noopener ugc nofollow" target="_blank">网站</a>以及<a class="ae mh" href="https://github.com/ericbreyer" rel="noopener ugc nofollow" target="_blank"> GitHub </a>和<a class="ae mh" href="https://www.linkedin.com/in/eric-breyer/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上找到他。</p></div></div>    
</body>
</html>