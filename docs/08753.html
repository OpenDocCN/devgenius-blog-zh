<html>
<head>
<title>Head First Java-Chapter 7 (inheritance and polymorphism)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">head First Java-第 7 章(继承和多态)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/head-first-java-chapter-7-inheritance-and-polymorphism-66c7a5095c14?source=collection_archive---------7-----------------------#2022-07-07">https://blog.devgenius.io/head-first-java-chapter-7-inheritance-and-polymorphism-66c7a5095c14?source=collection_archive---------7-----------------------#2022-07-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><blockquote class="jk"><p id="e3cd" class="jl jm in bd jn jo jp jq jr js jt ju dk translated">用一些长期的意图来计划你的项目。</p></blockquote><ul class=""><li id="e466" class="jv jw in jx b jy jz ka kb kc kd ke kf kg kh ju ki kj kk kl bi translated">如果您可以编写其他人可以轻松扩展的代码，会怎么样？如果你能写出灵活的代码呢？</li><li id="3d92" class="jv jw in jx b jy km ka kn kc ko ke kp kg kq ju ki kj kk kl bi translated">当你参加多态计划时，你将学到更好的类设计的 5 个步骤，多态的 3 个技巧，制作灵活代码的 8 种方法。这将给你应得的设计自由和编程灵活性。</li><li id="fd4b" class="jv jw in jx b jy km ka kn kc ko ke kp kg kq ju ki kj kk kl bi translated">所以当我们设计一个软件时，可能会有一些类具有相同的功能。因此，如果我们一遍又一遍地使用相同的代码来获得那个功能，可能会有重复。</li><li id="57c5" class="jv jw in jx b jy km ka kn kc ko ke kp kg kq ju ki kj kk kl bi translated">为了克服这一点，我们可以使用继承。</li></ul><p id="6e6d" class="pw-post-body-paragraph kr ks in jx b jy kt ku kv ka kw kx ky kc kz la lb ke lc ld le kg lf lg lh ju ig bi translated"><strong class="jx io">了解传承</strong></p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi li"><img src="../Images/71353daf0c6c4f369417e96daaeb0d39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qc6-9Ixpeyhf3BszK7Ibzw.png"/></div></div></figure><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi lu"><img src="../Images/eca764c12849e754413451790ce9caf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Aylp8PfhkHlUyv3Di_yRsw.png"/></div></div></figure><p id="d1d9" class="pw-post-body-paragraph kr ks in jx b jy kt ku kv ka kw kx ky kc kz la lb ke lc ld le kg lf lg lh ju ig bi translated">在 Java 中，我们说子类扩展了超类。</p><ol class=""><li id="28a6" class="jv jw in jx b jy kt ka kw kc lv ke lw kg lx ju ly kj kk kl bi translated">看看这四个类的共同点。</li><li id="7052" class="jv jw in jx b jy km ka kn kc ko ke kp kg kq ju ly kj kk kl bi translated">抽象出通用的特性，放入一个新的类(超类)。</li><li id="325f" class="jv jw in jx b jy km ka kn kc ko ke kp kg kq ju ly kj kk kl bi translated">将其他 f 类链接到新类(超类)，这种关系称为继承。</li></ol><p id="a79a" class="pw-post-body-paragraph kr ks in jx b jy kt ku kv ka kw kx ky kc kz la lb ke lc ld le kg lf lg lh ju ig bi translated">假设我们需要改变功能运作的方式。所以我们有一个选项叫做<strong class="jx io">超越</strong>。</p><p id="105e" class="pw-post-body-paragraph kr ks in jx b jy kt ku kv ka kw kx ky kc kz la lb ke lc ld le kg lf lg lh ju ig bi translated"><strong class="jx io">覆盖规则:</strong></p><ol class=""><li id="efc1" class="jv jw in jx b jy kt ka kw kc lv ke lw kg lx ju ly kj kk kl bi translated">参数必须相同，并且 returntypes 必须兼容。</li><li id="399e" class="jv jw in jx b jy km ka kn kc ko ke kp kg kq ju ly kj kk kl bi translated">这个方法不能再简单了。</li></ol><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi lz"><img src="../Images/4a015120bae1ecaf3ad6599860c4e7a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*DFyjP11yFY_9xkkvwqxCcw.png"/></div></div></figure><p id="c3df" class="pw-post-body-paragraph kr ks in jx b jy kt ku kv ka kw kx ky kc kz la lb ke lc ld le kg lf lg lh ju ig bi translated"><strong class="jx io">哪种方法叫？</strong></p><ul class=""><li id="b399" class="jv jw in jx b jy kt ka kw kc lv ke lw kg lx ju ki kj kk kl bi translated">当你在一个对象引用上调用一个方法时，你调用的是该对象类型的方法的最具体的版本。换句话说，最低的赢！“最低”意味着在继承树上最低。</li><li id="35a7" class="jv jw in jx b jy km ka kn kc ko ke kp kg kq ju ki kj kk kl bi translated">如果 JVM 没有在最低的类中找到该方法的版本，它就开始沿着继承层次结构往回走，直到找到匹配的为止。</li></ul><p id="fe04" class="pw-post-body-paragraph kr ks in jx b jy kt ku kv ka kw kx ky kc kz la lb ke lc ld le kg lf lg lh ju ig bi translated"><strong class="jx io">使用 IS-A 和 HAS-A </strong></p><blockquote class="ma mb mc"><p id="e7e1" class="kr ks md jx b jy kt ku kv ka kw kx ky me kz la lb mf lc ld le mg lf lg lh ju ig bi translated">当你想知道一件事是否应该延伸到另一件事时，应用 IS-A 测试。</p></blockquote><ul class=""><li id="d55d" class="jv jw in jx b jy kt ka kw kc lv ke lw kg lx ju ki kj kk kl bi translated">三角形是一种形状，是的，很有用，</li><li id="4eeb" class="jv jw in jx b jy km ka kn kc ko ke kp kg kq ju ki kj kk kl bi translated">猫是一种猫科动物的作品，</li><li id="90ab" class="jv jw in jx b jy km ka kn kc ko ke kp kg kq ju ki kj kk kl bi translated">外科医生是-医生工作，</li><li id="14de" class="jv jw in jx b jy km ka kn kc ko ke kp kg kq ju ki kj kk kl bi translated">浴缸延伸了浴室工程，</li></ul><blockquote class="ma mb mc"><p id="6c2b" class="kr ks md jx b jy kt ku kv ka kw kx ky me kz la lb mf lc ld le mg lf lg lh ju ig bi translated">直到你应用了 IS-A 测试。</p><p id="8dc1" class="kr ks md jx b jy kt ku kv ka kw kx ky me kz la lb mf lc ld le mg lf lg lh ju ig bi translated">如果类 B 扩展了类 A，那么类 B 就是-A 类 A。这在继承树的任何地方都是正确的。如果 C 类扩展了 B 类，那么 C 类通过了 B 和 A 的 IS-A 测试。</p></blockquote><p id="c9bc" class="pw-post-body-paragraph kr ks in jx b jy kt ku kv ka kw kx ky kc kz la lb ke lc ld le kg lf lg lh ju ig bi translated">问:在一个子类中，如果我想同时使用一个方法的超类版本和我的重写子类版本，该怎么办？换句话说，我不想完全取代超类版本，我只是想给它添加更多的东西。</p><p id="27e8" class="pw-post-body-paragraph kr ks in jx b jy kt ku kv ka kw kx ky kc kz la lb ke lc ld le kg lf lg lh ju ig bi translated"><strong class="jx io">答</strong>:你可以这样！这是一个重要的设计特征。把“扩展”这个词理解为“我想扩展超类的功能”。</p><blockquote class="ma mb mc"><p id="e7a1" class="kr ks md jx b jy kt ku kv ka kw kx ky me kz la lb mf lc ld le mg lf lg lh ju ig bi translated">公共 void roam() {</p><p id="52b9" class="kr ks md jx b jy kt ku kv ka kw kx ky me kz la lb mf lc ld le mg lf lg lh ju ig bi translated">super.roam()。</p><p id="b009" class="kr ks md jx b jy kt ku kv ka kw kx ky me kz la lb mf lc ld le mg lf lg lh ju ig bi translated">//我自己漫游的东西</p><p id="b5dc" class="kr ks md jx b jy kt ku kv ka kw kx ky me kz la lb mf lc ld le mg lf lg lh ju ig bi">}</p></blockquote><ul class=""><li id="041d" class="jv jw in jx b jy kt ka kw kc lv ke lw kg lx ju ki kj kk kl bi translated">在子类重写方法中，可以使用关键字 super 调用超类版本。这就像说，“先去运行超类版本，然后回来用我自己的代码完成…”</li></ul><p id="fb9c" class="pw-post-body-paragraph kr ks in jx b jy kt ku kv ka kw kx ky kc kz la lb ke lc ld le kg lf lg lh ju ig bi translated"><strong class="jx io">要点</strong></p><blockquote class="ma mb mc"><p id="82cb" class="kr ks md jx b jy kt ku kv ka kw kx ky me kz la lb mf lc ld le mg lf lg lh ju ig bi translated">子类扩展了超类。</p><p id="d4f8" class="kr ks md jx b jy kt ku kv ka kw kx ky me kz la lb mf lc ld le mg lf lg lh ju ig bi translated">子类继承超类的所有公共实例变量和方法，但不继承超类的私有实例变量和方法。</p><p id="e898" class="kr ks md jx b jy kt ku kv ka kw kx ky me kz la lb mf lc ld le mg lf lg lh ju ig bi translated">继承的方法可以被重写；实例变量不能被覆盖(虽然它们可以在子类中被重定义，但那不是一回事，而且几乎从来没有必要这么做。)</p><p id="a1b9" class="kr ks md jx b jy kt ku kv ka kw kx ky me kz la lb mf lc ld le mg lf lg lh ju ig bi translated">使用 IS-A 测试来验证您的继承层次结构是否有效。如果 X 延伸了 Y，那么 X 是-A Y 一定有意义。</p><p id="f8d5" class="kr ks md jx b jy kt ku kv ka kw kx ky me kz la lb mf lc ld le mg lf lg lh ju ig bi translated">这种关系只有一个方向。河马是一种动物，但不是所有的动物都是河马。</p><p id="70f6" class="kr ks md jx b jy kt ku kv ka kw kx ky me kz la lb mf lc ld le mg lf lg lh ju ig bi translated">当一个方法在子类中被覆盖，并且该方法在子类的实例上被调用时，该方法的被覆盖版本被调用。(最低者胜。)</p><p id="7cde" class="kr ks md jx b jy kt ku kv ka kw kx ky me kz la lb mf lc ld le mg lf lg lh ju ig bi translated">如果 B 类扩展了 A，C 扩展了 B，那么 B 类是-A 类，C 类是-A 类，C 类也是-A 类。</p></blockquote><h2 id="51c5" class="mh mi in bd mj mk ml dn mm mn mo dp mp kc mq mr ms ke mt mu mv kg mw mx my mz bi translated"><strong class="ak">多态性的工作方式:</strong></h2><ul class=""><li id="e77d" class="jv jw in jx b jy na ka nb kc nc ke nd kg ne ju ki kj kk kl bi translated">首先，最好看看我们通常声明引用和创建对象的方式。使用多态性，引用类型可以是实际对象类型的超类。</li><li id="b874" class="jv jw in jx b jy km ka kn kc ko ke kp kg kq ju ki kj kk kl bi translated">当您声明引用变量时，任何通过引用变量声明类型的 IS-A 测试的对象都可以被赋给该引用。</li><li id="7aa4" class="jv jw in jx b jy km ka kn kc ko ke kp kg kq ju ki kj kk kl bi translated">有了多态性，当你在程序中引入新的子类类型时，你可以编写不需要改变的代码。</li></ul><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi nf"><img src="../Images/3fe055fe1d0c02c5aef69d84eb50ac20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aj962g7-SrrD0DGnfNTeyQ.png"/></div></div></figure><blockquote class="ma mb mc"><p id="8346" class="kr ks md jx b jy kt ku kv ka kw kx ky me kz la lb mf lc ld le mg lf lg lh ju ig bi translated"><strong class="jx io"> <em class="in">类</em> </strong> <em class="in">一类</em></p><p id="3e66" class="kr ks md jx b jy kt ku kv ka kw kx ky me kz la lb mf lc ld le mg lf lg lh ju ig bi translated"><strong class="jx io"> <em class="in">类</em> </strong> <em class="in"> B </em> <strong class="jx io"> <em class="in">延伸</em></strong><em class="in"/></p><p id="460e" class="kr ks md jx b jy kt ku kv ka kw kx ky me kz la lb mf lc ld le mg lf lg lh ju ig bi translated"><em class="in">A =</em><strong class="jx io"><em class="in">新</em></strong><em class="in">B()；//向上投射</em></p></blockquote><p id="cd43" class="pw-post-body-paragraph kr ks in jx b jy kt ku kv ka kw kx ky kc kz la lb ke lc ld le kg lf lg lh ju ig bi translated">对于向上转换，我们可以使用类类型或接口类型的引用变量。例如:</p><blockquote class="ma mb mc"><p id="9c45" class="kr ks md jx b jy kt ku kv ka kw kx ky me kz la lb mf lc ld le mg lf lg lh ju ig bi translated"><strong class="jx io">接口</strong> I{}</p><p id="9895" class="kr ks md jx b jy kt ku kv ka kw kx ky me kz la lb mf lc ld le mg lf lg lh ju ig bi translated"><strong class="jx io">类</strong> A{}</p><p id="ac49" class="kr ks md jx b jy kt ku kv ka kw kx ky me kz la lb mf lc ld le mg lf lg lh ju ig bi translated"><strong class="jx io">类</strong> B <strong class="jx io">扩展</strong> A <strong class="jx io">实现</strong> I{}</p></blockquote><p id="b916" class="pw-post-body-paragraph kr ks in jx b jy kt ku kv ka kw kx ky kc kz la lb ke lc ld le kg lf lg lh ju ig bi translated">在这里，B 类的关系将是:</p><blockquote class="ma mb mc"><p id="6b2f" class="kr ks md jx b jy kt ku kv ka kw kx ky me kz la lb mf lc ld le mg lf lg lh ju ig bi translated">B 是-A A <br/> B 是-A I <br/> B 是-A 对象</p></blockquote><p id="edff" class="pw-post-body-paragraph kr ks in jx b jy kt ku kv ka kw kx ky kc kz la lb ke lc ld le kg lf lg lh ju ig bi translated">问:你为什么会想上最后一堂课？阻止一个类被子类化会有什么好处？</p><ul class=""><li id="5e25" class="jv jw in jx b jy kt ka kw kc lv ke lw kg lx ju ki kj kk kl bi translated">通常，您不会将您的类设置为最终类。但是如果你需要安全，知道方法总是按照你写的方式工作的安全(因为它们不能被覆盖)，final 类会给你这个。由于这个原因，Java API 中的许多类都是最终类。例如，String 类是 final 类，因为，嗯，想象一下如果有人改变了字符串的行为方式会造成多大的破坏！</li></ul></div></div>    
</body>
</html>