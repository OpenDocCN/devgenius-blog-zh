<html>
<head>
<title>Golang Data Structures: Stack and Queue #2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang 数据结构:堆栈和队列#2</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/golang-data-structures-stack-and-queue-2-5a6822baeb0d?source=collection_archive---------4-----------------------#2022-11-13">https://blog.devgenius.io/golang-data-structures-stack-and-queue-2-5a6822baeb0d?source=collection_archive---------4-----------------------#2022-11-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="4e82" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">之前我在 Golang 里写过链表。我们的下一个数据结构是堆栈和队列。堆栈和队列在很多研究案例中都有实现。让我们开始吧！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a38afbb10d7d62c1220c9c954831e4fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CdRcwi3Rl1Ccpo0p_LNsxQ.png"/></div></div></figure><h1 id="a0bf" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">堆</h1><p id="6171" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">堆栈是一种线性数据结构，遵循后进先出(LIFO)顺序的原则。插入堆栈中的最后一个元素将是第一个被移除的元素。堆栈有很多实现方式，例如当我们在食堂吃完饭后把盘子叠放在一起时，或者当计算机读取我们的代码时。当你想以相反的顺序把东西放进去的时候，Stack 是很有用的。</p><p id="99c3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">堆栈有 3 个操作</p><ul class=""><li id="06d3" class="lx ly in jm b jn jo jr js jv lz jz ma kd mb kh mc md me mf bi translated">推</li><li id="a044" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">流行音乐</li><li id="1061" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">偷看</li></ul><p id="7f5e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">堆栈可以用数组或链表来实现。在这篇文章中，我将展示如何创建一个带有单链表的堆栈。在我们创建堆栈之前，我们必须创建一个新的结构，它是节点和堆栈。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/ce338c687407844dc63d7e32b993558c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ns111902AZ6hf4KY"/></div></div></figure><p id="4db0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们必须设计我们的节点如何相互连接。我们有 2 个选择，底部节点指向上面的节点或者相反。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mm"><img src="../Images/6211f52d8c0dafbf1b292e7fc885a19c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1BZl9dcWGFIRhlHe"/></div></div></figure><p id="b4e4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正确答案是第二种，上面的节点指向下面的节点。为什么？因为在堆栈中，我们必须跟踪我们的顶层节点。如果我们在删除顶部节点后使用第一个选择，我们如何能够将顶部节点更改为下面的节点？我们不能，除非我们必须从底部节点遍历，这需要更多的时间或 O(n)。我们要的是 O(1)，所以用第二种选择。如果我们移除顶部节点，我们可以简单地将顶部节点更改为下面的节点。</p><h2 id="8faf" class="mn kv in bd kw mo mp dn la mq mr dp le jv ms mt li jz mu mv lm kd mw mx lq my bi translated">推</h2><p id="a9f5" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">在堆栈中，推是在堆栈顶部添加新元素的操作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/3c56859659742f1875f4fa279325f064.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/0*_84pKWcOGh339VJy"/></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">教程要点</figcaption></figure><p id="bfc2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了进行推送操作，我用一种指针将方法附加到堆栈上。首先，我们必须检查堆栈中是否有节点。如果我们没有，那么顶部和底部指向我们的新节点。如果我们已经有节点，我们的新节点指向顶部节点，然后顶部节点指向我们的新节点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/e50ea4434501d579d481b43b48cb2d75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*einbDIFvwvJhisrF"/></div></div></figure><h2 id="6572" class="mn kv in bd kw mo mp dn la mq mr dp le jv ms mt li jz mu mv lm kd mw mx lq my bi translated">流行音乐</h2><p id="be87" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">Pop 是一个移除栈顶元素的操作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/8efe4335f064992eeecbdfddbd1d6f13.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/0*klNyvibcpQccQpRD"/></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">教程要点</figcaption></figure><p id="9744" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们必须检查堆栈中是否有节点。如果我们没有，那就回来。如果我们只有一个节点，那么我们只需将顶点和底点更改为零。如果我们有一个以上的节点，那么我们改变顶部到顶部。下一步。之后，删除连接从以前我们的顶部节点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/745474282b5a16a39dc0f767fee7fbd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4IX6JfPUuw8sFHWb"/></div></div></figure><h2 id="3a93" class="mn kv in bd kw mo mp dn la mq mr dp le jv ms mt li jz mu mv lm kd mw mx lq my bi translated">偷看</h2><p id="35ca" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">Peek 是一个查看栈顶元素的操作。因为我们跟踪我们的顶部和底部节点，我们可以只打印出顶部节点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/89d031947a5e85eb52dd4ec684d94286.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KlTZqPYeCJxUTCaR"/></div></div></figure><h1 id="c836" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">长队</h1><p id="6907" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">队列是一种线性数据结构，遵循先入先出(FIFO)顺序的原则。队列中插入的第一个元素将是第一个被移除的元素。现实生活中有很多排队的例子，比如，打印、买票、叫优步等等。</p><p id="9cd3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">队列有 3 个操作:</p><ul class=""><li id="9168" class="lx ly in jm b jn jo jr js jv lz jz ma kd mb kh mc md me mf bi translated">入队:在最后一个索引上添加新元素</li><li id="1503" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">出列:删除第一个元素</li><li id="2f35" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">偷看:看第一个元素</li></ul><p id="9dc2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">队列可以用数组和链表来实现。但是，最好使用链表，因为我们有一个移除第一个索引的操作。在数组中，O(n)花费更多的时间，因为我们必须移动数组中的索引。首先，我们必须创建一个新的结构，即节点和队列。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/d5267cc382185ac46a6c2d895ad4ea87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2iQJCqC5SQY1hU1Q"/></div></div></figure><p id="31e6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们必须设计我们的节点如何相互连接。我们有两个选择，第一个节点指向第二个节点或者相反。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mm"><img src="../Images/c1c71149b16abafb3b039e6d252f7cbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RujtWOnYcvJHYG9L"/></div></div></figure><p id="c8ac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正确答案是最上面的一个，是第一个节点指向第二个节点。为什么？因为我们必须在移除第一个节点时追踪它。例如，如果我们删除第一个节点，我们必须将第一个节点移动到第二个节点。在底部的选择中，当我们删除第一个节点时，第一个节点与第二个节点没有任何连接，因此我们不能将第一个节点移动到第二个节点。</p><h2 id="9afb" class="mn kv in bd kw mo mp dn la mq mr dp le jv ms mt li jz mu mv lm kd mw mx lq my bi translated">使…入队</h2><p id="d382" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">Enqueue 是在队列末尾添加新元素的操作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/e082b19e8cf61ba3579ce2ca54ddae76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/0*FoIb_A7zwaVkZ9s7"/></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">教程要点</figcaption></figure><p id="3399" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要添加一个新节点，我们必须检查我们的队列中是否有任何节点。如果我们没有，那么我们将第一个和最后一个设置为我们的最后一个节点。如果我们有节点，那么最后一个节点指向我们的新节点，然后将最后一个节点移动到我们的节点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/1f935cc1befd5a35d5fca1b383f0351f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fltpRZ4wTRviGQ_6"/></div></div></figure><h2 id="44d7" class="mn kv in bd kw mo mp dn la mq mr dp le jv ms mt li jz mu mv lm kd mw mx lq my bi translated">出列</h2><p id="08e4" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">出列是删除队列中第一个节点的操作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/e4a5d57e4861e9b4eba379436c94c8e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/0*ArReQ6vbYAMrOsiD"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">教程要点</figcaption></figure><p id="cd28" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要删除第一个节点，我们必须检查我们的队列中是否有任何节点。如果我们没有，那就退回去。如果我们只有一个节点，那么我们将第一个和最后一个设置为零。如果我们有多个节点，那么我们将第一个节点移动到第二个节点，然后删除从第一个节点到第二个节点的连接。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/fe6c5218df2fe5af9a906f17d4b4c2e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Sq7cdDQEeyGd9r3-"/></div></div></figure><h2 id="b4a6" class="mn kv in bd kw mo mp dn la mq mr dp le jv ms mt li jz mu mv lm kd mw mx lq my bi translated">偷看</h2><p id="4ae0" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">Peek 是查看队列中第一个元素的操作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/a5d959628f3e980faaf483e2c90c8e17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zwtiZx1eeP9vMHLu"/></div></div></figure><h1 id="fb9a" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结论</h1><p id="7a8b" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">堆栈和队列是软件工程师需要了解的数据结构之一。它们可以在很多研究案例中实现。当你想把东西从你放进去的时候以相反的顺序取出来的时候，Stack 是很有用的。堆栈的一个例子是当计算机读取我们的程序时。当事情不是必须立即处理，而是必须以先进先出的顺序处理时，队列很有用。排队的一个例子是我们在电影院买票的时候。</p></div><div class="ab cl ng nh hr ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ig ih ii ij ik"><p id="d631" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本文到此为止，别忘了留下一个赞，分享给别人。如果你有任何建议或推荐，我会很高兴你在下面留下评论。感谢你阅读这篇文章，祝你有美好的一天👋。</p></div></div>    
</body>
</html>