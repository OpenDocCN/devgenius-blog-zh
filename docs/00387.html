<html>
<head>
<title>An Introduction to Functional Programming with JavaScript — part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript函数式编程介绍—第1部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/introduction-to-functional-programming-in-javascript-e33fe8e94ed6?source=collection_archive---------6-----------------------#2020-06-05">https://blog.devgenius.io/introduction-to-functional-programming-in-javascript-e33fe8e94ed6?source=collection_archive---------6-----------------------#2020-06-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="35f8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">纯函数、参照透明性和等式推理</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/760070141414908ceda4f2c705102146.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1gTm-BTEMJRZASoC"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@r3dmax?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">乔纳森派</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="7160" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">我目前正在学习JavaScript的函数式编程。</em></p><p id="e2be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我决定写下我的发现，以提高我对这个主题的理解，并帮助走上类似道路的人。</p><p id="7c25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管总是调查相关来源，并尝试对我文章中的每一个观点进行事实核查，错误还是会发生。所以，如果你注意到我的文章中有任何语法、语义、推理或任何其他类型的错误，请在下面的评论区留下建设性的反馈。</p><h2 id="13bb" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">有用的来源</h2><ul class=""><li id="8351" class="mm mn iq ky b kz mo lc mp lf mq lj mr ln ms lr mt mu mv mw bi translated"><em class="ls">“函数式轻JavaScript”作者凯尔·辛普森(1) </em></li><li id="f95a" class="mm mn iq ky b kz mx lc my lf mz lj na ln nb lr mt mu mv mw bi translated"><em class="ls">“编写软件，Javascript中函数式编程和对象组合的探索”，作者Eric Elliot (2) </em></li><li id="f646" class="mm mn iq ky b kz mx lc my lf mz lj na ln nb lr mt mu mv mw bi translated"><em class="ls">“弗里斯比教授的函数式编程基本指南”，作者布莱恩·朗斯多夫(3) </em></li><li id="1d9f" class="mm mn iq ky b kz mx lc my lf mz lj na ln nb lr mt mu mv mw bi translated"><em class="ls"> MDN网络文档/ JavaScript </em></li><li id="d822" class="mm mn iq ky b kz mx lc my lf mz lj na ln nb lr mt mu mv mw bi translated"><em class="ls">维基百科</em></li></ul><h1 id="854a" class="nc lu iq bd lv nd ne nf ly ng nh ni mb jw nj jx me jz nk ka mh kc nl kd mk nm bi translated">介绍</h1><p id="8319" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">本文的目标是分析以下FP概念:</p><ul class=""><li id="97f1" class="mm mn iq ky b kz la lc ld lf nq lj nr ln ns lr mt mu mv mw bi translated"><strong class="ky ir">纯功能</strong></li><li id="401c" class="mm mn iq ky b kz mx lc my lf mz lj na ln nb lr mt mu mv mw bi translated"><strong class="ky ir">参照透明度</strong></li><li id="6062" class="mm mn iq ky b kz mx lc my lf mz lj na ln nb lr mt mu mv mw bi translated"><strong class="ky ir">方程式推理</strong></li></ul><p id="ff88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">示例用于展示如何在基于JS的应用程序中实现这些概念。</p><h1 id="2f5f" class="nc lu iq bd lv nd ne nf ly ng nh ni mb jw nj jx me jz nk ka mh kc nl kd mk nm bi translated">论纯函数与副作用</h1><blockquote class="nt nu nv"><p id="e104" class="kw kx ls ky b kz la jr lb lc ld ju le nw lg lh li nx lk ll lm ny lo lp lq lr ij bi translated">一个<strong class="ky ir">纯函数</strong>是一个给定相同输入的函数，将总是返回相同的输出，并且没有任何可观察到的副作用</p></blockquote><p id="bb1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在继续举例之前，我们需要定义什么是副作用。</p><p id="caf0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，一个<strong class="ky ir">效果</strong>是在一个结果的计算中发生的任何事情，除了结果本身。</p><blockquote class="nt nu nv"><p id="9faa" class="kw kx ls ky b kz la jr lb lc ld ju le nw lg lh li nx lk ll lm ny lo lp lq lr ij bi translated"><strong class="ky ir">副作用</strong>是在结果的计算过程中，与“外部”世界的可观察到的相互作用，它导致系统状态的改变。</p></blockquote><p id="012c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">副作用例子有:</p><ul class=""><li id="3b0f" class="mm mn iq ky b kz la lc ld lf nq lj nr ln ns lr mt mu mv mw bi translated">从API中获取数据(或者更一般地说，进行HTTP调用)</li><li id="fc38" class="mm mn iq ky b kz mx lc my lf mz lj na ln nb lr mt mu mv mw bi translated">记录到控制台</li><li id="7d76" class="mm mn iq ky b kz mx lc my lf mz lj na ln nb lr mt mu mv mw bi translated">查询和/或改变DOM</li><li id="b5b0" class="mm mn iq ky b kz mx lc my lf mz lj na ln nb lr mt mu mv mw bi translated">处理用户事件(如鼠标点击、输入字段改变等)。)</li></ul><p id="ef86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">函数式编程并不禁止在我们的程序中使用副作用。如果是这样的话，那么几乎没有什么程序是有用的。</p><p id="88d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是FP的目标之一是以一种更加可控和包容的方式执行那些“危险”的计算。</p><h1 id="a4e9" class="nc lu iq bd lv nd ne nf ly ng nh ni mb jw nj jx me jz nk ka mh kc nl kd mk nm bi translated">非纯函数的例子</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="31a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> fetchData </strong>做它所说的。它从一个API获取一些数据，但是以一种<em class="ls">不受控制的方式，</em>所以它被认为是一个副作用。</p><p id="c672" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">简单地记录一个错误。但这也被认为是副作用。</strong></p><p id="f9be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这两种情况下，正确的FP实现应该是使用Monad(我计划在以后的文章中解决这个构造)。</p><p id="572e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">随机数发生器</strong>函数并不纯粹，因为当给定相同的输入时，它并不总是返回相同的输出。这是使用<strong class="ky ir"> Math.random() </strong>方法的明显结果。</p><p id="2d85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> sum2Numbers </strong>不好有两个原因。</p><p id="4af3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个，与FP相关，是函数在其词法范围之外改变状态(变量<em class="ls"> planets </em>，从而在系统状态中产生不可预测的变化(这是一个副作用)。</p><p id="f0e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二个问题与最佳实践有关，即函数的名称会产生误导。除了名字所暗示的之外，这个函数还做了额外的事情，这使得这个函数很难调试。</p><p id="6fef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，有一个简单的修复方法，不需要使用单子(或任何其他高级FP结构):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="6594" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个函数实际上做了它所说的，它在FP意义上是纯函数。如果给定相同的输入，它将总是返回相同的输出，并且它也不会改变其词法范围之外的任何系统状态。</p><h1 id="d42b" class="nc lu iq bd lv nd ne nf ly ng nh ni mb jw nj jx me jz nk ka mh kc nl kd mk nm bi translated">纯函数的例子</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="3714" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> slice </strong>是内置的JS数组方法。</p><blockquote class="nt nu nv"><p id="ac02" class="kw kx ls ky b kz la jr lb lc ld ju le nw lg lh li nx lk ll lm ny lo lp lq lr ij bi translated"><strong class="ky ir"> Slice </strong>将数组的一部分的浅拷贝返回到一个从头到尾选定的新数组对象中(不包括end ),其中start和end表示该数组中项的索引。</p></blockquote><p id="f537" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">定义的第一部分解释了为什么这个函数是纯的(不像一个非常相似的内置JS数组方法叫做<strong class="ky ir"> splice </strong>是不纯的)。</p><p id="d6d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，<strong class="ky ir"/><strong class="ky ir">remove vehicletype from inventory</strong>是一个纯函数，因为它不改变传递给它的参数(即<em class="ls"> inventory </em>对象)，当给定相同的输入时，它总是返回相同的输出。</p><h1 id="541f" class="nc lu iq bd lv nd ne nf ly ng nh ni mb jw nj jx me jz nk ka mh kc nl kd mk nm bi translated">浅复制与深复制</h1><p id="ff55" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">查看<strong class="ky ir">removevehicletypefromtumentory</strong>函数，我们如何确定它没有修改<em class="ls"> inventory </em>对象(位于其作用域之外，并且<em class="ls">作为引用传递)？</em></p><p id="993c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为<em class="ls">库存</em>是在突变发生之前复制的(在函数体中)。</p><p id="589a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一种确保我们没有改变<em class="ls">库存</em>对象的方法是冻结它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="145c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是<strong class="ky ir"> Object.freeze </strong>也浅。很像在<strong class="ky ir">removevehicletypefromtinventory</strong>函数({ … vehicles})中使用的spread运算符。</p><p id="4d96" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，如果您在JS中对嵌套的、通过引用传递的类型、数据(如对象和数组)的任何属性进行变异，请小心。尤其是当您将数据作为函数参数传递时。</p><p id="d120" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果数据结构更复杂，并且由多个嵌套层组成，那么有几个选项可用于保持数据的不变性；</p><ul class=""><li id="ba56" class="mm mn iq ky b kz la lc ld lf nq lj nr ln ns lr mt mu mv mw bi translated">使用类似于<em class="ls">JSON . parse(JSON . stringify(obj)</em>的东西执行深度复制。(但这不是很好的表现)</li><li id="ad2a" class="mm mn iq ky b kz mx lc my lf mz lj na ln nb lr mt mu mv mw bi translated">用JS原语手动浅复制数据结构的每一层，如<em class="ls"> Object.assign </em>或spread (…)操作符。</li><li id="50ae" class="mm mn iq ky b kz mx lc my lf mz lj na ln nb lr mt mu mv mw bi translated">使用外部库中的实用函数，如<em class="ls"> Lodash </em>来执行深度复制</li><li id="75e5" class="mm mn iq ky b kz mx lc my lf mz lj na ln nb lr mt mu mv mw bi translated">在外部库的帮助下使用不可变的数据结构，比如<em class="ls"> Immutable.js </em>(推荐的方法)</li></ul><h1 id="19e1" class="nc lu iq bd lv nd ne nf ly ng nh ni mb jw nj jx me jz nk ka mh kc nl kd mk nm bi translated">论指称透明性和等式推理</h1><p id="844b" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">纯函数是透明的。</p><p id="bac5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着带有特定参数的函数可以在代码中被其计算值完全替换。程序的逻辑也不会受到影响。</p><p id="fb42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="87d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以替换为:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="9f8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当试图对代码流进行推理时，这个属性很方便。</p><p id="e22b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用纯函数(引用透明)和不可变数据类型的组合开启了一种特殊的重构和调试FP代码的技术，称为<strong class="ky ir">等式推理</strong>。</p><p id="782e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们尝试一个例子来展示这种技术的威力。</p><p id="2fac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个非常糟糕的关系匹配算法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="5a78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls"> mike </em>和<em class="ls"> jane </em>数据结构是不可变的(借助于Immutable.js)，<strong class="ky ir">是CompatibleMatch </strong>和<strong class="ky ir"> generateMessage </strong>函数是纯函数。因此，我们可以使用等式推理来更详细地思考代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="7cd1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种技术简化了对代码进行推理的过程，因此重构和调试也变得更加容易。</p><h1 id="41b4" class="nc lu iq bd lv nd ne nf ly ng nh ni mb jw nj jx me jz nk ka mh kc nl kd mk nm bi translated"><strong class="ak">结论</strong></h1><p id="e60d" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">在这篇文章中，我试图用一种初学者友好和可理解的方式来处理一些简单的FP概念。</p><p id="2334" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你喜欢它。</p><p id="8ed0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在以后的博客文章中，我计划写一些关于FP的其他重要东西，比如不变性(更详细)，部分应用，Currying，Composition，Piping，Point Free style，函子，单子等等。</p></div></div>    
</body>
</html>