<html>
<head>
<title>DevOps in Go — Basic Data Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go 中的 DevOps 基本数据类型</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/devops-in-go-basic-data-types-492d69f733ca?source=collection_archive---------2-----------------------#2022-12-01">https://blog.devgenius.io/devops-in-go-basic-data-types-492d69f733ca?source=collection_archive---------2-----------------------#2022-12-01</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="478d" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">Go bootcamp 系列中的 DevOps</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj kg"><img src="../Images/c4c2d3b5829ff3319cc3a189056f2ae7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/0*bTcvWAQ89IJwjKpe.png"/></div></figure><p id="98be" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">在我的上一篇文章“<a class="ae lk" href="https://medium.com/geekculture/devops-in-go-variables-42022d5088bc" rel="noopener"> DevOps in Go — Variables </a>”中，我谈到了声明 Go 变量的不同方式，以及为什么 Go 变量应该通过指定变量类型来拥有清晰的内存边界。今天我们来探讨一下 Go 基本数据类型。</p><h1 id="f08c" class="ll lm ir bd ln lo lp lq lr ls lt lu lv jx lw jy lx ka ly kb lz kd ma ke mb mc bi translated">Go 数据类型</h1><p id="d6ba" class="pw-post-body-paragraph ko kp ir kq b kr md js kt ku me jv kw kx mf kz la lb mg ld le lf mh lh li lj ik bi translated">Go 数据类型大致可以分为三种:</p><ul class=""><li id="f75b" class="mi mj ir kq b kr ks ku kv kx mk lb ml lf mm lj mn mo mp mq bi translated">基本数据类型</li><li id="37d1" class="mi mj ir kq b kr mr ku ms kx mt lb mu lf mv lj mn mo mp mq bi translated">复杂数据类型</li><li id="0dc2" class="mi mj ir kq b kr mr ku ms kx mt lb mu lf mv lj mn mo mp mq bi translated">接口数据类型</li></ul><p id="c970" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">基本数据类型是三种类型中最常用的一种。</p><h1 id="e667" class="ll lm ir bd ln lo lp lq lr ls lt lu lv jx lw jy lx ka ly kb lz kd ma ke mb mc bi translated">基本数据类型</h1><h2 id="945e" class="mw lm ir bd ln mx my dn lr mz na dp lv kx nb nc lx lb nd ne lz lf nf ng mb nh bi translated">Go 整数类型</h2><p id="ee9b" class="pw-post-body-paragraph ko kp ir kq b kr md js kt ku me jv kw kx mf kz la lb mg ld le lf mh lh li lj ik bi translated">整数类型主要用于表示现实世界中的整数，如年龄、年份等。分为<strong class="kq is">平台无关</strong>整型和<strong class="kq is">平台相关</strong>整型。</p><p id="49b7" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">平台无关和平台相关的主要区别在于，在不同的 CPU 架构或操作系统下，这些整数类型是否相同。</p><p id="c4d8" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">下表显示了与 Go 平台无关的整数类型:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj kg"><img src="../Images/b299dce63491cb6dcbba370d671b3def.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/0*WWWM8gAmW_WvM0C7.png"/></div></figure><p id="9a6c" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">对于平台相关的整数类型，我们有<code class="fe ni nj nk nl b">int</code>、<code class="fe ni nj nk nl b">uint</code>和<code class="fe ni nj nk nl b">uintptr</code>:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj kg"><img src="../Images/2785588d5126084cea2c6e6217864005.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/0*9GS1ZKOfNINh_ItM.png"/></div></figure><p id="4780" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">因为<code class="fe ni nj nk nl b">int</code>、<code class="fe ni nj nk nl b">uint</code>和<code class="fe ni nj nk nl b">uintptr</code>都是平台相关的，所以当我们编写需要可移植性的代码时，一定不能依赖这些类型的长度。如果不知道目标操作平台上这三种类型的长度，可以通过 unsafe 包提供的<code class="fe ni nj nk nl b">SizeOf</code>函数得到。例如，在 x86–64 平台上，它们的长度是 8:</p><pre class="kh ki kj kk gu nm nl nn bn no np bi"><span id="4704" class="nq lm ir nl b be nr ns l nt nu">var a, b = int(5), uint(6)<br/>var p uintptr = 0x12345678<br/>fmt.Println("signed integer a's length is", unsafe.Sizeof(a)) // 8<br/>fmt.Println("unsigned integer b's length is", unsafe.Sizeof(b)) // 8<br/>fmt.Println("uintptr's length is", unsafe.Sizeof(p)) // 8</span></pre><p id="4224" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated"><strong class="kq is">整数数字文字</strong></p><p id="2d79" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">Go 继承了 C 编程语言在数字文字(number literal)上的语法形式。早期版本支持十进制、八进制和十六进制数字文字形式，例如:</p><pre class="kh ki kj kk gu nm nl nn bn no np bi"><span id="17f8" class="nq lm ir nl b be nr ns l nt nu">a := 53        // Decimal<br/>b := 0700      // Octal，"0" prefix<br/>c1 := 0xaabbcc // Hex，"0x" prefix<br/>c2 := 0Xddeeff // Hex，"0X" prefix</span></pre><p id="8f5a" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">在 Go v1.13 版之后，它增加了以下内容:</p><pre class="kh ki kj kk gu nm nl nn bn no np bi"><span id="9158" class="nq lm ir nl b be nr ns l nt nu">d1 := 0b10000001 // binary，"0b" prefix<br/>d2 := 0B10000001 // binary，"0B" prefix<br/>e1 := 0o700      // Octal，"0o" prefix<br/>e2 := 0O700      // Octal，"0O" prefixa := 5_3_7          // Decimal: 537<br/>b := 0b_1000_0111   // Binary 10000111 <br/>c1 := 0_700         // Octal: 0700<br/>c2 := 0o_700        // Octal: 0700<br/>d1 := 0x_5c_6d      // Hex：0x5c6d</span></pre><p id="ef07" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">你也可以使用<code class="fe ni nj nk nl b">fmt</code>包将整数转换成不同的格式输出:</p><pre class="kh ki kj kk gu nm nl nn bn no np bi"><span id="029c" class="nq lm ir nl b be nr ns l nt nu">var a int8 = 59<br/>fmt.Printf("%b\n", a) // binary：111011<br/>fmt.Printf("%d\n", a) // decimal：59<br/>fmt.Printf("%o\n", a) // octal：73<br/>fmt.Printf("%O\n", a) // octal with 0o prefix：0o73<br/>fmt.Printf("%x\n", a) // Hex：3b<br/>fmt.Printf("%X\n", a) // Hex：3B</span></pre><h2 id="4005" class="mw lm ir bd ln mx my dn lr mz na dp lv kx nb nc lx lb nd ne lz lf nf ng mb nh bi translated">浮点</h2><p id="660e" class="pw-post-body-paragraph ko kp ir kq b kr md js kt ku me jv kw kx mf kz la lb mg ld le lf mh lh li lj ik bi translated">与整数类型相比，浮点类型的使用场景相对集中，主要在科学数值计算、图形图像处理与仿真、多媒体游戏、人工智能等领域。</p><p id="dde3" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated"><strong class="kq is">浮动 32 vs 浮动 64 </strong></p><p id="a121" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">Go 提供了两种浮点类型<code class="fe ni nj nk nl b">float32</code>和<code class="fe ni nj nk nl b">float64</code>，分别对应于<strong class="kq is"> IEEE 754 </strong>中的单精度和双精度浮点数值类型。</p><p id="3023" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">不过这里需要注意的是，Go 语言中并没有提供<code class="fe ni nj nk nl b">float</code>类型。这不像整数类型。Go 既提供了<code class="fe ni nj nk nl b">int16</code>、<code class="fe ni nj nk nl b">int32</code>等类型，也提供了 int 类型。换句话说，Go 提供的浮点类型是<strong class="kq is">平台无关的</strong>。</p><p id="6e7c" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">无论是<code class="fe ni nj nk nl b">float32</code>还是<code class="fe ni nj nk nl b">float64</code>，它们变量的默认值都是 0.0。区别在于它们占用的内存空间，以及浮点数的范围/精度。</p><p id="15c9" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated"><code class="fe ni nj nk nl b">float</code>到<code class="fe ni nj nk nl b">binary</code>的对话比较复杂，这里不赘述，不过有兴趣的可以参考“<a class="ae lk" href="https://www.h-schmidt.net/FloatConverter/IEEE754.html" rel="noopener ugc nofollow" target="_blank"> IEEE-754 浮点转换器</a>”。</p><p id="c5f6" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">同样，为了方便起见，您可以只使用<code class="fe ni nj nk nl b">fmt</code>包。</p><pre class="kh ki kj kk gu nm nl nn bn no np bi"><span id="4776" class="nq lm ir nl b be nr ns l nt nu">func main() {<br/>    var f float32 = 139.8125<br/>    bits := math.Float32bits(f)<br/>    fmt.Printf("%b\n", bits)<br/>}Output:</span></pre><pre class="nv nm nl nw nx aw ny bi"><span id="7c2a" class="mw lm ir nl b gz nz oa l ob nu">1000011000010111101000000000000</span></pre><p id="cf6b" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated"><strong class="kq is">浮点数字面</strong></p><p id="88cc" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">Go 浮点型文字值大致可以分为两类，一类是浮点值形式:</p><pre class="kh ki kj kk gu nm nl nn bn no np bi"><span id="3895" class="nq lm ir nl b be nr ns l nt nu">3.1415<br/>.15<br/>81.80<br/>82.</span></pre><p id="baf5" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">另一种是科学符号形式:</p><pre class="kh ki kj kk gu nm nl nn bn no np bi"><span id="f463" class="nq lm ir nl b be nr ns l nt nu">6674.28e-2 // 6674.28 * 10^(-2) = 66.742800<br/>.12345E+5  // 0.12345 * 10^5 = 12345.000000</span></pre><p id="4098" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">与<code class="fe ni nj nk nl b">int</code>一样，<code class="fe ni nj nk nl b">fmt</code>包也提供浮点输出:</p><pre class="kh ki kj kk gu nm nl nn bn no np bi"><span id="5e12" class="nq lm ir nl b be nr ns l nt nu">var f float64 = 123.45678<br/>fmt.Printf("%f\n", f) // 123.456780fmt.Printf("%e\n", f) // 1.234568e+02<br/>fmt.Printf("%x\n", f) // 0x1.edd3be22e5de1p+06</span></pre><h2 id="6750" class="mw lm ir bd ln mx my dn lr mz na dp lv kx nb nc lx lb nd ne lz lf nf ng mb nh bi translated">复杂数据类型</h2><p id="1e70" class="pw-post-body-paragraph ko kp ir kq b kr md js kt ku me jv kw kx mf kz la lb mg ld le lf mh lh li lj ik bi translated"><code class="fe ni nj nk nl b">z=a+bi</code>形式的数字称为复数。Go 语言本身支持复数类型。但相比整数和浮点类型，复数类型在 Go 中的应用更加有限，主要用于专业领域的计算，比如向量计算。</p><p id="dd39" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">Go 提供了两种复数:<code class="fe ni nj nk nl b">complex64</code>和<code class="fe ni nj nk nl b">complex128</code>。如果一个复数没有显示分配的类型，那么它的默认类型是<code class="fe ni nj nk nl b">complex128</code>。</p><p id="b7aa" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">在围棋中有三种表示复数的方法:</p><ul class=""><li id="a509" class="mi mj ir kq b kr ks ku kv kx mk lb ml lf mm lj mn mo mp mq bi translated">直接初始化一个复数变量:</li></ul><pre class="kh ki kj kk gu nm nl nn bn no np bi"><span id="e998" class="nq lm ir nl b be nr ns l nt nu">var c = 5 + 6i<br/>var d = 0o123 + .12345E+5i // 83+12345i</span></pre><ul class=""><li id="6e11" class="mi mj ir kq b kr ks ku kv kx mk lb ml lf mm lj mn mo mp mq bi translated">使用<code class="fe ni nj nk nl b">complext</code>功能</li></ul><pre class="kh ki kj kk gu nm nl nn bn no np bi"><span id="e6e0" class="nq lm ir nl b be nr ns l nt nu">var c = complex(5, 6) // 5 + 6i<br/>var d = complex(0o123, .12345E+5) // 83+12345i</span></pre><ul class=""><li id="48bf" class="mi mj ir kq b kr ks ku kv kx mk lb ml lf mm lj mn mo mp mq bi translated">使用<code class="fe ni nj nk nl b">real</code>和<code class="fe ni nj nk nl b">imag</code>:</li></ul><pre class="kh ki kj kk gu nm nl nn bn no np bi"><span id="1707" class="nq lm ir nl b be nr ns l nt nu">var c = complex(5, 6) // 5 + 6i<br/>r := real(c) // 5.000000<br/>i := imag(c) // 6.000000</span></pre></div></div>    
</body>
</html>