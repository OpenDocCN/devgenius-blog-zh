<html>
<head>
<title>Database Sharding 101</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据库分片 101</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/database-sharding-101-4ef36046c29c?source=collection_archive---------4-----------------------#2022-06-19">https://blog.devgenius.io/database-sharding-101-4ef36046c29c?source=collection_archive---------4-----------------------#2022-06-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="af45" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这篇博客是我们从零开始讨论 101 个<strong class="jm io"> </strong>概念的系列文章的一部分，读者的入门知识有限。本文属于<strong class="jm io"> <em class="ki">中级</em> </strong>系列，因为它涉及对<strong class="jm io">数据库分片</strong>的理解，后者主要用于将单个节点中的数据分布到多个分区节点上，以提高业务应用程序的可伸缩性和性能。</p><p id="d451" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">101 系列中的一些早期博客如下:</p><p id="de31" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/caching-strategy-101-3bc974d2a6cd"> <strong class="jm io">缓存策略 101</strong><br/></a><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/cors-101-72b462396deb"><strong class="jm io">CORS 101</strong></a><strong class="jm io"><br/></strong><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/circuit-breaker-pattern-101-be2d7fdb656"><strong class="jm io">断路器 101 </strong> <br/> </a> <a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/priority-queues-101-40eb4f6f5ee9"> <strong class="jm io">优先级队列 101 </strong> </a> <a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/async-communication-101-b04d5c95333a"> <strong class="jm io"> <br/>异步通信 101</strong></a><strong class="jm io"><br/></strong><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/database-design-101-7c019d69b97f"><strong class="jm io">数据库设计 100</strong></a></p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/2ecf433de18f955fee682caa592432af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kLUqQRjE-oRf_RK1TOOqLw.png"/></div></div></figure><h1 id="0753" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">什么是分片？</h1><p id="e236" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">分片是一种设计模式，其中大型数据库被划分为多个节点，每个节点为由<em class="ki">键/id </em>逻辑分区的<em class="ki">客户/实体</em>的子集提供数据。对数据库进行分区的一些原因是<strong class="jm io">单个服务器上的垂直存储限制、由于高并发性需求而导致的缓慢性能、具有地理上共置的节点以更好地为客户服务的端到端延迟</strong>。</p><p id="1555" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过将数据分布到多个碎片中，大规模分布式应用可以针对当前和未来不断增长的数据需求建立长期弹性，这些需求受到云托管数据库的 SKU 的限制。</p><h1 id="1ac2" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">分片技术</h1><p id="bf90" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">使用不同的逻辑技术来决定为终端-2-终端客户请求找到正确的碎片。帮助做出这个决定的键被称为<a class="ae kj" href="https://www.mongodb.com/docs/manual/core/sharding-shard-key/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">分片键</strong> </a>，并且应该是生产过程中的静态字段。根据需要，分片密钥可以是单一的，也可以是复合的。</p><p id="23bf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在为整个分片策略生成一个合适的策略之前，要考虑许多因素，如数据库查找的<strong class="jm io">频率、后期添加分片的成本</strong>等。独立于这些技术，有两个关键原则受到警告— <strong class="jm io">避免碎片之间的数据迁移，以及将单个租户数据分布在多个碎片上。<em class="ki"> </em> </strong>一些常见的技巧如下</p><h2 id="f700" class="lz kx in bd ky ma mb dn lc mc md dp lg jv me mf lk jz mg mh lo kd mi mj ls mk bi translated">范围策略</h2><p id="48f9" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">在范围策略中，属于特定的<strong class="jm io">范围(1-N) </strong>的实体由给定的碎片提供服务。这用于将相关实体分组在一起。基于日期范围的 Ex <strong class="jm io">客户交易</strong>使用相同的 shard 提供服务，因此通过查询单个节点可以简化获取月度汇总报告。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/b777e303bd3b824041159b12fc2eccb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/1*ziuUUUn-zhNFqaZZCkt17A.jpeg"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated"><strong class="bd ky">客户基数范围策略</strong></figcaption></figure><p id="0492" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它更容易实现，并且范围查询适用于业务用例的<strong class="jm io">批处理操作</strong>。然而，这种策略并不能保证分片之间的最优流量分配，并且一些节点可能会为客户流量提供较大的乘数。</p><h2 id="daf7" class="lz kx in bd ky ma mb dn lc mc md dp lg jv me mf lk jz mg mh lo kd mi mj ls mk bi translated">查找策略</h2><p id="226a" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated"><strong class="jm io">基于查找</strong>或也被称为<strong class="jm io">目录</strong>的方法使用查找表来识别给定数据库实体的正确碎片。这种策略的一个很好的用例是让基于租户的数据库由一个公共平台提供服务。随着租户被添加到平台或从平台移除，查找表被修改。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi mq"><img src="../Images/a8ec36dbf34d70fc7b4bfc683d79094f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nvb_9POYt4UjLBCTk39iKA.jpeg"/></div></div></figure><p id="e646" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是一种易于实现的方法，但是这种方法有一个额外的开销，即<strong class="jm io">分片查找步骤</strong>，这可能会影响端到端延迟。如果<strong class="jm io">共享租户</strong>在同一个分片中，建议保留一个额外的虚拟分片映射，以最小化<strong class="jm io">分片重新平衡</strong>的影响。</p><h2 id="49f6" class="lz kx in bd ky ma mb dn lc mc md dp lg jv me mf lk jz mg mh lo kd mi mj ls mk bi translated">哈希策略</h2><p id="6bd4" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">该策略使用基于哈希的函数，该函数采用客户属性，如<strong class="jm io">名称、客户端 IP、地理位置</strong> <strong class="jm io">等</strong>来评估最佳分片。它的主要目标是<strong class="jm io">将整个 TPS 均匀分布到 N 个碎片中，以实现资源的有效利用。</strong></p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi mq"><img src="../Images/7d63ae3ca2f8ec39f20d5d1923fa563c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rKavo1qSWUg7wCy3v60Uig.jpeg"/></div></div></figure><p id="fc28" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就像查找方法一样，它在哈希计算的额外网络开销以及重新平衡哈希问题上有局限性。然而，使用<a class="ae kj" href="https://www.toptal.com/big-data/consistent-hashing" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">一致散列</strong> </a> <strong class="jm io"> </strong>方案可以帮助克服后者的限制。</p><h1 id="f3e0" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">摘要</h1><p id="e7d6" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">分片提供了一种优化系统数据库设计方法，可以将分布式设计模式扩展到云产品的垂直限制之外。有效地结合基于邻近的地理碎片分布，它最大限度地减少了中断<strong class="jm io">爆炸半径和更好的延迟。</strong>大多数云产品如<strong class="jm io"> AWS、Azure </strong> <strong class="jm io">等</strong>都使用分片作为核心原则来构建其多区域原生数据库解决方案，如<a class="ae kj" href="https://aws.amazon.com/rds/aurora/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> AWS Aurora </strong> </a>、<a class="ae kj" href="https://azure.microsoft.com/en-in/services/cosmos-db/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io">Azure Cosmos</strong></a><strong class="jm io">等</strong>解决了工程团队管理多个节点的运营开销。</p><p id="5314" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本系列未来的高级博客中，我们将深入探讨一种云原生数据库架构。</p><p id="a87c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">如需反馈，请留言至</em><strong class="jm io"><em class="ki">Amit[dot]894[at]Gmail[dot]com</em></strong><em class="ki">或联系</em><a class="ae kj" href="https://about.me/amit_raj" rel="noopener ugc nofollow" target="_blank"><em class="ki">https://about.me/amit_raj</em></a><em class="ki">的任何链接。</em></p></div></div>    
</body>
</html>