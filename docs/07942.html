<html>
<head>
<title>Optimizing Web Vitals with NextJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 NextJS 优化 Web 生命周期</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/optimizing-web-vitals-with-nextjs-f503aaded741?source=collection_archive---------3-----------------------#2022-05-05">https://blog.devgenius.io/optimizing-web-vitals-with-nextjs-f503aaded741?source=collection_archive---------3-----------------------#2022-05-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="7ece" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">根据<a class="ae ki" href="https://pagespeed.web.dev/" rel="noopener ugc nofollow" target="_blank"> pagespeed.web.dev </a>的说法，使用 NextJs 可以很容易地获得高达 95 的性能。一般来说，没有人急于得分超过 90，因为没有人知道 90 和 100 之间是否有区别，我想包括谷歌自己。但是如果你需要尽可能接近 100，那么你应该考虑另一个框架——我的建议是 NuxtJS (Vue.js)。</p><p id="a7d7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">结果:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi kj"><img src="../Images/9903ee0197c552ff03b3bc6cb5d37925.png" data-original-src="https://miro.medium.com/v2/resize:fit:508/format:webp/1*cIgahO5qB_LvEmSzvZlXWQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图 1 —使用 NextJS 时根据页面速度的性能</figcaption></figure><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi kv"><img src="../Images/82b396ccab0cd3f0223f67b6eb85c0df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jIp1Z89TglGTBo4FBAKJ3g.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图 2 —根据页面速度和 NuxtJS 的性能</figcaption></figure><p id="3a59" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我做了下面的改进后，所有的都是为了改进 js 事件循环，你不能用 NextJS 做得足够有效，只要在初始渲染时有丢帧，你就不能进一步改进。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi la"><img src="../Images/c688a4b34b11f8ac43e6d71a6877e965.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3ZongOnbPPhLtsXt.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图 Chrome DevTools 中的 NextJS 任务性能记录</figcaption></figure><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi lb"><img src="../Images/94cdd7e4ef2f19d0a3a4fe51242e643b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9wbOsYxGGTQORjgD.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图 Chrome DevTools 中的 NuxtJS 任务性能记录</figcaption></figure><p id="ef9a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是为什么我认为这不是一个错误:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi lc"><img src="../Images/389430ae8ee07a0e12444d4bd6eb38a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ev18XVY73yhijWTI.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图 5 —根据 NextJS 网站的页面速度的性能</figcaption></figure><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi ld"><img src="../Images/859ef2890e30d24053672490a085f8b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2aK7xU7he_xwi0Qt.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图 6 —根据 NuxtJS 网站的页面速度的性能</figcaption></figure><p id="20c1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">重要的是要注意上面各组之间名字的显著性差异，以及谁更需要 seo，但我认为 replit 和 vercel 自己知道他们在做什么。</p><p id="eaf5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">期望得到纠正后，我们将继续学习如何提高 seo 性能的技巧。</p><h1 id="9ad6" class="le lf in bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">如何测试</h1><ol class=""><li id="04ae" class="mc md in jm b jn me jr mf jv mg jz mh kd mi kh mj mk ml mm bi translated">移动外形更为重要，应该成为关注的焦点。桌面将会不断改进。上面所有的截图都是在移动设备上制作的。</li><li id="3b6a" class="mc md in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated"><a class="ae ki" href="https://pagespeed.web.dev/" rel="noopener ugc nofollow" target="_blank"> Pagespeed </a>对你网站的表现有最终决定权。在下面的所有改进之后，你应该验证它们在 pagespeed 上有多大帮助。本节中的所有工具只对本地开发有帮助。</li><li id="83f4" class="mc md in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated"><a class="ae ki" href="https://www.npmjs.com/package/lighthouse" rel="noopener ugc nofollow" target="_blank">灯塔</a>是用于本地测试的很棒的 npm 包。比 DevTools 里的 lighthouse 稳定多了。</li><li id="28d7" class="mc md in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated">DevTools 中的 Lighthouse 应该只在隐姓埋名模式下使用，这样会删除一些统计数据。如果仍然有可以匿名访问的扩展，你应该关闭它们，因为它们会在渲染、加载外部数据等过程中扰乱帧。</li><li id="d0d2" class="mc md in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated">即使你用缓存清除重新加载页面，chrome 仍然会缓存一些数据，这会扭曲结果。因为它我决定用火狐。</li><li id="e8e9" class="mc md in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated">如果在浏览器中使用 lighthouse 进行测试，那么每次重新构建项目时，都应该创建新的浏览器选项卡。</li></ol><p id="f378" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">专业提示:如果组件看起来太重或未经优化，最好删除它并检查它，因为问题可能在其他地方。</p><h1 id="7fbd" class="le lf in bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">字体</h1><p id="6bae" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv ms jx jy jz mt kb kc kd mu kf kg kh ig bi translated">这是最关键的部分。</p><p id="801d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">小建议——提供网络字体的资源保留禁止对其网络字体进行任何修改的权利。我不记得 google-fonts 这样做了，因为我看到的所有 web 字体都有开源许可(你可以通过查看 web-fonts 页面上的许可标签来验证)。</p><ol class=""><li id="085b" class="mc md in jm b jn jo jr js jv mv jz mw kd mx kh mj mk ml mm bi translated">仔细检查设计师是否仍然需要字体，是否应该使用字体，因为过一段时间后，他们很容易忘记。也许它们只是旧了，或者更换它们很简单，因为移除它们就简化了 CLS 修复。</li><li id="5459" class="mc md in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated">使用字体子集减少所有剩余 web 字体中使用的字形数量。<a class="ae ki" href="https://www.fontsquirrel.com/tools/webfont-generator" rel="noopener ugc nofollow" target="_blank"> Fontsquirrel </a>为不同语言、字体粗细甚至单个字形的子集化字体提供了强大的功能。</li><li id="e20c" class="mc md in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated">仔细检查从谷歌字体下载的任何字体。所有提供的 css 文件链接到不同的系列和权重子集，但在大多数情况下，这些链接将是相同的，这意味着字体是一体化的。这不是魔术，因为这些字体的尺寸要大得多。这就是为什么最好自己创建子集。<br/>对于自定义网页字体，您可以使用 DevTools 快速检查字形编号:<em class="my">代码元素</em>-&gt;-<em class="my">元素</em> - &gt;在样式中选择<em class="my">计算出的</em> - &gt;在<em class="my">渲染字体</em>窗口底部将会得到字形编号。</li><li id="bd51" class="mc md in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated">Webfonts 应使用值 preload <code class="fe mz na nb nc b">&lt;link rel="preload"/&gt;</code>与 rel 属性链接。这将大大降低 CLS，但对技术性贸易壁垒几乎没有影响。</li><li id="e5aa" class="mc md in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated">通过 base64 字体移除所有字体链接，因为这将极大地增加 css 文件的大小，从而删除所有重要的字体。</li></ol><h1 id="790f" class="le lf in bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">导入和第三方脚本</h1><ol class=""><li id="88c1" class="mc md in jm b jn me jr mf jv mg jz mh kd mi kh mj mk ml mm bi translated">在从版本 11 开始的 NextJS 中，外部脚本应该只通过<a class="ae ki" href="https://nextjs.org/docs/basic-features/script" rel="noopener ugc nofollow" target="_blank"> next/script </a>链接(<code class="fe mz na nb nc b">plugin:@next/next/recommended</code> eslint 扩展可以帮助避免遗漏)。Doc 详细解释了一切，但总结起来:<br/> 1。Id 总是不同的<br/> 2。策略:<br/><strong class="jm io"/><code class="fe mz na nb nc b">beforeInteractive</code>—会话管理器、bot 检查等。<br/><strong class="jm io"/><code class="fe mz na nb nc b">afterInteractive</code>—标签管理器和分析<br/><strong class="jm io"/><code class="fe mz na nb nc b">lazyOnload</code>—聊天插件和其他小部件(不在<em class="my">_ 文档</em>中使用它们，因为它们不会出现，而是在<em class="my">_ 应用</em>中使用)<br/>注意:<br/><strong class="jm io"/>在撰写原始文章时，测试是在 NextJS 版本 11.1.2 上进行的，由于某些原因，第一次加载 JS 时会更大最后，我对每个脚本进行了测试，以决定是使用 next/script 还是 standard &lt; script/ &gt;(没有找到哪个更好的模式)。<br/><strong class="jm io"/>由于某种原因，无论使用什么策略，也无论是否指定了 defer 或 async，都无法加载多个脚本(例如来自 googletagmanager 的 gtag 脚本)。小心点。</li><li id="8c63" class="mc md in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated">任何脚本都应该使用属性 defer 而不是 async。</li></ol><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi nd"><img src="../Images/78968cfc697d26f7f0b120c354f006e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9HCZ2ijo1QkURpuA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图 7 —包括带有异步属性的脚本</figcaption></figure><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi ne"><img src="../Images/aad0b1781fe68efb366665b2ea5ae9d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*M9H-6Gvp74XICLd6.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图 8 —包括具有延迟属性的脚本</figcaption></figure><p id="e40a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.积极使用<a class="ae ki" href="https://nextjs.org/docs/advanced-features/dynamic-import" rel="noopener ugc nofollow" target="_blank"> next/dynamic </a>用于页面打开时不出现的组件(如下拉菜单、汉堡菜单、弹出菜单)。与<code class="fe mz na nb nc b">{ ssr: false }</code>选项一起使用。</p><h1 id="1c77" class="le lf in bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">形象</h1><p id="d360" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv ms jx jy jz mt kb kc kd mu kf kg kh ig bi translated">我应该推荐<a class="ae ki" href="https://nextjs.org/docs/api-reference/next/image" rel="noopener ugc nofollow" target="_blank"> next/image </a>，但我不会。在编写&lt;的时候，图像&gt;没有使用 className 属性，这使得样式非常困难。使用包装元素的解决方法非常糟糕，因为除了/image 创建的 6 个其他节点之外，它还创建了另一个 DOM 节点(4 div + 1 img + 1 noscript)。通常它不会有太大的影响，但是 lighthouse 敦促我们每页创建少于 250 个节点。</p><ol class=""><li id="66a2" class="mc md in jm b jn jo jr js jv mv jz mw kd mx kh mj mk ml mm bi translated">所有 img 标签必须指定相应的宽度和高度。</li><li id="8d4f" class="mc md in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated">第一屏渲染之外的所有图像都应该加载属性<code class="fe mz na nb nc b">loading="lazy"</code>。</li><li id="e312" class="mc md in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated">如果页面使用了大量的图标，那么它们应该通过 sprite 来使用——小图像被组合成大图像，然后通过背景图像和背景位置来使用。互联网上有很多这样的例子，但随之而来的是一个常见的问题——如何调整精灵图片的大小。可悲的是，没有 js 也没办法。下面是一个示例片段:</li></ol><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="61e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">4.每个图像都应该用 SVGOMG 或它的模拟来处理。结果偶尔会被打破，所以不要在没有测试的情况下使用。如果你使用大量的 svg 图片，那么第一次加载 js 可以节省 100kb 的空间。</p><p id="5d99" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">5.使用<a class="ae ki" href="https://www.npmjs.com/package/next-images" rel="noopener ugc nofollow" target="_blank">下一张图片</a>有两个原因。首先，你可以使用 webp 和其他现代格式，但是本地支持是有缺陷的。其次，它会在适当的时候自动将图像转换为 base64 格式。bas64 中的图像大大提高了加载速度，因为对它们没有额外的请求。但是，不要自己转换所有图像，因为每个图像都有其大小阈值，当 base64 字符串实际上比图像本身更大时，整个页面的加载速度会下降。这个包省了很多麻烦。</p><pre class="kk kl km kn gt nh nc ni nj aw nk bi"><span id="b9d3" class="nl lf in nc b gy nm nn l no np">const withImages = require(‘next-images’)<br/>module.exports = withImages({<br/> // … then standard next.config.js<br/>})</span></pre><h1 id="8b93" class="le lf in bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">库和包</h1><p id="518c" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv ms jx jy jz mt kb kc kd mu kf kg kh ig bi translated">检查每个包裹的尺寸很重要。也许它有 30kb 大，但只有一小部分被使用，可以在 5 秒内重写，就像我用 swiper.js 一样。</p><ol class=""><li id="ead5" class="mc md in jm b jn jo jr js jv mv jz mw kd mx kh mj mk ml mm bi translated">使用<a class="ae ki" href="https://bundlephobia.com/" rel="noopener ugc nofollow" target="_blank"> bundlephobia </a>检查包裹尺寸。也许我在这里有点极端，但是每个 kb 都很重要，将包大小和第一次加载 js 减少 10kb 可以使性能提高 5 个百分点。</li><li id="4602" class="mc md in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated">仔细检查包装是否使用正确。在<a class="ae ki" href="https://github.com/vercel/next.js/tree/canary/examples" rel="noopener ugc nofollow" target="_blank"> NextJS github </a>上有如何使用像<a class="ae ki" href="https://github.com/vercel/next.js/tree/canary/examples/with-mobx-react-lite" rel="noopener ugc nofollow" target="_blank"> mobx </a>或者<a class="ae ki" href="https://github.com/vercel/next.js/tree/canary/examples/with-redux" rel="noopener ugc nofollow" target="_blank"> redux </a>这样的热门包的例子。</li></ol><h1 id="2fb8" class="le lf in bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">应用程序接口</h1><p id="b3e9" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv ms jx jy jz mt kb kc kd mu kf kg kh ig bi translated"><em class="my">这不会直接影响性能，但为什么不在这里改进呢。</em></p><p id="07ab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所有请求都应该使用压缩。</p><p id="22ad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在像 cloudflare 这样的 PaaS 上，您可以通过一个复选标记来启用压缩。或者使用类似 nginx 的反向代理来启用它。这将减少执行代码的数量，从而加快响应速度，缩短交互时间。</p><p id="899f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要通过代码进行压缩，您可以使用中间件，如用于 koa 的<a class="ae ki" href="https://www.npmjs.com/package/koa-compress" rel="noopener ugc nofollow" target="_blank"> koa-compress </a>或用于 Nest.js 的<a class="ae ki" href="https://docs.nestjs.com/techniques/compression" rel="noopener ugc nofollow" target="_blank">压缩模块</a>。最后一个注意到，对于高流量，压缩应该转移到反向代理:</p><blockquote class="nq nr ns"><p id="adbc" class="jk jl my jm b jn jo jp jq jr js jt ju nt jw jx jy nu ka kb kc nv ke kf kg kh ig bi translated">对于生产中的<strong class="jm io">高流量</strong>网站，强烈建议从应用服务器卸载压缩</p></blockquote><p id="01e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">尽管如前所述，压缩不应该通过代码来完成，但我决定找出 100 个请求的平均值。也许我得到这样的测试结果是因为请求的有效负载很小，但无论如何也不应该很大。</p><pre class="kk kl km kn gt nh nc ni nj aw nk bi"><span id="3fad" class="nl lf in nc b gy nm nn l no np">Nginx + middlewares: 353.61ms</span><span id="aaea" class="nl lf in nc b gy nw nn l no np">Nginx without middlewares: 370.54ms</span><span id="056b" class="nl lf in nc b gy nw nn l no np">Middlewares without Nginx: 433.11ms</span><span id="658a" class="nl lf in nc b gy nw nn l no np">None: 10.5s</span></pre><p id="563f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以目前我决定同时使用这两种方法，但也许未来会教我其他方法。</p><h1 id="42a6" class="le lf in bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">常规优化技巧</h1><ol class=""><li id="4ef6" class="mc md in jm b jn me jr mf jv mg jz mh kd mi kh mj mk ml mm bi translated">别忘了<code class="fe mz na nb nc b">requestAnimationFrame</code>。如果每一帧都要渲染一些东西，那么必须用这个函数来完成，因为它有助于事件循环在帧之间分配工作。</li><li id="fe68" class="mc md in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated"><code class="fe mz na nb nc b">scroll</code>和所有<code class="fe mz na nb nc b">touch</code>事件的处理程序必须添加<code class="fe mz na nb nc b">{ passive: true }</code>选项，因为它优化滚动。</li></ol><pre class="kk kl km kn gt nh nc ni nj aw nk bi"><span id="3f13" class="nl lf in nc b gy nm nn l no np">useEffect(() =&gt; {<br/>  window.addEventListener('scroll', () =&gt; {}, { passive: true })</span><span id="69f0" class="nl lf in nc b gy nw nn l no np">  return () =&gt; {<br/>    window.removeEventListener('scroll', () =&gt; {})<br/>  }<br/>}, [])</span></pre><p id="f798" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.仔细检查您对 api 的请求是否不应该通过批处理操作来实现。</p><p id="0cf2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">4.所有 mount useEffect(那些没有依赖关系的)都必须返回清理函数，以清除所有超时和间隔，删除所有事件侦听器，并禁止在异步函数中更改状态。如果不清理，这些元素只会导致错误或过度渲染。</p><pre class="kk kl km kn gt nh nc ni nj aw nk bi"><span id="cb23" class="nl lf in nc b gy nm nn l no np">const [response, setResponse] = useState()</span><span id="a777" class="nl lf in nc b gy nw nn l no np">useEffect(() =&gt; { <br/>  window.addEventListener('scroll', () =&gt; {}, { passive: true }) // remember paragraph 2</span><span id="3bf3" class="nl lf in nc b gy nw nn l no np">  return () =&gt; {<br/>    window.removeEventListener('scroll', () =&gt; {})<br/>  }<br/>}, [])</span></pre><p id="9f5b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">5.<a class="ae ki" href="https://nextjs.org/docs/api-reference/next/link" rel="noopener ugc nofollow" target="_blank">下一个/链接</a>必须与<code class="fe mz na nb nc b">prefetch={false}</code>一起使用。有了良好的优化，它们无论如何都会加载得很快，但是如果没有预取，它们不会引起额外的请求，这会减慢当前页面的渲染速度。</p><p id="d1f6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">6.<a class="ae ki" href="https://developer.mozilla.org/ru/docs/Web/API/Web_Workers_API/Using_web_workers" rel="noopener ugc nofollow" target="_blank">网络工作者</a>非常适合硬同步计算。复杂计算的例子是<code class="fe mz na nb nc b">for (let i = 0; i &lt; 10_000_000; i++) {}</code>。考虑到没有人实现空循环，导致阻塞的迭代次数将会显著减少，如果每帧都进行这些计算，那么即使 1000 次也太多了。<br/>这样的操作会阻塞 ui 渲染，总阻塞时间增长很快。<strong class="jm io">然而</strong>，如果所有的代码都是对 100 个元素的小数组进行排序和过滤，那么用户不会感觉到这些冻结，你需要解决的只是总阻塞时间，这可以通过将函数转换为<a class="ae ki" href="https://nodejs.org/en/docs/guides/blocking-vs-non-blocking/" rel="noopener ugc nofollow" target="_blank">非阻塞 i/o </a>来实现。</p><pre class="kk kl km kn gt nh nc ni nj aw nk bi"><span id="2df2" class="nl lf in nc b gy nm nn l no np">const isMounted = useRef(true)</span><span id="ae77" class="nl lf in nc b gy nw nn l no np">const [posts, setPosts] = useState([])</span><span id="58b5" class="nl lf in nc b gy nw nn l no np">useEffect(() =&gt; {<br/>  const formatPosts = async () =&gt; {<br/>    const newPosts = posts<br/>      .filter(el =&gt; el.is_visible)<br/>      .map(el =&gt; ({ ...el, page: 1 }))<br/>      .sort((a, b) =&gt; b.updated_at - a.updated_at)<br/>      .sort((a, b) =&gt; b.likes - a.likes)<br/>     // unoptimized solely for the example</span><span id="9765" class="nl lf in nc b gy nw nn l no np">    if (isMounted.current) { // prevents state mutation on unmounted components<br/>      setPosts(newPosts)<br/>    }<br/>  }</span><span id="c8fe" class="nl lf in nc b gy nw nn l no np">  void formatPosts()</span><span id="b912" class="nl lf in nc b gy nw nn l no np">  return () =&gt; {<br/>    isMounted.current = false<br/>   }<br/>}, [])</span></pre><h1 id="638e" class="le lf in bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">留下了什么</h1><ul class=""><li id="e6a3" class="mc md in jm b jn me jr mf jv mg jz mh kd mi kh nx mk ml mm bi translated">NextJS 允许您创建<a class="ae ki" href="https://nextjs.org/docs/advanced-features/custom-document" rel="noopener ugc nofollow" target="_blank">自定义 next/document </a>，这在理论上可以改善脚本的加载方式，但是:<br/>♀<strong class="jm io"/>我发现脚本根本不能改善性能。例如，<a class="ae ki" href="https://github.com/engineerapart/nextscript" rel="noopener ugc nofollow" target="_blank">这个</a><br/>♀<strong class="jm io"/>在引擎盖下接下来使用纯 react 来创建元素，这是更优化的方式</li><li id="f2bb" class="mc md in jm b jn mn jr mo jv mp jz mq kd mr kh nx mk ml mm bi translated">找到了一些<a class="ae ki" href="https://css-tricks.com/the-best-font-loading-strategies-and-how-to-execute-them/" rel="noopener ugc nofollow" target="_blank">超级优化的 css 加载脚本</a>但是没时间测试。</li></ul></div></div>    
</body>
</html>