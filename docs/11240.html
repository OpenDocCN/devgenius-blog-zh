<html>
<head>
<title>Context manager — Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">上下文管理器 Python</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/context-manager-python-d60c23e97a03?source=collection_archive---------5-----------------------#2022-12-27">https://blog.devgenius.io/context-manager-python-d60c23e97a03?source=collection_archive---------5-----------------------#2022-12-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/f2d47cc8aed64d78c78d5d3e8bd88b53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jm--LNpswHxbKT-qFTK9tw.jpeg"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">照片由<a class="ae ja" href="https://unsplash.com/@ajonesyyyyy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">亚伦·琼斯</a>在<a class="ae ja" href="https://unsplash.com/photos/i2MYu4AElsE?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><div class=""/><p id="d9e6" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">python 上下文管理器简介</p><p id="cf02" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在任何编程语言中，资源处理都很重要。我们需要沿着护栏清理使用过的资源。有时我们有一个如下的清单来确保这一点。</p><blockquote class="ky kz la"><p id="c682" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">打开→关闭<br/>锁→释放<br/>变化→复位<br/>设置→拆卸<br/>连接→断开<br/>启动→停止</p></blockquote><p id="a7d8" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Python 提供了上下文管理器来帮助我们。</p><p id="b052" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这篇博客中，我们将了解以下内容:</p><ul class=""><li id="b207" class="lf lg jd kc b kd ke kh ki kl lh kp li kt lj kx lk ll lm ln bi translated">with 语句的目的</li><li id="b8e5" class="lf lg jd kc b kd lo kh lp kl lq kp lr kt ls kx lk ll lm ln bi translated">为一个类/函数写一个上下文管理器。</li><li id="555f" class="lf lg jd kc b kd lo kh lp kl lq kp lr kt ls kx lk ll lm ln bi translated">异步处理上下文管理器</li></ul><h2 id="7928" class="lt lu jd bd lv lw lx dn ly lz ma dp mb kl mc md me kp mf mg mh kt mi mj mk ml bi translated">上下文管理器</h2><p id="cf15" class="pw-post-body-paragraph ka kb jd kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">上下文管理器是简化 Python 中资源管理的特性。上下文管理器定义临时运行时上下文。这些是干净简洁代码的语法糖。</p><h2 id="4070" class="lt lu jd bd lv lw lx dn ly lz ma dp mb kl mc md me kp mf mg mh kt mi mj mk ml bi translated"><code class="fe mr ms mt mu b">WITH</code>声明</h2><p id="e37c" class="pw-post-body-paragraph ka kb jd kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">当 python 遇到 WITH 语句时:</p><ul class=""><li id="c12e" class="lf lg jd kc b kd ke kh ki kl lh kp li kt lj kx lk ll lm ln bi translated">它调用对象的 __enter__ 方法</li><li id="ab6b" class="lf lg jd kc b kd lo kh lp kl lq kp lr kt ls kx lk ll lm ln bi translated">将 __enter__ 方法的返回分配给“AS”对象</li><li id="0d4b" class="lf lg jd kc b kd lo kh lp kl lq kp lr kt ls kx lk ll lm ln bi translated">执行代码块</li><li id="6cef" class="lf lg jd kc b kd lo kh lp kl lq kp lr kt ls kx lk ll lm ln bi translated">调用 exit 方法</li></ul><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="1261" class="lt lu jd mu b gy nd ne l nf ng">class CustomFiletManager:<br/>    def __init__(self, fileName, mode):<br/>        self.fileName = fileName<br/>        self.modeName = mode</span><span id="1b3d" class="lt lu jd mu b gy nh ne l nf ng">    def <strong class="mu je">__enter__</strong>(self):<br/>        self.file = open(self.fileName, self.mode)<br/>        return self.file    </span><span id="d014" class="lt lu jd mu b gy nh ne l nf ng">    def <strong class="mu je">__exit__</strong>(self,exc_type, exc_value, exc_traceback):<br/>        print(exc_type, exc_val, exc_traceback)<br/>        self.file.close()</span></pre><p id="352e" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mr ms mt mu b">__enter__</code>方法指定<code class="fe mr ms mt mu b">ContextManager</code>将以名称<code class="fe mr ms mt mu b">fileName</code>和模式<code class="fe mr ms mt mu b">mode</code>打开文件(读/写)。此方法的返回可用作 with 语句的“as”对象。</p><p id="7de0" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="lb">注意:我们甚至可以使用</em> <code class="fe mr ms mt mu b"><em class="lb">contextlib</em></code> <em class="lb">库中的上下文管理器来捕获打印语句。</em></p><p id="2c4a" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果出现异常，<code class="fe mr ms mt mu b">__exit__</code>方法使用<code class="fe mr ms mt mu b">close</code>方法关闭文件，并打印类型(<code class="fe mr ms mt mu b">exc_type</code>)、值(<code class="fe mr ms mt mu b">exc_value</code>)和回溯(<code class="fe mr ms mt mu b">exc_traceback</code>)。当对象超出范围时，调用此方法。</p><p id="8af4" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该自定义类对象可与<code class="fe mr ms mt mu b">with</code>一起使用，如下所示(由于上述 dunder 方法):</p><h2 id="400a" class="lt lu jd bd lv lw lx dn ly lz ma dp mb kl mc md me kp mf mg mh kt mi mj mk ml bi translated">向方法添加上下文</h2><p id="c5ab" class="pw-post-body-paragraph ka kb jd kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">Python 附带了一个名为<code class="fe mr ms mt mu b"><a class="ae ja" href="https://docs.python.org/3/library/contextlib.html" rel="noopener ugc nofollow" target="_blank">contextlib</a></code>的实用模块，它为我们提供了一个助手<code class="fe mr ms mt mu b">@contextmanager</code> decorator，让我们定义基于函数的上下文管理器。</p><pre class="mv mw mx my gt mz mu ni bn nj nk bi"><span id="f8e9" class="nl lu jd mu b be nm nn l no ng">from contextlib import contextmanager<br/>@contextmanager<br/>def my_cool_function(file_name):<br/>    try:<br/>        f = open(file_name, 'w')<br/>        yield f<br/>    finally:<br/>        f.close</span></pre><p id="1bf9" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意:必须有 yield 语句才能使其成为生成器。</p><ol class=""><li id="20db" class="lf lg jd kc b kd ke kh ki kl lh kp li kt lj kx np ll lm ln bi translated">在代码被<em class="lb">管理</em>之前，<code class="fe mr ms mt mu b">yield</code>上面的表达式被执行。</li><li id="f7da" class="lf lg jd kc b kd lo kh lp kl lq kp lr kt ls kx np ll lm ln bi translated">托管代码在<code class="fe mr ms mt mu b">yield</code>运行。无论产生什么，都构成了上下文变量——在我们的例子中是<code class="fe mr ms mt mu b">file object</code>。</li><li id="34a4" class="lf lg jd kc b kd lo kh lp kl lq kp lr kt ls kx np ll lm ln bi translated">在托管代码运行后，执行<code class="fe mr ms mt mu b">yield</code>下面的表达式。</li></ol><p id="3447" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的代码中，我们没有将<code class="fe mr ms mt mu b">yield f</code>放在 try…catch 块中。但这是强烈推荐的。如果在我们到达上下文管理器的退出处理程序之前发生任何错误，我们将拥有悬空对象/文件句柄/数据库连接。为了避免这种情况，我们应该将该语句放在错误处理代码下。</p><p id="ae5b" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">内置<code class="fe mr ms mt mu b">pathlib</code>模块中的上下文管理器示例</p><pre class="mv mw mx my gt mz mu ni bn nj nk bi"><span id="8b4d" class="nl lu jd mu b be nm nn l no ng">from pathlib import path<br/>import sys<br/><br/>src_path = Path(sys.argv[1])<br/>dest_path = Path(sys.argv[1] + '.output')<br/><br/>try:<br/>    with src_path.open() as src, dest_path.open(mode='x') as dest:<br/>        for line in src:<br/>            output = line.replace('o', '00')<br/>            dest.write(out)<br/>except OSError as error:<br/>    print("A file error occured")<br/></span></pre><p id="ebe0" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">线程模块的基本示例</p><pre class="mv mw mx my gt mz mu ni bn nj nk bi"><span id="b137" class="nl lu jd mu b be nm nn l no ng">import threading<br/><br/>balance_lock = threading.Lock()<br/><br/>with balance_lock:<br/>    # Do updates</span></pre><p id="5e40" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">异步调用中的上下文管理器示例</p><pre class="mv mw mx my gt mz mu ni bn nj nk bi"><span id="14af" class="nl lu jd mu b be nm nn l no ng">import asyncio<br/>import aiofiles<br/><br/>async def write_files():<br/>    async with aiofiles.open(filename, 'w') as f:<br/>        print(f"Opened file: {filename}.")<br/>        await f.write(f"Hello from the other side")<br/>        print(f"Finished writing to file: {filename}.")<br/><br/>async def main():<br/>    await asyncio.gather(<br/>        write_file("test1.txt"),<br/>        write_file("test2.txt"),<br/>    )<br/><br/><br/>asyncio.run(main())</span></pre><p id="8372" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">异步上下文管理器实现特殊的方法<code class="fe mr ms mt mu b">__aenter__</code>和<code class="fe mr ms mt mu b">__aexit__</code>，它们对应于常规上下文管理器中的<code class="fe mr ms mt mu b">__enter__()</code>和<code class="fe mr ms mt mu b">__exit__()</code>。</p><pre class="mv mw mx my gt mz mu ni bn nj nk bi"><span id="091b" class="nl lu jd mu b be nm nn l no ng">import aiohttp<br/>import asyncio<br/><br/>class AsyncSession:<br/>    def __init__(self, url):<br/>        self._url = url<br/><br/>    async def __aenter__(self):<br/>        self.session = aiohttp.ClientSession()<br/>        response = await self.session.get(self._url)<br/>        return response<br/><br/>    async def __aexit__(self, exc_type, exc_value, exc_tb):<br/>        await self.session.close()<br/><br/>async def check(url):<br/>    async with AsyncSession(url) as response:<br/>        print(f"{url}: status -&gt; {response.status}")<br/>        html = await response.text()<br/>        print(f"{url}: type -&gt; {html[:17].strip()}")<br/><br/>async def main():<br/>    await asyncio.gather(<br/>        check("https://realpython.com"),<br/>        check("https://pycoders.com"),<br/>    )<br/><br/>asyncio.run(main())</span></pre><p id="071a" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">带有 DB 连接的上下文管理器的另一个例子</p><pre class="mv mw mx my gt mz mu ni bn nj nk bi"><span id="4ff8" class="nl lu jd mu b be nm nn l no ng">import asyncio<br/>import logging<br/><br/>import aiosqlite<br/><br/><br/>async def main():<br/>    logging.basicConfig(level=logging.INFO)<br/>    async with aiosqlite.connect("application.db") as db:<br/>        async with db.execute("SELECT * FROM blogs") as cursor:<br/>            logging.info(await cursor.fetchall())<br/><br/>if __name__ == "__main__":<br/>    asyncio.run(main())</span></pre><p id="2551" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上下文管理器允许我们确保在运行代码时满足前置条件和后置条件。</p><p id="8cc5" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">参考:<a class="ae ja" href="https://realpython.com/python-with-statement/" rel="noopener ugc nofollow" target="_blank">https://realpython.com/python-with-statement/</a></p><p id="fe77" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">编码快乐！！</p></div></div>    
</body>
</html>