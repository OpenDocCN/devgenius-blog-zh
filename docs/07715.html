<html>
<head>
<title>What’s new in React 18?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React 18 有什么新功能？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/whats-new-in-react-18-3cbfdf83dc5a?source=collection_archive---------4-----------------------#2022-04-18">https://blog.devgenius.io/whats-new-in-react-18-3cbfdf83dc5a?source=collection_archive---------4-----------------------#2022-04-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="f542" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本快速指南中，您将了解 React latests 版本中最相关的可用功能。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d6bbe139ef39ace2acc7caf6d05acdc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zhjfr3A0UWFF3a6tzIQ8yg.png"/></div></div></figure><h1 id="ae23" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">索引</h1><ul class=""><li id="ac7a" class="ls lt in jm b jn lu jr lv jv lw jz lx kd ly kh lz ma mb mc bi translated">怎么升级？</li><li id="1003" class="ls lt in jm b jn md jr me jv mf jz mg kd mh kh lz ma mb mc bi translated">并发反应</li><li id="8680" class="ls lt in jm b jn md jr me jv mf jz mg kd mh kh lz ma mb mc bi translated">新功能</li><li id="f307" class="ls lt in jm b jn md jr me jv mf jz mg kd mh kh lz ma mb mc bi translated">结论</li></ul><h1 id="bb12" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">怎么升级？</h1><p id="2d22" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh ig bi translated">为了将您当前的 React 项目迁移到最新版本，您需要遵循以下步骤</p><ol class=""><li id="f846" class="ls lt in jm b jn jo jr js jv ml jz mm kd mn kh mo ma mb mc bi translated"><code class="fe mp mq mr ms b">npm install react react-dom</code>。</li><li id="36da" class="ls lt in jm b jn md jr me jv mf jz mg kd mh kh mo ma mb mc bi translated">更改 ReactDOM.render 方法</li></ol><p id="8e91" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，React 使用不同的 API 来呈现我们的应用程序。</p><p id="3df9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 React 17.0.0 中</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/f314f18dc0908a31c69156e229cc1f84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*YAZcQE5M6Xas4c-Ithw6KA.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">使用 ReactDOM.render 方法</figcaption></figure><p id="ee2b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从 React 18.0.0 开始</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi my"><img src="../Images/cc6daf0ead0fe040cfbe3b407bd0b83d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/1*LCtqlVi-VLOTtelrocb1yA.png"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">使用 ReactDOM.createRoot 方法</figcaption></figure><h1 id="e839" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">并发反应</h1><p id="fce0" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh ig bi translated">React 中的呈现引擎的工作方式类似于 JavaScript 中的异步。一旦更新开始渲染，没有什么可以阻止它，直到它完成。用户界面一次只能有一个变化。</p><p id="ca5f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，从 React 18 开始，情况就不完全是这样了。更新可以中途暂停，稍后继续。即使 React 也可以放弃正在进行的更新。这被称为<strong class="jm io">并发反应</strong>，这一特性带来了性能和 UX 方面的许多改进。我们将在本文中讨论的改进。</p><h1 id="9cec" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">新功能</h1><h2 id="753a" class="mz kv in bd kw na nb dn la nc nd dp le jv ne nf li jz ng nh lm kd ni nj lq nk bi translated">自动配料</h2><p id="cee4" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh ig bi translated">一些复杂的组件中有多个“使用状态”挂钩是很常见的。在有不止一个<strong class="jm io"> set </strong>语句的处理程序中结束，就像这样。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/c401a449339a4a3d96a05f8850e9f43a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1058/format:webp/1*GLleMCAhWUZSo8Vunw1Xkg.png"/></div></figure><p id="522a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一个处理程序中的几个<strong class="jm io"> set </strong>语句称为一个<em class="nm">批处理</em>。问题是上面的组件将被重新渲染两次。一次在<code class="fe mp mq mr ms b">setLoading</code>，另一次在<code class="fe mp mq mr ms b">setInput</code>。</p><p id="4096" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从 18 版本开始，React 了解何时有一个<em class="nm">批次</em>，并执行所有的<strong class="jm io"> set </strong>语句，以便以后只重新渲染组件一次。</p><p id="701e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">主要优点是:这是自动发生的，我们不需要做任何事情。最后，性能显著提高。</p><h2 id="e7a2" class="mz kv in bd kw na nb dn la nc nd dp le jv ne nf li jz ng nh lm kd ni nj lq nk bi translated">过渡</h2><p id="00f0" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh ig bi translated">转变是指状态的变化。例如，从<code class="fe mp mq mr ms b">loading=true</code>到<code class="fe mp mq mr ms b">loading=false</code>的过渡。</p><p id="b89d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，在处理 UI 时，有些转换比其他转换更重要。</p><p id="1dca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，在一个搜索栏中，每次你输入的时候，都会有一个关于你输入内容的视觉反馈，但同时，有一个进程在后台运行，试图从用户输入中找出一些匹配。</p><p id="b394" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在最坏的情况下，由于其他进程同时运行，视觉反馈变得更慢，最终导致糟糕的用户体验。在这种特殊情况下，搜索过程没有视觉反馈重要。</p><p id="002f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是<code class="fe mp mq mr ms b">startTransition</code>发挥作用的地方。一个新特性，当状态变化不紧急时，告诉显式地作出反应。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/60f6a8b13c78dc2827edfeea8a7cef82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*02ct7T-O5pgR5xlM_oDijw.png"/></div></div></figure><p id="2a5c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所有封装在<code class="fe mp mq mr ms b">startTransition</code>中的转换都处于较低的优先级，因此可以暂停，以优先考虑该功能之外的转换。只要他们同时表演。</p><h2 id="9e4a" class="mz kv in bd kw na nb dn la nc nd dp le jv ne nf li jz ng nh lm kd ni nj lq nk bi translated">服务器上的悬念</h2><p id="2408" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh ig bi translated">在解释服务器特性的<em class="nm">悬念意味着什么之前，让我们快速回顾一下客户端和服务器端渲染的区别。</em></p><p id="9727" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一个基于客户端的应用程序将从服务器加载 html 以及使我们的应用程序交互所需的所有 JavaScript。如果我们的 app 是一个简单的“hello world”，就足够快了。然而，通常我们的应用程序是巨大的，这个过程可能需要一段时间，最终导致糟糕的用户体验。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/acd697fe56c4b08be11c0fc84ce4d40c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WcVUPV9kMbPrP0fu.png"/></div></div></figure><p id="b6e7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">基于服务器端的应用部分解决了这个问题。因为你从服务器获得 HTML，准备好显示在屏幕上，JavaScript 代码被加载，使我们的应用程序交互。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/b5422b3db31e0c02d9e1a543239c90da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*b_7sTn2hSreMXLLF.jpeg"/></div></div></figure><p id="ad57" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">主要的优势是我们的用户界面在较短的时间内是空白的，这极大地改善了用户体验。</p></div><div class="ab cl nq nr hr ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ig ih ii ij ik"><p id="43a3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，想象你正处于<em class="nm"> Load JS </em>阶段。你需要 3 个 API 来丰富你的用户界面。其中两个返回数据非常快，但最后一个需要太长时间才能解决。最后一个 API 延迟了整个页面。</p><p id="0c23" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以将这个场景想象为 Promise.all API。当所有的承诺都被解决时，就是它返回数据的时候。这就是它的工作原理。</p><p id="a45e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，让我们想象慢速 API 负责在我们的应用程序中加载评论。在 React 18 之前，我们会等到所有这些 API 都解决了，但是有了悬念，我们现在可以包装组件以避免瓶颈，并且我们可以选择传递一个加载器作为后备。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/f92f8952868fa7730205aede0354262a.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*dM-HABEKIRENznSXHBlSKA.png"/></div></figure><p id="2889" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过这种方式，用户可以在注释(在本例中)等待解决时看到所有其他数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/2e6bd64e83b901976754e88dd399ed96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0-HAp-f6WlVePZF2.png"/></div></div></figure><h1 id="d088" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结论</h1><p id="a541" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh ig bi translated">React 18 为即将到来的版本和专注于用户体验和性能的功能奠定了基础。</p><p id="b255" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，您必须开始在您的实际项目中实现它。它应该不会超过一个晚上，你会开始抓住这个主要版本的所有新的好处。</p></div></div>    
</body>
</html>