<html>
<head>
<title>Asking to know basic about HTTP Cache</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">询问 HTTP 缓存的基本知识</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/asking-to-know-basic-about-http-cache-9c151a932709?source=collection_archive---------36-----------------------#2020-07-02">https://blog.devgenius.io/asking-to-know-basic-about-http-cache-9c151a932709?source=collection_archive---------36-----------------------#2020-07-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/3d688cee80c715100e2b2d33a58d6a9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fvlMpkpIKmPm6IF_QnmjmQ.jpeg"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">(图片来自互联网)</figcaption></figure><div class=""/><blockquote class="jz"><p id="87b1" class="ka kb jc bd kc kd ke kf kg kh ki kj dk translated"><strong class="ak"> <em class="kk">最快的 HTTP 请求是没有发出的请求。</em> </strong> <em class="kk"> </em> <strong class="ak"> <em class="kk"> _ 未知</em> </strong></p></blockquote><p id="da08" class="pw-post-body-paragraph kl km jc kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh kj ig bi translated">今天，我们通过一些问题来了解一下<strong class="kn jd"> HTTP 缓存——最快 HTTP 请求的关键</strong></p><h1 id="78a6" class="li lj jc bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">什么是缓存？</h1><blockquote class="jz"><p id="e803" class="ka kb jc bd kc kd mg mh mi mj mk kj dk translated"><em class="kk">缓存是一种技术，它存储给定资源的副本，并在 MDN 请求时返回给定资源</em></p></blockquote><h1 id="1313" class="li lj jc bd lk ll lm ln lo lp lq lr ls lt ml lv lw lx mm lz ma mb mn md me mf bi translated">什么是缓存概念？​</h1><figure class="mo mp mq mr gt ip"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">基本缓存概念</figcaption></figure><h1 id="18d2" class="li lj jc bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">什么是 HTTP 缓存？</h1><p id="4e40" class="pw-post-body-paragraph kl km jc kn b ko mu kq kr ks mv ku kv kw mw ky kz la mx lc ld le my lg lh kj ig bi translated">HTTP 缓存是缓存应用于 HTTP 协议(HTTP/1.1，HTTP/1.2)的方式</p><h1 id="036e" class="li lj jc bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">我们为什么要缓存？</h1><p id="ad62" class="pw-post-body-paragraph kl km jc kn b ko mu kq kr ks mv ku kv kw mw ky kz la mx lc ld le my lg lh kj ig bi translated">因为我们都喜欢快速网站，缓存是提高性能的英雄</p><h1 id="f9ed" class="li lj jc bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">HTTP 缓存中的基本缓存机制是什么？</h1><p id="777e" class="pw-post-body-paragraph kl km jc kn b ko mu kq kr ks mv ku kv kw mw ky kz la mx lc ld le my lg lh kj ig bi translated">基本的缓存机制确保每个服务器响应提供正确的<strong class="kn jd"> HTTP 头指令(Cache-Control) </strong>来指示浏览器何时缓存响应以及缓存多长时间</p><h1 id="4485" class="li lj jc bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">HTTP 缓存有几种？</h1><p id="53d6" class="pw-post-body-paragraph kl km jc kn b ko mu kq kr ks mv ku kv kw mw ky kz la mx lc ld le my lg lh kj ig bi translated">有 3 种 HTTP 缓存:</p><p id="c526" class="pw-post-body-paragraph kl km jc kn b ko mz kq kr ks na ku kv kw nb ky kz la nc lc ld le nd lg lh kj ig bi translated">♠没有缓存</p><p id="86b6" class="pw-post-body-paragraph kl km jc kn b ko mz kq kr ks na ku kv kw nb ky kz la nc lc ld le nd lg lh kj ig bi translated">♠共享缓存</p><p id="f5f6" class="pw-post-body-paragraph kl km jc kn b ko mz kq kr ks na ku kv kw nb ky kz la nc lc ld le nd lg lh kj ig bi translated">♠本地(私有)缓存</p><h1 id="17a8" class="li lj jc bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">有多少种高速缓存请求指令？​</h1><p id="b68d" class="pw-post-body-paragraph kl km jc kn b ko mu kq kr ks mv ku kv kw mw ky kz la mx lc ld le my lg lh kj ig bi translated">有许多种高速缓存请求指令。基于使用，有 2 组使用它们“由客户端在 HTTP 请求中使用”和“由服务器在 HTTP 响应中使用”</p><p id="94dc" class="pw-post-body-paragraph kl km jc kn b ko mz kq kr ks na ku kv kw nb ky kz la nc lc ld le nd lg lh kj ig bi translated"><strong class="kn jd">使用两个组</strong>:无缓存、无存储、最大年龄、无转换</p><p id="f782" class="pw-post-body-paragraph kl km jc kn b ko mz kq kr ks na ku kv kw nb ky kz la nc lc ld le nd lg lh kj ig bi translated"><strong class="kn jd">客户端— HTTP 请求</strong>:最大陈旧、最小新鲜、仅在缓存时</p><p id="d24a" class="pw-post-body-paragraph kl km jc kn b ko mz kq kr ks na ku kv kw nb ky kz la nc lc ld le nd lg lh kj ig bi translated"><strong class="kn jd">服务器端— HTTP 响应:</strong>公共、私有、必须重新验证、代理重新验证、x 管理</p><p id="6f61" class="pw-post-body-paragraph kl km jc kn b ko mz kq kr ks na ku kv kw nb ky kz la nc lc ld le nd lg lh kj ig bi translated">下图向我们展示了选择请求指令的方法:</p><figure class="mo mp mq mr gt ip gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/b663e73b22289d2dcd8acb44a9b1ef7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/0*QfCtxQ3Wv6NS9Okp.png"/></div></figure><h1 id="df5c" class="li lj jc bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">如何两全其美:客户端缓存和快速更新？​</h1><p id="0309" class="pw-post-body-paragraph kl km jc kn b ko mu kq kr ks mv ku kv kw mw ky kz la mx lc ld le my lg lh kj ig bi translated">最佳实践是对 html 文件不缓存，对 css、js 文件使用唯一的 URL</p><figure class="mo mp mq mr gt ip gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/659cfa6d6ec40a214adc7f96b90d0c30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/0*HEgjThaqvBGl11tH.png"/></div></figure><p id="4513" class="pw-post-body-paragraph kl km jc kn b ko mz kq kr ks na ku kv kw nb ky kz la nc lc ld le nd lg lh kj ig bi translated">请查看客户端缓存和按需更新如何:</p><figure class="mo mp mq mr gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi ng"><img src="../Images/d3c779938f0d664b3ea940ff2ccc4c6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CGGK6GjSxHtOb2xr.png"/></div></div></figure><h1 id="ee1b" class="li lj jc bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">HTTP 缓存处理的“高超三重奏”是什么？​</h1><p id="7958" class="pw-post-body-paragraph kl km jc kn b ko mu kq kr ks mv ku kv kw mw ky kz la mx lc ld le my lg lh kj ig bi translated"><strong class="kn jd"> ETag </strong> + <strong class="kn jd">缓存控制</strong> + <strong class="kn jd">唯一 URL</strong>帮助我们提供最好的服务:</p><p id="ddd9" class="pw-post-body-paragraph kl km jc kn b ko mz kq kr ks na ku kv kw nb ky kz la nc lc ld le nd lg lh kj ig bi translated">过期时间长久</p><p id="b8f8" class="pw-post-body-paragraph kl km jc kn b ko mz kq kr ks na ku kv kw nb ky kz la nc lc ld le nd lg lh kj ig bi translated">控制可缓存响应的位置</p><p id="5116" class="pw-post-body-paragraph kl km jc kn b ko mz kq kr ks na ku kv kw nb ky kz la nc lc ld le nd lg lh kj ig bi translated">按需更新</p><h1 id="7036" class="li lj jc bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">如何定义目标应该使用特定的缓存？​</h1><p id="fc42" class="pw-post-body-paragraph kl km jc kn b ko mu kq kr ks mv ku kv kw mw ky kz la mx lc ld le my lg lh kj ig bi translated">(例如:桌面用户缓存不应应用于移动用户)</p><p id="e555" class="pw-post-body-paragraph kl km jc kn b ko mz kq kr ks na ku kv kw nb ky kz la nc lc ld le nd lg lh kj ig bi translated">我们可以根据不同的请求头(<strong class="kn jd">变</strong>)定义不同的内容，如<strong class="kn jd"><em class="nh">cookie、语言、用户代理</em> </strong></p><h1 id="0e89" class="li lj jc bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">缓存策略怎么样？</h1><p id="89df" class="pw-post-body-paragraph kl km jc kn b ko mu kq kr ks mv ku kv kw mw ky kz la mx lc ld le my lg lh kj ig bi translated">没有最好的缓存策略，这取决于您的应用程序(需求、流量、数据……)您必须定义和配置您的预源设置和您的“缓存层次结构”</p><p id="733d" class="pw-post-body-paragraph kl km jc kn b ko mz kq kr ks na ku kv kw nb ky kz la nc lc ld le nd lg lh kj ig bi translated">在处理缓存时，有一些提示和检查列表:</p><p id="0aa8" class="pw-post-body-paragraph kl km jc kn b ko mz kq kr ks na ku kv kw nb ky kz la nc lc ld le nd lg lh kj ig bi translated">使用一致的 URL</p><p id="6944" class="pw-post-body-paragraph kl km jc kn b ko mz kq kr ks na ku kv kw nb ky kz la nc lc ld le nd lg lh kj ig bi translated">确保服务器提供验证令牌(ETag)</p><p id="8adf" class="pw-post-body-paragraph kl km jc kn b ko mz kq kr ks na ku kv kw nb ky kz la nc lc ld le nd lg lh kj ig bi translated">确定哪个资源应该缓存中介</p><p id="6063" class="pw-post-body-paragraph kl km jc kn b ko mz kq kr ks na ku kv kw nb ky kz la nc lc ld le nd lg lh kj ig bi translated">确定每个资源的缓存寿命</p><p id="4f64" class="pw-post-body-paragraph kl km jc kn b ko mz kq kr ks na ku kv kw nb ky kz la nc lc ld le nd lg lh kj ig bi translated">确定缓存层次结构</p><p id="bb23" class="pw-post-body-paragraph kl km jc kn b ko mz kq kr ks na ku kv kw nb ky kz la nc lc ld le nd lg lh kj ig bi translated">通过单独的资源最大限度地减少流失</p><p id="4f91" class="pw-post-body-paragraph kl km jc kn b ko mz kq kr ks na ku kv kw nb ky kz la nc lc ld le nd lg lh kj ig bi translated">我们只是绕过一些关于 HTTP 缓存的基本问题。如果你对此有更多的问题，请发表评论</p><p id="1af4" class="pw-post-body-paragraph kl km jc kn b ko mz kq kr ks na ku kv kw nb ky kz la nc lc ld le nd lg lh kj ig bi translated">一些参考链接:</p><p id="836a" class="pw-post-body-paragraph kl km jc kn b ko mz kq kr ks na ku kv kw nb ky kz la nc lc ld le nd lg lh kj ig bi translated">–<a class="ae ni" href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching" rel="noopener ugc nofollow" target="_blank">【Google Dev Doc】HTTP 缓存</a></p><p id="9dca" class="pw-post-body-paragraph kl km jc kn b ko mz kq kr ks na ku kv kw nb ky kz la nc lc ld le nd lg lh kj ig bi translated">–<a class="ae ni" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching" rel="noopener ugc nofollow" target="_blank">【MDN web docs】HTTP 缓存</a></p></div></div>    
</body>
</html>