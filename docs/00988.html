<html>
<head>
<title>Building lightweight single page apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建轻量级单页面应用程序</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/building-lightweight-single-page-apps-6e85925248d5?source=collection_archive---------20-----------------------#2020-06-21">https://blog.devgenius.io/building-lightweight-single-page-apps-6e85925248d5?source=collection_archive---------20-----------------------#2020-06-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="c9e6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我最近的项目是构建一个单页面应用程序。在这篇文章中，我将分享我的策略和一些建议。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/45066fc33bcfb4d83afabf67d8b3882b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GxYFl_b08HepDXtuHx9atg.jpeg"/></div></div></figure><p id="df48" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Codr并不是从一个单页面应用程序开始的。每一页实际上，就像任何其他常规网站一样，只是另一页。但是在速度测试和优化离线使用后，我不得不调整我的策略。我必须将单个页面转换成一个单页应用程序；使它更快，更友好，消耗更少的带宽和存储。</p><p id="3830" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在单页应用中，每次导航不需要完全刷新/重新加载网站；相反，只需要加载页面的一小部分并显示给用户。有许多现有的包可以帮你做到这一点(jquery routing、Vue、Reach等等)。但我更喜欢保持简单轻便。下面是我如何使用普通JavaScript &amp; jQuery实现的。</p><p id="28ba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> spa.js </strong></p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="8ca6" class="kz la in kv b gy lb lc l ld le">$(window).on('hashchange', function(e) {<br/>    codrRouter();<br/>});</span><span id="5d59" class="kz la in kv b gy lf lc l ld le">function codrRouter() {<br/>  try {<br/>      codrRouter_impl()<br/>  } catch (err) {<br/>      console.error(err)<br/>      $.get('./views/500.html', function(pageContent) {<br/>          $('.content').html(pageContent);<br/>      }).fail(failedGet)<br/>  }<br/>}</span></pre><p id="6873" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们定义了一个页面路由器(codrRouter ),它将成为SPA内导航的主干。注意，我们使用“hashchange”事件来触发导航。这意味着我们所有的页面都由URL中的#hashtag标识符来标识。</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="04c8" class="kz la in kv b gy lb lc l ld le">function codrRouter_impl() {<br/>  var page = window.location.hash;</span><span id="43c4" class="kz la in kv b gy lf lc l ld le">  if (page === '#' || page === '') {</span><span id="a26a" class="kz la in kv b gy lf lc l ld le">    $.get('./views/home.html', function(pageContent) {<br/>      $('.content').html(pageContent);<br/>    }).fail(failedGet)</span><span id="d7ff" class="kz la in kv b gy lf lc l ld le">  } else if (page === '#challenges') {</span><span id="eb8d" class="kz la in kv b gy lf lc l ld le">    $.get('./views/challenges_levels.html', function(pageContent) {<br/>      $('.content').html(pageContent);<br/>    }).fail(failedGet)</span><span id="1736" class="kz la in kv b gy lf lc l ld le">  } else {</span><span id="d1f3" class="kz la in kv b gy lf lc l ld le">    $.get('./views/404.html', function(pageContent) {<br/>      $('.content').html(pageContent);<br/>    }).fail(failedGet)</span><span id="f541" class="kz la in kv b gy lf lc l ld le">  }<br/>}</span><span id="106c" class="kz la in kv b gy lf lc l ld le">function failedGet() {<br/>  const refresh = '&lt;a class="refreshpage" href="."&gt;refresh page&lt;/a&gt;'<br/>  $('.content').html('Oops, make sure you are online.&lt;br&gt;' + refresh);<br/>}</span></pre><p id="ed70" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们实现路由器和可能的路由。正如您所看到的，每个匹配的路由都发出一个GET请求来获取一些html内容。此内容只是部分的，它将取代我们的现有代码”。内容”元素，它只是一个占位符。最后一步是确保所有的a-href链接都是hashtags/anchors。</p><p id="c39a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您还可以通过简单地触发hashchange事件，以编程方式将用户导航到不同的页面:</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="91d1" class="kz la in kv b gy lb lc l ld le">window.dispatchEvent(new HashChangeEvent("hashchange"));</span></pre><p id="663a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就这么简单，不需要使用任何第三方库。:)</p></div></div>    
</body>
</html>