<html>
<head>
<title>How Recursion Works — step-by-step walkthrough</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">递归如何工作—逐步演练</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-recursion-works-step-by-step-walkthrough-8447e7abc9ee?source=collection_archive---------4-----------------------#2022-02-27">https://blog.devgenius.io/how-recursion-works-step-by-step-walkthrough-8447e7abc9ee?source=collection_archive---------4-----------------------#2022-02-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="6947" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">什么是递归:</h1><p id="4df0" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">函数直接或间接调用自身的过程称为递归，相应的函数称为递归函数。使用递归算法，某些问题可以很容易地解决。</p><p id="7696" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">换句话说:为了解决一个问题，我们解决一个问题，这个问题是同一个问题的一个更小的实例，然后我们用这个更小实例的解决方案来解决原来的问题。对于递归算法的工作，更小的子问题必须最终到达基本情况。简单地说，任何递归算法都有两个部分:</p><ul class=""><li id="44a3" class="ll lm in kk b kl lg kp lh kt ln kx lo lb lp lf lq lr ls lt bi translated"><strong class="kk io">基本情况:</strong>函数可以立即返回结果的终止条件。这是我们已经知道解决方案的问题的最小版本。</li><li id="c1bf" class="ll lm in kk b kl lu kp lv kt lw kx lx lb ly lf lq lr ls lt bi translated"><strong class="kk io">递归结构:</strong>通过更小的子问题的解决方案来设计问题的解决方案，即相同的问题，但输入量更小。对于较小的输入大小，我们继续调用相同的问题，直到达到递归的基本条件。</li></ul><h1 id="7582" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">通过寻找 n 阶阶乘理解递归；</h1><p id="aaad" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">非负整数的阶乘是所有小于等于 n 的整数的乘积，例如:5 的阶乘是 1*2*3*4*5 = 120。</p><h2 id="d498" class="lz jl in bd jm ma mb dn jq mc md dp ju kt me mf jy kx mg mh kc lb mi mj kg mk bi translated">递归结构:</h2><p id="0a78" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">根据 n 的阶乘的数学定义，我们可以写成:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ml"><img src="../Images/c1ea371c16c7dfeae7f87cb0e12ede6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wmg4Ij2mxOkXggFBquve-w.jpeg"/></div></div></figure><p id="b398" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">如果我们计算第<strong class="kk io"> (n-1)个</strong>阶乘的值，我们可以很容易地计算第 n 个阶乘的值。这意味着我们可以用输入大小的较小问题<strong class="kk io"> (n-1)来解决输入大小 n 的问题。</strong>换句话说，我们可以用递归的思想来解决这个问题！</p><p id="7fe8" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">假设函数<strong class="kk io"> fact(n) </strong>和<strong class="kk io"> fact(n-1) </strong>分别返回第<strong class="kk io">个</strong>和第<strong class="kk io"> (n-1)个</strong>阶乘的值，那么我们可以写出下面的递归结构:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mx"><img src="../Images/4a0d3a495a770fec1972e803c40caf4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mAp5akL6sLrbheIxkALe_Q.jpeg"/></div></div></figure><h2 id="c817" class="lz jl in bd jm ma mb dn jq mc md dp ju kt me mf jy kx mg mh kc lb mi mj kg mk bi translated">基础案例</h2><p id="630a" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在每一个递归解决方案中，都必须有一个终止条件或基本情况，在这里我们的递归将直接给出结果，而不会再次破坏子问题。如果我们观察上面的递归结构，那么我们会发现场景背后的递归调用链如下:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi my"><img src="../Images/5ef47a88c43a592a1985746383e830c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NfocDrX04-LXSjK0K_KvDQ.jpeg"/></div></div></figure><p id="9bcf" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">负数的阶乘没有定义，所以 fact(0)是阶乘问题的最小版本，我们的递归将终止并直接返回值。所以 n = 0 是返回值 1 的基本情况。</p><p id="f6b5" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io">第 n 阶乘的递归伪代码</strong></p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mz"><img src="../Images/5a641a097225beeba85bb85d6ce3e573.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d0FHJydPUKHBCeHaV85hUg.jpeg"/></div></div></figure><h1 id="4426" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">递归是如何在后台工作的？</h1><p id="71db" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">如果我们画出上述阶乘程序的递归流程，可以发现这样的模式:我们最后调用 fact(0 ),但它首先返回值。类似地，我们首先调用 fact(n ),但是它最后返回值。有没有发现一些<strong class="kk io">后进先出(LIFO) </strong>顺序的递归调用和返回值？是的，你答对了！在后台，编译器使用堆栈数据结构来模拟递归并提供正确的输出。我们把这个栈叫做:<br/> <strong class="kk io">叫栈！</strong></p><ul class=""><li id="582e" class="ll lm in kk b kl lg kp lh kt ln kx lo lb lp lf lq lr ls lt bi translated"><strong class="kk io">递归调用顺序:较大问题到较小问题<br/> </strong>事实(n) - &gt;事实(n — 1) - &gt; … - &gt;事实(i) - &gt; … - &gt;事实(1) - &gt;事实(0)</li><li id="0bcb" class="ll lm in kk b kl lu kp lv kt lw kx lx lb ly lf lq lr ls lt bi translated"><strong class="kk io">返回值顺序:从小问题到大问题<br/> </strong>事实(0)——&gt;事实(1)——&gt;——&gt;事实(I)——&gt;——&gt;事实(n—1)——&gt;事实(n)</li></ul><h2 id="8b5f" class="lz jl in bd jm ma mb dn jq mc md dp ju kt me mf jy kx mg mh kc lb mi mj kg mk bi translated">递归中调用栈的思想是如何工作的？</h2><ul class=""><li id="69cd" class="ll lm in kk b kl km kp kq kt na kx nb lb nc lf lq lr ls lt bi translated">递归函数的执行信息存储在调用堆栈中。它包含关于执行的细节:函数控制流的当前状态、局部变量和其他内部信息。当从 main()调用任何函数时，内存都在堆栈中分配给它。</li><li id="327d" class="ll lm in kk b kl lu kp lv kt lw kx lx lb ly lf lq lr ls lt bi translated">在递归过程中，当函数为较小的输入大小调用相同的函数时，内存被分配给它，它位于调用堆栈的顶部。</li><li id="bd1d" class="ll lm in kk b kl lu kp lv kt lw kx lx lb ly lf lq lr ls lt bi translated">被调用函数的内存分配在分配给调用函数的内存之上，并且为每个函数调用创建一个不同的局部变量副本。</li><li id="bcf0" class="ll lm in kk b kl lu kp lv kt lw kx lx lb ly lf lq lr ls lt bi translated">当达到基本情况时，函数将其值返回给调用它的函数，内存被释放，过程继续。</li></ul><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nd"><img src="../Images/2f8025588bc914507dbdde9ec5528a62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QUP4RjnhcAcWbs-p72lU9Q.jpeg"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated"><strong class="bd jm">计算事实的递归可视化(3) </strong></figcaption></figure></div></div>    
</body>
</html>