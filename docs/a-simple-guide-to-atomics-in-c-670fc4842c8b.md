# C++中原子的简单指南

> 原文：<https://blog.devgenius.io/a-simple-guide-to-atomics-in-c-670fc4842c8b?source=collection_archive---------0----------------------->

![](img/aef2a9b8cc88adb19fab3e9256707863.png)

丹·迈耶斯在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

当计算机科学中的某个东西被称为“原子”时，经常会出现混淆。在大多数情况下，它可能只是意味着某个过程发生在一个单独的步骤或操作中。然而，在 C++中，原子性的定义要具体得多。相反，使用`std::atomic`类和类型并不能确保所有代码都是真正的原子代码。尽管原子类型是 C++语言的一部分，但是无论程序运行在什么硬件上，原子操作都必须得到支持。本指南是理解 C++中原子性的简单指南。

# 类型

在 C++中，`std::atomic<>`模板类可以用来包装许多其他类型，以便于对该类型进行原子操作。不过，该模板并不保证任何操作实际上都是原子的。如果当前 CPU 不支持任何原子操作，编译器将使用基于互斥体的回退。幸运的是，有一个有用的函数和原子类型的保证布尔成员来帮助你检查 CPU 是否支持原子操作

上面的观念也指出了关于原子的另一个重要事实，只有操作是原子的，而不是类型或数据。就其代表的底层数据而言，`int`与`std::atomic<int>`没有什么不同。只有对数据的操作可以是原子的。此外，`std::atomic<>`类型是以这样一种方式设计的，即只有原子操作才能应用于一个类型所代表的数据，而不能混合原子和非原子操作。

# 装载和存储

最基本的原子操作是加载和存储。尽管您可能会想到短语“在变量中存储值”，但这并不是原子存储真正发生的情况。首先，记住原子的目的是允许多线程以线程安全的方式修改数据。要做到这一点，这些数据必须存在于共享内存或缓存中。因此，根据处理器架构，原子加载将数据从共享内存加载到寄存器或线程专用内存。原子存储以原子方式将数据移动到共享内存中。

为了真正理解操作(如加载或存储)的原子性质，让我们先来看看原子性是什么样子的。

## 原子性，一个时间点

在时间 *t1* 取一个值为 3 的变量 *a* 。如果在 *t1* 向 a 施加原子负载，该负载将检索值 3。然而，如果在下一个时间点 *t2* 施加负载，则可能检索到不同于 3 的值，这仅仅是因为另一个操作可能已经在 *t1* 发生。

假设变量 *a* 用值 1 初始化，使得在应用任何操作之前 *a* 的表示必须是 1。如果一个存储操作，然后一个加载操作被应用到一个，则绝对不能保证加载操作将从存储操作中检索存储的值。这是因为加载和存储发生在两个不同的时间点。原子的经验法则是，在任意两个时间点之间可以有无限多的操作。

现在让我们把它们放在一个代码示例中。这里，两个线程都试图将一个值存储然后加载到同一个原子整数中。一个布尔标志协调两个线程几乎同时启动。

如果您编译并运行这个程序，您可能会得到如下结果

```
t1 0 - 3
t1 1 - 3
t1 2 - 3
t1 3 - 3
t1 4 - 3
t1 5 - 3
t1 6 - 3
t1 7 - 3
t1 8 - 3
t1 9 - 3
t2 0 - 6
t2 1 - 6
t2 2 - 6
t2 3 - 6
t2 4 - 6
t2 5 - 6
t2 6 - 6
t2 7 - 6
t2 8 - 6
t2 9 - 6
```

这可能看起来很奇怪，因为它表明每个线程都能够加载存储的内容。这个程序可能的操作顺序是线程`t1`加载开始变量，然后完成所有的加载和存储，然后`t2`加载开始变量，并完成所有的加载和存储。为了测试这一点，我们可以在存储和加载之间添加一些“旋转”。这相当于一个线程做了不在共享内存空间中的额外工作，就像`for (int k = 0; k < 1000; ++k);`。如果我们这样做并运行程序，每个线程加载的内容之间的差异开始出现。

# 交换

交换也称为交换，是一种原子操作，它替换原子变量中的某个值，并返回先前存在的值。交换的功能是存储，然后在单个原子操作中加载。但是，它不会在操作之前检查原子变量的值。因此，交换也可以被认为是无条件的。交易所不提供加载然后存储的原子解决方案。

交换操作也称为缓存一致性。这意味着，在交换之后，任何反映交换写入变量的值的操作。为了说明这一点，可以使用一个具有单个工作线程的示例。

在上面的例子中，工作线程被赋予了一个交换 100，000 次值的大任务。在此期间，主函数将存储在`foobar`中的值更改为`14`。主函数交换后的每个后续调用现在返回`14`。

# 提取操作

提取操作，例如提取和添加，或者提取和减去，将一些操作应用到原子变量，并且提取在应用操作之前存储的值。提取操作的工作方式类似于交换，从这个意义上说，原子交换只是写入一个值并“提取”前一个值。有几种类型的获取操作，C++支持以下几种:

*   `fetch_add`
*   `fetch_sub`
*   `fetch_and`
*   `fetch_or`
*   `fetch_xor`

原子获取操作的一个限制是它们只允许等价的后缀操作，比如`x++;`。提取操作只返回操作之前的值，从不返回操作之后的值。在操作之后返回值将需要额外的原子加载，这将使得这两个操作对于变量值来说不是原子的。下面的例子实现了一个基于`fetch_add`和`fetch_sub`操作的计数器

如果编译并运行的话，

```
0
1
2
1
```

最初`fetch_sub`返回 2 的原因是因为`fetch_add`在递增值之前返回该值。对`fetch_sub`的下一个调用返回 1，表明前一个调用在获取前一个值后减去了 1。

你可能会注意到像乘法和除法这样的典型算术运算没有`fetch`等价物。原因与原子背后的基本思想有关，它们需要硬件支持。没有支持原子乘法或除法的硬件。尽力而为的方法确实存在，包括在软件中实现它们。一个例子是自动加载一个整数，将其相乘，然后自动存储回来，例如

```
std::atomic<int> a(3);
int b = a.load() * 3;
a.store(b);
```

但这有个问题。在上面的第二个和第三个语句之间，有可能另一个线程改变了`a`的值，这样“乘以 3”的目标就不起作用了，因为`b`是`a`和 3 的前一个值的乘积。简单地将`b`存储在`a`中可能会导致数据状态不一致。在这种情况下没有什么危险，没有内存泄漏或分段错误的可能性。然而，在多线程程序中，每个线程都需要有一致的原子数据视图，以成功完成各自的任务。这需要原子操作中的“失败”概念。

# 比较交换

比较交换也称为比较和交换(CAS ),是 C++中最强大的原子操作。在大多数情况下，它允许对原子变量的当前值进行原子比较，如果比较结果为真，那么它将尝试存储所需的值。尽管是原子操作，但是如果另一个线程在比较交换读取和写入之间更改了变量值，比较交换肯定会失败。比较交换操作也称为读-修改-写操作(RMW)。

处理器以不同的方式实现比较交换。在一些强有序处理器中，如 x86 处理器，比较交换是在一条汇编指令中完成的。这意味着，只有在比较交换操作完成之前，另一个线程*真正地*改变了原子变量的值，比较交换操作才会失败。在弱序处理器上，比较交换是用两条汇编指令实现的，通常是锁定加载和条件存储(LLCS)。由于使用了两条指令，LLCS 可能会暂时失败，例如对于上下文切换的线程。

C++中有两个比较交换函数，`compare_exchange_weak`和`compare_exchange_strong`。弱版本更适合在循环中调用操作的情况。在循环中调用比较交换通常出现在实现无锁数据结构时。举个例子，让我们看看最简单的无锁数据结构，栈。

在上面的例子中，堆栈有两个方法，`push`和`pop`。它们中的每一个都满足锁自由的主要标准，一个线程总是取得进展并完成它的 push 或 pop 任务。如果许多线程调用`compare_exchange_weak`，其中只有一个会成功。所有其他线程都经历了一个失败的`compare_exchange_weak`，这意味着它们将加载当前存储在变量中的值。该循环允许比较交换操作实质上“对原子变量的最后一个已知值重复”。

一个堆栈只有一个点，可以从这个点添加或删除数据。因此，任何操作都依赖于该点的值。只有在栈顶最后一个已知节点上的`compare_exchange_weak`调用成功时，推送操作才能在原子意义上成功。pop 操作也是如此。