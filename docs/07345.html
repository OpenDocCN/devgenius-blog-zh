<html>
<head>
<title>[Golang] How did I learn Go!! Silly Stuff but Interesting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我是怎么学会围棋的！！愚蠢但有趣的东西</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-did-i-learn-go-silly-stuff-but-interesting-f69b2876514f?source=collection_archive---------1-----------------------#2022-03-17">https://blog.devgenius.io/how-did-i-learn-go-silly-stuff-but-interesting-f69b2876514f?source=collection_archive---------1-----------------------#2022-03-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="4ee6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">写这个博客是希望我做的傻事和学到的东西。而在<code class="fe ki kj kk kl b">Golang</code>中编码可以帮助其他人避免它们。我学到了修复它们的艰难方法，这也鼓励我学习更多关于<em class="km">语言的知识。</em></p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi kn"><img src="../Images/cddc14abbc345af315711d8343f5a679.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*tOqkcqTP1whELGRs.png"/></div></figure><p id="7d27" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">意图是保持它简短、简明和切中要点。这些大部分其实都是<em class="km">傻</em>😉但是嘿，学习就是学习…正确！！</p><ul class=""><li id="4051" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated"><code class="fe ki kj kk kl b">Golang</code> <code class="fe ki kj kk kl b">arrays</code>中的<strong class="jm io">数组 vs 切片</strong>是固定长度的<strong class="jm io">值</strong>和<strong class="jm io">，不是<em class="km">指针</em>，不是<em class="km">对象引用。</em>所以当你把一个<em class="km"> </em> <code class="fe ki kj kk kl b"><em class="km">array</em></code> <em class="km">传递给函数</em>或者赋值给另一个<code class="fe ki kj kk kl b"><em class="km">array</em></code> <em class="km"> </em>时，你得到的只是原来<em class="km"> </em> <code class="fe ki kj kk kl b"><em class="km">array</em></code> <em class="km">的副本。</em>所以用<a class="ae le" href="https://go.dev/blog/slices-intro" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="km">切片</em></strong></a><strong class="jm io"><em class="km"/></strong>代替它们是<em class="km"/>的引用类型，可以传递给其他函数并且可以用内置函数<a class="ae le" href="https://pkg.go.dev/builtin#append" rel="noopener ugc nofollow" target="_blank">追加</a>来改变它们</strong></li></ul><pre class="ko kp kq kr gt lf kl lg lh aw li bi"><span id="06f8" class="lj lk in kl b gy ll lm l ln lo">func ChangeArray(arr [5]int) {<br/>    arr[0] = 21<br/>}<br/><br/>func main() {<br/>    v:= [5]int{1, 2, 3, 4, 5}<br/>    ChangeArray(v) <br/>    fmt.Println(v)<br/>}</span><span id="db0b" class="lj lk in kl b gy lp lm l ln lo">Output<br/>[1 2 3 4 5] <!-- -->🤔</span></pre></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><pre class="lf kl lg lh aw li bi"><span id="0b57" class="lj lk in kl b gy lx ly lz ma mb lm l ln lo">func ChangeArray(arr []int) {<br/>    arr[0] = 21<br/>}<br/><br/>func main() {<br/>    v:= []int{1, 2, 3, 4, 5}<br/>    ChangeArray(v) <br/>    fmt.Println(v)<br/>}</span><span id="f224" class="lj lk in kl b gy lp lm l ln lo">Output<br/>[21 2 3 4 5] <!-- -->🤩</span></pre></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><ul class=""><li id="1b88" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated"><strong class="jm io">字符串是不可变的</strong>中的<code class="fe ki kj kk kl b">Golang</code>字符串是<em class="km">不可变的字节片。我们可以把一个字符串看作一个(元素不可变的)字节片。所以不能改变<em class="km">字符串</em>数据。为此，在<code class="fe ki kj kk kl b">byte</code>或<code class="fe ki kj kk kl b">rune</code>级别上操作。更喜欢<code class="fe ki kj kk kl b"><strong class="jm io">Rune</strong></code> <strong class="jm io">所以</strong> <code class="fe ki kj kk kl b"><strong class="jm io">utf8</strong></code> <strong class="jm io"> </strong>也支持。</em></li></ul><pre class="ko kp kq kr gt lf kl lg lh aw li bi"><span id="0e77" class="lj lk in kl b gy ll lm l ln lo">str := "modifyString"<br/>str[6] = "s"<!-- -->              ❌ Will throw error, C<!-- -->annot assign to s[0]<br/>fmt.Println(str)<br/>runeStore := []rune(str)<br/>runeStore[6] = "s"<br/>fmt.Println(string(runeStore)) <!-- -->✅ Work fine!!</span></pre></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><ul class=""><li id="026d" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated"><strong class="jm io">函数返回多个值时不使用多重赋值。</strong></li></ul><pre class="ko kp kq kr gt lf kl lg lh aw li bi"><span id="39ab" class="lj lk in kl b gy ll lm l ln lo">func returnValues() (int, int) {<br/>  a := 1<br/>  b := 2<br/>return a, b<br/>}<br/>value := returnValues()      ❌ don’t do this, will throw error<br/><strong class="kl io">_, value := returnValues()</strong>   ✅ do this, if you don’t need both</span></pre></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><ul class=""><li id="8dfd" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated"><strong class="jm io"> Go 乘法、除法和余数运算符具有相同的优先级</strong>并从左至右进行计算<strong class="jm io">。</strong>使用<code class="fe ki kj kk kl b">()</code>强制优先级</li></ul><pre class="ko kp kq kr gt lf kl lg lh aw li bi"><span id="b1f7" class="lj lk in kl b gy ll lm l ln lo">package main</span><span id="689f" class="lj lk in kl b gy lp lm l ln lo">import (<br/>  "fmt"<br/>)</span><span id="967d" class="lj lk in kl b gy lp lm l ln lo">func main() {<br/>  n := 43210 <br/>  fmt.Println(n/60*60, "hours and", n%60*60, "seconds")     ❌ Nope<br/>  fmt.Println(n/(60*60), "hours and", n%(60*60), "seconds") ✅ Yes<br/>}</span><span id="e983" class="lj lk in kl b gy lp lm l ln lo">43200 hours and 600 seconds<br/>12 hours and 10 seconds</span></pre></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><ul class=""><li id="66b0" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated">Nil 并不总是 Nil 令人困惑，请看例子。只有当<em class="km">接口</em>的值和动态类型都是<code class="fe ki kj kk kl b">nil</code>时，该接口的值才等于<code class="fe ki kj kk kl b">nil</code>。对于<code class="fe ki kj kk kl b">interface</code>,我们需要<code class="fe ki kj kk kl b">type</code>和<code class="fe ki kj kk kl b">value</code>都成为<code class="fe ki kj kk kl b">nil</code>,来真实地反映它。比较时，我们会比较<strong class="jm io">值</strong>和<strong class="jm io">类型</strong></li></ul><pre class="ko kp kq kr gt lf kl lg lh aw li bi"><span id="a524" class="lj lk in kl b gy ll lm l ln lo">package main</span><span id="0c47" class="lj lk in kl b gy lp lm l ln lo">import (<br/>  "fmt"<br/>)</span><span id="b35e" class="lj lk in kl b gy lp lm l ln lo">func main(){<br/>  var a *int = nil<br/>  var b interface{} = nil     ❌ No Type `Nil` is hardcoded<br/>  var c interface{} = a       ✅ Yes c is type interface &amp; value nil<br/>  if a != b {<br/>    fmt.Println("from [a compared with b] not a nil")<br/>  } else {<br/>    fmt.Println("from [a compared with b] is nil")<br/>  }<br/>  if a != c {<br/>    fmt.Println("from [a compared with c] not a nil")<br/>  } else {<br/>    fmt.Println("from [a compared with c] is nil")<br/>  }<br/>}</span><span id="ce21" class="lj lk in kl b gy lp lm l ln lo">Output:<br/>from [a compared with b] not a nil<br/>from [a compared with c] is nil</span></pre></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><ul class=""><li id="75ae" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated"><strong class="jm io">为什么空</strong> <code class="fe ki kj kk kl b"><strong class="jm io">{}</strong></code> <strong class="jm io">带</strong> <code class="fe ki kj kk kl b"><strong class="jm io">json.Marshal</strong></code> <strong class="jm io"> </strong>因为只有 Go 结构<strong class="jm io">的<strong class="jm io">导出</strong>字段<strong class="jm io"> </strong>才会被考虑。</strong> <em class="km"> Pro-tip:使用</em> <code class="fe ki kj kk kl b"><em class="km">json:tag</em></code> <em class="km">明确标识它们。在我之前的博客中阅读更多关于</em> <a class="ae le" href="https://towardsdev.com/golang-struct-tags-explained-ccb589dcbb98" rel="noopener ugc nofollow" target="_blank"> <em class="km"> Go Struct 标签</em> </a> <em class="km">的内容。</em></li></ul><pre class="ko kp kq kr gt lf kl lg lh aw li bi"><span id="8075" class="lj lk in kl b gy ll lm l ln lo">package main</span><span id="91d4" class="lj lk in kl b gy lp lm l ln lo">import (<br/>  "fmt"<br/>  "encoding/json"<br/>)</span><span id="81a8" class="lj lk in kl b gy lp lm l ln lo">type Food struct {<br/>    name string       ❌ Will not work<br/>    item int          ❌ Will not work<br/>}</span><span id="3244" class="lj lk in kl b gy lp lm l ln lo">type FevFood struct {<br/>    Name string       ✅ Will work, because <strong class="kl io">N</strong> in `<em class="km">Caps</em>` <strong class="kl io">exported</strong><br/>    Item int          ✅ Will work, because <strong class="kl io">I</strong> in `<em class="km">Caps</em>` <strong class="kl io">exported</strong><br/>}</span><span id="f0d8" class="lj lk in kl b gy lp lm l ln lo">func main() {<br/>  data1 := Food{"Apple Pie", 5}<br/>  data2 := FevFood{"Apple Pie", 5}<br/>  jd1, _ := json.Marshal(data1)<br/>  jd2, _ := json.Marshal(data2)<br/>  fmt.Println(string(jd1))<br/>  fmt.Println(string(jd2))<br/>}</span><span id="d1b7" class="lj lk in kl b gy lp lm l ln lo">Output<br/>{}<br/>{"Name":"Apple Pie","Item":5}</span></pre></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><ul class=""><li id="420a" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated"><strong class="jm io">改变</strong> <code class="fe ki kj kk kl b"><strong class="jm io">range</strong></code> <strong class="jm io">循环中的值——Nop 不可能</strong>，因为范围循环将值从切片复制到一个<strong class="jm io">局部变量。</strong>所以实际价值保持不变</li></ul><pre class="ko kp kq kr gt lf kl lg lh aw li bi"><span id="4769" class="lj lk in kl b gy ll lm l ln lo">package main</span><span id="d513" class="lj lk in kl b gy lp lm l ln lo">import (<br/>  "fmt"<br/>)</span><span id="82d7" class="lj lk in kl b gy lp lm l ln lo">func main() {<br/>  sliceOfInts := []int{1, 2, 3, 4, 5}<br/>  for _, slice := range sliceOfInts {<br/>      slice += 1                       ❌ Will not work<br/>  }<br/>  fmt.Println(sliceOfInts)<br/>  sliceOfInts = []int{1, 2, 3, 4, 5}<br/>  for i := range sliceOfInts {<br/>      sliceOfInts[i] += 2              ✅ Will work, using Indices<br/>  }<br/>  fmt.Println(sliceOfInts)<br/>}</span><span id="ad4e" class="lj lk in kl b gy lp lm l ln lo">Output:<br/>[1 2 3 4 5]<br/>[3 4 5 6 7]</span></pre></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><ul class=""><li id="f806" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated"><strong class="jm io">正则表达式</strong> <code class="fe ki kj kk kl b"><strong class="jm io">[0-9]*</strong></code> <strong class="jm io">匹配包含</strong>字符的字符串，因为<code class="fe ki kj kk kl b"><a class="ae le" href="https://golang.org/pkg/regexp/" rel="noopener ugc nofollow" target="_blank">regexp</a></code>包做<strong class="jm io">子串</strong>匹配。所以我们必须具体使用<code class="fe ki kj kk kl b">^</code>和<code class="fe ki kj kk kl b">$</code></li></ul><pre class="ko kp kq kr gt lf kl lg lh aw li bi"><span id="c669" class="lj lk in kl b gy ll lm l ln lo">package main</span><span id="6264" class="lj lk in kl b gy lp lm l ln lo">import (<br/>  "fmt"<br/>  "regexp"<br/>)</span><span id="ee0e" class="lj lk in kl b gy lp lm l ln lo">func main() {<br/>  if matched, _ := regexp.MatchString(`[0-9]*`, "12three45"); matched {<br/>    fmt.Printf("`[0-9]*` == '12three45' RegExp Matched [%v]\n", matched)                 ❌ <strong class="kl io">Will match because of substring matching</strong><br/>  } else {<br/>    fmt.Printf("`[0-9]*` != '12three45' RegExp didn't Match\n")<br/>  }<br/>  if matched, _ := regexp.MatchString(`^[0-9]*$`, "12three45"); matched {<br/>    fmt.Printf("`^[0-9]*$` == '12three45' RegExp Matched [%v]\n", matched)                  ✅ <strong class="kl io">Will not match because of ^ and $</strong><br/>  } else {<br/>    fmt.Printf("`^[0-9]*$` != '12three45'  RegExp didn't Match\n")<br/>  }<br/>}</span><span id="017c" class="lj lk in kl b gy lp lm l ln lo">Output<br/>`[0-9]*` == '12three45' RegExp Matched [true]<br/>`^[0-9]*$` != '12three45'  RegExp didn't Match</span></pre><p id="2d44" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这些有些<strong class="jm io"> <em class="km">傻傻的但是很有趣的</em> </strong>的玩意儿我都学过。我会继续下去。想法是让博客小而聪明！！</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi kn"><img src="../Images/8a29f96c4a9ce96ccef7778ac1baa73f.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*Z_nTYT9PxCYmr6ze.jpg"/></div></figure><p id="6daf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">希望你们喜欢它…..😁</p><h1 id="8826" class="mc lk in bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">编码快乐！！</h1></div></div>    
</body>
</html>