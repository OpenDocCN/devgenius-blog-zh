<html>
<head>
<title>Socket Programming in C — Bonus</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C 语言中的套接字编程——加分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/socket-programming-in-c-bonus-d794a0dc6f7?source=collection_archive---------11-----------------------#2022-12-17">https://blog.devgenius.io/socket-programming-in-c-bonus-d794a0dc6f7?source=collection_archive---------11-----------------------#2022-12-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/3a882296a85e99ac02568eb18f8a5dc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3J9qvxNWd4V1zK1yAQpEPg.png"/></div></div></figure><p id="af9f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本系列的前两篇博客中，我们看到了一个使用套接字的服务器-客户端通信的非常简单的实现，其中我们使用套接字创建了服务器和客户端。但是一般来说，我们的客户是我们提出请求的网络浏览器。因此，在这篇博客中，我将演示在我们预先构建的服务器上处理这些请求。</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="be03" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">套接字创建和绑定</h1><p id="2f8f" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">服务器的创建与前面完全相同。之前的代码只有一些小改动。</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="89b9" class="mm lb in mi b be mn mo l mp mq">int sockfd, newsockfd;<br/>int clilen;<br/>struct sockaddr_in cli_addr, serv_addr;<br/>int i;<br/>char buffer[4096];<br/><br/>if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)<br/>{<br/>  printf("Cannot create socket\n");<br/>  exit(0);<br/>}<br/><br/>serv_addr.sin_family = AF_INET;<br/>serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);<br/>serv_addr.sin_port = htons(5000);<br/><br/>if (bind(sockfd, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr)) &lt; 0)<br/>{<br/>  printf("Unable to bind local address\n");<br/>  exit(0);<br/>}<br/><br/>listen(sockfd, 5);</span></pre><p id="4435" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里引入两个新函数，<strong class="jx io"> htonl() </strong>和<strong class="jx io"> htons() </strong>。有用于将地址和端口号从本机字节顺序转换为网络字节顺序。嗯，听起来有点复杂。我给你简单解释一下。</p><p id="93f8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">基本上<strong class="jx io">字节顺序</strong>就是系统中数字的顺序。例如，大端字节顺序将字的最高有效字节存储在最小的内存地址。</p><blockquote class="mr ms mt"><p id="fa4b" class="jv jw mu jx b jy jz ka kb kc kd ke kf mv kh ki kj mw kl km kn mx kp kq kr ks ig bi translated">网络字节顺序总是被定义为大端顺序，这可能与主机的字节顺序不同。所以，我们需要转换它们。</p></blockquote><h1 id="f5a4" class="la lb in bd lc ld my lf lg lh mz lj lk ll na ln lo lp nb lr ls lt nc lv lw lx bi translated">处理来自浏览器的请求</h1><p id="4a5d" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">HTTP 请求有一些包含请求方法类型(GET、POST 等)的预定义格式。)、路径、内容类型、用户代理等。因此，现在每当我们从浏览器收到请求时，它都是这种格式，我们需要解析它来提取所需的数据。</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="e3b0" class="mm lb in mi b be mn mo l mp mq">Sample request format:<br/><br/>GET / HTTP/1.1<br/>Host: localhost:5000<br/>User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:69.0) Gecko/20100101 Firefox/69.0<br/>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8<br/>Accept-Language: en-US,en;q=0.5<br/>Accept-Encoding: gzip, deflate<br/>Connection: keep-alive<br/>Upgrade-Insecure-Requests: 1</span></pre><p id="04de" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里，GET 后面的“/”是客户端请求的路径，我们将返回一些 HTML 内容作为响应。</p><p id="c2a3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接受连接的代码与前面的一样，只有我们传输数据的部分会发生变化。</p><p id="271a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">连接建立后，使用 recv()函数将请求存储在字符串缓冲区中，并从中提取方法类型和请求的路径。</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="f97f" class="mm lb in mi b be mn mo l mp mq">if (strncmp(buffer, "GET ", 4) == 0)<br/>{<br/>    char *path = NULL;<br/>    path = strtok(buffer, " "); // returns the string "GET"<br/>    path = strtok(NULL, " ");   // returns the requested path<br/>    if (strcmp(path, "/") == 0)<br/>    {<br/>        ...<br/>    }<br/>}</span></pre><p id="bf44" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于此示例，在请求路径“/”上，服务器将读取并发送存储在系统(即服务器)中的 index.html 文件的内容。</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="30e4" class="mm lb in mi b be mn mo l mp mq">if ((file_fd = open("index.html", O_RDONLY)) == -1)<br/>{<br/>      printf("File error!");<br/>      continue;<br/>}<br/>len = lseek(file_fd, (off_t)0, SEEK_END); // length of file                                                              /* lseek to the file end to find the length */<br/>lseek(file_fd, (off_t)0, SEEK_SET);</span></pre><p id="f720" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在发送 HTML 内容之前，必须发送一些标题，如响应的状态码、内容长度、内容类型等。以便客户机(浏览器)能够理解作为响应的数据类型以及如何显示它。</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="f41b" class="mm lb in mi b be mn mo l mp mq">Example:<br/>HTTP/1.1 200 OK<br/>Content-Length: 50<br/>Content-Type: text/html<br/>…</span></pre><p id="6f86" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">标题和 HTML 文件内容将使用 send()函数发送。</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="a756" class="mm lb in mi b be mn mo l mp mq">// writing headers into buffer string<br/>sprintf(buffer, "HTTP/1.1 200 OK\nContent-Length: %ld\nConnection: close\nContent-Type: text/html\n\n", len);<br/><br/>// sending headers to client<br/>send(newsockfd, buffer, strlen(buffer),0);<br/><br/>// sending file content<br/>while ((ret = read(file_fd, buffer, 4096)) &gt; 0)<br/>{<br/>    send(newsockfd, buffer, ret, 0);<br/>}</span></pre><p id="f4ea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，该文件可以包含大量内容，因此应该以字节块的形式发送，比如 4096 字节的块。</p><p id="2962" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">完成了！！！总之，我们使用套接字创建了一个简单的服务器，解析来自浏览器的请求，提取方法类型和请求路径，并基于此提供响应。对于不同的路径，可以重复相同的过程。</p><h2 id="a5bf" class="nd lb in bd lc ne nf dn lg ng nh dp lk kg ni nj lo kk nk nl ls ko nm nn lw no bi translated">查看运行中的代码:</h2><p id="9952" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">运行服务器代码，打开浏览器，输入服务器的地址(这里是<em class="mu"> localhost:5000/ </em>)。定义的 index.html 在浏览器中加载并显示其内容。</p><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi np"><img src="../Images/c2e6abf65a2aa6f17e91989da0300eb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5WlVTfv0v1sLfGn6TiAiCA.png"/></div></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk translated">输出</figcaption></figure></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><p id="834a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个例子中，我只展示了 GET 请求的处理。它还可以扩展到处理 POST 请求。我们只需解析 POST 请求，提取包含参数的路径和请求体。</p><pre class="md me mf mg gt mh mi mj bn mk ml bi"><span id="a658" class="mm lb in mi b be mn mo l mp mq">POST request will have below format:<br/><br/>POST / HTTP/1.1<br/>Host: localhost:5000<br/>User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:69.0) Gecko/20100101 Firefox/69.0<br/>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8<br/>Accept-Language: en-US,en;q=0.5<br/>Accept-Encoding: gzip, deflate<br/>Content-Type: application/x-www-form-urlencoded<br/>Content-Length: 8<br/>Connection: keep-alive<br/>Referer: http://localhost:5000/<br/>Upgrade-Insecure-Requests: 1<br/><br/>name=asde&amp;age=17&amp;...</span></pre><blockquote class="mr ms mt"><p id="94fd" class="jv jw mu jx b jy jz ka kb kc kd ke kf mv kh ki kj mw kl km kn mx kp kq kr ks ig bi translated">参数(用户数据)将位于请求<strong class="jx io">的末尾(例如。name=asde &amp; age=17) </strong></p></blockquote></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><p id="2946" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这一系列的服务器-客户端实现到此结束。如果你在这三个博客中的任何一个中发现任何困难，那么请发表评论。如果您发现任何问题或错误信息，请指出来。</p><p id="3252" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">表现出一些欣赏👏👏如果你觉得这个博客有帮助，请与你的同事分享。</p><p id="65a9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">更了解我:【https://linktr.ee/yashpaneliya】T2</p></div></div>    
</body>
</html>