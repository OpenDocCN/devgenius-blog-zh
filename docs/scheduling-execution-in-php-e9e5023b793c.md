# 在 PHP 中调度执行

> 原文：<https://blog.devgenius.io/scheduling-execution-in-php-e9e5023b793c?source=collection_archive---------4----------------------->

![](img/e9188ec549b2e57734c97e4ae752e036.png)

我们经常需要在应用程序中安排给定业务功能的执行。时机取决于我们想要达到的目标。它可以是每月执行的发票或用户在网站上注册后发送的通知。在本文中，我们将深入探讨 PHP 中调度执行的不同方式。

本文假设了关于[命令](https://blog.ecotone.tech/cqrs-in-php/)和[事件](https://blog.ecotone.tech/event-handling-in-php/)的基本知识。

# 计划批处理作业

最常见的方法是计划批处理作业。
这是一个在特定时间上升的进程，在大多数情况下执行大型数据库查询，获取大部分数据并执行相关操作。

> 在 PHP 世界中，调度批处理作业大多由 Cron 作业实现，它在给定的时间执行进程。

批处理在实现、访问数据库、迭代和执行方面非常简单。
这样我们能实现什么？

*   我们可以获取过去 15 分钟内注册的所有用户，向他们发送欢迎通知。
*   我们可以获取所有订单来重新计算公司收入统计数据。
*   对于一个特定的用户，我们可能有一个在给定日期给他开发票的协议，所以我们会寻找过期的日期来生成它

# 计划作业实施

拥有一个系统 cron 作业经常会产生跟踪问题，如果出现问题，需要运行非 PHP 进程。
如果这对你来说有问题，econtero 将计划作业引入 PHP。

# 预定方法

`#[Scheduled]`中的`EndpointId`定义了将用于执行过程的名称。`#[Poller]`定义了这个方法应该如何执行。

该方法将被安排为每 10 秒执行一次。
流程现在可以运行:

```
# Symfony
bin/console ecotone:run notificationSender -vvv# Laravel
artisan ecotone:run notificationSender -vvv# Lite
$messagingSystem->run("notificationSender");
```

# 预定处理程序

您也可以计划执行给定的`Command Handler`。

`#[Scheduled]`的第一个参数表示路由到`Command Handler`。
在本例中，我们设置了 Cron 每分钟执行一次，并调用我们的命令处理程序。

# 计划批处理作业的问题

有时，计划的批处理作业可能会出现问题。

*   批处理作业通常会对数据库产生巨大的负载，从而影响系统的最终用户。
*   如果批处理作业将在午夜失败怎么办？如果我们能发现并通知它，那么系统的用户是幸运的，然而，开发者可能会有另一个不眠之夜。如果我们的脚本在处理过程中中断，这将变得更加困难。因为我们需要从中恢复，并且只对尚未处理的部分数据运行作业。
*   如果我们想在白天采取行动呢？
    我们要么需要增加系统资源，要么同意在此期间可能会影响最终用户。

所以一定有更好的方法，对吗？

# 信息发送

为我们提供了一个坚实稳定的平台来处理此类问题。
它帮助我们构建能够在高负载下良好扩展和运行的应用程序。

那么什么是`Message`？
消息是一封信，可以通知系统中最近发生的事件，或者命令系统应该执行的动作。

使用消息传递，我们一次处理一条消息(一条记录),为了保持系统稳定，我们可以将消息排队，并在准备好的时候处理它们。
这样就解决了超负荷，一次处理多条记录的问题。因为我们可以将消息排队并逐个处理它们。

> 消息传递为系统提供了更大的稳定性，因为如果我们在特定消息上失败了，我们可以重试该消息或将其提交审查并继续处理其他消息。

# 静态消息时间表

假设我们想在注册 5 分钟后给新注册的用户发送一个通知。

注册后，我们正在发布事件`UserWasRegistered`。现在我们可以异步处理这个事件[并延迟执行。](https://docs.ecotone.tech/modelling/asynchronous-handling)

`#[Delayed]`以毫秒为单位描述我们希望延迟执行多长时间。

> 生态区向每个事件处理程序传递一个消息的副本。由于这一点，你可以延迟一个处理程序，而立即执行另一个

# 动态消息时间表

如果我们想动态地决定何时执行一个给定的流程，我们可以在发送消息时定义它。

假设用户下了订单，如果他要快速发货，我们想推迟 3 天或者 7 天。

还有我们的`Command Handler`

> *我们使用异步来存储我们发送的消息。例如，我们可以通过 RabbitMQ 或 DBAL(数据库)来支持它。*

# 定期消息时间表

我们可能还想做一些重复性的动作，比如开发票。在给定的时间周期后执行给定的执行。

让我们为用户实现发票。
用户注册后，我们将注册第一次尝试生成的发票。
发票生成后，我们将延迟注册另一次尝试。

在新用户注册后，我们将他加入到流程中。
如果用户将被阻止，那么`generateInvoice`我们可以只做一个返回而不发布事件，给定用户的流程将简单地结束。
这将创建一个消息流，我们将每次为给定的用户生成发票，直到我们决定停止它的那一刻。

> 如果您将`#[Asynchronous]`属性放在类的顶部，它将应用于所有的`Handlers`。

# 摘要

econtero 为 PHP 带来了一个真正的消息平台。它提供了简单易用的工具，以一种可靠稳定的方式将事物粘合在一起。
消息传递是一个强大的概念，一旦开发人员习惯了这一点，它可以省去许多不眠之夜，尤其是在关键业务组件中。

你可以在这里阅读更多关于生态交错带的信息。
如果您想查看以下使用 econtero Lite 的文章的实现，请点击[这里](https://github.com/ecotoneframework/quickstart-examples/tree/master/Schedule/src)。