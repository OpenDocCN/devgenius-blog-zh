<html>
<head>
<title>How to write a Recursive Function in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在 Go 中编写递归函数</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-write-a-recursive-function-in-go-d35074dff32e?source=collection_archive---------24-----------------------#2020-07-08">https://blog.devgenius.io/how-to-write-a-recursive-function-in-go-d35074dff32e?source=collection_archive---------24-----------------------#2020-07-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2a37743f3164eba18d6066d5244a4071.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8xAj_NTwvs0Zaw0NxzytzA.jpeg"/></div></div></figure><p id="40fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我不知道你，但是当我开始编程时，递归这个术语让我有点发抖。老实说，我认为这是一种自然的反应。新事物会让人害怕！我也不理解在代码中使用递归的重要性或潜在影响。如果你对递归没有很好的理解，你很幸运！我将讨论如何利用递归的力量，并在你的围棋程序中使用它。</p><h1 id="96e3" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">那么，什么是递归？</h1><blockquote class="lv lw lx"><p id="3e76" class="jy jz kw ka b kb kc kd ke kf kg kh ki ly kk kl km lz ko kp kq ma ks kt ku kv ij bi translated">过程或定义的重复应用</p></blockquote><p id="db1c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">递归在编程中的一个常见用法是在同一个函数内部调用一个函数。让我给你看一个例子:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="2e69" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mh mi mj mk b">main</code>:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><ul class=""><li id="1484" class="ml mm iq ka b kb kc kf kg kj mn kn mo kr mp kv mq mr ms mt bi translated">在<code class="fe mh mi mj mk b">func</code> <code class="fe mh mi mj mk b">main</code>内部，我们声明变量<code class="fe mh mi mj mk b">n</code>，并将<code class="fe mh mi mj mk b">n</code>赋给<code class="fe mh mi mj mk b">factorial</code>函数的返回值</li><li id="9b5d" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated"><code class="fe mh mi mj mk b">factorial</code>函数有一个类型为<code class="fe mh mi mj mk b">int</code>的参数<code class="fe mh mi mj mk b">4</code></li><li id="15df" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">在下一行执行中，使用<code class="fe mh mi mj mk b">fmt</code>包，我们打印出<code class="fe mh mi mj mk b">n</code>的值</li></ul><blockquote class="lv lw lx"><p id="b2fa" class="jy jz kw ka b kb kc kd ke kf kg kh ki ly kk kl km lz ko kp kq ma ks kt ku kv ij bi translated">快速提示:在每一个递归函数中，都需要有一个“基本情况”。</p><p id="8b32" class="jy jz kw ka b kb kc kd ke kf kg kh ki ly kk kl km lz ko kp kq ma ks kt ku kv ij bi translated">基本情况是最常见的 if 语句，当评估为“真”时</p><p id="db98" class="jy jz kw ka b kb kc kd ke kf kg kh ki ly kk kl km lz ko kp kq ma ks kt ku kv ij bi translated">将停止调用函数内的函数(停止递归)</p><p id="c908" class="jy jz kw ka b kb kc kd ke kf kg kh ki ly kk kl km lz ko kp kq ma ks kt ku kv ij bi translated">并将允许程序从函数中返回</p></blockquote><p id="408d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mh mi mj mk b">factorial</code>:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><ul class=""><li id="ee72" class="ml mm iq ka b kb kc kf kg kj mn kn mo kr mp kv mq mr ms mt bi translated">在<code class="fe mh mi mj mk b">main</code>函数下面，我们声明了一个标识符为<code class="fe mh mi mj mk b">factorial</code>的函数</li><li id="9fe0" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">函数<code class="fe mh mi mj mk b">factorial</code>有一个类型为<code class="fe mh mi mj mk b">int</code>的参数<code class="fe mh mi mj mk b">n</code></li><li id="65f1" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">函数<code class="fe mh mi mj mk b">factorial</code>返回一个<code class="fe mh mi mj mk b">int</code>类型的值</li><li id="652f" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">在本例中，<code class="fe mh mi mj mk b">factorial</code>中的<em class="kw">基本用例</em>是一个<code class="fe mh mi mj mk b">if</code>语句，用于检查<code class="fe mh mi mj mk b">n</code>的值是否为<code class="fe mh mi mj mk b">0</code></li><li id="9623" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">因为我们的参数<code class="fe mh mi mj mk b">n</code>是<code class="fe mh mi mj mk b">4</code>，所以计算结果为<code class="fe mh mi mj mk b">false</code>，我们继续执行下一行</li><li id="d447" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">我们的下一行是一个表达式为<code class="fe mh mi mj mk b">n * factorial(n-1)</code>的<code class="fe mh mi mj mk b">return</code>语句，这是什么意思？</li></ul><p id="53c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">-我们的下一行是一个表达式为<code class="fe mh mi mj mk b">n * factorial(n-1)</code>的<code class="fe mh mi mj mk b">return</code>语句，这是什么意思？</p><p id="26e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mh mi mj mk b">n * factorial(n-1)</code>:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><ul class=""><li id="8748" class="ml mm iq ka b kb kc kf kg kj mn kn mo kr mp kv mq mr ms mt bi translated">在第一次迭代中，<code class="fe mh mi mj mk b">n</code>的值是<code class="fe mh mi mj mk b">4</code>，所以我们可以这样写这个表达式:<code class="fe mh mi mj mk b">4 * factorial(4–1)</code></li><li id="3ea8" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">我们可以为<code class="fe mh mi mj mk b">factorial</code>的自变量做减法，当我们做的时候，表达式看起来像这样:<code class="fe mh mi mj mk b">4 * factorial(3)</code></li><li id="3786" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">现在，我们知道我们有了<code class="fe mh mi mj mk b">4</code>的值；然而，我们用参数<code class="fe mh mi mj mk b">3</code>再次调用<code class="fe mh mi mj mk b">factorial</code></li><li id="668a" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">因为我们调用了<code class="fe mh mi mj mk b">factorial</code>，所以我们跳转到函数的第一行执行</li></ul><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><ul class=""><li id="0b29" class="ml mm iq ka b kb kc kf kg kj mn kn mo kr mp kv mq mr ms mt bi translated">我们知道<code class="fe mh mi mj mk b">n</code>的值现在是<code class="fe mh mi mj mk b">3</code>；因此，我们的<em class="kw">基础案例</em>仍然评估为<code class="fe mh mi mj mk b">false</code></li><li id="be34" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">现在<code class="fe mh mi mj mk b">n</code>的值是<code class="fe mh mi mj mk b">3</code>，我们的<code class="fe mh mi mj mk b">return</code>语句现在看起来像这样:<code class="fe mh mi mj mk b">4 * 3 * factorial(3–1)</code></li><li id="f4cc" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">简体:<code class="fe mh mi mj mk b">4 * 3 * factorial(2)</code></li><li id="24b3" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">我们再次调用<code class="fe mh mi mj mk b">factorial</code>，参数是类型<code class="fe mh mi mj mk b">int</code>的值<code class="fe mh mi mj mk b">2</code></li></ul><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><ul class=""><li id="99ba" class="ml mm iq ka b kb kc kf kg kj mn kn mo kr mp kv mq mr ms mt bi translated">我们的<em class="kw">基础案例</em>仍然评估为<code class="fe mh mi mj mk b">false</code>，因为<code class="fe mh mi mj mk b">2</code>不等于<code class="fe mh mi mj mk b">0</code></li><li id="4a85" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">我们的<code class="fe mh mi mj mk b">return</code>语句现在看起来像这样:<code class="fe mh mi mj mk b">4 * 3 * 2 * factorial(2–1)</code></li><li id="bf6b" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">简体:<code class="fe mh mi mj mk b">4 * 3 * 2 * factorial(1)</code></li><li id="b369" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">我们再次调用<code class="fe mh mi mj mk b">factorial</code>，参数是类型<code class="fe mh mi mj mk b">int</code>的值<code class="fe mh mi mj mk b">1</code></li></ul><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><ul class=""><li id="0097" class="ml mm iq ka b kb kc kf kg kj mn kn mo kr mp kv mq mr ms mt bi translated">我们的<em class="kw">基础案例</em>仍然评估为<code class="fe mh mi mj mk b">false</code>，因为<code class="fe mh mi mj mk b">1</code>不等于<code class="fe mh mi mj mk b">0</code></li><li id="d4f2" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">我们的<code class="fe mh mi mj mk b">return</code>语句现在看起来像这样:<code class="fe mh mi mj mk b">4 * 3 * 2 * 1 * factorial(1–1)</code></li><li id="3ee3" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">简体:<code class="fe mh mi mj mk b">4 * 3 * 2 * 1 * factorial(0)</code></li></ul><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><ul class=""><li id="0339" class="ml mm iq ka b kb kc kf kg kj mn kn mo kr mp kv mq mr ms mt bi translated">这一次，我们的<em class="kw">基础用例</em>仍然评估为<code class="fe mh mi mj mk b">true</code>，因为<code class="fe mh mi mj mk b">0</code> <em class="kw">等于</em>和<code class="fe mh mi mj mk b">0</code></li><li id="7b9f" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">在我们的<em class="kw">基础案例</em>中，我们返回类型<code class="fe mh mi mj mk b">int</code>的值<code class="fe mh mi mj mk b">1</code></li><li id="bbc1" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">既然我们的递归已经完成，我们最后的<code class="fe mh mi mj mk b">return</code>语句将看起来像这样:<code class="fe mh mi mj mk b">return 4 * 3 * 2 * 1</code>，它计算出类型<code class="fe mh mi mj mk b">int</code>的值<code class="fe mh mi mj mk b">24</code></li></ul><p id="8585" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mh mi mj mk b">main</code>:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><ul class=""><li id="306a" class="ml mm iq ka b kb kc kf kg kj mn kn mo kr mp kv mq mr ms mt bi translated">现在所有的执行都完成了，<code class="fe mh mi mj mk b">n</code>的值被计算为<code class="fe mh mi mj mk b">24</code>，这个值在下一行打印出来</li></ul><h1 id="f997" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">概括起来</h1><p id="1f80" class="pw-post-body-paragraph jy jz iq ka b kb mz kd ke kf na kh ki kj nb kl km kn nc kp kq kr nd kt ku kv ij bi translated">我希望你喜欢学习递归。尽管这个例子并不太复杂，但我希望你在阅读完这篇文章后，能够更好地理解<em class="kw">递归</em>的原理，并将它们应用到你的工作流程中。我会说，在编写递归函数时，应该有一定程度的谨慎。如果您的<em class="kw">基础用例</em>不健全，您可能会发现自己处于一个函数可以不断调用自身并且不可避免地导致<a class="ae ne" href="https://en.wikipedia.org/wiki/Stack_overflow" rel="noopener ugc nofollow" target="_blank">堆栈溢出</a>的位置。然而，如果做对了，<em class="kw">递归</em>允许我们写出干净、简洁、高效的代码。</p><p id="98e5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下周我将讨论<em class="kw">指针、JSON 编组和 JSON 解组</em>。到时候见！</p></div></div>    
</body>
</html>