<html>
<head>
<title>TDD explained: Practical example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TDD解释:实际例子</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/tdd-explained-practical-example-97cb99ee6033?source=collection_archive---------14-----------------------#2020-06-11">https://blog.devgenius.io/tdd-explained-practical-example-97cb99ee6033?source=collection_archive---------14-----------------------#2020-06-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/01d2cb0c7ccf044bd0b746a1ae98de63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MlQPYpSk7_j0fvtv"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@ffstop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Fotis Fotopoulos </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="2094" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你听说过缩写词TDD，但你不确定它的意思，或者即使你知道TDD是什么，但你不知道如何付诸实践；那么这篇文章就送给你了。</p><p id="c400" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">先解释一下什么是<strong class="kf ir"> TDD </strong>。</p><p id="2cc9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TDD代表<strong class="kf ir">测试驱动开发，</strong>正如它的名字所表明的，这是一种实践，我们使用测试作为下一步做什么的指导来编写代码。<br/>这就引出了我在TDD中的一个主要原则:</p><blockquote class="lb"><p id="c3e3" class="lc ld iq bd le lf lg lh li lj lk la dk translated">如果测试没有要求，就不要写一行代码！T12】</p></blockquote><p id="1d31" class="pw-post-body-paragraph kd ke iq kf b kg lm ki kj kk ln km kn ko lo kq kr ks lp ku kv kw lq ky kz la ij bi translated">那么它实际上意味着什么呢？</p><p id="028b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们开始解释TDD过程是什么样的，就更容易理解了。</p><h1 id="0103" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">过程</h1><p id="86d3" class="pw-post-body-paragraph kd ke iq kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">TDD过程非常简单:</p><ol class=""><li id="e171" class="mu mv iq kf b kg kh kk kl ko mw ks mx kw my la mz na nb nc bi translated">为您的功能编写一个<strong class="kf ir">失败的</strong>测试</li><li id="8246" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated">进行<strong class="kf ir">最简单的改变</strong>，使测试通过</li><li id="4d49" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated"><strong class="kf ir">一旦测试就绪，重构</strong>代码以保护功能</li><li id="65e7" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated"><strong class="kf ir">重复</strong></li></ol><p id="dfb5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就这样吗？这么简单吗？</p><p id="9ac1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对，就是这样。但是TDD是一个永无止境的循环；你写一个失败的测试，让它通过然后重构；然后选择下一个功能，重新开始。</p><figure class="nj nk nl nm gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/45c362ee107fd2c49e4b2d86cc579ea1.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/0*fsxS98281kM8vmRK"/></div></figure><p id="8b07" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">遵循这一过程，我们会取得什么成果？我们完成了几件事:</p><ul class=""><li id="77ac" class="mu mv iq kf b kg kh kk kl ko mw ks mx kw my la nn na nb nc bi translated"><strong class="kf ir">简单性</strong> <br/>如果我们只在测试需要时才写代码，并且我们总是写最简单的修改来使测试通过，那么我们解决方案的简单性是有保证的。</li><li id="125e" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la nn na nb nc bi translated">通过测试指导软件开发，不写任何不能通过当前测试的代码，我们写的任何代码都不可能不被我们的单元测试覆盖。</li><li id="0216" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la nn na nb nc bi translated">更少的脑力劳动TDD的另一个优点是我们不必事先过多地思考和考虑设计，大多数情况下，解决方案是在添加正确的测试后呈现给我们自己的。</li></ul><p id="c41a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么实际情况如何呢？让我们一起做一个练习吧！</p><figure class="nj nk nl nm gt jr gh gi paragraph-image"><div class="gh gi no"><img src="../Images/8810fd284beb90423ca4a3fc945127be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*zGEEEAq5hB04TexI"/></div></figure><h1 id="d527" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">实践中的TDD</h1><p id="90aa" class="pw-post-body-paragraph kd ke iq kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">我们将一起做一个简单的形来展示这个过程。问题中的形是<a class="ae kc" href="https://kata-log.rocks/roman-numerals-kata" rel="noopener ugc nofollow" target="_blank">罗马数字</a>，希望你喜欢。</p><p id="de64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如链接所示，我们必须转换的一些数字是:</p><pre class="nj nk nl nm gt np nq nr ns aw nt bi"><span id="8659" class="nu ls iq nq b gy nv nw l nx ny">1 ➔ I <br/>2 ➔ II <br/>3 ➔ III <br/>4 ➔ IV <br/>5 ➔ V <br/>9 ➔ IX <br/>21 ➔ XXI <br/>50 ➔ L <br/>100 ➔ C <br/>500 ➔ D <br/>1000 ➔ M</span></pre><p id="d743" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们编写我们的第一个测试！</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="d761" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了首先编译这个测试，我们必须创建我们的<strong class="kf ir">Roman numbers</strong>类的最简单的实现。</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="cf2b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们运行这个测试，它实际上<strong class="kf ir">没有通过</strong>，正如所料。</p><p id="c8fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好的，那么我们要怎么做才能通过第一次测试呢？请记住，我们必须做出最简单的改变才能通过测试；在这种情况下，最简单的方法是只返回“我”。我们运行我们的测试，我们的第一个测试是绿色的！</p><p id="6a27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然我们的第一个测试是绿色的，我们必须编写第二个测试。对于这个特殊的例子，我们有不同的选择来选择下一个测试。例如，它可能是“2 ”,但在罗马数字中，这将是一个两位数；在这种情况下，我更喜欢选择罗马数字中的下一个位数，所以我先选择5。</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="a42c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们运行这个测试，它<strong class="kf ir">会像预期的那样</strong>失败，因为它返回“I”。让我们更改我们的实现以使它通过，但现在我们必须记住，在实现我们的更改后，前面的测试也必须通过。还是那句话，我们来做最简单的！</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="72f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这样，简单！我们只是检查数字并返回相应的等价罗马数字。<br/>我知道你在想什么:那很丑！我知道，但别担心；我们以后再改。</p><blockquote class="lb"><p id="95e4" class="lc ld iq bd le lf lg lh li lj lk la dk translated"><em class="ll">我们应该避免TDD的过早优化，这通常会导致解决方案过于复杂。我们必须选择何时重构我们的代码；当我们觉得我们的实现变得混乱或缺乏清晰度时，我们将着手重构。</em></p></blockquote><p id="b2a9" class="pw-post-body-paragraph kd ke iq kf b kg lm ki kj kk ln km kn ko lo kq kr ks lp ku kv kw lq ky kz la ij bi translated">为了避免这篇文章写得太长，我将在介绍完所有“一位数”的罗马数字(这是最简单的情况)后添加测试和实现。然后我们就能应对接下来的挑战。让我们看看它会是什么样子:</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="7535" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们现在运行它们，所有的新测试都将<strong class="kf ir">失败</strong>，所以让我们看看如何以最简单的方式改变实现来使它们通过:</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="1fab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">太好了！我们的测试都是绿色的！但是等一下，我们的实现变得有点混乱，对吗？</p><p id="6a00" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们来重构一下吧！在这一点上，它成为一个问题，我们已经涵盖了所有个位数的情况；让我们改变它！<br/>使用if条件来确定等价性不是本练习的最佳方法，因此我们将定义一个结构来保存这些等价性。例如，使用Java映射来存储等价关系将允许我们每次都获取O(1)的等价关系。我用的是JDK 11，所以我将使用<a class="ae kc" href="https://docs.oracle.com/javase/9/docs/api/java/util/Map.html#of--" rel="noopener ugc nofollow" target="_blank">的</a>地图来初始化这个地图结构，它从JDK 9开始就可用了。</p><p id="995e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个新的实现最终是这样的:</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="c75c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在干净多了，对吧？我希望你喜欢它。</p><p id="7fe1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完成重构后，我们再次运行所有的测试来检查我们没有破坏任何东西。好消息，所有人！<br/>现在我们已经测试了所有个位数的案例，并且重构了实现，是时候应对下一个挑战了。让我们为第一个两位数的罗马数字写一个测试；这种情况下我选2。</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="38c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们运行这个测试，它<strong class="kf ir">会失败</strong>,因为在我们的结构中没有与数字2等价的东西。<br/>是时候让它过去了，但这将比第一次更复杂。如果我们仔细想想，我们有两个选择:在我们的结构中为数字2添加一个等价体，或者做一个改变来返回两个连接在一起的“I”。</p><p id="1803" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以选择第一个选项，但是在某个时候我们会意识到我们不能在我们的结构中存储所有的数字；即使在本练习中，我们将支持高达1000的数字，这仍然太多了。<br/>让我们试着做点什么，这样我们就可以把数字2处理成2 = 1 + 1。</p><p id="d817" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想一想，我们要做的是得到最接近的等价，它小于或等于我们想要处理的数。<br/>所以对于数字2，我们将得到更低或相等的最接近的键，恰好是1；然后我们会得到剩下的部分，并重复。</p><p id="80e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看我们的第一种方法是什么样的:</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="f0a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如你所看到的，我们已经用一个<a class="ae kc" href="https://docs.oracle.com/javase/8/docs/api/java/util/NavigableMap.html" rel="noopener ugc nofollow" target="_blank"> NavigableMap </a>接口替换了我们的等价存储结构，它提供了一个<a class="ae kc" href="https://docs.oracle.com/javase/8/docs/api/java/util/NavigableMap.html#lowerKey-K-" rel="noopener ugc nofollow" target="_blank"> lowerKey </a>方法来为我们完成这项工作。然而，尽管这个实现能够为我们获取lower键，但它仍然只返回一位数的罗马数字；不幸的是，我们的测试仍然<strong class="kf ir">失败</strong>。<br/>我们得想办法再迭代一次，找到剩余部分的等价。我认为<a class="ae kc" href="https://en.wikipedia.org/wiki/Recursion_(computer_science)" rel="noopener ugc nofollow" target="_blank">递归</a>在这种情况下会帮助我们，让我们实现它。</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="28ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你是递归的新手，在开始澄清你头脑中的概念可能有点令人兴奋，但是它比看起来要简单。<br/>我们所做的是首先检查一个等价性；如果没有等价项，则找到较低的键，获取该键的等价项，并为剩余部分(编号— lowerKey)再次调用<strong class="kf ir"> convert </strong>方法。如果我们现在运行我们的测试，它们都是！这是好消息。</p><p id="b1cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么下一步是什么？三位数的罗马数字呢？让我们试试3号。</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="28f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">惊喜！绿灯了，我们什么都不用做。但是第四条呢？我们必须记住，这个数字是一个特例，因为它的等价是“四”。</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="0260" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不出所料，它<strong class="kf ir">失败</strong>。我们如何解决这个问题？这是个特例，因为它从“V”中减去了“I”。<br/>听起来有些棘手，但让我们想想我们有多少这样的“特例”。我们只有IV (4)，IX (9)，XC (90)和CM (900)，所以花大力气真的没什么意义；让我们做最简单的，为它们在我们的结构中添加等价。</p><p id="f878" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们新的等价结构是:</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="258b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们增加对数字4和9的测试，它们是绿色的T4。还剩下什么？6号呢？它是不同的，因为它的对等词是“VI”，它把“I”加到“V”上。让我们添加一个测试:</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="ea04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们运行测试，它也是绿色的<strong class="kf ir"/>！我们的实现创造了奇迹。我想是时候尝试一个更复杂的数字了，比如838。让我们添加测试:</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="017a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的测试是<strong class="kf ir">绿色</strong>！我想我们已经完成了，我们有一个健壮实现，支持从1到1，000的罗马数字。</p><p id="8aae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后我们可以做的另一件事是，如果测试太多，重构我们的测试。在我们的例子中，我们可以转换我们的JUnit 4测试来使用<a class="ae kc" href="https://github.com/junit-team/junit4/wiki/Parameterized-tests" rel="noopener ugc nofollow" target="_blank">参数化的</a>，这将删除我们测试中的一些冗余。然而，我将把它作为一个练习留给你；我们在这篇文章中已经讨论了足够多的内容，而进行重构已经超出了展示TDD是什么的范围。</p><p id="82fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">原来如此！我希望你喜欢这个练习，并且对TDD过程有了很好的理解。</p><p id="eb5e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您喜欢这篇文章，请订阅，以便在新文章发表时收到通知！</p><p id="1195" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">非常感谢您的阅读！</p></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><p id="d456" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="oi">原载于2020年6月11日http://theboreddev.com</em><a class="ae kc" href="https://theboreddev.com/2020/06/06/tdd-explained-practical-example/" rel="noopener ugc nofollow" target="_blank"><em class="oi"/></a><em class="oi">。</em></p></div></div>    
</body>
</html>