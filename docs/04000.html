<html>
<head>
<title>Dynamic Programming (DP) AN Efficient Way 😎</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动态规划是一种有效的方法😎</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/dynamic-programming-dp-an-efficient-way-3ad561f27f22?source=collection_archive---------1-----------------------#2021-01-13">https://blog.devgenius.io/dynamic-programming-dp-an-efficient-way-3ad561f27f22?source=collection_archive---------1-----------------------#2021-01-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="215b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">举例说明。只要看一看，让我知道你的想法！</p><h1 id="93db" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">概观</h1><p id="e131" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi ll translated"><span class="l lm ln lo bm lp lq lr ls lt di"> D </span>动态编程和<strong class="jm io">记忆</strong>协同工作。<strong class="jm io">动态编程</strong>和<strong class="jm io">分治</strong>的主要区别在于，在后者的情况下，子问题<strong class="jm io">是独立的</strong>，而在DP中，子问题可以有<strong class="jm io">重叠。</strong></p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi lu"><img src="../Images/29756fae00a5ddb5334e31fb2a72c722.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yVXDmshUBpiu15IP0FmaQQ.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">来自unDraw</figcaption></figure><blockquote class="mk ml mm"><p id="d5e0" class="jk jl mn jm b jn jo jp jq jr js jt ju mo jw jx jy mp ka kb kc mq ke kf kg kh ig bi translated">通过使用<strong class="jm io">记忆</strong>【维护已经解决的子问题<strong class="jm io">的表】，动态编程将<strong class="jm io">指数复杂度降低到多项式</strong>复杂度(O(n 2)，O(n 3)等)。)对于很多问题。</strong></p></blockquote><h1 id="a4f4" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">动态编程的组件</h1><p id="5ce9" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">一般来说，动态编程有两个组成部分:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="c5e6" class="mw kj in ms b gy mx my l mz na">            Dynamic Programming = Recursion + Memoization</span></pre><h1 id="9651" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">动态规划策略的性质</h1><p id="1d6b" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">可以判断它是否能解决给定问题的两个动态规划特性是:</p><ul class=""><li id="d100" class="nb nc in jm b jn jo jr js jv nd jz ne kd nf kh ng nh ni nj bi translated"><strong class="jm io">最优子结构:</strong>一个问题的最优解包含子问题的最优解。</li><li id="3390" class="nb nc in jm b jn nk jr nl jv nm jz nn kd no kh ng nh ni nj bi translated"><strong class="jm io">重叠子问题:</strong>递归解决方案包含少量重复多次的不同子问题。</li></ul><blockquote class="mk ml mm"><p id="ea62" class="jk jl mn jm b jn jo jp jq jr js jt ju mo jw jx jy mp ka kb kc mq ke kf kg kh ig bi translated">L <!-- -->像贪婪和分而治之的技术一样，DP不能解决每一个问题。有些问题是任何算法技术(贪婪、分治和动态规划)都无法解决的。</p></blockquote><p id="f16d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">动态编程和直接递归的区别在于递归调用的记忆化。如果子问题是独立的，并且没有重复，那么记忆没有帮助，所以动态规划不是所有问题的解决方案。</p><h1 id="0aaa" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">动态规划方法</h1><p id="d8cd" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">基本上有两种解决动态规划问题的方法</p><ul class=""><li id="6dca" class="nb nc in jm b jn jo jr js jv nd jz ne kd nf kh ng nh ni nj bi translated">自底向上动态规划(迭代)</li><li id="8d49" class="nb nc in jm b jn nk jr nl jv nm jz nn kd no kh ng nh ni nj bi translated">自顶向下动态编程(递归)</li></ul><p id="badf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">自上而下:</strong>把给定的问题分解，开始解决。如果你看到问题已经解决了，那么只需返回保存的答案。如果还没解决，那就解决，保存答案。这通常很容易想到，也很直观。这被称为<strong class="jm io"> <em class="mn">记忆化</em> </strong>。</p><p id="e919" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">自下而上</strong> <strong class="jm io"> : </strong>分析问题，看子问题解决的顺序，从琐碎的子问题开始解决，向上朝着给定的问题解决。在这个过程中，保证在解决问题之前先解决子问题。这被称为<strong class="jm io"> <em class="mn">动态编程</em> </strong>。</p><h1 id="4e45" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">动态编程算法的例子</h1><ul class=""><li id="361f" class="nb nc in jm b jn lg jr lh jv np jz nq kd nr kh ng nh ni nj bi translated">许多字符串算法，包括最长公共子序列，最长增长子序列，最长公共子串，编辑距离。</li><li id="5635" class="nb nc in jm b jn nk jr nl jv nm jz nn kd no kh ng nh ni nj bi translated">图上的算法可以高效求解:求图中最短距离的Bellman-Ford算法，Floyd的全对最短路径算法等。</li><li id="c033" class="nb nc in jm b jn nk jr nl jv nm jz nn kd no kh ng nh ni nj bi translated">链式矩阵乘法</li><li id="e612" class="nb nc in jm b jn nk jr nl jv nm jz nn kd no kh ng nh ni nj bi translated">子集和</li><li id="cb57" class="nb nc in jm b jn nk jr nl jv nm jz nn kd no kh ng nh ni nj bi translated">0/1背包</li><li id="5a63" class="nb nc in jm b jn nk jr nl jv nm jz nn kd no kh ng nh ni nj bi translated">旅行推销员问题，等等</li></ul><h1 id="fd22" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">使用动态规划创建斐波那契数列</h1><p id="fecf" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">如果我们用nonDP写一个斐波那契数列，我们会得到一些指数复杂度。</p><p id="4533" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">自下而上的方法:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="00ff" class="mw kj in ms b gy mx my l mz na">def Fibo(n): <br/>    fibTable = [0, 1] <br/>    for i in range(2,n+ 1 ): <br/>        fibTable.append(fibTable[i-1] + fibTable[i-2]) <br/>    return fibTable[n]</span><span id="93d4" class="mw kj in ms b gy ns my l mz na">print(Fibo(10})</span></pre><p id="255a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">自上而下的方法:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="ba43" class="mw kj in ms b gy mx my l mz na">fibTable = {1: 1, 2:1}<br/>def Fibo(n):<br/>    if &lt;= 2 :<br/>        return 1 <br/>    if n in fibTable:<br/>        return fibTable[n]<br/>    else:<br/>        fibTable[n] = Fibo(n-1) + Fibo(n-2)<br/>        return fibTable[n]</span><span id="6475" class="mw kj in ms b gy ns my l mz na">print(Fibo(10))</span></pre><p id="3227" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">注:</strong> <em class="mn">斐波那契数列实现的两个版本都明显将问题复杂度降低到O(n)。这是因为如果已经计算了一个值，那么我们就不再调用子问题了。相反，我们直接从表</em> <strong class="jm io">中取其值。</strong></p><p id="89d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">时间复杂度:O(n)。空间复杂度:O(n)，对于表。</p><blockquote class="nt"><p id="5b41" class="nu nv in bd nw nx ny nz oa ob oc kh dk translated">因为我们只需要最后两个值的和，我们DONT需要存储所有的PRIVIOS值。我们可以这样改进它:</p></blockquote><pre class="od oe of og oh mr ms mt mu aw mv bi"><span id="af8c" class="mw kj in ms b gy mx my l mz na">def Fibo(n): <br/>    a, b = 0, 1 <br/>    for i in range(n): <br/>        a, b = b, a+ b <br/>    return a </span><span id="551d" class="mw kj in ms b gy ns my l mz na">print(Fibo(1O))</span></pre><p id="d2ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">时间复杂度:O(n)。空间复杂度:O(1)。</p><h1 id="4894" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">要记住的一点</h1><p id="9b1c" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">在使用DP解决问题时，尝试找出以下几点:</p><ul class=""><li id="a686" class="nb nc in jm b jn jo jr js jv nd jz ne kd nf kh ng nh ni nj bi translated">看看这些问题是如何根据子问题递归定义的。</li><li id="2f59" class="nb nc in jm b jn nk jr nl jv nm jz nn kd no kh ng nh ni nj bi translated">看看我们能否使用一些表格[记忆]来避免重复计算。</li></ul></div><div class="ab cl oi oj hr ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ig ih ii ij ik"><h1 id="a00b" class="ki kj in bd kk kl op kn ko kp oq kr ks kt or kv kw kx os kz la lb ot ld le lf bi translated">从这里去哪里</h1><blockquote class="mk ml mm"><p id="f312" class="jk jl mn jm b jn jo jp jq jr js jt ju mo jw jx jy mp ka kb kc mq ke kf kg kh ig bi translated"><em class="in">我的GitHub:</em><a class="ae ou" href="https://github.com/myawesomehub" rel="noopener ugc nofollow" target="_blank">https://github.com/myawesomehub</a></p></blockquote><p id="cab2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">我的写作:</strong> <a class="ae ou" href="https://docs.google.com/spreadsheets/d/15HwwuNHLgtw0W3TnllkAuWt0LN5ozsWfV5snf0Ky6ho/edit?usp=sharing" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">链接</strong> </a></p><p id="1e1a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">继续关注，获取更多有用的文章👍<br/>谢谢！</p></div></div>    
</body>
</html>