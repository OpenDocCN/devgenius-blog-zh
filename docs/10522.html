<html>
<head>
<title>Migrating from Dagger to Hilt</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从匕首转移到刀柄</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/migration-from-dagger-to-hilt-e6f60ccda191?source=collection_archive---------0-----------------------#2022-11-08">https://blog.devgenius.io/migration-from-dagger-to-hilt-e6f60ccda191?source=collection_archive---------0-----------------------#2022-11-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><h2 id="43eb" class="il im in bd b dl io ip iq ir is it dk iu translated" aria-label="kicker paragraph">Android 依赖注入教程</h2><div class=""/><div class=""><h2 id="b1bd" class="pw-subtitle-paragraph jt iw in bd b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk dk translated">让我们迁移到一个更好的地方！</h2></div><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/48e36457720a0ba02a9f42e3dfd131b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Ryf9-BTi5GfpKeb2.jpg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">图片由<a class="ae lb" href="https://goodheads.io/2016/03/16/dependency-injection-explained-plain-english/" rel="noopener ugc nofollow" target="_blank"> Goodheads </a>提供</figcaption></figure><p id="fa3e" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">如果你有一个庞大的代码库要处理，而且已经有好几年了，而且其中有依赖注入，那么在用 Hilt 清理注入时，似乎很难弄脏你的手。最近，我们在<a class="ae lb" href="https://sheroes.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="le ix"> S </strong>英雄</a>中遇到了类似的情况，我们不得不从匕首到剑柄迁移我们的代码库。</p><p id="2565" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">在本文中，我们将看到我们如何在<a class="ae lb" href="https://sheroes.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="le ix"> SHEROES </strong> </a>应用中完全移植依赖注入。</p></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><h1 id="33cd" class="mf mg in bd mh mi mj mk ml mm mn mo mp kc mq kd mr kf ms kg mt ki mu kj mv mw bi translated">目标状态</h1><p id="d12f" class="pw-post-body-paragraph lc ld in le b lf mx jx lh li my ka lk ll mz ln lo lp na lr ls lt nb lv lw lx ig bi translated">显然，我们不能在一开始就立即进行迁移，因为我们不希望我们的代码中断，而是在我们一步一步地迁移部分代码时继续工作。</p><p id="70f6" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">我们的目标将按以下顺序排列</p><ul class=""><li id="c6f7" class="nc nd in le b lf lg li lj ll ne lp nf lt ng lx nh ni nj nk bi translated">从所有类的注入中消除 Dagger 生成的 AppComponent 依赖</li><li id="7e25" class="nc nd in le b lf nl li nm ll nn lp no lt np lx nh ni nj nk bi translated">使 Activities/Fragments/Views 类成为我们通过 Hilt 注入的入口点，并从 Application 类中删除 AppComponent</li><li id="0e64" class="nc nd in le b lf nl li nm ll nn lp no lt np lx nh ni nj nk bi translated">我们将为不被 Hilt 直接支持的类提供入口点</li></ul></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><h1 id="f075" class="mf mg in bd mh mi mj mk ml mm mn mo mp kc mq kd mr kf ms kg mt ki mu kj mv mw bi translated">移民</h1><h2 id="20d8" class="nq mg in bd mh nr ns dn ml nt nu dp mp ll nv nw mr lp nx ny mt lt nz oa mv it bi translated">第一步</h2><p id="4994" class="pw-post-body-paragraph lc ld in le b lf mx jx lh li my ka lk ll mz ln lo lp na lr ls lt nb lv lw lx ig bi translated">我们首先消除 dagger 单例组件的依赖性，并通过 Hilt 单例组件提供它们。这就是它在应用程序类中的呈现方式。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="9977" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">这个 AppComponent 类如下所示:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="aa27" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">现在，我们首先为 app 组件创建另一个接口，名为<em class="od"> AppModuleComponent </em>，并通过 Hilt 组件提供单例模块。我们还用<em class="od"> @EntryPoint </em>和<em class="od"> @InstallIn </em>注释了旧的<em class="od"> SheroesAppComponent </em>接口，如下所示:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="8a38" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">其他一切暂时保持不变。但是如果我们在这个时间点上构建这个项目，那么我们将会得到一个异常，声明由于 Hilt 的期望，所有的 Hilt 模块都应该提供 InstallIn。</p><p id="d148" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">在迁移完全完成之前，我们可以通过在应用程序 Gradle 文件中添加以下行来避免这种异常。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="c7aa" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">现在我们已经更新了从<em class="od"> SheroesApplication </em>类中的 dagger 获取应用组件对象的方式</p><p id="f411" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">从</p><pre class="km kn ko kp gt oe of og oh aw oi bi"><span id="5907" class="nq mg in of b gy oj ok l ol om">mSheroesAppComponent = DaggerSheroesAppComponent.builder().build();</span></pre><p id="2cfe" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">到</p><pre class="km kn ko kp gt oe of og oh aw oi bi"><span id="55a8" class="nq mg in of b gy oj ok l ol om">mSheroesAppComponent = EntryPointAccessors.<em class="od">fromApplication</em>(<em class="od">this</em>, SheroesAppComponent::<em class="od">class</em>.java)</span></pre><p id="01ad" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">当我们在这个时间点构建我们的项目时，我们没有出现任何错误，一切都照常运行。我们已经从 Hilt 提供了我们的应用组件依赖。</p><p id="0185" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">从这里，我们现在进入下一步。</p><h2 id="f375" class="nq mg in bd mh nr ns dn ml nt nu dp mp ll nv nw mr lp nx ny mt lt nz oa mv it bi translated">第二步</h2><p id="043e" class="pw-post-body-paragraph lc ld in le b lf mx jx lh li my ka lk ll mz ln lo lp na lr ls lt nb lv lw lx ig bi translated">现在，我们开始用<em class="od">@ Android identry point</em>标记我们的活动/片段/视图/非视图注入类，并通过这些类中的 app 组件移除注入。</p><p id="f413" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">对我们来说，一个被注入了匕首的活动如下</p><pre class="km kn ko kp gt oe of og oh aw oi bi"><span id="e224" class="nq mg in of b gy oj ok l ol om"><em class="od">class </em>HomeActivity: AppCompatActivity() {<br/>    @override onCreate(bundle: Bundle) {<br/>        SheroesApplication.getAppComponent(<em class="od">this</em>).inject(<em class="od">this</em>);<br/>    }<br/>}</span></pre><p id="cc45" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">我们用<em class="od">@ Android identry point</em>注释了这个活动，并通过 app 组件移除了这个注入。</p><pre class="km kn ko kp gt oe of og oh aw oi bi"><span id="a58a" class="nq mg in of b gy oj ok l ol om"><em class="od">@AndroidEntryPoint<br/>class </em>HomeActivity: AppCompatActivity() {</span><span id="513a" class="nq mg in of b gy on ok l ol om">    @Inject<br/>    appUtils: AppUtils()</span><span id="3c9a" class="nq mg in of b gy on ok l ol om">    @override onCreate(bundle: Bundle) {<br/>        // no injection code required now<br/>    }<br/>}</span></pre><p id="eeb0" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">我们在所有的视图类中一步一步地这样做，并在每个阶段验证它。然后我们也从<em class="od"> SheroesAppComponent </em>接口中移除了相同的注入类。</p><p id="50b2" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">这样，我们从所有视图类中消除了应用程序组件注入。</p><h2 id="3381" class="nq mg in bd mh nr ns dn ml nt nu dp mp ll nv nw mr lp nx ny mt lt nz oa mv it bi translated">第三步</h2><p id="dec8" class="pw-post-body-paragraph lc ld in le b lf mx jx lh li my ka lk ll mz ln lo lp na lr ls lt nb lv lw lx ig bi translated">现在开始支持那些没有被 Hilt 直接支持的类。例如，util 类、视图容器、适配器等等。</p><p id="56e9" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">我们有使用 Dagger 注入的视图持有者和工具类。那么如何为这样的类提供依赖呢？希尔特也有办法做到这一点。</p><p id="71ac" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">作为参考，考虑以下带有 Dagger 注入的 ViewHolder 类。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="3515" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">为了给这些类提供依赖关系，我们创建了一个入口点接口，并定义了这个类需要的所有依赖关系。对于上述视图持有者类别，它需要用户偏好。因此，我们的入口点将如下所示</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="2360" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">现在，我们通过这个入口点向视图持有者提供依赖，如下所示</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="bcc4" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">Bamn！依赖项已注入。建立了项目，一切都像以前一样好。</p><p id="9d35" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">这里还要注意，我们从 activity reference 访问我们的入口点，因为我们将它安装在<em class="od"> ActivityComponent </em>中。所以我们需要确定我们安装的入口点是哪个组件，我们应该从同一个引用中提取它。</p><h2 id="39e2" class="nq mg in bd mh nr ns dn ml nt nu dp mp ll nv nw mr lp nx ny mt lt nz oa mv it bi translated">第四步</h2><p id="8018" class="pw-post-body-paragraph lc ld in le b lf mx jx lh li my ka lk ll mz ln lo lp na lr ls lt nb lv lw lx ig bi translated">我们还需要确保我们现有的所有模块，如网络模块、数据库模块等也应该安装在使用<em class="od"> @InstallIn </em>注释的 Hilt 组件中。这样，我们几乎已经完成了迁移，只剩下最后一步了。</p><h2 id="f886" class="nq mg in bd mh nr ns dn ml nt nu dp mp ll nv nw mr lp nx ny mt lt nz oa mv it bi translated">第五步</h2><p id="05fa" class="pw-post-body-paragraph lc ld in le b lf mx jx lh li my ka lk ll mz ln lo lp na lr ls lt nb lv lw lx ig bi translated">是时候清理残渣了。我们删除了</p><ul class=""><li id="ca44" class="nc nd in le b lf lg li lj ll ne lp nf lt ng lx nh ni nj nk bi translated">旧 AppComponent 接口</li><li id="9b2d" class="nc nd in le b lf nl li nm ll nn lp no lt np lx nh ni nj nk bi translated">来自我们的应用程序类的 AppComponent 引用</li><li id="0ddb" class="nc nd in le b lf nl li nm ll nn lp no lt np lx nh ni nj nk bi translated">app gradle 中的编译警告行</li></ul><p id="76c3" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">最后，构建了项目，一切都像以前一样工作。但是一定要确保运行和测试受迁移影响的应用程序的每个部分，因为如果任何依赖项丢失或没有正确提供，Hilt 将抛出运行时异常。</p></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><p id="484b" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">是的。我们已经把我们的<a class="ae lb" href="https://sheroes.com/" rel="noopener ugc nofollow" target="_blank"> SHEROES </a>应用程序的代码从匕首移植到了刀柄。您可能在您的项目中有不同的设置，但是您可以在短时间内了解如何在不破坏现有流程的情况下完成它。</p><p id="be0a" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">如果你有任何现有的匕首项目，那么是时候使用刀柄了。</p></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><h1 id="b57e" class="mf mg in bd mh mi mj mk ml mm mn mo mp kc mq kd mr kf ms kg mt ki mu kj mv mw bi translated">目前就这些了！敬请期待！</h1><p id="bd39" class="pw-post-body-paragraph lc ld in le b lf mx jx lh li my ka lk ll mz ln lo lp na lr ls lt nb lv lw lx ig bi translated">与我联系(如果内容对您有帮助),请访问</p><ul class=""><li id="1eab" class="nc nd in le b lf lg li lj ll ne lp nf lt ng lx nh ni nj nk bi translated"><a class="ae lb" href="https://saurabhpant.medium.com/" rel="noopener">中等</a></li><li id="9b9d" class="nc nd in le b lf nl li nm ll nn lp no lt np lx nh ni nj nk bi translated"><a class="ae lb" href="https://github.com/aqua30" rel="noopener ugc nofollow" target="_blank"> GitHub </a></li><li id="cccb" class="nc nd in le b lf nl li nm ll nn lp no lt np lx nh ni nj nk bi translated"><a class="ae lb" href="https://twitter.com/saurabh30pant" rel="noopener ugc nofollow" target="_blank">推特</a></li><li id="d255" class="nc nd in le b lf nl li nm ll nn lp no lt np lx nh ni nj nk bi translated"><a class="ae lb" href="https://www.linkedin.com/in/saurabh-pant-44619057/" rel="noopener ugc nofollow" target="_blank">领英</a></li></ul><p id="2982" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">订阅电子邮件，同步了解更多关于 Android/IOS/Backend/Web 的有趣话题。</p><p id="25e1" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">直到下一次…</p><p id="75b4" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">干杯！</p></div></div>    
</body>
</html>