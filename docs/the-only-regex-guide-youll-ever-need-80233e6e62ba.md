# 您需要的唯一正则表达式指南

> 原文：<https://blog.devgenius.io/the-only-regex-guide-youll-ever-need-80233e6e62ba?source=collection_archive---------6----------------------->

正则表达式是关联文本中字符序列的字符模式。我们可以使用正则表达式来提取或替换部分文本，以及在 HTML 页面中寻址或链接图像，修改文本格式或删除无效字符。

在本文中，我们将了解以下主题及更多内容:

*   [正则表达式是如何构造的？](#204b)
*   [正则表达式的元素是什么？](#2830)
*   如何在 Javascript 中使用正则表达式？
*   **奖励:** [最有用的正则表达式清单](#1bf3)

我们开始吧！👇

![](img/a60e5ad232ead4373714ee0897316427.png)

布莱克·康纳利在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

# RegEx 是如何构造的？

正则表达式基本上由 3 部分组成:

1.  正则表达式本身，负责定义要匹配的模式
2.  数据输入，它构成了将接受正则表达式操作的数据
3.  引擎，它负责应用表达式

例如:假设我们需要一个正则表达式**来验证一封邮件。**在这种情况下，我们将拥有以下组件:

1.  正则表达式将描述有效电子邮件的**模式**
2.  数据输入将是用户通知的**电子邮件，以进行验证**
3.  引擎将是用于应用表达式的编程语言

# 如何创建正则表达式？

正则表达式必须用斜杠(/)括起来。并且在表达式之后，可能会有一些执行指示叫做**标志**。

```
/meta-characters/[flags]
```

标志用于提供引擎在执行正则表达式时使用的特殊参数。标志是可选的，将被执行正则表达式的引擎接受或拒绝。

最常见的标志是:

*   **i(忽略大小写)** —不应考虑大写和小写字符之间的差异。
*   **g(全局源)** —在数据输入时启用全局数据捕获，以及保存出现索引并允许在它们之间导航(即，如果您的输入匹配多次，使用此标志您将得到所有结果，否则将只返回第一个匹配)
*   **m(多行)** —通知条目由多行组成，导致正则表达式应用于每一行。

# 元字符是什么？

元字符是在正则表达式中有意义的特殊字符。它们用于告诉引擎如何解析输入数据。正则表达式由一组元字符组成。

每个元角色**都有一个特定的功能**，这个功能根据情况而变化。您可以创建许多组合，并使用这些组合来执行更复杂的表达式。

让我们看看最常用的元字符:

## 开始(^)和结束(美元)

> **^(开始)** —表示正则表达式中行的开始。语法:`/^<....>/`
> 
> **$(end)**-表示正则表达式中的行尾。语法:`/<...>$/`

**例 1:**

*   正则表达式:`/^[1,9]/g`
*   输入:`0,1,2,3,4`

在这里**没有匹配的**，因为正则表达式搜索的是以 1 到 9 之间的字符开始**的一行。**

**例 2:**

*   正则表达式:`/^[1,9]/g`
*   输入:`1,2,3,4,5`
*   匹配:`1`

这里**有一个匹配**，因为输入从数字 1 开始。

**例 3:**

*   正则表达式:`/[1,9]$/g`
*   输入:`1,2,3,4,5`
*   火柴:`5`

**也是一个匹配**，但是使用了行尾，所以它匹配数字 5。

## 字符组([和])

> **[(组的开始)** —表示一个字符组的开始。语法:`/[<....>]/`
> 
> **](组尾)** —表示字符组的结束。语法:`/[<...>$]/`

**示例:**

想象一下，我们希望得到姓名“John”的所有匹配项，不管它们是大写还是小写。然后我们需要告诉引擎第一个字符可以是“J”或“J”。

*   正则表达式:`/[J,j]ohn/g`
*   输入:

```
john
John
johN
joseph
```

*   匹配:`john`，`John`

## 点(。)

> **。(通配符)** —表示任何其他字符。语法:`/./`

**示例:**

假设我们想得到所有有四个字母并以后缀“and”结尾的单词。

*   正则表达式:`/.and/g`
*   输入:

```
Sand
Same
Wand
Land
Brand
```

*   匹配:`sand`、`wand`、`land`

## 逻辑运算符 AND(。*)

> **。* (AND)** —在两个表达式之间进行逻辑运算。语法:`/<exp-1>.*<exp-2>/`

**例如:**

假设我们想得到所有以元音字母开头和结尾的名字。

*   正则表达式:`/[AEIOU].*[aeiou]/g`
*   输入:

```
Amira
Anna
Laura
Sophie
Olivia
```

*   匹配:`Amira`、`Anna`、`Olivia`

## 逻辑运算符 OR (|)

> **| (OR)** —在两个表达式之间进行逻辑或运算。语法:`*/<exp-1>|<exp-2>/*`

**例如:**

假设我们希望从一个数据输入中获得所有大型商店(超大型或大型)。

*   正则表达式:`/^(super|mega)store/gm`
*   输入:

```
superstore
ministore
megastore
```

*   火柴:`superstore`，`megastore`

## 逻辑运算符 NOT (^)

> ^ **(NOT)** —在表达式前进行逻辑运算 NOT。语法:`*/[*^<exp>]*/*`

**例如:**

假设我们想得到所有不以元音开头的名字。

*   正则表达式:`/^[^AEIOU].*/gm`
*   输入:

```
Amanda
Sam
John
Anna
```

*   匹配:`Sam`，`John`

## 大括号({和})

> **{}(重复)** —允许您检测表达式重复 n 次或在一个范围内。语法:`*/<exp>{min, max}/*`

**例如:**

让我们写一个表达式，得到以**和**结尾的 7 个字母的所有单词。

*   正则表达式:`/^.{7}nd*/gm`
*   输入:

```
Command
Rebound
Mustard
Executive
Inbound
```

*   匹配:`Command`、`Rebound`、`Inbound`

## 加号(+)

> **+ (1 次或多次)** —检查左侧的字符在输入中是否至少出现一次。语法:`*/<exp>+/*`

**示例:**

让我们写一个表达式来获得字符“c”的所有出现。

*   正则表达式:`/a+/gm`
*   输入:

```
Music
Book
Technology
Success
```

*   火柴:`Musi**c**`、`Te**c**hnology`、`Su**cc**ess`

## 问号(？)

> **？(0 或 1 次出现)** —检查左边的字符在输入中是出现 0 次还是至少出现一次。使其成为可选的。语法:`*/<exp>?/*`

**例:**

想象一下，我们想得到单词 car 的单数或复数形式，但没有拼错。

*   RegEx: `/^car[s]?$/gm`
*   输入:

```
car
cars
carz
```

*   比赛:`car`、`cars`

## 星号(*)

> *** (0 次或多次)**-检查输入中左边的字符出现了 0 次还是多次。语法:`*/<exp>*/*`

**例:**

想象一下，我们想让“嘿”这个词和这个人写的“y”一样多。

*   RegEx: `/^hey*$/gm`
*   输入:

```
hey
heyy
heyyy
heyhey
```

*   匹配:`hey`、`heyy`、`heyyy`

## 连字符(-)

> **-(间隔)**-检查与字符间隔相对应的匹配项。语法:`*/[<start>-<end>]/*`

**示例:**

想象一下，我们想要得到从字母 A 到 m 的所有名字。

*   RegEx: `/^[A-M].*$/gm`
*   输入:

```
Amanda
Nate
Joe
Clark
```

*   匹配:`Amanda`、`Joe`、`Clark`

## 字母数字和非字母数字(\w 和\W)

> **\w(字母数字)**-检查字母数字字符和下划线。语法:`*/\w/*`
> 
> **\W(非字母数字)**-检查是否存在非字母数字字符(如特殊字符)。语法:`*/\W/*`

**示例:**

*   RegEx: `/\w/gm`
*   输入:

```
Test
1234
Test_123
Test$%Test
$%&*&
```

*   匹配:`Test`、`1234`、`Test_123`、`**Test**$%**Test**`

## 数字和非数字(\d 和\D)

> **\d(数字)**-检查代表数字的字符。语法:`*/\d/*`
> 
> **\D(非数字)**-检查非数字字符。语法:`*/\D/*`

**示例:**

*   RegEx: `/\d/gm`
*   输入:

```
123
Test
Test_123
```

*   匹配:`123`、`Test_**123**`

## 空间和非空间(\s 和\S)

> **\s(空格)**-检查与空格(空格、制表符、换行符和回车)对应的字符。语法:`*/\s/*`
> 
> **\S(非数字)** —检查非空格字符。语法:`*/\S/*`

## 捕获和非捕获组(“()”和“(？:)")

> **()(捕获组)** —对要捕获的字符序列进行分组。使用这个元字符时会产生子匹配。语法:`*/(<characters>)/*`
> 
> **(？:)(非捕获组)** —对不应被捕获的字符序列进行分组。语法:`*/(?:<characters>)/*`

# Javascript 中如何使用正则表达式？

在 Javascript 中，正则表达式是 RegExp 类的对象。我们可以用两种方式来定义它:

## 文字形式:

```
const myExpression = /test/;
```

**使用 RegExp 构造函数:**

```
const myExpression = new RegExp('test');
```

然后，我们可以开始使用我们的表达式，假设我们想在一个字符串中找到一个匹配:

```
const newRE = /d(b+)d/g;
const matches = newRE.exec('cdbbdbsbz');
```

## 正则表达式方法

创建正则表达式后，我们可以使用一些方法，下面是其中的一些:

*   **exec()** — 在字符串中搜索匹配项并返回结果数组

```
const myExp = RegExp('foo*', 'g');
myExp.exec('table football, foosball');
```

*   **test()** —在字符串中搜索匹配项并返回`true`或`false`

```
const str = 'table football';
const regex = new RegExp('foo*');regex.test(str); // true
```

*   **match()** —在字符串中搜索匹配项并返回结果数组

```
const paragraph = 'The quick brown fox was named Mary.';
const regex = /[A-Z]/g;
const found = paragraph.match(regex);console.log(found); // Array ["T", "M"]
```

*   **search()** —搜索正则表达式之间的匹配，并返回匹配的索引

```
const paragraph = 'The quick brown fox jumps over the lazy dog. If the dog barked, was it really lazy?';// any character that is not a word character or whitespace
const regex = /[^\w\s]/g;console.log(paragraph.search(regex)); // 43
```

*   **replace()** —返回一个新字符串，其中一个、一些或所有匹配的模式被替换

```
const text = 'The quick brown fox jumps over the lazy dog. If the dog reacted, was it really lazy?';const regex = /Dog/i;
console.log(text.replace(regex, 'ferret'));
// "The quick brown fox jumps over the lazy ferret. If the dog reacted, was it really lazy?"
```

# 最常用正则表达式的备忘单

*   电子邮件

```
^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$
```

*   电子邮件(但仅限 Gmail 和 Hotmail)

```
^([\w\-\.]+@(?!gmail.com)(?!hotmail.com)([\w\- ]+\.)+[\w-]{2,4})?$
```

*   资源定位符

```
^(?:http(s)?:\/\/)?[\w.-]+(?:\.[\w\.-]+)+[\w\-\._~:/?#[\]@!\$&'\(\)\*\+,;=.]+$
```

*   电话和手机号码

```
(\(?([\d \-\)\–\+\/\(]+)\)?([ .\-–\/]?)([\d]+))
```

*   修剪字符串

```
^[\s]*(.*?)[\s]*$
```

*   IP 地址；网络地址

```
^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$
```

*   用户名(1-15 个字母数字字符)

```
^(?=.*[a-zA-Z]{1,})(?=.*[\d]{0,})[a-zA-Z0-9]{1,15}$
```

# 结论

今天到此为止。这是一篇很长的文章，但是我真的希望这篇文章可以帮助你使用正则表达式，并且你可以在将来编写新的表达式时使用它作为指导。

感谢阅读！在本平台关注我，阅读更多开发内容。祝您愉快，再见！👋