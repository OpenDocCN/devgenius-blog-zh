<html>
<head>
<title>Controller, Service, and Repository Layer Unit Testing using JUnit and Mockito</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用JUnit和Mockito进行控制器、服务和存储库层单元测试</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/spring-boot-deep-dive-on-unit-testing-92bbdf549594?source=collection_archive---------0-----------------------#2021-04-06">https://blog.devgenius.io/spring-boot-deep-dive-on-unit-testing-92bbdf549594?source=collection_archive---------0-----------------------#2021-04-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9b66" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">软件测试的主要目标是给软件以信心。—匿名。</h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/64980f683b79f6f54b11ab7125a24120.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ip6rXLNbuUWYQYSu"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated"><a class="ae kw" href="https://unsplash.com/@freestocks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">自由股</a>在<a class="ae kw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="8ad7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">单元测试</strong>是一种软件测试，其中测试软件的单个单元或组件。目的是验证软件代码的每个单元都如预期的那样执行。</p><p id="6310" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">单元测试由开发人员在应用程序的开发(编码阶段)过程中完成。</p><p id="d44a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">今天，我将涵盖以下主题</p><ol class=""><li id="41a5" class="lt lu iq kz b la lb ld le lg lv lk lw lo lx ls ly lz ma mb bi translated">软件测试的重要性，测试驱动开发(TDD)基础，以及测试用例的各个方面</li><li id="9e12" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">测试用例相关术语的细节:单元测试、集成测试、模仿、刺探、存根</li><li id="b0aa" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">在spring boot apps控制器、服务和存储库层单元测试中</li><li id="fe0a" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">编写可测试代码的技巧</li><li id="4482" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">共享代码库和相关文件</li></ol><h2 id="c8de" class="mh mi iq bd mj mk ml dn mm mn mo dp mp lg mq mr ms lk mt mu mv lo mw mx my mz bi translated"><strong class="ak">先决条件</strong></h2><p id="af5f" class="pw-post-body-paragraph kx ky iq kz b la na jr lc ld nb ju lf lg nc li lj lk nd lm ln lo ne lq lr ls ij bi translated">在开始本教程之前，您必须了解关于spring boot和JPA的详细信息。要了解这一点，你可以阅读我下面的文章。</p><div class="nf ng gp gr nh ni"><a href="https://mesukcse08.medium.com/spring-data-jpa-a-to-z-6c957ed17a66" rel="noopener follow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">深入探讨Spring Boot和JPA实施:从头到尾</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">Spring Data JPA是更大的Spring Data家族的一部分，它使得实现基于JPA的存储库变得很容易。</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">mesukcse08.medium.com</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw kq ni"/></div></div></a></div></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><h2 id="676b" class="mh mi iq bd mj mk ml dn mm mn mo dp mp lg mq mr ms lk mt mu mv lo mw mx my mz bi translated"><strong class="ak">软件测试的重要性，测试驱动开发(TDD)基础，以及测试用例的各个方面</strong></h2><p id="0f66" class="pw-post-body-paragraph kx ky iq kz b la na jr lc ld nb ju lf lg nc li lj lk nd lm ln lo ne lq lr ls ij bi translated">测试用例是一组特定的指令，测试人员应该遵循这些指令来实现特定的输出。牢记客户提供的需求，记录测试用例。测试用例的主要目的是确保应用程序中的不同特性是否如预期的那样工作。它帮助测试人员验证软件是否没有缺陷，是否按照最终用户的期望工作。测试用例的其他好处包括:</p><ul class=""><li id="96e0" class="lt lu iq kz b la lb ld le lg lv lk lw lo lx ls oe lz ma mb bi translated">测试用例确保良好的测试覆盖率</li><li id="acf6" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls oe lz ma mb bi translated">帮助提高软件质量</li><li id="dc1a" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls oe lz ma mb bi translated">降低维护和软件支持成本</li><li id="77d9" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls oe lz ma mb bi translated">帮助验证软件是否满足最终用户的要求</li><li id="377a" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls oe lz ma mb bi translated">单元测试是产品的一种活文档。为了了解一个模块或另一个模块提供了什么功能，开发人员可以参考单元测试来获得模块和系统整体逻辑的基本情况</li><li id="f719" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls oe lz ma mb bi translated">允许测试人员彻底思考并从尽可能多的角度进行测试</li><li id="368a" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls oe lz ma mb bi translated">测试用例在未来是可重用的——任何人都可以引用它们并执行测试。</li><li id="0b5b" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls oe lz ma mb bi translated">最佳实践建议开发人员首先在本地运行所有单元测试或一组测试，以确保任何编码更改不会中断现有代码。</li><li id="6b26" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls oe lz ma mb bi translated">然而，考虑到人的因素:开发人员可能会在做出更改后忘记运行单元测试，并将潜在的无效代码提交到公共分支。为了避免这种情况，许多公司采用了持续开发的方法。持续集成工具用于此，允许开发人员自动运行单元测试。因此，代码中任何不想要的变化都会被一台冷的逻辑机器检测到。</li></ul><h2 id="f9f9" class="mh mi iq bd mj mk ml dn mm mn mo dp mp lg mq mr ms lk mt mu mv lo mw mx my mz bi translated"><strong class="ak">测试驱动开发(TDD) </strong></h2><p id="c959" class="pw-post-body-paragraph kx ky iq kz b la na jr lc ld nb ju lf lg nc li lj lk nd lm ln lo ne lq lr ls ij bi translated"><strong class="kz ir">测试驱动开发(TDD) </strong>是一种软件开发方法，在这种方法中，开发测试用例来指定和验证代码将做什么。简而言之，首先创建并测试每个功能的测试用例，如果测试失败，则编写新代码以通过测试，并使代码简单且无错误。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi of"><img src="../Images/9dee4b716a7c04b07615d9335d871577.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*5HsfElr8niWGLqCNXc0Asg.png"/></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">图片来自:【https://www.guru99.com/test-driven-development.html T4】</figcaption></figure><p id="ef77" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">测试驱动开发从为应用程序的每个小功能设计和开发测试开始。TDD指导开发人员只有在自动化测试失败时才编写新代码。这避免了代码的重复。TDD的完整形式是测试驱动开发。</p><p id="4845" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">TDD的简单概念是在编写新代码之前(开发之前)编写并纠正失败的测试。这有助于避免代码的重复，因为我们一次只写少量的代码来通过测试。(测试只不过是我们需要测试来实现的需求条件)。</p><h2 id="6991" class="mh mi iq bd mj mk ml dn mm mn mo dp mp lg mq mr ms lk mt mu mv lo mw mx my mz bi translated">测试用例包含哪些方面？</h2><p id="8a0e" class="pw-post-body-paragraph kx ky iq kz b la na jr lc ld nb ju lf lg nc li lj lk nd lm ln lo ne lq lr ls ij bi translated">测试用例主要包含以下部分</p><ul class=""><li id="2966" class="lt lu iq kz b la lb ld le lg lv lk lw lo lx ls oe lz ma mb bi translated">目标<strong class="kz ir"><br/></strong>这里测试人员提到了他计划用那个特定的测试用例实现什么。测试人员必须拥有该代码单元的端到端业务逻辑。</li><li id="17dd" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls oe lz ma mb bi translated"><strong class="kz ir">先决条件<br/> </strong>此处应列出适用于测试的任何假设以及执行测试前必须满足的任何先决条件。任何依赖项、任何预初始化都必须留在这里。</li><li id="dc1c" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls oe lz ma mb bi translated"><strong class="kz ir">测试用例步骤<br/> </strong>这里测试人员提到了实现目标需要遵循的步骤。测试步骤应该包括关于如何执行测试的必要数据和信息。这些步骤应该清晰简洁，不遗漏重要的事实。</li><li id="9b40" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls oe lz ma mb bi translated"><strong class="kz ir">测试数据<br/>选定的数据集必须涵盖所有可能的正面和负面情景/案例。增加测试用例的数量，以确保更高的软件稳定性。</strong></li><li id="afb3" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls oe lz ma mb bi translated"><strong class="kz ir">预期和实际结果<br/> </strong>测试人员必须清楚地了解业务逻辑和数据行为。预期的结果告诉测试人员，作为测试步骤的结果，他们应该经历什么。它们还指定了测试用例执行时应用程序的实际行为。</li><li id="87d2" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls oe lz ma mb bi translated"><strong class="kz ir">通过/失败<br/> </strong>如果测试人员未能按照步骤实现“预期输出”,那么他将针对该特定测试用例提及“失败”。类似地，如果测试人员能够达到“预期的输出”，那么他会提到“通过”测试用例。</li></ul><h2 id="f271" class="mh mi iq bd mj mk ml dn mm mn mo dp mp lg mq mr ms lk mt mu mv lo mw mx my mz bi translated">2.测试用例相关术语详情:单元测试、集成测试、模仿、刺探、存根</h2><ul class=""><li id="c868" class="lt lu iq kz b la na ld nb lg og lk oh lo oi ls oe lz ma mb bi translated"><strong class="kz ir">单元测试</strong></li></ul><ol class=""><li id="5145" class="lt lu iq kz b la lb ld le lg lv lk lw lo lx ls ly lz ma mb bi translated">单元测试是一种软件测试，其中测试软件的单个单元或组件。</li><li id="4ec0" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">目的是验证软件代码的每个单元都如预期的那样执行。</li><li id="5ee8" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">单元测试由开发人员在应用程序的开发(编码阶段)过程中完成。</li><li id="94a0" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">单元测试隔离一段代码并验证其正确性。</li><li id="53f4" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">单元可以是单独的函数、方法、过程、模块或对象。</li></ol><ul class=""><li id="329e" class="lt lu iq kz b la lb ld le lg lv lk lw lo lx ls oe lz ma mb bi translated"><strong class="kz ir">集成测试</strong></li></ul><ol class=""><li id="7c2f" class="lt lu iq kz b la lb ld le lg lv lk lw lo lx ls ly lz ma mb bi translated"><strong class="kz ir">集成测试</strong>被定义为一种测试类型，其中软件模块被逻辑集成并作为一组进行测试</li><li id="7be8" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">这一级别的测试的目的是在集成这些软件模块时，暴露它们之间交互中的缺陷</li><li id="8978" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">集成测试侧重于检查这些模块之间的数据通信。</li><li id="47ba" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">它处理软件需求规范/数据和软件设计文档中规定的高级和低级软件需求的验证。</li></ol><ul class=""><li id="b354" class="lt lu iq kz b la lb ld le lg lv lk lw lo lx ls oe lz ma mb bi translated"><strong class="kz ir"> jUnit </strong></li></ul><ol class=""><li id="c540" class="lt lu iq kz b la lb ld le lg lv lk lw lo lx ls ly lz ma mb bi translated">JUnit是一个开源的JAVA单元测试框架。对于Java开发人员来说，编写和运行可重复的测试是很有用的。</li><li id="00f2" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">顾名思义，它用于一小块代码的单元测试。</li><li id="a824" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">在java中，TestNG也是jUnit的一个很好的替代品</li></ol><ul class=""><li id="8033" class="lt lu iq kz b la lb ld le lg lv lk lw lo lx ls oe lz ma mb bi translated"><strong class="kz ir">嘲讽</strong></li></ul><ol class=""><li id="0957" class="lt lu iq kz b la lb ld le lg lv lk lw lo lx ls ly lz ma mb bi translated">模仿是从单元测试中移除外部依赖的行为，目的是围绕它创建一个受控的环境。</li><li id="94db" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">当被测试的单元具有外部依赖性时，模仿是单元测试中使用的过程。</li><li id="dd7b" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">模仿的目的是隔离并关注被测试的代码，而不是外部依赖的行为或状态。</li><li id="65a8" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">在模拟中，依赖关系被模拟真实对象行为的严密控制的替换对象所替代。</li></ol><p id="946e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">通常，我们模拟所有其他与我们想要测试的类交互的类。嘲讽的常见目标是:</p><ul class=""><li id="47c1" class="lt lu iq kz b la lb ld le lg lv lk lw lo lx ls oe lz ma mb bi translated">数据库连接，</li><li id="e8eb" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls oe lz ma mb bi translated">网络服务，</li><li id="d4dc" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls oe lz ma mb bi translated">速度慢的课程，</li><li id="0d2e" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls oe lz ma mb bi translated">有副作用的类，以及</li><li id="7140" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls oe lz ma mb bi translated">具有不确定行为的类。</li><li id="cc0e" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls oe lz ma mb bi translated">具有遗留代码且不可测试的类/方法</li><li id="4250" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls oe lz ma mb bi translated">模仿和存根是替代这些外部依赖的假Java类。然后，在测试开始之前，这些假类会按照您预期的方式运行。</li></ul><ol class=""><li id="94c4" class="lt lu iq kz b la lb ld le lg lv lk lw lo lx ls ly lz ma mb bi translated">存根是一个伪类，带有预编程的返回值。</li><li id="98ad" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated"><strong class="kz ir"> Stubbing </strong>意味着用产生硬编码响应的版本替换一个方法、函数或整个对象。</li><li id="fbd9" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">这通常用于将组件彼此隔离，并将您的代码与外界隔离。</li><li id="a147" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">它被注入到被测试的类中，让您可以绝对控制作为输入被测试的内容。</li><li id="e35e" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">典型的存根是一个数据库连接，它允许您在没有真实数据库的情况下模拟任何场景。</li><li id="0af1" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">例如，存根经常用于将测试从存储系统中分离出来，并将HTTP请求的结果硬编码到依赖于来自互联网的数据的测试代码中。</li></ol><ul class=""><li id="89d2" class="lt lu iq kz b la lb ld le lg lv lk lw lo lx ls oe lz ma mb bi translated"><strong class="kz ir">刺探</strong></li></ul><ol class=""><li id="f8b8" class="lt lu iq kz b la lb ld le lg lv lk lw lo lx ls ly lz ma mb bi translated">可用于将Mockito间谍应用于Spring ApplicationContext的注释。</li><li id="4b63" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">一个间谍<em class="oj">将</em>包装在被测试类的一个<em class="oj">现有的</em>对象上。</li><li id="8bb5" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">它包含了模仿和存根两种优点</li><li id="412a" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">意思是:当你创建一个spy时，你可以决定是否应该“拦截”发送给spy的方法调用(这样你就可以像使用一个mock一样使用spy)；或者被“传递”到间谍包裹的实际物体。</li></ol></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><h2 id="a0fa" class="mh mi iq bd mj mk ml dn mm mn mo dp mp lg mq mr ms lk mt mu mv lo mw mx my mz bi translated"><strong class="ak"> 3。控制器、服务和存储库层每个术语的实际实现</strong></h2><p id="db83" class="pw-post-body-paragraph kx ky iq kz b la na jr lc ld nb ju lf lg nc li lj lk nd lm ln lo ne lq lr ls ij bi translated">在典型的项目中，遵循MVC模式，其中有一些控制器、一些服务和一些用于数据访问的存储库。在这一节，我们将写所有的层。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi ok"><img src="../Images/185f98c78607ee447637914f2990311b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I7lmEQZX6m2Ow__RtAJcBQ.png"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">图片来自<a class="ae kw" href="http://www.mitrais.com" rel="noopener ugc nofollow" target="_blank">www.mitrais.com</a></figcaption></figure><p id="b2ce" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">设置环境<br/> </strong>我们将致力于基于Gradle的项目。我们只需要三个依赖项来覆盖测试</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="b624" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们用<strong class="kz ir">spring-boot-starter-test</strong>测试框架，<strong class="kz ir"> mockito </strong>和<strong class="kz ir"> Jupiter。</strong>我们还对jpa使用了<strong class="kz ir">spring-boot-starter-data-JPA</strong>，对内存数据库使用了<strong class="kz ir"> h2database </strong>。项目结构如下所示</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi on"><img src="../Images/857c0c93d31f4fd678447040f32c2988.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZfMG_3mwbthl1-uNvnuecA.png"/></div></div></figure><p id="2004" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在这个文件夹结构中，我们将所有控制器保存在控制器包中，将服务保存在服务包中，将存储库保存在存储库包中。</p><h2 id="acc0" class="mh mi iq bd mj mk ml dn mm mn mo dp mp lg mq mr ms lk mt mu mv lo mw mx my mz bi translated"><strong class="ak"> 1。测试存储库层</strong></h2><p id="bc24" class="pw-post-body-paragraph kx ky iq kz b la na jr lc ld nb ju lf lg nc li lj lk nd lm ln lo ne lq lr ls ij bi translated">这里的库是基于spring <strong class="kz ir"> @Repository </strong>注解<strong class="kz ir">的。使用repository，我们在数据库上执行一些简单的CRUD操作。<strong class="kz ir"> </strong>下面给出我们的域类。</strong></p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="02dd" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在这个实体类中，我们主要有firstName、lastName和mobileNumber字段。为了从这个表中访问数据，我们的存储库类如下所示</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="837e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">从这个存储库类中，我们可以对实体<strong class="kz ir">客户</strong>执行CRUD操作</p><p id="2e6c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们的测试代码如下。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="d7b1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">从我们的测试用例类中，我们要知道一些关键词。</p><ol class=""><li id="4baf" class="lt lu iq kz b la lb ld le lg lv lk lw lo lx ls ly lz ma mb bi translated"><strong class="kz ir">@ extend with(mockito extension . class)</strong>:启用mockito扩展。</li><li id="d8e9" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated"><strong class="kz ir"> @DataJpaTest: </strong>将准备春季数据JPA的标注。它将支持基于实体的保存、获取和其他环境。</li><li id="76b9" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated"><strong class="kz ir"> @BeforeEach </strong>:在执行开始之前，我们可以初始化一些任务。在这里，我们保存一个默认客户。</li><li id="dd93" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated"><strong class="kz ir"> @AfterEach </strong>:执行完所有案例后，我们在这里做一些任务。在这里，我们将删除所有已更改的数据。</li></ol><p id="db6d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">保存表上的数据<br/>保存实体列表</strong>代码如下图</p><pre class="kh ki kj kk gt oo op oq or aw os bi"><span id="9243" class="mh mi iq op b gy ot ou l ov ow">&lt;S <strong class="op ir">extends </strong>Customer&gt; Iterable&lt;S&gt; saveAll(Iterable&lt;S&gt; entities);</span></pre><p id="625d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">看看测试用例</p><pre class="kh ki kj kk gt oo op oq or aw os bi"><span id="e411" class="mh mi iq op b gy ot ou l ov ow"><strong class="op ir">void </strong>saveAll_success() {<br/>    List&lt;Customer&gt; customers = Arrays.<em class="oj">asList</em>(<br/>            <strong class="op ir">new </strong>Customer(<strong class="op ir">"sajedul"</strong>, <strong class="op ir">"karim"</strong>, <strong class="op ir">"01737186095"</strong>),<br/>            <strong class="op ir">new </strong>Customer(<strong class="op ir">"nafis"</strong>, <strong class="op ir">"khan"</strong>, <strong class="op ir">"01737186096"</strong>),<br/>            <strong class="op ir">new </strong>Customer(<strong class="op ir">"aayan"</strong>, <strong class="op ir">"karim"</strong>, <strong class="op ir">"01737186097"</strong>)<br/>    );<br/>    Iterable&lt;Customer&gt; allCustomer = <strong class="op ir">customerRepository</strong>.saveAll(customers);<br/><br/>    AtomicInteger validIdFound = <strong class="op ir">new </strong>AtomicInteger();<br/>    allCustomer.forEach(customer -&gt; {<br/>        <strong class="op ir">if</strong>(customer.getId()&gt;0){<br/>            validIdFound.getAndIncrement();<br/>        }<br/>    });<br/><br/>    <em class="oj">assertThat</em>(validIdFound.intValue()).isEqualTo(3);<br/>}</span></pre><p id="1858" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这里，我们正在使用客户存储库构建3个客户对象和节约。保存数据后，我们将检查保存数据的大小。这里，有效性是指保存新数据后每个实体id必须大于0。这里正在发生真正的数据库事务。</p><p id="6b3d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">获取并匹配数据<br/> </strong>储存库获取方法如下</p><pre class="kh ki kj kk gt oo op oq or aw os bi"><span id="e4d6" class="mh mi iq op b gy ot ou l ov ow">@Override<br/>List&lt;Customer&gt; findAll();</span></pre><p id="b001" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们的测试代码如下</p><pre class="kh ki kj kk gt oo op oq or aw os bi"><span id="967d" class="mh mi iq op b gy ot ou l ov ow">@Test<br/><strong class="op ir">void </strong>findAll_success() {<br/>    List&lt;Customer&gt; allCustomer = <strong class="op ir">customerRepository</strong>.findAll();<br/>    <em class="oj">assertThat</em>(allCustomer.size()).isGreaterThanOrEqualTo(1);<br/>}</span></pre><p id="9719" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在这里，我们获取数据并检查大小1。我们的最大客户数据量大约是1到4。因为对于默认情况，测试用例的执行不保持任何顺序。在@ <strong class="kz ir"> BeforeEach </strong>命令中，我们只插入一个客户。所以我们正在检查<strong class="kz ir"> isGreaterThanOrEqualTo(1)。</strong></p><h2 id="1c9b" class="mh mi iq bd mj mk ml dn mm mn mo dp mp lg mq mr ms lk mt mu mv lo mw mx my mz bi translated"><strong class="ak"> 2。测试服务层</strong></h2><p id="fa02" class="pw-post-body-paragraph kx ky iq kz b la na jr lc ld nb ju lf lg nc li lj lk nd lm ln lo ne lq lr ls ij bi translated">这里的服务是基于spring <strong class="kz ir"> @Service </strong>注解<strong class="kz ir">的。使用服务，我们检查一些业务逻辑，将数据保存到数据库或从数据库中提取数据，然后返回给我们的控制器。</strong></p><p id="0476" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir"> <em class="oj">注意:我们正在测试服务层。所以我们不需要数据库层的实际操作。所以我们会让数据库层模拟。</em>T29】</strong></p><p id="4f15" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们的服务层代码如下</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="143d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在这里，我们有一些方法，如保存或更新，获取数据。我们将使用单元测试来测试所有这些方法。</p><p id="7083" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们的单元测试代码如下</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="926a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在这段代码中，我们通过annotation @<strong class="kz ir">Mock</strong><strong class="kz ir">customer repository</strong>来模拟数据库层。这里，mocking表示这是一个虚拟层，在数据库保存或获取期间不会发生任何实际操作。为了模仿数据库层，我们使用了一些<strong class="kz ir">存根</strong></p><p id="d154" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">保存或更新<br/> </strong>我们的保存或更新测试代码如下</p><pre class="kh ki kj kk gt oo op oq or aw os bi"><span id="851c" class="mh mi iq op b gy ot ou l ov ow">@Test<br/><strong class="op ir">public void </strong>savedCustomer_Success() {<br/>    Customer customer = <strong class="op ir">new </strong>Customer();<br/>    customer.setFirstName(<strong class="op ir">"sajedul"</strong>);<br/>    customer.setLastName(<strong class="op ir">"karim"</strong>);<br/>    customer.setMobileNumber(<strong class="op ir">"01737186095"</strong>);<br/><br/>    <em class="oj">// providing knowledge<br/>    when</em>(<strong class="op ir">customerRepository</strong>.save(<em class="oj">any</em>(Customer.<strong class="op ir">class</strong>))).thenReturn(customer);<br/><br/>    Customer savedCustomer = <strong class="op ir">customerRepository</strong>.save(customer);<br/>    <em class="oj">assertThat</em>(savedCustomer.getFirstName()).isNotNull();<br/>}</span></pre><p id="0ce9" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这里，我们正在构建一个客户对象。这里，存储库保存对象在成功保存到数据库后返回一个对象。因此，我们告诉mockito，如果我们试图保存任何客户对象，那么您将返回我们提供的客户对象。最后，我们检查这个返回的对象。通过存根，我们用预定义的操作来转换数据库操作。</p><p id="0452" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">从数据库中获取数据<br/> </strong>我们获取数据的代码如下</p><pre class="kh ki kj kk gt oo op oq or aw os bi"><span id="a898" class="mh mi iq op b gy ot ou l ov ow">@Test<br/><strong class="op ir">public void </strong>customer_exists_in_db_success() {<br/>    Customer customer = <strong class="op ir">new </strong>Customer();<br/>    customer.setFirstName(<strong class="op ir">"sajedul"</strong>);<br/>    customer.setLastName(<strong class="op ir">"karim"</strong>);<br/>    customer.setMobileNumber(<strong class="op ir">"01737186095"</strong>);<br/>    List&lt;Customer&gt; customerList = <strong class="op ir">new </strong>ArrayList&lt;&gt;();<br/>    customerList.add(customer);<br/><br/>    <em class="oj">// providing knowledge<br/>    when</em>(<strong class="op ir">customerRepository</strong>.findAll()).thenReturn(customerList);<br/><br/>    List&lt;Customer&gt; fetchedCustomers = <strong class="op ir">customerService</strong>.fetchAllCustomer();<br/>    <em class="oj">assertThat</em>(fetchedCustomers.size()).isGreaterThan(0);<br/>}</span></pre><p id="db5e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这里，存储库<strong class="kz ir"> findAll() </strong>方法返回一个客户列表。因此，我们正在构建一个客户列表，并停止使用<strong class="kz ir"> findAll() </strong>方法，并在操作后检查数据大小。</p><h2 id="a489" class="mh mi iq bd mj mk ml dn mm mn mo dp mp lg mq mr ms lk mt mu mv lo mw mx my mz bi translated"><strong class="ak"> 3。测试控制器层</strong></h2><p id="5ad3" class="pw-post-body-paragraph kx ky iq kz b la na jr lc ld nb ju lf lg nc li lj lk nd lm ln lo ne lq lr ls ij bi translated">在控制器层，我们模仿服务层，测试API。控制器层代码如下所示</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="69a1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这里，我们有两个端点，一个用于保存，另一个用于从服务层获取数据。</p><p id="35cb" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们的测试代码如下</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="44a3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在这里，我们模拟了<strong class="kz ir"> CustomerService </strong>，并且为了测试API，我们使用了<strong class="kz ir"> MockMvc。</strong>这里，我们也是在剔除服务层方法。</p><p id="3ffa" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在测试期间，我们构建请求，并在执行后检查状态</p></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><h2 id="dd0d" class="mh mi iq bd mj mk ml dn mm mn mo dp mp lg mq mr ms lk mt mu mv lo mw mx my mz bi translated"><strong class="ak"> 4。编写可测试代码的技巧</strong></h2><p id="8375" class="pw-post-body-paragraph kx ky iq kz b la na jr lc ld nb ju lf lg nc li lj lk nd lm ln lo ne lq lr ls ij bi translated">对于可测试的代码，我们必须遵循一些编码规则。这些在下面给出</p><ul class=""><li id="d70c" class="lt lu iq kz b la lb ld le lg lv lk lw lo lx ls oe lz ma mb bi translated">严格遵循坚实的原则</li><li id="e6b5" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls oe lz ma mb bi translated">正确使用依赖注入。使用构造函数注入或setter注入，而不是自动连接。对于难以测试的自动连线beans。</li><li id="7962" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls oe lz ma mb bi translated">分离对象创建和应用程序逻辑。否则，您必须在编写测试用例之前重写代码</li><li id="fbc8" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls oe lz ma mb bi translated">移除全局状态。全局状态使得代码更难理解，因为这些类的用户可能不知道哪些变量需要实例化。</li><li id="d74a" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls oe lz ma mb bi translated">避免静态方法和变量。静态方法是程序代码，应该在面向对象的范例中避免，因为它们不提供单元测试所需的接缝。</li><li id="2f05" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls oe lz ma mb bi translated">严格遵循命名约定。编写单元测试时，重要的是能够确定对象的哪些属性和方法是公共的，哪些是对象本身的私有实现细节。这是因为单元测试应该只测试公共定义的API，因为它们是唯一保证存在并产生稳定结果的API。</li><li id="6795" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls oe lz ma mb bi translated">干净的代码和良好的文档。测试不能代替清晰的、维护良好的代码库。事实上，为了编写准确的测试，代码保持足够干净是必要的，以便测试作者和未来的维护人员能够快速理解被测试的每个代码单元的目的，以及它如何适应整个应用程序。</li><li id="f6e1" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls oe lz ma mb bi translated">代码必须很快。开发人员编写单元测试，这样他们可以重复运行它们，并检查是否引入了错误。如果单元测试很慢，开发人员很可能会跳过在他们自己的机器上运行它们。</li><li id="fcca" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls oe lz ma mb bi translated">不要混淆单元测试和集成测试。正如我们已经讨论过的，单元测试和集成测试有不同的目的。单元测试和被测系统都不应该访问网络资源、数据库、文件系统等。，消除外界因素的影响。</li></ul></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><h2 id="42c8" class="mh mi iq bd mj mk ml dn mm mn mo dp mp lg mq mr ms lk mt mu mv lo mw mx my mz bi translated"><strong class="ak"> 5。源代码详情</strong></h2><p id="7065" class="pw-post-body-paragraph kx ky iq kz b la na jr lc ld nb ju lf lg nc li lj lk nd lm ln lo ne lq lr ls ij bi translated">所有的源代码都在<a class="ae kw" href="https://github.com/mesuk/SpringReadyApp" rel="noopener ugc nofollow" target="_blank"> <strong class="kz ir">这个GitHub </strong> </a>资源库中。<br/> <strong class="kz ir">控制器名称</strong> : CustomerController <br/> <strong class="kz ir">服务名称</strong>:CustomerServiceImpl<br/><strong class="kz ir">存储库名称</strong>:customer Repository<br/><strong class="kz ir">测试类:</strong>CustomerServiceLayerTest、CustomerControllerLayerTest</p><p id="4d73" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir"> Swagger网址</strong>:<a class="ae kw" href="http://localhost:8181/springreadyapp/swagger-ui.html#/MainController" rel="noopener ugc nofollow" target="_blank"><strong class="kz ir">http://localhost:8181/springreadyapp/Swagger-ui . html #/main controller</strong></a></p><p id="8d96" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">提前感谢:)</p><div class="nf ng gp gr nh ni"><a href="https://levelup.gitconnected.com/overview-of-solid-principles-and-its-java-implementations-4ae37fa5bb1b" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">固体原理及其JAVA实现概述</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">创建可理解的、可读的和可测试的代码，许多开发人员可以协作工作。</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nr l"><div class="ox l nt nu nv nr nw kq ni"/></div></div></a></div></div></div>    
</body>
</html>