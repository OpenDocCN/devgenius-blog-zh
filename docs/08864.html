<html>
<head>
<title>Head First Java-Chapter 16 (collections and generics)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">head First Java-第 16 章(集合和泛型)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/head-first-java-chapter-16-collections-and-generics-b0447b3733e9?source=collection_archive---------8-----------------------#2022-07-15">https://blog.devgenius.io/head-first-java-chapter-16-collections-and-generics-b0447b3733e9?source=collection_archive---------8-----------------------#2022-07-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="f02c" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated"><strong class="ak">数据结构</strong></h1><blockquote class="ki kj kk"><p id="faca" class="kl km kn ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="ko io">收藏-整理</strong></p></blockquote><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi lk"><img src="../Images/b2bb4ee9d575e05a117665391b037e95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fwpdES9HCNjUq84V9MMtzQ.png"/></div></div></figure><ul class=""><li id="bfa0" class="lw lx in ko b kp kq kt ku ly lz ma mb mc md lj me mf mg mh bi translated"><strong class="ko io">collections . sort()方法按字母顺序对字符串列表进行排序</strong></li></ul><p id="8e5d" class="pw-post-body-paragraph kl km in ko b kp kq kr ks kt ku kv kw ly ky kz la ma lc ld le mc lg lh li lj ig bi translated">例如:</p><blockquote class="ki kj kk"><p id="e2c4" class="kl km kn ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">ArrayList<string>song list = new ArrayList<string>()；</string></string></p><p id="896b" class="kl km kn ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Collections.sort(歌曲列表)；</p></blockquote><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi mi"><img src="../Images/68bcf2fe28d48aaf3837954a4f62e6c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VSFe_IYOX5DDwtZVACXMvw.png"/></div></div></figure><p id="7b78" class="pw-post-body-paragraph kl km in ko b kp kq kr ks kt ku kv kw ly ky kz la ma lc ld le mc lg lh li lj ig bi translated"><strong class="ko io">排序对象</strong></p><ul class=""><li id="b80a" class="lw lx in ko b kp kq kt ku ly lz ma mb mc md lj me mf mg mh bi translated">假设我们希望列表中有实际的类实例，在这种情况下每个实例可以有更多的数据。</li><li id="f816" class="lw lx in ko b kp mj kt mk ly ml ma mm mc mn lj me mf mg mh bi translated">这里我们将需要一个被覆盖的 toString()方法。</li><li id="d372" class="lw lx in ko b kp mj kt mk ly ml ma mm mc mn lj me mf mg mh bi translated">因为 toString()方法是在打印对象(System.out.println(anObject))时调用的，所以您应该重写它以打印比默认的唯一标识符代码更易读的内容。</li></ul><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="mo mp l"/></div></figure><ul class=""><li id="dce4" class="lw lx in ko b kp kq kt ku ly lz ma mb mc md lj me mf mg mh bi translated">我们覆盖 toString()，因为当你做一个 System.out.println(aSongObject)的时候，我们希望看到标题。当您执行 system . out . println(aListOfSongs)时，它会调用列表中每个元素的 toString()方法。</li></ul><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/6a71f902fed6a1275692bf0e28b9926e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*GQugeDdHPoFCZBIXoQO0_Q.png"/></div></figure><p id="7a0c" class="pw-post-body-paragraph kl km in ko b kp kq kr ks kt ku kv kw ly ky kz la ma lc ld le mc lg lh li lj ig bi translated"><strong class="ko io">改为歌曲对象的数组列表，而不是字符串</strong></p><ul class=""><li id="67d0" class="lw lx in ko b kp kq kt ku ly lz ma mb mc md lj me mf mg mh bi translated">现在使用这四个标记创建一个新的歌曲对象，然后将歌曲添加到列表中。</li></ul><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi mr"><img src="../Images/f0db2ff17e212f558dd82f14a64e3489.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XWTOq5wNpAhzrIsloNH3oQ.png"/></div></div></figure><ul class=""><li id="38cd" class="lw lx in ko b kp kq kt ku ly lz ma mb mc md lj me mf mg mh bi translated">不会编译！</li></ul><p id="eaeb" class="pw-post-body-paragraph kl km in ko b kp kq kr ks kt ku kv kw ly ky kz la ma lc ld le mc lg lh li lj ig bi translated">但是 Collections 类清楚地表明有一个 sort()方法，它接受一个列表。</p><ul class=""><li id="1ffc" class="lw lx in ko b kp kq kt ku ly lz ma mb mc md lj me mf mg mh bi translated">ArrayList 是-一个列表，因为 ArrayList 实现了 List 接口，所以…应该可以。</li></ul><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/5975ed55c4def977d091951dcebd8315.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*qmiwSVWY89D_qjNDIMTCAw.png"/></div></figure><ul class=""><li id="c4a4" class="lw lx in ko b kp kq kt ku ly lz ma mb mc md lj me mf mg mh bi translated">编译器说它找不到采用 ArrayList <song>的排序方法。</song></li></ul><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/8ee2958b2f3a2092f77058e9a99cedb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*a-tZhOc3aFLVsnf5ejP6pg.png"/></div></figure><ul class=""><li id="f872" class="lw lx in ko b kp kq kt ku ly lz ma mb mc md lj me mf mg mh bi translated">让我们看看为什么编译器甚至不让我们将一个 Song 数组列表传递给 sort()方法。</li></ul><blockquote class="ki kj kk"><p id="c4df" class="kl km kn ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">编译器不知道如何读取这个上的方法声明。上面说 sort()取一个列表<t>，但是 T 是什么？</t></p></blockquote><p id="4af1" class="pw-post-body-paragraph kl km in ko b kp kq kr ks kt ku kv kw ly ky kz la ma lc ld le mc lg lh li lj ig bi translated"><strong class="ko io">sort()方法声明</strong></p><ul class=""><li id="3ea5" class="lw lx in ko b kp kq kt ku ly lz ma mb mc md lj me mf mg mh bi translated">这是因为 sort()方法(以及 Java 中整个集合框架中的其他东西)大量使用了泛型。每当你在 Java 源代码或文档中看到带尖括号的东西，它就意味着泛型 Java 5.0 中增加的一个特性。</li></ul><blockquote class="ki kj kk"><p id="1ac9" class="kl km kn ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">泛型类型</p></blockquote><ul class=""><li id="9c81" class="lw lx in ko b kp kq kt ku ly lz ma mb mc md lj me mf mg mh bi translated">使用泛型，您可以创建类型安全的集合，其中更多的问题是在编译时而不是运行时解决的。</li><li id="b6a4" class="lw lx in ko b kp mj kt mk ly ml ma mm mc mn lj me mf mg mh bi translated">如果没有泛型，编译器会很乐意让你把一个南瓜放到一个应该只存放 Cat 对象的数组列表中。</li><li id="58eb" class="lw lx in ko b kp mj kt mk ly ml ma mm mc mn lj me mf mg mh bi translated">在泛型出现之前，没有办法声明数组列表的类型，所以它的 add()方法接受 type Object。</li></ul><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/f508f5c2089f9f667ce344b814cc294e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*JzpPhpAbz-dAdwEz86qJqw.png"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">没有泛型</figcaption></figure><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/f1a5fc72f88584b4824d7d44b4a5a9cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*HE0FmScw7zHvgUNizu0mrw.png"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">使用泛型</figcaption></figure><ul class=""><li id="c5b9" class="lw lx in ko b kp kq kt ku ly lz ma mb mc md lj me mf mg mh bi translated">现在有了泛型，你可以只把 Fish 对象放在 ArrayList <fish>中，所以对象以 Fish 引用的形式出现。你不必担心有人把一辆大众汽车放在那里，或者你得到的东西不会真的被铸造成鱼的参照物。</fish></li></ul><p id="ab6c" class="pw-post-body-paragraph kl km in ko b kp kq kr ks kt ku kv kw ly ky kz la ma lc ld le mc lg lh li lj ig bi translated"><strong class="ko io">通用类</strong></p><p id="a4a2" class="pw-post-body-paragraph kl km in ko b kp kq kr ks kt ku kv kw ly ky kz la ma lc ld le mc lg lh li lj ig bi translated">在泛型类中，有两个主要方面需要关注:</p><p id="4769" class="pw-post-body-paragraph kl km in ko b kp kq kr ks kt ku kv kw ly ky kz la ma lc ld le mc lg lh li lj ig bi translated">1)类声明</p><p id="3d89" class="pw-post-body-paragraph kl km in ko b kp kq kr ks kt ku kv kw ly ky kz la ma lc ld le mc lg lh li lj ig bi translated">2)允许您添加元素的方法声明</p><blockquote class="ki kj kk"><p id="2051" class="kl km kn ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">公共类数组列表<e>扩展抽象列表<e>实现列表<e> …{</e></e></e></p></blockquote><ul class=""><li id="ac8d" class="lw lx in ko b kp kq kt ku ly lz ma mb mc md lj me mf mg mh bi translated">可以把“E”看作是“您希望这个集合保存并返回的元素类型”的替身。(E 代表元素。).</li><li id="0476" class="lw lx in ko b kp mj kt mk ly ml ma mm mc mn lj me mf mg mh bi translated">ArrayList 是 AbstractList 的子类，所以您为 ArrayList 指定的任何类型都会自动用于 AbstractList 的类型。</li></ul><p id="5984" class="pw-post-body-paragraph kl km in ko b kp kq kr ks kt ku kv kw ly ky kz la ma lc ld le mc lg lh li lj ig bi translated"><strong class="ko io">泛型方法</strong></p><ol class=""><li id="a806" class="lw lx in ko b kp kq kt ku ly lz ma mb mc md lj na mf mg mh bi translated">使用在类声明中定义的类型参数</li></ol><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi nb"><img src="../Images/c8658431f6923887fe3db8ef17a1463d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_rENTDxrBe4nYKnLQM6n8Q.png"/></div></div></figure><p id="c2f4" class="pw-post-body-paragraph kl km in ko b kp kq kr ks kt ku kv kw ly ky kz la ma lc ld le mc lg lh li lj ig bi translated">2.使用未在类声明中定义的类型参数</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi nc"><img src="../Images/5cba9505af3695f79619a3c950e19cdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*iUyBZNMUA_149ejgBEKt1Q.png"/></div></div></figure><ul class=""><li id="1d0f" class="lw lx in ko b kp kq kt ku ly lz ma mb mc md lj me mf mg mh bi translated">这里我们可以使用<t>,因为我们之前在方法声明中声明了“T”。方法说 T 可以是“任何类型的动物”。</t></li></ul><p id="c7e9" class="pw-post-body-paragraph kl km in ko b kp kq kr ks kt ku kv kw ly ky kz la ma lc ld le mc lg lh li lj ig bi translated"><strong class="ko io">可比界面</strong></p><ul class=""><li id="8ffb" class="lw lx in ko b kp kq kt ku ly lz ma mb mc md lj me mf mg mh bi translated">Comparable 接口定义了用于比较对象的<strong class="ko io"> compareTo </strong>方法。</li></ul><blockquote class="ki kj kk"><p id="a78a" class="kl km kn ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">类宋器物可比<song/></p></blockquote><ul class=""><li id="9349" class="lw lx in ko b kp kq kt ku ly lz ma mb mc md lj me mf mg mh bi translated">我们正在指定实现类可以与之比较的类型。这意味着<strong class="ko io"> Song </strong>对象可以与其他<strong class="ko io"> Song </strong>对象进行比较，以便进行排序。</li></ul><blockquote class="ki kj kk"><p id="2822" class="kl km kn ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">公共 int compareTo(Song s) {</p></blockquote><ul class=""><li id="f831" class="lw lx in ko b kp kq kt ku ly lz ma mb mc md lj me mf mg mh bi translated">sort()方法向 compareTo()发送一首歌曲，以查看该歌曲与调用该方法的歌曲相比如何。</li></ul><p id="ae2f" class="pw-post-body-paragraph kl km in ko b kp kq kr ks kt ku kv kw ly ky kz la ma lc ld le mc lg lh li lj ig bi translated">示例代码:</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="ae8b" class="pw-post-body-paragraph kl km in ko b kp kq kr ks kt ku kv kw ly ky kz la ma lc ld le mc lg lh li lj ig bi translated">输出:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/38070cf29e3814bef74812978c48247d.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*UB6RWm0QgzdIZPb_fCfcdg.png"/></div></figure><h1 id="6ef4" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">列出、设置和映射接口</h1><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi ne"><img src="../Images/412dbbf10bbb83ea7b9660e8276e7a58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8NCsMwVBxiCA8860cGJaow.png"/></div></div></figure><p id="01c8" class="pw-post-body-paragraph kl km in ko b kp kq kr ks kt ku kv kw ly ky kz la ma lc ld le mc lg lh li lj ig bi translated"><strong class="ko io">对象相等</strong></p><ol class=""><li id="8762" class="lw lx in ko b kp kq kt ku ly lz ma mb mc md lj na mf mg mh bi translated">引用相等:引用堆上同一对象的两个引用相等。句号。如果对两个引用都调用 hashCode()方法，会得到相同的结果。如果不覆盖 hashCode()方法，默认行为。</li></ol><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/68f04336ef6b6997026979e55ac745be.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/format:webp/1*Ki7uSj3-ybFCGR8u2E8l1Q.png"/></div></figure><p id="515d" class="pw-post-body-paragraph kl km in ko b kp kq kr ks kt ku kv kw ly ky kz la ma lc ld le mc lg lh li lj ig bi translated">2.对象相等性:如果您想将两个不同的歌曲对象视为相等的(例如，如果您确定两首歌曲具有匹配的标题变量，则它们是相同的)，您必须重写从类对象继承的 hashCode()和 equals()方法。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/3b9bbf557ab4ad9895e264a8e5a01d17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*2A87uEVL0afDUrNj62Mp9A.png"/></div></figure></div></div>    
</body>
</html>