<html>
<head>
<title>Protecting audio assets with JavaScript and Web Audio API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用JavaScript和网络音频API保护音频资产</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/protecting-audio-assets-with-javascript-and-web-audio-api-a8e3a04d2bb6?source=collection_archive---------8-----------------------#2020-12-01">https://blog.devgenius.io/protecting-audio-assets-with-javascript-and-web-audio-api-a8e3a04d2bb6?source=collection_archive---------8-----------------------#2020-12-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/205231d8a4de30cd093b2fc3f0ad23fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hP6fbZWA77WdkYSF.jpg"/></div></div></figure><p id="3b85" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们的<a class="ae kt" href="https://dev.to/codr/protecting-audio-and-music-assets-with-node-and-javascript-2p92" rel="noopener ugc nofollow" target="_blank">上一篇文章</a>中，我们研究了如何使用HTML5 <code class="fe ku kv kw kx b">&lt;audio&gt;</code>标签来保护在客户端浏览器上播放的音频资产。缺点是，通过简单地使用属性<code class="fe ku kv kw kx b">src</code> location，仍然可以很容易地下载底层音轨。在本帖中，我们将关注另一种策略。</p><p id="0a11" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另一个现代但不太为人所知的播放声音的方法是<strong class="jx io"> Web Audio API </strong>，它被所有现代浏览器所支持(当然IE除外)。这个API有很多有趣的特性，比如多重播放、声音生成器、转换等等。而且能够播放来自二进制数据的声音，比如一个<code class="fe ku kv kw kx b">arraybuffer</code>，这对于我们的目的来说非常有趣。</p><p id="2ab6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从服务器端的角度来看，我们不需要从我们之前的<a class="ae kt" href="https://dev.to/codr/protecting-audio-and-music-assets-with-node-and-javascript-2p92" rel="noopener ugc nofollow" target="_blank">帖子</a>中修改任何代码。</p><p id="ff69" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">客户端只有一点点变化:</p><pre class="ky kz la lb gt lc kx ld le aw lf bi"><span id="366b" class="lg lh in kx b gy li lj l lk ll">let source = null;<br/>let oReq = new XMLHttpRequest();<br/>oReq.open("GET", 'http://localhost:3007/audio', true)<br/>oReq.responseType = "arraybuffer"</span><span id="f595" class="lg lh in kx b gy lm lj l lk ll">oReq.onload = function(oEvent) {<br/>  webapi()<br/>};<br/>oReq.send()</span><span id="fa4b" class="lg lh in kx b gy lm lj l lk ll">async function webapi() {<br/>  // obtain and decrypt the audio data<br/>  const arr = oReq.response<br/>  let byteArray = new Uint8Array(arr)<br/>  let key = byteArray[byteArray.length - 1] <br/>  byteArray = byteArray.map(x =&gt; x ^ key).map(x =&gt; ~x)<br/>  byteArray[0] = key</span><span id="ee1e" class="lg lh in kx b gy lm lj l lk ll">  // Web Audio API<br/>  // use the decrypted audio data as input<br/>  const context = new AudioContext();<br/>  const buffer = await context.decodeAudioData(byteArray.buffer)<br/>  source = context.createBufferSource()<br/>  source.buffer = buffer<br/>  source.connect(context.destination)<br/>}</span><span id="b242" class="lg lh in kx b gy lm lj l lk ll">// use 'source.start()' in some click event</span></pre><p id="e3ba" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种方法的优点是我们不再为用户留下容易下载音频数据的足迹。换句话说，我们不再有一个<code class="fe ku kv kw kx b">&lt;audio&gt;</code>标签，它的<code class="fe ku kv kw kx b">src</code>值可以被复制/下载。</p><p id="d3b2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了窃取音频内容，黑客/盗版者有三种选择:</p><ol class=""><li id="cdeb" class="ln lo in jx b jy jz kc kd kg lp kk lq ko lr ks ls lt lu lv bi translated">想办法解密音频。</li><li id="7f4e" class="ln lo in jx b jy lw kc lx kg ly kk lz ko ma ks ls lt lu lv bi translated">导出数组缓冲区的内容。</li><li id="d71b" class="ln lo in jx b jy lw kc lx kg ly kk lz ko ma ks ls lt lu lv bi translated">播放时录制音频。</li></ol><p id="d33e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当然，可能有更先进的方法，但它确实为大多数新手提高了窃取你的内容的门槛。</p><p id="57dd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">缺点是网络音频API还不完善，对我来说，在Firefox中播放mp3格式似乎并不总是有效，但在Chrome中却有效。它会抛出以下异常:<br/> <code class="fe ku kv kw kx b">Uncaught (in promise) DOMException: The buffer passed to decodeAudioData contains an unknown content type.</code> <br/>我没有测试过ogg和wav等其他格式，但我确实记得ogg在Safari中是不工作的。可能wav是三者中最好的？</p><h1 id="295c" class="mb lh in bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">最后的话</h1><p id="3502" class="pw-post-body-paragraph jv jw in jx b jy my ka kb kc mz ke kf kg na ki kj kk nb km kn ko nc kq kr ks ig bi translated"><strong class="jx io">为了最大限度地利用这种保护技术，我们必须尽可能地进行静态分析。</strong></p><p id="7764" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，确保总是混淆和缩小您的JavaScript代码，出于安全和性能原因，总是推荐这样做。</p><p id="500c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第二，尽量使加密/解密代码看起来尽可能复杂，同时保持其高性能。如果黑客使用Node/JS，他们可以直接复制粘贴函数，但是很多业余黑客可能会使用Python/Java/C#等非JavaScript代码来编写他们的bot/scraper/downloader。拥有一个看起来复杂的解密函数将迫使他们完全理解并将其翻译成他们选择的语言，这可能不是那么微不足道的(<em class="nd">除非使用翻译工具</em>)。</p></div></div>    
</body>
</html>