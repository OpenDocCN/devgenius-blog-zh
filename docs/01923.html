<html>
<head>
<title>Rails Associations &amp; Tables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rails关联和表格</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/rails-associations-tables-c9ec2f77a167?source=collection_archive---------16-----------------------#2020-07-14">https://blog.devgenius.io/rails-associations-tables-c9ec2f77a167?source=collection_archive---------16-----------------------#2020-07-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="536e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有不同类型的表，根据您希望它们之间的关系，您需要相应地配置表。我将讨论的关系类型有:属于、拥有和拥有许多:通过。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/bcac1c4fd79e4594f31c4dc1ea41b7ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*eu3p84jnLzuZzcwT.png"/></div></figure><p id="a30c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于<strong class="jm io">隶属于</strong>关联；我们希望在它所属的表中有一个外键(如上图所示)。以区分您是否需要模型的belongs_to关系；您首先想知道这个表是否需要一个<strong class="jm io">外键</strong>(上面例子中的author_id)。确定它所属的类是单数，因为我们选择的模型只能属于一个单数模型。如果我们要使用它，我们会这样做:</p><p id="0357" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">book1</strong><strong class="jm io">= book . find(1)</strong>&lt;——这将把变量post提交给具有该id号的图书。现在，如果我们假设已经创建了一本书，其author_id为3。</p><p id="1088" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将返回id为3的author对象及其所有信息。如果我们想说得更具体，我们可以加上。例中作者后的“姓名”只是获取姓名。或者使用列的特定名称来获取相应的数据。</p><p id="2b0f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> book1.author.name </strong></p><p id="0a19" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">book1 . author . id</strong>&lt;——将返回作者的id。在这种情况下将是3。</p></div><div class="ab cl kq kr hr ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="ig ih ii ij ik"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi kx"><img src="../Images/4e6cc837215b1364b6f71f5883567f94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/0*Se4aTsiIODq1o5nJ.png"/></div></figure><p id="fb32" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在另一边将是has_many协会。在这个例子中，一个作者能够出版多本书。在编写关联时，确保对象是复数(如上所示)。让我们假设我们使用相同的例子作为属于。现在，我们想用这样的话来称呼这个协会:</p><p id="b4a9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">author 3 = author . find _ by(id:3)</strong></p><p id="e036" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">author 3 . books</strong>&lt;——这将带来一个与这个特定作者相关联的对象数组。如果您正在测试这个，并且得到一个空数组([])，这很可能意味着还没有任何与该作者相关联的书籍。</p><p id="8fb5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们想要书名，我们不能用T21，除非我们明确想要哪本书的书名。</p><p id="5c04" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">author 3 . books . first . title&lt;-</strong>这将调用该作者的图书数组中第一本书的标题。</p></div><div class="ab cl kq kr hr ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="ig ih ii ij ik"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi kz"><img src="../Images/bdb2219030b37768da953d9ed6b0ec3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/0*SnNXxyNWPZ6N37Ne.png"/></div></figure><p id="d693" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在对于has_many :through我们将使用上面这个例子。这个关联使用一个joiner表(Appointment)来连接其他表(内科医生和病人)。进行关联时，始终将<strong class="jm io"> Joiner模型放在第一位(不需要“=&gt;”)</strong>。如您所见，医生和患者表没有外键。但是我们有一个带有外键的约会表。这将是我们用来在医生和病人之间建立关系的方式。为了使用它，我们想用一个类似这样的东西来调用它。</p><p id="e3ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们假设我们使用。为两者找到(1)。这两个都是id为1的对象。</p><p id="f1f6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">appointment = appointment . create(patient _ id:1，physician_id: 1，appointment _ date:12/12/2020)</strong>&lt;——这样我们就创建了另外两个对象之间的关系。既然我们有关系，我们就有能力给对方打电话。</p><p id="703d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">patient 1 . physicians</strong>&lt;——这将返回与患者预约相关的所有医生对象的数组；同样的方法也可以用在physician1上来寻找一系列的病人。如果你得到一个空数组，这可能意味着还没有创建关系。</p><p id="3d4d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">patient 1 . appointments</strong>&lt;——这将带来一个与该变量对应的约会数组。</p><p id="05a9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">patient 1 . appointments . last . appointment _ date</strong>&lt;-将获得该相应预约的预约日期。</p><p id="2ec8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">patient1 . appointments . first . physician</strong>&lt;——这将调用physician对象(而不是数组)，该对象属于patient 1的约会数组中的第一个约会。</p><p id="fb53" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">需要记住的重要一点是，约会数组将依赖于约会的创建时间。</p><p id="ab66" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">链接到更多表格和关联:<a class="ae la" href="https://guides.rubyonrails.org/association_basics.html" rel="noopener ugc nofollow" target="_blank">https://guides.rubyonrails.org/association_basics.html</a></p></div></div>    
</body>
</html>