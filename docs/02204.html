<html>
<head>
<title>Node.js Tips — Scheduled Tasks, Jest Tests, and Headers for Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js 提示—计划任务、Jest 测试和测试标题</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/node-js-tips-scheduled-tasks-jest-tests-and-headers-for-tests-4bad59e07f03?source=collection_archive---------5-----------------------#2020-07-23">https://blog.devgenius.io/node-js-tips-scheduled-tasks-jest-tests-and-headers-for-tests-4bad59e07f03?source=collection_archive---------5-----------------------#2020-07-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/22f3d6bc93404d7f6deeacc88e7012c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WYn8722VxoCgV3x9"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@alvaronino?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Á·阿尔瓦罗·尼诺</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="9e8d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，当我们编写节点应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些编写节点应用程序时常见问题的解决方案。</p><h1 id="a092" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用 Jest 循环动态测试用例</h1><p id="1f6b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">tests.each</code>方法遍历每个 tets。</p><p id="fa73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3271" class="mq lc iq mh b gy mr ms l mt mu">test.each([[4, 5, 9], [1, 2, 3], [2, 3, 5]])(<br/>  'add(%i, %i)',<br/>  (a, b, expected) =&gt; {<br/>    expect(a + b).toBe(expected);<br/>  },<br/>);</span></pre><p id="b160" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个参数是我们希望传递到每个测试中的项目。</p><p id="7d3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嵌套数组条目是回调的参数。</p><p id="7535" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个参数是每个测试的名称。</p><p id="3878" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第三次是回调，让争论和运行我们的期望。</p><h1 id="8bba" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用 Supertest 设置默认标题</h1><p id="c095" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以创建一个可以在测试中使用的头。</p><p id="741f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以把它传递给<code class="fe me mf mg mh b">set</code>方法。</p><p id="d271" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="71bd" class="mq lc iq mh b gy mr ms l mt mu">const request = require("supertest");</span><span id="e878" class="mq lc iq mh b gy mv ms l mt mu">const baseUrl = 'http://localhost';<br/>request = request(baseUrl);<br/>const commonHeaders = { authorization: "abc" };</span><span id="dbf4" class="mq lc iq mh b gy mv ms l mt mu">describe("testing", () =&gt; {<br/>  it.should('present authorization header to server', (done) =&gt; {<br/>    request.get('/foo')<br/>      .set(commonHeaders)<br/>      .set({ foo: "bar" })<br/>      .expect(200, done)<br/>  })</span><span id="7d6b" class="mq lc iq mh b gy mv ms l mt mu">})</span></pre><p id="c76f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">commonHeaders</code>在多个测试之间共享标题。</p><p id="83c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只是将它传递给<code class="fe me mf mg mh b">set</code>方法。</p><p id="728a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以将其他特定于测试的头传递给<code class="fe me mf mg mh b">set</code>方法。</p><h1 id="2840" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在 Node.js 中同步读取文件</h1><p id="0fac" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了与 Node 同步读取文件，我们可以使用<code class="fe me mf mg mh b">readFileSync</code>方法。</p><p id="2a0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d992" class="mq lc iq mh b gy mr ms l mt mu">const fs = require('fs');<br/>const content = fs.readFileSync('file');<br/>console.log(content);</span></pre><p id="4226" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只需传入文件的路径，内容就会被返回。</p><h1 id="5b22" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Base64 编码一个 JavaScript 对象</h1><p id="4b41" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过用<code class="fe me mf mg mh b">JSON.stringigy</code>将 JavaScript 对象转换成字符串来对其进行 base64 编码。</p><p id="7d41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以调用<code class="fe me mf mg mh b">Buffer.from</code>将其转换为缓冲区，然后调用<code class="fe me mf mg mh b">toString</code>将其转换为 base64 字符串。</p><p id="7c8f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="395e" class="mq lc iq mh b gy mr ms l mt mu">const str = JSON.stringify(obj);<br/>const objJsonB64 = Buffer.from(str).toString("base64");</span></pre><p id="229b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将字符串化的 JSON 对象转换成字节流。</p><p id="e0b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用<code class="fe me mf mg mh b">'base64'</code>参数调用<code class="fe me mf mg mh b">toString</code>将其转换成 base64 字符串。</p><h1 id="138b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">猫鼬填充嵌入式</h1><p id="d3be" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们用相关的模式定义一个模式，我们可以用 Mongoose 在嵌入式文档上调用<code class="fe me mf mg mh b">populate</code>。</p><p id="2a44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="bcb2" class="mq lc iq mh b gy mr ms l mt mu">const UserSchema = new Schema({<br/>  name: String,<br/>  friends: [{ type: ObjectId, ref: 'User' }]<br/>});</span></pre><p id="d4e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们有一个自引用模式，因为<code class="fe me mf mg mh b">friends</code>引用了另一个<code class="fe me mf mg mh b">User</code>文档。</p><p id="070c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以用<code class="fe me mf mg mh b">friends</code>来调用<code class="fe me mf mg mh b">populate</code>了:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="cc46" class="mq lc iq mh b gy mr ms l mt mu">User.<br/>  findOne({ name: 'james' }).<br/>  populate({<br/>    path: 'friends',<br/>    populate: { path: 'friends' }<br/>  });</span></pre><p id="d3ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们称<code class="fe me mf mg mh b">populate</code>为<code class="fe me mf mg mh b">friends</code>来获得朋友。</p><p id="95c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">populate</code>属性来获取朋友的朋友。</p><h1 id="a6ff" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">每天运行一项功能</h1><p id="e388" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过使用<code class="fe me mf mg mh b">node-schedule</code>包以预定的方式运行一个函数。</p><p id="817d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="857d" class="mq lc iq mh b gy mr ms l mt mu">import schedule from 'node-schedule'</span><span id="e5c4" class="mq lc iq mh b gy mv ms l mt mu">schedule.scheduleJob('0 0 0 * * *', () =&gt; { <br/>  //...<br/>})</span></pre><p id="e5ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们运行<code class="fe me mf mg mh b">schedule.scheduleJob</code>来按照字符串指定的时间表运行回调。</p><p id="b926" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它接受一个字符串，该字符串以与 cron 作业相同的方式指定计划。</p><p id="9bda" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个数字是第二个。</p><p id="5f1e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个是分钟。</p><p id="55bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3 号是整点。</p><p id="c773" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">4 号是这个月的第一天。</p><p id="576a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">5 号是月份。</p><p id="0ddf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">6 号是一周中的第一天。</p><p id="76d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们指定小时、分钟和秒来指定它在一天中的运行时间。</p><p id="be2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其余的都是星号，表示它将每天运行。</p><p id="83df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以指定日期来代替一个<code class="fe me mf mg mh b">cron </code>格式的字符串。</p><p id="8658" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9af7" class="mq lc iq mh b gy mr ms l mt mu">const schedule = require('node-schedule');<br/>const date = new Date(2020, 0, 0, 0, 0, 0);</span><span id="39ec" class="mq lc iq mh b gy mv ms l mt mu">const j = schedule.scheduleJob(date, () =&gt; {<br/>  console.log('hello');<br/>});</span></pre><p id="c531" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么回调只在给定的日期运行。</p><p id="c7d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以设置重复规则。</p><p id="e9cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="bf87" class="mq lc iq mh b gy mr ms l mt mu">const schedule = require('node-schedule');</span><span id="d37b" class="mq lc iq mh b gy mv ms l mt mu">const rule = new schedule.RecurrenceRule();<br/>rule.minute = 30;</span><span id="8a74" class="mq lc iq mh b gy mv ms l mt mu">const j = schedule.scheduleJob(rule, () =&gt; {<br/>  console.log('half hour job');<br/>});</span></pre><p id="4003" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<code class="fe me mf mg mh b">schedule.RecurrenceRule</code>构造函数来创建一个规则。</p><p id="9fc9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在上面的例子中设置了<code class="fe me mf mg mh b">minute</code>。</p><p id="ee86" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我们也可以设置<code class="fe me mf mg mh b">second</code>、<code class="fe me mf mg mh b">hour</code>、<code class="fe me mf mg mh b">date</code>、<code class="fe me mf mg mh b">month</code>、<code class="fe me mf mg mh b">year</code>、<code class="fe me mf mg mh b">dayOfWeek</code>。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/698d36877f3c8a96aa1387ae93016edd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nVGuTkdTkV5RiFMV"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@waldemarbrandt67w?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">瓦尔德马尔·布兰特</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="375d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="ac1a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">node-schedule</code>是一个有用的调度程序包。</p><p id="917b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用 supertest 为测试设置标题。</p><p id="8325" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Jest 可以动态定义和运行测试。</p><p id="4726" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">MongoDB 可以参考相关文档。</p><p id="7680" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以将 JavaScript 对象转换成 base64 字符串。</p></div></div>    
</body>
</html>