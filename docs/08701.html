<html>
<head>
<title>Typescript generics is so pragmatic</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Typescript 泛型非常实用</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/typescript-generics-is-so-pragmatic-bf3028401742?source=collection_archive---------11-----------------------#2022-07-04">https://blog.devgenius.io/typescript-generics-is-so-pragmatic-bf3028401742?source=collection_archive---------11-----------------------#2022-07-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="5546" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">只是 Angular app 现实生活中的一些实用编程瞬间。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/be16b4e22663bbcea5a15a2fb6995c9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jAHXwQYJ_eHLEbZG5L5EXQ.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">安德烈·埃西奥诺夫绘画</figcaption></figure><p id="aea7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">泛型方法它是一种特殊的函数，在成员之间提供有意义的类型约束。</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="ac62" class="ld le in kz b gy lf lg l lh li">function treatMethod&lt;T&gt;(args): TypeResult</span></pre><ol class=""><li id="5e1a" class="lj lk in jm b jn jo jr js jv ll jz lm kd ln kh lo lp lq lr bi translated">特殊的 T char 是 type 变量，我们可以使用 type 作为方法的参数。我们的方法将返回一个字符串类型的结果。</li></ol><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="9b38" class="ld le in kz b gy lf lg l lh li">function trestMethod&lt;T&gt;(args): T</span><span id="72c1" class="ld le in kz b gy ls lg l lh li">treatMethod&lt;string&gt;("Test");</span></pre><p id="363d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.我们还可以将类型变量<code class="fe lt lu lv kz b">T</code>用于函数的任何参数。</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="d6b0" class="ld le in kz b gy lf lg l lh li">function treatMethod&lt;T&gt;(arg: T): T</span><span id="5945" class="ld le in kz b gy ls lg l lh li">treatMethod("Test");</span></pre><p id="6340" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是一种论证推理。编译器会将 T 的值设置为我们传入的参数。</p><p id="a84b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.我们也可以使用 extends 操作符来表示我们的<code class="fe lt lu lv kz b">T</code>类型变量的约束。参数变成编译器的字符串。</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="fb3f" class="ld le in kz b gy lf lg l lh li">interface ComplexName{<br/>  name: string;<br/>}<br/>function treatMethod&lt;T extends ComplexName&gt;(arg: T): T {<br/>  arg.name = treatAndParse(arg.name);<br/>  return arg;<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lw"><img src="../Images/80dd2b373f3918abf28cb417ebcae934.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pBbLu8yTEZSAQT6z1xn9Ww.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">安德烈·埃西奥诺夫，水彩画</figcaption></figure><p id="fb54" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">一些练习的例子:</strong></p><p id="5677" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">假设我们有一个包含两种汽车引擎的大量逻辑的界面:电动引擎和汽油引擎。</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="2635" class="ld le in kz b gy lf lg l lh li">export interface Car {}</span><span id="59c4" class="ld le in kz b gy ls lg l lh li">export interface PetrolCar extends Car {<br/>  engineIgnition: boolean;<br/>  isCharged: boolean;<br/>  dataInfo: PetrolCarInfo;<br/>  type: LCLQuotationTs.TypeEnum;<br/>}</span><span id="39d8" class="ld le in kz b gy ls lg l lh li">export namespace PetrolCar{<br/>    export type TypeEnum = 'PetrolCar';<br/>    export const <strong class="kz io"><em class="lx">TypeEnum </em></strong>= {<br/>        PetrolCar: 'PetrolCar' as TypeEnum<br/>    };<br/>}</span><span id="3e47" class="ld le in kz b gy ls lg l lh li">export interface ElectricCar extends Car {<br/>  engineIgnition: boolean;<br/>  isCharged: boolean;<br/>  dataInfo: ElectricCarInfo;<br/>  type: LCLQuotationTs.TypeEnum;<br/>}</span><span id="0e6e" class="ld le in kz b gy ls lg l lh li">export namespace ElectricCar{<br/>    export type TypeEnum = 'ElectricCar';<br/>    export const <strong class="kz io"><em class="lx">TypeEnum </em></strong>= {<br/>        ElectricCar: 'ElectricCar' as TypeEnum<br/>    };<br/>}</span></pre><p id="fc8a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们不想用两种类型得到一堆乱七八糟的代码，所以将借助一个变量“car”来实现处理不同类型的泛型方法。</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="0038" class="ld le in kz b gy lf lg l lh li">export abstract class AbstractRequestComponent&lt;T extends Car&gt; implements OnInit {<br/>  car: T;</span><span id="fdc6" class="ld le in kz b gy ls lg l lh li">  ngOnInit() {<br/>    if (this.car as unknown as PetrolCar) {</span><span id="f0e6" class="ld le in kz b gy ls lg l lh li">      this.engineIgnition(this.car);</span><span id="290e" class="ld le in kz b gy ls lg l lh li">    } else if (this.car as unknown as ElectricCar) {</span><span id="1bc7" class="ld le in kz b gy ls lg l lh li">      if ( this.isCharged(this.car) ) {<br/>        this.engineIgnition(this.car);<br/>      }<br/>    }<br/>  }</span><span id="2ebb" class="ld le in kz b gy ls lg l lh li">  abstract engineIgnition(car: T): Ignition;</span><span id="9b43" class="ld le in kz b gy ls lg l lh li">  abstract isCharged(car: T): boolean;<br/>}</span></pre><p id="3502" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了使代码可读，我们将方法实现分成两个不同的类。</p><p id="90c7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，我们将业务逻辑转移到服务中，在没有 UI 的情况下只处理数据。</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="d6db" class="ld le in kz b gy lf lg l lh li">@Component({<br/>  templateUrl: "./petrolcar-request.component.html"<br/>})<br/>export class PetrolCarRequestComponent extends<br/>  AbstractRequestComponent&lt;PetrolCar&gt; {</span><span id="cc9e" class="ld le in kz b gy ls lg l lh li">  constructor(<br/>    readonly ignitionService: IgnitionService<br/>  ) {<br/>    super(ignitionService);<br/>  }</span><span id="cd90" class="ld le in kz b gy ls lg l lh li">  engineIgnition(car: PetrolCar): boolean {<br/>    return ignitionService.startIgnition(car);<br/>  }</span><span id="0c50" class="ld le in kz b gy ls lg l lh li">  isCharged(car: PetrolCar) {<br/>    throw new Error("Couldn't check charge in petrol engine!");<br/>  }<br/>}</span></pre><p id="dc14" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">和处理电机数据的第二个类似类:</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="cf16" class="ld le in kz b gy lf lg l lh li">@Component({<br/>  templateUrl: "./electriccar-request.component.html"<br/>})<br/>export class ElectricCarRequestComponent extends<br/>  AbstractRequestComponent&lt;ElectricCar&gt; {</span><span id="664a" class="ld le in kz b gy ls lg l lh li">  constructor(<br/>    readonly chargeService: chargeService,<br/>    readonly ignitionService: IgnitionService<br/>  ) {<br/>    super(chargeService, ignitionService);<br/>  }</span><span id="f361" class="ld le in kz b gy ls lg l lh li">  engineIgnition(car: ElectricCar): boolean {<br/>    return ignitionService.startIgnition(car);<br/>  }</span><span id="0d44" class="ld le in kz b gy ls lg l lh li">  isCharged(car: ElectricCar): boolean {<br/>    return chargeService.Charged(car);<br/>  }<br/>}</span></pre><p id="77ef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">服务方法将动态类型作为参数:</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="80fe" class="ld le in kz b gy lf lg l lh li">@Injectable({<br/>  providedIn: "root"<br/>})<br/>export class IgnitionService {</span><span id="7704" class="ld le in kz b gy ls lg l lh li">  startIgnition&lt;T&gt;(car: T): boolean {<br/>    let result: boolean;<br/>    if (isPetrolCar(car)) {<br/>      ...<br/>    } else if (isElectricCar(car)) {<br/>      ...<br/>    }<br/>    return result;<br/>  }<br/>}</span><span id="50b7" class="ld le in kz b gy ls lg l lh li">export function isPetrolCar(car: Car): car is PetrolCar{<br/>  return car !== null &amp;&amp; (car as PetrolCar).type ===<br/>    PetrolCar.<strong class="kz io"><em class="lx">TypeEnum</em></strong>.PetrolCar;<br/>}<br/>export function isElectricCar(car: Car): car is ElectricCar{<br/>  return car !== null<br/>    &amp;&amp; (car as ElectricCar).type=== ElectricCar.<strong class="kz io"><em class="lx">TypeEnum</em></strong>.ElectricCar<br/>    &amp;&amp; !!(car as ElectricCar).dataInfo;<br/>}</span></pre><p id="cc03" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">结论</strong></p><p id="12bd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个特殊的例子中，我使用了 MVC 方法(模型-视图-组件)。但是使用泛型函数也有很多好处，可以将相似的代码逻辑分成不同的子类。</p></div></div>    
</body>
</html>