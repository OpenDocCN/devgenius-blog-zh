# 学习 go —加速您的旅程(第 2 部分)

> 原文：<https://blog.devgenius.io/learning-go-in-2022-boost-your-journey-part-2-2c23c401c7b5?source=collection_archive---------7----------------------->

![](img/4e144f7750ca9110a55441017537e37c.png)

致谢:[https://github.com/MariaLetta/free-gophers-pack](https://github.com/MariaLetta/free-gophers-pack)

本文是学习围棋的第二部分——提升你的旅程。如果你错过了第一部分，点击查看[。](/learning-go-in-2022-boost-your-journey-6edc606ed030)

在本文中，我将重点介绍一些**“高级”Go 功能**，它们可以提升您的编程体验，并帮助您开始构建考虑到**并发性**的 Go 应用程序:

*   戈鲁廷斯
*   频道
*   Goroutine 同步
*   选择—多通道操作
*   原子计数器和互斥

所以，我们开始吧:)

# 戈鲁廷斯

正如我们在 [go by example](https://gobyexample.com/goroutines) 中看到的，Goroutine 是一个轻量级的执行线程**。Goroutines 就像线程，但是更便宜，并且可以与其他函数和方法并发运行。**

给定一个函数`printSomething`，为了在 Goroutine 中运行它，您可以简单地编写:`go printSomething()`。Go 还支持将 Goroutines 作为**匿名函数**运行，语法:`go func() { ... do something ...}()`

当我们启动 Go 程序时，默认情况下会运行一个主 Go 例程。这个特殊的 Go 例程控制程序何时退出，为此，如果你创建了一个或多个子 Go 例程，你需要一种方法在退出程序之前等待它们完成。

为了做到这一点，Go 提供了一个很好的机制来使它们通信和同步:**通道**。

# 频道

我们可以将通道视为一个**管道**，它帮助我们**连接**和**同步** **并发的 Goroutines。**让我们来看看通道的一些基本语法，以加速我们的开发:

*   **创建**一个通道:`make(chan val-type)` *(例如* `*make(chan string)*` *)*
*   通过一个通道发送一个值(**写**)**:`channel <- myValue`**
*   **从通道`myVar := <- channel`接收值(**读取**)**
*   ****关闭** a 通道:`close(channel)`。关闭一个通道意味着**上不再有值被发送**，这对于通知接收者不再有消息通过关闭的通道发送是有用的。
    总是可以关闭一个非空通道，但仍然可以接收剩余的值**
*   **将通道传递给函数时，您可以使用语法将它们标记为**readonly**/**write only**通道:
    –readonly→`func f(myReadOnlyChannel <-chan string)`
    –write only→`func f(myWriteOnlyChannel chan<- string)`**

**知道**默认:**真的很重要**

1.  ****发送**和**接收**都被**阻塞**。这意味着每次:
    –你通过通道发送一个值，线程阻塞等待消息被接收
    –你从通道接收一个值，线程阻塞等待消息出现在通道中**
2.  **通道**无缓冲**意味着它们的**缓冲容量为零。**
    带缓冲容量我指的是**阻塞**之前你的进程可以发送/接收**的消息量****

**如果你不知道自己在做什么，无缓冲通道加上发送和接收阻塞语法使你的 Go 程序成为死锁的好选择。**

**让我们看一个例子更清楚:**

**死锁示例**

**我们可以用两种方法来克服上面的僵局:**

**(1)使用一个**缓冲通道→** 在这种解决方案中，我们在某种程度上破解了默认的 Go 通道语义，使其在达到缓冲限制之前不会阻塞**

**死锁解决方案 1**

**(2)在这个解决方案中使用一个 **Goroutine →** ,我们保持 Go 阻塞语义不变，并引入一个并发执行线程来避免死锁**

**死锁解决方案 2**

# **Goroutines 同步**

**通道对于**跨多个**go routine 同步**执行非常有用。**在 Go 中，根据使用情况，可以通过不同的方式实现同步。**

**(1)当**用**单条线**处理**时，一条粗线通道就能完成**

**单路同步**

**(2)对于涉及**多个 Goroutines** 的更复杂的场景，我们可以利用包`sync`提供的内置 Go `WaitGroup`**

****注意:**如果一个 WaitGroup 被显式地传递到函数中，它应该通过指针来完成**

# **选择—多通道操作**

**当处理多个通道时，Go 提供了一个真正强大的编程构造，帮助我们使代码更加简洁: **Select。****

**选择允许您**等待多通道操作**。你可以把 Select 想象成一个`switch...case`，在这里，你不是打开一个条件，而是**选择**代码来执行**，这取决于**哪个**通道**通过接收/发送一个消息**解除阻塞**。事实上，如上所述，Go 通道是无缓冲的，默认情况下具有阻塞语义。**

**与在`switch...case`中一样，在不满足任何条件的情况下执行`default`情况，这在`select`语句中解释为:没有通道接收到消息或者没有通道能够发送消息。正如您可能注意到的，有一个`default`案例将`select`语义从阻塞转换为不阻塞。**

**在下面的例子中，我简单地说:**

1.  **创建 2 个频道**
2.  **启动一个 Goroutine，在一个无限循环中，使用`select`打印一条消息**
3.  **Goroutine 和 main 进程使用简单的 bool 通道进行同步**

**让我们看一个简单的例子:**

**选择示例**

# **原子计数器和互斥**

**Go 中管理状态的主要机制是通过通道进行通信，但是还有其他一些选项值得一提。**

1.  ****原子包→** 正如[官方文档](https://pkg.go.dev/sync/atomic)中提到的，原子包中包含的所有功能都需要**非常小心才能正确使用**。出于这个原因，除了特殊的、低级别的应用，他们建议与频道或同步包的设施进行同步。无论如何，原子包的一个用例可能是构建一个简单的**原子计数器。**例如，为了给一个 Goroutine 共享变量`myCounter`自动加 1，你可以简单地导入`sync/atomic`包并像
    `atomic.AddUint64(&myCounter, 1)`一样使用它**
2.  ****互斥体→** 互斥体可以用来处理更复杂的状态。正如[官方文档](https://pkg.go.dev/sync#Mutex)中所述，互斥体的零值是一个解锁的互斥体。对互斥体可以做的主要操作有:
    –**声明** → `var myMutex sync.Mutex`。–**锁定** → `myMutex.Lock()`(阻塞直到互斥可用)
    –**解锁** → `myMutex.Unlock()`(如果互斥未锁定则抛出)**

# **结论**

**这只是对 Goroutines 和 Channels 的介绍，但我认为掌握这些概念可以帮助你为下一个 Go 项目打下坚实的基础。**

**如果你喜欢这篇文章，并且想让我知道，请给我一些掌声👏如果您不想错过我的下一篇文章，请关注我；)**

**下一次，我将介绍一些更高级的同步技术，包括有状态的 Goroutines、定时器和 Tickers。**

**下次探索再见:)**