<html>
<head>
<title>5 tips for better unit testing in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang中更好的单元测试的5个技巧</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/5-tips-for-better-unit-testing-in-golang-b25f9e79885a?source=collection_archive---------1-----------------------#2021-12-26">https://blog.devgenius.io/5-tips-for-better-unit-testing-in-golang-b25f9e79885a?source=collection_archive---------1-----------------------#2021-12-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/07d1642359c30c343b532b60276dd5dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RzJ6ZT36D0ttmgiftP9CkA.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">拉塞尔·维斯特布鲁克，本·西蒙斯和地鼠不练习他们的投篮(测试)，因此他们的投篮命中率(覆盖率)很低，导致砖块(虫子)扔向篮筐(项目)。</figcaption></figure><p id="8dfa" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在编写代码项目时，开发人员通常会花费大量时间来选择合适的框架、库、数据库和其他第三方组件。一个经常被忽视的部分是测试。</p><p id="b5c3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">正确的测试实际上会使您的项目更好，因为它们鼓励您:</p><ol class=""><li id="920b" class="kx ky in kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated">应用干净的代码:编写简短的函数，每个函数处理一个任务，等等。</li><li id="ee05" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">通过使用抽象、接口和模拟来编写可扩展和不可知的代码。</li><li id="c0fe" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">通过测试常规/边缘案例和这些案例的高覆盖率，更好地理解业务逻辑。</li><li id="706b" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">避免遗留的、长期未接触的和/或不可维护的代码——测试将简化维护和验证代码变更的过程，使其不会腐烂。</li><li id="1c90" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">通过基准测试、负载测试等来衡量代码的性能。</li></ol><p id="e722" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">虽然测试显然不是由Golang发明或发起的，但该语言提供了丰富的标准库、约定和外部库，缩短了您通向经过适当测试的项目的道路。</p><h1 id="3819" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">表格驱动测试</h1><p id="bbde" class="pw-post-body-paragraph jz ka in kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ig bi translated">当您想要测试的功能处理太多任务时，尤其是当您想要测试许多不同的情况时，测试会很快变得不可读、重复且令人讨厌。</p><p id="bb4e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们看看下面的代码，它天真地检查了一个NBA球员的比赛是好是坏:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="ce51" class="mx lm in mt b gy my mz l na nb">package main<br/><br/>import (<br/>   "fmt"<br/>)<br/><br/>type Stats struct {<br/>   Name string<br/>   Minutes float32<br/>   Points int8<br/>   Rebounds int8<br/>   Assists int8<br/>   Turnovers int8<br/>}<br/><br/>func main() {<br/>   s := Stats{Name: "Stef Kuri", Minutes: 25.1, Points: 21, Assists: 3, Turnovers: 7, Rebounds: 8}<br/>   fmt.Println(hadAGoodGame(s))<br/>}<br/><br/>func hadAGoodGame(stats Stats) (bool, error) {<br/>   if stats.Assists &lt; 0 || stats.Points &lt; 0 || stats.Rebounds &lt; 0 || stats.Minutes &lt; 0 || stats.Turnovers &lt; 0 {<br/>      return false, fmt.Errorf("stat lines cannot be negative")<br/>   }<br/>   if stats.Name == "" {<br/>      return false, fmt.Errorf("missing player name")<br/>   }<br/>   if stats.Assists &gt;= (stats.Turnovers * 2) {<br/>      return true, nil<br/>   }<br/>   if stats.Assists &gt;= 10 &amp;&amp; stats.Rebounds &gt;= 10 &amp;&amp; stats.Points &gt;= 10 {<br/>      return true, nil<br/>   } else if stats.Points &lt; 10 &amp;&amp; stats.Assists &lt; 10 &amp;&amp; stats.Minutes &gt; 25.0 {<br/>      return false, nil<br/>   }<br/>   return false, nil<br/>}</span></pre><p id="652d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">显然，我们有许多案例要测试，让我们从两个案例开始:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="f1ef" class="mx lm in mt b gy my mz l na nb">package main<br/><br/>import (<br/>   "github.com/stretchr/testify/assert"<br/>   "github.com/stretchr/testify/require"<br/>   "testing"<br/>)<br/><br/>func TestHadAGoodGame(t *testing.T) {<br/>   t.Run("sad path: invalid stats", func(t *testing.T) {<br/>      s := Stats{Name: "Sam Cassell",<br/>         Minutes: 34.1,<br/>         Points: -19,<br/>         Assists: 8,<br/>         Turnovers: -4,<br/>         Rebounds: 11,<br/>      }<br/>      _, err := hadAGoodGame(s)<br/>      require.NotNil(t, err)<br/>   })<br/><br/>   t.Run("happy path: good game", func(t *testing.T) {<br/>      s := Stats{Name: "Dejounte Murray",<br/>         Minutes: 34.1,<br/>         Points: 19,<br/>         Assists: 8,<br/>         Turnovers: 4,<br/>         Rebounds: 11,<br/>      }<br/>      isAGoodGame, err := hadAGoodGame(s)<br/>      require.Nil(t, err)<br/>      assert.True(t, isAGoodGame)<br/>   })<br/>}</span></pre><p id="26b0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">你可以看到它的走向:当我们想要测试4个案例时会发生什么？5?我们开始一遍又一遍地重复吗？号码</p><p id="2eb1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">有一种很酷的替代方法叫做<strong class="kb io">表格驱动测试</strong> : <br/>表格驱动测试允许你创建紧凑的、可读的测试，并使其更容易覆盖所有情况，因为事实上所有的测试数据都是有组织的和简洁的。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="d570" class="mx lm in mt b gy my mz l na nb">package main<br/><br/>import (<br/>   "github.com/stretchr/testify/assert"<br/>   "testing"<br/>)<br/><br/>func TestHadAGoodGame(t *testing.T) {<br/>   tests := []struct {<br/>      name     string<br/>      stats   Stats<br/>      goodGame bool<br/>      wantErr  string<br/>   }{<br/>      {"sad path: invalid stats", Stats{Name: "Sam Cassell",<br/>         Minutes: 34.1,<br/>         Points: -19,<br/>         Assists: 8,<br/>         Turnovers: -4,<br/>         Rebounds: 11,<br/>         }, false, "stat lines cannot be negative",<br/>      },<br/>      {"happy path: good game", Stats{Name: "Dejounte Murray",<br/>         Minutes: 34.1,<br/>         Points: 19,<br/>         Assists: 8,<br/>         Turnovers: 4,<br/>         Rebounds: 11,<br/>      }, true, ""},<br/>   }<br/>   for _, tt := range tests {<br/>      isAGoodGame, err := hadAGoodGame(tt.stats)<br/>      if tt.wantErr != "" {<br/>         assert.Contains(t, err.Error(), tt.wantErr)<br/>      } else {<br/>         assert.Equal(t, tt.goodGame, isAGoodGame)<br/>      }<br/>   }<br/>}</span></pre><h1 id="5841" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">测试套</h1><p id="3779" class="pw-post-body-paragraph jz ka in kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ig bi translated">有时候你的测试可能需要你初始化一个上下文，声明一个变量，或者在运行测试之前做一些设置，或者在测试完成后进行拆卸。</p><p id="a5a9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">使用测试套件是实现这一点的便捷方式。<br/> Golang有一个叫做<a class="ae nc" href="http://godoc.org/github.com/stretchr/testify/suite" rel="noopener ugc nofollow" target="_blank">套房</a>的不错的套餐可以帮你到达那里。<br/>(您可能已经注意到，整个<a class="ae nc" href="https://github.com/stretchr/testify" rel="noopener ugc nofollow" target="_blank">evidence</a>存储库包含了帮助您创建质量测试的工具。)</p><p id="e1ab" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在合并了evidence的套件之后，上一节中的测试将如下所示:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="c805" class="mx lm in mt b gy my mz l na nb">package main<br/><br/>import (<br/>   "fmt"<br/>   "github.com/stretchr/testify/suite"<br/>   "testing"<br/>)<br/><br/>type GameTestSuite struct {<br/>   suite.Suite<br/>}<br/><br/>func (suite *GameTestSuite) BeforeTest(_, _ string) {<br/>   // execute code before test starts<br/>   fmt.Println("BEFORE")<br/>}<br/><br/>func (suite *GameTestSuite) AfterTest(_, _ string) {<br/>   // execute code after test finishes<br/>   fmt.Println("AFTER")<br/>}<br/><br/>func (suite *GameTestSuite) SetupSuite() {<br/>   // create relevant resources<br/>   fmt.Println("SETUP")<br/>}<br/><br/>func TestGameTestSuite(t *testing.T) {<br/>   suite.Run(t, new(GameTestSuite))<br/>}<br/><br/>func (suite *GameTestSuite) TestHadAGoodGame() {<br/>   tests := []struct {<br/>      name     string<br/>      stats    Stats<br/>      goodGame bool<br/>      wantErr  string<br/>   }{<br/>      {"sad path: invalid stats", Stats{Name: "Sam Cassell",<br/>         Minutes: 34.1,<br/>         Points: -19,<br/>         Assists: 8,<br/>         Turnovers: -4,<br/>         Rebounds: 11,<br/>      }, false, "stat lines cannot be negative",<br/>      },<br/>      {"happy path: good game", Stats{Name: "Dejounte Murray",<br/>         Minutes: 34.1,<br/>         Points: 19,<br/>         Assists: 8,<br/>         Turnovers: 4,<br/>         Rebounds: 11,<br/>      }, true, ""},<br/>   }<br/>   for _, tt := range tests {<br/>      suite.T().Run("test hadAGoodGame(): "+tt.name, func(t *testing.T) {<br/>         isAGoodGame, err := hadAGoodGame(tt.stats)<br/>         if tt.wantErr != "" {<br/>            suite.Require().Contains(err.Error(), tt.wantErr)<br/>         } else {<br/>            suite.Require().Equal(tt.goodGame, isAGoodGame)<br/>         }<br/>      })<br/>   }<br/>}</span></pre><h1 id="6ece" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">使用接口并避免文件I/O</h1><p id="7072" class="pw-post-body-paragraph jz ka in kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ig bi translated">现在我们有了一个从文件中读取球员数据并打印出来的函数:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="46e7" class="mx lm in mt b gy my mz l na nb">package main<br/><br/>import (<br/>   "encoding/json"<br/>   "fmt"<br/>   "io/ioutil"<br/>   "os"<br/>)<br/><br/>type Player struct {<br/>   Name   string `json:"name"`<br/>   Age    int    `json:"Age"`<br/>}<br/><br/>func main() {<br/>   processData("data.txt")<br/>}<br/><br/>func processData(file string) error {<br/>   f, err := os.Open(file)<br/>   if err != nil {<br/>      return err<br/>   }<br/>   defer f.Close()<br/>   data, err := ioutil.ReadAll(f)<br/>   if err != nil {<br/>      return err<br/>   }<br/>   var players []Player<br/><br/>   err = json.Unmarshal(data, &amp;players)<br/>   if err != nil {<br/>      return err<br/>   }<br/><br/>   for _, p := range players {<br/>      fmt.Println("Player name: ", p.Name)<br/>   }<br/>   return nil<br/>}</span></pre><p id="2888" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">有什么不好？</p><ol class=""><li id="bf15" class="kx ky in kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated">不容易测试，因为在运行测试之前，您需要确保<code class="fe nd ne nf mt b">data.txt</code>文件存在并且包含数据</li><li id="e844" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">如果有大量数据，而执行测试的服务器有一些较低级别的硬件，该怎么办？</li><li id="58e9" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">您也不希望遇到并发测试使用/修改同一个文件的竞争情况</li></ol><p id="c2eb" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">您希望您的测试快速、独立、孤立、一致而不古怪。</p><p id="7aea" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">更好的方法是这样的:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="0b14" class="mx lm in mt b gy my mz l na nb">package main<br/><br/>import (<br/>   "encoding/json"<br/>   "fmt"<br/>   "io/ioutil"<br/>   "os"<br/>   "io"<br/>)<br/><br/>type Player struct {<br/>   Name   string `json:"name"`<br/>   Age    int    `json:"age"`<br/>}<br/><br/>func main() {<br/>   processData("data.txt")<br/>}<br/><br/>func processData(file string) error {<br/>   f, err := os.Open(file)<br/>   if err != nil {<br/>      return err<br/>   }<br/>   defer f.Close()<br/>   return unmarshalAndPrint(f)<br/>}<br/><br/>func unmarshalAndPrint(f io.Reader) error {<br/>   data, err := ioutil.ReadAll(f)<br/>   if err != nil {<br/>      return err<br/>   }<br/>   var players []Player<br/><br/>   err = json.Unmarshal(data, &amp;players)<br/>   if err != nil {<br/>      return err<br/>   }<br/><br/>   for _, p := range players {<br/>      fmt.Println("Player name: ", p.Name)<br/>   }<br/>   return nil<br/>}</span></pre><p id="9cda" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">测试文件:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="c2b5" class="mx lm in mt b gy my mz l na nb">package main<br/><br/>import (<br/>   "github.com/stretchr/testify/assert"<br/>   "strings"<br/>   "testing"<br/>)<br/><br/>func TestUnmarshalAndPrint(t *testing.T) {<br/>   t.Run("testing unmarshalAndPrint()", func(t *testing.T) {<br/>      err := unmarshalAndPrint(strings.NewReader(`[{"name": "Dubi Gal", "age": 900}]`))<br/>      assert.Nil(t, err)<br/>   })<br/>}</span></pre><p id="5ba4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在为了测试，我们不用准备数据和打开文件，只需将一个JSON字符串传递给<code class="fe nd ne nf mt b">strings.NewReader</code></p><p id="ce2f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">但是，如果出于某种原因，您仍然必须与文件系统进行交互，请考虑使用以下资源:<br/> <a class="ae nc" href="https://github.com/spf13/afero" rel="noopener ugc nofollow" target="_blank"> AFERO </a>:用于Go <br/> <a class="ae nc" href="https://godocs.io/testing/fstest" rel="noopener ugc nofollow" target="_blank"> fstest </a> —测试文件系统的实现和用户<br/> <a class="ae nc" href="https://pkg.go.dev/io/ioutil#TempFile" rel="noopener ugc nofollow" target="_blank"> TempFile </a>，<a class="ae nc" href="https://pkg.go.dev/io/ioutil#TempDir" rel="noopener ugc nofollow" target="_blank"> TempDir </a> —创建临时文件/目录</p><h1 id="e5ed" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">使用httptest</h1><p id="696a" class="pw-post-body-paragraph jz ka in kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ig bi translated">与上面的相似，但是这一个值得它自己的一个部分。</p><p id="201e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">假设您有一个接收NBA球员数据、验证数据并通过HTTP请求进行保存或进一步处理的函数:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="a2e3" class="mx lm in mt b gy my mz l na nb">package main<br/><br/>import (<br/>   "bytes"<br/>   "fmt"<br/>   "net/http"<br/>   "encoding/json"<br/>)<br/><br/>func main() {<br/>   playerInfo := PlayerInfo{Name: "White Mambda", Team: "San Antonio Spurs", Position: "Forward"}<br/>   err := savePlayerInfo(playerInfo, "http://players.nba.com")<br/>   if err != nil {<br/>      panic(err)<br/>   }<br/>}<br/><br/>type PlayerInfo struct {<br/>   Name    string<br/>   Team    string<br/>   Position string<br/>}<br/><br/>func savePlayerInfo(playerInfo PlayerInfo, url string) error {<br/>   if playerInfo.Name == "" || playerInfo.Position == "" || playerInfo.Team == "" {<br/>      return fmt.Errorf("missing data")<br/>   }<br/>   b, err := json.Marshal(playerInfo)<br/>   if err != nil {<br/>      return err<br/>   }<br/>   body := bytes.NewBuffer(b)<br/>   req, err := http.NewRequest("POST", url, body)<br/>   req.Header.Set("Content-Type", "application/json")<br/>   client := &amp;http.Client{}<br/>   _, err = client.Do(req)<br/>   return err<br/>}</span></pre><p id="4ff5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">你如何测试这个函数？</p><p id="9c28" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">嗯，您可能已经发现自己正在测试一个发出HTTP请求的函数。通常，请求本身并不是您想要测试的部分，而是其他东西，比如输入/输出是如何被处理/操作的..<br/>此外，您不希望您的测试依赖于第三方，第三方可能会限制或限制您的测试，这可能会使您的测试不可靠或影响您的测试结果。</p><p id="5a51" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><a class="ae nc" href="https://pkg.go.dev/net/http/httptest" rel="noopener ugc nofollow" target="_blank"> httptest </a>包提供了用于HTTP测试的实用程序，并将轻松地处理您的测试的HTTP请求。</p><p id="0c03" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">使用httptest，您的测试看起来是这样的:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="34b2" class="mx lm in mt b gy my mz l na nb">package main<br/><br/>import (<br/>   "github.com/stretchr/testify/require"<br/>   "net/http"<br/>   "net/http/httptest"<br/>   "testing"<br/>)<br/><br/>func TestSavePlayerInfo(t *testing.T) {<br/>   testServer := httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {<br/>      res.Header().Set("Content-Type", "application/json")<br/>      res.WriteHeader(http.<em class="ng">StatusOK</em>)<br/>      _, err := res.Write([]byte(`{"message": "success"`))<br/>      if err != nil {<br/>         panic("cannot return http response")<br/>      }<br/>   }))<br/>   defer testServer.Close()<br/><br/>   t.Run("sad path: invalid stats", func(t *testing.T) {<br/>      s := PlayerInfo{Name: "Denis Rodman", Team: "Chicago Bulls", Position: "Forward"}<br/>      err := savePlayerInfo(s, testServer.URL)<br/>      require.Nil(t, err)<br/>   })<br/>}</span></pre><p id="8502" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">您可以控制响应、标题、状态代码和基本上您需要的一切。</p><h1 id="c0a5" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">基准测试您的代码</h1><p id="dcf4" class="pw-post-body-paragraph jz ka in kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ig bi translated">Golang的测试包中集成了基准测试，可以帮助您加快代码执行速度，避免代价高昂的性能损失。</p><p id="908b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">有没有想过解组JSON最有效的方法是什么？</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="19da" class="mx lm in mt b gy my mz l na nb">package main<br/><br/>import (<br/>   "encoding/json"<br/>   "io"<br/>   "io/ioutil"<br/>)<br/>/*<br/>func main() {<br/>   _, err := jsonDecoder(strings.NewReader(`[{"name": "Dubi Gal", "age": 900}]`))<br/>   if err != nil {<br/>      fmt.Println(err)<br/>   }<br/><br/>   _, err = readAll(strings.NewReader(`[{"name": "Dubi Gal", "age": 900}]`))<br/>   if err != nil {<br/>      fmt.Println(err)<br/>   }<br/>}<br/>*/<br/><br/>type Player struct {<br/>   Name   string `json:"name"`<br/>   Age    int    `json:"age"`<br/>}<br/><br/>func jsonDecoder(r io.Reader) ([]Player, error) {<br/>   var players []Player<br/>   return players, json.NewDecoder(r).Decode(&amp;players)<br/>}<br/><br/>func readAll(r io.Reader) ([]Player, error) {<br/>   var players []Player<br/>   bytez, err := ioutil.ReadAll(r)<br/>   if err != nil {<br/>      return players, err<br/>   }<br/><br/>   return players, json.Unmarshal(bytez, &amp;players)<br/>}</span></pre><p id="db07" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们去基准测试吧！(更大的数据集显然会产生更准确的结果)<br/>测试文件:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="d4c4" class="mx lm in mt b gy my mz l na nb">package main<br/><br/>import (<br/>   "strings"<br/>   "testing"<br/>)<br/><br/>var players = `[{"name": "Dubi Gal", "age": 900}, {"name": "jojo", "age": 51}]`<br/><br/>func BenchmarkJsonDecoder(b *testing.B) {<br/>   b.ReportAllocs()<br/>   for n := 0; n &lt; b.N; n++ {<br/>      jsonDecoder(strings.NewReader(players))<br/>   }<br/>}<br/><br/>func BenchmarkReadAll(b *testing.B) {<br/>   b.ReportAllocs()<br/>   for n := 0; n &lt; b.N; n++ {<br/>      readAll(strings.NewReader(players))<br/>   }<br/>}</span></pre><p id="71b6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">结果:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="f131" class="mx lm in mt b gy my mz l na nb">$ go test -bench=.</span><span id="bac0" class="mx lm in mt b gy nh mz l na nb">goos: darwin<br/>goarch: amd64<br/>pkg: medium/aaa2<br/>cpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz<br/>BenchmarkJsonDecoder-12           600022              1984 ns/op            1128 B/op         15 allocs/op<br/>BenchmarkReadAll-12               620658              1820 ns/op             928 B/op         13 allocs/op<br/>PASS<br/>ok      medium/aaa2     3.733s</span></pre><p id="33c3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在这个基准测试中，我们发现<code class="fe nd ne nf mt b">io.ReadAll</code>方法的性能稍好一些。这是由于对象已在内存中。<br/>在流式传输和/或处理大量数据(数百兆字节或更多)时，JSON Decoder可能是更好的选择。但现在我们已经知道如何进行基准测试，您可以自行进行基准测试和实验！</p></div></div>    
</body>
</html>