<html>
<head>
<title>Mutable and immutable in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript 中的可变和不可变</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/mutable-and-immutable-in-javascript-78a3cbc6187c?source=collection_archive---------0-----------------------#2019-10-21">https://blog.devgenius.io/mutable-and-immutable-in-javascript-78a3cbc6187c?source=collection_archive---------0-----------------------#2019-10-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/b60ae13b2fe07c606d4e3a57d1038684.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*m6bUaA-1xsHICpJC"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated"><a class="ae ja" href="https://unsplash.com/@tormius?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Adri Tormo </a>在<a class="ae ja" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><div class=""/><p id="12c0" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">根据 T4 的定义</p><blockquote class="ky kz la"><p id="05a1" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><em class="jd">可变</em>是一种可以改变的变量。在 JavaScript 中，只有<a class="ae ja" href="https://developer.mozilla.org/en-US/docs/Glossary/Object" rel="noopener ugc nofollow" target="_blank">对象</a>和<a class="ae ja" href="https://developer.mozilla.org/en-US/docs/Glossary/Array" rel="noopener ugc nofollow" target="_blank">数组</a>是可变的，而不是<a class="ae ja" href="https://developer.mozilla.org/en-US/docs/Glossary/primitive" rel="noopener ugc nofollow" target="_blank">原始值</a>。</p><p id="2552" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">一个<strong class="kc je">可变对象</strong>是一个对象，它的状态在它被创建后可以被修改。</p><p id="306f" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><strong class="kc je">不变量</strong>是一旦对象被创建，其状态就不能改变的对象。</p></blockquote><h1 id="c6a3" class="lf lg jd bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">我们来分解一下</h1><p id="abb4" class="pw-post-body-paragraph ka kb jd kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">JavaScript 中有两种数据类型——基本类型(值类型)和非基本类型(引用类型)。</p><figure class="mj mk ml mm gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mi"><img src="../Images/23216b4c7afe3cadfee6dd01f6113389.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jWWisFncH1QZFP4ZSbxTQw.png"/></div></div></figure><h2 id="30e7" class="mn lg jd bd lh mo mp dn ll mq mr dp lp kl ms mt lt kp mu mv lx kt mw mx mb my bi translated">值类型</h2><p id="6af0" class="pw-post-body-paragraph ka kb jd kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">值类型存储在内存中的堆栈<strong class="kc je">中。栈只是一个数据</strong>的<strong class="kc je">栈，具有“后进先出”的数据结构。它没有太多的空间(与其他数据结构相比)，但由于它的工作方式，它的访问速度非常快。</strong></p><p id="5e84" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当在内存中存储一个值类型时，它用新创建的变量的值将一个元素添加到堆栈的顶部。当创建一个新变量并将第一个变量赋给新变量时，它会在堆栈顶部添加一个新元素，该元素包含新变量的值(即第一个创建的变量的值)。</p><p id="7b75" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通过创造</p><pre class="mj mk ml mm gt mz na nb nc aw nd bi"><span id="635a" class="mn lg jd na b gy ne nf l ng nh">var name = "Maya";<br/>var newName = name;</span></pre><p id="8ba2" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第一个变量— <strong class="kc je"> name </strong>与变量 data 的值一起进入堆栈。然后，<strong class="kc je"> newName </strong>用变量 data 的值进入堆栈的新内存位置。</p><figure class="mj mk ml mm gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi ni"><img src="../Images/24fde810dc3cf4144a485ad08d68532f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*shQBULqHJR1AsRbqGPikAw.png"/></div></div></figure><h2 id="afb3" class="mn lg jd bd lh mo mp dn ll mq mr dp lp kl ms mt lt kp mu mv lx kt mw mx mb my bi translated">参考类型</h2><p id="88be" class="pw-post-body-paragraph ka kb jd kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">引用类型存储在<strong class="kc je">堆</strong>中。堆与堆栈无关，没有存储数据的顺序。你可以把它想象成随机存储数据，每个数据都有自己的地址。它的访问速度较慢，但由于它处理更复杂的变量，所以有更多的空间。</p><p id="b3fa" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当在内存中存储引用类型时，当它的值是指向已经存储在<strong class="kc je">堆</strong>上的对象地址的指针/引用时，它将一个新元素添加到<strong class="kc je">栈</strong>的顶部。</p><p id="0405" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通过创造</p><pre class="mj mk ml mm gt mz na nb nc aw nd bi"><span id="5fc2" class="mn lg jd na b gy ne nf l ng nh">var Person = {name: "Maya", age: "29"}<br/>var newPerson = Person;</span></pre><p id="b103" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一个新元素进入<strong class="kc je">栈</strong>，其值为已经存储在<strong class="kc je">堆</strong>中的<strong class="kc je">人</strong>对象的<strong class="kc je">指针/引用</strong>。</p><figure class="mj mk ml mm gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nj"><img src="../Images/2813cb00e882491cde6fbbd8e653b776.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9sL85S8e6uxdZ-H-Fc8ffA.png"/></div></div></figure><p id="cdfe" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当创建一个<strong class="kc je"> newPerson </strong>对象并将<strong class="kc je"> Person </strong>对象分配给它时，它将一个新元素添加到<strong class="kc je">堆栈</strong>的顶部，其值为已经存储在<strong class="kc je">堆</strong>上的第一个<strong class="kc je"> Person </strong>对象的<strong class="kc je">指针/引用</strong>。</p><figure class="mj mk ml mm gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nk"><img src="../Images/f715c2236576f52d3bcb8e09283e1dbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*18hC__pL122erNSZ1wA01w.png"/></div></div></figure><h2 id="a79b" class="mn lg jd bd lh mo mp dn ll mq mr dp lp kl ms mt lt kp mu mv lx kt mw mx mb my bi translated">让我们看看一些代码</h2><p id="18b6" class="pw-post-body-paragraph ka kb jd kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">让我们创建一个以字符串为值的变量。然后，我们创建一个新变量，并将第一个变量赋给它。然后，我们将更改第一个变量值。我们将在创建变量后打印每个变量。</p><pre class="mj mk ml mm gt mz na nb nc aw nd bi"><span id="7b54" class="mn lg jd na b gy ne nf l ng nh">var name = 'Maya';<br/>console.log(name);</span><span id="9eb8" class="mn lg jd na b gy nl nf l ng nh">var newName = name;<br/>console.log(newName);</span><span id="75a4" class="mn lg jd na b gy nl nf l ng nh">name = 'Joe';<br/>console.log(newName);</span></pre><p id="4399" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不出意外的话，我们将在控制台中看到它。</p><figure class="mj mk ml mm gt ip gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/a65ef5ca9b0405c9693afa73b3fb3d01.png" data-original-src="https://miro.medium.com/v2/resize:fit:380/format:webp/1*O2WYzAhumSQ4gYWA3aBxiw.png"/></div></figure><p id="d31f" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，让我们创建一个对象变量。然后，我们将创建一个新的对象变量，并将第一个对象赋给它。然后，我们将更改第一个对象的数据。同样，我们将在创建变量后打印每个变量。</p><pre class="mj mk ml mm gt mz na nb nc aw nd bi"><span id="1b3b" class="mn lg jd na b gy ne nf l ng nh">var person = {name:'Maya', age:29};<br/>console.log(person);</span><span id="6731" class="mn lg jd na b gy nl nf l ng nh">var newPerson = person;<br/>console.log(newPerson);</span><span id="a4a0" class="mn lg jd na b gy nl nf l ng nh">person.name = 'Joe';<br/>console.log(newPerson);</span></pre><p id="b411" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这一次，我们将在控制台中看到</p><figure class="mj mk ml mm gt ip gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/9cdce8b123c478031bd649c6766dc0c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:430/format:webp/1*7v0vSfQEyw_hTp36wc5Rrw.png"/></div></figure><h2 id="fa9f" class="mn lg jd bd lh mo mp dn ll mq mr dp lp kl ms mt lt kp mu mv lx kt mw mx mb my bi translated">可变和不可变</h2><p id="f288" class="pw-post-body-paragraph ka kb jd kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">你知道改变值类型<strong class="kc je">名字</strong>数据不会影响<strong class="kc je">新名字</strong>数据，但是当改变<strong class="kc je">人物</strong>对象数据时，它会影响<strong class="kc je">新人物</strong>数据吗？</p><p id="d5c1" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是由于数据的存储方式造成的。</p><p id="9d08" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每次创建值类型时，都会有一个新元素进入堆栈的顶部，存储该变量的数据。另一方面，当创建一个引用类型时，一个新元素进入堆栈的顶部，但是这次，它将引用/指针存储到堆中对象的地址位置。然后，当我们将创建的对象赋给一个新的对象变量时，一个新元素进入堆栈的顶部，但具有指向第一个对象的相同引用/指针。</p><p id="8ea3" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc je">因此，当改变一个已创建对象的数据时，指向堆上相同地址位置的所有其他对象也被改变。</strong></p><p id="dfc3" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">记住这一点，我们可以说<strong class="kc je">值类型是不可变的</strong>，而<strong class="kc je">引用类型是可变的</strong>。</p></div></div>    
</body>
</html>