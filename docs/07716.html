<html>
<head>
<title>State pattern for changing internal processes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">改变内部流程的状态模式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/state-pattern-for-changing-internal-processes-kotlin-72bd4ef92b2e?source=collection_archive---------5-----------------------#2022-04-18">https://blog.devgenius.io/state-pattern-for-changing-internal-processes-kotlin-72bd4ef92b2e?source=collection_archive---------5-----------------------#2022-04-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="4aaf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi ki translated">亲爱的模式学习者，很高兴再次见到你👨‍💻。这是“设计模式”系列的下一篇文章，我开始传播它们的乐趣。一定要看看我以前的所有文章，我在这些文章中分解了许多关于面向对象设计的有用的东西📝：</p><ul class=""><li id="dc53" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">策略模式:<a class="ae la" href="/towardsdev/strategy-pattern-for-independent-algorithms-kotlin-70ed24c7bd8b" rel="noopener ugc nofollow" target="_blank">https://medium . com/toward sdev/strategy-pattern-for-independent-algorithms-kot Lin-70 ed 24 c 7 BD 8 b</a></li><li id="93b0" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">观察者模式:<a class="ae la" href="/towardsdev/observer-pattern-for-loose-coupling-kotlin-f5ab804609bb" rel="noopener ugc nofollow" target="_blank">https://medium . com/toward sdev/observer-pattern-for-loose-coupling-kot Lin-f5ab 804609 bb</a></li><li id="dfbd" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">装饰模式:<a class="ae la" href="/towardsdev/decorator-decorator-pattern-for-object-composition-kotlin-7cec92cbaf7b" rel="noopener ugc nofollow" target="_blank">https://medium . com/toward sdev/decorator-decorator-pattern-for-object-composition-kot Lin-7 CEC 92 cbaf 7b</a></li><li id="ec0a" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">工厂模式:<a class="ae la" href="/dev-genius/factory-patterns-to-hide-instantiation-kotlin-d5f01cf01921" rel="noopener ugc nofollow" target="_blank">https://medium . com/dev-genius/factory-patternS-to-hide-instantiation-kot Lin-D5 f 01 cf 01921</a></li><li id="aacc" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">单例模式:<a class="ae la" href="/dev-genius/singleton-pattern-for-one-of-a-kind-objects-java-a63c774d9d4" rel="noopener ugc nofollow" target="_blank">https://medium . com/dev-genius/singleton-pattern-for-one-of-a-class-objects-Java-a63c 774 d9d 4</a></li><li id="d61b" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">命令模式:<a class="ae la" href="/dev-genius/command-pattern-for-encapsulated-invocation-kotlin-4338eb23d2ca" rel="noopener ugc nofollow" target="_blank">https://medium . com/dev-genius/command-pattern-for-encapsulated-invocation-kot Lin-4338 EB 23 D2 ca</a></li><li id="a42e" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">适配器和外观模式:<a class="ae la" href="/dev-genius/adapter-facade-pattern-for-perfect-adapting-kotlin-ccbc8f8cfcd6" rel="noopener ugc nofollow" target="_blank">https://medium . com/dev-genius/adapter-Facade-pattern-for-perfect-adapting-kot Lin-ccbc 8 f 8 cfcd 6</a></li><li id="e842" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">模板模式:<a class="ae la" href="/dev-genius/template-pattern-for-encapsulating-algorithms-kotlin-3ded81377fc5" rel="noopener ugc nofollow" target="_blank">https://medium . com/dev-genius/template-pattern-for-encapsulating-algorithms-kot Lin-3d ed 81377 fc 5</a></li><li id="4a74" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">迭代器和复合模式:<a class="ae la" href="https://medium.com/dev-genius/iterator-composite-patterns-for-managing-collection-kotlin-fda036ffda9f" rel="noopener">https://medium . com/dev-genius/iterator-Composite-patterns-for-managing-collection-kot Lin-FDA 036 ffda 9 f</a></li></ul><p id="1ac6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">像往常一样，我提到<a class="lg lh ep" href="https://medium.com/u/fbfa235a954c?source=post_page-----72bd4ef92b2e--------------------------------" rel="noopener" target="_blank">奥莱利媒体</a>，因为他们的宏伟的书给了我很大的帮助:<a class="ae la" href="https://www.oreilly.com/library/view/head-first-design/9781492077992/" rel="noopener ugc nofollow" target="_blank">https://www . oreilly . com/library/view/head-first-design/9781492077992/</a></p><p id="38a4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">结构:</p><ul class=""><li id="3af2" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">介绍</li><li id="4bad" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">问题</li><li id="13ef" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated"><code class="fe li lj lk ll b">null</code>本文遵循的设计原则</li><li id="ff5c" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">最终解决方案代码</li><li id="2c77" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">额外部分</li><li id="3a6a" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">图画</li></ul></div><div class="ab cl lm ln hr lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ig ih ii ij ik"><h1 id="7515" class="lt lu in bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">状态模式</h1><h2 id="75f3" class="mr lu in bd lv ms mt dn lz mu mv dp md jv mw mx mh jz my mz ml kd na nb mp nc bi translated">介绍</h2><p id="b90f" class="pw-post-body-paragraph jk jl in jm b jn nd jp jq jr ne jt ju jv nf jx jy jz ng kb kc kd nh kf kg kh ig bi translated">开始这篇新文章时，我想指出一个事实:一些模式在描述上非常相似，甚至可能解决相关类型的问题，但是它们选择的方法却大相径庭🎭</p><p id="8e07" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为什么我要提到这些信息？实际上，<strong class="jm io">策略模式</strong>，在本系列的第一篇文章中已经介绍过了(是的，通读一遍😬:<a class="ae la" href="/towardsdev/strategy-pattern-for-independent-algorithms-kotlin-70ed24c7bd8b" rel="noopener ugc nofollow" target="_blank">https://medium . com/towardsdev/strategy-pattern-for-independent-algorithms-kot Lin-70 ed 24 c 7 BD 8 b</a>)和本文中的<strong class="jm io">状态模式</strong>可能看起来很相似，大家可能会猜测有什么用途等等。被激起了兴趣？让我们进入问题部分，稍后我会回到这个 discussion🪃.</p><h2 id="6fd4" class="mr lu in bd lv ms mt dn lz mu mv dp md jv mw mx mh jz my mz ml kd na nb mp nc bi translated">问题</h2><p id="cf39" class="pw-post-body-paragraph jk jl in jm b jn nd jp jq jr ne jt ju jv nf jx jy jz ng kb kc kd nh kf kg kh ig bi translated">直截了当地说:这个<strong class="jm io">模式</strong>用于改变系统的内部状态。</p><p id="8a21" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，我们需要创建一个系统，它将从 user🥷获取输入，然后根据条件执行它。假设您对此模式一无所知，并以普通的完全没有模式的方式应用概念解决方案。</p><p id="8f2b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">系统的设计💭：</p><p id="042b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ni">开始状态:</em></p><ul class=""><li id="55a6" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated"><strong class="jm io">无季度</strong>是开始状态</li><li id="b3f0" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated"><strong class="jm io">有四分之一</strong>是你装球的时候</li><li id="f970" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated"><strong class="jm io">售出的口香糖球</strong>是当你转动曲柄时，球被加工</li><li id="2601" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated"><strong class="jm io">当<strong class="jm io">售出的口香糖</strong>发现机器没有剩余的口香糖时</strong>到达口香糖用尽</li></ul><p id="eeaa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ni">下一步行动:</em></p><ul class=""><li id="c260" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated"><strong class="jm io">插入四分之一</strong>——当我们装入球时</li><li id="594f" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated"><strong class="jm io">弹出四分之一</strong> —移除球并回到先前状态</li><li id="e6de" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated"><strong class="jm io">转动曲柄</strong> —加工球</li><li id="b753" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated"><strong class="jm io">分配球</strong> —在下一个状态之前重新充电的内部动作</li></ul><pre class="nj nk nl nm gt nn ll no np aw nq bi"><span id="7ce4" class="mr lu in ll b gy nr ns l nt nu"><strong class="ll io">No Quarter</strong> &lt;- (insert quarter || eject quarter) -&gt; <strong class="ll io">Has Quarter</strong> - (turn crank) -&gt; (see next line)</span><span id="6138" class="mr lu in ll b gy nv ns l nt nu"><strong class="ll io">Gumball Sold</strong> - (dispense gumball &amp; gumball &gt; 0) -&gt; <strong class="ll io">No Quarter</strong><br/>     |<br/>     <br/>   (dispense gumball &amp; gumball = 0)<br/>     |<br/>   <strong class="ll io">Out Of Gumballs</strong>  <br/>     |<br/>   (use refill() to load new gumballs &amp; enter <strong class="ll io">NoQuarter)</strong></span></pre><p id="af3a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">嗯，你可以考虑一下，记下下面的解决方法:</p><figure class="nj nk nl nm gt nw"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="64fe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">分析 it🧠:</p><ul class=""><li id="2c19" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">你有描述<strong class="jm io">状态</strong>的变量</li><li id="2549" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">你有<strong class="jm io">当前状态</strong></li><li id="2b53" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">你有<strong class="jm io">个口香糖球</strong></li></ul><p id="b273" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您将通过实例化这个类来触发动作&amp;逐个调用方法。</p><p id="a70b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可能会想，听起来不错。为什么我们需要你的模式？🤨</p><p id="fb9d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">变化有 come…🛠，你需要调整你的设计。</p><ul class=""><li id="c07a" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">添加新的<strong class="jm io">状态</strong></li><li id="5706" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">返工大多数<strong class="jm io">方法</strong></li></ul><p id="ae2e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这意味着:</p><ul class=""><li id="a89a" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">违反<strong class="jm io">开闭原则</strong>:阅读<strong class="jm io">装饰模式</strong>，其中解释了该原则<a class="ae la" href="https://towardsdev.com/decorator-decorator-pattern-for-object-composition-kotlin-7cec92cbaf7b" rel="noopener ugc nofollow" target="_blank">https://towardsdev . com/Decorator-Decorator-Pattern-for-object-composition-kot Lin-7 CEC 92 cbaf 7b</a></li><li id="2131" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">否<strong class="jm io"> OOP </strong></li><li id="027a" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">转换在那些方法中<strong class="jm io">，这使得很难找到它们</strong></li><li id="7419" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">进一步的变化会产生<strong class="jm io">bug</strong>🪲</li></ul><p id="73c4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们来处理更改代码的步骤:</p><ul class=""><li id="5b6f" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">封装变化:<strong class="jm io">状态</strong></li><li id="f847" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">使用<strong class="jm io">构图</strong></li><li id="0739" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated"><strong class="jm io">开闭原理</strong>:每种状态都是关闭修改，但机器是开放扩展的</li></ul><p id="32e4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">全新改造的 solution✨:</p><ul class=""><li id="6ae0" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">定义所有<strong class="jm io">状态</strong>方法的状态<code class="fe li lj lk ll b">interface</code></li><li id="e9c0" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">为每个<strong class="jm io">状态</strong>单独分类</li><li id="3a9c" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">代码中没有<strong class="jm io">条件</strong>:变化将发生在一个<strong class="jm io">主类</strong>中</li><li id="246a" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">依赖<strong class="jm io">抽象</strong>:机器依赖于<code class="fe li lj lk ll b">interface</code> &amp;所有<strong class="jm io">状态</strong>也依赖于它。阅读关于<strong class="jm io">工厂模式</strong>的文章，在那里我更彻底地讨论了它<a class="ae la" href="https://medium.com/dev-genius/factory-patterns-to-hide-instantiation-kotlin-d5f01cf01921" rel="noopener">https://medium . com/dev-genius/Factory-Patterns-to-hide-instantiation-kot Lin-D5 f 01 cf 01921</a></li></ul><pre class="nj nk nl nm gt nn ll no np aw nq bi"><span id="d45a" class="mr lu in ll b gy nr ns l nt nu">                       interface<!-- --> State<br/>                  /       |        |             \<br/>           SoldState SoldOutState NoQuarterState HasQuarterState</span><span id="38bf" class="mr lu in ll b gy nv ns l nt nu">GumballMachine - through composition has access to all States</span><span id="9adf" class="mr lu in ll b gy nv ns l nt nu">+ other new States will be possible</span></pre><p id="b189" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在大多数情况下，<strong class="jm io">机器</strong>中的方法会在<strong class="jm io">状态</strong>中被复制，即当用户在<strong class="jm io">机器</strong>上执行某个动作时——它会被传输到特定的<strong class="jm io">状态</strong>(取决于机器的当前状态)||或者根本不被传输，如果这个<strong class="jm io">状态</strong>是 impossible🦾.的话</p><ul class=""><li id="8c55" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">代码的更多细微差别将在<strong class="jm io">最终解决方案代码</strong>部分<code class="fe li lj lk ll b">=&gt;</code>中观察和解释，如果您对实现的理解模糊不清，请不要担心😥。</li></ul><h2 id="8029" class="mr lu in bd lv ms mt dn lz mu mv dp md jv mw mx mh jz my mz ml kd na nb mp nc bi translated">最终解决方案代码</h2><p id="9cd6" class="pw-post-body-paragraph jk jl in jm b jn nd jp jq jr ne jt ju jv nf jx jy jz ng kb kc kd nh kf kg kh ig bi translated">让我们深入代码演练，我将仔细阅读代码，使您全面了解 clearer✌🏽。</p><div class="nz oa gp gr ob oc"><a href="https://github.com/SleeplessChallenger/KotlinDesignPatterns/tree/main/src/main/kotlin/StatePattern" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd io gy z fp oh fr fs oi fu fw im bi translated">KotlinDesignPatterns/src/main/kotlin/state pattern at main…</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">Kotlin + Medium 文章中的设计模式。通过以下方式为 sleep less challenger/KotlinDesignPatterns 开发做出贡献…</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">github.com</p></div></div><div class="ol l"><div class="om l on oo op ol oq or oc"/></div></div></a></div><ol class=""><li id="e326" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh os kx ky kz bi translated">是我们的机器。为什么<strong class="jm io">语境</strong>？- &gt;在传统图中，这意味着类本身包含所有其他<strong class="jm io">状态</strong>。</li><li id="a45e" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh os kx ky kz bi translated"><code class="fe li lj lk ll b">State.kt</code>是我们的<code class="fe li lj lk ll b">interface</code>，它是所有现有&amp;未来<strong class="jm io">状态</strong>的<em class="ni">抽象</em>。</li><li id="2c1a" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh os kx ky kz bi translated"><code class="fe li lj lk ll b">NoQuarterState.kt</code> &amp;串其他<strong class="jm io">状态</strong>—<strong class="jm io">状态</strong>的实现</li><li id="1b81" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh os kx ky kz bi translated"><code class="fe li lj lk ll b">main.kt</code>是描述用户与系统交互的文件。</li></ol><p id="1b44" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，按照承诺，让我们一步一步地解决问题。</p><ol class=""><li id="e581" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh os kx ky kz bi translated">我们用一些 balls🪀.实例化了机器<strong class="jm io">和</strong>最初，如果您装载超过 0 个<strong class="jm io">球，它从<code class="fe li lj lk ll b">noQuarterState</code>开始。</strong></li><li id="5b1b" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh os kx ky kz bi translated"><code class="fe li lj lk ll b">insertQuarter()</code>装球:<code class="fe li lj lk ll b">NoQuarterState</code>合格</li><li id="58e1" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh os kx ky kz bi translated"><code class="fe li lj lk ll b">turnCrank()</code>加工球:在<code class="fe li lj lk ll b">HasQuarterState</code>中合格</li><li id="17b4" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh os kx ky kz bi translated"><code class="fe li lj lk ll b">ejectQuarter()</code>回球:在<code class="fe li lj lk ll b">HasQuarterState</code>中合格</li><li id="0a91" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh os kx ky kz bi translated"><strong class="jm io">机</strong>达到<strong class="jm io">售完</strong>状态后<code class="fe li lj lk ll b">dispense()</code>会自动触发(使用<code class="fe li lj lk ll b">turnCrank()</code>后)</li><li id="7852" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh os kx ky kz bi translated"><code class="fe li lj lk ll b">refill()</code>允许用户装载新球</li></ol><p id="f1a6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，当用户应用<strong class="jm io">动作</strong>时，有两种结果:</p><ul class=""><li id="7954" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated"><em class="ni">成功</em>:表示<strong class="jm io">机</strong>将对其进行加工</li><li id="dfdd" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated"><em class="ni">不成功</em>:表示<strong class="jm io">机</strong>会打印错误</li></ul><p id="fad7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">机</strong>如何处理这种变化？每个动作都与方法相关，该方法利用<strong class="jm io">当前状态</strong>变量。在<strong class="jm io">状态</strong> - &gt;下调用特定方法，我们输入所需的<em class="ni">类</em>。接下来，<em class="ni">成功</em> <code class="fe li lj lk ll b">||</code> <em class="ni">不成功</em>结果。</p><ul class=""><li id="17ff" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">每个<strong class="jm io">状态</strong>都有<strong class="jm io">当前机器</strong>的实例(查看<code class="fe li lj lk ll b">Context.kt</code>类)</li></ul><p id="b950" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Soo…，我们如何设法改变状态呢？🤷🏽‍♂️很容易使用<strong class="jm io"> getters </strong>(就当它是一个返回期望的<strong class="jm io">状态</strong>的方法):</p><ul class=""><li id="b070" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated"><code class="fe li lj lk ll b">getSoldState()</code>、<code class="fe li lj lk ll b">getHasQuarterState() </code>等。它们将返回应该是下一个状态。</li><li id="dbc1" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated"><code class="fe li lj lk ll b">setState()</code>在<code class="fe li lj lk ll b">getter</code>之后被杠杆化，以将<strong class="jm io">下一个状态</strong>置于<code class="fe li lj lk ll b">Context.kt</code>的<strong class="jm io">当前状态变量</strong>中。</li></ul><p id="e229" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">同样，如前所述，我们可以很容易地设置新的状态:看看<code class="fe li lj lk ll b">WinnerState.kt</code>中的逻辑</p><p id="1c2f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，我建议您逐步阅读代码，以便更好地理解解决方案。如果有东西没有点击— <em class="ni">在评论中删除一条消息</em>👇🏼</p><h2 id="4545" class="mr lu in bd lv ms mt dn lz mu mv dp md jv mw mx mh jz my mz ml kd na nb mp nc bi translated">额外部分</h2><p id="d945" class="pw-post-body-paragraph jk jl in jm b jn nd jp jq jr ne jt ju jv nf jx jy jz ng kb kc kd nh kf kg kh ig bi translated">正如我在开始时发誓的那样，我将明确区分<strong class="jm io">策略</strong> &amp; <strong class="jm io">状态</strong>模式。</p><ol class=""><li id="61b2" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh os kx ky kz bi translated"><strong class="jm io">状态</strong>用来替代<code class="fe li lj lk ll b">if/else</code>条件句。通过将行为封装在<strong class="jm io">状态对象</strong>中，我们可以从机器/上下文中改变当前状态。<br/> *客户端对内部情况知之甚少，因为机器/上下文已经配置</li><li id="8a38" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh os kx ky kz bi translated"><strong class="jm io">策略</strong>是子类化的另一种选择:<em class="ni">组合</em>允许你交换组合的对象进行灵活的设计，因此不会被继承所束缚。<br/> *客户端手动更改合成对象以指定所需的行为</li></ol><p id="fd64" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">附言（同 postscript）；警官（police sergeant）👋🏻:在模式的这个实现中，<strong class="jm io">状态</strong>决定下一步做什么。还有第二种实现:<strong class="jm io">机器</strong>决定切换到哪个状态。为什么？在我们的例子中，<strong class="jm io">状态</strong>是动态的，因此它们能够选择下一步做什么(但是，当然，这增加了模式中的依赖性)。当状态变得不那么动态时，一切都是反过来的 ➿.</p><h2 id="304c" class="mr lu in bd lv ms mt dn lz mu mv dp md jv mw mx mh jz my mz ml kd na nb mp nc bi translated">图画🗺</h2><figure class="nj nk nl nm gt nw gh gi paragraph-image"><div role="button" tabindex="0" class="ou ov di ow bf ox"><div class="gh gi ot"><img src="../Images/4b0ff1e2ee0c6a39a6f1e5090c51a8ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ueXkRAgQvVtHWl_w4AS8w.jpeg"/></div></div></figure><p id="aad0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">像以前一样，我潦草地让图案以肉体出现👁。分析图片&amp;研究上面提到的<strong class="jm io">上下文</strong> &amp; <strong class="jm io">状态</strong>之间的关系。</p><h2 id="6994" class="mr lu in bd lv ms mt dn lz mu mv dp md jv mw mx mh jz my mz ml kd na nb mp nc bi translated">结尾部分🙌</h2><blockquote class="oz pa pb"><p id="7340" class="jk jl ni jm b jn jo jp jq jr js jt ju pc jw jx jy pd ka kb kc pe ke kf kg kh ig bi translated"><strong class="jm io">状态模式</strong>的学术定义:允许对象根据内部状态的变化改变其行为。该对象看起来会改变它的类。</p></blockquote><p id="9c60" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">PS:相对于<strong class="jm io">机床</strong>来说<em class="ni">改变其等级</em>意味着什么？当<strong class="jm io">状态</strong>发生变化时，从外面看像是另一个物体介入，而实际上——<strong class="jm io">机</strong>通过<em class="ni">构图</em>杠杆作用于另一个<strong class="jm io">状态</strong>。</p><p id="0d80" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">哇，信息量真大👓。阅读和观看代码，汲取 pattern🧠</p><p id="e836" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以找到我:</p><ul class=""><li id="65f2" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">领英:<a class="ae la" href="http://www.linkedin.com/in/sleeplesschallenger" rel="noopener ugc nofollow" target="_blank">www.linkedin.com/in/sleeplesschallenger</a></li><li id="bb5b" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">GitHub:<a class="ae la" href="https://github.com/SleeplessChallenger" rel="noopener ugc nofollow" target="_blank">https://github.com/SleeplessChallenger</a></li><li id="2b91" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">leet code:【https://leetcode.com/SleeplessChallenger/】T2</li><li id="0f5f" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">电报:@无眠挑战者</li></ul></div></div>    
</body>
</html>