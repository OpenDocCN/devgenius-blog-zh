<html>
<head>
<title>Sort Array By Parity Problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">按奇偶问题排序数组</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/sort-array-by-parity-problem-584bfbf861a1?source=collection_archive---------8-----------------------#2020-07-30">https://blog.devgenius.io/sort-array-by-parity-problem-584bfbf861a1?source=collection_archive---------8-----------------------#2020-07-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0e06" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">解释了JavaScript和Ruby中的两种方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e01419530519cbfd648c6e0913c34285.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6-VFh2g_yisAQgMUFcLMtw.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自<a class="ae kv" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4014181" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae kv" href="https://pixabay.com/users/_Alicja_-5975425/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4014181" rel="noopener ugc nofollow" target="_blank"> _Alicja_ </a></figcaption></figure><p id="bdd6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi ls translated"><span class="l lt lu lv bm lw lx ly lz ma di">在</span>这篇文章中，我将讲述我是如何在<a class="ae kv" href="https://leetcode.com/problems/sort-array-by-parity/" rel="noopener ugc nofollow" target="_blank"> LeetCode </a>上解决“按奇偶校验排序数组”问题的。</p><p id="8cc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mb">给定一个非负整数的数组</em> <code class="fe mc md me mf b"><em class="mb">A</em></code> <em class="mb">，返回一个由</em> <code class="fe mc md me mf b"><em class="mb">A</em></code> <em class="mb">的所有偶数元素组成的数组，后跟</em> <code class="fe mc md me mf b"><em class="mb">A</em></code> <em class="mb">的所有奇数元素。</em></p><p id="f253" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以返回满足此条件的任何答案数组。</p><pre class="kg kh ki kj gt mg mf mh mi aw mj bi"><span id="815a" class="mk ml iq mf b gy mm mn l mo mp"><strong class="mf ir">Example:</strong></span><span id="a0a6" class="mk ml iq mf b gy mq mn l mo mp"><strong class="mf ir">Input: </strong>[3,1,2,4]<br/><strong class="mf ir">Output: </strong>[2,4,3,1]<br/>The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.</span></pre><p id="affa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个问题有多种公认的解决方案，我将与您分享其中的两种:</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h2 id="0bbb" class="mk ml iq bd my mz na dn nb nc nd dp ne lf nf ng nh lj ni nj nk ln nl nm nn no bi translated">我的第一次尝试</h2><p id="668e" class="pw-post-body-paragraph kw kx iq ky b kz np jr lb lc nq ju le lf nr lh li lj ns ll lm ln nt lp lq lr ij bi translated">以下是我得出第一个解决方案的步骤:</p><ol class=""><li id="8850" class="nu nv iq ky b kz la lc ld lf nw lj nx ln ny lr nz oa ob oc bi translated">定义一个函数，它接受一个名为<code class="fe mc md me mf b">A</code>的数组作为参数。</li><li id="fa26" class="nu nv iq ky b kz od lc oe lf of lj og ln oh lr nz oa ob oc bi translated">创建两个空数组；一个存储<code class="fe mc md me mf b">even</code>数字，另一个存储<code class="fe mc md me mf b">odd</code>数字。</li><li id="c094" class="nu nv iq ky b kz od lc oe lf of lj og ln oh lr nz oa ob oc bi translated">遍历给定的数组；<code class="fe mc md me mf b">A</code>。</li><li id="e34d" class="nu nv iq ky b kz od lc oe lf of lj og ln oh lr nz oa ob oc bi translated">通过执行模数运算(<code class="fe mc md me mf b">A[i] % 2 === 0</code>)检查<code class="fe mc md me mf b">A</code>的当前元素是偶数还是奇数。</li><li id="d1fb" class="nu nv iq ky b kz od lc oe lf of lj og ln oh lr nz oa ob oc bi translated">将<code class="fe mc md me mf b">A</code>的每个元素推到其对应的数组中:偶数元素放入偶数数组，奇数元素放入奇数数组。</li><li id="8566" class="nu nv iq ky b kz od lc oe lf of lj og ln oh lr nz oa ob oc bi translated">将奇数数组的元素追加到偶数元素的数组中，并返回该数组。</li></ol><p id="c750" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们通过查看JavaScript中的以下实现来更好地理解:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/58a96cca1bdf25cc092001998528d1a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*it_ZAuCdLzja7o39Zy325Q.png"/></div></div></figure><p id="bd0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">给定的数组；<code class="fe mc md me mf b">A</code>，被分割成两个独立的数组；<code class="fe mc md me mf b">even</code>，包含所有偶数，<code class="fe mc md me mf b">odd</code>，包含所有奇数。然后，这两个数组以偶数元素后跟奇数元素的方式组合。</p><h2 id="2540" class="mk ml iq bd my mz na dn nb nc nd dp ne lf nf ng nh lj ni nj nk ln nl nm nn no bi translated">时间和空间复杂性</h2><p id="99e5" class="pw-post-body-paragraph kw kx iq ky b kz np jr lb lc nq ju le lf nr lh li lj ns ll lm ln nt lp lq lr ij bi translated">给定数组的每个元素无论发生什么都需要检查，所以<strong class="ky ir">这个方案的</strong> <strong class="ky ir">时间复杂度</strong>为<strong class="ky ir"> O(n) </strong>，其中<code class="fe mc md me mf b">n</code>为<code class="fe mc md me mf b">A</code>的长度。引入新的数组来存储偶数和奇数会导致额外的空间，因此<strong class="ky ir">空间复杂度</strong>也是<strong class="ky ir"> O(n)，</strong>但它可以在O(1)空间复杂度内完成，而不需要使用额外的空间，这将在下一部分中看到。</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h2 id="b113" class="mk ml iq bd my mz na dn nb nc nd dp ne lf nf ng nh lj ni nj nk ln nl nm nn no bi translated">我的第二个方法</h2><p id="144b" class="pw-post-body-paragraph kw kx iq ky b kz np jr lb lc nq ju le lf nr lh li lj ns ll lm ln nt lp lq lr ij bi translated">与我的第一个解决方案相比，这个解决方案有点复杂，但是不需要额外的空间来存放任何东西。对于这种方法，我将采取以下步骤:</p><ol class=""><li id="3aa8" class="nu nv iq ky b kz la lc ld lf nw lj nx ln ny lr nz oa ob oc bi translated">创建一个索引<code class="fe mc md me mf b">j</code>，并将其设置为<code class="fe mc md me mf b">0</code>。</li><li id="f2ef" class="nu nv iq ky b kz od lc oe lf of lj og ln oh lr nz oa ob oc bi translated">遍历给定的数组；<code class="fe mc md me mf b">A</code>。</li><li id="f691" class="nu nv iq ky b kz od lc oe lf of lj og ln oh lr nz oa ob oc bi translated">如果遇到偶数元素，交换<code class="fe mc md me mf b">A</code>的元素和<code class="fe mc md me mf b">j</code>的索引元素。</li><li id="34c1" class="nu nv iq ky b kz od lc oe lf of lj og ln oh lr nz oa ob oc bi translated">将<code class="fe mc md me mf b">j</code>增加<code class="fe mc md me mf b">1</code>。</li><li id="667d" class="nu nv iq ky b kz od lc oe lf of lj og ln oh lr nz oa ob oc bi translated">继续直到<code class="fe mc md me mf b">A</code>结束，然后返回数组。</li></ol><p id="372b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是JavaScript代码的实现:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/e1f19a37314157a067b9c91e11c6d46e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*P73kH7PEEXU5z1LBlucc7g.png"/></div></figure><p id="6d52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我的第二种方法中使用了两个指针技术，其中两个指针都从数组的开头开始，以执行<strong class="ky ir">就地</strong>排序，这种解决方案不再需要O(n)空间复杂度。</p><p id="fe98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果数组的元素不是偶数，我们只增加一个指针；<code class="fe mc md me mf b">i</code>。如果是偶数，我们交换奇数和偶数元素，然后增加指针<code class="fe mc md me mf b">j</code>和<code class="fe mc md me mf b">i</code>。如果元素不在适当的位置，该过程交换元素，直到<code class="fe mc md me mf b">A</code>中的所有偶数元素出现在<code class="fe mc md me mf b">A</code>的所有奇数元素之前。</p><h2 id="c0ad" class="mk ml iq bd my mz na dn nb nc nd dp ne lf nf ng nh lj ni nj nk ln nl nm nn no bi translated">时间和空间复杂性</h2><p id="52db" class="pw-post-body-paragraph kw kx iq ky b kz np jr lb lc nq ju le lf nr lh li lj ns ll lm ln nt lp lq lr ij bi translated"><strong class="ky ir">空间复杂度</strong>通过编写就地解决方案，从O(n)进一步优化到<strong class="ky ir"> O(1) </strong>。<strong class="ky ir">该方案的时间复杂度</strong>仍与第一种方案一样为<strong class="ky ir"> O(n) </strong>，其中<code class="fe mc md me mf b">n</code>为<code class="fe mc md me mf b">A</code>的长度。</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h2 id="0174" class="mk ml iq bd my mz na dn nb nc nd dp ne lf nf ng nh lj ni nj nk ln nl nm nn no bi translated">奖金！</h2><p id="19b3" class="pw-post-body-paragraph kw kx iq ky b kz np jr lb lc nq ju le lf nr lh li lj ns ll lm ln nt lp lq lr ij bi translated">我通常喜欢用不同的语言解决同一个问题，下面是我在Ruby中解决这个问题的方法，类似于我的第一个解决方案:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/b93276cbd1eff7b5288c40880f49efa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_oa9zy6OzMSifhvl5RcmIA.png"/></div></div></figure></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h2 id="a154" class="mk ml iq bd my mz na dn nb nc nd dp ne lf nf ng nh lj ni nj nk ln nl nm nn no bi translated">结论</h2><p id="7f1f" class="pw-post-body-paragraph kw kx iq ky b kz np jr lb lc nq ju le lf nr lh li lj ns ll lm ln nt lp lq lr ij bi translated">声明新的数组并遍历给定的数组以将其偶数和奇数元素存储在它们各自的新数组中是解决这个问题的简单方法，但是第一种方法需要O(n)的额外空间复杂度。在第二部分中，通过维护两个指针来执行就地排序，以O(1)空间复杂度而不是O(n)来解决该问题。</p><p id="95b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望这篇文章能帮你想出解决这个常见算法的办法，谢谢阅读！</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h2 id="de7a" class="mk ml iq bd my mz na dn nb nc nd dp ne lf nf ng nh lj ni nj nk ln nl nm nn no bi translated">关于算法的更多信息:</h2><ul class=""><li id="23e8" class="nu nv iq ky b kz np lc nq lf ol lj om ln on lr oo oa ob oc bi translated"><a class="ae kv" href="https://medium.com/swlh/remove-adjacent-duplicates-problem-5b9ac4abe87f?source=friends_link&amp;sk=bdf036762719e49fc1bd7e8d5b736535" rel="noopener">删除相邻重复项问题</a></li><li id="20e7" class="nu nv iq ky b kz od lc oe lf of lj og ln oh lr oo oa ob oc bi translated"><a class="ae kv" href="https://medium.com/dev-genius/subtract-product-and-sum-problem-6d4d39a3c91e?source=friends_link&amp;sk=8f84a47a3a6255359f6fdf19f8bd4868" rel="noopener">减积求和问题</a></li><li id="c37e" class="nu nv iq ky b kz od lc oe lf of lj og ln oh lr oo oa ob oc bi translated"><a class="ae kv" href="https://medium.com/swlh/unique-number-of-occurrences-problem-cf25bd3fab4f?source=friends_link&amp;sk=739488a111b56958aeaea75847f48832" rel="noopener">独特的出现次数问题</a></li><li id="6ffc" class="nu nv iq ky b kz od lc oe lf of lj og ln oh lr oo oa ob oc bi translated"><a class="ae kv" href="https://medium.com/analytics-vidhya/javascript-check-valid-parentheses-with-a-stack-bc7b1bab26c2?source=friends_link&amp;sk=47981315af12a900d66f148ed482fc8a" rel="noopener"> JavaScript:用堆栈检查有效的括号</a></li><li id="723e" class="nu nv iq ky b kz od lc oe lf of lj og ln oh lr oo oa ob oc bi translated"><a class="ae kv" href="https://medium.com/analytics-vidhya/javascript-deep-comparison-of-objects-with-a-recursive-call-f67a8f37a343?source=friends_link&amp;sk=1dd4f4ef81e3cbea796827fd7d59187f" rel="noopener"> JavaScript:使用递归调用对对象进行深度比较</a></li></ul></div></div>    
</body>
</html>