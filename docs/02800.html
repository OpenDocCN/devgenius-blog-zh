<html>
<head>
<title>Node.js Best Practices — Environment and Clusters</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js 最佳实践—环境和集群</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/node-js-best-practices-environment-and-clusters-8b23b96bc783?source=collection_archive---------5-----------------------#2020-08-31">https://blog.devgenius.io/node-js-best-practices-environment-and-clusters-8b23b96bc783?source=collection_archive---------5-----------------------#2020-08-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ce3428c016f28be78b9c7355b744a239.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*482sM_86uSNOpy6D"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Kelly Sikkema </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="b503" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，JavaScript 应用程序也必须写得很好。</p><p id="9a1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们以后会遇到各种各样的问题。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看在编写节点应用程序时应该遵循的一些最佳实践。</p><h1 id="7125" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">DevOps 工具</h1><p id="adb7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">DevOps 工具将使配置我们的环境和服务器设置更加容易。</p><p id="c652" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们需要一个流程管理器来自动重启我们的 Express 应用程序，以防它崩溃。</p><p id="55ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要一个反向代理和负载平衡器来将我们的应用程序公开给互联网，缓存请求，并在多个工作进程之间平衡负载。</p><p id="5412" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这让我们在应用程序中保持高性能。</p><h1 id="946e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用 dotenv 管理 Node.js 中的环境变量</h1><p id="634d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">dotenv 库对于让我们从一个<code class="fe me mf mg mh b">.env</code>文件中读取变量非常有用</p><p id="013e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c8fe" class="mq lc iq mh b gy mr ms l mt mu">NODE_ENV=production<br/>DEBUG=false</span></pre><p id="1738" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的<code class="fe me mf mg mh b">.env</code>文件中。</p><p id="4474" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以用:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="de0a" class="mq lc iq mh b gy mr ms l mt mu">require('dotenv').config()<br/>​<br/>const express = require('express')<br/>const app = express()</span></pre><p id="f667" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">默认情况下，它会从名为<code class="fe me mf mg mh b">.env</code>的文件中读取环境变量。</p><p id="681f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，它也可以从多个环境变量文件中读取。</p><h1 id="87e5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">确保应用程序通过进程管理器自动重启</h1><p id="f072" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们有一个 Express 应用程序，当遇到未处理的错误时，它会崩溃。</p><p id="6787" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，重要的是我们要自动重启我们的应用程序，这样它就不会关闭。</p><p id="187c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过在<code class="fe me mf mg mh b">/lib/systemd/system</code>中创建一个名为<code class="fe me mf mg mh b">app.service</code>的新文件来使用 Systemd:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a425" class="mq lc iq mh b gy mr ms l mt mu">[Unit]<br/>Description=Node.js as a system service.<br/>Documentation=https://example.com<br/>After=network.target<br/>[Service]<br/>Type=simple<br/>User=ubuntu<br/>ExecStart=/usr/bin/node /my-app/server.js<br/>Restart=on-failure<br/>[Install]<br/>WantedBy=multi-user.target</span></pre><p id="50ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Service</code>部分有<code class="fe me mf mg mh b">ExecStart</code>行，它在启动时运行我们的应用程序。</p><p id="01bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它还有一条<code class="fe me mf mg mh b">Restart</code>线，可以在出现故障时重启。</p><p id="8ca7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以重新加载守护程序，用以下命令启动脚本:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5ade" class="mq lc iq mh b gy mr ms l mt mu">systemctl daemon-reload<br/>systemctl start fooapp<br/>systemctl enable fooapp<br/>systemctl status fooapp</span></pre><h1 id="0db6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">PM2</h1><p id="eae7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">PM2 是一个流程经理，让我们管理快速应用程序流程。</p><p id="e905" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过运行以下命令来安装它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c1d6" class="mq lc iq mh b gy mr ms l mt mu">npm i -g pm2</span></pre><p id="2590" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过运行以下命令来运行我们的应用程序:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="696c" class="mq lc iq mh b gy mr ms l mt mu">pm2 start server.js -i max</span></pre><p id="986c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">-i max</code>是运行我们应用的最大线程数。</p><p id="7c07" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，它将产生足够的工人来使用所有的 CPU 核心。</p><h1 id="b22c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">负载平衡和反向代理</h1><p id="2374" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">节点集群模块允许我们生成服务于我们的应用程序的工作进程。</p><p id="1d4d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过编写以下内容来创建集群:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3314" class="mq lc iq mh b gy mr ms l mt mu">const cluster = require('cluster')<br/>const numCPUs = require('os').cpus().length<br/>const app = require('./src/app')<br/>const port = process.env.PORT || 8888<br/>​<br/>const masterProcess = () =&gt; Array.from(Array(numCPUs)).map(cluster.fork)<br/>const childProcess = () =&gt; app.listen(port)<br/>​<br/>if (cluster.isMaster) {<br/>  masterProcess()<br/>} else {<br/>  childProcess()<br/>}<br/>​<br/>cluster.on('exit', () =&gt; cluster.fork())</span></pre><p id="8efd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">主进程创建集群，子进程在给定的端口上按 listen 来监听请求。</p><p id="2279" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">masterProcess</code>计算有多少 CPU 内核，并调用<code class="fe me mf mg mh b">cluser.fork</code>创建与可用内核数量相等的子进程。</p><p id="9cdd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果因<code class="fe me mf mg mh b">cluster.fork</code>而失败，<code class="fe me mf mg mh b">exit</code>事件监听器将重启进程。</p><p id="b231" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在 Systemd 文件中，我们替换:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="74d6" class="mq lc iq mh b gy mr ms l mt mu">ExecStart=/usr/bin/node /my-app/server.js</span></pre><p id="48f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="025e" class="mq lc iq mh b gy mr ms l mt mu">ExecStart=/usr/bin/node /my-app/cluster.js</span></pre><p id="a9a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以使用以下命令重新启动 Systemd:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f5f9" class="mq lc iq mh b gy mr ms l mt mu">systemctl daemon-reload<br/>systemctl restart fooapp</span></pre><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/d9a8eccc3b8c3825f43a7f575fc80032.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PZHN2Yw1L9up9GM-"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@lazycreekimages?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">迈克尔·泽兹奇</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><h1 id="c59b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="27f2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用 dotenv 读取环境变量，用<code class="fe me mf mg mh b">cluster</code>模块添加集群。</p></div></div>    
</body>
</html>