<html>
<head>
<title>Getting started with Apache Airflow — The Beginners Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Apache Airflow 入门指南</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/getting-started-with-apache-airflow-the-beginners-guide-62c194f6d00f?source=collection_archive---------0-----------------------#2022-03-01">https://blog.devgenius.io/getting-started-with-apache-airflow-the-beginners-guide-62c194f6d00f?source=collection_archive---------0-----------------------#2022-03-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="1682" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">计划、自动化、监控</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/939c529e1594cdd3ea7814c934366d92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FJsMPN5kPMI7JuqhsaP7rA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Apache air flow——编排工作流程的绝佳工具！</figcaption></figure></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="3d07" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">概观</h1><p id="e2f1" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">当今世界，对自动化的需求空前高涨。它使我们能够有效地使用分配的资源，提高质量，减少人为错误。然而，许多人仍然无法理解如何自动化一些任务，最终只能一遍又一遍地手动操作。</p><p id="ffbf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">许多技术驱动的团队有一个相对通用的管道——收集数据，预处理数据，上传到某个地方，然后生成报告。只有当有一种工具能够按照定义的顺序进行调度、触发和处理时；完全靠自己，没有任何人为干预。Apache Airflow 是在自动化您的工作流程中非常有用的工具之一！</p><p id="726f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文中，我们将讨论什么是 Apache Airflow，浏览它的构造块，并且我们将使用不同的 Airflow 操作符用 Python 编写一个示例工作流。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="c649" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">什么是气流——我为什么要使用它？</h1><p id="58bc" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">Apache Airflow 是编排的最佳工具之一。它在三个方面做得非常好——调度、自动化和监控。正如 Apache Airflow 主页上所定义的，<em class="mi">“[它]是一个由社区创建的平台，用于以编程方式创作、调度和监控工作流”。</em></p><p id="dc2f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以下是使用气流的一些好处:</p><ul class=""><li id="afab" class="mj mk in jm b jn jo jr js jv ml jz mm kd mn kh mo mp mq mr bi translated">开放源码</li><li id="e761" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated">用 Python 写的</li><li id="0960" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated">可攀登的</li><li id="2345" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated">行程安排</li><li id="6d44" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated">用户界面</li><li id="e548" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated">通知/警报系统</li><li id="2b9c" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated">插件、挂钩、传感器</li><li id="82bc" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated">能够与其他服务(即云服务)集成</li><li id="7489" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated">可供外部使用的 RestAPI 端点</li><li id="5f34" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated">气流应用程序可以在 Docker / K8s 容器上运行</li></ul></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="1974" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">什么是 DAG？</h1><p id="041d" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">在计算机科学和数学中，DAG(有向无环图)是一种有向(单向)且没有连接其他顶点的环的图。</p><p id="469a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在气流环境中，DAG 是所有小任务(操作符)的集合，这些小任务连接在一起执行更大的任务，其中不存在循环，并且从一个任务到下一个任务的方向总是从左到右。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/78294db3009756592e2f7a5e835170ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8z2cZlZtKNtD_uAT4sS2Yg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">示例 DAG(有向无环图)</figcaption></figure><p id="e4bd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于 DAG 的性质是单向的，我们还可以得出结论，一个任务的开始仅发生在前一个任务已经完成的情况下。例如，在上面的例子中，'<em class="mi">分支</em>'任务仅在'<em class="mi"> run_this_first' </em>完成后开始。</p><p id="ba27" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以下是如何在气流中定义 DAG 的示例代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="72ee" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">经营者</h1><p id="d964" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">在 DAG 中，所有东西都作为操作符工作。您可以使用以下注释来定义运算符:</p><p id="1eac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">task_a = SomeOperator( <em class="mi">参数</em>)</p><p id="6ca9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们使用 bash 操作符(执行 Bash 脚本)作为更具体的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/d34bd66937c0c980da35577515fb68be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*76EPGgjtWYWUsBFuG8z7IA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Bash 运算符 DAG 示例</figcaption></figure><p id="ce5f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是一些其他类型的运算符的列表。</p><ul class=""><li id="396d" class="mj mk in jm b jn jo jr js jv ml jz mm kd mn kh mo mp mq mr bi translated"><code class="fe nb nc nd ne b">DummyOperator</code> —填充任务，不执行任何操作</li><li id="9a5d" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated"><code class="fe nb nc nd ne b">PythonOperator </code> —用于调用 DAG 中任何已定义的 python 函数</li><li id="e7cc" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated"><code class="fe nb nc nd ne b">EmailOperator </code> —发送电子邮件</li><li id="f8cd" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated"><code class="fe nb nc nd ne b">SimpleHttpOperator </code> —发送 HTTP 请求</li><li id="2e65" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated"><code class="fe nb nc nd ne b">MySqlOperator</code>、<code class="fe nb nc nd ne b">SqliteOperator</code>、<code class="fe nb nc nd ne b">PostgresOperator</code>、<code class="fe nb nc nd ne b">OracleOperator</code>、<code class="fe nb nc nd ne b">JdbcOperator </code> —执行 SQL 查询。</li><li id="d35c" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated"><code class="fe nb nc nd ne b">BaseSensorOperator</code></li><li id="74f6" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated"><code class="fe nb nc nd ne b">BranchingOperator</code></li></ul><p id="8961" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在一个给定的 DAG 中，假设我们正在运行两个不同的任务，即<code class="fe nb nc nd ne b">task_1 </code>和<code class="fe nb nc nd ne b">task_2</code>——按此顺序。回想一下定义，dag 是定向的，因此我们需要确保在运行<code class="fe nb nc nd ne b">task_2.</code>之前执行并完成<code class="fe nb nc nd ne b">task_1 </code>——因此存在依赖关系。</p><p id="3869" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">设置此类依赖关系有三种方式:</strong></p><ul class=""><li id="bda6" class="mj mk in jm b jn jo jr js jv ml jz mm kd mn kh mo mp mq mr bi translated"><code class="fe nb nc nd ne b">task_1 &gt;&gt; task_2</code></li><li id="7cf2" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated"><code class="fe nb nc nd ne b">task_1.downstream(task_2)</code></li><li id="e36b" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated"><code class="fe nb nc nd ne b">task_2.upstream(task_1)</code></li></ul><p id="c2c5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以上三个注解都是等价的——<code class="fe nb nc nd ne b">task_2</code>依赖<code class="fe nb nc nd ne b">task_1</code>。必须为创建的每个单个操作符<em class="mi">定义这组依赖关系。换句话说，每一个顶点都必须与另一个顶点相连才能完成这个图。</em></p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="693d" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">计划 DAG</h1><p id="0bc3" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">如果您希望以某个固定的频率运行您的作业，您可以通过 cron job annotation 在 Airflow 中调度您的 Dag。例如，您可以将它安排在每分钟、每天凌晨 04:30 或每年 5 月 31 日。</p><p id="8796" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">cron 作业的注释是:</p><p id="dfcf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mi"> &lt;分钟&gt; &lt;小时&gt; &lt;月日&gt; &lt;月日&gt; &lt;周日&gt; </em></p><p id="85e1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/cf08747bd12fe1e0e783ee81df3666c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V4Bi-tkiDPkK6bY0wle78w.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">cron 作业示例。</figcaption></figure><p id="a328" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要计划 DAG，您可以在 DAG 定义中定义 cronjob。</p><h1 id="bef8" class="lf lg in bd lh li ng lk ll lm nh lo lp lq ni ls lt lu nj lw lx ly nk ma mb mc bi translated">通过 XCom 进行任务间的通信</h1><p id="c6fc" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">XCom 是代表“交叉通信”的缩写，它允许在任务之间交换消息或小块数据。您可以将 XCom 视为包含以下字段的字典对象:</p><ul class=""><li id="2eb0" class="mj mk in jm b jn jo jr js jv ml jz mm kd mn kh mo mp mq mr bi translated"><strong class="jm io">键</strong> —识别 XCom</li><li id="e314" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated"><strong class="jm io">值</strong> —您的 XCom 的值，与定义的密钥相关联</li><li id="056b" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated"><strong class="jm io">时间戳— </strong>创建 XCom 的日期</li><li id="b0c3" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated"><strong class="jm io">执行日期— </strong>初始化 XCom 的 DagRun 的执行日期</li><li id="c8d8" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated"><strong class="jm io">任务 id </strong> —创建 XCom 的任务</li><li id="a8b6" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated"><strong class="jm io"> dag id </strong> —创建 XCom 的 dag</li></ul><p id="a1ec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">xcom 对象提供了两个函数——xcom _ push()和 xcom_pull()。让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/fc39bd055fe1356e4af75dfbb84b83d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EiQDjEa7cB1DainK5j7hyQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">两个 Python 操作符之间带有 XCom 的 DAG 示例</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/a4deae1259a0c1c7896586486bf7837a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rASwi3C1qBnWvsuRTe_UZw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">可以查看<em class="nn">管理-&gt;xcom</em>下所有推送的 xcom</figcaption></figure></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="9f73" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">完成时通知</h1><p id="1c30" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">一个自然的问题是，我的管道完成后会发生什么？例如，如果它计划在每天晚上 22 点运行，我是否需要每天晚上检查我的 DAG 是否成功完成？</p><p id="1f06" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">幸运的是，Apache Airflow 考虑到了这种情况，并且有很好的附加特性来解决这个问题。例如，一个人可以通过电子邮件操作员发送电子邮件警告，或者向适当的人/团队发送懈怠通知。这些通知可以用于各种情况，例如，仅在 DAG 失败时发送此类通知，或者在 DAG 成功完成时发送通知。另一个常见的情况是，如果您的任务比预期时间长，该怎么办？这难道不令人担忧吗？在那种情况下，也可以建立这种基于通知的系统。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="2141" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">例子</h1><p id="f469" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">让我们做一个实际操作的例子，它涉及到使用多个操作符、xcom 以及在 DAG 执行成功时发送电子邮件。</p><p id="1c38" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">场景:我们需要一个 DAG，计划在每个月的第一天清理 HDFS 的空间。它应该有一个功能，能够在运行时读取 HDFS 的基本路径，你要清理的目录名，最后是以天为单位的时间段(即删除超过 14 天的文件)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/f7e92a18a50657bfb483f78766c93b42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vfrINm1-MRY3UN41L6Z2gQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">清理 DAG</figcaption></figure></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="eaae" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">奖金</h1><ul class=""><li id="6e21" class="mj mk in jm b jn md jr me jv np jz nq kd nr kh mo mp mq mr bi translated">重新运行任务</li></ul><p id="1bce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在您希望重新运行某项任务而不需要重新运行整个 DAG 的情况下，您可以执行以下操作:</p><ol class=""><li id="35b6" class="mj mk in jm b jn jo jr js jv ml jz mm kd mn kh ns mp mq mr bi translated">单击要重新运行的任务</li><li id="d309" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh ns mp mq mr bi translated">将出现一个弹出屏幕，如下所示</li><li id="05fb" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh ns mp mq mr bi translated">点击<em class="mi">清除</em></li><li id="67f1" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh ns mp mq mr bi translated">点击“确定”</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/5e380c743386121fdd0c3fce169aa530.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R_F1uAujeyZ1wfEWg3laVg.png"/></div></div></figure><ul class=""><li id="eb6a" class="mj mk in jm b jn jo jr js jv ml jz mm kd mn kh mo mp mq mr bi translated">在运行时传递参数</li></ul><p id="f40d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">回到<em class="mi">HDFS _ 清理</em> DAG 的例子，您可以在运行时传入参数，并且可以通过 kwargs 对象→ <em class="mi"> kwargs['params']进行检索。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/b1b1d71e6f0a2ba816887e104c528fe0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bMhwm7_UHjyD_YWgbJLF7g.png"/></div></div></figure><ul class=""><li id="2973" class="mj mk in jm b jn jo jr js jv ml jz mm kd mn kh mo mp mq mr bi translated">基于特定场景运行任务</li></ul><p id="5c80" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">默认情况下，如果上游任务失败，将跳过所有后续任务(即不执行)。但是，有时您可能希望根据前面任何/所有任务的结果来运行某个任务。</p><p id="25d5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为此，您可以在定义任务时初始化一个名为<em class="mi"> trigger_rule </em>的参数。例如:</p><p id="28c1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">task = branch python operator(task _ id = ' task '，python_callable='some_func '，<strong class="jm io">trigger _ rule</strong>= "&lt;trigger _ rule&gt;"，dag=dag)</p><p id="ba46" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以下是气流中的触发规则:</p><ul class=""><li id="30e5" class="mj mk in jm b jn jo jr js jv ml jz mm kd mn kh mo mp mq mr bi translated">all_success —当所有上游任务(父任务)都成功时触发任务(默认情况下)</li><li id="4530" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated">all_failed —如果任务的所有父任务都失败，则触发该任务</li><li id="c926" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated">all_done —一旦所有上游任务执行完毕，无论其状态如何，都会触发任务</li><li id="208e" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated">one_failed —如果至少一个上游失败，则触发任务</li><li id="7a12" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated">one _ success—如果至少一个上游成功，则触发任务</li><li id="2e83" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated">none _ failed 如果所有上游任务都已成功或被跳过，则触发任务</li><li id="dd39" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated">none _ failed _ min _ one _ success 如果所有上游任务都没有失败，并且至少有一个任务成功，则触发任务</li><li id="6002" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated">none_skipped —如果没有跳过上游任务，则触发任务</li></ul></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="050c" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">资源</h1><ul class=""><li id="82db" class="mj mk in jm b jn md jr me jv np jz nq kd nr kh mo mp mq mr bi translated">Airflow 有优秀的文档:<a class="ae nv" href="https://airflow.apache.org/docs/apache-airflow/stable/index.html" rel="noopener ugc nofollow" target="_blank">https://air flow . Apache . org/docs/Apache-air flow/stable/index . html</a></li><li id="d3dc" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated">气流来源代码—【https://github.com/apache/airflow T2】</li></ul></div></div>    
</body>
</html>