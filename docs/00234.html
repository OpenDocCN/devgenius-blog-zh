<html>
<head>
<title>My experience with nullable reference types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我使用可空引用类型的经验</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/my-experience-with-nullable-reference-types-c83f117e205d?source=collection_archive---------1-----------------------#2020-05-26">https://blog.devgenius.io/my-experience-with-nullable-reference-types-c83f117e205d?source=collection_archive---------1-----------------------#2020-05-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/bc9d5aa43ce720da9ed33e79c5d796b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RbWt9WdrcOOKT1uE"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">马库斯·斯皮斯克在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="ff41" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">今天我想分享一下我对c# 8版本的一个新特性的想法。著名的“可空引用类型”我在测试中使用它们，现在，我已经有一年的经验了。嗯，我不得不说它们很棒，它们似乎是这个版本的主要创新。</p><p id="5b98" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您不知道参考类型是什么，请查看下面的<a class="ae jz" href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2018/february/essential-net-csharp-8-0-and-nullable-reference-types" rel="noopener ugc nofollow" target="_blank">文章</a>。</p><p id="98d6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你想知道为什么我认为这是一个非常好的创新吗？这是因为“空引用”被称为十亿美元的错误:</p><p id="2006" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">东尼·霍尔在2009年QCon伦敦会议上做出如下道歉:</p><p id="a31c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我称之为我的十亿美元错误。这是1965年零引用的发明。那时，我正在设计第一个面向对象语言(ALGOL W)的引用综合类型系统。我的目标是确保所有引用的使用都是绝对安全的，由编译器自动执行检查。但是我无法抗拒放入空引用的诱惑，仅仅是因为它太容易实现了。这导致了数不清的错误、漏洞和系统崩溃，在过去的四十年里，这可能造成了数十亿美元的痛苦和损失。</p><p id="c874" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，有了处理空引用异常的新工具，为了我们的后代，是时候摆脱这个噩梦了。我有点夸张了:)</p><h2 id="1d5f" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated"><strong class="ak">我使用可空引用类型的经验</strong></h2><p id="6519" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated"><strong class="kc io">非真实类型！</strong></p><p id="66ee" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我觉得什么是最重要的？你必须记住，它不是一个真正的类型，就像“int？”或者“布尔？”。与其说是经典，不如说是信息标签。网络类型。这位语言作者的决定可能会导致，而且很可能会导致，一个危险的误解和隐藏的错误。</p><p id="d687" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为什么？即使你声明一个属性为不可空，比如:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="c76d" class="kz la in mc b gy mg mh l mi mj">public string Name{get;set;}</span></pre><p id="8d6c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">。NET运行库可以在此字段中设置null。这通常发生在您的应用程序“跨越边界”的时候我的意思是，当你的程序需要离开. NET的安全环境时。例如，它调用一个数据库，从REST API之类的外部世界接收数据，使用一个<em class="ky">旧的或坏的第三方库</em>。</p><p id="58e6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用不可空的值类型，可以很好地防范空值。然而，引用类型的情况并不令人满意。如果你有一个不可空的字符串，并且你从API收到一个空值，突然之间，空值会像病毒一样在你的系统中流动。通常，会发生一些可怕的事情。在这种情况下，C#运行时<em class="ky">不会像处理传统的不可空类型(int、bool等)那样帮助你。)</em></p><p id="985b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我相信这个问题会在库级别得到解决，但是现在我们必须更加小心，因为不能保证非空引用属性有时不会得到空值。</p><p id="1675" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面的代码描述了这个问题:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="4b2b" class="kz la in mc b gy mg mh l mi mj">class Entity<br/>{<br/>   public string Name { get; set; }<br/>}</span><span id="4229" class="kz la in mc b gy mk mh l mi mj">var obj = JsonConvert.DeserializeObject&lt;Entity&gt;(“{\”Name\”:null}”);<br/>//after the deserialization you get obj.Name == null.</span></pre><p id="d3ef" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如我提到的，不幸的是，这种行为与其他真正的可空类型不一致，比如“int？或者“布尔？”。实际上，这类似于使用打字稿。你的运行时不能确保你的代码停留在<em class="ky">安全的一边。</em></p><p id="4e6b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> POCO类</strong></p><p id="ad2a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在引入可空引用类型之后，我就如何更改我的POCO类进行了实验。通过反复试验，我的班级向这种形式靠拢:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="438b" class="kz la in mc b gy mg mh l mi mj">class Company<br/>{<br/>   public string Name{get;set;} =String.Empty;<br/>   public string AdditionalInformation {get;set;}=String.Empty;<br/>   public ProjectManager? OptionalProjectManager;<br/>   public Address[] Addresses {get;set;}= new Address[0];<br/>}</span></pre><p id="46c6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">解释:</strong></p><p id="056c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">名称:</em></p><p id="7826" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">名称是必需的，所以它总是被赋值为。甚至“字符串。空”是比null更合适、更好的值。</p><p id="6e22" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">附加信息</em></p><p id="237c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">尽管有可能将该属性标记为可空类型，但我确实为它们提供了一个值。它为我节省了几行代码和编写“if guard”的问题，并在将来处理一个潜在的空引用异常。</p><p id="bb6b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">可选项目经理:</em></p><p id="8910" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它是可选的。我没有一些公司的任何值，也没有合适的默认值。因此，我将它标记为可空类型，并保持原样。</p><p id="8d35" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">地址</em></p><p id="0e0c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">空数组几乎比空数组更好。为什么？这是另一篇博文的主题。长话短说——我相信提供一个“缺省”值可能会减少“如果”的数量，这不可避免地会增加<em class="ky">圈复杂度</em>并导致其他不好的事情。然而，正如我所说的，这个主题是巨大的，我将写另一篇纯粹与“空值”相关的博文。</p><p id="9348" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">旁注—为什么我不使用构造函数</em></p><p id="94de" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可能已经注意到，我没有为我的POCO类使用构造函数。是的，这不是一个错误；我很少使用构造函数。</p><p id="cb57" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">事实上，自从我学会了这种语言结构，我就对它又爱又恨。我真的试着爱上建造者，我知道他们有很多优点，但是维护总是很费力。我花了很多时间和试验来寻找如何将构造函数应用于两个以上字段的类，但我总是放弃。</p><p id="4f04" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我开始使用ReSharper的时候，我终于认为我明白了。有了构造函数的半自动生成体，我就可以在任何地方使用它了。然而，任何修改仍然是一种痛苦。</p><p id="9340" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">事实上，我曾经对自己使用构造函数的心态感到有点惭愧，它代表了OOP范例的一个支柱。尽管如此，我已经习惯了。:)</p><p id="36fe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在空引用类型出现后，我尝试使用构造函数。然而，像往常一样，我没能再次喜欢上它。</p><p id="ccfb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">相反，对象初始化(伴随我们很多年)是一个超级有用的技术，我很喜欢它。到目前为止，我最不乐意使用构造函数的地方是依赖注入。</p><h2 id="b547" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated"><strong class="ak">失踪的霹雳符</strong></h2><p id="6fc6" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">我非常想念声明字段中的bang操作符，比如在Typescript中。</p><p id="0e22" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">看看这个例子:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="b6d5" class="kz la in mc b gy mg mh l mi mj">class TypescriptClass<br/>{<br/>    requiredField!: string;<br/>}</span></pre><p id="6d7d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在不允许在C#中包含该类，例如:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="a43e" class="kz la in mc b gy mg mh l mi mj">class CSharpClass<br/>{<br/>   string! requiredField;<br/>}</span></pre><p id="8ba1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">相反，您应该在“调用站点”使用bang运算符，如下所示:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="082c" class="kz la in mc b gy mg mh l mi mj">var instance.requiredField!.ToLower();</span></pre><p id="1340" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我在TS中使用bang操作符有过很好的体验，在C#中有点怀念。也许，在未来。</p><h2 id="7960" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated"><strong class="ak">警告与错误</strong></h2><p id="cb29" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">对于非引用类型，您可以选择编译器指示违反规则的方式:警告或错误。到目前为止，我都是以此为戒。我没有任何确凿的数据，甚至没有强烈的观点。然而，这比一个错误更适合我。</p><p id="9c8b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此外，使用pragma来禁用空检查并不可耻。在我的一个项目中，我有一个与支付网关相关的代码。它只是由几个类和一个序列化机制组成。由于这是一个旧代码，我不得不花一整天的时间来删除所有的警告。相反，我使用pragma来禁用检查，每个人都很高兴。</p><h2 id="5175" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated"><strong class="ak">单元测试</strong></h2><p id="eae7" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">我试图确定空引用类型是如何改变我的单元测试的。我相信它一定会对我的单元测试产生影响。然而，我什么也没发现。也许你有不一样的体验。但是现在，我看不出有什么不同。</p><h2 id="9a23" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated"><strong class="ak">暗示自己</strong></h2><p id="3590" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">将引用类型标记为可空对编译器和我都有帮助。检查数据库中的某一列是否为空对我很有帮助。我知道这只是一个暗示，也许并不完全可靠。然而，它仍然是关于我的程序的少量信息，我能够在没有任何<em class="ky">额外成本</em>的情况下获得这些信息。</p><h2 id="c4f6" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated"><strong class="ak">结论</strong></h2><p id="c51c" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">我发现这个新功能总体上很有用，尽管它的具体实现方式可能会引起争议<em class="ky"/>。可空引用类型非常有用。对于我来说，毫不奇怪，它减少了代码中的空引用异常的数量。毫无疑问，它提高了我的代码质量。</p><p id="5f97" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">将来，我准备像现在一样广泛地使用它，如果你还没有尝试过，我建议你也尝试一下。</p></div></div>    
</body>
</html>