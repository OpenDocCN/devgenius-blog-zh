<html>
<head>
<title>Caching Instagram API Response in a Dockerised Go Server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Dockerised Go 服务器中缓存 Instagram API 响应</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/caching-instagram-api-response-in-a-go-server-b67beaeaa1fd?source=collection_archive---------8-----------------------#2022-11-24">https://blog.devgenius.io/caching-instagram-api-response-in-a-go-server-b67beaeaa1fd?source=collection_archive---------8-----------------------#2022-11-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/7cc6f9d78e61eba9a0b4ad4b08387c4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1XbP114CDNbO6aBfGhb9yw.png"/></div></div></figure></div><div class="ab cl jv jw hr jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ig ih ii ij ik"><p id="5b43" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated"><strong class="ke io">目录:</strong></p><p id="7123" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated"><a class="ae la" href="#13e6" rel="noopener ugc nofollow">缓存结果</a>T6】∘<a class="ae la" href="#9aaa" rel="noopener ugc nofollow">cache . go</a>T9】∘<a class="ae la" href="#7807" rel="noopener ugc nofollow">types . go</a>T12】∘<a class="ae la" href="#6fb3" rel="noopener ugc nofollow">fetch . go</a>t15】∘<a class="ae la" href="#2825" rel="noopener ugc nofollow">service . go</a>t18】∘<a class="ae la" href="#db05" rel="noopener ugc nofollow">。env</a><br/>∘<a class="ae la" href="#1bb2" rel="noopener ugc nofollow">main . go</a><br/><a class="ae la" href="#e988" rel="noopener ugc nofollow">dockere 服务器</a><br/>∘<a class="ae la" href="#23ad" rel="noopener ugc nofollow">docker file</a><br/>∘<a class="ae la" href="#0a2a" rel="noopener ugc nofollow">docker-compose . yml</a><br/>t34】在 Firebase 上发布服务器</p></div><div class="ab cl jv jw hr jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ig ih ii ij ik"><p id="5c8e" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我一直面临着一个有趣的挑战:在 React 应用程序中以 3x3 的网格显示 Instagram 帖子。我在最后几篇文章中致力于这一努力。</p><p id="df80" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">在本系列的第一篇文章中，我讨论了在 React 应用程序中显示 Instagram 帖子的方法。</p><p id="5a97" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">在<a class="ae la" rel="noopener ugc nofollow" target="_blank" href="/improving-instagram-posts-in-react-cea3eec4dbaa">的第二篇文章</a>中，我概述了一种使用 Google Cloud 函数改进我的 Instagram Feed React 组件的方法，以便通过隐藏<code class="fe lb lc ld le b">access_token</code>和<code class="fe lb lc ld le b">user_id</code>来提高安全性。</p><p id="02b4" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我遇到的问题是，云函数会为每个请求获取相同的数据，我很快就会达到 API 速率限制(Instagram 基本显示 API 每小时约 200 个请求)。</p><p id="3883" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">基于前面的文章，我的<strong class="ke io">目标</strong>是:</p><ul class=""><li id="1379" class="lf lg in ke b kf kg kj kk kn lh kr li kv lj kz lk ll lm ln bi translated">在 Go 服务器中缓存 Instagram API 响应，以避免超过 Instagram API 速率限制</li><li id="d91b" class="lf lg in ke b kf lo kj lp kn lq kr lr kv ls kz lk ll lm ln bi translated">停靠服务器</li><li id="0838" class="lf lg in ke b kf lo kj lp kn lq kr lr kv ls kz lk ll lm ln bi translated">在 Firebase 上发布服务器</li></ul><p id="4bed" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">GitHub 上有<a class="ae la" href="https://github.com/fs1g17/http-server" rel="noopener ugc nofollow" target="_blank">后端</a>和<a class="ae la" href="https://github.com/fs1g17/instafeed" rel="noopener ugc nofollow" target="_blank">前端</a>代码。</p><h1 id="13e6" class="lt lu in bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">缓存结果</h1><p id="bd29" class="pw-post-body-paragraph kc kd in ke b kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz ig bi translated">在这一部分，我将回顾一下我在好朋友 Victor 的帮助下编写的 go 服务器。完整的代码可以在 GitHub 上公开获得。</p><p id="378d" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">后端代码保存在这个结构中:</p><pre class="mw mx my mz gt na le nb bn nc nd bi"><span id="f9f5" class="ne lu in le b be nf ng l nh ni">http-server<br/>├── cache<br/>│   └── cache.go<br/>├── instagram<br/>│   ├── fetch.go<br/>│   └── types.go<br/>├── service<br/>│   └── service.go<br/>├── .env<br/>└── main.go</span></pre><p id="906b" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">这种结构提供了关注点的分离:<code class="fe lb lc ld le b">cache.go</code>仅用于提供缓存功能(以避免超过 Instagram API 的限制)，<code class="fe lb lc ld le b">fetch.go</code>用于执行获取，<code class="fe lb lc ld le b">service.go</code>启动<a class="ae la" href="https://echo.labstack.com/" rel="noopener ugc nofollow" target="_blank"> echo </a>服务器。</p><h2 id="9aaa" class="nj lu in bd lv nk nl dn lz nm nn dp md kn no np mh kr nq nr ml kv ns nt mp nu bi translated">cache.go</h2><pre class="mw mx my mz gt na le nb bn nc nd bi"><span id="69fa" class="ne lu in le b be nf ng l nv ni">package cache<br/><br/>import (<br/> "time"<br/>)<br/><br/>// Fetcher can fetch items that will be held by Cache.<br/>type Fetcher[T any] interface {<br/> Fetch() (T, error)<br/>}<br/><br/>// Cache contains cached items and keeps track of time.<br/>type Cache[T any] struct {<br/> Fetcher[T]<br/> cache            T<br/> lastRefreshTime  time.Time<br/> expirationPeriod time.Duration<br/>}<br/><br/>func New[T any](fetcher Fetcher[T], expirationPeriod time.Duration) *Cache[T] {<br/> return &amp;Cache[T]{<br/>  Fetcher: fetcher,<br/>  // Cache is expired by default as there are no items in it.<br/>  lastRefreshTime:  time.Now().Add(-2 * expirationPeriod),<br/>  expirationPeriod: expirationPeriod,<br/> }<br/>}<br/><br/>// Get cached item(s) that are refreshed if expired or returned as is.<br/>func (c *Cache[T]) Get() (T, error) {<br/> err := c.refresh()<br/> return c.cache, err<br/>}<br/><br/>// refresh expired cache if necessary.<br/>func (c *Cache[T]) refresh() (err error) {<br/> if c.isFresh() {<br/>  return<br/> }<br/><br/> c.cache, err = c.Fetch()<br/> if err != nil {<br/>  return<br/> }<br/><br/> c.lastRefreshTime = time.Now()<br/> return<br/>}<br/><br/>// isFresh tells us whether it's time to refresh our cache.<br/>func (c *Cache[T]) isFresh() bool {<br/> return time.Now().Sub(c.lastRefreshTime) &lt; c.expirationPeriod<br/>}</span></pre><p id="6a0c" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">构造函数将<code class="fe lb lc ld le b">lastRefreshTime</code>及时设置为 2 个<code class="fe lb lc ld le b">expirationPeriod</code>单位，这确保了<code class="fe lb lc ld le b">refresh</code>在第一次加载时发生。</p><p id="b33e" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated"><code class="fe lb lc ld le b">isFresh</code>函数检查自上次刷新以来是否经过了<code class="fe lb lc ld le b">expirationPeriod</code>时间量，如果经过的时间量小于<code class="fe lb lc ld le b">expirationPeriod</code>则返回<code class="fe lb lc ld le b">true</code>(即不需要刷新)，如果自上次刷新以来经过的时间大于<code class="fe lb lc ld le b">expirationPeriod</code>(即需要刷新)，则返回<code class="fe lb lc ld le b">false</code>。</p><h2 id="7807" class="nj lu in bd lv nk nl dn lz nm nn dp md kn no np mh kr nq nr ml kv ns nt mp nu bi translated">types.go</h2><pre class="mw mx my mz gt na le nb bn nc nd bi"><span id="0b59" class="ne lu in le b be nf ng l nv ni">package instagram<br/><br/>type Feed struct {<br/> Data []struct {<br/>  ID string `json:"id"`<br/> } `json:"data"`<br/> Paging struct {<br/>  Cursors struct {<br/>   Before string `json:"before"`<br/>   After  string `json:"after"`<br/>  } `json:"cursors"`<br/>  Next string `json:"next"`<br/> } `json:"paging"`<br/>}<br/><br/>type Item struct {<br/> MediaURL     string `json:"media_url"`<br/> Permalink    string `json:"permalink"`<br/> ThumbnailURL string `json:"thumbnail_url"`<br/> MediaType    string `json:"media_type"`<br/> ID           string `json:"id"`<br/>}</span></pre><p id="8722" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated"><code class="fe lb lc ld le b">types.go</code>包含了<code class="fe lb lc ld le b">Feed</code>和<code class="fe lb lc ld le b">Item</code>的类型定义，它们是使用<a class="ae la" href="https://transform.tools/json-to-go" rel="noopener ugc nofollow" target="_blank">这个 JSON to Go transformer 工具</a>从 Instagram API 响应中自动生成的。</p><p id="6fbb" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated"><code class="fe lb lc ld le b">Feed</code>类型是通过查询这个 API 端点的 JSON 响应生成的:</p><p id="76e6" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated"><code class="fe lb lc ld le b">https://graph.instagram.com/{user_id}/media?access_token={access_token}</code></p><p id="2874" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated"><code class="fe lb lc ld le b">Item</code>类型是从查询该 API 端点的 JSON 响应中生成的(使用之前响应中的 Instagram post <code class="fe lb lc ld le b">id</code>):</p><p id="12a3" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated"><code class="fe lb lc ld le b">https://graph.instagram.com/{id}?access_token={access_token}&amp;fields=media_url,permalink,thumbnail_url,media_type</code></p><h2 id="6fb3" class="nj lu in bd lv nk nl dn lz nm nn dp md kn no np mh kr nq nr ml kv ns nt mp nu bi translated">去拿吧</h2><pre class="mw mx my mz gt na le nb bn nc nd bi"><span id="e19a" class="ne lu in le b be nf ng l nv ni">package instagram<br/><br/>import (<br/> "encoding/json"<br/> "fmt"<br/> "net/http"<br/>)<br/><br/>type Fetcher struct {<br/> instaURL    string<br/> accessToken string<br/>}<br/><br/>func NewFetcher(instaURL string, accessToken string) *Fetcher {<br/> return &amp;Fetcher{<br/>  instaURL:    instaURL,<br/>  accessToken: accessToken,<br/> }<br/>}<br/><br/>// Fetch gets the Feed by calling feed(), and for each Instagram post it <br/>// gets the Item by calling Item(id) and puts them all in a slice<br/>func (f *Fetcher) Fetch() (items []*Item, err error) {<br/> feed, err := f.feed()<br/> if err != nil {<br/>  return<br/> }<br/><br/> for i := 0; i &lt; 9 &amp;&amp; i &lt; len(feed.Data); i++ {<br/>  item, err := f.item(feed.Data[i].ID)<br/>  if err != nil {<br/>   return nil, err<br/>  }<br/>  items = append(items, item)<br/> }<br/><br/> return<br/>}<br/><br/>// feed performs the GET request using instaURL<br/>func (f *Fetcher) feed() (feed *Feed, err error) {<br/> resp, err := http.Get(f.instaURL)<br/> if err != nil {<br/>  return nil, fmt.Errorf("error making HTTP request: %s", err)<br/> }<br/><br/> feed = new(Feed)<br/> if err := json.NewDecoder(resp.Body).Decode(feed); err != nil {<br/>  return nil, fmt.Errorf("error decoding insta feed: %s", err)<br/> }<br/><br/> return<br/>}<br/><br/>// item performs the GET request for a specific Instagram post given the id<br/>func (f *Fetcher) item(id string) (instaItem *Item, err error) {<br/> mediaUrl := fmt.Sprintf(<br/>  "https://graph.instagram.com/%s?access_token=%s&amp;fields=media_url,permalink,thumbnail_url,media_type",<br/>  id,<br/>  f.accessToken,<br/> )<br/><br/> resp, err := http.Get(mediaUrl)<br/> if err != nil {<br/>  return nil, fmt.Errorf("error getting media item with id %s: %s", id, err)<br/> }<br/><br/> instaItem = new(Item)<br/> if err := json.NewDecoder(resp.Body).Decode(instaItem); err != nil {<br/>  return nil, fmt.Errorf("error decoding media item with id %s: %s", id, err)<br/> }<br/><br/> return<br/>}</span></pre><p id="fd50" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated"><code class="fe lb lc ld le b">Fetch</code>函数执行提取操作。</p><p id="0dd0" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated"><code class="fe lb lc ld le b">https://graph.instagram.com/{user_id}/media?access_token={access_token}</code></p><p id="a095" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated"><code class="fe lb lc ld le b">Fetch</code>调用<code class="fe lb lc ld le b">feed</code>函数，该函数查询上述端点并返回一个<code class="fe lb lc ld le b">Feed</code>。<code class="fe lb lc ld le b">Feed</code>包含<code class="fe lb lc ld le b">Data</code>:一片介质<code class="fe lb lc ld le b">id</code>。</p><p id="284f" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">在这些<code class="fe lb lc ld le b">id</code>的循环中，<code class="fe lb lc ld le b">Fetch</code>为每个<code class="fe lb lc ld le b">id</code>调用<code class="fe lb lc ld le b">item</code>函数，该函数返回一个<code class="fe lb lc ld le b">Item</code>。这个<code class="fe lb lc ld le b">Item</code>然后被加到<code class="fe lb lc ld le b">items</code>片上并返回。</p><h2 id="2825" class="nj lu in bd lv nk nl dn lz nm nn dp md kn no np mh kr nq nr ml kv ns nt mp nu bi translated">service.go</h2><pre class="mw mx my mz gt na le nb bn nc nd bi"><span id="041d" class="ne lu in le b be nf ng l nv ni">package service<br/><br/>import (<br/> "net/http"<br/><br/> "github.com/fs1g17/http-server/instagram"<br/> "github.com/labstack/echo/v4"<br/> "github.com/labstack/echo/v4/middleware"<br/>)<br/><br/>type Getter interface {<br/> Get() ([]*instagram.Item, error)<br/>}<br/><br/>type Service struct {<br/> Getter<br/>}<br/><br/>func New(getter Getter) *Service {<br/> return &amp;Service{<br/>  Getter: getter,<br/> }<br/>}<br/><br/>// Server returns an echo server with CORS permissions and serves the items<br/>func (s *Service) Server() *echo.Echo {<br/> e := echo.New()<br/> e.Use(<br/>  middleware.Recover(),<br/>  middleware.Logger(),<br/>  middleware.CORS(),<br/> )<br/> e.GET("/", s.items)<br/> return e<br/>}<br/><br/>// items gets the items using the Getter<br/>func (s *Service) items(c echo.Context) (err error) {<br/> items, err := s.Get()<br/> if err != nil {<br/>  c.Logger().Errorf("error getting instagram feed items: %s", err)<br/>  return c.String(http.StatusInternalServerError, "can't fetch instagram items")<br/> }<br/> return c.JSON(http.StatusOK, items)<br/>}</span></pre><p id="54ff" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated"><code class="fe lb lc ld le b">Server</code>函数启动 echo 服务器并启用 CORS，服务于<code class="fe lb lc ld le b">items</code>函数以响应路径<code class="fe lb lc ld le b">/</code>的请求。</p><h2 id="db05" class="nj lu in bd lv nk nl dn lz nm nn dp md kn no np mh kr nq nr ml kv ns nt mp nu bi translated">。包封/包围（动词 envelop 的简写）</h2><p id="83e2" class="pw-post-body-paragraph kc kd in ke b kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz ig bi translated"><code class="fe lb lc ld le b">.env</code>文件包含了<code class="fe lb lc ld le b">access_token</code>和<code class="fe lb lc ld le b">user_id</code>，因此可以在<code class="fe lb lc ld le b">main.go</code>中访问它们:</p><pre class="mw mx my mz gt na le nb bn nc nd bi"><span id="57d6" class="ne lu in le b be nf ng l nv ni">ACCESS_TOKEN="your-access-token"<br/>USER_ID="your-user-id"</span></pre><h2 id="1bb2" class="nj lu in bd lv nk nl dn lz nm nn dp md kn no np mh kr nq nr ml kv ns nt mp nu bi translated">main.go</h2><p id="82cd" class="pw-post-body-paragraph kc kd in ke b kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz ig bi translated">最后，<code class="fe lb lc ld le b">main.go</code>看起来是这样的:</p><pre class="mw mx my mz gt na le nb bn nc nd bi"><span id="d279" class="ne lu in le b be nf ng l nv ni">package main<br/><br/>import (<br/> "fmt"<br/> "log"<br/> "os"<br/> "time"<br/><br/> "github.com/fs1g17/http-server/cache"<br/> "github.com/fs1g17/http-server/instagram"<br/> "github.com/fs1g17/http-server/service"<br/><br/> "github.com/joho/godotenv"<br/>)<br/><br/>func main() {<br/> err := godotenv.Load(".env")<br/><br/> if err != nil {<br/>  log.Fatalf("Error loading .env file")<br/> }<br/><br/> accessToken := os.Getenv("ACCESS_TOKEN")<br/> userId := os.Getenv("USER_ID")<br/> addr := ":9090"<br/> cacheExpirationTime := time.Hour<br/><br/> instaURL := fmt.Sprintf("https://graph.instagram.com/%s/media?access_token=%s", userId, accessToken)<br/> fetcher := instagram.NewFetcher(instaURL, accessToken)<br/> cache := cache.New[[]*instagram.Item](fetcher, cacheExpirationTime)<br/> service := service.New(cache)<br/> if err := service.Server().Start(addr); err != nil {<br/>  log.Fatalln(err)<br/> }<br/>}</span></pre><p id="4e4b" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated"><code class="fe lb lc ld le b">main</code>函数从<code class="fe lb lc ld le b">.env</code>文件中检索<code class="fe lb lc ld le b">user_id</code>和<code class="fe lb lc ld le b">access_token</code>变量，并启动 echo 服务器。</p><h1 id="e988" class="lt lu in bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">停靠服务器</h1><h2 id="23ad" class="nj lu in bd lv nk nl dn lz nm nn dp md kn no np mh kr nq nr ml kv ns nt mp nu bi translated">Dockerfile 文件</h2><p id="53b3" class="pw-post-body-paragraph kc kd in ke b kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz ig bi translated">docker 文件的灵感来自于<a class="ae la" href="https://firebase.google.com/docs/hosting/cloud-run#containerize" rel="noopener ugc nofollow" target="_blank"> Firebase 容器化文档</a></p><pre class="mw mx my mz gt na le nb bn nc nd bi"><span id="ad01" class="ne lu in le b be nf ng l nv ni">FROM golang:1.19 as builder<br/>WORKDIR /app<br/>COPY . .<br/>RUN go mod download<br/>RUN CGO_ENABLED=0 GOOS=linux go build -mod=readonly -v -o server<br/><br/>FROM alpine:3<br/>RUN apk add --no-cache ca-certificates<br/>WORKDIR /app<br/>COPY .env .<br/>COPY --from=builder /app/server .<br/>EXPOSE 8080<br/>CMD [ "/app/server" ]</span></pre><h2 id="0a2a" class="nj lu in bd lv nk nl dn lz nm nn dp md kn no np mh kr nq nr ml kv ns nt mp nu bi translated">docker-compose.yml</h2><pre class="mw mx my mz gt na le nb bn nc nd bi"><span id="c0e1" class="ne lu in le b be nf ng l nv ni">version: "3"<br/>services:<br/>  gw:<br/>    build: .<br/>    image: gw<br/>    container_name: gw<br/>    ports:<br/>      - 8080:8080</span></pre><h1 id="6831" class="lt lu in bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">在 Firebase 上发布服务器</h1><p id="ceb2" class="pw-post-body-paragraph kc kd in ke b kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz ig bi translated">为了在 Firebase 上发布服务器，我首先创建了一个 Firebase 项目，然后按照<a class="ae la" href="https://firebase.google.com/docs/hosting/cloud-run" rel="noopener ugc nofollow" target="_blank">的说明提供动态内容</a>。此时，剩下的唯一事情就是<a class="ae la" href="https://github.com/fs1g17/instafeed/blob/c3bc6c262d20a9ec430ede18f1eebc349599338d/src/components/InstaFeed/InstaFeed.tsx#L16" rel="noopener ugc nofollow" target="_blank">将<a class="ae la" href="https://github.com/fs1g17/instafeed/" rel="noopener ugc nofollow" target="_blank">前端</a>中的 URL </a>更新为 Firebase 上发布的 Go 服务器的 URL。</p><h1 id="f4a8" class="lt lu in bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">结论</h1><p id="8d40" class="pw-post-body-paragraph kc kd in ke b kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz ig bi translated">在本文中，我讨论了一种使用用 Go 编写的服务器缓存 Instagram API 结果的方法，这种服务器是容器化的，托管在 Firebase 上。</p><p id="68e3" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">通过这种方式，<code class="fe lb lc ld le b">access_token</code>和<code class="fe lb lc ld le b">user_id</code>被隐藏起来，结果被缓存在云中，每小时重新获取一次，并且不会超过 Instagram API 的限制。</p><p id="ef4d" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">然而，这种方法的一个潜在问题是，<code class="fe lb lc ld le b">access_token</code>和<code class="fe lb lc ld le b">user_id</code>可能会改变(例如，如果<code class="fe lb lc ld le b">access_token</code>到期)。如果这些变量确实改变了，</p></div></div>    
</body>
</html>