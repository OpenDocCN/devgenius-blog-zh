<html>
<head>
<title>React Interview: Difference between class-based &amp; Functional component</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React 面试:基于课程和功能组件的区别</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/react-interview-difference-between-class-based-functional-component-f0c24e8b73a3?source=collection_archive---------10-----------------------#2022-12-26">https://blog.devgenius.io/react-interview-difference-between-class-based-functional-component-f0c24e8b73a3?source=collection_archive---------10-----------------------#2022-12-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="065e" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">react 中基于类的组件与功能组件</h2></div><p id="f817" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是一个非常著名的面试问题，在 React 的每次面试中都会被问到，因为它基于<strong class="ke io"> react 生命周期方法</strong>。你可以说没有生命周期方法的 react 是<strong class="ke io">空</strong>，因为<strong class="ke io">挂载</strong>，<strong class="ke io">更新</strong> &amp; <strong class="ke io">卸载</strong> dom。感谢<a class="ae ky" href="https://www.youtube.com/watch?v=UbLYdbOPLe8&amp;ab_channel=TechnicalSuneja" rel="noopener ugc nofollow" target="_blank">技术 Suneja </a>对上述话题的很好的解释。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi kz"><img src="../Images/e995a246af287c564938f92b43e0c1d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*jN5NVXJ6zJacqJFEIw00Tg.png"/></div><figcaption class="lh li gj gh gi lj lk bd b be z dk translated">React 中的组件</figcaption></figure><p id="78ec" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">文档对象模型</strong> (DOM)是放置所有元素的地方。现在，假设您想要操作 dom，如果没有 react app 的生命周期方法，首次加载内容、更新内容或从 dom 中删除内容是不可能的。所以 react 本身在内部使用这些方法，不管是基于类的组件还是有方法的组件，如果你使用功能性的组件，那么你就有 T21 来实现 react 中的生命周期方法。React 有 3 个阶段，即。<strong class="ke io">安装</strong>、<strong class="ke io">更新</strong> &amp; <strong class="ke io">卸载</strong>。</p><h1 id="3e8f" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">I)基于类的组件</h1><p id="8875" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">(I)基于类的组件是<strong class="ke io">有状态或无状态</strong>组件，因为它依赖于<strong class="ke io">状态的值。<br/> </strong> (ii)在基于类的组件中有一个<strong class="ke io"> render </strong>函数，用于返回 react 元素。<br/> (iii)我们有两个选项的类组件使用<strong class="ke io">道具</strong>并设置<strong class="ke io">状态</strong>。</p><p id="1639" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">基于类的组件基于<strong class="ke io"> 3 </strong>生命周期方法，即</p><ol class=""><li id="6401" class="mi mj in ke b kf kg ki kj kl mk kp ml kt mm kx mn mo mp mq bi translated"><strong class="ke io"> componentDidMount() </strong> —组件首次加载或渲染时。<br/>例如，当你想加载 web 服务并且它的响应或内容应该在页面加载时可用时，你可以使用这个方法。</li><li id="c525" class="mi mj in ke b kf mr ki ms kl mt kp mu kt mv kx mn mo mp mq bi translated"><strong class="ke io"> componentDidUpdate() — </strong>每当第一次加载页面时，都会调用 componentDidMount()。</li><li id="d6d0" class="mi mj in ke b kf mr ki ms kl mt kp mu kt mv kx mn mo mp mq bi translated">c<strong class="ke io">componentdidunmount()—</strong>无论何时从 dom 中移除任何组件，都会调用 componentWillUnmount()。</li></ol><p id="69f2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意——如果你想在加载 DOM 之前加载<strong class="ke io">，那么你需要使用<strong class="ke io">构造函数</strong>。例如，你想在加载页面之前初始化值或变量。</strong></p><pre class="la lb lc ld gt mw mx my bn mz na bi"><span id="e7d6" class="nb lm in mx b be nc nd l ne nf"> //initialize variable before page load<br/>  constructor() {<br/>    super();<br/><br/>    //creating state by intializing setting variable count to 0<br/>    this.state = {<br/>      count: 0,<br/>    };<br/>  }</span></pre><p id="03bb" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，点击此处观看<a class="ae ky" href="https://stackblitz.com/edit/react-xb5w7q?file=src/components/Counter.js\" rel="noopener ugc nofollow" target="_blank">演示</a></p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="e6de" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">II)基于功能的组件</h1><p id="787c" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">(I)在基于类中，我们已经看到了实现生命周期的各种方法，但是功能组件是<strong class="ke io">无状态的</strong>，从版本<strong class="ke io"> 16.8 </strong>开始，钩子被用来实现生命周期方法。<br/>为了在使用基于功能的组件时实现安装，我们有<strong class="ke io">挂钩</strong>。在 react 中通常使用<strong class="ke io"> useEffect() </strong>钩子来实现一个生命周期。</p><p id="00b2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">(ii)在功能组件中，没有可用的渲染功能。<br/> (iii)功能组件只接受<strong class="ke io">道具</strong>作为参数。</p><p id="d7fa" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">示例:</p><pre class="la lb lc ld gt mw mx my bn mz na bi"><span id="5771" class="nb lm in mx b be nc nd l ne nf">1. load page on mounting<br/>  useEffect(() =&gt; {<br/>    console.log('Functional component: Mounting...');<br/>  });<br/><br/>2. load component only when data is updated, just add [] with dependency<br/>  useEffect(() =&gt; {<br/>    console.log('Functional component: Updating...');<br/>  }, [number]);<br/><br/>3. To acheive unmounting we need to return a callback<br/>  useEffect(() =&gt; {<br/>    return () =&gt; {<br/>      console.log('Functional component: Unmounted and Removed...');<br/>    };<br/>  }, [number]);</span></pre><p id="444a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">—点击此处观看<a class="ae ky" href="https://stackblitz.com/edit/react-25yecg?file=src%2FApp.js" rel="noopener ugc nofollow" target="_blank">演示</a></p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="ng nh l"/></div></figure></div></div>    
</body>
</html>