<html>
<head>
<title>How to add your C Library in Lua</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Lua中添加你的C库</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-add-your-c-library-in-lua-46fd246f0fa8?source=collection_archive---------3-----------------------#2020-06-21">https://blog.devgenius.io/how-to-add-your-c-library-in-lua-46fd246f0fa8?source=collection_archive---------3-----------------------#2020-06-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="d46b" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何将你的C库与Lua集成的基本例子</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/19f90dc0c9267d76775dcd62e53a022b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zKIAdEqFH5aR-H_L"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">由<a class="ae ks" href="https://unsplash.com/@austindistel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Austin Distel </a>在<a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="cc8e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">大家好，我在用love开发一个C库时遇到了一些麻烦，所以我想归档一下如何做:这个教程主要是为Linux制作的，但是来自windows的有经验的用户会明白该怎么做</p><p id="9c5e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">首先，如果您在linux环境下工作，您将希望安装Lua(您可能只从love使用它)，但它不应该是任何版本，它必须是与**Love 11.3**一起使用的Lua版本，即**Lua 5.1**，因此在您的终端中执行以下命令</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="06bf" class="lu lv in lq b gy lw lx l ly lz">sudo apt-get install lua5.1-dev</span></pre><p id="1822" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">使用这个版本是很重要的，正如我所读到的，我觉得Lua改变了你在每个版本中导出C函数的方式</p><p id="8670" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">该命令将安装在您的/usr/include/lua5.1 Lua头文件中，以便使用c。</p><p id="117b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，为了编译C，您必须安装gcc命令，这样做就像在终端<code class="fe ma mb mc lq b">shsudo apt-get install gcc </code>中调用一样简单。之后，您将需要创建您的C文件，其中包含要导出的函数，所以我们称它为nativefunc.c</p><p id="9ff0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">创建文件后，您需要在C代码中导入两个主库，lua库和lua辅助库:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="94c1" class="lu lv in lq b gy lw lx l ly lz">#include &lt;lua.h&gt;<br/>#include &lt;lauxlib.h&gt;</span></pre><p id="a77c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">[本教程的可选读物](在编写更复杂的函数时，您将需要它)之后，您将需要研究lua.org网站的第26到28章的一些规范:<a class="ae ks" href="https://www.lua.org/pil/contents.html" rel="noopener ugc nofollow" target="_blank">https://www.lua.org/pil/contents.html</a></p><h1 id="fdb1" class="md lv in bd me mf mg mh mi mj mk ml mm jt mn ju mo jw mp jx mq jz mr ka ms mt bi translated">要阅读的章节</h1><ul class=""><li id="b2ea" class="mu mv in kv b kw mw kz mx lc my lg mz lk na lo nb nc nd ne bi translated">26= &gt;从Lua调用C</li><li id="94b6" class="mu mv in kv b kw nf kz ng lc nh lg ni lk nj lo nb nc nd ne bi translated">27= &gt;编写C函数的技巧</li><li id="36a8" class="mu mv in kv b kw nf kz ng lc nh lg ni lk nj lo nb nc nd ne bi translated">28 =中的用户定义类型</li></ul><p id="1641" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">读完之后，你就有了编写复杂的C函数所需的大部分内容，接下来，让我们创建你的第一个C导出函数:每个导出的函数都必须遵循下面的原型:<code class="fe ma mb mc lq b">typedef int (*lua_CFunction) (lua_State *L)</code></p><p id="9dbf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">也就是说:定义一个函数，它的返回类型是**int**，收到的参数是* <em class="nk"> lua_State </em> L**，那么，看看它是怎么定义的:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="5a55" class="lu lv in lq b gy lw lx l ly lz">static int l_mult50(lua_State* L)</span></pre><p id="47c8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">正如你所看到的，这里有一些常见的做法:首先，通常函数被声明为静态函数，在C语言中，这意味着你的函数在外部是不可见的，l_通常被用来表示这个函数在库上。</p><p id="87a6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">要获取函数中的参数，您必须获取它的索引，每个参数函数都从1开始，因此示例如下:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="3b9d" class="lu lv in lq b gy lw lx l ly lz">double number = lua_tonumber(L, 1);</span></pre><p id="705d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当你从你的Lua脚本中调用这个函数时，它将接收传递的数字作为第一个参数，但是这是类型不安全的，如果你想在传递错误消息时得到著名的错误消息，你需要把它转换为:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="35c3" class="lu lv in lq b gy lw lx l ly lz">double number = luaL_checknumber(L, 1)</span></pre><p id="510f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">其中一些检查很容易记住</p><h1 id="b61b" class="md lv in bd me mf mg mh mi mj mk ml mm jt mn ju mo jw mp jx mq jz mr ka ms mt bi translated">Checktype函数</h1><ul class=""><li id="b39b" class="mu mv in kv b kw mw kz mx lc my lg mz lk na lo nb nc nd ne bi translated">luaL_checkstring，</li><li id="1b24" class="mu mv in kv b kw nf kz ng lc nh lg ni lk nj lo nb nc nd ne bi translated">luaL_checknumber，</li><li id="2100" class="mu mv in kv b kw nf kz ng lc nh lg ni lk nj lo nb nc nd ne bi translated">luaL_checkint，</li><li id="50e4" class="mu mv in kv b kw nf kz ng lc nh lg ni lk nj lo nb nc nd ne bi translated">luaL_checkany</li></ul><p id="04cb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，您可以对参数做任何您想做的事情了，如简单示例所示，让我们将它乘以50</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="6b57" class="lu lv in lq b gy lw lx l ly lz">number*= 50;</span></pre><p id="1143" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">(number = number * 50的缩写)之后，我们会想把它返回给Lua中的某个变量，那么我们该怎么做呢？你需要调用lua_push <a class="ae ks" href="https://github.com/MrcSnm/How-to-add-your-C-Library-in-Lua/blob/master/value" rel="noopener ugc nofollow" target="_blank">数据</a>，最常见的查找使用有:</p><h1 id="b4e6" class="md lv in bd me mf mg mh mi mj mk ml mm jt mn ju mo jw mp jx mq jz mr ka ms mt bi translated">推动价值函数</h1><ul class=""><li id="ddd8" class="mu mv in kv b kw mw kz mx lc my lg mz lk na lo nb nc nd ne bi translated">lua_pushnumber，</li><li id="f829" class="mu mv in kv b kw nf kz ng lc nh lg ni lk nj lo nb nc nd ne bi translated">lua_pushboolean，</li><li id="b7c4" class="mu mv in kv b kw nf kz ng lc nh lg ni lk nj lo nb nc nd ne bi translated">lua_pushstring，</li><li id="0bca" class="mu mv in kv b kw nf kz ng lc nh lg ni lk nj lo nb nc nd ne bi translated">lua _ pushcfunction，</li><li id="fc66" class="mu mv in kv b kw nf kz ng lc nh lg ni lk nj lo nb nc nd ne bi translated">lua_pushnil，</li><li id="4e44" class="mu mv in kv b kw nf kz ng lc nh lg ni lk nj lo nb nc nd ne bi translated">lua_pushvalue</li></ul><p id="a426" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在我们的例子中，我们返回一个数字，所以:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="d882" class="lu lv in lq b gy lw lx l ly lz">lua_pushnumber(L, number);</span></pre><p id="da08" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在那之后，我们需要从我们的函数返回，但是有一件重要的事情:我们的函数必须返回我们推送了多少个值，在我们的例子中，我们必须<code class="fe ma mb mc lq b">return 1 </code>在你返回x和y的例子中，你会返回2，(因为你需要推送数字x和y)</p><p id="febc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以，我们完成的函数看起来像这样:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="ccca" class="lu lv in lq b gy lw lx l ly lz">static int l_mult50(lua_State* L)<br/>{<br/>    double number = luaL_checknumber(L, 1);<br/>    lua_pushnumber(L, number*50);<br/>    return 1;<br/>}</span></pre><p id="951e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">之后，Lua将需要命名函数以及在哪里找到它，这部分对于在Lua中执行它是极其重要的。你需要创建另一个前缀为luaopen_的函数，在这个前缀之后，你需要输入将要导入到你的游戏中的文件名，在我们的例子中，它将被命名为libnativefunc.so(在Windows情况下为dll)，最终的名字将是luaopen_libnativefunc我使用lib作为文件前缀，因为以_lib_开始你的库名是一个好习惯，所以让我们开始定义这个函数</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="ec75" class="lu lv in lq b gy lw lx l ly lz">int luaopen_libnativefunc(lua_State* L)</span></pre><p id="d36f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在我们需要定义我们的lib将在Lua中实现什么函数，为此我们需要定义一个C Struct数组，它被定义为:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="52e7" class="lu lv in lq b gy lw lx l ly lz">static const struct luaL_Reg nativeFuncLib []</span></pre><p id="004a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">luaL_Reg是一个由Lua定义的结构，它有一个名称和一个函数，所以继续使用这种类型很重要，为了定义它，我们将使用数组填充运算符:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="a0c8" class="lu lv in lq b gy lw lx l ly lz">static const struct luaL_Reg nativeFuncLib [] =<br/>{<br/>    {"mult50", l_mult50}, //Your function name, and the function reference after<br/>    {NULL, NULL}<br/>}</span></pre><p id="d51b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">正如你所看到的，我们的lib中注册的函数必须总是以{NULL，NULL}结尾，这意味着它已经完成了整个数组的迭代，如果不这样做，将会产生下面的错误分段错误(核心转储)。这是一个默认的C错误消息，当你的迭代器超出数组长度之后，在同一个函数中，你将需要在Lua中注册你的lib，这是我在试图找到要使用的正确的迭代器时出现最多错误的地方:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="b456" class="lu lv in lq b gy lw lx l ly lz">luaL_register(L, "nativelib", nativeFuncLib)</span></pre><p id="09ae" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">nativelib是保存库函数的全局变量，它被定义为一种Lua回调表:nativelib <a class="ae ks" href="https://github.com/MrcSnm/How-to-add-your-C-Library-in-Lua/blob/master" rel="noopener ugc nofollow" target="_blank"> "mult50" </a>，这就是它的工作方式，要完成它，只需返回1，现在我将所有代码放在这里以便于下面的操作:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="af96" class="lu lv in lq b gy lw lx l ly lz">#include &lt;lua.h&gt;<br/>#include &lt;lauxlib.h&gt;</span><span id="74b6" class="lu lv in lq b gy nl lx l ly lz">static int l_mult50(lua_State* L)<br/>{<br/>    double number = luaL_checknumber(L, 1);<br/>    lua_pushnumber(L, number*50);<br/>    return 1;<br/>}</span><span id="f586" class="lu lv in lq b gy nl lx l ly lz">int luaopen_libnativefunc(lua_State* L)<br/>{<br/>    static const struct luaL_Reg nativeFuncLib [] =<br/>    {<br/>         {"mult50", l_mult50}, //Your function name, and the function reference after<br/>         {NULL, NULL}<br/>    };<br/>    luaL_register(L, "nativelib", nativeFuncLib);<br/>    return 1;<br/>}</span></pre><p id="b894" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这就是我们完成的nativefunc.c文件。之后，为了在我们的Lua代码中使用它，我们需要将它编译为一个共享对象，通常称为library。所以还是。dll文件，我们需要用新的gcc命令来编译它</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="6aba" class="lu lv in lq b gy lw lx l ly lz">gcc -I/usr/include/lua5.1 nativefunc.c -c -fPIC</span></pre><p id="0549" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这段代码将编译我们的代码而不链接它，它将输出一个名为“nativefunc.o”的文件，现在我们将使用它:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="c417" class="lu lv in lq b gy lw lx l ly lz">gcc nativefunc.o -shared -o libnativefunc.so</span></pre><p id="cb17" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">(转换一下。所以在。在这之后，你将最终生成你将在Lua中导入的文件，有两种通用的方法，一种更简单，灵活性更差，另一种是anthonym:</p><p id="6854" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">休闲小站</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="0383" class="lu lv in lq b gy lw lx l ly lz">require "libnativefunc"</span></pre><p id="40c0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">更难的方法</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="3900" class="lu lv in lq b gy lw lx l ly lz">lib = package.loadlib("./libnativefunc.so", "luaopen_libnativefunc")<br/>lib();<br/>--Shorter Version - package.loadlib("./libnativefunc.so", "luaopen_libnativefunc")()</span></pre><p id="7b5e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以，基本上，比较难和比较容易的方法的区别在于，在比较难的方法中，你定义哪个函数注册了你的库，之后，你就可以调用你自己的函数了</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="8e08" class="lu lv in lq b gy lw lx l ly lz">print(nativelib.mult50(50))</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nm"><img src="../Images/042488e35de5e9aaca4ab1b46534f41e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VZ_8yqukdHE3fMZQEhYqtg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">结果呢</figcaption></figure></div></div>    
</body>
</html>