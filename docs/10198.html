<html>
<head>
<title>Series: Developing a web application with Ktor</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">系列:用 Ktor 开发 web 应用程序</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/series-developing-a-web-application-with-ktor-67cdd8e0f73b?source=collection_archive---------4-----------------------#2022-10-14">https://blog.devgenius.io/series-developing-a-web-application-with-ktor-67cdd8e0f73b?source=collection_archive---------4-----------------------#2022-10-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b335e56674b3c561e14ddb8538faf56d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dX5WByhliJbHx-hl9pgnHQ.png"/></div></div></figure><p id="a610" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是我关于用<strong class="jx io"> Ktor </strong>开发 web 应用程序系列的第三篇文章。</p><p id="89b1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些文章将涵盖以下主题:</p><ul class=""><li id="e64e" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">需求规格</li><li id="9261" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">申请的结构</li><li id="92a0" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">服务器后端应用程序—设置</li><li id="71a1" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">服务器后端应用程序—持久性</li><li id="ba24" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">服务器后端应用程序—业务逻辑</li><li id="4b78" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">服务器后端应用程序— API 接口</li><li id="9c1d" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">服务器后端应用程序—身份验证+安全性+用户角色</li><li id="334b" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">前端 web 客户端—设置+用户界面</li><li id="b37a" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">前端 web 客户端— API 连接+身份验证</li><li id="5ad9" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">文档+应用交付</li><li id="5933" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">结论</li></ul><p id="287b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上一篇文章中，我实现了服务器后端应用程序的持久层。这包括数据库表定义、<strong class="jx io">公开的</strong>实体、创建当前数据库模式版本的机制(使用<strong class="jx io"> Liquibase </strong>)以及在应用程序启动时连接到数据库的功能。</p><h1 id="bc77" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">服务器后端应用程序—业务逻辑</h1><p id="0fa6" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated"><strong class="jx io">储存库</strong></p><p id="57d9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我完成持久层之后，仍然存在一些缺点。在开始实现银行应用程序的业务逻辑之前，我试图删除它们，或者至少最小化它们。</p><p id="0aa8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">到目前为止，<strong class="jx io">暴露的</strong>实体是用于持久化数据的接口。从业务服务直接调用它们将导致与<strong class="jx io">公开的</strong>框架实现的严格耦合，我甚至需要将所有实体调用包装在手动事务块中，以满足<strong class="jx io">公开的</strong>。还需要将域对象映射到业务服务中的<strong class="jx io">公开的</strong>实体。这两层之间没有明显的分离。持久层中的低级更改，如添加新列或更改列的数据类型，会导致业务服务的更改。</p><p id="2680" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，让我们开始通过引入存储库来增加层的分离。</p><p id="b31e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我为我的<strong class="jx io">公开的</strong>实体添加了存储库，这些实体包装了所有特定的功能，并提供了与数据库通信的接口，该接口独立于<strong class="jx io">公开的</strong>的具体实现。为了以后有机会替换<strong class="jx io">暴露的</strong>作为持久性框架，而不需要更新库，我还引入了<strong class="jx io"> Koin，</strong>作为依赖注入框架，这使我能够拥有不同版本的库，这些库是可交换的。</p><p id="4d3f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我将以下依赖项添加到<em class="mk"> build.gradle.kts </em>中:</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="6a93" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在应用程序中实现依赖注入的最后一步是安装<strong class="jx io"> Koin </strong>:</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="e7d9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如您所见，我已经通过注入在代码中定义了一个可用的依赖项。我创建了一个接口(<em class="mk"> UserRepository </em>)，它定义了应该可用的方法，还创建了一个实现类(<em class="mk"> UserRepositoryImpl </em>)，如果我需要接口类型的话，它会被注入。为了以后交换存储库实现，我只需添加一个新的实现类并更新<em class="mk"> bankingAppModule 的配置。</em>就这样。</p><p id="e9c2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了检查一切是否按预期运行，我为<em class="mk"> UserRepository </em>类创建了一个集成测试。</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="e593" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如你所看到的，依赖是通过<em class="mk"> inject() </em>函数注入的(该函数在幕后与委托一起工作)。为了在我的测试中使用<strong class="jx io"> Koin </strong>依赖注入，我必须注册一个测试扩展，它为注入提供必要的组件。</p><p id="37d1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下一步是最终确定<em class="mk">用户</em>、<em class="mk">账户</em>和<em class="mk">交易</em>的存储库。管理员<em class="mk">的功能</em>包括存储库，我将在后面的步骤中实现。原因是再次关注一件事。管理员用例与用户用例无关，所以我可以很容易地在以后添加它，并且仍然有一个工作的应用程序。</p><p id="705b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于帐户<em class="mk">和</em>，存储库的实现如下所示:</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="54c9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有一个定义必要方法的接口和一个实现<strong class="jx io">暴露的</strong>功能的类。存储库的调用者不必处理<strong class="jx io">暴露的</strong>特定功能，而是直接处理域对象。</p><p id="fcaa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">用于<em class="mk">事务</em>和<em class="mk">用户</em>存储库的代码可以在该项目的 Github 存储库中找到。它没有什么特别的，所以我在这里省略了展示。</p><p id="b5b9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">既然存储库已经最终确定，是时候将当前的功能与我在第一篇文章中定义的需求进行比较了。</p><p id="2e3e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于所有域对象，UUID 属性应该是唯一的(对于<em class="mk">用户</em>，<em class="mk">帐户 Id </em>对于<em class="mk">帐户</em>以及<em class="mk">事务 Id </em>对于<em class="mk">事务</em>)。通常情况下，UUID 的创建应该是独特的，当使用</p><pre class="ml mm mn mo gt mr ms mt mu aw mv bi"><span id="b6b9" class="mw li in ms b gy mx my l mz na">UUID.randomUUID()</span></pre><p id="5071" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是数据库的模式直到现在才强制执行这一点。这可以通过测试来验证(以<em class="mk">用户</em>为例):</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nb"><img src="../Images/ed620f7cd96327adebf2ea017ad635a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uGWGWdZotHPsq-ZWxF9CZw.png"/></div></div></figure><p id="b35a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">插入一个已经存在的用户 Id 为<em class="mk">的用户应该会抛出一个异常，因为违反了约束，但是这并没有发生。所以为了确保表中的列总是包含唯一的值，我必须给列添加一个约束。</em></p><p id="9d21" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是用<strong class="jx io"> Liquibase </strong>测试模式版本控制机制的好方法。我添加了第二个变更集，用于向列添加 unique 约束。</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="7386" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我还更新了表定义，所以<strong class="jx io">暴露的</strong>可以强制新的约束。</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="fbfa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">更新模式版本后，不再可能将重复的<em class="mk">用户 id/帐户 id/事务 Id </em>插入数据库。很明显，每个测试用例都涵盖了这些需求。</p><p id="85f5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">还有一个额外的需求是当前数据库模式所不能满足的。用户帐户的名称应该是唯一的。因为代码与上面的约束非常相似，所以我省略了代码展示。有兴趣的话可以去 Github 的资源库看看。</p><p id="c865" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我采取以下步骤来满足要求:</p><ul class=""><li id="86f2" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">我还先写了一个测试，验证是否可以为一个同名用户创建 2 个帐户。正如预期的那样，没有抛出异常，并且创建了一个重复的帐户。</li><li id="291f" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">我将约束添加到<em class="mk"> AccountTable </em>定义中。</li><li id="c327" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">我在<strong class="jx io"> Liquibase </strong> changelog 中添加了一个额外的变更集，并验证在更新之后，上面的测试场景会抛出一个异常。</li></ul><p id="f482" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当前数据库模式未满足的最后一个数据库模式相关需求是通过<em class="mk">名</em>、<em class="mk">姓</em>和<em class="mk">出生日期</em>对唯一用户的需求。</p><p id="22c8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">与上面的其他需求一样，我执行以下步骤:</p><ul class=""><li id="270b" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">我编写了一个测试来验证需求还没有被满足。</li><li id="588c" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">我将约束添加到<em class="mk">用户表</em>定义中。</li><li id="adb6" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">我向<strong class="jx io"> Liquibase </strong> changelog 添加了一个额外的变更集，并验证了在更新之后测试抛出了一个异常。</li></ul><p id="bb98" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过添加一个<em class="mk"> init{} </em>块，可以在<strong class="jx io"> Exposed </strong>中为一个表创建一个复合唯一索引，该块为指定的列创建一个<em class="mk"> uniqueIndex </em>。</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="7e98" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有了这个改变，所有与数据库模式相关的需求都满足了，我可以继续实现业务逻辑了。</p><p id="2f9f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从现在开始，我将不再为<strong class="jx io"> Liquibase </strong>添加变更集来迁移模式。我想现在用法应该很清楚了吧。</p><h1 id="a532" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated"><strong class="ak">应用服务</strong></h1><p id="438a" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">应用程序服务包含应用程序的主要业务逻辑。该层完成以下任务:</p><ul class=""><li id="d91f" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">将从请求处理器接收的 DTO 对象映射到域对象。</li><li id="16ce" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">验证 DTO 对象。</li><li id="0a85" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">处理异常(由验证引起或来自持久层)。</li><li id="6acd" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">调用持久层。</li><li id="2e03" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">日志请求流。</li><li id="e303" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">返回结果(成功或失败)。</li></ul><p id="19b1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因为许多任务都是在这一层完成的，所以我检查了如何在<strong class="jx io"> Ktor </strong>中使用日志记录，作为能够在以后跟踪请求的第一步。</p><p id="f736" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">默认情况下<strong class="jx io"> Ktor </strong>被配置为使用<strong class="jx io"> logback </strong>(默认配置已经可以通过 facade SLF4J API(log back . XML)获得。更多信息见<a class="ae nc" href="https://ktor.io/docs/logging.html" rel="noopener ugc nofollow" target="_blank"> Ktor 测井</a>。记录器可以在使用 SLF4J<em class="mk">logger factory</em>的类中使用。</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="c123" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在可以使用日志了，我开始为用户域对象实现应用程序服务。</p><p id="dce7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我创建了一个<em class="mk"> UserDto </em>，它包含了在数据库中创建用户所必需的属性——名字、姓氏、出生日期和密码。域对象的其余属性具有默认值，并在构造域对象时设置— userId、created、lastUpdated。</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="260d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">作为第一步，<em class="mk">用户服务</em>正在将<em class="mk">用户数据</em>映射到<em class="mk">用户</em>。在映射过程中，检查是否可以从<em class="mk">用户到</em>创建一个<em class="mk">用户</em>对象(是否可以将出生日期字符串解析为<em class="mk">本地日期</em>)并且完成业务验证:</p><ul class=""><li id="46d6" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated"><em class="mk">的出生日期</em>距离当前日期至少是 18 年前吗？</li><li id="8224" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated"><em class="mk">密码</em>是否满足要求:至少 16 个字符长度，大写+小写字符，数字和特殊字符。</li></ul><p id="4680" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">验证在<em class="mk"> init{} </em>块中完成，以验证<em class="mk">用户</em>对象只能用有效输入创建。</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="9be0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，也可以为用户类编写单元测试来进行验证。</p><p id="0f69" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mk">用户服务</em>的下一步是<em class="mk">用户</em>域对象的持久化，它现在包含一个有效的输入。在数据库模式约束的情况下(例如，通过<em class="mk">名字</em>、<em class="mk">姓氏</em>和<em class="mk">出生日期</em>重复用户)或一般数据库错误(例如，没有可用的连接)，持久性可能会失败。</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="076d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该服务将结果包装在一个<em class="mk"> ApiResult </em>中，该 ApiResult 由一个密封的类表示，该类有两个针对成功和失败情况的实现。<em class="mk">失败</em>案例还包含一个<em class="mk">错误代码</em>，该错误代码<em class="mk"> </em>帮助 API 的消费者稍后更具体地处理异常。</p><p id="5024" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个通用类用于所有的应用服务，与处理请求的控制器有一个一致的接口，并且不会在处理 http 请求的层中抛出异常。</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="4bee" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了处理可能发生的异常，我通常选择以下选项之一:</p><ul class=""><li id="f5d1" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">每个层都将所有可能发生的异常包装在特定的自定义异常类型中。由此，不需要在服务层中处理通用的<em class="mk">异常</em>类型。将异常类型映射到<em class="mk">错误代码</em>非常简单。</li><li id="1e4a" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">只有服务层在捕捉异常。有必要捕捉通用的<em class="mk">异常</em>类型，如果多个层抛出相同的异常类型(例如<em class="mk"> IllegalArgumentException </em>，则映射到<em class="mk">错误代码</em>并不容易。</li></ul><p id="2c8d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我选择第二个选项是因为对于银行应用程序，不同例外的数量是有限的。</p><p id="2ffa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我引入了<em class="mk"> InvalidInputException </em>，将所有与输入不匹配要求相关的异常打包到一个异常中。<strong class="jx io"> Kotlin </strong>目前不支持多次捕获，因此如果单独捕获异常，会导致多个具有相同内容的捕获块。</p><p id="4b23" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了验证<em class="mk"> UserService </em>是否按预期工作，我创建了集成测试来检查每个可能的失败和成功案例。测试设置与存储库测试完全相同。可以看到下面的两个测试用例。</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="af79" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在实现了第一个用例“创建用户”之后，我继续根据需求添加其他用例:更新用户、删除用户、查找用户和更新密码。最终实现如下所示:</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="bf98" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">用户的用例现在是最终的，我可以继续处理帐户和交易的用例。</p><p id="dc84" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于实现非常简单，并且与<em class="mk"> UserService </em>相比没有引入新的概念，因此我省略了显示代码。您可以在相关的 Github 存储库中找到该实现。</p><p id="0443" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在已经实现了应用程序服务，在继续下一篇文章之前，我将清理现有的代码。对于<strong class="jx io"> Kotlin </strong>有一个可用于 IntelliJ 的插件，可以提供静态代码分析—<strong class="jx io">detect</strong></p><p id="c3ca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该插件可以从市场安装到<strong class="jx io"> IntelliJ </strong>上，按照<strong class="jx io">detect</strong>页面中的步骤在项目中激活(参见<a class="ae nc" href="https://plugins.jetbrains.com/plugin/10761-detekt" rel="noopener ugc nofollow" target="_blank">detect plugin</a>)。</p><p id="fb5a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">安装和配置后(我使用默认设置)<strong class="jx io">detect</strong>显示了开放源代码文件中的潜在问题。目前，关于复杂性和重复的问题主要是有趣的，它们给出了一个提示，告诉我应该分析代码中的哪些区域，或者进行重构。</p><p id="fb63" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我检查所有现有的代码，并检查是否有相关的问题，我应该修复。这对于保持代码整洁非常有帮助。重要的是要知道，<strong class="jx io"> Detekt </strong>只是一个可以帮助你并给出提示的工具。修复所有的<strong class="jx io">检测</strong>问题以获得良好的代码质量并不是我们的目标。一些问题(比如重复)可以被修复，让<strong class="jx io"> Detekt </strong>高兴，但是不能提高代码的可读性。</p><p id="cdc8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">清理之后，我对当前的状态有了更好的感觉，这个系列的这篇文章就完成了。我将在下一篇文章中继续讨论以下主题:</p><ul class=""><li id="e1c9" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">为密码添加加密，因此它不再以纯文本形式存储</li><li id="db8b" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">添加 REST API 接口缺少的部分</li><li id="9fa7" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">向 REST API 接口添加身份验证机制</li></ul><p id="89d9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">服务器后端应用程序的代码可以在 Github 上找到:<a class="ae nc" href="https://github.com/PoisonedYouth/ktor-banking-app" rel="noopener ugc nofollow" target="_blank">https://github.com/PoisonedYouth/ktor-banking-app</a></p></div></div>    
</body>
</html>