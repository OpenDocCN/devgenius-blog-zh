<html>
<head>
<title>12 Ways to Add an Array of Integers in C# — Part 5: All Together Now</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C#中添加整数数组的12种方法—第5部分:现在全部完成</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/12-ways-to-add-an-array-of-integers-in-c-part-5-all-together-now-e45323a86610?source=collection_archive---------4-----------------------#2020-12-11">https://blog.devgenius.io/12-ways-to-add-an-array-of-integers-in-c-part-5-all-together-now-e45323a86610?source=collection_archive---------4-----------------------#2020-12-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/83dbca67bdb4fcb88058d5c862ed4514.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qp2ZpWG9RI5nxG4SveMKMg.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">照片由<a class="ae jz" href="https://www.pexels.com/@ruiyang-zhang-915467?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">瑞阳张</a>从<a class="ae jz" href="https://www.pexels.com/photo/cars-driving-on-urban-highway-in-evening-3717242/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">派克斯</a></figcaption></figure><p id="20bc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我第一次开始这个系列的时候，我承诺用C#总共有12种方法来添加整数数组。到目前为止，我已经交付了10个(加上一个JavaScript版本和一个F#版本)。概括一下:</p><p id="86ff" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第1部分 : (1)一个简单的for循环，(2)一个使用goto的变体，以及(3)另一个使用指针的变体</p><p id="8e50" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://medium.com/dev-genius/12-ways-to-add-an-array-of-integers-in-c-part-2-freeform-iteration-2f5c810a8e7b?source=friends_link&amp;sk=ae3d73998d2e57811d3bea1374f7ddc7" rel="noopener">第二部分</a>:(4)foreach循环和(5)显式使用枚举器</p><p id="628c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://medium.com/dev-genius/12-ways-to-add-an-array-of-integers-in-c-part-3-thinking-in-sets-e2f456454f88?source=friends_link&amp;sk=4dff1c44cc446516161d65fe6e0fba26" rel="noopener">第三部分</a> : (6)可枚举。聚合和(7)可枚举。总和</p><p id="7858" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://medium.com/dev-genius/12-ways-to-add-an-array-of-integers-in-c-part-4-again-and-again-and-again-dddd86ec8ee?source=friends_link&amp;sk=bab4198dd6fea824897b88af9e1d6af5" rel="noopener">第4部分</a>:递归地，使用(8)个数组，(9)个Linq，和(10)个指针</p><p id="f295" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从那里还能去哪里？正如维兹尼所说(就在无意中毒死自己之前):“我才刚刚开始！”</p><p id="0528" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不过，真的，我不是。我快没主意了。事实上，下一个是如此愚蠢，几乎不算数。但我要用它来引出更有趣的东西，所以请多包涵。</p><h1 id="41ed" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">从队列中读取</h1><p id="a578" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">这里有两个片段。</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="56b5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一点都不有趣，是吗？这在讨论扩展方法的编码面试(记住这是整个事情开始的地方)中是有用的。但除此之外，这只是一个更复杂的方法，来做我们在第一个版本中做的事情。</p><p id="bdec" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">更糟糕的是，与其他方法相比，它实际上比较慢。这并不奇怪，因为它比其他的要复杂得多，没有真正的好处。</p><p id="2e47" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是这会带来更好的结果吗？例如，如果我们用一个<code class="fe mi mj mk ml b">ConcurrentQueue&lt;T&gt;</code>代替<code class="fe mi mj mk ml b">Queue&lt;T&gt;</code>会怎么样？我们能否多线程化这个宝贝，让它在一半或更短的时间内运行起来？</p><h1 id="b9e0" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">并行使用并发队列</h1><p id="2291" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">让我们试一试。</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="5846" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">没问题！我们只需运行之前的队列示例，将它分成四个并行任务，然后看着它燃烧。那里的<code class="fe mi mj mk ml b">Interlocked.Add</code>防止我们在加法上出错。</p><p id="a55d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那么它真的有用吗？嗯，算是吧。我只能用我自己的笔记本电脑，它有两个不错的内核，但没有创下任何速度记录。但是从我目前的结果来看，这种方法非常慢。比平均速度慢10倍或更多。老实说，我不太清楚具体原因。对于将一个数字加到另一个数字这样的小操作来说，这可能需要太多的脚手架。对于运行时间更长、更复杂的操作，这种方法实际上可能行得通。</p><p id="7614" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以从技术上来说，这是我们的12种方式。但是为了防止有人认为第8和第9基本上是一样的——它们在某种程度上是一样的，但在某种程度上，这里的几乎所有东西都是同一件事情的不同版本——或者第11太荒谬了而无法计数，这里还有一个方法，实际上是对第12的一点改进。</p><h1 id="8ade" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">使用矩形阵列并行</h1><p id="0360" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">有多种方法可以提供对一系列事物的线程安全并发访问。</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="f335" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有很多，但总结一下:我们把一维数组重新排列成多维数组，然后并行处理所有的维度。它比并发队列版本更复杂，但性能也大大提高。事实上，在其他方法中，它略高于平均水平。遗憾的是，这并不是最快的，可能是因为安装成本的原因。</p><h1 id="0578" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="ba37" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">那么这一切有什么意义呢？从表面上看，这是一种挖掘潜在团队成员对C#语言的知识深度的方式，不管这有什么价值。更重要的是，谈论这些例子是一种衡量一个人对计算机编程如何工作的理解的广度和深度的方式。这些不同的方法展示了软件开发中的重要概念，而不仅仅是C#。一个非常了解他们的人可能会对你的团队做出积极的贡献。一个对概念模糊不清，但能提出好问题并表现出真正兴趣的人，处于学习和成长的有利位置。</p><p id="0c68" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">概括一下，下面是完整的列表:</p><p id="9c96" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">(1) <code class="fe mi mj mk ml b">for</code>循环:最普遍理解的，最快的</p><p id="89f0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">(2) <code class="fe mi mj mk ml b">goto</code>:大约和<code class="fe mi mj mk ml b">for</code>一样快，并不比它快多少，而且更令人困惑</p><p id="6981" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">(3)指针:挺快的，但不是最快的；没有做这件事的好理由</p><p id="363b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">(4) <code class="fe mi mj mk ml b">foreach</code>:另一种常见的解决方案，几乎和<code class="fe mi mj mk ml b">for</code>一样快</p><p id="6302" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">(5) <code class="fe mi mj mk ml b">Enumerator</code>:和<code class="fe mi mj mk ml b">foreach</code>一样的基本思想，但是更复杂，也不会更快</p><p id="fb63" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">(6) <code class="fe mi mj mk ml b">Enumerable.Aggregate</code>:在JavaScript中很棒的一种做法(reduce)，但在C#中就不那么好了；较慢的方法之一</p><p id="b44b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">(7) <code class="fe mi mj mk ml b">Enumerable.Sum</code>:不是最快的，但是非常接近，也是最简单的。有时在大型数据集上失败。</p><p id="431c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">(8)使用数组递归:由于尾部调用优化，这在F#中是一个好主意，但在C#中不是；较大数据集上的堆栈溢出，较小数据集上的一般性能</p><p id="ba80" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">(9)使用Linq递归:与使用数组递归有相同的缺点，性能更差</p><p id="ab95" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">(10)带指针的递归:令人惊讶的好性能，但是在大型数据集上仍然失败</p><p id="e515" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">(11a)排队:不必要的复杂和低于平均水平的性能</p><p id="dda9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">(11b)并发队列:令人惊讶的糟糕性能</p><p id="1861" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">(12)矩形阵列:性能一般，但复杂得多</p><p id="bc32" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">谢谢你陪我走完这段旅程。你永远不会做我在这里描述的大部分东西，但是希望这里有一些技术，你会发现对更合适的应用程序有帮助。</p><p id="dd18" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">还有其他建议吗？很想听听大家的意见。</p></div></div>    
</body>
</html>