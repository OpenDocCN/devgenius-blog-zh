<html>
<head>
<title>How to Migrate from MySQL to PostgreSQL RDBMS: An Enterprise Approach</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何从 MySQL 迁移到 PostgreSQL RDBMS:企业方法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-migrate-from-mysql-to-postgresql-rdbms-an-enterprise-approach-ef796fa2b189?source=collection_archive---------14-----------------------#2022-10-17">https://blog.devgenius.io/how-to-migrate-from-mysql-to-postgresql-rdbms-an-enterprise-approach-ef796fa2b189?source=collection_archive---------14-----------------------#2022-10-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="46f9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这篇文章最初发表在 JFrog 的博客上。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/7b3b50dbc9b77725a75f8a7ac1594d3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s5LLTSIFGI0_uWvB_dpDjQ.png"/></div></div></figure><h1 id="d7e5" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">1.将 MySQL 迁移到 PostgreSQL 的介绍。</h1><p id="61a9" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">作为 JFrog 仅支持 PostgreSQL 数据库(DB)的 SaaS 战略的一部分，JFrog 需要将 SaaS 现有客户的数据库从 MySQL 迁移到 PostgreSQL。</p><p id="f66b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">必须开发一个完全自动化、可靠且稳定的迁移流程，实现零数据丢失和最短的停机时间，能够迁移数十/数百 GB 的数据库，并保证现有应用程序能够透明地处理迁移的数据库。</p><p id="5086" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们开发了一个基于 pgloader 开源实用程序[【https://github.com/dimitri/pgloader】T2]的 MySQL2PG 进程来满足这种需求。</p><h1 id="28c5" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">2.将数据库从 MySQL 迁移到 PostgreSQL 的组件/拓扑是什么？</h1><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/f869f3e4dcf64044655ad0121434d439.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/0*KjAjbye4Xz86DHaO.png"/></div></figure><p id="4c9f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">DB 迁移过程的基本拓扑包括源数据库(MySQL)、目标数据库(PostgreSQL)和迁移机器。pgloader 从迁移机器上运行，从源数据库(MySQL)读取数据，并将其写入目标数据库(PostgreSQL)。</p><p id="becb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">迁移机器应该具有到源和目标数据库的直接、可靠和高吞吐量的连接。迁移机器的典型配置包括 16 个 CPU 和 64 GB RAM、至少 10 Gbps 的网络带宽和至少 500GB 的存储空间。</p><p id="8a90" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了保证数据库对象的兼容性、它们的结构以及与特定数据类型的一致性，数据库迁移过程首先运行适合特定类型/版本产品的 DDL 脚本。然后，它将数据复制到预先准备好的目标数据库模式中。</p><p id="f023" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">pgloader 没有将数据导出到转储中，没有将转储放在迁移机器上，也没有让 DBs 数据占用存储空间。它在迁移机器 RAM 中创建了一种管道进程，并从源数据库中选择数据并将其复制到目标数据库中。</p><h1 id="f693" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">3.迁移机器的典型操作系统是什么？</h1><p id="a890" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">操作系统:Ubuntu 20.04</p><p id="e658" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">lsb_release -a <br/>没有 lsb 模块可用。<br/>发行商 ID: Ubuntu <br/>描述:Ubuntu 20.04.2 LTS <br/>发布时间:20.04 <br/>代号:focal</p><h1 id="14ec" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">4.建议在迁移机器上安装什么？</h1><pre class="kk kl km kn gt lz ma mb mc aw md bi"><span id="eb7b" class="me kw in ma b gy mf mg l mh mi">sudo sh -c 'echo "deb http://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main" &gt; /etc/apt/sources.list.d/pgdg.list'<br/>wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add -<br/>sudo apt-get update<br/>sudo apt-get -y install postgresql-13<br/>sudo apt-get install -y pgloader<br/>sudo apt-get install mysql-client</span></pre><h1 id="01df" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">5.如何运行 pgloader 将一个 DB 从 MySQL 迁移到 PostgreSQL？</h1><p id="66a6" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">创建 pgloader 配置文件:</p><pre class="kk kl km kn gt lz ma mb mc aw md bi"><span id="40b8" class="me kw in ma b gy mf mg l mh mi">cat pgloader.conf</span><span id="c47a" class="me kw in ma b gy mj mg l mh mi">LOAD DATABASE<br/>FROM mysql://src_db_user:src_db_pwd@src_db_host/src_db_name?sslmode=&lt;...&gt;<br/>INTO postgresql://dest_db_user:dest_db_pwd@dest_db_host/dest_db_name;</span></pre><p id="5003" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">运行 pgloader:</p><pre class="kk kl km kn gt lz ma mb mc aw md bi"><span id="1b90" class="me kw in ma b gy mf mg l mh mi">pgloader pgloader.conf</span></pre><h1 id="8ac1" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">6.如何运行 MySQL2PG pgloader 作为后台进程？</h1><p id="57f1" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">为了避免 MySQL2PG 迁移过程的中断，建议将 pgloader 作为后台进程运行。该过程包括以下步骤。</p><p id="6091" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">创建 pgloader 配置文件:</p><pre class="kk kl km kn gt lz ma mb mc aw md bi"><span id="84b9" class="me kw in ma b gy mf mg l mh mi">cat pgloader.conf</span><span id="9931" class="me kw in ma b gy mj mg l mh mi">LOAD DATABASE<br/>FROM mysql://src_db_user:src_db_pwd@src_db_host/src_db_name?sslmode=&lt;...&gt;<br/>INTO postgresql://dest_db_user:dest_db_pwd@dest_db_host/dest_db_name;</span></pre><p id="9f12" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">创建一个 shell 脚本，将 pgloader 作为后台进程运行:</p><pre class="kk kl km kn gt lz ma mb mc aw md bi"><span id="5546" class="me kw in ma b gy mf mg l mh mi">cat run_pgloader_background.sh</span><span id="8266" class="me kw in ma b gy mj mg l mh mi">nohup pgloader pgloader.conf 2&gt;&amp;1 &amp;</span></pre><p id="d479" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">运行脚本:</p><pre class="kk kl km kn gt lz ma mb mc aw md bi"><span id="c8a0" class="me kw in ma b gy mf mg l mh mi">run_pgloader_background.sh</span></pre><p id="c3c3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">运行跟踪将保存在文件中:</p><pre class="kk kl km kn gt lz ma mb mc aw md bi"><span id="3271" class="me kw in ma b gy mf mg l mh mi">nohup.out</span></pre><p id="b676" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意事项:</p><p id="f431" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通常</p><pre class="kk kl km kn gt lz ma mb mc aw md bi"><span id="efe2" class="me kw in ma b gy mf mg l mh mi">src_db_user = dest_db_user,<br/>src_db_pwd = dest_db_pwd,<br/>src_db_name = dest_db_name</span></pre><h1 id="3af4" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">7.pgloader 的典型输出跟踪是什么样的？</h1><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mk"><img src="../Images/0642fa7a06136f6632e1c1f03de4d9c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a6lE6VaRrC5a4bXWMwlEgQ.png"/></div></div></figure><h1 id="5f74" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">8.如何确保迁移成功完成？我如何确保零数据丢失？</h1><p id="c112" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">验证 pgloader 的跟踪:它应该没有错误，并且读取和导入的值应该匹配。</p><h1 id="3b38" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">9.如何从 pgloader 进程中排除表？</h1><p id="c5da" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">如果源数据库包含可以从迁移过程中安全排除的表，这可以通过 pgloader 的“排除表名匹配”配置来完成。</p><p id="849f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">示例:</p><pre class="kk kl km kn gt lz ma mb mc aw md bi"><span id="2ad5" class="me kw in ma b gy mf mg l mh mi">LOAD DATABASE<br/>FROM mysql://src_db_user:src_db_pwd@src_db_host/src_db_name?sslmode=&lt;...&gt;<br/>INTO postgresql://dest_db_user:dest_db_pwd@dest_db_host/dest_db_name</span><span id="f97a" class="me kw in ma b gy mj mg l mh mi">EXCLUDING TABLE NAMES MATCHING 'table_to_exclude_one','table_to_exclude_two','table_to_exclude_three';</span></pre><h1 id="ce70" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">10.“堆筋疲力尽，游戏结束”的问题。</h1><p id="98f6" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">来自 pgloader 的“Heap exhausted，game over”消息可能表明 pgloader 默认的专用 4GB RAM 对于给定的 DB 迁移运行来说是不够的。</p><p id="355d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种情况下的解决方案是使用用更广泛的 DYNSIZE 参数编译的 pgloader。DYNSIZE 参数允许修改 pgloader 映像在运行数据时允许自己使用的默认内存量。</p><h1 id="aebc" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">11.如何编译 pgloader 使用更多 RAM？</h1><p id="6b10" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">pgloader 实用程序没有使用主机上所有可用的 RAM。pgloader 可以使用的 RAM 数量在编译阶段定义。要使用更多的 RAM，应该编译定制版本的 pgloader。以下分步指南说明了如何使用自定义参数 DYNSIZE 编译 pgloader。DYNSIZE 参数允许在运行数据时修改 pgloader 映像。</p><pre class="kk kl km kn gt lz ma mb mc aw md bi"><span id="77ef" class="me kw in ma b gy mf mg l mh mi">pgloader compilation<br/>--------------------</span><span id="2659" class="me kw in ma b gy mj mg l mh mi">Build pgloader from sources</span><span id="8b95" class="me kw in ma b gy mj mg l mh mi">(1) Check OS:</span><span id="6d82" class="me kw in ma b gy mj mg l mh mi">dima@dima-VirtualBox:~$ lsb_release  -a<br/>No LSB modules are available.<br/>Distributor ID: Ubuntu<br/>Description:    Ubuntu 20.04.3 LTS<br/>Release:        20.04<br/>Codename:       focal<br/>dima@dima-VirtualBox:~$</span><span id="03d7" class="me kw in ma b gy mj mg l mh mi">(2) Install git:</span><span id="d5f1" class="me kw in ma b gy mj mg l mh mi">sudo apt update</span><span id="0a1b" class="me kw in ma b gy mj mg l mh mi">sudo apt install git</span><span id="608d" class="me kw in ma b gy mj mg l mh mi">(3) Clone pgloader:</span><span id="872f" class="me kw in ma b gy mj mg l mh mi">mkdir my_pgloader<br/>cd my_pgloader/<br/>git clone https://github.com/dimitri/pgloader.git</span><span id="5bbc" class="me kw in ma b gy mj mg l mh mi">(4) install packages necessary for build:</span><span id="fa11" class="me kw in ma b gy mj mg l mh mi">sudo apt-get install sbcl unzip libsqlite3-dev make curl gawk freetds-dev libzip-dev</span><span id="e571" class="me kw in ma b gy mj mg l mh mi">(5) make build:</span><span id="b904" class="me kw in ma b gy mj mg l mh mi"> make DYNSIZE=10240 pgloader</span><span id="ee3e" class="me kw in ma b gy mj mg l mh mi">(6) make outputs a ./build/bin/pgloader file for us to use.</span><span id="6d11" class="me kw in ma b gy mj mg l mh mi">dima@dima-VirtualBox:~/my_pgloader/pgloader/build/bin$ pwd<br/>/home/dima/my_pgloader/pgloader/build/bin<br/>dima@dima-VirtualBox:~/my_pgloader/pgloader/build/bin$ ls -rtogla<br/>total 69160<br/>-rw-rw-r-- 1       70 Jan  7 17:17 .gitignore<br/>drwxrwxr-x 5     4096 Jan  7 17:29 ..<br/>-rwxr-xr-x 1 41918800 Jan  7 17:29 buildapp.sbcl<br/>-rwxr-xr-x 1 29036008 Jan  7 17:29 pgloader<br/>drwxrwxr-x 2     4096 Jan  7 17:29 .<br/>dima@dima-VirtualBox:~/my_pgloader/pgloader/build/bin$</span><span id="acb7" class="me kw in ma b gy mj mg l mh mi">cp pgloader pgloader_dima_dynsize_10240</span><span id="85c8" class="me kw in ma b gy mj mg l mh mi">dima@dima-VirtualBox:~/my_pgloader/pgloader/build/bin$ ls -rtogla<br/>total 97396<br/>-rw-rw-r-- 1       70 Jan  7 17:17 .gitignore<br/>drwxrwxr-x 5     4096 Jan  7 17:29 ..<br/>-rwxr-xr-x 1 41918800 Jan  7 17:29 buildapp.sbcl<br/>-rwxr-xr-x 1 29036008 Jan  7 17:29 pgloader<br/>-rwxr-xr-x 1 29036008 Jan  7 17:33 pgloader_dima_dynsize_10240<br/>drwxrwxr-x 2     4096 Jan  7 17:33 .<br/>dima@dima-VirtualBox:~/my_pgloader/pgloader/build/bin$</span><span id="17c1" class="me kw in ma b gy mj mg l mh mi">dima@dima-VirtualBox:~/my_pgloader/pgloader/build/bin$ ./pgloader_dima_dynsize_10240 --version<br/>pgloader version "3.6.a94a0a3"<br/>compiled with SBCL 2.0.1.debian<br/>dima@dima-VirtualBox:~/my_pgloader/pgloader/build/bin$</span></pre><h1 id="867d" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">12.如何管理“对等端重置连接”pgloader 问题？</h1><p id="0e1b" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">pgloader 运行期间的“Connection reset by peer”错误消息通常表示 pgloader 连接 MySQL [源数据库]超时。</p><p id="881a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要解决此问题，我们建议将以下参数添加到 pgloader 配置脚本中:</p><pre class="kk kl km kn gt lz ma mb mc aw md bi"><span id="8db9" class="me kw in ma b gy mf mg l mh mi">SET MySQL PARAMETERS<br/>net_read_timeout = '5000',<br/>net_write_timeout = '5000'</span></pre><h1 id="8b7f" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">13.如何改善 pgloader 迁移过程的持续时间？</h1><p id="851c" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">有几种方法可以缩短 pgloader 迁移过程的持续时间:</p><p id="517f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">–纵向扩展源和目标数据库<br/>–确保源和目标数据库上无负载/大量活动/足够的存储、RAM、连接和资源<br/>–使用使用定制参数 DYNSIZE <br/>编译的 pgloader–纵向扩展迁移机器以允许更多 RAM<br/>–使用以下参数运行 pg loader:</p><pre class="kk kl km kn gt lz ma mb mc aw md bi"><span id="9c8a" class="me kw in ma b gy mf mg l mh mi">SET PostgreSQL PARAMETERS<br/>maintenance_work_mem to '512MB',<br/>work_mem to '48MB'</span></pre><h1 id="0bf9" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">14.如何配置 pgloader 在大数据库/大数据量上稳定可靠运行？</h1><p id="942c" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">–使用用定制的 DYNSIZE 参数编译的 pgloader。它将允许更多的 RAM 专用于 pgloader 进程<br/>–使用以下 pgloader 配置:</p><pre class="kk kl km kn gt lz ma mb mc aw md bi"><span id="213c" class="me kw in ma b gy mf mg l mh mi">cat pgloader.conf</span><span id="0d6d" class="me kw in ma b gy mj mg l mh mi">FROM LOAD DATABASE<br/>FROM mysql://db_user:db_pwd@src_db_host/db_name?sslmode=&lt;...&gt;<br/>INTO postgresql://db_user:db_pwd@dest_db_host/db_name</span><span id="501a" class="me kw in ma b gy mj mg l mh mi">WITH</span><span id="6a3b" class="me kw in ma b gy mj mg l mh mi">data only, create no indexes,</span><span id="3a6c" class="me kw in ma b gy mj mg l mh mi">workers = 8, concurrency = 1,<br/>multiple readers per thread, rows per range = 10000,<br/>batch rows = 10000</span><span id="9095" class="me kw in ma b gy mj mg l mh mi">SET PostgreSQL PARAMETERS<br/>maintenance_work_mem to '512MB',<br/>work_mem to '48MB'</span><span id="078d" class="me kw in ma b gy mj mg l mh mi">SET MySQL PARAMETERS<br/>net_read_timeout = '5000',<br/>net_write_timeout = '5000'</span><span id="d5cd" class="me kw in ma b gy mj mg l mh mi">EXCLUDING TABLE NAMES MATCHING 'table_to_exclude_one','table_to_exclude_two','table_to_exclude_three'</span><span id="4545" class="me kw in ma b gy mj mg l mh mi">ALTER SCHEMA 'db_schema_name' RENAME TO 'public';</span></pre><h1 id="43dd" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">15.最小的 pgloader 配置会是什么样子？</h1><pre class="kk kl km kn gt lz ma mb mc aw md bi"><span id="c247" class="me kw in ma b gy mf mg l mh mi">FROM LOAD DATABASE<br/>FROM mysql://db_user:db_pwd@src_db_host/db_name?sslmode=&lt;...&gt;<br/>INTO postgresql://db_user:db_pwd@dest_db_host/db_name</span><span id="69f7" class="me kw in ma b gy mj mg l mh mi">with<br/>batch size = 2048 kB,<br/>batch rows = 2000,<br/>prefetch rows = 2000</span><span id="3168" class="me kw in ma b gy mj mg l mh mi">SET PostgreSQL PARAMETERS<br/>maintenance_work_mem to '512MB',<br/>work_mem to '48MB'</span><span id="cd2a" class="me kw in ma b gy mj mg l mh mi">SET MySQL PARAMETERS<br/>net_read_timeout = '5000',<br/>net_write_timeout = '5000'</span><span id="c082" class="me kw in ma b gy mj mg l mh mi">EXCLUDING TABLE NAMES MATCHING 'table_to_exclude_one','table_to_exclude_two','table_to_exclude_three'</span><span id="0800" class="me kw in ma b gy mj mg l mh mi">ALTER SCHEMA 'db_schema_name' RENAME TO 'public';</span></pre><h1 id="6410" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">16.为什么在迁移过程之前、之中和之后监控源、目标数据库和迁移机器很重要？</h1><p id="b748" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">为了保证 pgloader 的稳定、可靠和最佳工作，在迁移之前、期间和之后监控源和目标数据库是至关重要的。DB 的机器应该足够强大，并且它们需要足够的资源来执行 pgloader 密集型活动。源和目标 DBs 机器都不应该被繁重的活动或密集的 CPU 操作或高读或(和)写负载。</p><p id="0f44" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意:源或目标数据库机器上的任何负载或繁重活动都会直接影响数据库迁移的性能和成功。</p><p id="ffe9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，在迁移过程中监控迁移机器的 CPU、IOPs、内存和网络也很重要。</p><h1 id="ea2e" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">17.分割对源数据库、目标数据库和迁移机器的重要性。</h1><p id="f62f" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">将源数据库实例、目标数据库实例和迁移机器分开很重要。组合这些组件将影响数据库迁移的性能和稳定性。</p><h1 id="6267" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">18.在迁移过程中，可以查询目标 PostgreSQL 数据库吗？通过“动态”查询复制的表，我们会看到数据库迁移的进度吗？</h1><p id="20fd" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">虽然我们可以在迁移过程中看到目标 PostgreSQL 数据库上的实时会话，但实际数据只是在迁移结束时才提交。</p><p id="25d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 pgloader 运行过程中查询任何填充的表都是无用的:它们的数据被放在脏的、尚未提交的块上。只有当 pgloader 完成后，我们才能看到查询“select * from”的目标数据库上的实际记录</p></div></div>    
</body>
</html>