<html>
<head>
<title>Power Couple Spring Boot And Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Boot 和爪哇的电力耦合</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/power-couple-spring-boot-and-java-74c556b32334?source=collection_archive---------9-----------------------#2020-07-25">https://blog.devgenius.io/power-couple-spring-boot-and-java-74c556b32334?source=collection_archive---------9-----------------------#2020-07-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b257ec18b9d793168315ef019d2a879d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MsFqZTTwyOW7y5SeDUwfiQ.jpeg"/></div></div></figure><p id="b276" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在学 Java 之前，我在学校学过 C#。这对我来说既简单又高效。我觉得我可以用它做任何事。</p><p id="f3a9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我大学的最后一年，我们学习了 java，它看起来非常难学，因为 C#看起来更紧凑<em class="kt">(至少对我来说)</em>而且容易学，你不需要做太多。但是我喜欢 Java，我想做得更多。</p><p id="7430" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上了几节 java 课之后，我们的老师给我们展示了抽象类，我记得我们的课堂一片死寂，没有人理解它，我们只是从老师的电脑上复制代码，然后给老师<em class="kt">看，“是的，我们成功了，它成功了。”</em>但是不，我们没有这样做，然后我想<em class="kt">“我永远不会用这个垃圾，谁在乎我可以不用它写代码。”是的，我是个哑巴…</em></p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="a33f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在专业领域，每个应用程序都很大，不管它是什么，因为在学校，他们向我们展示了编码世界的一小部分，没有足够的时间来展示它的一半。</p><p id="0a5b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">大型应用程序更加复杂，因此你需要使用一个好的逻辑来提高效率。有大量的策略和模式可以使用。你用得越多，你就会本能地自动去做。你在<a class="ae lb" href="https://www.javatpoint.com/design-patterns-in-java" rel="noopener ugc nofollow" target="_blank">这里</a>看设计模式。我不会解释策略或设计模式。</p><p id="95df" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我将向您展示当我必须用 2 个不同的函数类型执行 2 个不同的类类型时我在做什么，我不会使用<em class="kt"> if-else </em>或<em class="kt"> switch-case。</em>挺野的吧？</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="2c75" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们有一个对象，它有 4 种不同的类型<em class="kt">“A-first function，A-SecondFunction，B-FirstFunction 和 B-SecondFunction”。</em>当 A-FirstFunction 出现时，我想触发 ClassA.firstFunction()，但 B-SecondFunction 出现时，我想触发 ClassB.secondFunction()，通常你可以这样做，只需放置 if else 并通过的<em class="kt">instance 检查对象，就完成了。但是有更有效的方法可以做到这一点。</em></p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="92a6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我告诉过你我永远不会使用抽象类，对吗？嗯……在公司和更大的项目中工作，抽象类成了我每天使用的东西。它非常好用，让我的工作变得更加容易。</p><blockquote class="lc ld le"><p id="c9bb" class="jv jw kt jx b jy jz ka kb kc kd ke kf lf kh ki kj lg kl km kn lh kp kq kr ks ig bi translated">当你认为你永远不会使用某样东西，因为它很难或很难学的时候，你应该更加注意这一点。因为学难的东西会让你的生活更轻松。</p></blockquote><p id="1ab1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以说够了…</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="c266" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我们需要创建 ClassA 和 ClassB。它们都有两个函数，所以我要创建一个抽象类，并把它作为父类。</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="f0cf" class="lr ls in ln b gy lt lu l lv lw">public abstract class AbstractClass {<br/><br/>    private Map&lt;String, Function&lt;String, String&gt;&gt; functionalMap = new HashMap&lt;&gt;();<br/><br/>public AbstractClass() {<br/>    this.functionalMap.put("first", firstFunction());<br/>    this.functionalMap.put("second", secondFunction());<br/>  }<br/><br/>protected abstract Function&lt;String, String&gt; firstFunction();<br/><br/>protected abstract Function&lt;String, String&gt; secondFunction();<br/><br/>public Map&lt;String, Function&lt;String, String&gt;&gt; getFunctionalMap() {<br/>    return functionalMap;<br/>  }<br/>}</span></pre><p id="a1bc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个抽象类中，我们有两个函数。我使用 java <a class="ae lb" href="https://www.baeldung.com/java-8-functional-interfaces" rel="noopener ugc nofollow" target="_blank">函数接口</a>，用它我可以创建一个值可以被函数化的映射。你想通了，对吗？</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="50e7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后我们创建另外两个类；a 类和 b 类。</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="2a4c" class="lr ls in ln b gy lt lu l lv lw">@Service("A")<br/>public class ClassA extends AbstractClass {<br/><br/>    @Override<br/>    protected Function&lt;String, String&gt; firstFunction() {<br/>        return "Class A:First "::concat;<br/>    }<br/><br/>    @Override<br/>    protected Function&lt;String, String&gt; secondFunction() {<br/>        return "Class A:First "::concat;<br/>    }<br/>}</span><span id="b4da" class="lr ls in ln b gy lx lu l lv lw">@Service("B")<br/>public class ClassB extends AbstractClass {<br/><br/>    @Override<br/>    protected Function&lt;String, String&gt; firstFunction() {<br/>        return "Class B:First "::concat;<br/>    }<br/><br/>    @Override<br/>    protected Function&lt;String, String&gt; secondFunction() {<br/>        return "Class B:Second "::concat;<br/>    }<br/>}</span></pre><p id="b18e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用 spring boot，我将它们创建为一个 bean，并给它们起了一个名字，它们在函数中使用了自己独特的进程。</p><p id="8ff2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">非常经典的编码，对吗？但是魔法从这里开始…</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="0202" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通常当你想启动 ClassA.firstFunction()时，你只需要这样做；</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="7ceb" class="lr ls in ln b gy lt lu l lv lw">@Autowired<br/>private ClassA classA;<br/>...<br/>classA.firstFunction().apply("value");<br/>...</span></pre><p id="2df1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是不，我们不会用那个。这就是为什么 Spring Boot 和爪哇是一对强有力的夫妇。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="4e85" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们用 AbstractClass 和 spring boot 的魔法扩展了我们的类，我将把子类放到地图中，并按名称调用它们。</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="d830" class="lr ls in ln b gy lt lu l lv lw">@Component<br/>public class Executor {<br/><br/>    private final Map&lt;String, AbstractClass&gt; abstractClassMap;<br/><br/>    public Executor(Map&lt;String, AbstractClass&gt; abstractClassMap) {<br/>        this.abstractClassMap = abstractClassMap;<br/>    }<br/><br/>    ...<br/>}</span></pre><p id="e985" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过这样做<em class="kt">(或自动布线)</em> spring 为我们做了所有的工作。Spring 按名称将 AbstractClass 的孩子放入映射中，您可以在@Service("name ")中按指定的名称获取他们。所以如果你想得到 A 级，你可以像这样。</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="28cd" class="lr ls in ln b gy lt lu l lv lw">AbstractClass aClass = abstractClassMap.get("A");</span></pre><p id="9486" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这样你就可以得到并执行你的函数。但是这还没有完成…</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="d4da" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在 AbsctractClass 中，我们有一个映射，我放置了一些函数，因为我不想像<em class="kt">a class . first class()那样执行它们。【值】</em>应用。</p><p id="60ad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我可以用这个来处决他们。<em class="kt">“getFunctionalMap()。get(“第一”)。</em>【值】【应用】</p><p id="2d9a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以我们需要做的就是在 executor 类中放入最后一个函数；</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="ce01" class="lr ls in ln b gy lt lu l lv lw">...<br/>public String init(String className, String functionName, String value) {<br/>    return abstractClassMap.get(className).getFunctionalMap().get(functionName).apply(value);<br/>}<br/>...</span></pre><p id="15a4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个函数中，您可以使用要处理的值执行给定的类名和给定的函数名。</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="2ff1" class="lr ls in ln b gy lt lu l lv lw">Executor executor = run.getBean(Executor.class);<br/>System.<em class="kt">out</em>.println(executor.init("A","second","value"));</span></pre><p id="5d31" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有了这一行代码，你可以调用无限的类和函数。我使用这种技术的次数比任何东西都多<em class="kt">(当然如果我需要的话)</em>。</p></div></div>    
</body>
</html>