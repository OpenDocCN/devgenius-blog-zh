<html>
<head>
<title>Basic C++. Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基本 C++。第二部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/basic-c-part-2-ce60f7b89216?source=collection_archive---------18-----------------------#2022-11-27">https://blog.devgenius.io/basic-c-part-2-ce60f7b89216?source=collection_archive---------18-----------------------#2022-11-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/bcaaae7bb41560c7a6cdbe237a92e8ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MP30x6315quq0LzJ.png"/></div></div></figure><p id="19eb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在第 1 部分中，我们讨论了数据类型、初始化变量的方法、数组、指针和引用。由于从版本 17 开始增加了编写程序的新特性，一些例子也在 C++17 和更高版本中展示和给出。</p><p id="af0f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这一次，我们将学习如何在 C++中建立条件和循环。将提供一些新版本的例子。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="3fa8" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">情况</h1><p id="b608" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated"><strong class="jx io"> If 语句</strong></p><p id="8cb7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">C++支持数学中常见的逻辑条件:</p><ul class=""><li id="cd17" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated">小于:<code class="fe mn mo mp mq b">num1 &lt; num2</code></li><li id="6847" class="me mf in jx b jy mr kc ms kg mt kk mu ko mv ks mj mk ml mm bi translated">小于或等于:<code class="fe mn mo mp mq b">num1 &lt;= num2</code></li><li id="7f49" class="me mf in jx b jy mr kc ms kg mt kk mu ko mv ks mj mk ml mm bi translated">大于:<code class="fe mn mo mp mq b">num1 &gt;num2</code></li><li id="bfa7" class="me mf in jx b jy mr kc ms kg mt kk mu ko mv ks mj mk ml mm bi translated">大于或等于:<code class="fe mn mo mp mq b">num1 &gt;=num2</code></li><li id="d9f2" class="me mf in jx b jy mr kc ms kg mt kk mu ko mv ks mj mk ml mm bi translated">等于:<code class="fe mn mo mp mq b">num1 == num2</code></li><li id="17fb" class="me mf in jx b jy mr kc ms kg mt kk mu ko mv ks mj mk ml mm bi translated">不等于:<code class="fe mn mo mp mq b">num1 != num2</code></li></ul><p id="bc2f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">if 语句根据给定的条件选择并执行语句。如果条件评估为<strong class="jx io">真</strong>，则执行给定的一组语句。示例:</p><pre class="mw mx my mz gt na mq nb bn nc nd bi"><span id="0288" class="ne lc in mq b be nf ng l nh ni">if(condition) {<br/>  action1;<br/>  action2;<br/>  .....<br/>}</span></pre><p id="d59f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另一方面，如果在该示例中条件为假，则跳过该条件并执行另一动作。示例:</p><pre class="mw mx my mz gt na mq nb bn nc nd bi"><span id="37b0" class="ne lc in mq b be nf ng l nh ni">if(condition) {  // this one is false<br/>  action1;<br/>  ....<br/>}<br/>action3; // this line will be runned</span></pre><p id="7974" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> If-else 语句</strong></p><p id="b772" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">除了 C++中的 if 语句，还可以添加<code class="fe mn mo mp mq b">else</code>子句。示例:</p><pre class="mw mx my mz gt na mq nb bn nc nd bi"><span id="9b7d" class="ne lc in mq b be nf ng l nh ni">if(condition) {<br/>  action1;<br/>  ...<br/>} else {<br/>  action3;<br/>  ...<br/>}</span></pre><p id="6322" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种语句的工作方式是，如果条件为真，那么 if 中的操作将被执行，否则将被跳过，反之亦然。</p><p id="3a6c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">如果-否则如果-否则</strong></p><p id="43ff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe mn mo mp mq b">if...else</code>语句用于在两个选项中执行一个代码块。然而，如果我们需要在两个以上的选项中做出选择，我们使用<code class="fe mn mo mp mq b">if...else if...else</code>语句。示例:</p><pre class="mw mx my mz gt na mq nb bn nc nd bi"><span id="611f" class="ne lc in mq b be nf ng l nh ni">if(condition1) {<br/>  action1;<br/>  ...<br/>} else if(condition2) {<br/>  action2;<br/>  ...<br/>} else {<br/>  action3;<br/>  ...<br/>}</span></pre><p id="c47c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本例中，将执行条件为真的操作。</p><p id="ce15" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在 C++中，可以使用嵌套条件。例如:</p><pre class="mw mx my mz gt na mq nb bn nc nd bi"><span id="05bd" class="ne lc in mq b be nf ng l nh ni">// example1<br/>if(condition1) {<br/>  ....<br/>  if(condition2) {<br/>    ....<br/>  }<br/>}<br/>// example2<br/>if(condition1) {<br/>  if(condition2) {<br/>    action1;<br/>    ...<br/>  } else {<br/>    action2;<br/>    ...<br/>  }<br/>}</span></pre><p id="1ff8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">如果带初始化</strong></p><p id="c16b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">注:</strong>从 C++版本 17 开始，我们可以创建带有初始化的 if 语句。语法如下所示:</p><pre class="mw mx my mz gt na mq nb bn nc nd bi"><span id="51f5" class="ne lc in mq b be nf ng l nh ni">if(initialiation; condition) {<br/>  action1;<br/>} else {<br/>  action2;<br/>}</span></pre><p id="1289" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">示例:</p><pre class="mw mx my mz gt na mq nb bn nc nd bi"><span id="f5f8" class="ne lc in mq b be nf ng l nh ni">if(auto rnd = rand(); rnd % 2 == 0) {<br/>  std::cout &lt;&lt; "Even\n";<br/>} else {<br/>  std::cout &lt;&lt; "Odd\n";<br/>}</span></pre><p id="29b0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> Constexpr if </strong></p><p id="f4db" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从 C++17 开始，您可以在函数模板中使用<code class="fe mn mo mp mq b">if constexpr</code>语句来进行编译时分支决策，而不必求助于微软文档中的多个函数重载<a class="ae kt" href="https://learn.microsoft.com/en-us/cpp/cpp/if-else-statement-cpp?view=msvc-170" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="9e0f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">语法:</p><pre class="mw mx my mz gt na mq nb bn nc nd bi"><span id="cb25" class="ne lc in mq b be nf ng l nh ni">if constexpr(condition) {<br/>  ...<br/>}</span></pre><p id="560e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">示例:</p><pre class="mw mx my mz gt na mq nb bn nc nd bi"><span id="1236" class="ne lc in mq b be nf ng l nh ni">constexpr auto num = 10;<br/>if constexpr(num == 10) {<br/>  std::cout &lt;&lt; "true";<br/>} else {<br/>  std::cout &lt;&lt; "false";<br/>}</span></pre><p id="325d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> Consteval if (C++23) </strong></p><p id="d2c0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">根据<a class="ae kt" href="https://en.cppreference.com/w/cpp/language/if" rel="noopener ugc nofollow" target="_blank"> C++文档</a>的记载:</p><blockquote class="nj nk nl"><p id="c52f" class="jv jw nm jx b jy jz ka kb kc kd ke kf nn kh ki kj no kl km kn np kp kq kr ks ig bi translated"><em class="in">在 consteval if 语句中，</em> <em class="in"> c </em>复合语句<em class="in">和</em>语句<em class="in">(如果有)</em> <em class="in">都必须是复合语句。</em></p><p id="a558" class="jv jw nm jx b jy jz ka kb kc kd ke kf nn kh ki kj no kl km kn np kp kq kr ks ig bi translated"><em class="in">如果</em> <em class="in">语句</em>不是复合语句，<em class="in">它仍将被视为 consteval if 语句的一部分(从而导致编译错误)</em></p></blockquote><p id="48dd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这样的条目会出现在<a class="ae kt" href="https://en.cppreference.com/w/cpp/23" rel="noopener ugc nofollow" target="_blank"> C++23 </a>中。在 C++23 之前，有一个函数<code class="fe mn mo mp mq b">std::is_constant_evaluated()</code>作为编译器内嵌的，结果是<a class="ae kt" href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1938r3.html" rel="noopener ugc nofollow" target="_blank">错误</a>。正如在提案的文章中所写的，这个函数有两个问题:</p><ol class=""><li id="6aa1" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks nq mk ml mm bi translated"><a class="ae kt" href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1938r3.html#interaction-between-constexpr-and-consteval" rel="noopener ugc nofollow" target="_blank"> constexpr 和 consteval </a>之间的交互；</li><li id="76df" class="me mf in jx b jy mr kc ms kg mt kk mu ko mv ks nq mk ml mm bi translated">与写表达式直接相关的一个问题<a class="ae kt" href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1938r3.html#the-if-constexpr-stdis_constant_evaluated-problem" rel="noopener ugc nofollow" target="_blank">。</a></li></ol></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="84fd" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">环</h1><p id="9733" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">循环用于根据特定条件多次执行特定操作。C++语言有以下类型的循环:</p><ul class=""><li id="1efb" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated">for 循环</li><li id="8be6" class="me mf in jx b jy mr kc ms kg mt kk mu ko mv ks mj mk ml mm bi translated">在…期间</li><li id="9a64" class="me mf in jx b jy mr kc ms kg mt kk mu ko mv ks mj mk ml mm bi translated">做一会儿</li></ul><p id="9a61" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> While 循环</strong></p><p id="77e6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">while 循环在其条件为真时执行一些代码，即返回 true。它有以下正式定义:</p><pre class="mw mx my mz gt na mq nb bn nc nd bi"><span id="5882" class="ne lc in mq b be nf ng l nh ni">while(condition) {<br/>  some_action;<br/>}</span></pre><p id="5d81" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在 while 关键字之后，括号中是一个条件表达式，表示<strong class="jx io">返回 true </strong>或<strong class="jx io"> false </strong>。然后，在花括号中，有一组<strong class="jx io">语句</strong>组成了循环体。并且<strong class="jx io">当条件返回真</strong>时，循环<strong class="jx io">的主体</strong>中的<strong class="jx io">语句将被执行</strong>。</p><p id="1b50" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如:</p><pre class="mw mx my mz gt na mq nb bn nc nd bi"><span id="4a5f" class="ne lc in mq b be nf ng l nh ni">int i = 1;<br/>while(i &lt; 10) {<br/>  std::cout &lt;&lt; i * i &lt;&lt; "\n";<br/>  i++;<br/>}</span></pre><p id="9f6d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">而条件 i &lt; 10 is true, the while loop will be executed, in which the square of the number is calculated and the variable i is incremented. At some point, the variable i will increase to 10, the condition i &lt; 10 will return false, and the loop will end.</p><p id="e58a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">为循环</strong></p><p id="6b61" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">for 循环有以下正式定义:</p><pre class="mw mx my mz gt na mq nb bn nc nd bi"><span id="cbea" class="ne lc in mq b be nf ng l nh ni">for(expression_1; expression_2; expression_3) {<br/>  some_action;<br/>}</span></pre><p id="5f41" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">expression_1 在循环执行开始时执行一次，表示初始条件的设置，通常，这是计数器的初始化—用于控制循环的特殊变量。</p><p id="2594" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">expression_2 表示执行循环的条件。作为一个规则，比较操作被用作一个条件，如果它返回一个非零值(即条件为真)，则执行循环体，然后计算 expression_3。</p><p id="37c4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">expression_3 指定了循环参数的变化，通常这里循环计数器增加 1。</p><p id="340e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如:</p><pre class="mw mx my mz gt na mq nb bn nc nd bi"><span id="71cb" class="ne lc in mq b be nf ng l nh ni">for(int i = 0; i &lt; 10; i++) {<br/>  std::cout &lt;&lt; i * i &lt;&lt; "\n";<br/>}</span></pre><p id="1b35" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">循环的范围(自 C++11 开始)</strong></p><p id="5512" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从关于<a class="ae kt" href="https://en.cppreference.com/w/cpp/language/range-for" rel="noopener ugc nofollow" target="_blank">基于范围的环路</a>的文档中:</p><blockquote class="nj nk nl"><p id="b202" class="jv jw nm jx b jy jz ka kb kc kd ke kf nn kh ki kj no kl km kn np kp kq kr ks ig bi translated">在一定范围内执行 for 循环。</p><p id="0958" class="jv jw nm jx b jy jz ka kb kc kd ke kf nn kh ki kj no kl km kn np kp kq kr ks ig bi translated">作为传统的<a class="ae kt" href="https://en.cppreference.com/w/cpp/language/for" rel="noopener ugc nofollow" target="_blank">的等效物，用于循环</a>在一个值范围内的操作，比如一个容器中的所有元素。</p></blockquote><p id="a315" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正式定义:</p><pre class="mw mx my mz gt na mq nb bn nc nd bi"><span id="9c0a" class="ne lc in mq b be nf ng l nh ni">for(value : expression) {<br/>    loop_statement;<br/>}</span></pre><p id="8e3d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如:</p><pre class="mw mx my mz gt na mq nb bn nc nd bi"><span id="6173" class="ne lc in mq b be nf ng l nh ni">int a[] = {1, 2, 3, 4, 5};<br/>for(auto&amp; i : a) {<br/>  std::cout &lt;&lt; i &lt;&lt; " ";<br/>}</span></pre><p id="1233" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从 C++17 开始，可以为地图编写范围循环(关于地图和 STL 库，我们将在另一个话题中讨论)。</p><p id="7030" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如:</p><pre class="mw mx my mz gt na mq nb bn nc nd bi"><span id="70ff" class="ne lc in mq b be nf ng l nh ni">for (auto&amp;&amp; [first, second] : some_map) {<br/>  some_action;<br/>}</span></pre><p id="ae9b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> For each (STL &lt;算法&gt;库)</strong></p><p id="6935" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">STL 库和与之相关的一切，我们稍后会考虑，因为这是一个非常大而复杂的主题，涉及很多东西。</p><p id="c8cf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">注:</strong>这个话题和下面将要讨论的一切，我以后会告诉你，但我决定写一下，让你对使用现代 C++编写复杂的东西有一个大致的了解。</p><p id="4328" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">C++中的<a class="ae kt" href="https://en.cppreference.com/w/cpp/algorithm/for_each" rel="noopener ugc nofollow" target="_blank"> for_each </a>是一种遍历数组和类数组结构的算法。</p><p id="2e0a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">for_each 有三个参数:要遍历的数据集的开始和结束，以及执行被遍历元素的主要处理的函数指针或 lambda 表达式或仿函数<strong class="jx io">(关于这一点我们将在稍后详细讨论)</strong>。</p><p id="b114" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以设置数组的边界，要么使用普通的指针，使用指针算法，要么使用迭代器，如果在被绕过的结构中有迭代器的话。例如，常规数组[]不假设迭代器，所以你需要为它们使用指针，而来自 std 名称空间的数组数组(可插拔的<a class="ae kt" href="https://en.cppreference.com/w/cpp/container/array" rel="noopener ugc nofollow" target="_blank">包括&lt;数组&gt; </a>)存储迭代器，因此迭代器对它们更好。关于迭代器我们下次会讨论。</p><p id="1bc4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如:</p><pre class="mw mx my mz gt na mq nb bn nc nd bi"><span id="2fce" class="ne lc in mq b be nf ng l nh ni">#include &lt;algorithm&gt;<br/>#include &lt;iostream&gt;<br/><br/>void show(int element) { // &lt;- this function<br/>  std::cout &lt;&lt; element &lt;&lt; " ";<br/>}<br/><br/>int main() {<br/>  int array[] = {1, 2, 3, 4, 5}; // &lt;- regular array<br/>  int length_array = sizeof(array) / sizeof(array[0]); // getting size of array<br/>  std::for_each(array, array + length_array, show); // algorithm<br/>}</span></pre><p id="2c97" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">注意:</strong>在这个例子中，数组中元素的数量没有被显式地设置，但是 C++数组，根据定义，总是有固定的容量，所以在初始化期间，一定数量的单元被分配给数组，由于我没有显式地指定单元的数量，所以我使用一个公式来计算它们的数量。</p><p id="67a6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下一个例子展示了如何使用迭代器</p><pre class="mw mx my mz gt na mq nb bn nc nd bi"><span id="6446" class="ne lc in mq b be nf ng l nh ni">#include &lt;algorithm&gt;<br/>#include &lt;iostream&gt;<br/>#include &lt;vector&gt;<br/><br/>void show(int element) { // &lt;- this function<br/>  std::cout &lt;&lt; element &lt;&lt; " ";<br/>}<br/><br/>int main() {<br/>  std::vector&lt;int&gt; array = {1, 2, 3, 4, 5};<br/>  std::for_each(array.begin(), array.end(), show); // algorithm, specifying boundaries through iterators<br/>}</span></pre><p id="0530" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">注意:</strong>虽然数组[]不假设迭代器的存在，但是它们的迭代器可以使用 std::begin 和 std::end 函数。这比使用 length 要好，但是这只对数组有效，对作为数组的指针无效。</p><p id="06af" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如</p><pre class="mw mx my mz gt na mq nb bn nc nd bi"><span id="0137" class="ne lc in mq b be nf ng l nh ni">#include &lt;algorithm&gt;<br/>#include &lt;iostream&gt;<br/><br/>void show(int element) { // &lt;- this function<br/>  std::cout &lt;&lt; element &lt;&lt; " ";<br/>}<br/><br/>int main() {<br/>  int array[] = {1, 2, 3, 4, 5}; // &lt;- regular array<br/>  std::for_each(std::begin(array), std::end(array), show); // algorithm<br/>}</span></pre><p id="be13" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">算法很方便，因为您可以将不同的函数代入其中，绕过相同的数据集，同时保持代码外观的优雅。for_each 不仅允许您绕过，还允许您执行任何元素处理。如果我们写一个改变数据的函数，那么数组中的值也会改变。</p><p id="b566" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">边做边</strong></p><p id="f67f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在 do 循环中，首先执行循环代码，然后检查 while 语句中的条件。并且当该条件为真时，即不等于 0，则循环重复。循环的正式定义:</p><pre class="mw mx my mz gt na mq nb bn nc nd bi"><span id="3902" class="ne lc in mq b be nf ng l nh ni">do {<br/>  some_action;<br/>} while(condition);</span></pre><p id="be4a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如:</p><pre class="mw mx my mz gt na mq nb bn nc nd bi"><span id="d1dd" class="ne lc in mq b be nf ng l nh ni">int i = 0;<br/>do {<br/>  std::cout &lt;&lt; i * i &lt;&lt; "\n";<br/>  i++;<br/>} while (i &lt; 10);</span></pre><p id="47af" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">注意:</strong>你会经常看到处理循环计数器的不同方式:递减或递增。对于初学编程的人来说，i++和++ I(I--和--I)之间的区别问题总是会出现。</p><p id="7419" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">摘自<a class="ae kt" href="https://zhjwpku.com/assets/pdf/books/C++.Primer.Plus.6th.Edition.Oct.2011.pdf" rel="noopener ugc nofollow" target="_blank">斯蒂芬·普拉塔著</a>:</p><blockquote class="nj nk nl"><p id="d57c" class="jv jw nm jx b jy jz ka kb kc kd ke kf nn kh ki kj no kl km kn np kp kq kr ks ig bi translated">前缀版本在操作数之前，如<code class="fe mn mo mp mq b">++x</code>。后缀版本在操作数之后，如在<code class="fe mn mo mp mq b">x++</code>中。这两个版本对操作数有相同的影响，但它们发生的时间不同。</p><p id="83f6" class="jv jw nm jx b jy jz ka kb kc kd ke kf nn kh ki kj no kl km kn np kp kq kr ks ig bi translated">符号<code class="fe mn mo mp mq b">a++</code>表示“在计算表达式时使用 a 的当前值，然后增加 a 的值。”类似地，符号<code class="fe mn mo mp mq b">++b</code>表示“首先增加 b 的值，然后在计算表达式时使用新值。”</p><p id="7655" class="jv jw nm jx b jy jz ka kb kc kd ke kf nn kh ki kj no kl km kn np kp kq kr ks ig bi translated">对于内置类型，使用哪种形式几乎没有区别。对于具有用户定义的递增和递减运算符的用户定义类型，前缀形式更有效。</p></blockquote><p id="5477" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">继续并中断循环</strong></p><p id="3aa4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有时有必要在循环完成前退出。在这种情况下，可以使用 break 语句。例如:</p><pre class="mw mx my mz gt na mq nb bn nc nd bi"><span id="8b20" class="ne lc in mq b be nf ng l nh ni">for(int i = 0; i &lt; 8; i++) {<br/>  if(i == 5) {<br/>    break;<br/>  }<br/>}</span></pre><p id="0f69" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当<code class="fe mn mo mp mq b">i</code>等于 5 时，这个例子跳出循环。</p><p id="89b0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">与 break 语句不同，continue 语句跳转到下一个迭代。例如，我们只需要计算某个范围内奇数的和:</p><pre class="mw mx my mz gt na mq nb bn nc nd bi"><span id="dc58" class="ne lc in mq b be nf ng l nh ni">int result = 0;<br/>for (int i=0; i&lt;10; i++) {<br/>    if (i % 2 == 0) continue;<br/>    result +=i;<br/>}</span></pre><p id="a118" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了确定数字是否是偶数，我们得到整数除以 2 的余数，如果是 0，那么使用 continue 语句进入循环的下一次迭代。如果这个数是奇数，那么把它加到其余的奇数上。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="e0c5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">希望你喜欢这篇文章，尤其是 C++编程的新手可以从这篇文章中受益。在下一篇文章中，我将解释函数。</p></div></div>    
</body>
</html>