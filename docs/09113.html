<html>
<head>
<title>Python Up Your Code: Generators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python Up 您的代码:生成器</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/python-up-your-code-generators-c9018820ca98?source=collection_archive---------6-----------------------#2022-07-30">https://blog.devgenius.io/python-up-your-code-generators-c9018820ca98?source=collection_archive---------6-----------------------#2022-07-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="29d5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Python 中的生成器代表什么，它们的用法和最佳实践</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/55b8fc9dd6a97c63d9cbb0c0c532d49e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zjvSSxtFBuDQkQVRHxwMng.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Jr Korpa 在<a class="ae kv" href="https://unsplash.com/s/photos/digital-abstract?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="6ee8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为自然的下一步，正如我们稍后将看到的，在上一篇<a class="ae kv" href="https://medium.com/@deck451/python-up-your-code-iterators-af5331f68ccd" rel="noopener">文章中我们发现并讨论了迭代器的主题，今天我们将讨论另一个与 Python 相关的非常重要的主题:生成器。</a></p><p id="2bf2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经看到用 Python 构建迭代器并不是最简单的事情。我们看到了我们如何需要创建和使用一个实现了<code class="fe ls lt lu lv b">__iter__()</code>和<code class="fe ls lt lu lv b">__next__()</code>方法的类，此外，我们还必须密切关注元素耗尽的情况，并引发一个<code class="fe ls lt lu lv b">StopIteration</code>异常作为直接后果。</p><p id="81a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们指出，通过这些生成器，所有这些功能都可以用我们这边更少的努力来实现。我想我描述生成器的最简单的方式是:一个返回生成器对象的函数，我们可以在迭代过程中使用它。</p><p id="d39a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，生成器只不过是一个函数，创建它相当容易。但是它确实使用了<code class="fe ls lt lu lv b">yield</code>语句，与常规函数相反，常规函数通常使用<code class="fe ls lt lu lv b">return</code>语句。</p><p id="1beb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就返回值而言，<code class="fe ls lt lu lv b">yield</code>和<code class="fe ls lt lu lv b">return</code>的作用相同。它们返回值。不同之处在于这两者对函数执行流程的影响:</p><ul class=""><li id="67b8" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated"><code class="fe ls lt lu lv b">return</code>终止函数的执行；</li><li id="251d" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated"><code class="fe ls lt lu lv b">yield</code>相当于音乐播放器上的<strong class="ky ir">暂停</strong>按钮。它维护函数的状态，以便以后再次调用时可以从该点恢复。</li></ul><p id="5e43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">生成器函数与常规函数有一些基本区别:</p><ul class=""><li id="cf04" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated">生成器函数包含一个或多个<code class="fe ls lt lu lv b">yield</code>语句。常规函数不包含这样的语句。如果有，它将立即成为一个生成器函数；</li><li id="b825" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">作为一个生成器函数，它返回一个生成器对象。但是，调用该函数不会开始执行。我们可以使用<code class="fe ls lt lu lv b">next()</code>函数或<code class="fe ls lt lu lv b">for</code> / <code class="fe ls lt lu lv b">while</code>循环对其进行迭代，然后生成器函数才开始执行；</li><li id="e6ba" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">像<code class="fe ls lt lu lv b">__iter__()</code>和<code class="fe ls lt lu lv b">__next__()</code>这样的方法是自动实现的。因此，我们可以使用<code class="fe ls lt lu lv b">next()</code>遍历元素；</li><li id="6fe1" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">如前所述，<code class="fe ls lt lu lv b">yield</code>只是暂停函数，控制转移到调用块；这意味着局部变量及其值在连续调用之间得到维护；</li><li id="d537" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">当函数终止时，<code class="fe ls lt lu lv b">StopIteration</code>会在进一步调用时自动引发。这也意味着迭代器只能迭代一次。要重启这个过程，我们需要创建另一个生成器对象；</li></ul><p id="fa54" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们举例说明所有这些特征:</p><pre class="kg kh ki kj gt mk lv ml mm aw mn bi"><span id="ab90" class="mo mp iq lv b gy mq mr l ms mt"><em class="mu"># define a generator function to generate 1 number<br/></em><strong class="lv ir">def</strong> my_generator():<br/>    <strong class="lv ir">print</strong>("Generator function running")<br/>    n = 1<br/>    <strong class="lv ir">yield</strong> n</span><span id="6f28" class="mo mp iq lv b gy mv mr l ms mt"><em class="mu"><br/># run the function to return a generator object<br/></em>my_gen = my_generator()<br/><strong class="lv ir">print</strong>(f"{<strong class="lv ir">type</strong>(my_gen)}: {my_gen}")</span><span id="a30a" class="mo mp iq lv b gy mv mr l ms mt"><em class="mu"><br/># only when we iterate over it,<br/># does the generator function execute<br/># ask for two values, but generator can only give 1</em><strong class="lv ir"><br/>print</strong>(<strong class="lv ir">next</strong>(my_gen))<br/><strong class="lv ir">print</strong>(<strong class="lv ir">next</strong>(my_gen))</span><span id="ff14" class="mo mp iq lv b gy mv mr l ms mt">Output:<br/>&lt;class 'generator'&gt;: &lt;generator object my_generator at 0x7fbed6d56490&gt;<br/>Generator function running<br/>1<br/>Traceback (most recent call last):<br/>  ...<br/>    print(next(my_gen))<br/>StopIteration</span></pre><p id="2f74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如我们所见，在这种情况下，生成器函数只包含一个<code class="fe ls lt lu lv b">yield</code>语句。</p><p id="deab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还看到，通过使用<code class="fe ls lt lu lv b">next()</code>函数，我们可以对生成器函数返回的迭代器进行迭代。这意味着迭代器协议方法(<code class="fe ls lt lu lv b">__iter__()</code>和<code class="fe ls lt lu lv b">__next__()</code>)都已经实现；</p><p id="7a92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出行非常清楚地表明，在被我们对<code class="fe ls lt lu lv b">next()</code>函数的两次调用触发之前，生成器函数不会开始实际执行。另外，注意对<code class="fe ls lt lu lv b">next()</code>的第二次调用是如何触发<code class="fe ls lt lu lv b">StopIteration</code>异常的。</p><p id="7ff7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们举一个更现实的例子。如果生成器只生成一个值，就没什么用了:</p><pre class="kg kh ki kj gt mk lv ml mm aw mn bi"><span id="a9d4" class="mo mp iq lv b gy mq mr l ms mt"><em class="mu"># define a generator function<br/></em><strong class="lv ir">def</strong> my_generator():<br/>    <strong class="lv ir">print</strong>("Generator function called")<br/>    <strong class="lv ir">for</strong> element <strong class="lv ir">in</strong> <strong class="lv ir">range</strong>(10):<br/>        <strong class="lv ir">yield</strong> element</span><span id="84cb" class="mo mp iq lv b gy mv mr l ms mt"><em class="mu"><br/># run the function to return a generator object<br/></em>my_gen = my_generator()</span><span id="550a" class="mo mp iq lv b gy mv mr l ms mt"><em class="mu"># use the generator object</em><br/><strong class="lv ir">for</strong> number <strong class="lv ir">in</strong> my_gen:<br/>    <strong class="lv ir">print</strong>(number)</span><span id="5382" class="mo mp iq lv b gy mv mr l ms mt">Output:<br/>0<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7<br/>8<br/>9</span></pre><p id="8c49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">生成器的另一个非常有趣的特性是，我们不仅可以从它们那里获取数据，还可以向它们提供数据，潜在地动态定制它们的行为。这里有一个简单的使用案例。假设我们需要一个生成器函数来返回一个数字的三倍值:</p><pre class="kg kh ki kj gt mk lv ml mm aw mn bi"><span id="c63e" class="mo mp iq lv b gy mq mr l ms mt"><em class="mu"># define a generator function</em><strong class="lv ir"><br/>def</strong> my_generator():<br/>    <strong class="lv ir">while</strong> <strong class="lv ir">True</strong>:<br/>        <em class="mu"># get the value</em><br/>        value = <strong class="lv ir">yield</strong></span><span id="3938" class="mo mp iq lv b gy mv mr l ms mt"><em class="mu">        # triple it and return it</em><strong class="lv ir"><br/>        yield</strong> value * 3</span><span id="9cbe" class="mo mp iq lv b gy mv mr l ms mt"><em class="mu"><br/># now use the generator</em><br/>my_gen = my_generator()</span><span id="156d" class="mo mp iq lv b gy mv mr l ms mt"><strong class="lv ir">for</strong> number <strong class="lv ir">in</strong> <strong class="lv ir">range</strong>(10):<br/>    <strong class="lv ir">next</strong>(my_gen)<br/>    <strong class="lv ir">print</strong>(my_gen.<strong class="lv ir">send</strong>(number))</span><span id="43b4" class="mo mp iq lv b gy mv mr l ms mt">Output:<br/>0<br/>3<br/>6<br/>9<br/>12<br/>15<br/>18<br/>21<br/>24<br/>27</span></pre><p id="85a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看看我们使用<code class="fe ls lt lu lv b">yield</code>关键字让生成器函数获取我们通过<code class="fe ls lt lu lv b">send()</code>发送给它的值有多容易？这是<code class="fe ls lt lu lv b">yield</code>关键字的另一种用法。可能会有点混乱，因为我们已经习惯了<code class="fe ls lt lu lv b">yield</code> — <code class="fe ls lt lu lv b">return</code>的类比，而<code class="fe ls lt lu lv b">return</code>绝不是一个与输出相关的关键字，然而，值得注意的是，我刚刚介绍的<code class="fe ls lt lu lv b">yield</code>关键字的两种用法都只与生成器相关，所以也有这种情况。</p><p id="6cf7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">官方文档谈到了这个<code class="fe ls lt lu lv b">yield</code> <strong class="ky ir">语句</strong>(也就是通常的<code class="fe ls lt lu lv b">yield some_value</code>)与<code class="fe ls lt lu lv b">yield</code> <strong class="ky ir">表达式</strong>(它表示在赋值的右边使用的<code class="fe ls lt lu lv b">yield</code>关键字)<a class="ae kv" href="https://peps.python.org/pep-0342/#specification-sending-values-into-generators" rel="noopener ugc nofollow" target="_blank">这里是</a>。</p><p id="1220" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另外，请注意，不允许试图在尚未执行到到达<code class="fe ls lt lu lv b">yield</code>语句的点的生成器上立即调用<code class="fe ls lt lu lv b">send()</code>。它会抛出一个<code class="fe ls lt lu lv b">TypeError</code>:</p><pre class="kg kh ki kj gt mk lv ml mm aw mn bi"><span id="52bd" class="mo mp iq lv b gy mq mr l ms mt">Traceback (most recent call last):<br/>  ...<br/>    my_gen.send(123)<br/>TypeError: can't send non-None value to a just-started generator</span></pre><p id="b200" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们深入了解一下<code class="fe ls lt lu lv b">for</code>循环实现了什么，以及它实际上是如何工作的:</p><ol class=""><li id="e93c" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mw mc md me bi translated">对<code class="fe ls lt lu lv b">next()</code>的调用使生成器执行，直到到达第一个<code class="fe ls lt lu lv b">yield</code>语句(对<code class="fe ls lt lu lv b">next()</code>的调用相当于一个<code class="fe ls lt lu lv b">send(None)</code>，所以我们可能没有调用<code class="fe ls lt lu lv b">send(None)</code>而是调用了生成器上的<code class="fe ls lt lu lv b">next()</code>)；</li><li id="6939" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mw mc md me bi translated">此时，生成器正在等待发送给它的某个值；</li><li id="2b8b" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mw mc md me bi translated">我们通过<code class="fe ls lt lu lv b">send()</code>方法发送该值，然后生成器恢复执行，消耗发送的值，然后<code class="fe ls lt lu lv b">yield</code>处理三倍的值，一旦生成新元素就再次暂停执行；</li><li id="0c59" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mw mc md me bi translated">循环重新开始，对<code class="fe ls lt lu lv b">next()</code>的另一个调用将看到发生器再次恢复执行，直到发生器函数的第一个<code class="fe ls lt lu lv b">yield</code>语句，它将耐心等待下一个<code class="fe ls lt lu lv b">send()</code>调用，循环继续进行。</li></ol><p id="e3e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码可以重写为只使用一个<code class="fe ls lt lu lv b">yield</code>表达式，如下所示:</p><pre class="kg kh ki kj gt mk lv ml mm aw mn bi"><span id="7196" class="mo mp iq lv b gy mq mr l ms mt"><em class="mu"># define a generator function</em><strong class="lv ir"><br/>def</strong> my_generator():<br/>    value = -1<br/>    <strong class="lv ir">while</strong> <strong class="lv ir">True</strong>:<br/>        <em class="mu"># get the value and yield its triple</em><br/>        value = <strong class="lv ir">yield </strong>value * 3</span><span id="14fe" class="mo mp iq lv b gy mv mr l ms mt"><em class="mu"><br/># create the generator<br/># start its execution up to the yield statement</em><br/>my_gen = my_generator()<br/><strong class="lv ir">next</strong>(my_gen)</span><span id="1232" class="mo mp iq lv b gy mv mr l ms mt"><strong class="lv ir">for</strong> number <strong class="lv ir">in</strong> <strong class="lv ir">range</strong>(10):<br/>    <strong class="lv ir">print</strong>(my_gen.<strong class="lv ir">send</strong>(number))</span><span id="63ab" class="mo mp iq lv b gy mv mr l ms mt">Output:<br/>0<br/>3<br/>6<br/>9<br/>12<br/>15<br/>18<br/>21<br/>24<br/>27</span></pre><ol class=""><li id="6f7a" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mw mc md me bi translated">首先，我们调用生成器函数。它返回一个生成器对象，我们将把它赋给<code class="fe ls lt lu lv b">my_gen</code>；然后，我们对它调用<code class="fe ls lt lu lv b">next()</code>，生成器函数开始执行，直到它到达<code class="fe ls lt lu lv b">yield</code>表达式；</li><li id="d674" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mw mc md me bi translated">在生成器对象上调用了<code class="fe ls lt lu lv b">send()</code>方法。生成器函数获取这个值，然后继续执行，直到再次到达<code class="fe ls lt lu lv b">yield</code>语句；此时，它返回三倍的值，并再次暂停执行，等待下一个<code class="fe ls lt lu lv b">send()</code>方法。</li></ol><h2 id="b349" class="mo mp iq bd mx my mz dn na nb nc dp nd lf ne nf ng lj nh ni nj ln nk nl nm nn bi translated">生成器表达式</h2><p id="255c" class="pw-post-body-paragraph kw kx iq ky b kz no jr lb lc np ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">如果我们的目标是构建相对简单的生成器，我们甚至不需要单独的生成器函数。我们可以使用生成器表达式。从语法上来说，它看起来非常类似于<a class="ae kv" href="https://medium.com/@deck451/python-up-your-code-list-comprehensions-bc34ac300b48" rel="noopener">列表理解</a>。然而，有两个基本方面将它们区分开来:</p><ol class=""><li id="d0f3" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mw mc md me bi translated">与列表理解不同，列表理解可以通过包围理解的方括号来识别，生成器表达式具有常规(圆)括号或圆括号的特征；</li><li id="14af" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mw mc md me bi translated">列表理解生成整个列表，而生成器表达式一个接一个地生成元素。</li></ol><p id="f85f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们举例说明:</p><pre class="kg kh ki kj gt mk lv ml mm aw mn bi"><span id="352b" class="mo mp iq lv b gy mq mr l ms mt"><em class="mu"># define a list</em><br/>my_list = [0, 1, 2, 3]</span><span id="ed19" class="mo mp iq lv b gy mv mr l ms mt"><em class="mu"># list comprehension: triple the value for each element<br/></em>my_list_comprehension = [i * 3 <strong class="lv ir">for</strong> i <strong class="lv ir">in</strong> my_list]</span><span id="36e6" class="mo mp iq lv b gy mv mr l ms mt"><em class="mu"># generator expression: same functionality<br/></em>my_generator = (i * 3 <strong class="lv ir">for</strong> i <strong class="lv ir">in</strong> my_list)</span><span id="5957" class="mo mp iq lv b gy mv mr l ms mt"><strong class="lv ir">print</strong>(my_list_comprehension)<br/><strong class="lv ir">print</strong>(my_generator)</span><span id="603b" class="mo mp iq lv b gy mv mr l ms mt">Output:<br/>[0, 3, 6, 9]<br/>&lt;generator object &lt;genexpr&gt; at 0x7f8a4446e340&gt;</span></pre><p id="c4d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如预期的那样，生成器表达式生成了一个生成器对象，它将根据需要一个接一个地生成结果，就像我们前面看到的生成器函数一样。</p><h2 id="b9ff" class="mo mp iq bd mx my mz dn na nb nc dp nd lf ne nf ng lj nh ni nj ln nk nl nm nn bi translated">发电机的优势</h2><p id="d301" class="pw-post-body-paragraph kw kx iq ky b kz no jr lb lc np ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">与其他 iterables 相比，生成器的一个很大的优势是，不像 list 那样必须在内存中存储所有元素，生成器只需要存储当前元素以及如何到达下一个元素。这使得生成器在内存消耗方面非常高效，并且它还为生成器提供了独特的优势，能够表示真正无限的数据流，特别是因为它们一次生成一个项目，这意味着在任何给定时间只有一个元素会存储在内存中。</p><p id="955d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">生成器的另一个优点是，在我们开始在代码中进一步使用它们之前，我们不需要等待所有的元素都被生成(在列表的情况下，我们需要等待)。</p><p id="758e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们应该注意到，只有当我们不打算多次使用生成的数字时，这两个优点才是显著的和真正有用的。</p><p id="e71e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还发现它们非常容易实现，不像<a class="ae kv" href="https://medium.com/@deck451/python-up-your-code-iterators-af5331f68ccd" rel="noopener">迭代器</a>，它们有相当多的样板代码来实现这两个<code class="fe ls lt lu lv b">__iter__()</code>和<code class="fe ls lt lu lv b">__next__()</code>方法。</p><p id="a2ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总结这篇文章，我希望它有助于积累一些(更多)关于发电机的知识。这篇文章决不是关于这个话题的详尽的信息来源。互联网上充满了关于 Python 生成器的令人难以置信的全面教程和文档。写这篇文章时，我让自己从中获得灵感的一个这样的网页可以在这里找到。</p><p id="ca04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">话虽如此，请注意安全，我们在下一站<a class="ae kv" href="https://medium.com/@deck451/python-up-your-code-chained-comparisons-a949778d166d" rel="noopener">见！编码快乐！</a></p></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><p id="3d52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mu"> Deck 是软件工程师、导师、作家，有时甚至是老师。他拥有 12 年以上的软件工程经验，现在是 Python 编程语言的真正倡导者，同时他的热情是帮助人们提高他们的 Python(以及一般的编程)技能。你可以在</em><a class="ae kv" href="https://www.linkedin.com/in/deck451/" rel="noopener ugc nofollow" target="_blank"><em class="mu">Linkedin</em></a><em class="mu">，</em> <a class="ae kv" href="https://www.facebook.com/deck451/" rel="noopener ugc nofollow" target="_blank"> <em class="mu">脸书</em> </a> <em class="mu">，</em><a class="ae kv" href="https://twitter.com/Deck45100" rel="noopener ugc nofollow" target="_blank"><em class="mu">Twitter</em></a><em class="mu">，</em><a class="ae kv" href="https://discord.com" rel="noopener ugc nofollow" target="_blank"><em class="mu">Discord</em></a><em class="mu">:Deck 451 # 6188，以及跟随他写在这里的</em> <a class="ae kv" href="https://medium.com/@deck451" rel="noopener"> <em class="mu"> Medium </em> </a></p></div></div>    
</body>
</html>