<html>
<head>
<title>Factory Design Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">工厂设计模式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/factory-design-pattern-23e20d933045?source=collection_archive---------17-----------------------#2020-06-29">https://blog.devgenius.io/factory-design-pattern-23e20d933045?source=collection_archive---------17-----------------------#2020-06-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/536826efe07ca33eb9c7ce0d8a16d326.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hSsvQhYCdDjsqHKxHmqbLQ.png"/></div></div></figure><p id="4d51" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在软件工程中，创造性的设计模式处理对象创建机制，也就是说，试图以适合情况的方式创建对象。除此之外，这种基本或普通形式的对象创建可能会导致设计问题或增加设计的复杂性。C++中的工厂设计模式通过<strong class="ka ir"> <em class="kw">使用单独的方法或多态类</em> </strong>创建对象来帮助缓解这个问题。</p><blockquote class="kx ky kz"><p id="e34c" class="jy jz kw ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><em class="iq"> /！\:这篇文章最初发表在我的博客上。如果你有兴趣接收我的最新文章，</em> <a class="ae ld" href="http://eepurl.com/gDNybv" rel="noopener ugc nofollow" target="_blank"> <em class="iq">请报名参加我的简讯</em> </a> <em class="iq">。</em></p></blockquote><p id="3bf2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">顺便说一句，如果你还没有看过我关于创造性设计模式的其他文章，那么下面是列表:</p><ol class=""><li id="cad4" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated"><a class="ae ld" href="http://www.vishalchovatiya.com/factory-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">工厂</strong> </a></li><li id="005b" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><a class="ae ld" href="http://www.vishalchovatiya.com/builder-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">建造者</strong> </a></li><li id="ee91" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><a class="ae ld" href="http://www.vishalchovatiya.com/prototype-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">原型</strong> </a></li><li id="7f31" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><a class="ae ld" href="http://www.vishalchovatiya.com/singleton-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">单胎</strong> </a></li></ol><p id="161a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您在这一系列文章中看到的代码片段是简化的，而不是复杂的。所以你经常看到我不使用像<code class="fe ls lt lu lv b">override</code>、<code class="fe ls lt lu lv b">final</code>、<code class="fe ls lt lu lv b">public</code>(同时继承)这样的关键字，只是为了让代码紧凑&amp;可消耗(大部分时间)在单一标准屏幕尺寸。我也更喜欢<code class="fe ls lt lu lv b">struct</code>而不是<code class="fe ls lt lu lv b">class</code>，只是为了节省代码行，有时不写<code class="fe ls lt lu lv b">public:</code>，也故意忽略<a class="ae ld" href="http://www.vishalchovatiya.com/part-3-all-about-virtual-keyword-in-c-how-virtual-destructor-works/" rel="noopener ugc nofollow" target="_blank">虚析构函数</a>，构造函数<a class="ae ld" href="http://www.vishalchovatiya.com/all-about-copy-constructor-in-cpp-with-example/" rel="noopener ugc nofollow" target="_blank">，复制构造函数</a>，前缀<code class="fe ls lt lu lv b">std::</code>，删除动态内存。我也认为自己是一个务实的人，希望用尽可能简单的方式，而不是标准的方式或使用术语来传达一个想法。</p><p id="a3fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="kw">注:</em>T42】</strong></p><ul class=""><li id="1f8d" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lw lk ll lm bi translated">如果你是在这里被直接绊倒的，那么我建议你浏览一下<a class="ae ld" href="http://www.vishalchovatiya.com/what-is-design-pattern/" rel="noopener ugc nofollow" target="_blank">什么是设计模式？</a>一、哪怕是鸡毛蒜皮的小事。相信会鼓励你对这个话题进行更多的探索。</li><li id="e965" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lw lk ll lm bi translated">您在本系列文章中遇到的所有这些代码都是使用 C++20 编译的(尽管我在大多数情况下使用了 C++17 之前的<a class="ae ld" href="http://www.vishalchovatiya.com/21-new-features-of-modern-cpp-to-use-in-your-project/" rel="noopener ugc nofollow" target="_blank">现代 C++ </a>特性)。因此，如果你没有获得最新的编译器，你可以使用<a class="ae ld" href="https://wandbox.org/" rel="noopener ugc nofollow" target="_blank">https://wandbox.org/</a>，它也已经预装了 boost 库。</li></ul><h1 id="a569" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">目的</h1><blockquote class="kx ky kz"><p id="05a7" class="jy jz kw ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="iq">用于创建批发对象，不同于生成器(分段创建)。</em> </strong></p></blockquote><h1 id="ad6e" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">动机</h1><ul class=""><li id="7d9a" class="le lf iq ka b kb mv kf mw kj mx kn my kr mz kv lw lk ll lm bi translated">假设你有一个<code class="fe ls lt lu lv b">Point</code>类，有<code class="fe ls lt lu lv b">x</code> &amp; <code class="fe ls lt lu lv b">y</code>作为坐标，可以是笛卡尔坐标或极坐标，如下所示:</li></ul><pre class="na nb nc nd gt ne lv nf ng aw nh bi"><span id="5539" class="ni ly iq lv b gy nj nk l nl nm">struct Point {<br/>    Point(float x, float y){ /*...*/ }      // Cartesian co-ordinates</span><span id="0e09" class="ni ly iq lv b gy nn nk l nl nm">    // Not OK: Cannot overload with same type of arguments<br/>    // Point(float a, float b){ /*...*/ }    // Polar co-ordinates</span><span id="e59c" class="ni ly iq lv b gy nn nk l nl nm">    // ... Implementation<br/>};</span></pre><ul class=""><li id="96fe" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lw lk ll lm bi translated">这是不可能的，因为你可能知道你不能用相同类型的参数创建两个构造函数。</li><li id="5189" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lw lk ll lm bi translated">反过来是:</li></ul><pre class="na nb nc nd gt ne lv nf ng aw nh bi"><span id="4ae6" class="ni ly iq lv b gy nj nk l nl nm">enum class PointType{ cartesian, polar };</span><span id="f66c" class="ni ly iq lv b gy nn nk l nl nm">class Point {<br/>    Point(float a, float b, PointTypetype = PointType::cartesian) {<br/>        if (type == PointType::cartesian) {<br/>            x = a; b = y;<br/>        }<br/>        else {<br/>            x = a * cos(b);<br/>            y = a * sin(b);<br/>        }<br/>    }<br/>};</span></pre><ul class=""><li id="dabe" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lw lk ll lm bi translated">但这并不是一种复杂的方式。相反，我们应该将单独的实例化委托给单独的方法。</li></ul><h1 id="88c8" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">C++中的工厂设计模式示例</h1><ul class=""><li id="ddb3" class="le lf iq ka b kb mv kf mw kj mx kn my kr mz kv lw lk ll lm bi translated">所以你可以猜到。我们将通过将初始化过程从构造函数转移到其他结构来减轻构造函数的限制。我们将使用工厂方法。</li><li id="d9c0" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lw lk ll lm bi translated">顾名思义，它使用方法或成员函数来初始化对象。</li></ul><h1 id="86d5" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">工厂方法</h1><pre class="na nb nc nd gt ne lv nf ng aw nh bi"><span id="c3bb" class="ni ly iq lv b gy nj nk l nl nm">enum class PointType { cartesian, polar };</span><span id="2837" class="ni ly iq lv b gy nn nk l nl nm">class Point {<br/>    float       m_x;<br/>    float       m_y;<br/>    PointType   m_type;</span><span id="2606" class="ni ly iq lv b gy nn nk l nl nm">    // Private constructor, so that object can't be created directly<br/>    Point(const float x, const float y, PointType t) : m_x{x}, m_y{y}, m_type{t} { }<br/>public:<br/>    friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const Point&amp; obj) {<br/>        return os &lt;&lt; "x: " &lt;&lt; obj.m_x &lt;&lt; " y: " &lt;&lt; obj.m_y;<br/>    }<br/>    static Point NewCartesian(float x, float y) { <br/>        return { x, y, PointType::cartesian }; <br/>    }<br/>    static Point NewPolar(float a, float b) { <br/>        return { a*cos(b), a*sin(b), PointType::polar }; <br/>    }<br/>};</span><span id="8917" class="ni ly iq lv b gy nn nk l nl nm">int main() {<br/>    // Point p{ 1,2 };  // will not work<br/>    auto p = Point::NewPolar(5, M_PI_4);<br/>    cout &lt;&lt; p &lt;&lt; endl;  // x: 3.53553 y: 3.53553<br/>    return EXIT_SUCCESS;<br/>}</span></pre><ul class=""><li id="bd51" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lw lk ll lm bi translated">正如您可以从实现中观察到的。它实际上不允许使用构造函数&amp;强迫用户使用静态方法。而这就是<strong class="ka ir"> <em class="kw">工厂方法即私有构造函数&amp;静态方法</em> </strong>的本质。</li></ul><h1 id="52a5" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">经典工厂设计模式</h1><ul class=""><li id="1776" class="le lf iq ka b kb mv kf mw kj mx kn my kr mz kv lw lk ll lm bi translated">如果你有专门的代码用于构造，那么当没有的时候，我们把它移到一个专门的类中。仅仅是为了分离关注点，即<a class="ae ld" href="http://www.vishalchovatiya.com/single-responsibility-principle-in-cpp-solid-as-a-rock/" rel="noopener ugc nofollow" target="_blank">单一责任原则</a>和实体设计原则。</li></ul><pre class="na nb nc nd gt ne lv nf ng aw nh bi"><span id="b4a0" class="ni ly iq lv b gy nj nk l nl nm">class Point {<br/>    // ... as it is from above<br/>    friend class PointFactory;<br/>};</span><span id="c157" class="ni ly iq lv b gy nn nk l nl nm">class PointFactory {<br/>public:<br/>    static Point NewCartesian(float x, float y) {<br/>        return { x, y };<br/>    }<br/>    static Point NewPolar(float r, float theta) {<br/>        return { r*cos(theta), r*sin(theta) };<br/>    }<br/>};</span></pre><ul class=""><li id="bb75" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lw lk ll lm bi translated">请注意，这不是抽象的工厂，这是具体的工厂。</li><li id="13f3" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lw lk ll lm bi translated">制作<code class="fe ls lt lu lv b">Point</code>的<code class="fe ls lt lu lv b">PointFactory</code>好友类我们违反了<a class="ae ld" href="http://www.vishalchovatiya.com/open-closed-principle-in-cpp-solid-as-a-rock/" rel="noopener ugc nofollow" target="_blank">开闭原则</a> (OCP)。作为朋友的关键词本身与 OCP 相反。</li></ul><h1 id="5609" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">内部工厂</h1><ul class=""><li id="2a13" class="le lf iq ka b kb mv kf mw kj mx kn my kr mz kv lw lk ll lm bi translated">我们工厂忽略了一个关键的东西，即<code class="fe ls lt lu lv b">PointFactory</code> &amp; <code class="fe ls lt lu lv b">Point</code>之间没有强有力的联系，这使得用户看到一切都是<code class="fe ls lt lu lv b">private</code>就混淆了使用<code class="fe ls lt lu lv b">Point</code>。</li><li id="5f7c" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lw lk ll lm bi translated">所以与其在课堂外设计工厂。我们可以简单地把它放在鼓励用户使用工厂的类中。</li><li id="c737" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lw lk ll lm bi translated">因此，我们也服务于第二个问题，即打破<a class="ae ld" href="http://www.vishalchovatiya.com/open-closed-principle-in-cpp-solid-as-a-rock/" rel="noopener ugc nofollow" target="_blank">开闭原则</a>。这对于用户使用 Factory 来说会更加直观。</li></ul><pre class="na nb nc nd gt ne lv nf ng aw nh bi"><span id="06e1" class="ni ly iq lv b gy nj nk l nl nm">class Point {<br/>    float   m_x;<br/>    float   m_y;</span><span id="396f" class="ni ly iq lv b gy nn nk l nl nm">    Point(float x, float y) : m_x(x), m_y(y) {}<br/>public:<br/>    struct Factory {<br/>        static Point NewCartesian(float x, float y) { return { x,y }; }<br/>        static Point NewPolar(float r, float theta) { return{ r*cos(theta), r*sin(theta) }; }<br/>    };<br/>};</span><span id="4670" class="ni ly iq lv b gy nn nk l nl nm">int main() {<br/>    auto p = Point::Factory::NewCartesian(2, 3);<br/>    return EXIT_SUCCESS;<br/>}</span></pre><h1 id="6b5c" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">抽象工厂</h1><h2 id="e4f7" class="ni ly iq bd lz no np dn md nq nr dp mh kj ns nt ml kn nu nv mp kr nw nx mt ny bi translated">为什么我们需要一个抽象工厂？</h2><ul class=""><li id="1965" class="le lf iq ka b kb mv kf mw kj mx kn my kr mz kv lw lk ll lm bi translated">C++使用基类的<a class="ae ld" href="http://www.vishalchovatiya.com/part-3-all-about-virtual-keyword-in-c-how-virtual-destructor-works/" rel="noopener ugc nofollow" target="_blank">虚拟析构函数</a>支持多态对象析构。类似地，由于с++不支持<a class="ae ld" href="http://www.vishalchovatiya.com/7-advanced-cpp-concepts-idiom-examples-you-should-know/" rel="noopener ugc nofollow" target="_blank">虚拟构造函数</a> &amp; <a class="ae ld" href="http://www.vishalchovatiya.com/all-about-copy-constructor-in-cpp-with-example/" rel="noopener ugc nofollow" target="_blank">复制构造函数</a>，因此缺少对对象的创建&amp;复制的等效支持。</li><li id="c8f0" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lw lk ll lm bi translated">此外，除非知道对象的静态类型，否则无法创建对象，因为编译器必须知道它需要分配的空间量。出于同样的原因，复制一个对象也需要在编译时知道它的类型。</li></ul><pre class="na nb nc nd gt ne lv nf ng aw nh bi"><span id="7972" class="ni ly iq lv b gy nj nk l nl nm">struct Point {<br/>    virtual ~Point(){ cout&lt;&lt;"~Point\n"; }<br/>};</span><span id="c19f" class="ni ly iq lv b gy nn nk l nl nm">struct Point2D : Point {<br/>    ~Point2D(){ cout&lt;&lt;"~Point2D\n"; }<br/>};</span><span id="dbd7" class="ni ly iq lv b gy nn nk l nl nm">struct Point3D : Point {<br/>    ~Point3D(){ cout&lt;&lt;"~Point3D\n"; }<br/>};</span><span id="e37c" class="ni ly iq lv b gy nn nk l nl nm">void who_am_i(Point *who) { // Not sure whether Point2D would be passed here or Point3D<br/>    // How to `create` the object of same type i.e. pointed by who ?<br/>    // How to `copy` object of same type i.e. pointed by who ?<br/>    delete who; // you can delete object pointed by who, thanks to virtual destructor<br/>}</span></pre><h2 id="b7cb" class="ni ly iq bd lz no np dn md nq nr dp mh kj ns nt ml kn nu nv mp kr nw nx mt ny bi translated">抽象工厂设计模式的例子</h2><ul class=""><li id="0da8" class="le lf iq ka b kb mv kf mw kj mx kn my kr mz kv lw lk ll lm bi translated">抽象工厂在需要创建许多不同类型的对象的情况下非常有用，这些对象都是从一个公共的基类型派生出来的。</li><li id="679c" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lw lk ll lm bi translated">抽象工厂定义了创建对象的方法，然后<a class="ae ld" href="http://www.vishalchovatiya.com/memory-layout-of-cpp-object/" rel="noopener ugc nofollow" target="_blank">的子类</a>可以覆盖该方法来指定将要创建的派生类型。因此，在运行时，将根据引用/指向的对象类型调用适当的抽象工厂方法&amp;返回指向该对象的新实例的基类指针。</li></ul><pre class="na nb nc nd gt ne lv nf ng aw nh bi"><span id="e072" class="ni ly iq lv b gy nj nk l nl nm">struct Point {<br/>    virtual ~Point() = default;<br/>    virtual unique_ptr&lt;Point&gt; create() = 0;<br/>    virtual unique_ptr&lt;Point&gt; clone()    = 0;<br/>};</span><span id="5d77" class="ni ly iq lv b gy nn nk l nl nm">struct Point2D : Point {<br/>    unique_ptr&lt;Point&gt; create() { return make_unique&lt;Point2D&gt;(); }<br/>    unique_ptr&lt;Point&gt; clone() { return make_unique&lt;Point2D&gt;(*this); }<br/>};</span><span id="0c8a" class="ni ly iq lv b gy nn nk l nl nm">struct Point3D : Point {<br/>    unique_ptr&lt;Point&gt; create() { return make_unique&lt;Point3D&gt;(); }<br/>    unique_ptr&lt;Point&gt; clone() { return make_unique&lt;Point3D&gt;(*this); }<br/>};</span><span id="0622" class="ni ly iq lv b gy nn nk l nl nm">void who_am_i(Point *who) {<br/>    auto new_who       = who-&gt;create(); // `create` the object of same type i.e. pointed by who ?<br/>    auto duplicate_who = who-&gt;clone();    // `copy` the object of same type i.e. pointed by who ?<br/>    delete who;<br/>}</span></pre><ul class=""><li id="5775" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lw lk ll lm bi translated">如上所示，我们通过委托创建动作来利用多态方法&amp;通过使用纯虚拟方法将对象复制到派生类。</li><li id="f7a6" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lw lk ll lm bi translated">上面的代码不仅实现了<code class="fe ls lt lu lv b"><a class="ae ld" href="http://www.vishalchovatiya.com/7-advanced-cpp-concepts-idiom-examples-you-should-know/#Virtual-Constructor" rel="noopener ugc nofollow" target="_blank">virtual constructor</a></code>(即<code class="fe ls lt lu lv b">create()</code>)，还实现了<a class="ae ld" href="http://www.vishalchovatiya.com/7-advanced-cpp-concepts-idiom-examples-you-should-know/#Virtual-Constructor" rel="noopener ugc nofollow" target="_blank">【虚拟复制构造器】</a>(即<code class="fe ls lt lu lv b">clone()</code>)。</li><li id="2d1d" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lw lk ll lm bi translated">确保在使用抽象工厂时，你已经确保了<a class="ae ld" href="http://www.vishalchovatiya.com/liskovs-substitution-principle-in-cpp-solid-as-a-rock/" rel="noopener ugc nofollow" target="_blank">利斯科夫的替代原则(LSP) </a>。</li></ul><h1 id="0ea7" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">使用现代 C++实现工厂设计模式的函数方法</h1><ul class=""><li id="9d6c" class="le lf iq ka b kb mv kf mw kj mx kn my kr mz kv lw lk ll lm bi translated">在我们的抽象工厂例子中，我们遵循了面向对象的方法，但是现在它同样可能是一种更功能化的方法。</li><li id="4abf" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lw lk ll lm bi translated">因此，让我们建立一个类似的工厂，不依赖多态功能，因为它可能不适合一些时间受限的应用程序，如<a class="ae ld" href="https://en.wikipedia.org/wiki/Embedded_system" rel="noopener ugc nofollow" target="_blank">嵌入式系统</a>。因为<a class="ae ld" href="http://www.vishalchovatiya.com/part-1-all-about-virtual-keyword-in-cpp-how-virtual-function-works-internally/" rel="noopener ugc nofollow" target="_blank">虚拟表&amp;动态调度机制</a>可能会在关键功能期间影响系统。</li><li id="498c" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lw lk ll lm bi translated">这非常简单，因为它使用了如下的函数式λ函数:</li></ul><pre class="na nb nc nd gt ne lv nf ng aw nh bi"><span id="0bd9" class="ni ly iq lv b gy nj nk l nl nm">struct Point { /* . . . */ };<br/>struct Point2D : Point {/* . . . */};<br/>struct Point3D : Point {/* . . . */};</span><span id="0db5" class="ni ly iq lv b gy nn nk l nl nm">class PointFunctionalFactory {<br/>    map&lt;PointType, function&lt;unique_ptr&lt;Point&gt;() &gt;&gt;      m_factories;</span><span id="8650" class="ni ly iq lv b gy nn nk l nl nm">public:<br/>    PointFunctionalFactory() {<br/>        m_factories[PointType::Point2D] = [] { return make_unique&lt;Point2D&gt;(); };<br/>        m_factories[PointType::Point3D] = [] { return make_unique&lt;Point3D&gt;(); };<br/>    }    <br/>    unique_ptr&lt;Point&gt; create(PointType type) { return m_factories[type](); }  <br/>};</span><span id="013d" class="ni ly iq lv b gy nn nk l nl nm">int main() {<br/>    PointFunctionalFactory pf;<br/>    auto p2D = pf.create(PointType::Point2D);<br/>    return EXIT_SUCCESS;<br/>}</span></pre><ul class=""><li id="01bb" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lw lk ll lm bi translated">如果您认为我们过度工程化了，那么请记住，我们的对象构造很简单，只是为了演示该技术&amp;我们的 lambda 函数也是如此。</li><li id="20bc" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lw lk ll lm bi translated">当你的对象表示增加时，需要调用很多方法才能正确实例化对象，这种情况下你只需要修改工厂的 lambda 表达式或者引入<a class="ae ld" href="http://www.vishalchovatiya.com/builder-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> Builder 设计模式</a>。</li></ul><h1 id="1e3d" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">工厂设计模式的好处</h1><ol class=""><li id="e73e" class="le lf iq ka b kb mv kf mw kj mx kn my kr mz kv lj lk ll lm bi translated">不同对象创建的单点/类。因此易于维护和理解软件。</li><li id="f329" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">通过使用抽象工厂，您甚至可以在不知道对象类型的情况下创建对象。</li><li id="156a" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">它提供了很好的模块化。想象一下，编写一个视频游戏，你想在未来添加新类型的敌人，每个敌人都有不同的 AI 功能，可以不同地更新。通过使用工厂方法，程序的控制者可以调用工厂来创建敌人，而不需要任何依赖或实际敌人类型的知识。现在，未来的开发者可以创造新的敌人，用新的人工智能控制和新的绘图成员功能，把它添加到工厂，并创建一个调用工厂的关卡，通过名字询问敌人。将这种方法与级别的 XML 描述结合起来，开发人员就可以创建新的级别，而不必重新编译他们的程序。所有这一切，都要归功于对象的创建和对象的使用的分离。</li><li id="3a9f" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">允许您更容易地更改应用程序的设计，这被称为松耦合。</li></ol><h1 id="5905" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">常见问题汇总</h1><p id="df04" class="pw-post-body-paragraph jy jz iq ka b kb mv kd ke kf mw kh ki kj nz kl km kn oa kp kq kr ob kt ku kv ij bi translated"><strong class="ka ir">在 C++中实现工厂设计模式的正确方法是什么？</strong></p><p id="752a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">抽象工厂&amp;功能工厂总是一个不错的选择。</p><p id="0791" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">工厂 vs 抽象因素 vs 功能工厂？</strong></p><p id="b551" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">- Factory:创建具有不同实例化的对象。<br/> -抽象因素:创建一个不知道类型的对象&amp;引用使用基类指针&amp;引用。使用多态方法访问。<br/> -功能工厂:当对象创建比较复杂的时候。抽象工厂+ <a class="ae ld" href="http://www.vishalchovatiya.com/builder-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank">构建器设计模式</a>。虽然我没有在功能工厂示例中包括构建器。</p><p id="187d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">什么时候使用工厂设计模式？</strong></p><p id="c721" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用工厂设计模式创建所需功能的对象，但对象类型仍未确定，或者将由传递的动态参数决定。</p><p id="4506" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae ld" href="http://www.vishalchovatiya.com/contact-2/" rel="noopener ugc nofollow" target="_blank">有什么建议、疑问或者想说</a> <code class="fe ls lt lu lv b"><a class="ae ld" href="http://www.vishalchovatiya.com/contact-2/" rel="noopener ugc nofollow" target="_blank">Hi</a></code> <a class="ae ld" href="http://www.vishalchovatiya.com/contact-2/" rel="noopener ugc nofollow" target="_blank">？减轻压力，只需点击一下鼠标。</a> 🖱️</p></div></div>    
</body>
</html>