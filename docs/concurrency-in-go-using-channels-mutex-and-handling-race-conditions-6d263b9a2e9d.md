# Go 中的并发性——使用通道和处理竞争条件

> 原文：<https://blog.devgenius.io/concurrency-in-go-using-channels-mutex-and-handling-race-conditions-6d263b9a2e9d?source=collection_archive---------4----------------------->

![](img/03f51961dd429ce2e861e3b81adb1bea.png)

这是我每周系列*学习围棋*的第十二篇。上周我谈到了使用 Goroutines 和 WaitGroups 来利用 Go 中的并发模式。本周我将继续扩展并发性的话题，向您展示如何使用 Go 的几个更有用的特性:*通道和互斥*。我还将带您了解如何在代码中识别和修复潜在的竞态条件。我们开始吧！

# 频道

> 允许您在并发 Goroutines 中发送和接收值的“管道”

从本质上来说，*通道*可以被认为是信使，你可以将它们发送到不同的 Goroutines 来传递或获取价值

*   频道阻塞
*   它们是同步的
*   它们必须同时传递或接收值

通道有两个重要的语法片段`<-`和`->`

当你想把数据*发送到信道*时，你可以使用这个语法`channel <-`

当您想要从通道中检索数据*时，您可以使用以下语法`<- channel`*

让我给你看一个简单的例子，看看渠道的作用

在我们的`func` `main`中，我们使用短声明操作符创建一个带有标识符`c`的新变量。我们使用`make`关键字来创建一个新的`chan`，它的类型是`int`

接下来，我们创建一个匿名的 *Goroutine* 。在这个 *Goroutine* 内部，我们使用`c <-`语法将值`29`发送到我们的`c` *通道*。我们使用`()`来立即运行这个 *Goroutine*

我们使用`<- c`语法获取通道的值，并打印`c`的值。当我们去的时候，我们得到值`29`应该是不足为奇的。酷！我们已经成功地向*通道*发送了数据，并从*通道*接收了一个值。

如果我们想限制发送到我们创建的*通道*上的数据量，该怎么办？Go 通过使用一个叫做*通道缓冲*的特性来实现这一点

默认情况下，*通道*无缓冲，这意味着在*通道*上可以发送和存储的数据量没有限制。你可以想象，这可能会很快失控。只要有可能，使用*通道缓冲*总是一个好主意。

让我给你看一个例子:

这应该是个惊喜，对吧？如你所见，我们有 5 条消息发送到`chat`，并成功使用`fmt.Println()`打印出每一条记录。但是如果我们试图给`chat`添加另一个条目会发生什么呢？

但是，如果我试图向我们的*通道*添加另一个`string`值，会发生什么呢？让我们来看看:

这是相同的代码，除了这一次我们试图添加`No spoilers please!`到我们的`chat` *频道*。围棋不喜欢这样。当我们试图运行我们的应用程序时，Go 给出了这个错误:

尽管错误通常被认为是令人讨厌的，但 Go 深思熟虑地引入了它们，以帮助您防止应用程序中不必要的副作用。

# 定向渠道

当您开始使用*通道*时，您会很快意识到创建只能接收值或只能发送值的*通道*是多么有用。Go bakes 在这个特性中变成了`chan`类型，让我给你看几个例子:

在`func` `main`内部，我们创建了一个标识符为`c`的新变量，其类型为`chan`，包含类型为`int`的值

注意，我们通过将值`1`作为第二个参数传递给`make`，使`c`成为*缓冲通道*。在这种情况下，我们的*缓冲通道*只能包含一个值。

接下来，我们将值`29`发送到我们的`c` *通道*

这看起来很简单，不是吗？当执行`fmt.Println(<-c)`时，我们应该期望打印出值`29`，对吗？没有。这是*定向频道*在做他们的工作。还记得我们创建`c`频道的时候吗？我们明确地告诉 Go，当我们使用这个语法`chan <- int`时，这个`c`通道只会是一个*发送*通道

当我们试图运行这段代码时，Go 会阻止我们，并给出一个非常有用的错误消息

让我给你看另一个使用*定向频道*的例子

在这个例子中，我们创建了一个标识符为`c`的新变量，它的类型为`chan`，包含类型为`int`的值；然而，在本例中，我们创建了一个只能接收值的*方向通道*

现在，当我们试图将值`29`发送到`c` *通道*时，我们得到这个错误消息

*方向通道*可以在组织你的代码中扮演重要的角色。现在，您可以显式创建一个*发送通道*和一个*接收通道*。如果您放心地让这两个通道都得到缓冲，那么您将在代码中获得很多可预测性。

让我给你看一个使用*缓冲定向通道*的更深入的例子

在这个例子中，我们使用了一个*缓冲通道*，并且我们创建了两个函数:一个向我们的*通道*发送一个值，另一个从我们的*通道*接收一个值

重要的事情先来。我们创建一个标识符为`c`的新变量，它的类型为`chan`，包含类型为`int`的值。我们的`make`函数中的`1`参数使`c`成为*缓冲通道*

接下来，我们调用一个带有标识符`send`的函数，并传递我们的`c` *通道*作为唯一的参数，我们对带有标识符`receive`的函数做同样的事情

我们创建一个标识符为`send`的函数，它有一个参数，即*发送通道* ( *通道*，您只能向其发送值)。这个*通道*将包含类型`int`的值。在这个函数内部，我们*将值 29 发送到我们的`c` *通道**

我们创建一个标识符为`receive`的函数，它有一个参数，这个参数是一个*接收通道*(一个*通道*，您只能从这个通道接收值)。这个*通道*将包含`int`类型的值。在这个函数中，我们*在我们的`c` *通道*上接收*值 29，并使用`fmt`包打印该值

# 互斥和竞争条件

我们已经了解了如何通过*通道*发送和接收数据，但是如果多个 *Goroutines* 需要访问一个共享的状态，会发生什么呢？我们国家的可靠性很容易受到损害，我们不希望这样。

让我给你看一个例子，当多个 *Goroutines* 使用一个共享的状态会产生不需要的结果

注意:为了这个例子，我将使用[运行时](https://golang.org/pkg/runtime/)包来使用 [Gosched()](https://golang.org/pkg/runtime/#Gosched) 方法。这个方法将允许我发射一个新的 Goroutine。

我想确保我正在导入将要使用的包；因此，我导入了`fmt`、`runtime`和`sync`包

在`func` `main`内部，我们声明了一个新的变量，它的标识符`counter`被赋给了值`0`

接下来，我创建一个标识符为`gs`的变量(它代表 *Go Schedule* ，我将很快介绍这一点)，该变量被赋值为`5`

我创建了一个标识符为`wg`的变量，并赋予它一个新的 *WaitGroup* 的值

我将使用`gs`的值进行迭代；因此，我要确保我的`Add` `5` *WaitGroups*

接下来，我们创建一个`for`循环，它将使用`condition statement`中`gs`的值。在这个`for`循环中，我们创建了一个匿名的 *_Goroutine_* 并立即调用 *Goroutine* 。

在我们的匿名 *Goroutine* 中，我们用标识符`v`声明了一个新变量，并赋予了值`counter`

我们使用`runtime`包来调用`Gosched()`方法，从而触发一个新的 *Goroutine*

在下一行，我们增加我们的`v`变量，并将`counter`变量赋给`v`变量

我们使用`fmt`包打印出`counter`的值，并使用`wg`变量调用`Done()`方法，这将让 Go 运行时知道我们的`WaitGroup`已经完成

我们总共重复这个过程 5 次

在`for`循环之外，我们调用从`wg`变量访问的`Wait()`方法。`Wait()`方法阻止我们的`main`函数退出

一旦我们的*等待组*全部完成，我们的`main`函数就退出

你注意到我们的`for`循环为`counter`的值打印了什么吗？目前，每次迭代的值是`1`。这是为什么呢？

目前，我们立即调用了 5 个 Goroutines，但没有告诉 Go 运行时如何处理它们；因此，它们随机运行、访问和更新我们的`counter`状态。没有办法预测这些 *Goroutines* 的顺序。不过，有一种方法可以解决这个问题！

一次只希望一个 *Goroutine* 访问一个状态，从而避免冲突的概念被称为*互斥*。共享这种方法的数据结构的传统名称叫做*互斥*

Go 标准库提供的`sync`包为我们提供了`sync.Mutex`两个重要的方法:`Lock`和`Unlock`

让我给你看一个使用`Mutex`的例子

除了几处不同，上面的代码是一样的。让我解释一下在使用互斥锁*时我们代码中的不同之处*

为了让我们使用一个*互斥体*，我们创建了一个标识符为`mu`的新变量，它的值为从`sync`包中获得的`Mutex`

在我们的匿名 *Goroutine* 的第一行，我们使用我们的`mu`变量来调用`Lock()`方法。这种方法确保独占访问我们的状态。一旦我们完成了状态更新，我们就调用`Unlock()`方法，这个方法也是由我们的`mu`变量提供的

现在我们可以看到我们的`counter`日志看起来更像我们所期望的

# 概括起来

很酷吧？我们现在了解了什么是*通道*、*缓冲通道*和*定向通道*以及如何有效地使用它们。我们还学习了*互斥体*以及如何在我们的围棋程序中充分利用它们，以确保我们永远不会污染我们的状态并制造任何竞争条件。

我的*学围棋*系列到此结束。我希望你喜欢阅读！虽然这是本系列的最后一篇文章，但您可以期待将来会有更多关于 Go 的文章！与此同时，考虑订阅我的简讯，在那里我会发布软件行业的新帖子以及有用的工具和技巧。我偶尔也会附上一两张我的金毛猎犬的照片。👋🏻