<html>
<head>
<title>The shadow DOM of an HTML5 web component</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">HTML5 web 组件的阴影 DOM</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/the-shadow-dom-of-an-html5-web-component-d99af7844192?source=collection_archive---------8-----------------------#2022-05-06">https://blog.devgenius.io/the-shadow-dom-of-an-html5-web-component-d99af7844192?source=collection_archive---------8-----------------------#2022-05-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/02aa5563580e3fbb0b9e4d3ae42a4ca9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VCpj_onVN4TFyAB5"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@victorious_light?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">妮可·约翰逊</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="ba49" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将在 HTML5 教程的后面部分展示使用 HTML5 web 组件构建 web 应用程序的原生 Javascript 方法。到目前为止，我们为我们的<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/the-responsive-layout-for-our-rust-web-application-8fb46fe14c8f">响应式</a> RSS 阅读器<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/initial-setup-for-a-rust-web-application-using-web-components-and-native-javascript-modules-ee832c062e8a">应用程序</a>创建了一些<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/html5-rss-reader-writing-the-first-web-components-949eec88dbf9"> web 组件</a>，我们看到了如何设计它们的样式并<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/html5-rss-reader-writing-specialized-web-components-8c8a972e681a">扩展它们</a>，但是有一个核心方面我们需要讨论:影子 DOM。如果为 web 组件激活，shadow DOM 允许该组件的内容对外界隐藏。它是这样工作的:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="7a8d" class="lk ll iq lg b gy lm ln l lo lp">class FilteredList extends HTMLDivElement {<br/>  constructor() {<br/>    super();<br/><br/>    let shadow = this.attachShadow({ mode: 'open' });<br/>    let list = document.createElement('ul');<br/>    let input = document.createElement('input');</span><span id="9f74" class="lk ll iq lg b gy lq ln l lo lp">    shadow.appendChild(input);<br/>    shadow.appendChild(list);<br/>  }<br/>}</span><span id="8e9d" class="lk ll iq lg b gy lq ln l lo lp">customElements.define('filtered-list', FilteredList, { extends: 'div' });</span></pre><p id="850c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的例子中，我们创建了一个名为<code class="fe lr ls lt lg b">FilteredList</code>的复合元素，它有一个列表和一个文本框:就像我们对<code class="fe lr ls lt lg b">CustomList</code>所做的一样，只是这次过滤<code class="fe lr ls lt lg b">input</code>被包含在组件中。在<code class="fe lr ls lt lg b">CustomList</code>的情况下，过滤<code class="fe lr ls lt lg b">input</code>在<code class="fe lr ls lt lg b">index.html</code>的组件之外。</p><p id="5550" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将一个阴影 DOM 附加到<code class="fe lr ls lt lg b">FilteredList</code>上，并用<code class="fe lr ls lt lg b">mode: open</code>对其进行设置(我们稍后会看到这意味着什么)。然后我们将列表和文本框添加到影子 DOM 中。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lu"><img src="../Images/40d193e5d6f901be0e7e1b9a236587ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GhhkqJMkGLvFGxhls7xIMA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">JSFiddle 中的项目结构</figcaption></figure><p id="db13" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在结果中看到<code class="fe lr ls lt lg b">input</code>出现了，但这不是我们现在感兴趣的。让我们看看 DOM:</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lv"><img src="../Images/df2f870043f58b2896fc9e7ea97d9368.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VD_5-AX6rJipTjQfvAf1Lw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">我们的过滤列表的 DOM</figcaption></figure><p id="4c05" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简化后，DOM 看起来像这样:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="6694" class="lk ll iq lg b gy lm ln l lo lp">&lt;body&gt;<br/>  &lt;div is="filtered-list"&gt;<br/>    #shadow-root (open)<br/>      &lt;input&gt;<br/>      &lt;ul&gt;&lt;/ul&gt;<br/>  &lt;/div&gt;<br/>&lt;/body&gt;</span></pre><p id="d08e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lr ls lt lg b">FilteredList</code>的影子 DOM 是包含在<code class="fe lr ls lt lg b">#shadow-root</code>节点中的所有内容。一个组件可以有一个单独的阴影 DOM，有些组件不能有它，比如 image 元素。可以是<code class="fe lr ls lt lg b">open</code>，意思是可以在 Javascript 中使用元素<code class="fe lr ls lt lg b">myCustomElement.shadowRoot</code>的<code class="fe lr ls lt lg b">shadowRoot</code>属性访问影子 DOM 内容，也可以是<code class="fe lr ls lt lg b">closed</code>，<code class="fe lr ls lt lg b">shadowRoot</code>返回<code class="fe lr ls lt lg b">null</code>。在这两种情况下，普通的 CSS 都无法定位影子 DOM 的内容。</p><h2 id="10af" class="lk ll iq bd lw lx ly dn lz ma mb dp mc ko md me mf ks mg mh mi kw mj mk ml mm bi translated">设计 web 组件的样式</h2><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mn"><img src="../Images/afd4947de8fc1238989da4f1378cbc73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fVtyert5UEZP-WbK"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@jeremythomasphoto?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杰瑞米·托马斯</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="60af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过向 shadow DOM 添加一个<code class="fe lr ls lt lg b">style</code>元素来添加样式:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="d595" class="lk ll iq lg b gy lm ln l lo lp">class FilteredList extends HTMLDivElement {<br/>  constructor() {<br/>    super();<br/><br/>    let shadow = this.attachShadow({ mode: 'open' });<br/>    let list = document.createElement('ul');<br/>    let input = document.createElement('input');<br/>    let style = document.createElement('style');</span><span id="eb2c" class="lk ll iq lg b gy lq ln l lo lp">    style.textContent = '.list { color: red; }';<br/>    list.classList.add('list');</span><span id="9906" class="lk ll iq lg b gy lq ln l lo lp">    shadow.appendChild(input);<br/>    shadow.appendChild(list);<br/>    shadow.appendChild(style);<br/>  }<br/>}</span><span id="592c" class="lk ll iq lg b gy lq ln l lo lp">customElements.define('filtered-list', FilteredList, { extends: 'div' });</span></pre><p id="0514" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将使我们能够在影子 DOM 中拥有一个<code class="fe lr ls lt lg b">&lt;style&gt;</code>节点，为 web 组件的内容提供 CSS 类。我们还可以使用 CSS 对象模型来提供样式:我们可以以任何我们想要的方式拥有组件，外部世界不能干涉。</p><p id="668c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是创建业务组件库的一个很好的方法，例如，我们希望所有公司应用程序的所有组件的外观都相同。在这种情况下，我们希望锁定样式，并防止其他人改变它。如果我们进一步想出售组件库并阻止其他人使用它们的内部组件，我们使用<code class="fe lr ls lt lg b">closed</code> shadow DOM。</p><p id="d620" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无论哪种方式，通常的 CSS 选择器都不能从组件外部接触到组件。这不行:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="7817" class="lk ll iq lg b gy lm ln l lo lp">&lt;style&gt;<br/>  .list input {<br/>    color: red;<br/>  }<br/>&lt;/style&gt;</span></pre><p id="f741" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于外界来说，<code class="fe lr ls lt lg b">FilteredList</code>中没有<code class="fe lr ls lt lg b">input</code>标签。为了让 CSS 样式化<code class="fe lr ls lt lg b">input</code>，组件必须首先通过将它导出为组件<code class="fe lr ls lt lg b">part</code>来允许它:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="4883" class="lk ll iq lg b gy lm ln l lo lp">class FilteredList extends HTMLDivElement {<br/>  constructor() {<br/>    super();<br/><br/>    let shadow = this.attachShadow({ mode: 'open' });<br/>    let list = document.createElement('ul');<br/>    let input = document.createElement('input');</span><span id="95d5" class="lk ll iq lg b gy lq ln l lo lp">    list.setAttribute('part', 'list');<br/>    input.setAttribute('part', 'input');</span><span id="733c" class="lk ll iq lg b gy lq ln l lo lp">    shadow.appendChild(input);<br/>    shadow.appendChild(list);<br/>  }<br/>}</span><span id="c737" class="lk ll iq lg b gy lq ln l lo lp">customElements.define('filtered-list', FilteredList, { extends: 'div' });</span></pre><p id="3439" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在组件将<code class="fe lr ls lt lg b">input</code>元素导出为<code class="fe lr ls lt lg b">input</code>部件，将<code class="fe lr ls lt lg b">ul</code>导出为<code class="fe lr ls lt lg b">list</code>部件。这样，我们可以使用 CSS 来设计这些部分的样式，如下所示:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="f1d0" class="lk ll iq lg b gy lm ln l lo lp">&lt;style&gt;<br/>  div::part(list) {<br/>    color: red;<br/>  }<br/>  div::part(input) {<br/>    color: blue;<br/>  }<br/>&lt;/style&gt;</span></pre><p id="6d6f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上述样式可以放在应用程序中任何地方的任何 CSS 文件中，它将成功地将导出的组件作为目标。不幸的是，如果你的 web 组件有可能包含其他 web 组件的模板，事情就变得复杂了，比如我们的<code class="fe lr ls lt lg b">CustomList</code>包含了一个<code class="fe lr ls lt lg b">ArticleListItem</code>。在这些情况下，主组件需要再次导出所包含组件的一部分，以使它们可以被访问，这就把我们带到了下一点。</p><h2 id="e6ef" class="lk ll iq bd lw lx ly dn lz ma mb dp mc ko md me mf ks mg mh mi kw mj mk ml mm bi translated">何时使用阴影 DOM</h2><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/54dd17dc72fcdbfea718c3584ddb3af1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*V9-92WzomXvnc4bf"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Clint Patterson 在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="4a06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要清楚地了解我们希望组件如何工作。没有必要总是隐藏他们的造型。例如，在我们的 RSS 阅读器中，出于几个原因，我特意为组件使用了简单的 CSS 样式。首先，我们不是在构建一个组件库:我们的组件只是其他 web 组件的混合。像<code class="fe lr ls lt lg b">CustomList</code>这样的其他组件甚至没有 UI:它只是向<code class="fe lr ls lt lg b">ul</code>元素添加了一些行为。</p><p id="4155" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种类型的复合 web 组件不一定符合封闭和受保护的部分。他们只是添加功能或混合现有组件。然而，如果我们为一组需要看起来相同的企业业务产品构建一个组件库，我们将从样式化列表、输入和其他标签开始，并将其隐藏在影子 DOM 中。通过这种方式，我们可以使用<code class="fe lr ls lt lg b">part</code>语法精确地控制我们想要留给定制样式的内容。</p><p id="d831" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样的事情也适用于<code class="fe lr ls lt lg b">open</code>或<code class="fe lr ls lt lg b">closed</code>阴影 DOM。如果您想密封您的组件，以便 Javascript 无法检测到它们，请使用<code class="fe lr ls lt lg b">closed</code> shadow DOM。这对于你想出售的私有组件或者像保存密码这样的私有功能非常有用。如果 Javascript 看不到影子 DOM 中包含私有信息的输入，那么该信息在组件中是安全的。</p><p id="f2f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有另一种可能，复制当前由 React 等框架引领的 Javascript 趋势，将样式包含在组件中。这也可以使用包含<code class="fe lr ls lt lg b">style</code>标签的<code class="fe lr ls lt lg b">closed</code> shadow DOM 来实现。所有的特性都在那里并且可以实现，只是不要简单地复制 React 或者只是封闭所有的组件:思考和计划，允许或不允许 CSS 根据你的需要来设计你的组件，而不是简单地跟随潮流。这基本上是整个 web 组件教程的目的。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><p id="1615" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这一部分到此结束，接下来是最后一部分，我们将在组件中加载 RSS 数据。这一次没有 Github 链接，这只是一篇展示 shadow DOM 的说明性文章，讨论它，并尝试设置在哪里以及如何使用它的例子。</p><p id="b7a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还(主要是不由自主地)上了一堂简短的(也许很无聊的)“生活/编码”课:不要只是跟风。不要因为有框架就使用框架。试着考虑你的应用程序，并应用最适合你的。它可以是 React，它可以与 Redux 反应，它可以与 React 路由器，Redux，Redux Thunk，React 动画和许多其他东西反应。或者它可以是一个只有 Javascript 的应用程序，带有 web 组件和本地模块。你说了算。浏览器已经支持这一切。web 组件教程到此结束，下次再见！</p></div></div>    
</body>
</html>