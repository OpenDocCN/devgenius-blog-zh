<html>
<head>
<title>Big O Notation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大 O 符号</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/big-o-notation-583adf20af1?source=collection_archive---------10-----------------------#2022-10-31">https://blog.devgenius.io/big-o-notation-583adf20af1?source=collection_archive---------10-----------------------#2022-10-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/2c40351f50bee54b28027127a175fc53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tf6zDFr1aVkz63lDKx60Rg.png"/></div></div></figure><p id="6a3b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">关于使用大 O 符号的算法分析和分类的基础文章。</p><h1 id="6f89" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">介绍</h1><p id="872e" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">一般来说，算法的度量有点难以估计，因为它不仅涉及到度量它的执行时间，还涉及到它所使用的资源的效率。</p><p id="7edc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当试图测量算法时，影响的一个基本因素是当前机器的处理器能力，这是因为在两台不同的机器上执行的相同算法将具有不同的结果，这取决于每台机器的能力。</p><h1 id="ee0a" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">大 O 符号</h1><p id="f059" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">大 O 记法是一种基本的数学形式，用于评估算法的复杂性，并对其效率进行分级。</p><p id="12d4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">大 O 符号抽象地表达了算法的处理速度，关注于执行时间会增加多少，这取决于输入数据的大小。结果，这将给出一条增长曲线，将时间作为大小的函数进行评估。</p><p id="7795" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要强调的另一个特征是，大 O 符号是一种渐近分析，它侧重于测量接近无穷大的极限，而不是小值，目的是方便一般分析。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lw"><img src="../Images/1f9d4fce4314c440ab2f0103af387926.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0FBi-Ogmrc9BKiKAuEKzug.jpeg"/></div></div></figure><h1 id="c84f" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">关键概念</h1><ul class=""><li id="baea" class="mb mc in jx b jy lr kc ls kg md kk me ko mf ks mg mh mi mj bi translated"><strong class="jx io">大“O”</strong>:字母 O 来源于对要分析的函数的数量级进行分类。</li><li id="c796" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated"><strong class="jx io"> O(1) </strong>:恒定时间，表示执行时间不会随着输入数据大小的增加而变化。无论输入幅度如何，响应都需要相同的时间。这是最好的分类之一。</li><li id="a6d7" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated"><strong class="jx io"> O(log n) </strong>:对数时间，意味着算法在开始时增长，但随着输入大小的增加而达到平台期。这对于算法来说是个好结果，因为它稳定了。</li><li id="674f" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated"><strong class="jx io"> O(n) </strong>:线性时间，这意味着执行时间与输入数据成正比。</li><li id="c440" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated"><strong class="jx io"> O(n2): </strong>二次时间，算法的增长是多项式。随着输入大小的增加，时间会变得非常长，运行的机器可能会因为大量的输入数据而缺乏资源。这是现存最糟糕的分类之一。</li><li id="0e59" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated"><strong class="jx io"> O(！n) </strong>:阶乘时间，算法的增长将是阶乘类型，这趋向于无法管理的值，因此是一条垂直线。毫无疑问，这是最糟糕的分类。</li></ul><h1 id="2bf5" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">一些基本代码分析的例子</h1><p id="d2f8" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">为了更好地理解大 O 符号，我们将展示一些支持对任何类型的算法进行分类的基本示例，强调算法中的一切都是根据大 O 进行分类的，包括变量的赋值。</p><p id="27c0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">注意</strong> 🧐:需要注意的是，如果算法有多种分类，我们总是会得到最差的复杂度。</p><h1 id="6322" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">O(1) —恒定复杂度</h1><pre class="lx ly lz ma gt mp mq mr ms aw mt bi"><span id="1fb9" class="mu ku in mq b gy mv mw l mx my">x = 1 + 1;  // <strong class="mq io">O(1)</strong><br/>y = x + 1;  // <strong class="mq io">O(1)</strong><br/>print(y);   // <strong class="mq io">O(1)</strong></span></pre><p id="9db9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的代码中，变量赋值不依赖于输入大小，因此它具有简单的复杂度，用 O(1)表示。执行分组时，会产生以下结果:</p><pre class="lx ly lz ma gt mp mq mr ms aw mt bi"><span id="82cf" class="mu ku in mq b gy mv mw l mx my">O(1) <strong class="mq io">+</strong> O(1) <strong class="mq io">+</strong> O(1) <strong class="mq io">=</strong> O(1)</span></pre><h1 id="37d7" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">O(n) —线性复杂度</h1><pre class="lx ly lz ma gt mp mq mr ms aw mt bi"><span id="6210" class="mu ku in mq b gy mv mw l mx my">for (int i = 0; i &lt; n; i++) {<br/>  print(arr[i]); //<strong class="mq io"> O(1)</strong><br/>}</span></pre><p id="4b31" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在前面的代码中，我们有一个已知复杂度为 O(1)的打印操作，但是，在这个操作中，我们不知道数组的大小，因此，我们可以得出结论，我们将打印值 O(1)N 次，也就是说，将产生以下结果:</p><pre class="lx ly lz ma gt mp mq mr ms aw mt bi"><span id="5901" class="mu ku in mq b gy mv mw l mx my">O(1) <strong class="mq io">*</strong> n <strong class="mq io">=</strong> O(n)</span></pre><h1 id="2c06" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">O(n2) —二次复杂度</h1><pre class="lx ly lz ma gt mp mq mr ms aw mt bi"><span id="8f57" class="mu ku in mq b gy mv mw l mx my">for (int i = 0; i &lt; n; i++) {<br/>  for (int j = 0; j &lt; k ; j++) {<br/>    print(m[i][j]); //<strong class="mq io"> O(1)</strong><br/>  }<br/>}</span></pre><p id="7cda" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在前面的代码中，我们有两个嵌套循环，我们已经知道每个循环都是 O(n ),因此 print O(1)操作乘以 2 N，也就是说，将产生以下结果:</p><pre class="lx ly lz ma gt mp mq mr ms aw mt bi"><span id="5452" class="mu ku in mq b gy mv mw l mx my">n * n * O(1) = O(n2)</span></pre></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><p id="c359" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">感谢你远道而来，如果你觉得这很有用，别忘了鼓掌👏。订阅以接收更多内容🔔。</p><p id="532c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你需要额外的帮助，请联系我🤠。</p><ul class=""><li id="60b4" class="mb mc in jx b jy jz kc kd kg ng kk nh ko ni ks mg mh mi mj bi translated">✉️ <a class="ae nj" href="mailto:dcortes.net@gmail.com" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">给我发邮件</strong> </a></li><li id="323a" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated">🤝<a class="ae nj" href="https://www.linkedin.com/in/dcortesnet/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">在 LinkedIn 上联系我</strong> </a></li><li id="cbe1" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated">📮<a class="ae nj" href="https://twitter.com/dcortes_net" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">在推特上联系我</strong> </a></li></ul><p id="2f97" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">非常感谢您的阅读，我感谢您的时间。</p></div></div>    
</body>
</html>