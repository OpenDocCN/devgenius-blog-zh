<html>
<head>
<title>Creating a React Calendar Component: Part 4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建 React 日历组件:第 4 部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/creating-a-react-calendar-component-part-4-d30fdc2e99e?source=collection_archive---------16-----------------------#2020-07-17">https://blog.devgenius.io/creating-a-react-calendar-component-part-4-d30fdc2e99e?source=collection_archive---------16-----------------------#2020-07-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><figure class="js jt ju jv gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi jr"><img src="../Images/c750b8a63057e1ae9f220e131a452313.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1C9Re2WLnzfQMJ5K.png"/></div></div></figure><p id="89b8" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">文件夹结构和代码布局与实际代码本身一样重要。干净的代码应该易读易懂。目标应该是让一个新人看一看你的代码，并且能够理解你的目的，而不需要深入代码的细节。同样，我喜欢用一种方式来组织我的文件和文件夹，这种方式可以很容易地浏览和理解哪些文件是相互关联的。</p><p id="37b6" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">在这一部分中，让我们添加两个功能，让用户可以很容易地看到哪个日期被选中，组件的用户能够访问该日期，然后查看日历组件的文件夹结构，然后</p></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><p id="40cc" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated"><strong class="kf io">第一部分:选定日期显示</strong></p><p id="d091" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">web 应用程序(任何相关的应用程序)最令人恼火的事情之一就是缺少指示器。如果用户不知道什么是选中的、加载的、禁用的或活动的，那么他们会感到困惑。正如大多数人所知，您可以尽可能多地测试任何 web 应用程序，只是让用户通过<code class="fe lb lc ld le b">dumb users</code>来挑选它。这是谬论。</p><p id="7e87" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">如果 web 应用程序没有指导用户正确地使用它，那么在创建时就严重缺乏 UI/UX 决策。当然，我不是 UI/UX 专家，但是和他们以及 QA 测试人员一起工作过，理解它的重要性。因此，让我们花一点时间添加一个由用户选择的日期指示。</p><p id="0576" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">下面是已完成组件的图像，我们现在要添加的是所选日期周围的圆圈。</p><p id="4afa" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">这是我们的<code class="fe lb lc ld le b">DateIndicator</code>的代码:</p><pre class="js jt ju jv gt lf le lg lh aw li bi"><span id="dab4" class="lj lk in le b gy ll lm l ln lo">import React from 'react';<br/>import {<br/>  getDayOfMonth,<br/>  getMonthDayYear,<br/>  getMonth,<br/>  getYear,<br/>} from '../utils/moment-utils';<br/>import { getDatesInMonthDisplay } from '../utils/date-utils';</span><span id="0f7c" class="lj lk in le b gy lp lm l ln lo">const DateIndicator = ({ activeDates, selectDate, setSelectDate }) =&gt; {<br/>  const changeDate = (e) =&gt; {<br/>    setSelectDate(e.target.getAttribute('data-date'));<br/>  };</span><span id="0108" class="lj lk in le b gy lp lm l ln lo">  const datesInMonth = getDatesInMonthDisplay(<br/>    getMonth(selectDate) + 1,<br/>    getYear(selectDate)<br/>  );</span><span id="9948" class="lj lk in le b gy lp lm l ln lo">  const monthDates = datesInMonth.map((i, key) =&gt; {<br/>    return (<br/>      &lt;div<br/>        className="date-icon"<br/>        data-active-month={i.currentMonth}<br/>        data-date={i.date.toString()}<br/>        key={key}<br/>        onClick={changeDate}<br/>      &gt;<br/>        {getDayOfMonth(i.date)}<br/>      &lt;/div&gt;<br/>    );<br/>  });</span><span id="946a" class="lj lk in le b gy lp lm l ln lo">return &lt;div className="bae-date-indicator"&gt;{monthDates}&lt;/div&gt;;<br/>};</span><span id="efd5" class="lj lk in le b gy lp lm l ln lo">export default DateIndicator;</span></pre><p id="5f0e" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">由于使用 CSS 在 HTML 元素上指定不同的样式只需要一个应用于属性的样式，我们将利用一个名为<code class="fe lb lc ld le b">selected</code>的类名。正在讨论的元素目前有一个类名叫做<code class="fe lb lc ld le b">date-icon</code>。但是没有规定说我不能再加了！</p><pre class="js jt ju jv gt lf le lg lh aw li bi"><span id="58f2" class="lj lk in le b gy ll lm l ln lo">// We want to add `className="date-icon selected"<br/>&lt;div<br/>  className="date-icon"<br/>  data-active-month={i.currentMonth}<br/>  data-date={i.date.toString()}<br/>  key={key}<br/>  onClick={changeDate}<br/>&gt;<br/>  {getDayOfMonth(i.date)}<br/>&lt;/div&gt;</span></pre><p id="8521" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">现在真正的问题是，我们如何确定选择了哪个日期，并且只将<code class="fe lb lc ld le b">selected</code>类名应用于正确的日期？良好的...这很简单。我们知道<code class="fe lb lc ld le b">selectDate</code>属性是由父组件跟踪的状态。幸运的是，这个组件可以访问它。当每个<code class="fe lb lc ld le b">monthDates</code>被构建时，我们可以做一个匹配，看看正在构建的<code class="fe lb lc ld le b">date</code>图标是否与<code class="fe lb lc ld le b">selectDate</code>匹配。但是，让我们想一想，我们实际上需要匹配哪些数据？</p><p id="aaf1" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">我对匹配日期对象本身犹豫不决，因为你永远不知道日期对象是否精确到毫秒。更不用说，我不知道当日期对象从一个时区移动到另一个时区时，它会如何表现。例如，如果我的数据库使用 UTC 时间，但最终用户使用 PST 时间，则 date 对象可能会根据时区而变化。通常，我们会将这些信息存储为一个字符串来防止这种情况，但是你永远不会知道。所以…我们将采取安全的路线，使用下面的函数和<code class="fe lb lc ld le b">MomentJs</code>将月、日和年作为一个字符串提取出来。</p><pre class="js jt ju jv gt lf le lg lh aw li bi"><span id="a8ba" class="lj lk in le b gy ll lm l ln lo">export const getMonthDayYear = (date) =&gt; moment(date).format('MM-DD-YYYY');</span></pre><p id="32f8" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">利用这一点，我们可以像这样进行匹配。</p><pre class="js jt ju jv gt lf le lg lh aw li bi"><span id="9dbf" class="lj lk in le b gy ll lm l ln lo">const selected = getMonthDayYear(selectDate) === getMonthDayYear(i.date) ? 'selected' : '';</span></pre><p id="c915" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">三元运算状态，如果<code class="fe lb lc ld le b">selectDate</code>的<code class="fe lb lc ld le b">MM-DD-YYYY</code>与另一个日期的<code class="fe lb lc ld le b">MM-DD-YYYY</code>匹配，那么变量<code class="fe lb lc ld le b">selected</code>将被赋予一个字符串值<code class="fe lb lc ld le b">selected</code>。否则，它将是一个空字符串。请注意，我们忽略了小时、分钟和秒钟，因为这些信息对于本特性来说并不重要。</p><p id="97b0" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">应用这个新的变化，让我们来看看完整的组件。</p><pre class="js jt ju jv gt lf le lg lh aw li bi"><span id="034f" class="lj lk in le b gy ll lm l ln lo">import React from 'react';<br/>import {<br/>  getDayOfMonth,<br/>  getMonthDayYear,<br/>  getMonth,<br/>  getYear,<br/>} from '../utils/moment-utils';<br/>import { getDatesInMonthDisplay } from '../utils/date-utils';</span><span id="5136" class="lj lk in le b gy lp lm l ln lo">const DateIndicator = ({ activeDates, selectDate, setSelectDate }) =&gt; {<br/>  const changeDate = (e) =&gt; {<br/>    setSelectDate(e.target.getAttribute('data-date'));<br/>  };</span><span id="4568" class="lj lk in le b gy lp lm l ln lo">  const datesInMonth = getDatesInMonthDisplay(<br/>    getMonth(selectDate) + 1,<br/>    getYear(selectDate)<br/>  );</span><span id="ec60" class="lj lk in le b gy lp lm l ln lo">  const monthDates = datesInMonth.map((i, key) =&gt; {<br/>    const selected =<br/>      getMonthDayYear(selectDate) === getMonthDayYear(i.date) ? 'selected' : '';</span><span id="77d4" class="lj lk in le b gy lp lm l ln lo">  return (<br/>      &lt;div<br/>        className={`date-icon ${selected}`}<br/>        data-active-month={i.currentMonth}<br/>        data-date={i.date.toString()}<br/>        key={key}<br/>        onClick={changeDate}<br/>      &gt;<br/>        {getDayOfMonth(i.date)}<br/>      &lt;/div&gt;<br/>    );<br/>  });</span><span id="acc9" class="lj lk in le b gy lp lm l ln lo">  return &lt;div className="bae-date-indicator"&gt;{monthDates}&lt;/div&gt;;<br/>};</span><span id="5f7d" class="lj lk in le b gy lp lm l ln lo">export default DateIndicator;</span></pre><p id="b370" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">如您所见，<code class="fe lb lc ld le b">className</code>现在是<code class="fe lb lc ld le b">className={</code>日期图标\${selected} <code class="fe lb lc ld le b">}</code>。如果日期匹配，它将追加字符串<code class="fe lb lc ld le b">selected</code>并添加另一个类名属性。从现在开始，让我们快速添加对样式文件的更改。</p><pre class="js jt ju jv gt lf le lg lh aw li bi"><span id="ddcc" class="lj lk in le b gy ll lm l ln lo">.date-icon {<br/>  display: flex;<br/>  justify-content: center;<br/>  justify-self: center;<br/>  align-items: center;<br/>  height: 25px;<br/>  width: 25px;<br/>  padding: 5px;<br/>  cursor: pointer;<br/>  &amp;[data-active-month='false'] {<br/>    color: rgba(0, 0, 0, 0.3);<br/>  }<br/>  &amp;.selected {<br/>    border-radius: 50%;<br/>    box-shadow: 0 0 3px rgba(0, 0, 0, 0.5);<br/>  }<br/>}</span></pre><p id="8bcf" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">在我们的主题文件中，来自<a class="ae lq" href="https://dev.to/bertbae/creating-a-react-calendar-component-part-2-1nep" rel="noopener ugc nofollow" target="_blank">第二部分</a>:</p><pre class="js jt ju jv gt lf le lg lh aw li bi"><span id="a200" class="lj lk in le b gy ll lm l ln lo">.bae-date-indicator {<br/>  .date-icon {<br/>    &amp;.active {<br/>      background-color: $secondaryColor;<br/>      color: $activeTextColor;<br/>    }<br/>    &amp;.selected {<br/>      background-color: $primaryColor;<br/>      color: $activeTextColor;<br/>    }<br/>  }<br/>}</span></pre><p id="8ea1" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">这样，你的组件就是交互式的了！但是如果不能将日期作为数据选择出来，那么交互组件有什么用呢？</p></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><p id="a3a9" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated"><strong class="kf io">第二部分:提取日期数据</strong></p><p id="57a9" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">这是一个相当简单的问题，但是如果你不熟悉一个叫做<code class="fe lb lc ld le b">callbacks</code>的东西，那么答案对你来说可能不是那么明显。当然，大多数程序员在他们工作的早期就理解回调，因为它经常被使用。我们要做的是利用回调来提取所选的日期。</p><p id="be40" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">主组件文件目前使用名为<code class="fe lb lc ld le b">useState</code>的 React 钩子。对于我们的下一个项目，我们需要拉进另一个名为<code class="fe lb lc ld le b">useEffect</code>的钩子。</p><pre class="js jt ju jv gt lf le lg lh aw li bi"><span id="135b" class="lj lk in le b gy ll lm l ln lo">import React, { useEffect, useState } from 'react';<br/>import { getToday } from './utils/moment-utils';<br/>import './bae-calendar.scss';</span><span id="766b" class="lj lk in le b gy lp lm l ln lo">import CalendarHeader from './components/calendar-header';<br/>import WeekdayIndicator from './components/weekday-indicator';<br/>import DateIndicator from './components/date-indicator';<br/>import MonthIndicator from './components/month-indicator';<br/>// <a class="ae lq" href="https://uicookies.com/html-calendar/" rel="noopener ugc nofollow" target="_blank">https://uicookies.com/html-calendar/</a></span><span id="de1e" class="lj lk in le b gy lp lm l ln lo">import { presetDateTracker } from './utils/date-utils';</span><span id="cbee" class="lj lk in le b gy lp lm l ln lo">const themes = {<br/>  salmon: 'salmon-theme',<br/>  monochrome: 'monochrome-theme',<br/>  rouge: 'rouge-theme',<br/>};</span><span id="5b05" class="lj lk in le b gy lp lm l ln lo">const BaeCalendar = ({ theme, activeDates, onDateSelect }) =&gt; {<br/>  const [selectDate, setSelectDate] = useState(getToday());</span><span id="64f7" class="lj lk in le b gy lp lm l ln lo">  return (<br/>    &lt;div className={`bae-calendar-container ${themes[theme]}`}&gt;<br/>      &lt;CalendarHeader selectDate={selectDate} /&gt;<br/>      &lt;WeekdayIndicator /&gt;<br/>      &lt;DateIndicator<br/>        activeDates={presetActiveDates.current}<br/>        selectDate={selectDate}<br/>        setSelectDate={setSelectDate}<br/>      /&gt;<br/>      &lt;MonthIndicator selectDate={selectDate} setSelectDate={setSelectDate} /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span><span id="9b00" class="lj lk in le b gy lp lm l ln lo">export default BaeCalendar;</span></pre><p id="c7ab" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">钩子<code class="fe lb lc ld le b">useEffect</code>类似于基于类的 react 中的<code class="fe lb lc ld le b">componentDidMount</code>和<code class="fe lb lc ld le b">componentDidUpdate</code>。看着上面的组件代码，我们来做一个小实验。我们将增加<code class="fe lb lc ld le b">useEffect</code>和<code class="fe lb lc ld le b">selectDate</code>中的<code class="fe lb lc ld le b">console.log</code>。</p><pre class="js jt ju jv gt lf le lg lh aw li bi"><span id="d197" class="lj lk in le b gy ll lm l ln lo">const BaeCalendar = ({ theme, activeDates, onDateSelect }) =&gt; {<br/>  const [selectDate, setSelectDate] = useState(getToday());</span><span id="56bf" class="lj lk in le b gy lp lm l ln lo">  useEffect(() =&gt; {<br/>    console.log(selectDate);<br/>  }, []);</span><span id="9795" class="lj lk in le b gy lp lm l ln lo">  return (<br/>    &lt;div className={`bae-calendar-container ${themes[theme]}`}&gt;<br/>      &lt;CalendarHeader selectDate={selectDate} /&gt;<br/>      &lt;WeekdayIndicator /&gt;<br/>      &lt;DateIndicator<br/>        activeDates={presetActiveDates.current}<br/>        selectDate={selectDate}<br/>        setSelectDate={setSelectDate}<br/>      /&gt;<br/>      &lt;MonthIndicator selectDate={selectDate} setSelectDate={setSelectDate} /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span><span id="a694" class="lj lk in le b gy lp lm l ln lo">export default BaeCalendar;</span></pre><p id="e853" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">太好了！我们看到日期记录在浏览器控制台上。但是，在使用该组件时，您会很快注意到后续的日期选择不会重新记录新选择的日期数据。这是怎么回事？</p><figure class="js jt ju jv gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi lr"><img src="../Images/9908b7ea2ecdd057d369c4c83bce9a51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wotXVSTFuv0YvLxDeuZ4rQ.png"/></div></div></figure><p id="d142" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">嗯，<code class="fe lb lc ld le b">useEffect</code>有第二个参数，它当前是一个空数组。进入这个数组的项目通常是我们想要跟踪的<code class="fe lb lc ld le b">state</code>。例如，如果我在下面添加以下内容，我们现在可以看到，选择日期会像我们希望的那样触发日志。</p><pre class="js jt ju jv gt lf le lg lh aw li bi"><span id="a9e7" class="lj lk in le b gy ll lm l ln lo">const BaeCalendar = ({ theme, activeDates, onDateSelect }) =&gt; {<br/>  const [selectDate, setSelectDate] = useState(getToday());</span><span id="1f0a" class="lj lk in le b gy lp lm l ln lo">  useEffect(() =&gt; {<br/>    console.log(selectDate);<br/>  }, [selectDate]);</span><span id="5e53" class="lj lk in le b gy lp lm l ln lo">  return (<br/>    &lt;div className={`bae-calendar-container ${themes[theme]}`}&gt;<br/>      &lt;CalendarHeader selectDate={selectDate} /&gt;<br/>      &lt;WeekdayIndicator /&gt;<br/>      &lt;DateIndicator<br/>        activeDates={presetActiveDates.current}<br/>        selectDate={selectDate}<br/>        setSelectDate={setSelectDate}<br/>      /&gt;<br/>      &lt;MonthIndicator selectDate={selectDate} setSelectDate={setSelectDate} /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span><span id="2c42" class="lj lk in le b gy lp lm l ln lo">export default BaeCalendar;</span></pre><p id="e916" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">本质上，您需要订阅<code class="fe lb lc ld le b">useEffect</code>来监听某些状态的变化。如果需要，您可以在一个组件中创建多个<code class="fe lb lc ld le b">useEffect</code>钩子来跟踪多个状态。出于我们的目的，因为我们只跟踪一个，我们只需要将一个带有<code class="fe lb lc ld le b">selectDate</code>的<code class="fe lb lc ld le b">useEffect</code>钩子添加到第二个参数的数组中。现在它应该是这样的。</p><figure class="js jt ju jv gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi ls"><img src="../Images/2a3a4cdb6a8923f73d9b892db939fded.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LjXh_jQb5BN2tSIuIql0Og.png"/></div></div></figure><p id="e866" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">这太棒了。现在我们知道有一种方法可以跟踪状态变化来获取数据。现在，我们如何让程序在组件之外访问这些信息？这就是回调的用武之地。</p><p id="6392" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">幸运的是，我们可以向组件中添加任意多的道具。所以，让我们像这样给我们的父组件添加一个名为<code class="fe lb lc ld le b">onDateSelect</code>的道具。</p><pre class="js jt ju jv gt lf le lg lh aw li bi"><span id="947d" class="lj lk in le b gy ll lm l ln lo">const BaeCalendar = ({ theme, activeDates, onDateSelect }) =&gt; {<br/>  const presetActiveDates = useRef(presetDateTracker(activeDates || []));<br/>  const [selectDate, setSelectDate] = useState(getToday());</span><span id="08ab" class="lj lk in le b gy lp lm l ln lo">  useEffect(() =&gt; {<br/>    if (onDateSelect) {<br/>      onDateSelect(selectDate);<br/>    }<br/>  }, [selectDate]);</span><span id="e33b" class="lj lk in le b gy lp lm l ln lo">  return (<br/>    &lt;div className={`bae-calendar-container ${themes[theme]}`}&gt;<br/>      &lt;CalendarHeader selectDate={selectDate} /&gt;<br/>      &lt;WeekdayIndicator /&gt;<br/>      &lt;DateIndicator<br/>        activeDates={presetActiveDates.current}<br/>        selectDate={selectDate}<br/>        setSelectDate={setSelectDate}<br/>      /&gt;<br/>      &lt;MonthIndicator selectDate={selectDate} setSelectDate={setSelectDate} /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="91af" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">正如你所看到的，在我们的<code class="fe lb lc ld le b">useEffect</code>钩子中，我们现在有一个<code class="fe lb lc ld le b">if</code>语句，如果它是真的(例如存在)，它就调用<code class="fe lb lc ld le b">onDateSelect</code> prop 函数。请注意，在正常情况下，您可能需要在这里更加具体，因为用户可能会传入<code class="fe lb lc ld le b">true</code>到这个属性，这会破坏组件。但是，让我们看看该组件在其他地方是如何使用的。</p><pre class="js jt ju jv gt lf le lg lh aw li bi"><span id="98e8" class="lj lk in le b gy ll lm l ln lo">&lt;BaeCalendar<br/>  theme="salmon"<br/>  onDateSelect={(date) =&gt; {<br/>    console.log(`The callback is accessing the date: ${date}`);<br/>    return date;<br/>  }}<br/>  activeDates={null}<br/>/&gt;</span></pre><p id="8dc3" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">如您所见，传入的回调函数可以在组件和<code class="fe lb lc ld le b">console.log</code>日期数据之外定义，在我们的浏览器日志中给出以下内容。简单吧？现在，该组件可以在表单中用于日期选择、日历或任何您想要创建的创意。在我们结束之前，作为开发人员，我们知道变化是不可避免的。因此，让我们看看组件文件夹和文件是如何组织的，以防我们以后需要修改或添加更多功能。</p><figure class="js jt ju jv gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi lt"><img src="../Images/0d38a84dcfeb8e53e5d195472a468f08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sqb7WTt-CxNFhMPh__HUFg.png"/></div></div></figure></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><p id="5509" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated"><strong class="kf io">第 3 节:组件的文件夹结构</strong></p><p id="2c9a" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">设计文件夹结构的方法有很多，通常，当你开始在一家公司工作时，这是你应该首先弄清楚的事情之一。团队维护的设计模式是所有团队成员签署的协议(即使做出决策时你不在)。也就是说，使用什么结构没有正确的答案。在大多数情况下，要使用的最佳设计或惯例取决于项目及其需求。</p><p id="5c99" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">对于这个小组件来说，文件夹结构非常简单。我们知道有一个<code class="fe lb lc ld le b">index.js</code>文件保存着根组件和 4 个子组件:</p><p id="2e48" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">我决定使用的文件夹结构是<a class="ae lq" href="https://reactjs.org/docs/faq-structure.html" rel="noopener ugc nofollow" target="_blank"> React 文档</a>中推荐的许多结构之一，它源于一种叫做原子设计的设计方法。原子设计的基本前提是相似的文件被分组在一起。在这种情况下，与日历组件相关的所有文件都被分组在一起。</p><p id="4c27" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">花几分钟时间看看图像中的文件夹结构。</p><figure class="js jt ju jv gt jw gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/434489d26b6b3a16713d2dcd46aac4ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/format:webp/1*79UpS2rRXuvt5KZX2qCZXQ.png"/></div></figure><p id="f11d" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">正如你所看到的，组件文件夹中的<code class="fe lb lc ld le b">root</code>是一个<code class="fe lb lc ld le b">index.js</code>和<code class="fe lb lc ld le b">bae-calendar.scss</code>文件。在它里面，有另一个包含日历子组件的<code class="fe lb lc ld le b">component</code>文件夹。紧挨着它们的是相关的样式文件。除此之外，还有 3 个文件夹叫做<code class="fe lb lc ld le b">constants</code>、<code class="fe lb lc ld le b">themes</code>和<code class="fe lb lc ld le b">utils</code>。让我们花一点时间来讨论为什么我喜欢这样构造我的组件文件。</p><h2 id="c096" class="lj lk in bd lv lw lx dn ly lz ma dp mb ko mc md me ks mf mg mh kw mi mj mk ml bi translated">按责任组织</h2><p id="6e22" class="pw-post-body-paragraph kd ke in kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ig bi translated">子组件在技术上仍然是组件。他们各有各的责任。进一步看，应该很容易看出什么文件/文件夹负责什么。<code class="fe lb lc ld le b">themes</code>文件夹只包含样式文件。它的职责显然是我们在本系列第 3 部分<a class="ae lq" href="https://dev.to/bertbae/creating-a-react-calendar-component-part-3-5b57" rel="noopener ugc nofollow" target="_blank">中添加的独立主题的样式。<code class="fe lb lc ld le b">constants</code>是我不希望动态改变的枚举数据集。<code class="fe lb lc ld le b">utils</code>是可重用的代码，可以被拉入任何组件中使用。花点时间想想<code class="fe lb lc ld le b">utils</code>文件里面可能有什么。回想一下在</a><a class="ae lq" href="https://dev.to/bertbae/creating-a-react-calendar-component-part-1-31j1" rel="noopener ugc nofollow" target="_blank">第 1 部分</a>和<a class="ae lq" href="https://dev.to/bertbae/creating-a-react-calendar-component-part-2-1nep" rel="noopener ugc nofollow" target="_blank">第 2 部分</a>中，我们创建了一些逻辑和日期格式。</p><h2 id="0210" class="lj lk in bd lv lw lx dn ly lz ma dp mb ko mc md me ks mf mg mh kw mi mj mk ml bi translated">容易找到</h2><p id="b8b4" class="pw-post-body-paragraph kd ke in kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ig bi translated">如果在任何时候，我需要对子组件或其相关样式进行修改，很容易找到需要进行更改的地方。文件的名称及其与相关文件的接近性意味着更少的点击和搜索。</p><h2 id="e705" class="lj lk in bd lv lw lx dn ly lz ma dp mb ko mc md me ks mf mg mh kw mi mj mk ml bi translated">易于移动</h2><p id="7177" class="pw-post-body-paragraph kd ke in kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ig bi translated">将来，如果我决定重用这段代码或者决定不再需要它并删除代码，我只需要在一个地方完成它。整个文件夹只包含与日历相关的代码。这意味着我可以删除或移动文件夹，而没有任何组件损坏的风险。我们正在确保编程的规则之一是<code class="fe lb lc ld le b">do not create side-effects</code>(尽可能)。</p></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><p id="3265" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">你能想到任何类似的模式吗？其中一个是 redux 推荐的叫做<code class="fe lb lc ld le b">duck</code>归档的东西。我就不赘述了，不过有兴趣的话可以多看看<a class="ae lq" href="http://bradfrost.com/blog/post/atomic-web-design/" rel="noopener ugc nofollow" target="_blank">原子设计</a>或者<a class="ae lq" href="https://medium.com/building-crowdriff/react-redux-file-architecture-ducks-it-up-6b32eaaba341" rel="noopener">鸭归档</a>。</p></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><p id="8661" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated"><strong class="kf io">包装东西</strong></p><p id="309e" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">首先，如果您已经阅读了该系列并发现这些信息很有帮助，请让我知道，并感谢您对这一过程的关注。编程是一个充满大量信息的疯狂之旅，但一次掌握少量信息会让我们更容易继续学习。我希望你考虑的一个挑战是给你的日历组件添加一个特性，允许其他人给它<code class="fe lb lc ld le b">pre-selected</code>日期。举个例子，如果程序员知道一个人在 2020 年有 10 件事，你会如何在日历上显示出来？</p><p id="24f5" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">为这个系列写这些是一次有趣的经历，我希望这些信息在某种程度上对你有益。如果你还有什么想知道的，请在下面留言。</p></div></div>    
</body>
</html>