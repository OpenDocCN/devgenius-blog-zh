<html>
<head>
<title>Let’s Build a Linux Shell — Part V</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们构建一个Linux Shell —第五部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/building-a-linux-shell-part-v-9cf3c0e31269?source=collection_archive---------4-----------------------#2020-08-03">https://blog.devgenius.io/building-a-linux-shell-part-v-9cf3c0e31269?source=collection_archive---------4-----------------------#2020-08-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/2db1a07234756fc5eb3674deaf5c90a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*X-_nBthmuN6WHiiC"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae jz" href="https://unsplash.com/@_imkiran?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Sai Kiran Anagani </a>拍摄的照片</figcaption></figure><p id="8694" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是关于如何构建Linux shell的教程的第五部分。可以从以下链接阅读本教程的前几部分:<a class="ae jz" href="https://medium.com/dev-genius/lets-build-a-linux-shell-part-i-954c95911501" rel="noopener">第一部分</a>、<a class="ae jz" href="https://medium.com/swlh/lets-build-a-linux-shell-part-ii-340ecf471028" rel="noopener">第二部分</a>、<a class="ae jz" href="https://medium.com/swlh/lets-build-a-linux-shell-part-iii-a472c0102849" rel="noopener">第三部分</a>、<a class="ae jz" href="https://medium.com/dev-genius/lets-build-a-linux-shell-part-iv-cefdd8f58138" rel="noopener">第四部分</a>。</p><p id="799c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">注意</strong>:你可以从<a class="ae jz" href="https://github.com/moisam/lets-build-a-linux-shell/tree/master/part5" rel="noopener ugc nofollow" target="_blank">这个GitHub库</a>下载第五部分的完整源代码。</p><h1 id="3fb1" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第五部分导言</h1><p id="f1c2" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">正如我们在前面的部分中看到的，一个简单的命令由一个或多个<strong class="kc io">参数</strong>组成，也称为<strong class="kc io">字</strong>。第一个单词包含我们要执行的命令的名称，而其余的单词包含命令的参数。</p><p id="165f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">shell执行命令之前，会对命令字进行<strong class="kc io">字扩展</strong>。<a class="ae jz" href="https://www.gnu.org/software/bash/manual/html_node/Shell-Expansions.html" rel="noopener ugc nofollow" target="_blank">字扩展</a>是shell获取一个命令字，检查它是否包含变量名、路径名、命令和算术表达式，并用它的值替换每个名称/命令/表达式的过程。生成的单词通常(但不总是)比原始单词长，可能会被分解成一个或多个子单词(或<strong class="kc io">字段</strong>)，这一过程称为<strong class="kc io">字段拆分</strong>。</p><p id="e800" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这一部分，我们将实现POSIX定义的7个字扩展，分别是:<a class="ae jz" href="https://www.gnu.org/software/bash/manual/html_node/Tilde-Expansion.html#Tilde-Expansion" rel="noopener ugc nofollow" target="_blank">波浪号扩展</a>、<a class="ae jz" href="https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html#Shell-Parameter-Expansion" rel="noopener ugc nofollow" target="_blank">参数扩展</a>、<a class="ae jz" href="https://www.gnu.org/software/bash/manual/html_node/Arithmetic-Expansion.html#Arithmetic-Expansion" rel="noopener ugc nofollow" target="_blank">算术扩展</a>、<a class="ae jz" href="https://www.gnu.org/software/bash/manual/html_node/Command-Substitution.html#Command-Substitution" rel="noopener ugc nofollow" target="_blank">命令替换</a>、<a class="ae jz" href="https://www.gnu.org/software/bash/manual/html_node/Word-Splitting.html#Word-Splitting" rel="noopener ugc nofollow" target="_blank">字段拆分</a>、<a class="ae jz" href="https://www.gnu.org/software/bash/manual/html_node/Filename-Expansion.html#Filename-Expansion" rel="noopener ugc nofollow" target="_blank">路径名扩展</a>和<a class="ae jz" href="https://www.gnu.org/software/bash/manual/html_node/Quote-Removal.html#Quote-Removal" rel="noopener ugc nofollow" target="_blank">引号移除</a>。还有其他的单词扩展，比如<a class="ae jz" href="https://www.gnu.org/software/bash/manual/html_node/Brace-Expansion.html#Brace-Expansion" rel="noopener ugc nofollow" target="_blank">括号扩展</a>和<a class="ae jz" href="https://www.gnu.org/software/bash/manual/html_node/Process-Substitution.html#Process-Substitution" rel="noopener ugc nofollow" target="_blank">进程替换</a>，POSIX没有定义，这里我们就不讨论了。学完本课后，如果您通过实现非POSIX word扩展来扩展shell，这将是一个很好的练习。</p><h1 id="be85" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">关于本课代码的注释</h1><p id="81f6" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">单词扩展过程非常复杂，为了在shell中执行单词扩展，我们必须实现许多函数。因此，我们不可能详细讨论每一个功能。相反，我们将对每个单词的扩展以及处理该扩展所需的函数有一个总体的概述。在每一节的末尾，你会找到一个到我们的<a class="ae jz" href="https://github.com/moisam/lets-build-a-linux-shell/tree/master/part5" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>的链接，在那里你可以按照自己的速度阅读整个函数的代码。</p><p id="1107" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们讨论完单个单词扩展函数之后，我们将编写将所有内容联系在一起的main函数，然后我们将更新我们现有的shell代码，使我们的shell使用我们刚刚实现的单词扩展函数。为了让代码更容易阅读，我在源文件<code class="fe mb mc md me b"><strong class="kc io">wordexp.c</strong></code>中定义了我们所有的单词扩展函数，你可以在<a class="ae jz" href="https://github.com/moisam/lets-build-a-linux-shell/tree/master/part5/wordexp.c" rel="noopener ugc nofollow" target="_blank">这个链接</a>中找到(模式匹配函数在<code class="fe mb mc md me b"><strong class="kc io">pattern.c</strong></code>中定义，你可以在<a class="ae jz" href="https://github.com/moisam/lets-build-a-linux-shell/tree/master/part5/pattern.c" rel="noopener ugc nofollow" target="_blank">这个链接</a>中读到)。</p><p id="092e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在让我们开始吧。</p><h1 id="4da7" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">单词扩展过程</h1><p id="9f93" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">当shell执行单词扩展时，它会检查命令行中的每个单词，看它是否包含可能的单词扩展。扩展可以出现在单词的任何地方:单词的开头、中间或结尾。扩展也可能包括整个单词。</p><p id="a080" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">单词扩展前面有一个<code class="fe mb mc md me b">$</code>符号。<code class="fe mb mc md me b">$</code>符号后面的字符表示外壳要执行的扩展类型。shell对这些字符的解释如下:</p><ul class=""><li id="1384" class="mf mg in kc b kd ke kh ki kl mh kp mi kt mj kx mk ml mm mn bi translated">一个或多个数字，表示<a class="ae jz" href="https://www.thegeekdiary.com/understanding-positional-parameters-passing-parameters-arguments-to-shell-script/" rel="noopener ugc nofollow" target="_blank">位置参数</a>的变量扩展(我们将在本教程的后续课程中讨论)。</li><li id="4886" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated"><code class="fe mb mc md me b">@</code>、<code class="fe mb mc md me b">*</code>、<code class="fe mb mc md me b">#</code>、<code class="fe mb mc md me b">?</code>、<code class="fe mb mc md me b">-</code>、<code class="fe mb mc md me b">$</code>、<code class="fe mb mc md me b">!</code>或<code class="fe mb mc md me b">0</code>中的一个，表示<a class="ae jz" href="https://www.gnu.org/software/bash/manual/html_node/Special-Parameters.html" rel="noopener ugc nofollow" target="_blank">特殊参数</a>的变量扩展(我们将在本教程后面的课程中讨论)。</li><li id="b391" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">一个或多个字母数字字符和/或下划线，以字母或下划线开头，表示shell变量名。</li><li id="7037" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">用花括号<code class="fe mb mc md me b">{</code>和<code class="fe mb mc md me b">}</code>包围的变量名。</li><li id="2330" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">一个算术展开，被<code class="fe mb mc md me b">(</code>和<code class="fe mb mc md me b">)</code>包围。</li><li id="603f" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">一个命令替换，被<code class="fe mb mc md me b">((</code>和<code class="fe mb mc md me b">))</code>包围。</li></ul><p id="1781" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">shell首先执行波浪号扩展、参数扩展、命令替换和算术扩展，然后是字段拆分和路径名扩展。最后，shell从扩展的单词中删除任何引用字符，这些字符是原始单词的一部分。</p><h1 id="16e5" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">使用单词</h1><p id="7672" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">当shell执行单词扩展时，该过程可以产生零个、一个或多个单词。我们将使用一个特殊的结构来表示这些单词，我们将在头文件<code class="fe mb mc md me b"><a class="ae jz" href="https://github.com/moisam/lets-build-a-linux-shell/tree/master/part5/shell.h" rel="noopener ugc nofollow" target="_blank"><strong class="kc io">shell.h</strong></a></code>中定义它:</p><pre class="mt mu mv mw gt mx me my mz aw na bi"><span id="3eb4" class="nb kz in me b gy nc nd l ne nf">struct <strong class="me io">word_s</strong><br/>{<br/>    char  *<strong class="me io">data</strong>;<br/>    int    <strong class="me io">len</strong>;<br/>    struct word_s *<strong class="me io">next</strong>;<br/>};</span></pre><p id="f140" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该结构包含以下字段:</p><ul class=""><li id="0106" class="mf mg in kc b kd ke kh ki kl mh kp mi kt mj kx mk ml mm mn bi translated"><code class="fe mb mc md me b">data</code> = &gt;代表这个单词的字符串。</li><li id="1b3f" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated"><code class="fe mb mc md me b">len</code>=&gt;<code class="fe mb mc md me b">data</code>字段的长度。</li><li id="6aad" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated"><code class="fe mb mc md me b">next</code> = &gt;指向下一个单词的指针，或者<code class="fe mb mc md me b">NULL</code>如果这是最后一个单词(我们将使用一个链表来表示我们扩展的单词)。</li></ul><p id="43bc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当然，我们需要一些函数来分配和释放我们的<code class="fe mb mc md me b">struct word_s</code>结构。为此，我们将使用以下函数:</p><pre class="mt mu mv mw gt mx me my mz aw na bi"><span id="b139" class="nb kz in me b gy nc nd l ne nf">struct word_s *<strong class="me io">make_word</strong>(char *<strong class="me io">str</strong>);<br/>void <strong class="me io">free_all_words</strong>(struct word_s *<strong class="me io">first</strong>);</span></pre><p id="b9ba" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第一个函数为结构分配内存，创建单词字符串的副本，并返回新分配的单词。第二个函数释放单词结构列表使用的内存。你可以在我们的<code class="fe mb mc md me b"><strong class="kc io">wordexp.c</strong></code> <a class="ae jz" href="https://github.com/moisam/lets-build-a-linux-shell/tree/master/part5/wordexp.c" rel="noopener ugc nofollow" target="_blank">源文件</a>中读取这些函数的代码。</p><h1 id="278b" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">定义一些助手函数</h1><p id="878e" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">正如我们前面说过的，单词扩展是一个复杂的过程，为此我们需要定义许多不同的函数。在我们深入到单词扩展的细节之前，让我们首先定义一些辅助函数。</p><p id="ce9e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面的列表显示了我们助手函数的函数原型，我们将在<code class="fe mb mc md me b"><strong class="kc io">wordexp.c</strong></code> <a class="ae jz" href="https://github.com/moisam/lets-build-a-linux-shell/tree/master/part5/wordexp.c" rel="noopener ugc nofollow" target="_blank">源文件</a>中定义所有这些函数原型:</p><pre class="mt mu mv mw gt mx me my mz aw na bi"><span id="ce85" class="nb kz in me b gy nc nd l ne nf">char *<strong class="me io">wordlist_to_str</strong>(struct word_s *<strong class="me io">word</strong>);<br/>void <strong class="me io">delete_char_at</strong>(char *<strong class="me io">str</strong>, size_t <strong class="me io">index</strong>);<br/>int <strong class="me io">is_name</strong>(char *<strong class="me io">str</strong>);<br/>size_t <strong class="me io">find_closing_quote</strong>(char *<strong class="me io">data</strong>);<br/>size_t <strong class="me io">find_closing_brace</strong>(char *<strong class="me io">data</strong>);<br/>char *<strong class="me io">substitute_str</strong>(char *<strong class="me io">s1</strong>, char *<strong class="me io">s2</strong>, size_t <strong class="me io">start</strong>, size_t <strong class="me io">end</strong>);<br/>int <strong class="me io">substitute_word</strong>(char **<strong class="me io">pstart</strong>, char **<strong class="me io">p</strong>, size_t <strong class="me io">len</strong>, char *(<strong class="me io">func</strong>)(char *), int <strong class="me io">add_quotes</strong>);</span></pre><p id="14ae" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是这些功能的详细说明:</p><ul class=""><li id="87de" class="mf mg in kc b kd ke kh ki kl mh kp mi kt mj kx mk ml mm mn bi translated"><code class="fe mb mc md me b">wordlist_to_str()</code> = &gt;将扩展单词的链接列表转换为单个字符串。</li><li id="e74e" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated"><code class="fe mb mc md me b">delete_char_at()</code> = &gt;从字符串中移除给定索引处的字符。</li><li id="07e2" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated"><code class="fe mb mc md me b">is_name()</code> = &gt;检查一个字符串是否代表一个有效的变量名(参考上文<strong class="kc io">单词扩展过程</strong>部分)。</li><li id="5264" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated"><code class="fe mb mc md me b">find_closing_quote()</code> = &gt;当一个单词扩展包含一个开始引用字符(<code class="fe mb mc md me b">"</code>、<code class="fe mb mc md me b">'</code>或<code class="fe mb mc md me b">`</code>)时，我们需要找到包含引用字符串的匹配结束引用字符(下面有更多关于引用的内容)。该函数返回单词中右引号字符的从零开始的索引。</li><li id="46a1" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated"><code class="fe mb mc md me b">find_closing_brace()</code> = &gt;与上面类似，除了它找到匹配的右括号。也就是说，如果左大括号是<code class="fe mb mc md me b">{</code>、<code class="fe mb mc md me b">(</code>或<code class="fe mb mc md me b">[</code>，该函数将分别返回匹配的<code class="fe mb mc md me b">}</code>、<code class="fe mb mc md me b">)</code>或<code class="fe mb mc md me b">]</code>字符的从零开始的索引。找到引号对对于处理参数扩展、算术扩展和命令替换非常重要。</li><li id="2a6b" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated"><code class="fe mb mc md me b">substitute_str()</code> = &gt;用<code class="fe mb mc md me b">s2</code>字符串替换<code class="fe mb mc md me b">s1</code>的子字符串，从位置<code class="fe mb mc md me b">start</code>到位置<code class="fe mb mc md me b">end</code>(两个位置都是从零开始的)。当单词expansion是一个较长单词的一部分时，例如<code class="fe mb mc md me b">${PATH}/ls</code>，这是很有用的，在这种情况下，我们只需要扩展<code class="fe mb mc md me b">${PATH}</code>，然后将<code class="fe mb mc md me b">/ls</code>附加到扩展字符串的末尾。</li><li id="8d21" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">调用其他单词扩展函数的辅助函数，我们将在下面的部分中定义。</li></ul><p id="8efa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此外，我们将定义一些函数来帮助我们处理字符串。我们将在源文件中定义所有这些函数:</p><pre class="mt mu mv mw gt mx me my mz aw na bi"><span id="ee18" class="nb kz in me b gy nc nd l ne nf">char   *<strong class="me io">strchr_any</strong>(char *<strong class="me io">string</strong>, char *<strong class="me io">chars</strong>);<br/>char   *<strong class="me io">quote_val</strong>(char *<strong class="me io">val</strong>, int <strong class="me io">add_quotes</strong>);<br/>int     <strong class="me io">check_buffer_bounds</strong>(int *<strong class="me io">count</strong>, int *<strong class="me io">len</strong>, char ***<strong class="me io">buf</strong>);<br/>void    <strong class="me io">free_buffer</strong>(int <strong class="me io">len</strong>, char **<strong class="me io">buf</strong>);</span></pre><p id="5c12" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这些函数的作用如下:</p><ul class=""><li id="3d83" class="mf mg in kc b kd ke kh ki kl mh kp mi kt mj kx mk ml mm mn bi translated"><code class="fe mb mc md me b">strchr_any()</code> = &gt;类似于<code class="fe mb mc md me b"><a class="ae jz" href="https://pubs.opengroup.org/onlinepubs/009695399/functions/strchr.html" rel="noopener ugc nofollow" target="_blank">strchr()</a></code>，除了它在给定的字符串中搜索任何给定的字符。</li><li id="09c2" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated"><code class="fe mb mc md me b">quote_val()</code> = &gt;执行引号删除的反向操作，即将一个字符串转换为带引号的字符串(这起初看起来可能很简单，但是当我们必须对引号和反斜杠字符进行转义时，引用可能会变得复杂)。</li><li id="ee9b" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated"><code class="fe mb mc md me b">check_buffer_bounds()</code>和<code class="fe mb mc md me b">free_buffer()</code>函数将允许我们的后端执行器支持可变数量的命令参数，而不是我们在<a class="ae jz" href="https://medium.com/swlh/lets-build-a-linux-shell-part-ii-340ecf471028" rel="noopener">第二部分</a>中设置的255个硬限制。</li></ul><p id="39ef" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在让我们编写函数来处理每种类型的单词扩展。</p><h1 id="0553" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">波浪号展开</h1><p id="f5b0" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">在<a class="ae jz" href="https://www.gnu.org/software/bash/manual/html_node/Tilde-Expansion.html#Tilde-Expansion" rel="noopener ugc nofollow" target="_blank">波浪号扩展</a>期间，shell用用户主目录的路径名替换波浪号字符(后跟可选用户名)。例如，<code class="fe mb mc md me b">~</code>和<code class="fe mb mc md me b">~/</code>被波浪号展开到当前用户的主目录，而<code class="fe mb mc md me b">~john</code>被波浪号展开到用户John的主目录，等等。除了第一个未加引号的正斜杠之前的所有后续字符之外，波浪号字符被称为<strong class="kc io">波浪号前缀</strong>(我们将在本课稍后处理引用问题)。</p><p id="a00a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了执行波浪号扩展，我们将定义<code class="fe mb mc md me b"><strong class="kc io">tilde_expand()</strong></code>函数，它具有以下原型:</p><pre class="mt mu mv mw gt mx me my mz aw na bi"><span id="952d" class="nb kz in me b gy nc nd l ne nf">char *<strong class="me io">tilde_expand</strong>(char *<strong class="me io">s</strong>);</span></pre><p id="4427" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该函数接受一个参数:我们要扩展的波浪号前缀。如果扩展成功，该函数返回一个代表波浪号扩展前缀的<a class="ae jz" href="https://pubs.opengroup.org/onlinepubs/000095399/functions/malloc.html" rel="noopener ugc nofollow" target="_blank">malloc</a>d字符串。否则返回<code class="fe mb mc md me b">NULL</code>。下面是该函数为了扩展波浪号前缀所做工作的快速分解:</p><ul class=""><li id="eae8" class="mf mg in kc b kd ke kh ki kl mh kp mi kt mj kx mk ml mm mn bi translated">如果前缀是<code class="fe mb mc md me b">~</code>，则获取<code class="fe mb mc md me b">$HOME</code> shell变量的值。如果定义了<code class="fe mb mc md me b">$HOME</code>，但不是<code class="fe mb mc md me b">NULL</code>，则返回其值。否则，通过调用<code class="fe mb mc md me b"><a class="ae jz" href="https://pubs.opengroup.org/onlinepubs/009695399/functions/getuid.html" rel="noopener ugc nofollow" target="_blank">getuid()</a></code>获取当前<strong class="kc io">用户ID </strong> ( <strong class="kc io"> UID </strong>)，并将UID传递给<code class="fe mb mc md me b"><a class="ae jz" href="https://pubs.opengroup.org/onlinepubs/009695399/functions/getpwuid.html" rel="noopener ugc nofollow" target="_blank">getpwuid()</a></code>获取当前用户对应的<a class="ae jz" href="https://www.tutorialspoint.com/accessing-the-unix-linux-password-database-pwd" rel="noopener ugc nofollow" target="_blank">密码数据库条目</a>。密码数据库条目的<code class="fe mb mc md me b">pw_dir</code>字段包含函数返回的主目录的路径名。</li><li id="7656" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">如果前缀包含其他字符(除了前导的<code class="fe mb mc md me b">~</code>)，我们将这些字母作为我们想要获得其主目录的用户的名称。我们调用<code class="fe mb mc md me b"><a class="ae jz" href="https://pubs.opengroup.org/onlinepubs/009695399/functions/getpwnam.html" rel="noopener ugc nofollow" target="_blank">getpwnam()</a></code>，向其传递用户名，并返回<code class="fe mb mc md me b">pw_dir</code>字段的值。</li><li id="d314" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">如果我们不能检索主目录(例如，如果用户名无效)，我们返回<code class="fe mb mc md me b">NULL</code>。否则，我们返回一个主目录路径的malloc副本。</li></ul><p id="39ac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">花点时间阅读一下我们<a class="ae jz" href="https://github.com/moisam/lets-build-a-linux-shell/tree/master/part5/wordexp.c" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中的<code class="fe mb mc md me b"><strong class="kc io">tilde_expand()</strong></code>函数代码。</p><h1 id="963c" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">参数扩展</h1><p id="d813" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">在<a class="ae jz" href="https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html#Shell-Parameter-Expansion" rel="noopener ugc nofollow" target="_blank">参数扩展</a>中，shell用变量的值替换了一个shell变量的名称(因此有了另一个名字<strong class="kc io">变量扩展</strong>)。参数扩展允许shell执行一个命令，比如<code class="fe mb mc md me b">echo $PATH</code>。在这个例子中，shell对<code class="fe mb mc md me b">$PATH</code>变量执行参数扩展，用实际的可执行路径(类似于<code class="fe mb mc md me b">/bin:/sbin:/usr/bin:/usr/sbin</code>)替换它。<code class="fe mb mc md me b">echo</code>命令看到的不是<code class="fe mb mc md me b">$PATH</code>字，而是它的扩展值(当然也可以是<code class="fe mb mc md me b">NULL</code>)。</p><p id="e72c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了通知shell我们想要扩展一个shell变量，我们在变量名前面加了一个<code class="fe mb mc md me b">$</code>符号。也就是说，为了扩展<code class="fe mb mc md me b">PATH</code>、<code class="fe mb mc md me b">USER</code>和<code class="fe mb mc md me b">SHELL</code>变量，我们需要分别将<code class="fe mb mc md me b">$PATH</code>、<code class="fe mb mc md me b">$USER</code>和<code class="fe mb mc md me b">$SHELL</code>字传递给shell(或者，我们可以将这些变量扩展作为<code class="fe mb mc md me b">${PATH}</code>、<code class="fe mb mc md me b">${USER}</code>和<code class="fe mb mc md me b">${SHELL}</code>传递给shell)。Shell变量名可以包含字母、数字和下划线的任意组合。名字可以包含大写或小写字母，尽管按照惯例，大写的名字是为标准shell变量保留的，比如那些由POSIX 定义的<a class="ae jz" href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_05_03" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="2b82" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以通过使用参数扩展修饰符来控制shell如何执行参数扩展，参数扩展修饰符告诉shell我们希望扩展值的哪一部分，以及如果没有具有给定名称的shell变量时该怎么做。下表总结了参数扩展修饰符(由POSIX 定义的那些<a class="ae jz" href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_02" rel="noopener ugc nofollow" target="_blank">在<strong class="kc io">描述</strong>列中用POSIX字标记)。大多数shells支持其他修饰符(在表的下半部分)，我们在这里不讨论。有关非POSIX修饰符的更多信息，请参考shell的手册页。</a></p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ng"><img src="../Images/64d39fceaf96fe0bd4d84972b267a679.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zSb9EH_gkbTM9PE9"/></div></div></figure><p id="53d3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了执行参数(或变量)扩展，我们将定义<code class="fe mb mc md me b"><strong class="kc io">var_expand()</strong></code>函数，其原型如下:</p><pre class="mt mu mv mw gt mx me my mz aw na bi"><span id="d914" class="nb kz in me b gy nc nd l ne nf">char *<strong class="me io">var_expand</strong>(char *<strong class="me io">orig_var_name</strong>);</span></pre><p id="caaa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该函数接受一个参数:我们想要扩展的参数(即变量名)。如果扩展成功，该函数返回一个包含扩展值的<a class="ae jz" href="https://pubs.opengroup.org/onlinepubs/000095399/functions/malloc.html" rel="noopener ugc nofollow" target="_blank">malloc</a>d字符串。否则返回<code class="fe mb mc md me b">NULL</code>。下面是该函数为了扩展变量名以获取其值所做工作的快速分解:</p><ul class=""><li id="dd0c" class="mf mg in kc b kd ke kh ki kl mh kp mi kt mj kx mk ml mm mn bi translated">如果变量名用花括号括起来(例如，<code class="fe mb mc md me b">${PATH}</code>，去掉花括号，因为它们不是变量名本身的一部分。</li><li id="bc2c" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">如果名称以<code class="fe mb mc md me b">#</code>开头，我们需要得到变量名的长度(上表第5行的<code class="fe mb mc md me b">${#parameter}</code>扩展)。</li><li id="be64" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">如果变量名包含一个冒号，我们将使用它来分隔名称和(可选的)单词或模式。如上表所示使用单词或模式。</li><li id="c454" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">获取具有给定变量名的符号表条目(我们在<a class="ae jz" href="https://medium.com/dev-genius/lets-build-a-linux-shell-part-iv-cefdd8f58138" rel="noopener">第四部分</a>中实现了符号表堆栈)。获取符号表条目的值。</li><li id="d759" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">如果值为空或null，则使用扩展中提供的替代单词(如果有)。</li><li id="2c9c" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">如果值不为空，则使用该值作为扩展结果。为了使shell能够执行模式匹配(<code class="fe mb mc md me b">${parameter#word}</code>和<code class="fe mb mc md me b">${parameter%word}</code>扩展)，我们需要两个助手函数:<code class="fe mb mc md me b"><strong class="kc io">match_suffix()</strong></code>和<code class="fe mb mc md me b"><strong class="kc io">match_prefix()</strong></code>。我们在这里不讨论这些函数，但是你可以从<a class="ae jz" href="https://github.com/moisam/lets-build-a-linux-shell/tree/master/part5/pattern.c" rel="noopener ugc nofollow" target="_blank">这个链接</a>中读到它们的代码。</li><li id="d655" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">如果扩展修饰符是<code class="fe mb mc md me b">${parameter:=word}</code>，我们需要将符号表条目的值设置为我们刚刚扩展的值。</li><li id="67a1" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">如果展开以<code class="fe mb mc md me b">#</code>开始，则获取展开值的长度，并将其作为最终结果。</li><li id="1a60" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">根据需要，返回扩展值的一个<a class="ae jz" href="https://pubs.opengroup.org/onlinepubs/000095399/functions/malloc.html" rel="noopener ugc nofollow" target="_blank">malloc</a>d副本，或其长度(字符串格式)。</li></ul><p id="d8af" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">花点时间阅读一下我们的<a class="ae jz" href="https://github.com/moisam/lets-build-a-linux-shell/tree/master/part5/wordexp.c" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中的<code class="fe mb mc md me b"><strong class="kc io">var_expand()</strong></code>函数代码。</p><h1 id="6551" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">命令替换</h1><p id="831a" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">在<a class="ae jz" href="https://www.gnu.org/software/bash/manual/html_node/Command-Substitution.html#Command-Substitution" rel="noopener ugc nofollow" target="_blank">命令替换</a>中，shell派生一个进程来运行命令，然后用命令的输出替换命令替换扩展。例如，在下面的循环中:</p><pre class="mt mu mv mw gt mx me my mz aw na bi"><span id="f84a" class="nb kz in me b gy nc nd l ne nf">for i in $(ls); do echo $i; done</span></pre><p id="4ba0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">shell派生出一个进程，在这个进程中运行<code class="fe mb mc md me b">ls</code>命令。该命令的输出是当前目录中的文件列表。shell获取输出，将其拆分成一个单词列表，然后将这些单词一次一个地输入到循环中。在循环的每次迭代中，变量<code class="fe mb mc md me b">$i</code>被赋予列表中下一个文件的名称。该名称被传递给<code class="fe mb mc md me b">echo</code>命令，该命令在单独的行上输出该名称(实际上，直接执行<code class="fe mb mc md me b">ls</code>会更好，但是这个示例只是为了展示如何在shell中使用命令替换)。</p><p id="2a33" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">命令替换可以写成<code class="fe mb mc md me b">$(command)</code>，或者<code class="fe mb mc md me b">`command`</code>。为了执行命令替换，我们将定义<code class="fe mb mc md me b"><strong class="kc io">command_substitute()</strong></code>函数，其原型如下:</p><pre class="mt mu mv mw gt mx me my mz aw na bi"><span id="8736" class="nb kz in me b gy nc nd l ne nf">char *<strong class="me io">command_substitute</strong>(char *<strong class="me io">orig_cmd</strong>);</span></pre><p id="3de3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该函数接受一个参数:我们要执行的命令。如果扩展成功，该函数返回一个代表命令输出的<a class="ae jz" href="https://pubs.opengroup.org/onlinepubs/000095399/functions/malloc.html" rel="noopener ugc nofollow" target="_blank">malloc</a>d字符串。如果扩展失败，或者如果命令不输出任何内容，函数返回<code class="fe mb mc md me b">NULL</code>。为了扩展命令替换，下面是该函数的快速分解:</p><ul class=""><li id="5f2c" class="mf mg in kc b kd ke kh ki kl mh kp mi kt mj kx mk ml mm mn bi translated">根据使用的格式，我们首先删除<code class="fe mb mc md me b">$()</code>或反引号<code class="fe mb mc md me b">``</code>。这留给我们需要执行的命令。</li><li id="5d51" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">调用<code class="fe mb mc md me b"><a class="ae jz" href="https://pubs.opengroup.org/onlinepubs/009695399/functions/popen.html" rel="noopener ugc nofollow" target="_blank">popen()</a></code>创建一个管道。我们将待执行的命令传递给<code class="fe mb mc md me b">popen()</code>，并获得一个指向<code class="fe mb mc md me b">FILE</code>流的指针，我们将从中读取命令的输出。</li><li id="f85f" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">调用<code class="fe mb mc md me b"><a class="ae jz" href="https://pubs.opengroup.org/onlinepubs/009695399/functions/fread.html" rel="noopener ugc nofollow" target="_blank">fread()</a></code>从管道中读取命令的输出。将读取的字符串存储在缓冲区中。</li><li id="9981" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">删除任何尾随换行符。</li><li id="42c5" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">关闭管道并用命令输出返回缓冲区。</li></ul><p id="f470" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">花点时间阅读一下我们的<a class="ae jz" href="https://github.com/moisam/lets-build-a-linux-shell/tree/master/part5/wordexp.c" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中的<code class="fe mb mc md me b"><strong class="kc io">command_substitute()</strong></code>函数的代码。</p><h1 id="2512" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">算术扩展</h1><p id="22b1" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">使用<a class="ae jz" href="https://www.gnu.org/software/bash/manual/html_node/Arithmetic-Expansion.html#Arithmetic-Expansion" rel="noopener ugc nofollow" target="_blank">算术扩展</a>，我们可以让shell执行不同的算术运算，并将结果用于执行其他命令。虽然POSIX要求shell只支持带符号的长整数运算，但是许多shell(例如<a class="ae jz" href="https://linux.die.net/man/1/ksh" rel="noopener ugc nofollow" target="_blank"> ksh </a>和<a class="ae jz" href="https://linux.die.net/man/1/zsh" rel="noopener ugc nofollow" target="_blank"> zsh </a>)都支持浮点运算。此外，不要求shell支持任何数学函数，尽管大多数shell都支持。对于我们的简单shell，我们只支持带符号的长整数运算，不支持数学函数。</p><p id="2a84" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">算术展开写成<code class="fe mb mc md me b">$((expression))</code>。为了执行扩展，我们将定义<code class="fe mb mc md me b"><strong class="kc io">arithm_expand()</strong></code>函数，其原型如下:</p><pre class="mt mu mv mw gt mx me my mz aw na bi"><span id="d010" class="nb kz in me b gy nc nd l ne nf">char *<strong class="me io">arithm_expand</strong>(char *<strong class="me io">expr</strong>);</span></pre><p id="cb10" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mb mc md me b"><strong class="kc io">arithm_expand()</strong></code>函数接收包含算术表达式的字符串，执行必要的计算，并以<a class="ae jz" href="https://pubs.opengroup.org/onlinepubs/000095399/functions/malloc.html" rel="noopener ugc nofollow" target="_blank">malloc</a>d字符串的形式返回结果(如果出现错误，例如无效的算术运算，则返回<code class="fe mb mc md me b">NULL</code>)。该函数及其相关的辅助函数既复杂又冗长，但以下是主要亮点:</p><ul class=""><li id="a468" class="mf mg in kc b kd ke kh ki kl mh kp mi kt mj kx mk ml mm mn bi translated">算术表达式转换成<a class="ae jz" href="https://en.wikipedia.org/wiki/Reverse_Polish_notation" rel="noopener ugc nofollow" target="_blank">反向波兰符号</a> (RPN)，更容易解析和计算。RPN由一系列算术运算组成，其中运算符跟随(即跟随)其操作数。比如<code class="fe mb mc md me b">x - y</code>的RPN是<code class="fe mb mc md me b">x y -</code>，而<code class="fe mb mc md me b">3 + 4 × (2 − 1)</code>的RPN是<code class="fe mb mc md me b">3 4 2 1 − × +</code>。</li><li id="ad7b" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">在转换过程中，算术运算符被推送到一个运算符堆栈上，我们将从中弹出每个运算符，并在稍后执行其运算。类似地，操作数被添加到它们自己的堆栈中。</li><li id="2a3b" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">运算符从堆栈中弹出，一次弹出一个，并检查该运算符。根据运算符的类型，从堆栈中弹出一个或两个操作数。管理这个过程的规则是调车场算法，你可以在这里读到<a class="ae jz" href="https://en.wikipedia.org/wiki/Shunting-yard_algorithm" rel="noopener ugc nofollow" target="_blank">。</a></li><li id="3c2e" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">结果被转换成字符串，并返回给调用者。</li></ul><p id="a2ad" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">花点时间阅读一下我们的<a class="ae jz" href="https://github.com/moisam/lets-build-a-linux-shell/tree/master/part5/wordexp.c" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中的<code class="fe mb mc md me b"><strong class="kc io">arithm_expand()</strong></code>函数的代码。</p><h1 id="3c50" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">场分裂</h1><p id="63c5" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">在<a class="ae jz" href="https://www.gnu.org/software/bash/manual/html_node/Word-Splitting.html#Word-Splitting" rel="noopener ugc nofollow" target="_blank">字段拆分</a>过程中，shell将参数扩展、命令替换和算术扩展的结果拆分成一个或多个<strong class="kc io">部分</strong>，我们称之为<strong class="kc io">字段</strong>(因此得名<strong class="kc io">字段拆分</strong>)。这个过程取决于<code class="fe mb mc md me b">$IFS</code> shell变量的值。<em class="nh"> IFS </em>是一个历史术语，代表<em class="nh">内部</em>(或<em class="nh">输入</em> ) <em class="nh">字段分隔符</em>，起源于Unix shells没有内置数组类型的时代。作为一种变通方法，早期的Unix shells不得不寻找另一种方法来表示多成员数组。shell将数组成员连接成一个字符串，用空格隔开。当shell需要检索数组成员时，它会将字符串分解成一个或多个字段。<code class="fe mb mc md me b">$IFS</code>变量告诉shell在哪里断开字符串。shell对<code class="fe mb mc md me b">$IFS</code>字符的解释如下(这个描述是取自POSIX 的<a class="ae jz" href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_05" rel="noopener ugc nofollow" target="_blank">):</a></p><ul class=""><li id="13cb" class="mf mg in kc b kd ke kh ki kl mh kp mi kt mj kx mk ml mm mn bi translated">如果<code class="fe mb mc md me b">$IFS</code>的值是一个<strong class="kc io">空格</strong>、<strong class="kc io">制表符</strong>和<strong class="kc io">换行符</strong>，或者如果没有设置该变量，则输入开始或结束处的<strong class="kc io">空格</strong>、<strong class="kc io">制表符</strong>或<strong class="kc io">换行符</strong>的任何序列都将被忽略，输入中这些字符的任何序列都将限定一个字段。</li><li id="6efc" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">如果<code class="fe mb mc md me b">$IFS</code>的值为空，则不进行字段拆分。</li><li id="40b2" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">否则，应依次应用以下规则:(a) <code class="fe mb mc md me b">$IFS</code>输入开始和结束时应忽略空白。(b)非<code class="fe mb mc md me b">$IFS</code>空白的<code class="fe mb mc md me b">$IFS</code>字符输入的每一次出现，连同任何相邻的<code class="fe mb mc md me b">$IFS</code>空白，应界定一个字段，如前所述。(c)非零长度<code class="fe mb mc md me b">$IFS</code>空白应界定一个字段。</li></ul><p id="2d98" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了执行扩展，我们将定义<code class="fe mb mc md me b"><strong class="kc io">field_split()</strong></code>函数，它具有以下原型:</p><pre class="mt mu mv mw gt mx me my mz aw na bi"><span id="926d" class="nb kz in me b gy nc nd l ne nf">struct word_s *<strong class="me io">field_split</strong>(char *<strong class="me io">str</strong>);</span></pre><p id="ecc6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">花点时间阅读一下我们的<a class="ae jz" href="https://github.com/moisam/lets-build-a-linux-shell/tree/master/part5/wordexp.c" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中的<code class="fe mb mc md me b"><strong class="kc io">field_split()</strong></code>函数代码。</p><h1 id="1127" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">路径名扩展</h1><p id="9d81" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">在<a class="ae jz" href="https://www.gnu.org/software/bash/manual/html_node/Filename-Expansion.html#Filename-Expansion" rel="noopener ugc nofollow" target="_blank">路径名扩展</a>(也称为<strong class="kc io">文件名全球绑定</strong>)期间，shell将一个或多个文件名与给定的模式进行匹配。除了特殊字符<code class="fe mb mc md me b">*</code>、<code class="fe mb mc md me b">?</code>和<code class="fe mb mc md me b">[]</code>之外，该模式还可以包含普通字符(与自身匹配)，这些特殊字符也被称为<strong class="kc io">全局字符</strong>。星号<code class="fe mb mc md me b">*</code>匹配任意长度的字符(包括零个字符)，<code class="fe mb mc md me b">?</code>匹配一个字符，方括号引入一个<a class="ae jz" href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_03_05" rel="noopener ugc nofollow" target="_blank">正则表达式(RE)括号表达式</a>。扩展的结果是名称与模式匹配的文件列表。</p><p id="320d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了执行扩展，我们将定义<code class="fe mb mc md me b"><strong class="kc io">pathnames_expand()</strong></code>函数，它具有以下原型:</p><pre class="mt mu mv mw gt mx me my mz aw na bi"><span id="5f58" class="nb kz in me b gy nc nd l ne nf">struct word_s *<strong class="me io">pathnames_expand</strong>(struct word_s *<strong class="me io">words</strong>);</span></pre><p id="3fd6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个函数接受一个参数:指向我们要进行路径名扩展的单词链表中的第一个单词的指针。对于每个单词，该函数执行以下操作:</p><ul class=""><li id="5a4e" class="mf mg in kc b kd ke kh ki kl mh kp mi kt mj kx mk ml mm mn bi translated">通过调用helper函数<code class="fe mb mc md me b">has_glob_chars()</code>，检查这个单词是否包含任何globbing字符(<code class="fe mb mc md me b">*</code>、<code class="fe mb mc md me b">?</code>和<code class="fe mb mc md me b">[]</code>)，我们将在源文件<code class="fe mb mc md me b"><a class="ae jz" href="https://github.com/moisam/lets-build-a-linux-shell/tree/master/part5/pattern.c" rel="noopener ugc nofollow" target="_blank">pattern.c</a></code>中定义这个函数。如果单词包含globbing字符，我们将其视为需要匹配的模式；否则，我们移动到下一个单词(如果有的话)。</li><li id="ae66" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">获取名称与模式匹配的文件列表，不包括特殊名称<code class="fe mb mc md me b">.</code>和<code class="fe mb mc md me b">..</code>(分别指向当前目录和父目录)。我们将模式匹配委托给另一个助手函数<code class="fe mb mc md me b">get_filename_matches()</code>，我们将在同一个源文件<code class="fe mb mc md me b"><a class="ae jz" href="https://github.com/moisam/lets-build-a-linux-shell/tree/master/part5/pattern.c" rel="noopener ugc nofollow" target="_blank">pattern.c</a></code>中定义它。</li><li id="fef7" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">将匹配的文件名添加到最终列表中。</li><li id="c3ab" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">移动到下一个单词并循环。</li><li id="8ec3" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">返回匹配所有给定单词的文件名列表。</li></ul><p id="1df4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">花点时间阅读一下我们的<a class="ae jz" href="https://github.com/moisam/lets-build-a-linux-shell/tree/master/part5/wordexp.c" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中的<code class="fe mb mc md me b"><strong class="kc io">pathnames_expand()</strong></code>函数的代码。</p><h1 id="24df" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">报价删除</h1><p id="899d" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">单词扩展过程的最后一步是<a class="ae jz" href="https://www.gnu.org/software/bash/manual/html_node/Quote-Removal.html#Quote-Removal" rel="noopener ugc nofollow" target="_blank">去掉引号</a>。引用用于消除某些字符对shell的特殊意义。shell以特殊的方式处理一些字符，比如反斜杠和引号。为了抑制这种行为，我们需要引用这些字符来强制shell将它们视为正常字符(您可以在<a class="ae jz" href="https://www.gnu.org/software/bash/manual/html_node/Quoting.html" rel="noopener ugc nofollow" target="_blank">这个链接</a>中阅读更多关于引用的内容)。</p><p id="d8ee" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以用三种方式之一来引用字符:使用反斜杠、单引号或双引号。反斜杠字符用于保留反斜杠后面的字符的字面意义(即转义)。这类似于我们在C语言中对字符进行转义的方式。</p><p id="341b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">单引号保留了引号内所有字符的字面意思，也就是说，shell不会尝试对单引号字符串进行单词扩展。</p><p id="de94" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">双引号与单引号相似，只是shell识别反引号、反斜杠和<code class="fe mb mc md me b">$</code>符号的特殊含义。也就是说，shell可以在双引号字符串中执行单词扩展。</p><p id="520c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了执行引用移除，我们将定义<code class="fe mb mc md me b"><strong class="kc io">remove_quotes()</strong></code>函数，它具有以下原型:</p><pre class="mt mu mv mw gt mx me my mz aw na bi"><span id="bfee" class="nb kz in me b gy nc nd l ne nf">void <strong class="me io">remove_quotes</strong>(struct word_s *<strong class="me io">wordlist</strong>);</span></pre><p id="f304" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">花点时间阅读一下我们的<a class="ae jz" href="https://github.com/moisam/lets-build-a-linux-shell/tree/master/part5/wordexp.c" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中的<code class="fe mb mc md me b"><strong class="kc io">remove_quotes()</strong></code>函数代码。</p><h1 id="80ff" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">把所有的放在一起</h1><p id="1eaa" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">现在我们有了单词扩展函数，是时候把它们结合在一起了。在这一节中，我们将编写我们的主单词扩展函数，我们将调用它来执行单词扩展。这个函数将依次调用其他函数来执行单词扩展的各个步骤。</p><p id="a77c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的主要函数是<code class="fe mb mc md me b"><strong class="kc io">word_expand()</strong></code>，我们将在源文件<code class="fe mb mc md me b"><a class="ae jz" href="https://github.com/moisam/lets-build-a-linux-shell/tree/master/part5/wordexp.c" rel="noopener ugc nofollow" target="_blank"><strong class="kc io">wordexp.c</strong></a></code>中定义它:</p><pre class="mt mu mv mw gt mx me my mz aw na bi"><span id="6abb" class="nb kz in me b gy nc nd l ne nf">struct word_s *<strong class="me io">word_expand</strong>(char *<strong class="me io">orig_word</strong>);</span></pre><p id="55e9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是该函数为了对作为唯一参数传递的单词执行单词扩展所做的工作:</p><ul class=""><li id="ddf3" class="mf mg in kc b kd ke kh ki kl mh kp mi kt mj kx mk ml mm mn bi translated">创建原始单词的副本。我们将在这个副本上执行我们的word扩展，这样，如果出现任何问题，我们将保持原始word的完整性。</li><li id="f375" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">逐个字符地扫描单词，寻找特殊字符<code class="fe mb mc md me b">~</code>、<code class="fe mb mc md me b">"</code>、<code class="fe mb mc md me b">'</code>、<code class="fe mb mc md me b">`</code>、<code class="fe mb mc md me b">=</code>、<code class="fe mb mc md me b">\</code>和<code class="fe mb mc md me b">$</code>。</li><li id="76dd" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">如果找到上述字符之一，调用<code class="fe mb mc md me b"><strong class="kc io">substitute_word()</strong></code>，它将依次调用相应的单词扩展函数。</li><li id="1ade" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">跳过任何没有特殊意义的字符。</li><li id="df12" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">完成单词扩展后，调用<code class="fe mb mc md me b"><strong class="kc io">field_split()</strong></code>进行字段拆分。</li><li id="d348" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">通过调用<code class="fe mb mc md me b"><strong class="kc io">pathnames_expand()</strong></code>执行路径名扩展。</li><li id="73ea" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">通过调用<code class="fe mb mc md me b"><strong class="kc io">remove_quotes()</strong></code>执行报价删除。</li><li id="c4e3" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">返回扩展单词列表。</li></ul><p id="ebbb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">花点时间阅读一下我们的<a class="ae jz" href="https://github.com/moisam/lets-build-a-linux-shell/tree/master/part5/wordexp.c" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中的<code class="fe mb mc md me b"><strong class="kc io">word_expand()</strong></code>函数代码。</p><h1 id="7e8a" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">更新扫描仪</h1><p id="45ce" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">在本教程的<a class="ae jz" href="https://hackernoon.com/building-a-linux-shell-part-ii-a-step-by-step-guide-pk203ywg?ref=hackernoon.com" rel="noopener ugc nofollow" target="_blank">第二部分</a>中，我们编写了我们的<code class="fe mb mc md me b"><strong class="kc io">tokenize()</strong></code>函数，用于获取输入令牌。到目前为止，我们的<code class="fe mb mc md me b"><strong class="kc io">tokenize()</strong></code>函数还不知道如何处理带引号的字符串和转义字符。为了增加这个功能，我们需要更新我们的代码。打开<code class="fe mb mc md me b"><strong class="kc io">scanner.c</strong></code>文件，将以下代码添加到<code class="fe mb mc md me b"><strong class="kc io">tokenize()</strong></code>函数中，就在<code class="fe mb mc md me b">switch</code>语句的左括号后面:</p><pre class="mt mu mv mw gt mx me my mz aw na bi"><span id="686a" class="nb kz in me b gy nc nd l ne nf">case  '"':<br/>            case '\'':<br/>            case  '`':<br/>                add_to_buf(nc);<br/>                i = find_closing_quote(src-&gt;buffer+src-&gt;curpos);<br/>                if(!i)<br/>                {<br/>                    src-&gt;curpos = src-&gt;bufsize;<br/>                    fprintf(stderr,<br/>                       "error: missing closing quote '%c'\n", nc);<br/>                    return &amp;eof_token;<br/>                }<br/>                while(i--)<br/>                {<br/>                    add_to_buf(next_char(src));<br/>                }<br/>                break;</span><span id="273e" class="nb kz in me b gy ni nd l ne nf">            case '\\':<br/>                nc2 = next_char(src);<br/>                if(nc2 == '\n')<br/>                {<br/>                    break;<br/>                }</span><span id="5f62" class="nb kz in me b gy ni nd l ne nf">                add_to_buf(nc);</span><span id="b7c1" class="nb kz in me b gy ni nd l ne nf">                if(nc2 &gt; 0)<br/>                {<br/>                    add_to_buf(nc2);<br/>                }<br/>                break;<br/>                <br/>            case '$':<br/>                add_to_buf(nc);<br/>                nc = peek_char(src);</span><span id="197f" class="nb kz in me b gy ni nd l ne nf">                if(nc == '{' || nc == '(')<br/>                {<br/>                    i = find_closing_brace(src-&gt;buffer+<br/>                                   src-&gt;curpos+1);<br/>                    if(!i)<br/>                    {<br/>                        src-&gt;curpos = src-&gt;bufsize;<br/>                        fprintf(stderr,<br/>                            "error: missing closing brace '%c'\n",<br/>                            nc);<br/>                        return &amp;eof_token;<br/>                    }</span><span id="4ac0" class="nb kz in me b gy ni nd l ne nf">                    while(i--)<br/>                    {<br/>                        add_to_buf(next_char(src));<br/>                    }<br/>                }<br/>                else if(isalnum(nc) || nc == '*' || nc == '@' ||<br/>                          nc == '#' || nc == '!' || nc == '?' ||<br/>                          nc == '$')<br/>                {<br/>                    add_to_buf(next_char(src));<br/>                }<br/>                break;</span></pre><p id="2acb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们的词法扫描器知道如何识别和跳过引用字符串、转义字符和其他单词扩展结构。在<a class="ae jz" href="https://github.com/moisam/lets-build-a-linux-shell/tree/master/part5/scanner.c" rel="noopener ugc nofollow" target="_blank">链接</a>中查看更新的词法扫描器代码。</p><h1 id="1ec8" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">更新执行者</h1><p id="a439" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">最后，我们需要更新我们的后端执行器，以便它能够:</p><ul class=""><li id="973d" class="mf mg in kc b kd ke kh ki kl mh kp mi kt mj kx mk ml mm mn bi translated">在执行命令之前，对该命令的参数执行单词扩展。</li><li id="5d4f" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">支持每个命令超过255个参数(我们在<a class="ae jz" href="https://medium.com/swlh/lets-build-a-linux-shell-part-ii-340ecf471028" rel="noopener">第二部分</a>中设置了这个限制)。</li></ul><p id="256a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">打开<code class="fe mb mc md me b"><strong class="kc io">executor.c</strong></code>文件，导航到<code class="fe mb mc md me b"><strong class="kc io">do_simple_command()</strong></code>函数的开头，找到以下几行(为了节省空间，我将循环减少到了<code class="fe mb mc md me b">...</code>):</p><pre class="mt mu mv mw gt mx me my mz aw na bi"><span id="11e0" class="nb kz in me b gy nc nd l ne nf">    int argc = 0;<br/>    long max_args = 255;<br/>    char *argv[max_args+1];<br/>    char *str;</span><span id="4dc5" class="nb kz in me b gy ni nd l ne nf">    while(child)<br/>    {<br/>        ...<br/>    }<br/>    argv[argc] = NULL;</span></pre><p id="2f60" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">并用以下代码替换它们:</p><pre class="mt mu mv mw gt mx me my mz aw na bi"><span id="75f1" class="nb kz in me b gy nc nd l ne nf">    int argc = 0;<br/>    int targc = 0;<br/>    char **argv = NULL;<br/>    char *str;</span><span id="d9a0" class="nb kz in me b gy ni nd l ne nf">    while(child)<br/>    {<br/>        str = child-&gt;val.str;<br/>        struct word_s *w = word_expand(str);<br/>        <br/>        if(!w)<br/>        {<br/>            child = child-&gt;next_sibling;<br/>            continue;<br/>        }</span><span id="e790" class="nb kz in me b gy ni nd l ne nf">        struct word_s *w2 = w;<br/>        while(w2)<br/>        {<br/>            if(check_buffer_bounds(&amp;argc, &amp;targc, &amp;argv))<br/>            {<br/>                str = malloc(strlen(w2-&gt;data)+1);<br/>                if(str)<br/>                {<br/>                    strcpy(str, w2-&gt;data);<br/>                    argv[argc++] = str;<br/>                }<br/>            }<br/>            w2 = w2-&gt;next;<br/>        }<br/>        <br/>        free_all_words(w);<br/>        <br/>        child = child-&gt;next_sibling;<br/>    }</span><span id="9ef5" class="nb kz in me b gy ni nd l ne nf">    if(check_buffer_bounds(&amp;argc, &amp;targc, &amp;argv))<br/>    {<br/>        argv[argc] = NULL;<br/>    }</span></pre><p id="6f41" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用这段代码，执行器调用每个命令参数上的<code class="fe mb mc md me b"><strong class="kc io">word_expand()</strong></code>,并将扩展的单词添加到参数列表中，我们最终会将它传递给命令。由于我们的<code class="fe mb mc md me b"><strong class="kc io">check_buffer_bounds()</strong></code>函数可以根据需要为缓冲区分配内存，列表可以根据需要增长。</p><p id="e381" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在剩下的就是在我们执行完命令后，在返回到调用者之前，释放我们的参数列表。我们通过调用:</p><pre class="mt mu mv mw gt mx me my mz aw na bi"><span id="dd78" class="nb kz in me b gy nc nd l ne nf">free_buffer(argc, argv);</span></pre><p id="f4cb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在三个不同的地方:在执行一个内置的实用程序之后，如果<code class="fe mb mc md me b">fork()</code>返回错误状态(这意味着我们不能执行外部命令)，以及在<code class="fe mb mc md me b">waitpid()</code>返回之后。点击<a class="ae jz" href="https://github.com/moisam/lets-build-a-linux-shell/tree/master/part5/executor.c" rel="noopener ugc nofollow" target="_blank">链接</a>查看更新后的执行代码。</p><h1 id="c5b1" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">编译外壳</h1><p id="8af0" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">让我们编译我们的外壳。打开您最喜欢的终端模拟器，导航到您的源目录，并确保其中有19个文件和2个子目录:</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nj"><img src="../Images/419a3627272aae2dae27f0cea30058e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IIbY3TDhlX6S5FWe"/></div></div></figure><p id="90cc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在使用以下命令编译shell(您需要从我们的<a class="ae jz" href="https://github.com/moisam/lets-build-a-linux-shell/tree/master/part5" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>下载源代码项目):</p><pre class="mt mu mv mw gt mx me my mz aw na bi"><span id="d778" class="nb kz in me b gy nc nd l ne nf">make</span></pre><p id="8ee0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果一切顺利，<code class="fe mb mc md me b"><strong class="kc io">gcc</strong></code>应该不会输出任何东西(除了几个无害的警告)，当前目录下应该有一个名为<code class="fe mb mc md me b"><strong class="kc io">shell</strong></code>的可执行文件:</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nj"><img src="../Images/2c8955771a35163daebc8f730c827069.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2A-700uPuurAbQU0"/></div></div></figure><p id="49c9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在通过运行<code class="fe mb mc md me b"><strong class="kc io">./shell</strong></code>调用shell，并尝试使用我们的单词扩展函数并检查结果:</p><pre class="mt mu mv mw gt mx me my mz aw na bi"><span id="1acc" class="nb kz in me b gy nc nd l ne nf">$ <strong class="me io">echo *</strong><br/>Makefile build builtins executor.c executor.h initsh.c main.c node.c node.h parser.c parser.h pattern.c prompt.c scanner.c scanner.h shell shell.h shunt.c source.c source.h strings.c symtab wordexp.c<br/>$ <strong class="me io">echo '*'</strong><br/>*<br/>$ <strong class="me io">echo ~</strong><br/>/home/user<br/>$ <strong class="me io">echo ~/Downloads</strong><br/>/home/user/Downloads<br/>$ <strong class="me io">echo ${A=value}</strong><br/>value<br/>$ <strong class="me io">echo $A</strong><br/>value<br/>$ <strong class="me io">echo $((2+7))</strong><br/>9</span></pre><p id="4c87" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">今天就到这里。我们的shell现在可以处理所有类型的单词扩展(具体来说，是由POSIX定义的)。摆弄一下外壳，看看不同类型的单词扩展能得到什么结果。将结果与您从默认shell中获得的结果进行比较。</p><h1 id="57ed" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">下一步是什么</h1><p id="08fb" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">在本课中，我们进行了一次巨大的飞跃，使用了大量的代码，其中大部分我们没有时间或空间来详细检查。您可能想花些时间通读我们的GitHub存储库中的代码，以便熟悉单词扩展过程。</p><p id="5b3d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在下一部分，我们将讨论<strong class="kc io">位置参数</strong>和<strong class="kc io">特殊参数</strong>，它们是什么，我们为什么需要它们，以及如何在我们的shell中实现它们。</p><p id="47e2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">敬请期待！</p></div></div>    
</body>
</html>