<html>
<head>
<title>Microservice Architecture — Communication &amp; Design Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务架构——通信和设计模式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/microservice-architecture-communication-design-patterns-70b37beec294?source=collection_archive---------0-----------------------#2020-11-13">https://blog.devgenius.io/microservice-architecture-communication-design-patterns-70b37beec294?source=collection_archive---------0-----------------------#2020-11-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="5f4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">处理微服务中的进程间通信和执行流</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/76b3c5ee8d37c5da3ceaa27cd77438cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P8BKNxE4T3ScTYB423f9Mg.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">地球(来源:<a class="ae lb" href="https://pixabay.com/photos/network-earth-block-chain-globe-3607641/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>)</figcaption></figure><p id="ad27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lb" href="https://en.wikipedia.org/wiki/Microservices" rel="noopener ugc nofollow" target="_blank">微服务</a>的目标是将应用程序充分分解/解耦为围绕业务功能组织的松散耦合的服务。分布式微单元共同服务于应用目的。</p><p id="a852" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将单个应用拆分为微服务后，跨越多个服务的事务(读写)变得不可避免。然后<strong class="jp ir">跨微服务边界的通信——工作流管理——数据存储机制变得具有挑战性。</strong>系统应该遵守一个被称为<a class="ae lb" href="https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing" rel="noopener ugc nofollow" target="_blank">分布式计算谬误</a>的准则。<strong class="jp ir"> </strong> <a class="ae lb" href="https://en.wikipedia.org/wiki/ACID" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> ACID </strong> </a>跨多个服务(每个服务都有自己的业务逻辑&amp;数据库)处理事务时，无法保证数据库系统保证的真实性。<a class="ae lb" href="https://en.wikipedia.org/wiki/CAP_theorem" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">上限定理</strong> </a>表明你将在一致性(C)和可用性(A)之间进行权衡，因为分区容差(P)在分布式系统中是一个不理想的现实。在这篇博文中，我们将探索这些挑战和设计模式的解决方案。</p><h1 id="02eb" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">协调服务间的沟通</strong></h1><p id="44ac" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">针对不同环境和目标的客户和服务可以通过不同的机制进行通信。根据协议的不同，它可以是同步的也可以是异步的。</p><h2 id="dc23" class="mf ld iq bd le mg mh dn li mi mj dp lm jy mk ml lq kc mm mn lu kg mo mp ly mq bi translated"><strong class="ak">同步通信——请求响应方法</strong></h2><p id="7ffc" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在同步通信中，需要一个预定义的源服务地址，准确地将请求发送到哪里，并且服务<strong class="jp ir"/>(调用者和被调用者)此时都应该启动并运行。虽然协议可以是同步的，但是I/O操作可以是异步的，客户端不需要等待响应。这就是<strong class="jp ir"> I/O和</strong>协议的区别。web API常见的请求-响应方法包括REST、GraphQL和gRPC。</p><h2 id="7e01" class="mf ld iq bd le mg mh dn li mi mj dp lm jy mk ml lq kc mm mn lu kg mo mp ly mq bi translated"><strong class="ak">异步通信</strong></h2><p id="fa0b" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在异步通信的情况下，调用方不需要知道被调用方的特定目的地。一次处理多个消费者变得相对容易(因为服务可能会增加消费者)。此外，如果接收服务关闭，消息会排队等候，并在稍后服务启动时继续<strong class="jp ir"> </strong>。<strong class="jp ir"> </strong>从<strong class="jp ir">松耦合、多服务通信、应对部分服务器故障的角度来看，这一点尤为重要。</strong>这些是使<strong class="jp ir">微服务向异步通信</strong>倾斜的决定性因素。像MQTT，STOMP，AMQP这样的异步协议是由Apache Kafka Stream，RabbitMQ这样的平台处理的。</p><p id="200a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">了解何时何地使用同步模型和异步模型是设计有效微服务通信的基本决策。你可以在这里分析微服务中基于REST的vs异步通信<a class="ae lb" href="https://solace.com/blog/messaging-between-microservices/" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="fd08" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">消息&amp;事件</strong></h1><p id="73d5" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在异步通信中，常见的机制是消息传递和事件流。</p><h2 id="0895" class="mf ld iq bd le mg mh dn li mi mj dp lm jy mk ml lq kc mm mn lu kg mo mp ly mq bi translated">消息</h2><p id="bf50" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated"><strong class="jp ir">消息</strong>是发送到特定目的地的一项数据，它封装了<strong class="jp ir">意图/动作</strong>(必须发生什么)并通过消息传递等渠道分发。队列存储消息，直到消息被处理和删除。在消息驱动的系统中，可寻址的接收者等待消息的到达并对它们做出反应，否则就处于休眠状态。</p><h2 id="921a" class="mf ld iq bd le mg mh dn li mi mj dp lm jy mk ml lq kc mm mn lu kg mo mp ly mq bi translated"><strong class="ak">事件</strong></h2><p id="9a7c" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">事件封装了状态的变化(发生了什么),侦听器被附加到事件源，以便在发出事件时调用它们。</p><ul class=""><li id="fe28" class="mr ms iq jp b jq jr ju jv jy mt kc mu kg mv kk mw mx my mz bi translated">域事件—与应用程序生成的业务域相关联的事件(下图中的OrderRequested、CreditReserved、InventoryReserved)。这些事件是事件源的关注点。</li><li id="7b3e" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">变更事件—从数据库生成的指示状态转换的事件。这些事件是变更数据捕获的关注点。</li></ul><p id="f38a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事件流是持久的、持久的、容错的，不需要任何消费者的想法。在这种情况下，处理器是哑的(在某种意义上，它仅充当消息路由器),客户端/服务拥有以域为中心的逻辑，使得<strong class="jp ir">转储处理器和活动客户端。</strong>这避免了复杂的集成平台，如传统SOA设计中使用的ESB<strong class="jp ir">。</strong></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nf"><img src="../Images/c39558987d1b86ebd499c0c6f626351a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gSg1fyx0YyqTqykmN0Ibrw.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">图微服务设计中的事件</figcaption></figure><h2 id="3371" class="mf ld iq bd le mg mh dn li mi mj dp lm jy mk ml lq kc mm mn lu kg mo mp ly mq bi translated"><strong class="ak">微服务原理——智能消费哑管道</strong></h2><p id="065d" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">微服务社区推广了<a class="ae lb" href="https://simplicable.com/new/smart-endpoints-and-dumb-pipes" rel="noopener ugc nofollow" target="_blank">智能端点和哑管道</a>的理念。马丁·福勒提倡他所谓的微服务通信的智能端点和哑管道。统治SOA世界的ESB有许多与复杂性、成本和故障排除相关的问题。</p><h1 id="79f2" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">异步通信协议</strong></h1><ul class=""><li id="289e" class="mr ms iq jp b jq ma ju mb jy ng kc nh kg ni kk mw mx my mz bi translated"><strong class="jp ir"> MQTT — </strong>消息队列遥测传输(<a class="ae lb" href="https://en.wikipedia.org/wiki/MQTT" rel="noopener ugc nofollow" target="_blank"> MQTT </a>)是一种基于ISO标准发布订阅的轻量级消息协议<a class="ae lb" href="https://www.integrasources.com/blog/mqtt-protocol-iot-devices/" rel="noopener ugc nofollow" target="_blank">，广泛应用于物联网</a>。</li><li id="e16c" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated"><strong class="jp ir"> AMQP — </strong>高级消息队列协议(AMQP)是面向消息中间件的开放标准应用层协议。</li><li id="6262" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated"><strong class="jp ir"> STOMP — </strong>简单面向文本的消息协议(<a class="ae lb" href="http://stomp.github.io/" rel="noopener ugc nofollow" target="_blank"> STOMP </a>)，是一种基于文本的协议，以HTTP为模型，用于在服务之间交换数据。</li></ul><p id="6f49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有关这些协议的深入比较，请参考此处的<a class="ae lb" href="https://lists.oasis-open.org/archives/amqp/201202/msg00086/StormMQ_WhitePaper_-_A_Comparison_of_AMQP_and_MQTT.pdf" rel="noopener ugc nofollow" target="_blank"/>。</p><h2 id="dd2c" class="mf ld iq bd le mg mh dn li mi mj dp lm jy mk ml lq kc mm mn lu kg mo mp ly mq bi translated"><strong class="ak">通用消息/流媒体平台</strong></h2><ul class=""><li id="57da" class="mr ms iq jp b jq ma ju mb jy ng kc nh kg ni kk mw mx my mz bi translated"><a class="ae lb" href="http://activemq.apache.org/" rel="noopener ugc nofollow" target="_blank"> ActiveMQ </a></li><li id="ea30" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated"><a class="ae lb" href="http://kafka.apache.org/" rel="noopener ugc nofollow" target="_blank">卡夫卡</a></li><li id="2f1c" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated"><a class="ae lb" href="https://www.rabbitmq.com/" rel="noopener ugc nofollow" target="_blank"> RabbitMQ </a></li><li id="bfce" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated"><a class="ae lb" href="https://redis.io/topics/streams-intro" rel="noopener ugc nofollow" target="_blank"> Redis Streams </a></li></ul><p id="9235" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">评估标准的一些常见基线包括可用性、持久性/持久性、持久性、拉/推模式、可伸缩性和消费者能力。这些平台的详细对比可以参考<a class="ae lb" href="https://otonomo.io/blog/redis-kafka-or-rabbitmq-which-microservices-message-broker-to-choose/" rel="noopener ugc nofollow" target="_blank">这里的</a>。</p><h1 id="fc7b" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">微服务设计模式</strong></h1><p id="6fc3" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">微服务建立在独立自主的服务、可伸缩性、松散耦合的高内聚和容错的原则之上。这将带来挑战，包括复杂的管理和配置。设计模式是关于在给定的特定上下文中描述一个问题的可重用解决方案。我们将讨论这些模式，以应对挑战，提供经过验证的解决方案，使架构更加高效。</p><h1 id="9a16" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak"> Saga模式——跨多个服务维护原子性</strong></h1><p id="30d0" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">单个事务可能跨越多个服务。例如，在电子商务应用程序中，新订单(与订单服务相关联)不应超过客户信用限额(与客户服务相关联)，并且商品(与库存服务相关联)应该可用。该事务不能使用本地ACID事务。</p><p id="b0df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">saga是本地事务的序列，它更新每个服务并发布消息/事件以触发下一个本地事务。在任何本地事务失败的情况下，saga执行一系列的<strong class="jp ir">补偿事务</strong>，这些补偿事务撤消先前本地事务所做的更改，从而保持<strong class="jp ir">的原子性</strong>。</p><ul class=""><li id="3759" class="mr ms iq jp b jq jr ju jv jy mt kc mu kg mv kk mw mx my mz bi translated"><strong class="jp ir">基于编排的传奇— </strong>参与者在没有集中控制点的情况下交换<strong class="jp ir">事件</strong>。</li><li id="82a2" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated"><strong class="jp ir">基于编排的saga — </strong>集中控制器告诉saga参与者要执行哪些本地事务。</li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nj"><img src="../Images/05192c7b6e992b69e6fdb9220cd3908a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BzKOmdat9L6KVjT1Xlh9rw.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">图1 .编舞和编排传奇</figcaption></figure><p id="c180" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这两种模式中进行选择取决于工作流的复杂性、参与者的数量、耦合性和其他因素，在这里<a class="ae lb" href="https://docs.microsoft.com/en-us/azure/architecture/reference-architectures/saga/saga" rel="noopener ugc nofollow" target="_blank">详细解释</a>。</p><h2 id="7918" class="mf ld iq bd le mg mh dn li mi mj dp lm jy mk ml lq kc mm mn lu kg mo mp ly mq bi translated"><strong class="ak">两阶段提交</strong></h2><p id="01da" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">与saga类似，事务分两个阶段发生:准备和提交阶段。在准备阶段，要求所有参与者准备数据&amp;在提交阶段，进行实际的更改。然而，与不希望的副作用和性能问题同步，它被认为<a class="ae lb" href="https://developers.redhat.com/blog/2018/10/01/patterns-for-distributed-transactions-within-a-microservices-architecture/#:~:text=When%20a%20microservice%20architecture%20decomposes,services%2C%20it%20can%20break%20transactions.&amp;text=If%20any%20step%20fails%2C%20the,guaranteed%20by%20the%20database%20system." rel="noopener ugc nofollow" target="_blank">在微服务架构</a>中不切实际。</p><h1 id="dcad" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">事件源—面向状态的持久性的替代方案</strong></h1><p id="7461" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">持久化数据的传统方式是通过更新现有数据来保持实体状态的最新版本。假设，如果我们必须改变一个用户实体的名称，我们用一个新的用户名改变当前的状态。如果我们需要在任何时间点或时间旅行中重建国家呢？在这种情况下，我们需要考虑这种持久性策略的替代方案。</p><p id="2ac8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与这种面向状态的持久性相反，Event Sourcing将每个状态突变存储为一个称为Event的独立事件，应用程序状态存储为一系列不可变的事件，而不是修改数据。通过有选择地重放事件，我们可以随时了解应用程序的状态。应用程序保存在名为事件存储的仅附加事件日志中。一个众所周知的例子是事务数据库系统的事务日志。</p><p id="ff16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事件源依赖于三个服务层:</p><ul class=""><li id="dfa4" class="mr ms iq jp b jq jr ju jv jy mt kc mu kg mv kk mw mx my mz bi translated"><strong class="jp ir">命令</strong>:命令处理程序处理的状态改变请求。</li><li id="7516" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated"><strong class="jp ir">事件</strong>:状态变化的不变表现。</li><li id="ba60" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated"><strong class="jp ir">聚合</strong>:领域模型当前状态的聚合表示。</li></ul><p id="c341" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事件源有利于提供准确的审计日志记录、状态重建(任意时间点)、简单的时态查询、时间旅行、性能和可伸缩性因素。网飞用事件源解决了<a class="ae lb" href="https://netflixtechblog.com/scaling-event-sourcing-for-netflix-downloads-episode-2-ce1b54d46eec" rel="noopener ugc nofollow" target="_blank">离线下载功能</a>。这里用一个典型的例子讨论<a class="ae lb" href="https://www.eventstore.com/blog/what-is-event-sourcing" rel="noopener ugc nofollow" target="_blank">的实现细节</a>。</p><h1 id="48de" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak"> CQRS —命令查询责任分离</strong></h1><p id="8503" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">如果我们将CRUD操作设计成可以由两个独立的读写模型来处理，会怎么样？这显然增加了系统的复杂性，但是好处是什么&amp;我们什么时候需要它？这种分离有助于增加另一层可伸缩性、性能和灵活性，允许在处理复杂的域模型时进行粒度读写优化。</p><p id="3e63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">CQRS清楚地将在应用程序中进行更改的模型/对象与读取应用程序数据的模型/对象分开。命令只是一些方法，它们的唯一目的是执行操作(创建、更新、删除),要么被接受，要么被拒绝——而不会暴露系统状态。查询是读取系统状态而不做任何修改的方法。更进一步，我们可以通过引入一种保持同步的机制来分离数据存储的写部分和读部分(可以由多个数据库管理)。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nk"><img src="../Images/8675e09832a519c92135dbecf48e0d4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gp7KlNF4qv41Q0SOUyHjFA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">图1 .具有相同和不同数据存储的CQRS</figcaption></figure><h2 id="6e92" class="mf ld iq bd le mg mh dn li mi mj dp lm jy mk ml lq kc mm mn lu kg mo mp ly mq bi translated"><strong class="ak">活动采购和CQRS </strong></h2><p id="f607" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">这些通常被称为互补模式。</p><blockquote class="nl nm nn"><p id="d1cc" class="jn jo no jp b jq jr js jt ju jv jw jx np jz ka kb nq kd ke kf nr kh ki kj kk ij bi translated">“您可以在没有活动采购的情况下使用CQRS，但在有活动采购的情况下，您必须使用CQRS。”——Greg Young—<a class="ae lb" href="https://www.youtube.com/watch?v=JHGkaShoyNs&amp;feature=youtu.be" rel="noopener ugc nofollow" target="_blank">CQRS和活动采购—海滩上的代码2014 </a>。</p></blockquote><p id="9c07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如前所述，事件存储由一系列不可变的事件组成。通常，业务需求想要<strong class="jp ir">执行复杂的查询，这不能由单个聚合</strong>来回答。每次都重复事件的顺序在计算上将是昂贵的(并且在巨大的数据集中是不实际的)。在这种情况下，隔离将证明是有益的。</p><p id="e465" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下图中，命令更新事件存储将发布事件。查询服务使用更改日志事件，并为将来的查询构建一个预测。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ns"><img src="../Images/f853fd649f1f9e3554ec015dc44934b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K4bJbuj7gOVy61NUnwMZdw.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">图1服务中的事件源和CQRS</figcaption></figure><h1 id="2613" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">事务发件箱模式</h1><p id="1a30" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在某些情况下，我们需要在数据库中进行更新，并调用另一个动作，通常是在外部系统上。例如，在电子商务应用程序中，我们需要保存订单并向客户发送电子邮件。如果任何一个事务失败，都会导致系统不一致。</p><p id="b553" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，<strong class="jp ir">发件箱</strong>和<strong class="jp ir">消息中继</strong>可以协同工作，可靠地保持状态并调用另一个动作。一个“<strong class="jp ir">发件箱</strong>”表驻留在服务的数据库中。随着主要变化(例如在订单表中创建订单)，表示事件的记录(orderPlaced)也被引入到同一数据库事务中的发件箱表中。在非关系数据库中，通常通过在文档中存储事件来实现。</p><p id="c0de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，消息中继读取发件箱表，并将消息转发到相应的目的地。消息分派过程可以是轮询发布者(轮询发件箱表)或事务日志跟踪(跟踪数据库提交日志)。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nt"><img src="../Images/403c31774a5120dd57b985974125fcd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KOc-B4XGexxv4hERn07h2Q.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">图交易发件箱模式</figcaption></figure><h2 id="29f5" class="mf ld iq bd le mg mh dn li mi mj dp lm jy mk ml lq kc mm mn lu kg mo mp ly mq bi translated">变更数据捕获(CDC)</h2><p id="84f4" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">应用程序状态保存在数据库中。变更数据捕获跟踪源数据库中的变更，并将这些变更转发到目标，以便与相同的增量变更同步。CDC可以是基于<a class="ae lb" href="https://debezium.io/blog/2018/07/19/advantages-of-log-based-change-data-capture/" rel="noopener ugc nofollow" target="_blank">日志的</a>(事务数据库将所有更改存储在事务日志中)或基于查询的(定期使用查询检查源数据库，因为事务日志在类似<a class="ae lb" href="https://www.teradata.com/" rel="noopener ugc nofollow" target="_blank"> Teradata </a>的数据库中可能不可用)。</p><p id="9ed1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下图显示了基于日志的CDC，用于捕获发件箱表中的新条目(使用<a class="ae lb" href="https://debezium.io/docs/connectors/postgresql" rel="noopener ugc nofollow" target="_blank">Debezium connector for Postgres</a>)并将它们传输到Apache Kafka。事件捕获以非常低的开销近乎实时地发生，并且事件是订阅的目的地服务。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nu"><img src="../Images/ffb8b0339f72b68b7d7112f1650a8639.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sXdHsypCMI1pGZej"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">图使用Apache Kafka的CDC事务发件箱</figcaption></figure><h1 id="0b8f" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">微服务设计的考虑因素</h1><p id="ea58" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我们将简要介绍设计微服务时需要的一些杂项想法/原则。</p><h2 id="cdea" class="mf ld iq bd le mg mh dn li mi mj dp lm jy mk ml lq kc mm mn lu kg mo mp ly mq bi translated">幂等交易</h2><p id="1a04" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">幂等事务是那些发出多个相同请求的事务，这些请求具有与发出单个请求相同的效果。在一个<a class="ae lb" href="https://en.wikipedia.org/wiki/Representational_state_transfer" rel="noopener ugc nofollow" target="_blank"> REST API </a>中，GET方法是等幂的(可以重复调用，保证结果与处理该方法一次相同)，而POST方法不是等幂的(item在每个请求上不断增加)。</p><p id="60d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在分布式系统的上下文中，<a class="ae lb" href="https://bravenewgeek.com/you-cannot-have-exactly-once-delivery/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">你不能拥有恰好一次的消息传递</strong> </a>。消息代理，比如Apache Kafka或RabbitMQ，实现了<strong class="jp ir">至少一次交付</strong>，这为同一个事务创建了多次调用的可能性。因此，在分布式系统中，消费者需要是幂等的。如果消费者不是等幂的，多次调用会导致bug&amp;不一致。</p><p id="f1f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Airbnb实现了<a class="ae lb" href="https://medium.com/airbnb-engineering/avoiding-double-payments-in-a-distributed-payments-system-2981f6b070bb#:~:text=This%20is%20critical%20for%20Airbnb,API%20to%20achieve%20eventual%20consistency." rel="noopener"><strong class="jp ir">【Orpheus】</strong>，一个跨多个支付服务的通用幂等库</a>、<strong class="jp ir"> </strong>，其中一个<strong class="jp ir">幂等键</strong>被传递到框架中，表示单个幂等请求。Paypal使用<a class="ae lb" href="https://developer.paypal.com/docs/archive/express-checkout/integration-guide/ec-related-ops/#api-idempotency" rel="noopener ugc nofollow" target="_blank"> MsgSubId(消息提交ID) </a>在API中实现幂等，Google Service Payment使用<a class="ae lb" href="https://developers.google.com/standard-payments/reference/idempotent-behavior-examples#idempotency_and_google_standard_payments" rel="noopener ugc nofollow" target="_blank">请求ID </a>实现幂等。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nv"><img src="../Images/68cef8dc394cac703c4ae3a9c31bfbc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7V6PN7AwOY18twTs.jpg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">图1列车目的地标志控制中的开/关。按下On按钮是等幂的，因为无论按一次还是多次，效果都是一样的。同样，按下关闭是幂等的。(来源:<a class="ae lb" href="https://en.wikipedia.org/" rel="noopener ugc nofollow" target="_blank">维基百科</a>)</figcaption></figure><h2 id="9945" class="mf ld iq bd le mg mh dn li mi mj dp lm jy mk ml lq kc mm mn lu kg mo mp ly mq bi translated">最终一致性</h2><p id="f356" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在分布式系统中，一致性定义了对一个节点/服务的更新是否以及如何传播到所有服务。也被称为<strong class="jp ir">乐观复制</strong>，最终一致性只是承认在将一台机器上所做的更改传播到所有其他副本时存在无限延迟。</p><p id="4f86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">网络分区是分布式系统的一个不理想的现实，网络可能会发生故障。由于分区容差(P)是不可避免的，CAP定理表明您将在一致性和可用性之间进行权衡。如果您选择可用性，您不能有强一致性，但是您仍然可以在您的系统中提供最终的一致性。</p><p id="a744" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">许多业务系统对数据不一致性的容忍度比通常认为的更高，可用性高于一致性。<a class="ae lb" href="https://www.techopedia.com/definition/29164/basically-available-soft-state-eventual-consistency-base" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"/></a>(<strong class="jp ir">B</strong>A<strong class="jp ir">A</strong>可用，<strong class="jp ir"> S </strong> oft状态，<strong class="jp ir">E</strong>vent Consistency)系统优于酸系统。</p><blockquote class="nl nm nn"><p id="0886" class="jn jo no jp b jq jr js jt ju jv jw jx np jz ka kb nq kd ke kf nr kh ki kj kk ij bi translated">对于分布式系统来说，维护强一致性极其困难，这意味着每个人都必须管理最终的一致性</p><p id="b806" class="jn jo no jp b jq jr js jt ju jv jw jx np jz ka kb nq kd ke kf nr kh ki kj kk ij bi translated">马丁·福勒</p></blockquote><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nw"><img src="../Images/7b66ec59219a4961bb472d3ebc6c8846.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qykNZ5sZ0lxihrp-LSFnjg.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">图4分布式系统中的最终一致性</figcaption></figure><h2 id="9439" class="mf ld iq bd le mg mh dn li mi mj dp lm jy mk ml lq kc mm mn lu kg mo mp ly mq bi translated"><strong class="ak">分布式跟踪</strong></h2><p id="61f7" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在微服务中，与请求相关联的元数据(可能跨越多个服务)将有助于不同的原因:监控、日志聚合、故障排除、延迟和性能优化、服务依赖性分析和分布式上下文传播。</p><p id="735d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">分布式跟踪是从头到尾捕获请求的<strong class="jp ir">元数据</strong>的过程，确保日志记录开销保持最小。一个<strong class="jp ir">唯一的事务ID </strong>被分配给外部请求&amp;，该请求通过分布式拓扑&amp;中每个事务的调用链传递，包括在所有消息中(以及时间戳和元数据)。</p><p id="8ed3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">唯一标识符可以通过使用数据库票服务器(如<a class="ae lb" href="https://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/" rel="noopener ugc nofollow" target="_blank"> Flickr </a> ) <a class="ae lb" href="https://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/)," rel="noopener ugc nofollow" target="_blank">、</a> UUID或Twitter雪花所使用的)来生成。常见的分布式追踪工具有<a class="ae lb" href="https://opentracing.io/" rel="noopener ugc nofollow" target="_blank"> OpenTracing </a>、<a class="ae lb" href="https://www.jaegertracing.io/" rel="noopener ugc nofollow" target="_blank"> Jaeger </a>、<a class="ae lb" href="https://zipkin.io/" rel="noopener ugc nofollow" target="_blank"> Zipkin </a>和<a class="ae lb" href="https://opentracing.io/registry/appdash/" rel="noopener ugc nofollow" target="_blank"> AppDash </a>。</p><h2 id="6a84" class="mf ld iq bd le mg mh dn li mi mj dp lm jy mk ml lq kc mm mn lu kg mo mp ly mq bi translated">服务网格</h2><p id="55bf" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">微服务中的服务网格是处理进程间通信的可配置网络基础设施层。这类似于通常所说的边车代理或边车网关。它提供的功能包括:</p><ul class=""><li id="c2d6" class="mr ms iq jp b jq jr ju jv jy mt kc mu kg mv kk mw mx my mz bi translated">负载平衡</li><li id="49d8" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">服务发现</li><li id="657b" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">健康检查</li><li id="14c5" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">安全性</li></ul><p id="4907" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Envoy是一款流行的开源代理，专为云原生应用而设计。<a class="ae lb" href="https://istio.io/" rel="noopener ugc nofollow" target="_blank"> Istio </a>是一个开放平台，用于连接、管理和保护Kubernetes社区中流行的微服务。</p><p id="9271" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了向客户端应用程序公开你的微服务API，请参考我的<a class="ae lb" href="https://medium.com/dev-genius/microservices-design-api-gateway-pattern-980e8d02bdd5" rel="noopener">博文:微服务设计——API网关模式</a>。</p><h2 id="61aa" class="mf ld iq bd le mg mh dn li mi mj dp lm jy mk ml lq kc mm mn lu kg mo mp ly mq bi translated">参考</h2><ol class=""><li id="da9d" class="mr ms iq jp b jq ma ju mb jy ng kc nh kg ni kk nx mx my mz bi translated"><a class="ae lb" href="https://martinfowler.com/articles/microservices.html" rel="noopener ugc nofollow" target="_blank">https://martinfowler.com/articles/microservices.html</a></li><li id="4f8a" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk nx mx my mz bi translated"><a class="ae lb" href="https://docs.microsoft.com/" rel="noopener ugc nofollow" target="_blank">https://docs.microsoft.com</a></li><li id="c00e" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk nx mx my mz bi translated"><a class="ae lb" href="https://microservices.io/" rel="noopener ugc nofollow" target="_blank">https://microservices . io</a></li><li id="860c" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk nx mx my mz bi translated"><a class="ae lb" href="https://www.nginx.com/blog" rel="noopener ugc nofollow" target="_blank">https://www.nginx.com</a></li><li id="a5b4" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk nx mx my mz bi translated"><a class="ae lb" href="https://www.confluent.io/blog/" rel="noopener ugc nofollow" target="_blank">https://www . confluent . io</a></li><li id="f6ae" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk nx mx my mz bi translated">微服务从设计到部署——Chris Richardson与Floyd Smith</li><li id="007c" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk nx mx my mz bi translated">https://www.infoq.com优步-微服务-分布式-追踪— <a class="ae lb" href="https://www.infoq.com/" rel="noopener ugc nofollow" target="_blank"/></li><li id="bdff" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk nx mx my mz bi translated"><a class="ae lb" href="https://netflixtechblog.com/" rel="noopener ugc nofollow" target="_blank">https://netflixtechblog.com</a></li><li id="2f37" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk nx mx my mz bi translated"><a class="ae lb" href="https://medium.com/airbnb-engineering" rel="noopener">https://medium.com/airbnb-engineering</a></li><li id="7242" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk nx mx my mz bi translated">构建微服务— Sam Newman</li></ol></div></div>    
</body>
</html>