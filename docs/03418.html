<html>
<head>
<title>Best of Modern JavaScript — Typed Arrays and its Uses</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代 JavaScript 类型数组的精华及其用途</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/best-of-modern-javascript-typed-arrays-and-its-uses-db20f43827e7?source=collection_archive---------1-----------------------#2020-11-01">https://blog.devgenius.io/best-of-modern-javascript-typed-arrays-and-its-uses-db20f43827e7?source=collection_archive---------1-----------------------#2020-11-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/120984022079191ea416a897a9f4af25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kW9CmQMenBeoXVD-"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@bharathrajn89?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">巴拉思·拉杰·N</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="cfec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自 2015 年以来，JavaScript 有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究 JavaScript 类型化数组的用法。</p><h1 id="8966" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">静态类型化数组属性</h1><p id="ee74" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">类型化数组有<code class="fe me mf mg mh b">BYTES_PER_ELEMENT</code>属性来计算存储一个元素需要多少字节。</p><p id="7d47" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在类型化数组的原型中也有相同的属性。</p><h1 id="6e2d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">串联类型化数组</h1><p id="5a57" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">类型化数组不像普通数组那样有一个<code class="fe me mf mg mh b">concat</code>方法。</p><p id="3ee4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">set</code>方法，将类型化数组作为第一个参数，偏移量索引作为第二个参数。</p><p id="73b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a088" class="mq lc iq mh b gy mr ms l mt mu">const arr = Int8Array.of(1, 2, 3);<br/>const arr2 = Int8Array.of(4, 5, 6);</span><span id="fdf2" class="mq lc iq mh b gy mv ms l mt mu">const arrays = [arr, arr2];</span><span id="ac10" class="mq lc iq mh b gy mv ms l mt mu">let totalLength = 0;<br/>for (const arr of arrays) {<br/>  totalLength += arr.length;<br/>}</span><span id="5991" class="mq lc iq mh b gy mv ms l mt mu">const result = new Int8Array(totalLength);</span><span id="f8eb" class="mq lc iq mh b gy mv ms l mt mu">let offset = 0;<br/>for (const arr of arrays) {<br/>  result.set(arr, offset);<br/>  offset += arr.length;<br/>}</span><span id="d5fe" class="mq lc iq mh b gy mv ms l mt mu">console.log(result);</span></pre><p id="ed26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建一个新的<code class="fe me mf mg mh b">result</code>类型化数组，长度为所有数组的总长度。</p><p id="9e5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以用<code class="fe me mf mg mh b">set</code>方法将每个类型化数组的条目添加到<code class="fe me mf mg mh b">result</code>类型化数组中。</p><p id="7c7a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在每个数组后更新<code class="fe me mf mg mh b">offet</code>来添加条目。</p><h1 id="8eb0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">数据视图</h1><p id="5ae8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">DataView</code>构造函数让我们创建一个 DataView，它的数据存储在给定的 ArrayBuffer 中。</p><p id="2565" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它的签名是<code class="fe me mf mg mh b">(buffer, byteOffset, byteLength)</code>。</p><p id="fdbd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">buffer</code>是缓冲对象。</p><p id="e59c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">byteOffset</code>是缓冲区的偏移量，以字节为单位，</p><p id="39bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">byteLength</code>是数据视图的长度，以字节为单位。</p><h1 id="d948" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">数据视图实例属性</h1><p id="f641" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">DataView 具有以下实例属性。</p><p id="9fa8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">DataView.prototype.buffer</code>是一个 getter，它返回 DataView 的 ArrayBuffer。</p><p id="54d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">DataView.prototype.length</code>返回数据视图可以访问多少字节。</p><p id="f1a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">DataView.prototype.byteOffset</code>返回 DataView 开始访问其缓冲区中的字节的偏移量。</p><p id="e744" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">DataView.prototype.get</code>从数据视图的缓冲区返回一个值。</p><p id="a71a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它将字节偏移量作为第一个参数开始访问数组。</p><p id="4e27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个参数是是否将<code class="fe me mf mg mh b">littleEndian</code>设置为<code class="fe me mf mg mh b">true</code>。</p><p id="dd08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">默认是<code class="fe me mf mg mh b">false</code>。</p><p id="4f5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">DataView.prototype.set</code>让我们将一个值写入数据视图的缓冲区。</p><p id="1eb5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它的签名是<code class="fe me mf mg mh b">(byteOffset, value, littleEndian=false)</code>，<code class="fe me mf mg mh b">byteOffset</code>是开始写的偏移量。</p><p id="e220" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">value</code>美其名曰写。</p><p id="1b7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">littleEndian</code>让我们设置数据视图的字节顺序。</p><h1 id="8c8e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">类型化数组的用法</h1><p id="c9fa" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">打字电报被用在许多地方。</p><p id="131c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">文件 API 使用它来存储来自文件输入的文件数据。</p><p id="b211" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以通过编写以下内容来获得类型化数组:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0647" class="mq lc iq mh b gy mr ms l mt mu">const fileInput = document.getElementById('fileInput');</span><span id="4bb4" class="mq lc iq mh b gy mv ms l mt mu">fileInput.onchange = () =&gt; {<br/>  const file = fileInput.files[0];<br/>  const reader = new FileReader();<br/>  reader.readAsArrayBuffer(file);<br/>  reader.onload = function() {<br/>    const arrayBuffer = reader.result;    <br/>    //...<br/>  };<br/>}</span></pre><p id="f794" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe me mf mg mh b">fileInput.files[0]</code>得到文件对象。</p><p id="888e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们使用<code class="fe me mf mg mh b">FileReader</code>实例的<code class="fe me mf mg mh b">readAsArrayBuffer</code>函数将文件内容读入数组缓冲区。</p><p id="b25f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">reader.result</code>有结果了。</p><h1 id="cae6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">获取 API</h1><p id="6e02" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Fetch API 还允许我们以 ArrayBuffer 的形式获取数据。</p><p id="fe44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="50d3" class="mq lc iq mh b gy mr ms l mt mu">fetch('https://file-examples-com.github.io/uploads/2017/10/file-sample_150kB.pdf')<br/>  .then(request =&gt; request.arrayBuffer())<br/>  .then(arrayBuffer =&gt; {<br/>    console.log(arrayBuffer);<br/>  });</span></pre><p id="fb62" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从一个 URL 获取一个 PDF 文件，并在结果上使用<code class="fe me mf mg mh b">arrayBuffer</code>方法将其转换成一个 ArrayBuffer。</p><p id="33ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其他使用类型化数组的 API 包括 canvas 和 WebSockets。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/559cbdb92ec2b07567b89cbe54b7fc50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MDpJJJ5xn16Dqqlb"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@francistogram?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Fran </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="0134" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="7b20" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">类型化数组可以像数组一样被操作。</p><p id="1bd9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们被用在许多本地浏览器 API 中。</p></div></div>    
</body>
</html>