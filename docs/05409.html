<html>
<head>
<title>Data structures exercise: Making a collection available to Java’s For Each loops</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据结构练习:使集合对Java For Each循环可用</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/data-structures-exercise-making-a-collection-available-to-javas-for-each-loops-126e6cf8a877?source=collection_archive---------1-----------------------#2021-08-05">https://blog.devgenius.io/data-structures-exercise-making-a-collection-available-to-javas-for-each-loops-126e6cf8a877?source=collection_archive---------1-----------------------#2021-08-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8ad5631acb3e2a94db1fcefe3fa0b8bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HD4cGNP1g6FiHTM9"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@noah_negishi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">诺亚根岸</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="0749" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于<code class="fe lb lc ld le b">java.util.ArrayList</code>的一个好处是，您可以使用一个“增强的”For循环(称为“For Each”循环)遍历列表的内容。例如，鉴于</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="0046" class="ln lo iq le b gy lp lq l lr ls">ArrayList&lt;Transaction&gt; trx = account.getTransactions();</span></pre><p id="eedc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是不得不写</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="3195" class="ln lo iq le b gy lp lq l lr ls">CurrencyAmount bal = ZERO_DOLLARS;<br/>for (i = 0; i &lt; trx.size(); i++) {<br/>    Transaction curr = trx.get(i);<br/>    CurrencyAmount amt = curr.getAmount();<br/>    bal = bal.plus(amt);<br/>}</span></pre><p id="98a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以写</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="505f" class="ln lo iq le b gy lp lq l lr ls">CurrencyAmount bal = ZERO_DOLLARS;<br/>for (<strong class="le ir">Transaction trs : trx</strong>) {<br/>    CurrencyAmount amt = <strong class="le ir">trs</strong>.getAmount();<br/>    bal = bal.plus(amt);<br/>}</span></pre><p id="27e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您的集成开发环境(IDE)可能会为更少的代码行建议一个lambda。</p><p id="1473" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这不是一个只有在<code class="fe lb lc ld le b">java.util</code>中的职业才有的魔法能力。您可以简单地通过实现<code class="fe lb lc ld le b">Iterable&lt;E&gt;</code>接口赋予自己编写的集合类同样的能力。</p><p id="384b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嗯，可能没那么简单，因为你还得实现<code class="fe lb lc ld le b">Iterator&lt;E&gt;</code>接口。这可能看起来令人生畏，当我们考虑到我们可能会遇到职业角色转换问题时就更是如此。</p><p id="527f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每当任何编程任务看起来令人生畏时，测试驱动开发(TDD)通常会帮助我们克服阻碍我们开始任务的任何恐惧。</p><p id="240b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于未检查的强制转换问题，我们可能会想出一个非常不优雅的解决方案，但是如果我们通过TDD得到这个不优雅的解决方案，我们可以自由地快速尝试潜在的更优雅的解决方案，并检查它们是否按下按钮就能工作。</p><p id="9a65" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们认为可能更好的解决方案实际上不起作用，我们会知道，因为我们的一个或多个测试会失败。在这种情况下，我们可以回到不优雅的解决方案。</p><p id="a3b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个练习中，我们需要一些可以实现<code class="fe lb lc ld le b">Iterable&lt;E&gt;</code>但还没有实现的集合类。我在之前的文章中描述的<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/data-structures-exercise-array-backed-set-in-java-with-tdd-9a54cc06e5e5">中的数组支持的集合练习是这个练习的一个很好的候选。</a></p><p id="667b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个练习适用于数组支持的集合，但是除了缓存之外，您应该能够很容易地将它应用于其他集合类型。</p><p id="23f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一份非常粗略的草稿。请随意将它复制并粘贴到您最喜欢的IDE中，并使用它来阅读本文。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="5723" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据您的IDE，这应该至少有两个警告，或者如果您使用默认设置的IntelliJ IDEA，可能有十个警告。但是当我们完成的时候，我们会把它们减少到不超过一个。</p><p id="a229" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将<code class="fe lb lc ld le b">ArrayIterator</code>声明为私有包，因为我认为只有<code class="fe lb lc ld le b">collections</code>包中的类才能使用它。</p><p id="df6b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我想到，我们可以通过使<code class="fe lb lc ld le b">ArrayIterator&lt;E&gt;</code>成为<code class="fe lb lc ld le b">ArrayBackedSet&lt;E&gt;</code>的私有非静态嵌套类来避免未检查的强制转换警告的各种问题。但是我不想把它重写为<code class="fe lb lc ld le b">ArrayBackedList&lt;E&gt;</code>的私有非静态类。</p><p id="0078" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我的想法是，使用<code class="fe lb lc ld le b">ArrayIterator&lt;E&gt;</code>的类可以将它们的后备数组声明为<code class="fe lb lc ld le b">Object[]</code>或<code class="fe lb lc ld le b">E[]</code>。不管怎样，运行时类强制转换异常的幽灵仍然存在，因为它向后兼容泛型之前的Java版本。</p><p id="19bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我假设将使用<code class="fe lb lc ld le b">ArrayIterator&lt;E&gt;</code>的集合类通过在数组的第一个空闲位置添加新元素来工作，其余的都是空的，直到后备数组满了为止(在这个练习中，我们不担心扩展后备数组的容量)。</p><p id="32e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，当调用<code class="fe lb lc ld le b">ArrayIterator&lt;E&gt;</code>构造函数时，它接收一个数组和最后一个空闲索引作为其参数，并且它期望最后一个空闲索引之前的所有数组槽不为空。或者至少在我们编写了适当的测试并让它们通过之后会是这样。</p><p id="88ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不过，首先，我希望您编写测试来解决构造函数中的To Do注释中提到的三个问题(上面的第32、33和34行)。这三个很简单，所以我会很轻松地浏览一下。</p><p id="c9f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让你的IDE从JUnit开始<code class="fe lb lc ld le b">ArrayIteratorTest</code>，最好是JUnit 5，但是JUnit 4也不错。根据不同的设置，您可能会得到不同用途的测试过程存根。</p><p id="2e33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我让你来决定是要保留这些存根，因为它们以后可能会有用，还是要从空的括号开始。</p><p id="e82a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">编写由第一个待办事项注释(第32行)指示的测试，看到它失败，然后做最少的必要工作使它通过。</p><p id="96fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在构造函数中重复第二个和第三个To Do注释。TDD周期还包括一个重构步骤，但是在这个过程的早期阶段，这不太可能是必要的。</p><p id="dc4b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果数组<code class="fe lb lc ld le b">elements</code>为空，那么<code class="fe lb lc ld le b">ArrayIterator&lt;E&gt;</code>构造函数应该抛出一个<code class="fe lb lc ld le b">NullPointerException</code>和一个有用的非空异常消息。</p><p id="903b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">至于一个不好的<code class="fe lb lc ld le b">lastFreeIndex</code>参数(负值，或者正值但是太高)，我在想也许<code class="fe lb lc ld le b">IllegalArgumentException</code>有道理。如果您喜欢不同的异常，请相应地编写您的测试。如果你使用的是JUnit 5，那就利用一下<code class="fe lb lc ld le b">assertThrows()</code>。</p><p id="55f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">考虑到这一点，我们可以继续为<code class="fe lb lc ld le b">Iterator&lt;E&gt;</code>接口的“强制方法”编写测试。布尔<code class="fe lb lc ld le b">hasNext()</code>函数似乎是开始这部分过程的好地方。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="1aae" class="ln lo iq le b gy lp lq l lr ls">    @Test<br/>    void testHasNext() {<br/>        String msg = "Non-empty iterator should have next element";<br/>        String[] array = {msg};<br/>        ArrayIterator&lt;String&gt; iterator <br/>                = new ArrayIterator&lt;&gt;(array, 1);<br/>        assert iterator.hasNext() : msg;<br/>    }</span></pre><p id="6b91" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">提醒:如果您使用的是JUnit 4，测试过程必须是公共的(在JUnit 5中它们可能是公共的，但不一定是)。</p><p id="bf46" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个测试应该会失败。我们简单地通过将<code class="fe lb lc ld le b">ranOut</code>字段的初始化改为false来让它通过。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="3d7e" class="ln lo iq le b gy lp lq l lr ls">    private boolean ranOut = <strong class="le ir">false</strong>;</span></pre><p id="6ef1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一个测试实际上需要我们在<code class="fe lb lc ld le b">lastFreeIndex</code>为正数而不是0时让<code class="fe lb lc ld le b">ArrayIterator&lt;E&gt;</code>构造函数读入指定的数组元素。或者这可能超越了我们的想象。我们很快就会知道了。</p><p id="23ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一次测试的类型<code class="fe lb lc ld le b">E</code>没有太大关系。我要用<code class="fe lb lc ld le b">javax.naming.ldap.Rdn</code>。如果您选择也使用<code class="fe lb lc ld le b">Rdn</code>，请导入它。我也喜欢导入<code class="fe lb lc ld le b">java.util.Random</code>来拥有一个简单的伪随机数发生器，而不是编写一堆容易出错的<code class="fe lb lc ld le b">Math.random()</code>调用。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="7659" class="ln lo iq le b gy lp lq l lr ls">    @Test<br/>    void testDoesNotHaveNext() {<br/>        int size = RANDOM.nextInt(256) + 1;<br/>        Rdn[] array = new Rdn[size];<br/>        ArrayIterator&lt;Rdn&gt; iterator = new ArrayIterator&lt;&gt;(array, 0);<br/>        String msg = "Even though passed in array has " + size<br/>                + " slots, 0-capped iter should not have next elem";<br/>        assert !iterator.hasNext() : msg;<br/>    }</span></pre><p id="9a7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了通过这个测试，如果<code class="fe lb lc ld le b">lastFreeIndex</code>为0，那么<code class="fe lb lc ld le b">ArrayIterator&lt;E&gt;</code>构造器将<code class="fe lb lc ld le b">ranOut</code>设置为真就足够了。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="c4eb" class="ln lo iq le b gy lp lq l lr ls">    ArrayIterator(Object[] elements, int lastFreeIndex) {<br/>        // null check, index checks go here<br/>        <strong class="le ir">if (lastFreeIndex == 0) {<br/>            this.ranOut = true;<br/>        }</strong><br/>        E elem = (E) elements[0];<br/>        this.current = new Node&lt;&gt;(elem);<br/>    }</span></pre><p id="6f21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">验证这是否通过。此时，实际上不需要读入任何指定的数组元素。</p><p id="10e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们编写一个实际读取数组元素的测试之前，我们应该编写一个测试来检查当所有元素都通过<code class="fe lb lc ld le b">next()</code>给出时<code class="fe lb lc ld le b">ranOut</code>字段实际上从假变为真。</p><p id="cdd2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个<code class="fe lb lc ld le b">Iterator&lt;E&gt;</code>的核心概念。当<code class="fe lb lc ld le b">iterator.hasNext()</code>为真时，<code class="fe lb lc ld le b">iterator.next()</code>应该给出一个<code class="fe lb lc ld le b">E</code>类型的元素。但是一旦它为假，相同的函数调用应该导致<code class="fe lb lc ld le b">NoSuchElementException</code>(那是来自<code class="fe lb lc ld le b">java.util</code>，所以继续为它添加一个导入到<code class="fe lb lc ld le b">ArrayIteratorTest</code>)。</p><p id="91b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于下一个测试，只有一个元素的数组也足够了。一旦单个元素由<code class="fe lb lc ld le b">next()</code>给出，<code class="fe lb lc ld le b">hasNext()</code>应该返回false，而不是true。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="52cf" class="ln lo iq le b gy lp lq l lr ls">    @Test<br/>    void testHasNextChangesToDoesNotHaveNext() {<br/>        String[] array = {"Just one element for this test"};<br/>        ArrayIterator&lt;String&gt; iterator <br/>                = new ArrayIterator&lt;&gt;(array, 1);<br/>        String preMsg = "Iterator should have next element";<br/>        assert iterator.hasNext() : preMsg;<br/>        String element = iterator.next();<br/>        String postMsg = "After giving single element \"" + element<br/>                + "\", iterator should not have next anymore";<br/>        assert !iterator.hasNext() : postMsg;<br/>    }</span></pre><p id="c989" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，我们没有对<code class="fe lb lc ld le b">next()</code>实际上给出了什么做出任何断言。那是因为我们还没有为<code class="fe lb lc ld le b">next()</code>本身编写任何测试。</p><p id="c27d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一步是重写<code class="fe lb lc ld le b">ArrayIterator&lt;E&gt;</code>构造函数，这样它实际上将数组元素读入<code class="fe lb lc ld le b">Node&lt;E&gt;</code>实例。本质上，这构建了一个单链表。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="0726" class="ln lo iq le b gy lp lq l lr ls">    ArrayIterator(Object[] elements, int lastFreeIndex) {<br/>        // null check, index checks go here<br/>        if (lastFreeIndex == 0) {<br/>            this.ranOut = true;<br/>        }<br/>        E elem = (E) elements[0];<br/>        this.current = new Node&lt;&gt;(elem);<br/>        <strong class="le ir">Node&lt;E&gt; node = this.current;<br/>        Node&lt;E&gt; follower;<br/>        for (int i = 1; i &lt; lastFreeIndex; i++) {<br/>            elem = (E) elements[i];<br/>            follower = new Node&lt;&gt;(elem);<br/>            node.attachNext(follower);<br/>            node = follower;<br/>        }</strong><br/>    }</span></pre><p id="bc53" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们重写<code class="fe lb lc ld le b">next()</code>来遍历单链表，一次遍历一个节点。但是在用完节点之前，它仍然会返回null，当用完节点时，它会抛出<code class="fe lb lc ld le b">RuntimeException</code>而不是<code class="fe lb lc ld le b">NoSuchElementException</code>。</p><p id="ed43" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是为了在我们着手为<code class="fe lb lc ld le b">next()</code>编写测试时保留最初的测试失败。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="0274" class="ln lo iq le b gy lp lq l lr ls">    @Override<br/>    public E next() {<br/>        <strong class="le ir">if (this.ranOut) {<br/>            String excMsg = "No more elements to iterate through";<br/>            throw new RuntimeException(excMsg);<br/>        }<br/>        if (this.current.nextElement == null) {<br/>            this.ranOut = true;<br/>        } else {<br/>            this.current = this.current.nextElement;<br/>        }</strong><br/>        return null;<br/>    }</span></pre><p id="4637" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了这些改变，我们对<code class="fe lb lc ld le b">hasNext()</code>的最新测试现在应该通过了。</p><p id="fcfb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于重构，我担心<code class="fe lb lc ld le b">ArrayIterator&lt;E&gt;</code>构造函数超过二十行。</p><p id="20fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，现在更紧迫的问题可能是，您的IDE现在至少向您显示了三个警告(至少IntelliJ是这样)。也许让接下来的几个测试通过会清除警告。</p><p id="16c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以现在没有重构。我建议下一个测试要求<code class="fe lb lc ld le b">lastFreeIndex</code>之前的所有数组元素都为非空。我让你写这个。</p><p id="35e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这正是我为编写私有函数<code class="fe lb lc ld le b">ascertainNotNull()</code>的原因。像这样编辑构造函数:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="4857" class="ln lo iq le b gy lp lq l lr ls">    ArrayIterator(Object[] elements, int lastFreeIndex) {<br/>        // null check, index checks go here<br/>        <strong class="le ir">E elem;</strong><br/>        if (lastFreeIndex == 0) {<br/>            <strong class="le ir">elem = (E) elements[0];</strong><br/>            this.ranOut = true;<br/>        } <strong class="le ir">else {<br/>            elem = this.ascertainNotNull((E) elements[0], 0);<br/>        }</strong><br/>        this.current = new Node&lt;&gt;(elem);<br/>        Node&lt;E&gt; node = this.current;<br/>        Node&lt;E&gt; follower;<br/>        for (int i = 1; i &lt; lastFreeIndex; i++) {<br/>            elem = <strong class="le ir">this.ascertainNotNull(</strong>elements[i]<strong class="le ir">, i)</strong>;<br/>            follower = new Node&lt;&gt;(elem);<br/>            node.attachNext(follower);<br/>            node = follower;<br/>        }<br/>    }</span></pre><p id="426a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在测试应该通过了。这一改变的额外好处是，除了一个警告之外，所有的警告都被消除了:在<code class="fe lb lc ld le b">ascertainNotNull()</code>中未检查的类型强制转换。可能没有简洁、简单的方法来消除这个警告。</p><p id="7ef8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们先不要担心这个，先把它放在一边，然后继续测试，测试需要迭代器实际给出数组的元素。</p><p id="b405" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于这个测试，我使用<code class="fe lb lc ld le b">java.math.BigInteger</code>作为<code class="fe lb lc ld le b">E</code>类型，因为它很容易生成伪随机实例。被测类更难猜出伪随机数。</p><p id="cf05" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您还没有为<code class="fe lb lc ld le b">BigInteger</code>添加一个导入语句，请将其添加到测试类中。然后进行这个测试:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="6c1e" class="ln lo iq le b gy lp lq l lr ls">    @Test<br/>    void testNext() {<br/>        int size = RANDOM.nextInt(32) + 1;<br/>        BigInteger[] array = new BigInteger[size];<br/>        BigInteger number;<br/>        for (int i = 0; i &lt; size; i++) {<br/>            number = new BigInteger(64 + i, RANDOM);<br/>            array[i] = number;<br/>        }<br/>        ArrayIterator&lt;BigInteger&gt; iterator <br/>                = new ArrayIterator&lt;&gt;(array, size);<br/>        int counter = 0;<br/>        while (iterator.hasNext()) {<br/>            number = iterator.next();<br/>            assertEquals(array[counter], number);<br/>            counter++;<br/>        }<br/>    }</span></pre><p id="26b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，测试失败了，因为<code class="fe lb lc ld le b">next()</code>返回null，即使它实际上正在遍历链表。我们只需要对<code class="fe lb lc ld le b">next()</code>做一些小的改动就能通过测试:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="57d4" class="ln lo iq le b gy lp lq l lr ls">    @Override<br/>    public E next() {<br/>        if (this.ranOut) {<br/>            String excMsg = "No more elements to iterate through";<br/>            throw new RuntimeException(excMsg);<br/>        }<br/>        <strong class="le ir">E element = this.current.element;</strong><br/>        if (this.current.nextElement == null) {<br/>            this.ranOut = true;<br/>        } else {<br/>            this.current = this.current.nextElement;<br/>        }<br/>        return <strong class="le ir">element</strong>;<br/>    }</span></pre><p id="0901" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看起来我们现在唯一缺少的是确保迭代器在元素用完时抛出<code class="fe lb lc ld le b">NoSuchElementException</code>。</p><p id="d411" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此时，您可能想简单地将<code class="fe lb lc ld le b">RuntimeException</code>改为<code class="fe lb lc ld le b">NoSuchElementException</code>，但是我们需要首先编写一个测试。我也把这个留给你。</p><p id="4877" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您使用的是JUnit 5，请使用<code class="fe lb lc ld le b">assertThrows()</code>。如果您使用的是JUnit 4，您可以在<code class="fe lb lc ld le b">@Test</code>注释上使用<code class="fe lb lc ld le b">expected</code>属性，但是我会使用传统的Try-Fail-Catch。</p><p id="e858" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">测试失败，因为当前<code class="fe lb lc ld le b">next()</code>抛出的是<code class="fe lb lc ld le b">RuntimeException</code>，而不是它的子类<code class="fe lb lc ld le b">NoSuchElementException</code>。校正非常容易。首先，为该异常添加一个导入。您的IDE可能已经猜到这就是您想要添加的内容。然后更改<code class="fe lb lc ld le b">next()</code>来抛出异常。测试应该会通过。</p><p id="12b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们几乎准备好将它连接到一个数组支持的集合。如果没有明显的重构要做，我们应该看看我们是否需要实现任何有默认实现的东西。</p><p id="914e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从Javadoc 的<a class="ae kc" href="https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html" rel="noopener ugc nofollow" target="_blank">中，我们看到<code class="fe lb lc ld le b">Iterator&lt;E&gt;</code>接口指定了两个函数和两个过程，但是实现类只需要<code class="fe lb lc ld le b">hasNext()</code>和<code class="fe lb lc ld le b">next()</code>函数。</a></p><p id="caa6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">forEachRemaining()</code>程序可能是每个循环的启动程序。它的默认实现归结为在<code class="fe lb lc ld le b">hasNext()</code>返回true时调用<code class="fe lb lc ld le b">next()</code>。我们应该让它保持原样。</p><p id="9741" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">remove()</code>过程应该允许通过迭代器从底层集合中移除元素。这似乎是多线程环境中的一个麻烦。</p><p id="04f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">remove()</code>的默认实现只是抛出一个<code class="fe lb lc ld le b">UnsupportedOperationException</code>的实例，并给出无用的消息“remove”但是我还没有不喜欢到推翻<code class="fe lb lc ld le b">remove()</code>的地步。</p><p id="88ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在将它连接到一个数组支持的集合，就像上一个练习中的<code class="fe lb lc ld le b">ArrayBackedSet&lt;E&gt;</code>。确保该课程的所有测试都通过。</p><p id="fc8d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后将<code class="fe lb lc ld le b">Iterable&lt;E&gt;</code>添加到您选择的集合类的类声明中(不需要导入，因为该接口来自<code class="fe lb lc ld le b">java.lang</code>包)。</p><p id="6787" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这应该会导致一个错误，因为<code class="fe lb lc ld le b">Iterable&lt;E&gt;</code>要求我们实现<code class="fe lb lc ld le b">iterator()</code>，一个返回<code class="fe lb lc ld le b">Iterator&lt;E&gt;</code>实例的函数。我建议放入下面的存根来清除这个错误:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="896f" class="ln lo iq le b gy lp lq l lr ls">    // TODO: Write a test for this<br/>    @Override<br/>    public Iterator&lt;E&gt; iterator() {<br/>        return new ArrayIterator&lt;&gt;(this.elements, 0);<br/>    }</span></pre><p id="08f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也是<code class="fe lb lc ld le b">java.util.Iterator&lt;E&gt;</code>的一个导入。</p><p id="bb73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，在相应的测试类中，编写一个测试。对于这个测试来说,<code class="fe lb lc ld le b">E</code>类型并不重要，重要的是集合应该有多于零个的非空元素，这样测试第一次就会失败。</p><p id="9b81" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我写了一个测试，开始时使用一个标准的For循环，用伪随机<code class="fe lb lc ld le b">BigInteger</code>实例填充一组由数组支持的<code class="fe lb lc ld le b">BigInteger</code>。我将测试的源代码列表分开，以便在中间给出解释。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="974f" class="ln lo iq le b gy lp lq l lr ls">    @Test<br/>    void testIterator() {<br/>        System.out.println("iterator");<br/>        int size = RANDOM.nextInt(48) + 16;<br/>        ArrayBackedSet&lt;BigInteger&gt; expected <br/>                = new ArrayBackedSet&lt;&gt;(size);<br/>        BigInteger number;<br/>        for (int i = 0; i &lt; size; i++) {<br/>            number = new BigInteger(i + 32, RANDOM);<br/>            expected.add(number);<br/>        }</span></pre><p id="5ef6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，测试应该使用相同的<code class="fe lb lc ld le b">E</code>类型创建一个新的集合实例，这次使用For Each循环将第一个集合的元素添加到第二个集合中。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="1ce1" class="ln lo iq le b gy lp lq l lr ls">        ArrayBackedSet&lt;BigInteger&gt; actual <br/>                = new ArrayBackedSet&lt;&gt;(size);<br/>        for (BigInteger n : expected) {<br/>            actual.add(n);<br/>        }<br/>        assertEquals(expected, actual);<br/>    }</span></pre><p id="3894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您没有任何语法错误(比如由于不完整的复制和粘贴导致的错误粘贴)，您就可以运行测试了。</p><p id="0982" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它应该会失败。在我的系统上，测试首先用以下伪随机数生成了一个数组支持的集合:2478834069，4237164324，3174102804，你明白了吧。在您的系统上，您可能会看到也可能看不到任何伪随机数。</p><p id="79ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为<code class="fe lb lc ld le b">lastFreeIndex</code>为0，迭代器的<code class="fe lb lc ld le b">hasNext()</code>函数在第一次从<code class="fe lb lc ld le b">forEachRemaining()</code>调用时返回false，所以根本不给出任何元素。</p><p id="fb2b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们简单地通过将<code class="fe lb lc ld le b">lastFreeIndex</code>参数更改为正确的界限来使测试通过。根据您如何进行数组支持的set练习，这可能是<code class="fe lb lc ld le b">this.nextUp</code>。</p><p id="8640" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不需要编写对<code class="fe lb lc ld le b">iterator()</code>函数的直接调用，因为这是启用For Each循环的原因。如果您对此有丝毫怀疑，请从集合类中删除“<code class="fe lb lc ld le b">implements Iterable&lt;E&gt;</code>”，并验证测试类中显示的错误。</p><p id="5ec5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行测试，应该会通过。现在您知道了如何让自己编写的Java集合对For Each循环可用。</p><h1 id="d9cb" class="lv lo iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">重构</h1><p id="ce0e" class="pw-post-body-paragraph kd ke iq kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">关于TDD的一个好处是它帮助我们防止过度工程化。不过，这并不能完全阻止它。我在这里提出的解决方案是过度设计的。</p><p id="935a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它应该是一个数组迭代器，然而它创建了一个单链表？那太多了。删除<code class="fe lb lc ld le b">Node&lt;E&gt;</code>类并相应地重构。你可以这样做，因为如果你怀疑你的更好的解决方案真的更好，你可以运行测试。</p><h1 id="12ad" class="lv lo iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">结论，现在</h1><p id="e723" class="pw-post-body-paragraph kd ke iq kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">我想到，也许我们可以为数组支持的集合创建一个抽象超类。那么这个抽象超类包含<code class="fe lb lc ld le b">ArrayIterator&lt;E&gt;</code>作为私有的、非静态的内部类。</p><p id="fb3e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，所有的子类都不必实现<code class="fe lb lc ld le b">iterator()</code>。也许这将清除所有未检查的演员警告。但这是另一篇文章的主题。</p></div></div>    
</body>
</html>