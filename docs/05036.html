<html>
<head>
<title>How to Create A Loading Scene in Unity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Unity中创建装载场景</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-create-a-loading-scene-in-unity-19589666df82?source=collection_archive---------1-----------------------#2021-06-06">https://blog.devgenius.io/how-to-create-a-loading-scene-in-unity-19589666df82?source=collection_archive---------1-----------------------#2021-06-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="d084" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">异步操作和进度条</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/d93615149d37d5f685eab307a291d8ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*meTkA7LJ44PRxD8bMBvtoA.gif"/></div></div></figure><p id="fee7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Unity有<a class="ae lk" href="https://docs.unity3d.com/2021.1/Documentation/ScriptReference/AsyncOperation.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> AsyncOperation </strong> </a>可以用来加载<a class="ae lk" href="https://docs.unity3d.com/2021.1/Documentation/ScriptReference/SceneManagement.SceneManager.LoadSceneAsync.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">场景</strong></a><a class="ae lk" href="https://docs.unity3d.com/2021.1/Documentation/ScriptReference/AssetBundle.LoadAssetAsync.html" rel="noopener ugc nofollow" target="_blank"><strong class="kq io">资产</strong></a><a class="ae lk" href="https://docs.unity3d.com/2021.1/Documentation/ScriptReference/Resources.LoadAsync.html" rel="noopener ugc nofollow" target="_blank"><strong class="kq io">资源</strong> </a>。这些操作的目的是当游戏继续运行时，Unity中的资产可以在后台用协程加载。大型资产的加载需要几秒甚至几分钟的时间，这取决于运行它的硬件的互联网速度(如果从互联网加载)。在Unity中使用正常的加载功能可以让它看起来像游戏被破坏了一样。</p><p id="b5c6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我的游戏关卡需要几秒钟才能加载。当游戏加载时，我会显示一个带有进度条的加载屏幕，这样玩家就可以看到游戏没有被破坏，它只是在加载。</p><h1 id="eac4" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">场景设置</h1><p id="947b" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">在unity中显示任何类型的进度条的基础是拥有一个<strong class="kq io">图像类型</strong>设置为填充的图像。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/db5f7f88ae87bdba4aa7862287a585f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/1*CWZK8fjU7w6w_wyuox0IPA.gif"/></div></figure><p id="3375" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">有几种不同的<strong class="kq io">填充方法</strong>和不同的<strong class="kq io">填充原点</strong>可以用来控制<strong class="kq io">图像</strong>的填充方式。圆形样式填充也有顺时针选项。正如你所看到的，Unity有一个非常强大且易于使用的系统，可以处理大多数类型的灌装。因为我有一个水平栏，我想让它从左向右填充，所以我将使用<code class="fe mj mk ml mm b"><strong class="kq io">Fill Method</strong>=Horizontal</code>和<code class="fe mj mk ml mm b"><strong class="kq io">Fill Origin</strong>=Left</code></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mn"><img src="../Images/e4f845149c48867e545e8335dfd2d620.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*N35qdjyiMbjcJ9XaIcuRbw.gif"/></div></div></figure><p id="9511" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">更改填充代码非常简单，只需获取对图像的引用，并将填充量设置为0到1之间的浮点数，0表示空，0.5表示一半，1表示满。恰好Unity中的<a class="ae lk" href="https://docs.unity3d.com/2021.1/Documentation/ScriptReference/AsyncOperation.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> AsyncOperation </strong> </a>方法有一个<a class="ae lk" href="https://docs.unity3d.com/2021.1/Documentation/ScriptReference/AsyncOperation-progress.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> Progress </strong> </a>属性，返回一个0到1之间的数字。</p><h1 id="3e82" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">代码</h1><p id="8c13" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">我需要一个从Start方法启动的协程</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mo"><img src="../Images/604ced9cf91eb0f487e02ee42081a31c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Z5CVzwjHseSmEDq9Kx_IUA.gif"/></div></div></figure><p id="5889" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">加载场景需要一个字符串作为场景名称，或者一个int作为构建索引。我需要一种方法来与负载级场景之外的其他场景进行交流，有几种方法可以做到这一点，即脚本化对象或静态变量。我将使用一个公共的静态Int变量。我还需要一个有填充类型的图像。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/6063e9c718acce359c7fad17f71e73f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*kc7F7OoqSoZPM2XdfCtZqQ.png"/></div></figure><p id="4a6c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在Start方法中，我做了一些错误检查，以确保我有进度条图像。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mq"><img src="../Images/e34beff8e7e4e401b4909f2d3171a6ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*njEqF5h_arljZbPOykPq0w.png"/></div></div></figure><p id="4118" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在加载场景协程中，我需要从<a class="ae lk" href="https://docs.unity3d.com/2021.1/Documentation/ScriptReference/SceneManagement.SceneManager.LoadSceneAsync.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">加载场景异步</strong> </a>方法中获取<a class="ae lk" href="https://docs.unity3d.com/2021.1/Documentation/ScriptReference/AsyncOperation.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">异步操作</strong> </a>。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mr"><img src="../Images/315fbd8657862874d2880e37f28ae882.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Zpna4q9Mxwujx3KbrttChA.gif"/></div></div></figure><p id="7bc8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在我可以使用<a class="ae lk" href="https://docs.unity3d.com/2021.1/Documentation/ScriptReference/AsyncOperation.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">异步操作</strong> </a>来显示场景加载的进度。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ms"><img src="../Images/ec72183d99f14e64b8b8430abf4376c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*f8OOPNfmxljhgfqw42JYeg.gif"/></div></div></figure><p id="7861" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在我需要从我的主菜单行为中使用加载场景。我为加载屏幕的构建索引添加了一个变量，<a class="ae lk" rel="noopener ugc nofollow" target="_blank" href="/making-the-inspector-look-better-175baf39ada0"> <strong class="kq io">场景属性</strong> </a>，这样我就可以从下拉列表中选择场景。我必须更改方法的名称，这样我才能访问负载级别行为。我将场景设置为加载，然后加载加载场景。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/1a3625cb8efbd9e6e236cd772c3b1f7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/1*QXmiq2QIhKxWW0PPKItxTA.gif"/></div></figure><p id="f5fd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在主菜单场景中，我需要修复Start按钮，因为我更改了它正在使用的方法的名称，丢失了对该方法的引用。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mu"><img src="../Images/1537eceaf3222c959fb2cd67012a408c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*yNHw0Y2fgZOVIF4BojJ2Uw.gif"/></div></div></figure><p id="bba6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在我需要确保加载屏幕在构建设置中。然后我可以在下拉列表中设置它。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mv"><img src="../Images/b21cb49fd26c666962474e4ba0cfb0bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Sowh9oLOJiFTwHMG6MSP_Q.gif"/></div></div></figure><p id="4f3a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在开始游戏有一个很好的过渡。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/1c674e0fbcd335742cad7931e82c51e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/1*KbFkw3jMhbOpQJxukBcvCA.gif"/></div></figure><p id="503f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我甚至可以使用UI管理器中的加载屏幕。这样做的好处是，我不需要担心当前场景的场景索引是什么，因为它已经在静态场景中加载构建索引了。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ms"><img src="../Images/40c95bee882ffd0d882eb4e4e5523d77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*eqtug7nsd4MsloSTOpveHg.gif"/></div></div></figure><p id="b892" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">固定装载杆。因此，进度返回值0到0.9，因为最后的0.1实际上是在场景激活过程中完成的，我实际上从来没有看到过，因为完成设置为true。为了让我的进度条在卸载加载场景之前完全显示，我需要通过除以0.9，然后使用Mathf将其箝位，将进度条转换为0到1之间的数字。夹具01</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mx"><img src="../Images/271f4c90025e9da7a7e3488b22ad088e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*pXaBRBKMHH_UJgysr-U5Ow.gif"/></div></div></figure><h1 id="4f67" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated"><a class="ae lk" href="https://docs.unity3d.com/2021.1/Documentation/ScriptReference/AsyncOperation-allowSceneActivation.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">允许场景操作</strong> </a></h1><p id="c61d" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated"><a class="ae lk" href="https://docs.unity3d.com/2021.1/Documentation/ScriptReference/AsyncOperation.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">异步操作</strong> </a>也有<a class="ae lk" href="https://docs.unity3d.com/2021.1/Documentation/ScriptReference/AsyncOperation-allowSceneActivation.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">允许场景操作</strong> </a>允许我保持下一个场景不完全加载。我可以用它来做一些其他有趣的事情，比如显示关于游戏或游戏知识的提示。我不会在我目前的游戏中使用这个。为了使用它，我在while循环之前将它设置为false，在while循环中，我需要添加一个条件，一旦进度达到0.9就将它设置为true，例如，我可以等待一段时间，进入另一个while循环，等到玩家按下空格键，等待另一个Corutine完成。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi my"><img src="../Images/f296b8c5decfc98a4d35e96bbb160a2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*lzuyQzzqB6CdQKKjqNmtvA.gif"/></div></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/d6576ce4a8cf7577a46a126d27d07254.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/1*aJSOAeaF_wc_9UHYJ5EFwg.gif"/></div></figure></div></div>    
</body>
</html>