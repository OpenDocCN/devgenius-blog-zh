<html>
<head>
<title>Use Generics to follow DRY principles without guilt</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用泛型来遵循枯燥的原则，而没有负罪感</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/use-generics-to-follow-dry-principles-without-guilt-7602e6914b0a?source=collection_archive---------3-----------------------#2021-08-29">https://blog.devgenius.io/use-generics-to-follow-dry-principles-without-guilt-7602e6914b0a?source=collection_archive---------3-----------------------#2021-08-29</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><p id="ae7b" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">干——不要重复你的</p><figure class="kn ko kp kq gu kr gi gj paragraph-image"><div class="gi gj km"><img src="../Images/f62025dce44d44d2a203ebda8181171c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*mBSurGNKYRN7hMtuJ387DA.png"/></div></figure><p id="8e33" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">最常用的开发实践之一是遵循 DRY(不要重复自己)原则。这一原则的目的是避免代码重复。它消除了技术债务，促进了代码的简单维护。</p><p id="c0ef" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">有时，<a class="ae ku" href="https://jeremiahflaga.github.io/2021/10/01/on-the-tension-between-DRY-and-SRP/" rel="noopener ugc nofollow" target="_blank">遵循 DRY 原则</a>可能会很棘手，因为如果我们在一个地方组合许多功能或编写许多条件逻辑，它可能会违反<a class="ae ku" href="https://tarunbhatt9784.medium.com/solid-take-responsibility-c5404bf2d4c8?sk=29b469d3fe353abec3e3352f9dc69559" rel="noopener">单一责任原则</a>。</p><p id="f24f" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">我们可以坚持 DRY 原则而不用担心违反 SRP 的方法之一是使用泛型。在这篇文章中，我将使用 C#，但是其他一些软件语言也支持泛型，概念或多或少是相同的。</p></div><div class="ab cl kv kw hv kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ik il im in io"><h1 id="0030" class="lc ld ir bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">什么是泛型</h1><blockquote class="ma"><p id="05d3" class="mb mc ir bd md me mf mg mh mi mj kl dk translated">泛型允许软件程序员在不指定数据类型但确保类型安全的情况下编写代码。</p></blockquote><p id="1573" class="pw-post-body-paragraph jo jp ir jq b jr mk jt ju jv ml jx jy jz mm kb kc kd mn kf kg kh mo kj kk kl ik bi translated">泛型的最好例子是查看一些集合类，如 List、Dictionary 等。</p><pre class="kn ko kp kq gu mp mq mr ms aw mt bi"><span id="9412" class="mu ld ir mq b gz mv mw l mx my">IList&lt;string&gt; strings = new List&lt;string&gt;();</span></pre><p id="c440" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">在上一行中，我们已经初始化了一个字符串列表。这并不意味着我们只能创建一个字符串列表。List 支持开发任何类型的列表。例如，要实例化 Employee 类型的对象列表，我们可以执行以下操作:</p><pre class="kn ko kp kq gu mp mq mr ms aw mt bi"><span id="2cf4" class="mu ld ir mq b gz mv mw l mx my">IList&lt;Employee&gt; employees = new List&lt;Employee&gt;();</span></pre><p id="b558" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">这并不意味着有一个单独的类来创建字符串和类雇员的列表。不仅如此，用于添加一个字符串或者 employee 类型的类的 Add()也是一样的。</p><figure class="kn ko kp kq gu kr gi gj paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gi gj mz"><img src="../Images/d0c78c7e31b5d34806ac3fc312228c3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oMsiNHzN8lDbVd67_DD0QA.png"/></div></div><figcaption class="ne nf gk gi gj ng nh bd b be z dk translated">我的开发人员笔记本电脑截图</figcaption></figure><p id="71a2" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">有了这个介绍，我将把这篇文章分成三个部分</p><ol class=""><li id="11da" class="ni nj ir jq b jr js jv jw jz nk kd nl kh nm kl nn no np nq bi translated">创建泛型类</li><li id="03a2" class="ni nj ir jq b jr nr jv ns jz nt kd nu kh nv kl nn no np nq bi translated">创建泛型方法</li><li id="d52e" class="ni nj ir jq b jr nr jv ns jz nt kd nu kh nv kl nn no np nq bi translated">向泛型方法或类添加约束</li></ol></div><div class="ab cl kv kw hv kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ik il im in io"><h1 id="9199" class="lc ld ir bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">创建泛型类</h1><p id="d178" class="pw-post-body-paragraph jo jp ir jq b jr nw jt ju jv nx jx jy jz ny kb kc kd nz kf kg kh oa kj kk kl ik bi translated">假设我们需要一个执行一些列表操作的类:</p><ol class=""><li id="3180" class="ni nj ir jq b jr js jv jw jz nk kd nl kh nm kl nn no np nq bi translated">InsertRecordAt() —在字符串列表中的特定位置插入记录</li><li id="a03b" class="ni nj ir jq b jr nr jv ns jz nt kd nu kh nv kl nn no np nq bi translated">MergeList() —合并两个字符串列表。</li></ol><p id="4145" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">这些方法的代码将类似于</p><figure class="kn ko kp kq gu kr"><div class="bz fq l di"><div class="ob oc l"/></div></figure><p id="23cc" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">假设我们想要对整数列表或任何其他类型的列表执行类似的操作。我们将不得不制定新的方法。由于创建这些额外方法的逻辑将与现有方法相同，所以问题是违反了 DRY(不要重复自己)原则。</p><p id="40a1" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">让我们利用泛型为任何类型的列表创建逻辑。</p><figure class="kn ko kp kq gu kr"><div class="bz fq l di"><div class="ob oc l"/></div></figure><p id="63c5" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">让我们比较这两个类以及它们的实例化方式</p><figure class="kn ko kp kq gu kr gi gj paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gi gj od"><img src="../Images/0582da467d5ef63713e2fba2e9794f6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4nPFsKmh8RJucOVEOef3EQ.png"/></div></div><figcaption class="ne nf gk gi gj ng nh bd b be z dk translated">从我的开发人员笔记本电脑</figcaption></figure></div><div class="ab cl kv kw hv kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ik il im in io"><h1 id="d2ea" class="lc ld ir bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">创建泛型方法</h1><p id="02c8" class="pw-post-body-paragraph jo jp ir jq b jr nw jt ju jv nx jx jy jz ny kb kc kd nz kf kg kh oa kj kk kl ik bi translated">做任何事都是一个问题。如果我们不希望所有的类方法都操作泛型参数，我们应该使用泛型方法而不是泛型类。下面的示例演示了由泛型和非泛型方法组成的非泛型类:</p><figure class="kn ko kp kq gu kr"><div class="bz fq l di"><div class="ob oc l"/></div></figure><p id="d957" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">泛型和非泛型方法可以被称为:</p><pre class="kn ko kp kq gu mp mq mr ms aw mt bi"><span id="ada8" class="mu ld ir mq b gz mv mw l mx my">ListOperations ops1 = new ListOperations();</span><span id="150d" class="mu ld ir mq b gz oe mw l mx my">ops1.InsertRecordAt&lt;string&gt;(originalList, “item 3”, 4);<br/>ops1.NonGenericMethod();</span></pre></div><div class="ab cl kv kw hv kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ik il im in io"><h1 id="f445" class="lc ld ir bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">带约束的泛型</h1><p id="433b" class="pw-post-body-paragraph jo jp ir jq b jr nw jt ju jv nx jx jy jz ny kb kc kd nz kf kg kh oa kj kk kl ik bi translated">可能会有这样的情况，我们希望对泛型类或方法的使用者施加约束。例如，如果您希望将列表操作用于引用而不是值数据类型。执行以下操作</p><pre class="kn ko kp kq gu mp mq mr ms aw mt bi"><span id="d129" class="mu ld ir mq b gz mv mw l mx my">public class ListOperations&lt;T&gt; where T : class</span></pre><p id="8226" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">完整的类将看起来像:</p><figure class="kn ko kp kq gu kr"><div class="bz fq l di"><div class="ob oc l"/></div></figure><p id="99ca" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">如果我们使用这个类对整数进行任何列表操作，编译器将会报错，因为 int 数据类型是值类型而不是引用类型。</p><figure class="kn ko kp kq gu kr gi gj paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gi gj of"><img src="../Images/74d3fa1d5d301655ad93ca35ced9e745.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4q8jK_fRQ62v3aBQtYnMmw.png"/></div></div><figcaption class="ne nf gk gi gj ng nh bd b be z dk translated">从我的开发人员笔记本电脑</figcaption></figure><p id="9a58" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">本文是对 C#中泛型的快速介绍。这是一个很大的话题，我希望在接下来的会议中能涉及更多。</p><p id="441c" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">谢谢</p><p id="9f94" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">塔伦</p></div><div class="ab cl kv kw hv kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ik il im in io"><blockquote class="ma"><p id="343b" class="mb mc ir bd md me mf mg mh mi mj kl dk translated">页（page 的缩写）s-Medium 是一个阅读、写作和向其他作者学习的绝佳平台。如果你想加入我的旅程，今天就加入<a class="ae ku" href="https://tarunbhatt9784.medium.com/membership" rel="noopener"> medium </a>。</p></blockquote></div></div>    
</body>
</html>