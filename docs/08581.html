<html>
<head>
<title>Download a video from YouTube and convert it to mp3 using Python/Django</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从 YouTube 下载一个视频，并使用 Python/Django 将其转换为 mp3</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/download-a-video-from-youtube-and-convert-it-to-mp3-using-python-django-552141990d57?source=collection_archive---------2-----------------------#2022-06-26">https://blog.devgenius.io/download-a-video-from-youtube-and-convert-it-to-mp3-using-python-django-552141990d57?source=collection_archive---------2-----------------------#2022-06-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/7c98440457bae4a0acb55c2a61668f0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BmsIdhNrHMinLXHe24sjOg.jpeg"/></div></div></figure><p id="4802" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是我和姜戈可爱约会历史上的第二篇博文。我最近的经历是关于我将要谈到的几件事:处理文件(上传、转换、删除和作为临时文件存储)，将它们存储在存储器中(在我们的例子中是 AWS S3 Bucket 🪣)，以及将有关它的数据保存到数据库中。</p><ol class=""><li id="949f" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">我的第一个目标是从 YouTube URL 下载一个视频。</li><li id="c216" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">之后再转换成 mp3。</li><li id="39c0" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">接下来，将 mp3 文件保存到存储器中。</li><li id="5dd1" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">最后，在数据库中保存关于它的信息以及到它的存储链接。</li></ol></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><ol class=""><li id="5ba3" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated"><strong class="jx io">通过 YouTube 网址下载视频。</strong></li></ol><p id="c63d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我们需要下载视频。</p><p id="4445" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我在所有解决方案中使用的一个包是“pytube”，用于通过 URL 下载 YouTube 视频，而不是带有图像的完整视频，而是视频中的音频。</p><p id="1312" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当然，我们可以用 pip 安装它:</p><p id="ac88" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lo lp lq lr b">pip3 install pytube</code></p><p id="4254" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们需要使用它导入“Youtube”类:</p><p id="61f8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lo lp lq lr b">from pytube import YouTube</code></p><p id="6e5d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我们需要从 YouTube 视频下载一个音频流，只接收它的 URL。为此，我们肯定会使用“pytube”包。它有很多很好的功能，如解析所有视频流格式(mp3，mp4，wav，WebM，WMV)，并以查询流列表的形式返回它们，如果我们需要，我们可以使用它来显示页面上的所有流，并只下载用户想要的一个，但这里我们只需要音频。</p><p id="3854" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，为了只从 YouTube 视频中下载音频，我们需要首先接收 URL，并且存在一些特殊性:URL 必须是共享的，这意味着它必须具有特定的短格式，以便在“pytube”类中使用。</p><p id="8f38" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以我们需要用这个按钮来获取分享的短 URL 格式。</p><figure class="lt lu lv lw gt jo gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/7a3f0f10883caef9ce60e6f2bdf84d67.png" data-original-src="https://miro.medium.com/v2/resize:fit:324/format:webp/0*pw9fBYc0Ck68ct55.png"/></div></figure><p id="0633" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">并复制以下 URL:</p><figure class="lt lu lv lw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lx"><img src="../Images/a1da10db95f99f26e0d3151a7b5abdca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*b3Bkl24DOdC5u2fH.png"/></div></div></figure><p id="04fd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是视频通常的 YouTube 网址:</p><figure class="lt lu lv lw gt jo gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/ab1d01d3fa12b787b7c86bac4b342f06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/0*473GWz1pfHxY8WDy.png"/></div></figure><p id="d3a4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你仔细看，会发现除了短域(<a class="ae lz" href="http://youtu.be/" rel="noopener ugc nofollow" target="_blank"> youtu.be </a>而不是通常的<a class="ae lz" href="http://youtube.com/" rel="noopener ugc nofollow" target="_blank">youtube.com</a>)和域后的属性(短 URL 中只有视频的 ID 而不是普通 URL 中的‘观看’属性及其值是视频本身的 ID)之外，它们几乎是一样的。当然，我们可以创建一个普通 URL 的验证器和格式化器到它的较短版本中，或者它可以在“pytube”包中，但是我还没有看到它。但是，这是我们在使用该软件包时需要了解的特定功能。</p><p id="1883" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，我们使用“pytube”包中的“YouTube”类，从 Youtube 视频中下载音频。</p><p id="c333" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们通过 API 请求从一个输入或另一个输入接收 URL，现在这对我们来说无关紧要，并将其保存在一个变量中:</p><p id="79a0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lo lp lq lr b">url = YouTube(str(youtube_url))</code></p><p id="843c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意,“Youtube”类只接收 str 作为 URL 属性。</p><p id="899e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">之后，我们使用“streams”方法解析可用格式的流，并通过设置为 True 的“only_audio”属性按音频过滤它们:</p><p id="f7a9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lo lp lq lr b">audio_stream = url.streams.filter(only_audio=True).first()</code></p><p id="2666" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">之后，我们可以将它下载到某个目标路径中，或者如果我们将其留空，它将下载到项目的基本目录中:</p><p id="195a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lo lp lq lr b">out_file = audio_stream.download(output_path=destination)</code></p><p id="e64d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意，这个文件现在是 mp4 格式，但是没有图像，只有音频。</p><p id="dfa1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里，我们不再需要“pytube”包装。</p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="4eb0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 2。将视频转换成 mp3 </strong></p><p id="7687" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于第二点，存在几个解决方案包，但是当你为你的项目使用某个包时，它是一个好的实践，这个包应该现在就被支持，或者至少不要超过 1-2 年，完善它不应该有很多依赖。如果软件包的使用时间超过 2 年，则其依赖项过期的可能性非常高，并且您使用的软件包中的任何功能都不支持其依赖项的新版本。我会给你看我找到的所有解决方案，无论是第三方包还是没有任何包的简单解决方案。</p><p id="35f3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先我将向你展示一个不使用任何包的解决方案，只使用 python 的原生函数。</p><p id="a460" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以在我们下载了 mp4 文件和 pytube 包之后，我们可以简单地重命名它，特别是重命名它的格式。为此，我们可以使用 python 内核的“操作系统”模块:</p><p id="fb47" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lo lp lq lr b">import os</code></p><p id="a3a9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">需要把文件名分成两部分，文件名本身和点后的格式。</p><p id="c011" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lo lp lq lr b">base, ext = os.path.splitext(out_file)</code></p><p id="cd78" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">之后，我们将名称与新格式(mp3)连接起来:</p><p id="ab4a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lo lp lq lr b">new_file = base + '.mp3'</code></p><p id="c13f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，我们将该文件重命名为:</p><p id="0e83" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lo lp lq lr b">os.rename(out_file, new_file)</code></p><p id="681b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，我们删除了第一个完整的名称，并将其重命名为新的连接字符串，该字符串由文件名和新格式(mp3)格式化而成。</p><p id="9c55" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以将它作为 FileResponse 实例返回到页面，当您在浏览器中打开页面时，它将会播放。</p><p id="7099" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lo lp lq lr b">return FileResponse(open(new_file, 'rb'))</code></p><p id="bb4e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意，文件的打开模式是“rb”，这意味着它将以二进制格式打开进行读取，音频和视频应该以该格式打开进行读取。</p><p id="014f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但对我来说，这个解决方案并不适合，因为它已经保存在本地，但我需要直接保存在 AWS 存储上，而不使用本地存储。最后，我会告诉你如何避免这种情况。</p><p id="e542" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">使用第三方软件包转换:</strong></p><p id="a776" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为此，我尝试使用更多的软件包，我将谈谈其中的几个。</p><p id="8818" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以，我用的第一个包是“pydub”。“Pydub”提供多种格式进行转换，如 mp3、mp4、wav、m4a 等。它在 Mac 和 Linux 上工作是一样的，你只需要安装“Pydub”所基于的“FFmpeg”。</p><p id="25a5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在 Mac 上，我们安装了:</p><p id="ccb8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lo lp lq lr b">brew install ffmpeg</code></p><p id="1a32" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在 Linux 上:</p><p id="fb52" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lo lp lq lr b">sudo apt-get install ffmpeg</code></p><p id="6e51" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在 Windows 上，我们应该从他们的链接下载它:</p><p id="a45c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lo lp lq lr b"><a class="ae lz" href="https://ffmpeg.org/download.html" rel="noopener ugc nofollow" target="_blank">https://ffmpeg.org/download.html</a></code></p><p id="08cd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当然，我们还需要安装“pydub”:</p><p id="44f2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lo lp lq lr b">pip3 install pydub</code></p><p id="3e75" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了使用这个包，我们需要从中导入 AudioSegment 类:</p><p id="c9d9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lo lp lq lr b">from pydub import AudioSegment</code></p><p id="b2b6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我们还需要拆分文件名，以获得文件的原始扩展名。</p><p id="b135" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lo lp lq lr b">original_extension = out_file.split('.')[-1]</code></p><p id="8906" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">之后，我们可以使用 AudioSegment 类来创建它的实例，以便进一步转换:</p><p id="e5df" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lo lp lq lr b">mp3_converted_file = AudioSegment.from_file(out_file, original_extension)</code></p><p id="fc9d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，我们为文件创建一个新名称，并在保存时获取路径。</p><p id="4329" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lo lp lq lr b">new_path = out_file[:-3] + target_filetype</code></p><p id="650b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里我们最终用我们想要的质量(码率)转换成我们想要的。</p><p id="a37a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lo lp lq lr b">mp3_converted_file.export(new_path, format=target_filetype, bitrate="192k")</code></p><p id="669b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">之后，我们可以打开它阅读。</p><p id="f818" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lo lp lq lr b">converted_audiofile = File(file=open(new_path, 'rb'))</code></p><p id="1e26" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lo lp lq lr b">return converted_audiofile</code></p><p id="4697" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">剩下的最后一个解决方案包括 python 内核的“tempfile”特性。我决定使用它，因为我需要直接上传 mp3 文件到存储器，这似乎是我发现的最好的解决方案。</p><p id="27e3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，我们将使用 NamedTemporaryFile 类，因为它会自动为我们的文件创建一个随机名称，并且在我们使用它后会自动删除它。我们需要将该类的一个实例保存在一个变量中，并且我们必须指定临时保存该实例的路径:</p><p id="b663" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lo lp lq lr b">audio = NamedTemporaryFile(dir='music')</code></p><p id="035a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，我们在这个临时文件中写入我们之前下载的音频，并以“rb”模式打开它，读取以获取关于它的二进制信息。</p><p id="c79f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lo lp lq lr b">audio.write(File(file=open(out_file, 'rb')).read())</code></p><p id="def0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">之后，我们需要对它使用 flush()方法，以清除内部缓冲区。</p><p id="b53f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lo lp lq lr b">audio.flush()</code></p><p id="dafc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，创建 File 类的实例，并将其作为进一步交互的属性:</p><p id="ba21" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lo lp lq lr b">audio = File(audio)</code></p><p id="a053" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里，我们改变格式:</p><p id="69cb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lo lp lq lr b">name = str(audio.name).split('.')[-1]</code></p><p id="f69f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lo lp lq lr b">name += '.mp3'</code></p><p id="4512" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，我们得到路径:</p><p id="9aa0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lo lp lq lr b">audio_path = name.split('/')[-1:]</code></p><p id="8f91" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lo lp lq lr b">audio.name = '/'.join(audio_path)</code></p><p id="87d7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里，我们将它返回并保存到存储器中(在下一篇文章中)。</p><p id="10e6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是在这里我发现了一个问题，mp4 还是会留在本地存储，在这里我除了直接删除之外没有发现别的。</p><p id="5750" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lo lp lq lr b">os.remove(out_file) # delete the mp4 file from the local</code></p><p id="50f9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就这些了，谢谢你阅读这篇文章。这当然不是一个完美的解决方案，但至少是可行的。</p><p id="a3a3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你应该知道，视频越大，上传和处理的时间就越长。</p><p id="e77e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第 3 点和第 4 点关于保存文件到 AWS S3 桶存储和保存从存储的链接，以便在任何需要的地方使用它，以及关于数据库中的音频文件的信息，我将在下一篇文章中描述。</p><p id="0518" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这篇文章中使用的所有代码:</p><p id="8c2c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第一种解决方案:</p><pre class="lt lu lv lw gt ma lr mb mc aw md bi"><span id="a506" class="me mf in lr b gy mg mh l mi mj">def youtube_downloader(url='&lt;https://youtu.be/s-PKj3eUT9k&gt;', destination=BASE_DIR / 'music/'):<br/>"""Download audio only from youtube url."""</span><span id="3ae2" class="me mf in lr b gy mk mh l mi mj"># extract only audio<br/>video = YouTube(str('&lt;https://youtu.be/s-PKj3eUT9k&gt;'))<br/>video = video.streams.filter(only_audio=True).first()</span><span id="08fb" class="me mf in lr b gy mk mh l mi mj"># download the file<br/>out_file = video.download(destination)</span><span id="7915" class="me mf in lr b gy mk mh l mi mj"># save the file<br/>base, ext = os.path.splitext(out_file)<br/>new_file = base + '.mp3'<br/>os.rename(out_file, new_file)</span><span id="5c6b" class="me mf in lr b gy mk mh l mi mj">return FileResponse(open(new_file, 'rb'))</span></pre><p id="3637" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第二种解决方案:</p><pre class="lt lu lv lw gt ma lr mb mc aw md bi"><span id="8edc" class="me mf in lr b gy mg mh l mi mj">def youtube_downloader(url='&lt;https://youtu.be/s-PKj3eUT9k&gt;', destination=BASE_DIR / 'music/'):<br/>"""Download audio only from youtube url."""</span><span id="8439" class="me mf in lr b gy mk mh l mi mj"># extract only audio`<br/>video = YouTube(str('&lt;https://youtu.be/s-PKj3eUT9k&gt;'))<br/>video = video.streams.filter(only_audio=True).first()</span><span id="66ba" class="me mf in lr b gy mk mh l mi mj"># download the file<br/>out_file = video.download(destination)<br/>original_extension = out_file.split('.')[-1]</span><span id="0471" class="me mf in lr b gy mk mh l mi mj">mp3_converted_file = AudioSegment.from_file(out_file, original_extension)<br/>new_path = out_file[:-3] + target_filetype<br/>mp3_converted_file.export(new_path, format=target_filetype, bitrate="192k")<br/>converted_audiofile = File(file=open(new_path, 'rb'))</span><span id="724c" class="me mf in lr b gy mk mh l mi mj">return converted_audiofile</span></pre><p id="386a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">主要解决方案:</p><pre class="lt lu lv lw gt ma lr mb mc aw md bi"><span id="9335" class="me mf in lr b gy mg mh l mi mj">def convert_youtube_url_to_mp3(youtube_url: str, destination: str = BASE_DIR / 'music/') -&gt; File:<br/>    url = YouTube(str(youtube_url))<br/>    audio_stream = url.streams.filter(only_audio=True).first()<br/>    # get first video with only audio true format</span><span id="b29c" class="me mf in lr b gy mk mh l mi mj">    out_file = audio_stream.download(output_path=destination)<br/>    # download the mp4 from YouTube url</span><span id="056c" class="me mf in lr b gy mk mh l mi mj">    audio = NamedTemporaryFile(dir='music')<br/>    audio.write(File(file=open(out_file, 'rb')).read())<br/>    audio.flush()<br/>    audio = File(audio)</span><span id="7e0c" class="me mf in lr b gy mk mh l mi mj">    name = str(audio.name).split('.')[-1]<br/>    name += '.mp3'</span><span id="622a" class="me mf in lr b gy mk mh l mi mj">    audio_path = name.split('/')[-1:]<br/>    audio.name = '/'.join(audio_path)</span><span id="2670" class="me mf in lr b gy mk mh l mi mj">    os.remove(out_file)  # delete the mp4 file from the local</span><span id="eba7" class="me mf in lr b gy mk mh l mi mj">    return audio</span></pre><p id="4090" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">可能的问题列表:</p><p id="7432" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您从“pytube”包中得到这样的异常:</p><p id="df11" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lo lp lq lr b">pytube.exceptions.RegexMatchError: __init__: could not find match for ^\\w+\\W</code></p><p id="bd81" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您应该进入<a class="ae lz" href="http://cipher.py/" rel="noopener ugc nofollow" target="_blank"> cipher.py </a>文件并替换第 30 行，它是:</p><p id="3306" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lo lp lq lr b">var_regex = re.compile(r"^\\w+\\W")</code></p><p id="23b0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">用那句台词:</p><p id="ad09" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lo lp lq lr b">var_regex = re.compile(r"^\\$*\\w+\\W")</code></p></div></div>    
</body>
</html>