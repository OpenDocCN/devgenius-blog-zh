<html>
<head>
<title>Common Text Filtering Use Cases with Linux Tools</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Linux 工具的常见文本过滤用例</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/common-text-filtering-use-cases-with-linux-tools-a5284efc5af?source=collection_archive---------17-----------------------#2022-07-29">https://blog.devgenius.io/common-text-filtering-use-cases-with-linux-tools-a5284efc5af?source=collection_archive---------17-----------------------#2022-07-29</a></blockquote><div><div class="fc ic id ie if ig"/><div class="ih ii ij ik il"><div class=""/><p id="00c9" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">使用<code class="fe kj kk kl km b">grep</code>、<code class="fe kj kk kl km b">awk</code>和<code class="fe kj kk kl km b">sed</code>导航并挖掘文本文件中的隐藏模式。</p><figure class="ko kp kq kr gu ks gi gj paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gi gj kn"><img src="../Images/45dfe172eececc19eb2bdd8c52bb803f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*304je8plnlq01u-T"/></div></div><figcaption class="kz la gk gi gj lb lc bd b be z dk translated">帕特里克·托马索在<a class="ae ld" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="30d7" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">我们经常以代码、配置、数据或日志文件的形式处理各种文本文件，其中一些文件的大小可能是千兆字节。在像<code class="fe kj kk kl km b">less</code>这样的文本查看器中简单地浏览或搜索如此大的文本文件以获得洞察力将是具有挑战性的，尤其是当搜索的信息事先并不完全已知时。幸运的是，这里有大量的 Linux 命令行工具可以帮助我们，这可能会让我们很快获得有用的见解。在本文中，我将展示三个突出的 Linux 命令行工具的一些常见用例，即<code class="fe kj kk kl km b">grep</code>、<code class="fe kj kk kl km b">awk</code>和<code class="fe kj kk kl km b">sed</code>，它们都与文本过滤和转换有关。这里讨论的所有用例都在 Linux 环境中使用 GNU <code class="fe kj kk kl km b">grep</code>和<code class="fe kj kk kl km b">sed</code>以及 POSIX <code class="fe kj kk kl km b">awk</code>，尽管在 MacOS 上也有具有相似属性的同名工具。</p><p id="3492" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">为了演示这些工具的运行，我们将采用以下从这个<a class="ae ld" href="https://imsdb.com/scripts/Star-Wars-A-New-Hope.html" rel="noopener ugc nofollow" target="_blank"> IMSDb 链接</a>中摘录的文本，并存储在一个名为<code class="fe kj kk kl km b">starwars.txt.</code>的文件中</p><pre class="ko kp kq kr gu le km lf lg aw lh bi"><span id="8e95" class="li lj io km b gz lk ll l lm ln">    It is a period of civil war. Rebel spaceships, <br/>    striking from a hidden base, have won their first <br/>    victory against the evil Galactic Empire.<br/>    <br/>    During the battle, Rebel spies managed to steal <br/>    secret plans to the Empire's ultimate weapon, the <br/>    Death Star, an armored space station with enough <br/>    power to destroy an entire planet.<br/>    <br/>    Pursued by the Empire's sinister agents, Princess <br/>    Leia races home aboard her starship, custodian of <br/>    the stolen plans that can save her people and <br/>    restore freedom to the galaxy...</span></pre></div><div class="ab cl lo lp hs lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ih ii ij ik il"><h1 id="3d3a" class="lv lj io bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">常见<code class="fe kj kk kl km b">grep</code>用例</h1><p id="d89b" class="pw-post-body-paragraph jl jm io jn b jo ms jq jr js mt ju jv jw mu jy jz ka mv kc kd ke mw kg kh ki ih bi translated"><code class="fe kj kk kl km b">grep</code>及其工具系列广泛用于显示一个或多个文本文件中的选择性行。我经常使用这个工具来了解文件中项目出现的频率，以及收集感兴趣的行之前和/或之后的内容。</p><p id="6c96" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">其典型的用法语法是:<br/> <code class="fe kj kk kl km b">grep [OPTION] 'PATTERNS' FILE</code></p><p id="4fc7" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">以下是一些常见的<code class="fe kj kk kl km b">grep</code>用例:</p><p id="dcac" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">1.<strong class="jn ip"> </strong> <code class="fe kj kk kl km b"><strong class="jn ip">grep 'foo.*bar' file.txt</strong></code> <br/>显示由<em class="mx">任何</em>字符(regex <code class="fe kj kk kl km b">".*"</code>)与图案<em class="mx">栏</em>分隔的图案<em class="mx"> foo </em>的任何行。<br/>以下命令显示文件<code class="fe kj kk kl km b">starwars.txt</code>中带有<em class="mx">功率</em>和<em class="mx">行星</em>字样的行:</p><pre class="ko kp kq kr gu le km lf lg aw lh bi"><span id="ae70" class="li lj io km b gz lk ll l lm ln">$ grep 'power.*planet' starwars.txt <br/> power to destroy an entire planet.</span></pre><p id="5c98" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">2.<code class="fe kj kk kl km b"><strong class="jn ip">grep '^foo' file1.txt</strong></code> <br/>用模式<em class="mx"> foo </em>匹配任何一行的开始(<code class="fe kj kk kl km b">^</code>)。<br/>以下命令显示以一个或多个空格开始的任何行，后跟不区分大小写的(<code class="fe kj kk kl km b">-i</code>)模式<em class="mx">胜利</em>:</p><pre class="ko kp kq kr gu le km lf lg aw lh bi"><span id="eb43" class="li lj io km b gz lk ll l lm ln">$ grep -i '^[ ]\+victory' starwars.txt<br/>    victory against the evil Galactic Empire.</span></pre><p id="7247" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">3.<code class="fe kj kk kl km b"><strong class="jn ip">grep 'bar$' file1.txt</strong></code> <br/>匹配以图案<em class="mx">条</em>结束的任意行尾(<code class="fe kj kk kl km b">$</code>)。<br/>下面一行显示任何以点结束的行(点是特殊字符，因此需要转义):</p><pre class="ko kp kq kr gu le km lf lg aw lh bi"><span id="dec3" class="li lj io km b gz lk ll l lm ln">$ grep '\.$' starwars.txt<br/>    victory against the evil Galactic Empire.<br/>    power to destroy an entire planet.<br/>    restore freedom to the galaxy...</span></pre><p id="ab09" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">4.<code class="fe kj kk kl km b"><strong class="jn ip">grep -B1 -A1 'foo' file.txt</strong></code> <br/>查找模式为<em class="mx"> foo </em>的任何一行，找到后显示前一行(<code class="fe kj kk kl km b">-B1</code>)、匹配行和后一行(<code class="fe kj kk kl km b">-A1</code>)。<br/>以下命令显示任何带有图案<em class="mx">死星</em>的行，以及前后的行:</p><pre class="ko kp kq kr gu le km lf lg aw lh bi"><span id="2a2c" class="li lj io km b gz lk ll l lm ln">$ grep -B1 -A1 'Death Star' starwars.txt <br/>    secret plans to the Empire's ultimate weapon, the <br/>    Death Star, an armored space station with enough <br/>    power to destroy an entire planet.</span></pre><p id="c32a" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">5.<code class="fe kj kk kl km b"><strong class="jn ip">grep -m1 'foo' file.txt</strong></code> <br/>查找任意一条模式为<em class="mx"> foo </em>的线，并停在第一个匹配点(<code class="fe kj kk kl km b">-m1</code>)。如果您想知道某个特定的公共模式是否存在，而不处理文件的其余部分，这是很有用的。<br/>以下命令显示模式为<em class="mx"> ship </em>的第一个匹配行:</p><pre class="ko kp kq kr gu le km lf lg aw lh bi"><span id="84b1" class="li lj io km b gz lk ll l lm ln">$ grep -m1 'ship' starwars.txt <br/>    It is a period of civil war. Rebel spaceships,</span></pre><p id="52d7" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">6.<code class="fe kj kk kl km b"><strong class="jn ip">fgrep 'foo' file.txt</strong></code> <br/>显示任何带有文字字符串<em class="mx"> foo </em>的行，不作为正则表达式。与<code class="fe kj kk kl km b">grep</code>不同的是，<code class="fe kj kk kl km b">fgrep</code>将任何包含特殊字符的模式视为文字。<br/>以下命令显示任何带省略号的行(用三个点表示):</p><pre class="ko kp kq kr gu le km lf lg aw lh bi"><span id="a145" class="li lj io km b gz lk ll l lm ln">$ fgrep '...' starwars.txt<br/>    restore freedom to the galaxy...</span></pre><p id="3edc" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">7.<code class="fe kj kk kl km b"><strong class="jn ip">egrep 'foo|bar' file.txt</strong></code> <br/>查找任何带有图案<em class="mx"> foo </em>或 bar 的线条。<code class="fe kj kk kl km b">egrep</code>将模式解释为扩展正则表达式。<br/>以下命令显示任何带有图案<em class="mx"> war </em>或<em class="mx"> battle </em>的行:</p><pre class="ko kp kq kr gu le km lf lg aw lh bi"><span id="8793" class="li lj io km b gz lk ll l lm ln">$ egrep 'war|battle' starwars.txt <br/>    It is a period of civil war. Rebel spaceships, <br/>    During the battle, Rebel spies managed to steal</span></pre></div><div class="ab cl lo lp hs lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ih ii ij ik il"><h1 id="6a1b" class="lv lj io bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">常见<code class="fe kj kk kl km b">awk</code>用例</h1><p id="e5aa" class="pw-post-body-paragraph jl jm io jn b jo ms jq jr js mt ju jv jw mu jy jz ka mv kc kd ke mw kg kh ki ih bi translated"><code class="fe kj kk kl km b">awk</code>本身就是一门完整的语言。它的基本功能是在文件中搜索包含特定模式的行。由于它的灵活性和许多内置功能，甚至可以在单词级别操作行，而不仅仅是显示匹配的行。在<code class="fe kj kk kl km b">awk</code>中，每个输入行被称为一个<em class="mx">记录</em>，默认情况下，由空白分隔的每个单词被称为一个<em class="mx">字段</em>。这应该有助于理解<code class="fe kj kk kl km b">awk</code>的内在变量。</p><p id="ae96" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">其典型的语法是:<br/> <code class="fe kj kk kl km b">awk 'PROGRAM' FILE</code></p><p id="d34e" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">以下是一些常见的<code class="fe kj kk kl km b">awk</code>用例:</p><p id="363a" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">1.<code class="fe kj kk kl km b"><strong class="jn ip">awk '{print $NF}' file.txt</strong></code> <br/>用内置变量<code class="fe kj kk kl km b">NF</code>(即字段数)显示每条记录的最后一个字段。<br/>以下命令显示了对样本文件的运行:</p><pre class="ko kp kq kr gu le km lf lg aw lh bi"><span id="7467" class="li lj io km b gz lk ll l lm ln">$ awk '{print $NF}' starwars.txt<br/>spaceships,<br/>first<br/>Empire.<br/>...<br/>galaxy...</span></pre><p id="f6f0" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">2.<code class="fe kj kk kl km b"><strong class="jn ip">awk 'NF &gt; 0 {print}' file.txt</strong></code> <br/>通过检查一条记录中 NF 是否大于 0 来显示任何非空记录。<br/>为了限制输出行，以下命令使用逻辑 and 运算符(<code class="fe kj kk kl km b">&amp;&amp;</code>)显示非空的<em class="mx">偶数行</em>:</p><pre class="ko kp kq kr gu le km lf lg aw lh bi"><span id="b04e" class="li lj io km b gz lk ll l lm ln">$ awk '(NF &gt; 0) &amp;&amp; (NR % 2 == 0) { print NR,$0 }' starwars.txt <br/>2     striking from a hidden base, have won their first <br/>6     secret plans to the Empire's ultimate weapon, the <br/>8     power to destroy an entire planet.<br/>10     Pursued by the Empire's sinister agents, Princess <br/>12     the stolen plans that can save her people and</span></pre><p id="fb72" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">3.<code class="fe kj kk kl km b"><strong class="jn ip">awk '/foo/ {print $1,$NF}' file.txt</strong></code> <br/>显示与模式<em class="mx"> foo </em>匹配的记录的第一个和最后一个字段。<code class="fe kj kk kl km b">awk</code>不显示记录，而是允许轻松引用任何单个字段。<br/>以下命令检查记录是否与模式<em class="mx"> ship、</em>匹配，并相应地打印第一个和最后一个字段:</p><pre class="ko kp kq kr gu le km lf lg aw lh bi"><span id="712e" class="li lj io km b gz lk ll l lm ln">$ awk '/ship/ {print $1,$NF}' starwars.txt<br/>It spaceships,<br/>Leia of</span></pre><p id="63fd" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">4.<code class="fe kj kk kl km b"><strong class="jn ip">awk '{ print NR,length }' file.txt</strong></code> <br/>打印行号及其字符数。<br/>下面是对样本文件的运行:</p><pre class="ko kp kq kr gu le km lf lg aw lh bi"><span id="0ccf" class="li lj io km b gz lk ll l lm ln">$ awk '{ print NR,length }' starwars.txt<br/>1 51<br/>2 54<br/>3 45<br/>4 4<br/>5 52<br/>6 54<br/>7 53<br/>8 38<br/>9 4<br/>10 54<br/>11 54<br/>12 50<br/>13 36</span></pre><p id="f6e2" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">5.<code class="fe kj kk kl km b"><strong class="jn ip">awk '$2 ~ /foo/ { print }' file.txt<br/></strong></code>如果第二个字段(第一个字段为<code class="fe kj kk kl km b">$1</code>)与模式<em class="mx"> foo </em>匹配，则打印一条记录。要反转匹配，使用运算符<code class="fe kj kk kl km b">!~</code>。如果我们在一个特定的字段或列中寻找一个模式，<code class="fe kj kk kl km b">awk</code>内在的字段级支持在这里大放异彩。<br/>下面的<code class="fe kj kk kl km b">awk</code>脚本检查第四个字段是否与模式<em class="mx"> Empire </em>匹配，并相应地打印记录:</p><pre class="ko kp kq kr gu le km lf lg aw lh bi"><span id="37ce" class="li lj io km b gz lk ll l lm ln">$ awk '$4 ~ /Empire/ { print }' starwars.txt <br/>    Pursued by the Empire's sinister agents, Princess</span></pre><p id="cfdb" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">6.<code class="fe kj kk kl km b"><strong class="jn ip">awk -F, '{if (NF &gt; 1) print $2}' file.txt</strong></code> <br/>打印记录中的第二个字段，如果其字段数大于 1，则用“，”分隔(<code class="fe kj kk kl km b">-F</code>)字段。<br/>下面是一个运行示例:</p><pre class="ko kp kq kr gu le km lf lg aw lh bi"><span id="8ca4" class="li lj io km b gz lk ll l lm ln">$ awk -F, '{if (NF &gt; 1) print $2}' starwars.txt <br/> <br/> have won their first <br/> Rebel spies managed to steal <br/> the <br/> an armored space station with enough <br/> Princess <br/> custodian of</span></pre></div><div class="ab cl lo lp hs lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ih ii ij ik il"><h1 id="52e1" class="lv lj io bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">常见的<code class="fe kj kk kl km b">sed</code>用例</h1><p id="7db5" class="pw-post-body-paragraph jl jm io jn b jo ms jq jr js mt ju jv jw mu jy jz ka mv kc kd ke mw kg kh ki ih bi translated"><code class="fe kj kk kl km b">sed</code>是另一个强大的工具，可以在一行中的任意点对输入流执行文本转换。由于其灵活性和简洁的脚本，它可能会让新手望而生畏，并有一个陡峭的学习曲线。然而，<code class="fe kj kk kl km b">sed</code>提供了各种有用的特性，这些特性是其他工具无法轻易实现的，是一个值得推荐的工具。</p><p id="210d" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">其典型用法语法为:<br/> <code class="fe kj kk kl km b">sed 'SCRIPT' INPUTFILE</code></p><p id="4c63" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">以下是一些常见的<code class="fe kj kk kl km b">sed</code>用例:</p><p id="55ed" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">1.<code class="fe kj kk kl km b"><strong class="jn ip">sed -n '10,20p' file.txt</strong></code> <br/>打印(命令<code class="fe kj kk kl km b">p</code>)输入文件的第 10 行到第 20 行。选项<code class="fe kj kk kl km b">-n</code>导致<code class="fe kj kk kl km b">sed</code>抑制其默认的线条显示。对于大文件，建议在匹配后退出进一步处理。为了实现这一点，下面是带有指令<code class="fe kj kk kl km b">21q</code>的相关命令，指示<code class="fe kj kk kl km b">sed</code>在第 21 行退出:<br/> <code class="fe kj kk kl km b">sed -n '10,20p;21q' file.txt<br/></code>下面是显示第 1–3 行的运行示例:</p><pre class="ko kp kq kr gu le km lf lg aw lh bi"><span id="586e" class="li lj io km b gz lk ll l lm ln">$ sed -n '1,3p' starwars.txt <br/>    It is a period of civil war. Rebel spaceships, <br/>    striking from a hidden base, have won their first <br/>    victory against the evil Galactic Empire.</span></pre><p id="049e" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">2.<code class="fe kj kk kl km b"><strong class="jn ip">sed '/foo/d' file.txt</strong></code> <br/>删除(命令<code class="fe kj kk kl km b">d</code>)任何带有图案<em class="mx"> foo </em>的行。<br/>以下脚本删除任何带有空格的行，只使用正则表达式<code class="fe kj kk kl km b">"^[ ]*$"</code>来匹配从该行开始到结束的空格，第一行(<code class="fe kj kk kl km b">1d</code>以及最后一行(<code class="fe kj kk kl km b">$d</code>):</p><pre class="ko kp kq kr gu le km lf lg aw lh bi"><span id="3e07" class="li lj io km b gz lk ll l lm ln">$ sed '/^[ ]*$/d;1d;$d' starwars.txt<br/>    striking from a hidden base, have won their first <br/>    victory against the evil Galactic Empire.<br/>    During the battle, Rebel spies managed to steal <br/>    secret plans to the Empire's ultimate weapon, the <br/>    Death Star, an armored space station with enough <br/>    power to destroy an entire planet.<br/>    Pursued by the Empire's sinister agents, Princess <br/>    Leia races home aboard her starship, custodian of <br/>    the stolen plans that can save her people and</span></pre><p id="db04" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">3.<code class="fe kj kk kl km b"><strong class="jn ip">sed '/foo/,/bar/d' file.txt</strong></code> <br/>删除从图案<em class="mx"> foo </em>行到图案<em class="mx"> bar </em>行的所有行。<br/>以下命令从样本文件中删除中间段落:</p><pre class="ko kp kq kr gu le km lf lg aw lh bi"><span id="49ac" class="li lj io km b gz lk ll l lm ln">$ sed '/During/,/planet./d' starwars.txt<br/>    It is a period of civil war. Rebel spaceships, <br/>    striking from a hidden base, have won their first <br/>    victory against the evil Galactic Empire.<br/>    <br/>    <br/>    Pursued by the Empire's sinister agents, Princess <br/>    Leia races home aboard her starship, custodian of <br/>    the stolen plans that can save her people and <br/>    restore freedom to the galaxy...</span></pre><p id="c363" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">要删除空行，我们可以使用:</p><pre class="ko kp kq kr gu le km lf lg aw lh bi"><span id="4c1a" class="li lj io km b gz lk ll l lm ln">$ sed '/^[ ]*$/,/^[ ]*$/d' starwars.txt<br/>    It is a period of civil war. Rebel spaceships, <br/>    striking from a hidden base, have won their first <br/>    victory against the evil Galactic Empire.<br/>    Pursued by the Empire's sinister agents, Princess <br/>    Leia races home aboard her starship, custodian of <br/>    the stolen plans that can save her people and</span></pre><p id="e4c4" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">4.<code class="fe kj kk kl km b"><strong class="jn ip">sed -rn '/(foo).*\1/p' file.txt</strong></code> <br/>显示任何带有两个模式<em class="mx"> foo </em>的行，括号内的<code class="fe kj kk kl km b">\1</code>表示匹配的表达式，作为第二个模式<em class="mx"> foo </em>。选项<code class="fe kj kk kl km b">-r</code>允许<code class="fe kj kk kl km b">sed</code>将脚本视为扩展正则表达式。<br/>以下命令显示任何带有两个“The”的行:</p><pre class="ko kp kq kr gu le km lf lg aw lh bi"><span id="2b33" class="li lj io km b gz lk ll l lm ln">$ sed -rn '/ (the).*\1/p' starwars.txt <br/>    secret plans to the Empire's ultimate weapon, the</span></pre><p id="e6d1" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">5.<code class="fe kj kk kl km b"><strong class="jn ip">sed 's/../&amp;:/g' file.txt</strong></code> <br/>用匹配的字符(指令<code class="fe kj kk kl km b">&amp;</code>)替换(命令<code class="fe kj kk kl km b">s</code>)每两个字符，后跟一个冒号，重复执行直到行尾(命令<code class="fe kj kk kl km b">g</code>)。<br/>以下脚本查找任何非空格字符序列(regex <code class="fe kj kk kl km b">"[^ ]+"</code>)并附加一个冒号:</p><pre class="ko kp kq kr gu le km lf lg aw lh bi"><span id="7449" class="li lj io km b gz lk ll l lm ln">$ sed -r 's/[^ ]+/&amp;:/g' starwars.txt <br/>    It: is: a: period: of: civil: war.: Rebel: spaceships,: <br/>    striking: from: a: hidden: base,: have: won: their: first: <br/>    victory: against: the: evil: Galactic: Empire.:<br/>    <br/>    During: the: battle,: Rebel: spies: managed: to: steal: <br/>    secret: plans: to: the: Empire's: ultimate: weapon,: the: <br/>    Death: Star,: an: armored: space: station: with: enough: <br/>    power: to: destroy: an: entire: planet.:<br/>    <br/>    Pursued: by: the: Empire's: sinister: agents,: Princess: <br/>    Leia: races: home: aboard: her: starship,: custodian: of: <br/>    the: stolen: plans: that: can: save: her: people: and: <br/>    restore: freedom: to: the: galaxy...:</span></pre><p id="0cd9" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">6.<code class="fe kj kk kl km b"><strong class="jn ip">sed -re 's/^[ ]+//' -e 's/$/0/' data.txt</strong></code> <br/>对每一行执行两次替换，第一个脚本删除该行开头的所有空格，第二个脚本在末尾附加一个 0。这个稍微复杂一点的用法说明了<code class="fe kj kk kl km b">sed</code>的多功能性和灵活性。<br/>下面是一个运行示例，用于修剪开头的任何空白，并用虚线替换样本文件的任何空行:</p><pre class="ko kp kq kr gu le km lf lg aw lh bi"><span id="f831" class="li lj io km b gz lk ll l lm ln">$ sed -re 's/^[ ]+//' -e 's/^$/---------/' starwars.txt<br/>It is a period of civil war. Rebel spaceships, <br/>striking from a hidden base, have won their first <br/>victory against the evil Galactic Empire.<br/>---------<br/>During the battle, Rebel spies managed to steal <br/>secret plans to the Empire's ultimate weapon, the <br/>Death Star, an armored space station with enough <br/>power to destroy an entire planet.<br/>---------<br/>Pursued by the Empire's sinister agents, Princess <br/>Leia races home aboard her starship, custodian of <br/>the stolen plans that can save her people and <br/>restore freedom to the galaxy...</span></pre></div><div class="ab cl lo lp hs lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ih ii ij ik il"><h1 id="1e9d" class="lv lj io bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">最后的话</h1><p id="a529" class="pw-post-body-paragraph jl jm io jn b jo ms jq jr js mt ju jv jw mu jy jz ka mv kc kd ke mw kg kh ki ih bi translated">Linux 提供了许多文本过滤和转换工具，以便于浏览文本文件。在<code class="fe kj kk kl km b">grep</code>、<code class="fe kj kk kl km b">awk</code>和<code class="fe kj kk kl km b">sed</code>的帮助下，我们甚至可以快速发现非常大的文件中的模式或趋势，否则在文本查看器中浏览文件时是看不到的。</p><p id="f9f5" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">您使用这些工具或者甚至其他 Linux 命令行工具来发现和探索您的文件的<em class="mx">前景</em>吗？请在评论区分享。谢谢你的阅读，任何掌声都很感谢！</p></div></div>    
</body>
</html>