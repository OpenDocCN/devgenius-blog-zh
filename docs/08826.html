<html>
<head>
<title>Input validation for known values</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">已知值的输入验证</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/input-validation-for-known-values-b060e779ee5b?source=collection_archive---------19-----------------------#2022-07-12">https://blog.devgenius.io/input-validation-for-known-values-b060e779ee5b?source=collection_archive---------19-----------------------#2022-07-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/f79eedced4da49f8acf9bcaf38346736.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GTTZA_R5xPdFZlk_q9lKGQ.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><a class="ae jz" href="https://www.freepik.com/photos/html-code" rel="noopener ugc nofollow" target="_blank">www.freepik.com nikitabuida 制作的 Html 代码照片</a></figcaption></figure><p id="e33c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">相当多的安全问题是由于输入验证缺失或有缺陷造成的。</p><p id="a826" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">完全避免所有类型注射的唯一方法是完全不使用用户输入。在大多数情况下，这是不可行的。</p><p id="83f6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是有一部分使用可以完全避免安全问题:任何时候从一组已知的值中选择输入，都可以使用白名单来防止不好的事情发生。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="d3b5" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">直接使用用户输入</h1><p id="402a" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">幸运的是，在过去几年中，不经过任何验证和确认就直接使用参数的情况越来越少了。这主要归功于涵盖这些基础知识的良好框架。</p><p id="cd8a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">像这个 PHP 片段这样的代码容易受到各种注入攻击。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="3763" class="mr lg in mn b gy ms mt l mu mv">include "locale_" + $_GET['lang'] + ".php";</span></pre><p id="0916" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了你的灵魂，<strong class="kc io">永远不要</strong>写任何接受任何类型输入并直接使用它的代码。(相信我，这会导致永恒的火焰和诅咒)</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="eca9" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">一些基本验证后的使用</h1><h2 id="d7ab" class="mr lg in bd lh mw mx dn ll my mz dp lp kl na nb lt kp nc nd lx kt ne nf mb ng bi translated">用文字验证后使用</h2><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="f50c" class="mr lg in mn b gy ms mt l mu mv">if (arg == "value1") {<br/>  own_variable = arg;<br/>  do_something(arg);<br/>} else if (arg == "value2") {<br/>  own_variable = arg;<br/>  do_something_else(arg);<br/>} else {<br/>  own_variable = "default_value";<br/>  do_some_default();<br/>}</span><span id="cbe0" class="mr lg in mn b gy nh mt l mu mv">do_something_further(own_variable);</span></pre><p id="c2c2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">用文字验证用户输入，并在认为安全的情况下使用它，乍一看似乎没问题。然而，这取决于所使用的语言。有些语言，例如 C 系列，这可能是天生不安全的。</p><p id="02e0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，如果 arg 的值包含一个空字节(0x00 ),则后面的任何内容可能不会在条件中进行检查，但可能会在以后使用。这种情况是否会发生取决于很多因素，比如使用哪种语言，在哪个版本中使用。甚至还取决于事后用这些值实际调用了什么函数。例如，即使一种语言本身不容易受到这种攻击，但如果执行像文件系统操作这样的操作系统级调用，它也可能会继承这种攻击。</p><p id="759d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">事实是，一个有经验的开发人员可能会说这是显而易见的，知道该做什么和不该做什么，并且第一次就做对了。对于没有经验的开发人员来说，情况可能会有所不同。我们必须永远不要忘记，即使是最有经验的开发人员也曾经是新手，犯过所有新手犯过的基本错误。</p><p id="0595" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，即使对于这不是一个问题的语言，我也建议不要使用这种结构，原因很简单，而且完全不是技术性的:人脑是一个有趣的东西，它倾向于遵循过去行之有效的已知模式。</p><p id="ee85" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果开发人员在安全的语言中使用这样的验证，这种情况往往会持续下去。即使在转换到其他语言后，情况可能并非如此。</p><h2 id="4132" class="mr lg in bd lh mw mx dn ll my mz dp lp kl na nb lt kp nc nd lx kt ne nf mb ng bi translated">逻辑验证</h2><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="a1c6" class="mr lg in mn b gy ms mt l mu mv">if (is_valid(arg)) {<br/>  own_variable = arg;<br/>} else {<br/>  own_variable = “value_default”;<br/>}</span><span id="4bff" class="mr lg in mn b gy nh mt l mu mv">do_something_further(own_variable);</span></pre><p id="be35" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这只是上述内容的一个变体，只是做有效性检查的逻辑更长，通常更复杂，因此包含更多出错的机会。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="acce" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">气隙使用</h1><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="125f" class="mr lg in mn b gy ms mt l mu mv">if (arg == “value1”) {<br/>  own_variable = “value1”;<br/>  do_something(“value1”);<br/>} else if (arg == “value2”) {<br/>  own_variable = “value2”;<br/>  do_something_else(“value2”);<br/>} else {<br/>  own_variable = “default_value”;<br/>  do_some_default();<br/>}</span><span id="ba79" class="mr lg in mn b gy nh mt l mu mv">do_something_further(own_variable);</span></pre><p id="c77a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如我在开始时所说的，完全避免任何类型的注入的唯一方法是不使用用户提供的输入。</p><p id="2cfd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里，输入仅在条件中使用。任何疯狂，即使是一个天才的对手，也不会影响接下来的逻辑，因为它与论点毫无关系。</p><p id="5e42" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我听到有人说这是一种不好的风格，因为它复制了硬编码的值。所以请使用硬编码的常量，定义一次就可以在任何需要的地方使用它们。</p><p id="4575" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">重要的是将用户输入与逻辑中使用的值彻底分离。从根本上说，这是争论的空隙，也是唯一安全的方法。</p><p id="2628" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从头回到 PHP 的例子。最简单的方法是增加几行代码，每当添加一种新语言时，都需要修改文件，但这很难被滥用:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="f1cb" class="mr lg in mn b gy ms mt l mu mv">if ($_GET['lang'] == "de") {<br/>  include "locale_de.php";<br/>}else if ($_GET['lang'] == "es") {<br/>  include "locale_es.php";<br/>}else{<br/>  include "locale_en.php";<br/>}</span></pre><p id="27d6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">警告</strong></p><p id="95ce" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">必须确保 arg 的内容不能用于脱离代码结构本身。在编译语言中这不是问题，在解释语言中可能是。然而，大多数这样的语言还提供了对任何可能被用来脱离结构的内容进行转义的功能。</p></div></div>    
</body>
</html>