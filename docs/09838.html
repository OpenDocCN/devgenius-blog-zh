<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://blog.devgenius.io/kubevela-1-5-4a571bd719af?source=collection_archive---------7-----------------------#2022-09-16">https://blog.devgenius.io/kubevela-1-5-4a571bd719af?source=collection_archive---------7-----------------------#2022-09-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><h2 id="f491" class="il im in bd io ip iq dn ir is it dp iu iv iw ix iy iz ja jb jc jd je jf jg jh bi translated">KubeVela 1.5:灵活选择 CNCF 原子功能，构建独特的企业应用发布平台</h2><p id="c83f" class="pw-post-body-paragraph ji jj in jk b jl jm jn jo jp jq jr js iv jt ju jv iz jw jx jy jd jz ka kb kc ig bi translated"><em class="kd">曾庆国(大岳)</em></p><p id="5667" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">摘要:本文讨论了最新发布的 KubeVela 1.5 中的进展和更新。</p><p id="f86c" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated"><a class="ae kj" href="https://github.com/kubevela/kubevela/releases/tag/v1.5.0" rel="noopener ugc nofollow" target="_blank"> KubeVela 1.5 </a>最近发布。该版本为社区带来了更方便的应用交付功能，包括系统可观察性、将 Vela CLI 移至浏览器的 CloudShell 终端、增强的 canary 版本以及优化的多环境应用交付工作流。也提高了 KubeVela 作为应用交付平台的高可扩展性。社区已经开始将该项目推广到 CNCF 孵化阶段。在多次社区会议中吸收了多个标杆用户的实践分享，证明了社区的健康发展。该项目目前已有一定程度的成熟，并取得了阶段性成果，这要归功于社区中 200 多名开发者的贡献。</p><p id="8ba2" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">在过去的一年里，KubeVela 发布了五个主要版本。每一次迭代都是一次飞跃。版本 1.1 的发布带来了连接多个集群的能力。1.2/1.3 版本带来了扩展的系统和对开发者更友好的体验。1.4 版本在整个流程中引入了安全机制。今天 1.5 的发布让我们更接近 KubeVela 的愿景<em class="kd">，让应用交付和管理更容易。</em>一路走来，我们坚持相同的设计理念，构建了一个平台，在不损失可扩展性的情况下，自动化底层差异化基础设施的复杂性。它帮助应用程序开发人员以低成本从业务开发升级到云原生研发。从技术上讲，它关注的是从代码到云，从应用交付到管理的完整流程。它细化了基于开放应用模型(OAM)的连接基础设施的框架能力。如图 1 所示，KubeVela 已经覆盖了应用定义、交付、O &amp; M、管理的完整能力，所有这些都是基于 OAM 可伸缩性(OAM 定义)以附加方式连接生态项目。<strong class="jk kk">本质上，每一个定义都将特定能力的经验转化为可重用的最佳实践模块，可以通过 addon 打包由企业或社区共享。</strong></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/48c3c4b270b60775acc84ee26156e15a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IsIS8PThISY4TV67"/></div></div></figure><p id="4a37" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated"><em class="kd">图 KubeVela 可扩展性的核心结构</em></p><p id="cbb5" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">云原生的原子能力的蓬勃发展是一项资产，提高了该领域的门槛。平台搭建者需要学习大量开源项目，聚合多个领域的经验。为企业构建云原生支持平台通常需要数月或更长时间。然而，平台往往会将复杂性转嫁给应用程序开发人员，这意味着他们必须学习许多额外的知识。KubeVela 的设计理念和现有的技术成果或许可以帮助你快速进入云原生世界。<strong class="jk kk"> KubeVela 在 1.5 版本及之前版本中的主要 addon 集成规范和统一应用交付经验，解决了云原生领域的离散原子能力问题。</strong></p><h1 id="99e3" class="kx im in bd io ky kz la ir lb lc ld iu le lf lg iy lh li lj jc lk ll lm jg ln bi translated">附加规范升级和更灵活的定义</h1><p id="2d56" class="pw-post-body-paragraph ji jj in jk b jl jm jn jo jp jq jr js iv jt ju jv iz jw jx jy jd jz ka kb kc ig bi translated">KubeVela addon 机制从 1.2 版本开始就在社区用户中流行。社区插件库中有将近 50 个插件。近 50 名开发者参与了该插件的贡献。</p><p id="cea8" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">更多信息请见<a class="ae kj" href="https://github.com/kubevela/catalog" rel="noopener ugc nofollow" target="_blank">此链接</a></p><p id="90f3" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">从 1.5 版本开始，插件开发者可以有更好的体验。插件定义、分发和可视化管理都得到了改进。除了使用 YAML 定义插件之外，如果开发者想要插件资源和更高级参数化控制更灵活的组合，他们完全可以使用 CUE 来定义插件。插件定义的当前规范包括以下部分:</p><p id="c172" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">template.cue 或 template.yaml 与资源目录结合使用，用于定义插件的运行时。例如，您需要在后面运行一个操作符来扩展工作负载。这部分是可选的。例如，一些轻量级插件可以没有运行时或者重用其他运行时。YAML 和线索配置的组合可以覆盖大多数场景。</p><p id="f435" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">存储定义的定义目录是插件的核心部分，定义了用户如何使用插件扩展的功能。</p><p id="925d" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">用于辅助定义的模式目录为 UI 端的相关定义定义了自定义呈现规则。</p><p id="8203" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">views 目录存储 VelaQL 的语法定义，用于扩展 VelaQL 的查询功能。</p><p id="1e19" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">附加组件元数据定义文件，如 metadata.yaml 和 readme.md，描述了附加组件的基本信息和环境要求。</p><p id="14be" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">详见<a class="ae kj" href="http://kubevela.net/docs/platform-engineers/addon/intro" rel="noopener ugc nofollow" target="_blank">文件</a>。</p><p id="2a0e" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">这是一个集成 Helm Chart 包交付能力的例子。目前，社区中的项目如 FluxCD 或 ArgoCD 提供了部署图表包的原子功能。它们的实现各不相同，各有千秋。对于 KubeVela 用户来说，这两个项目都可以通过插件来介绍。如图 2 所示，我们需要为最终用户定义一个标准的 API，根据企业的具体情况向最终用户公开必要的参数。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi lo"><img src="../Images/ae42524f796dc5756571a707ea575de4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DDYa6FieIOqYWFUZ"/></div></div></figure><p id="5285" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated"><em class="kd">图 KubeVela 扩展舵图包的过程</em></p><p id="2c9d" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">如图 3 所示，根据标准 API，前端 UI 可以自动生成相应的交互页面，帮助最终用户轻松便捷地部署 Helm Chart 包。平台端根据用户输入的参数和插件定义自动生成底层能力的驱动配置，并智能地向用户发送相关的状态反馈。这些都是基于附加规范的，比如 integrating FluxCD。这个项目包括提供不同原子功能的多个控制器。首先，我们使用 template.cue 定义 FluxCD 的部署方法，根据不同的参数输入部署不同的组件。然后，用户体验由定义和模式目录定义。</p><p id="6153" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">更多信息请见<a class="ae kj" href="https://github.com/kubevela/catalog/tree/master/addons/fluxcd" rel="noopener ugc nofollow" target="_blank">此链接</a>。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi lp"><img src="../Images/570c95b470d6487db01dfe48d6d2cb47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bZwUUP62jXsTRjSK"/></div></div></figure><p id="208f" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated"><em class="kd">图 KubeVela 交付舵图包的交互</em></p><h1 id="1a7b" class="kx im in bd io ky kz la ir lb lc ld iu le lf lg iy lh li lj jc lk ll lm jg ln bi translated">基于插件扩展的函数解释</h1><h1 id="f147" class="kx im in bd io ky kz la ir lb lc ld iu le lf lg iy lh li lj jc lk ll lm jg ln bi translated">遥测集成 Prometheus + Grafana + Exporters 以支持系统可观测性</h1><p id="0f84" class="pw-post-body-paragraph ji jj in jk b jl jm jn jo jp jq jr js iv jt ju jv iz jw jx jy jd jz ka kb kc ig bi translated">应用程序可观察性系统与应用程序发布密切相关。一个好的应用程序可观测性系统可以使应用程序可靠性的管理变得容易。<strong class="jk kk">KubeVela 社区将应用程序可观察性纳入了核心特性。在 1.5 版本中，社区选择了 KubeVela 系统可观测性作为系统能力开发的案例。实现了以下关键点:</strong></p><p id="98f0" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">1.<strong class="jk kk">多集群可观察基础设施可通过插件轻松安装。</strong>首先，我们围绕 Prometheus + Grafana + Exporters 的解决方案，形成了一个可观察的 addon 集合。它可以方便地为不同的基本环境安装基本功能。</p><p id="b78c" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">2.<strong class="jk kk">支持多集群指标数据聚合一键打开，使用灭霸查询解决方案</strong>实现多集群指标聚合查询和可视化。一个类似的解决方案将逐渐涵盖记录器和跟踪维度。</p><p id="2114" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">3.<strong class="jk kk">Grafana IaC:</strong>Grafana 数据源和仪表盘的配置通过应用模型进行描述。可扩展 API 的创新应用，使得 Grafana API 变成了 KubeVela 可以运行的运行时。</p><p id="d37e" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">4.<strong class="jk kk">Grafana 仪表板是自动生成的。</strong>您可以启用 Grafana 插件自动生成 KubeVela 系统可观察性仪表板。</p><p id="8061" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">图 4 显示了 KubeVela 系统操作指示器的仪表板。仪表板通过 IaC 系统自动生成。你只需要启用相应的插件。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi lq"><img src="../Images/e5d07f86be05d9bdb7344bc24994cc44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6SyqVRbvI7e-fOb4"/></div></div></figure><p id="713c" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated"><em class="kd">图 4: KubeVela 系统可观察仪表板</em></p><p id="714b" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">图 5 显示了连接到 KubeVela 的 Kubernetes API 服务器服务的监控仪表板。使用插件向所有子集群发布导出器，向每个集群的 Prometheus 服务公开数据，并将其聚合到控制集群以进行集中可视化。您可以同时完成许多集群的数据监控和仪表板访问。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi lr"><img src="../Images/9e5ec8bb413702a4b8b6aac4d395bce5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3hgqc7Vrn9niCv3R"/></div></div></figure><p id="be9e" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated"><em class="kd">图 5: KubeVela 多集群 API 观察仪表板</em></p><p id="8e97" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">在下一个版本中，社区将逐步将应用可观察性的统一描述和交付集成到应用交付流程中。它涵盖了度量、记录和跟踪数据采集、中间处理和传输、存储和分析、警报和可视化，以及应用程序发布工作流的完整流程。</p><p id="bc57" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">参考:<a class="ae kj" href="http://kubevela.net/docs/platform-engineers/operations/observability" rel="noopener ugc nofollow" target="_blank">http://kubevela . net/docs/platform-engineers/operations/observability</a></p><h1 id="6179" class="kx im in bd io ky kz la ir lb lc ld iu le lf lg iy lh li lj jc lk ll lm jg ln bi translated">为 CLI 和 UI 协作应用交付集成 CloudShell</h1><p id="75d0" class="pw-post-body-paragraph ji jj in jk b jl jm jn jo jp jq jr js iv jt ju jv iz jw jx jy jd jz ka kb kc ig bi translated">通过 CLI 黑屏操作应用程序交付非常方便，易于复制，并且可以批量完成。开发者喜欢它。通过 UI 交付应用程序交互更加优雅。流程操作有助于降低学习成本，实现更严格的企业安全控制。高度的可视化可以帮助我们随时随地掌握应用并进行相关操作。KubeVela 在过去版本中的 CLI 和 UI 维度有很大不同，两个维度中的数据互不通信。如果能够将这两种终端方法结合起来，应用程序的交付和管理可以更加顺畅。在 1.5 版本中，KubeVela 引入了 CloudShell 插件，为 UI 用户提供了一个 Web Shell 终端。统一门户解决了 CLI 和 UI 分离的问题，带来了更多的功能。该流程的主要变化如下:</p><p id="5a91" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">1.<strong class="jk kk">便捷工具集:</strong>与其他平台主要提供进入应用运行时的 Web Shell 能力不同，CloudShell 为每个用户生成一个终端环境，包括 CLI 工具(如 Vela、Kubectl)。您可以在同一环境中管理多个应用程序。</p><p id="6376" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">2.<strong class="jk kk">自动授权:</strong>用户不需要关心如何分配 KubeConfig。系统根据 UI 用户拥有的权限自动完成黑屏环境的授权，从而实现白屏和黑屏基本权限的一致性。</p><p id="8a39" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">3.<strong class="jk kk">自动环境回收:</strong>每个用户终端环境最大生存时间为一小时。过期后自动回收可防止过度消耗资源。</p><p id="0e61" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">4.<strong class="jk kk">增强的 Vela CLI 能力:</strong>重新实现了调试应用的 log、status、exec、port-forward 等操作命令，实现了对应用下差异化工作负载的无缝兼容，让用户在无意识的情况下完成相关操作。无论是基础部署资源、Helm 打包的负载资源集，还是自定义的操作员驱动的工作负载，Vela 都能自动发现与命令相关的底层操作对象。</p><p id="5ce2" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">5.<strong class="jk kk">数据自动同步:</strong> CLI 可以创建和更新应用程序。在用户选择通过 UI 接管应用程序和后续版本之前，更改将在 UI 上可视化。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ls"><img src="../Images/79e57ab9a65eb3b69c18482d764b4f9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mqNyMYllGxgPQo-3"/></div></div></figure><p id="28ff" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated"><em class="kd">图 6: KubeVela CloudShell 操作终端</em></p><h1 id="77c6" class="kx im in bd io ky kz la ir lb lc ld iu le lf lg iy lh li lj jc lk ll lm jg ln bi translated">集成 OpenKruise Rollout 以提供金丝雀发布功能</h1><p id="afb5" class="pw-post-body-paragraph ji jj in jk b jl jm jn jo jp jq jr js iv jt ju jv iz jw jx jy jd jz ka kb kc ig bi translated">KubeVela 社区在早期孵化了 Rollout 项目，类似于 Argo Rollout 的实现模型。它以一个新的工作负载的形式工作，主要实现批量释放的能力。随着社区的发展，KubeVela 更加专注于应用全局控制层和 addon 扩展能力。因此，工作负载级别的首次展示实现已经转移到 OpenKruise 社区。在双方的共同努力下，可以针对各种工作负载(如 native Deployment、StatefulSet、OpenKruise 扩展工作负载 CloneSet)实现 canary release 能力。同时，当它与 KubeVela 中的 Helm delivery 模式共存时，无需任何更改即可实现 Helm chart 包应用的 canary release。这在行业内是创新的，对用户来说非常方便。Kruise Rollout 作为一个插件集成到 KubeVela 生态系统中。KubeVela 用户只需要启用插件来配置应用程序组件中的 Rollout Trait。同时可以配合网关规则(比如 gateway 和 HTTPRoute)。这种实现方式具有以下优点:</p><p id="cb52" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">1.<strong class="jk kk">无入侵和绑定:</strong>通过 bypass 引入了部署功能，用户不需要对现有的应用程序配置进行其他更改。引进成本低，随时可以撤掉。</p><p id="d58b" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">2.<strong class="jk kk">易于使用:</strong>通过一个简单的流量配置切换规则，结合 KubeVela 的 UI 可视化，可以有效观察到部署过程中副本数量的变化以及引入的额外资源关系。</p><p id="f670" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">3.<strong class="jk kk">兼容性好:</strong>无论用户使用什么工作负载进行打包(Helm 或 custom Operator)，Rollout 在发现当前底层负载资源后都能以 bypass 的形式工作。</p><p id="65ee" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">参考:<a class="ae kj" href="http://kubevela.net/docs/end-user/traits/rollout" rel="noopener ugc nofollow" target="_blank">http://kubevela.net/docs/end-user/traits/rollout</a></p><h1 id="d31f" class="kx im in bd io ky kz la ir lb lc ld iu le lf lg iy lh li lj jc lk ll lm jg ln bi translated">VelaUX 增加多环境差异化可视化配置</h1><p id="0677" class="pw-post-body-paragraph ji jj in jk b jl jm jn jo jp jq jr js iv jt ju jv iz jw jx jy jd jz ka kb kc ig bi translated">自推出以来，VelaUX 就具备了多环境部署能力。直到 1.5 版本，支持多环境差异化进行用户可视化编辑，真正匹配用户多环境应用发布需求。覆盖策略配置支持环境、集群或名称空间的维度区分，以及应用基线和配置的统一管理..</p><p id="86d4" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">如图 7 所示，应用程序策略内置了各种可用选项，包括差异化配置、应用程序多集群策略、应用程序维护策略和 GC 策略。用户可以通过 UI 指导，根据自己的需求轻松配置相应的策略。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi lt"><img src="../Images/586273036236b7fc8b745b8fb9b765a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SJdldrauGAjMQ7kv"/></div></div></figure><p id="cada" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated"><em class="kd">图 7: KubeVela 策略添加/编辑窗口</em></p><p id="21e2" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">在 1.5 版中，针对不同的环境，在部署前后添加了以下方便的功能:</p><p id="83e5" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated"><strong class="jk kk">试运行(试运行)功能:</strong>您可以在部署环境之前执行试运行。然后，您可以根据 UI 反馈结果评估应用程序配置是否符合预期，以防止不正确的配置影响部署后在线服务的稳定性。</p><p id="aa9f" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated"><strong class="jk kk">环境差异洞察:</strong>切换到不同的环境视图时，自动比较本地配置和部署配置的对比。如果有差异，会提示用户，并显示差异的配置项。对于计划上线的配置，它可以防止配置漂移或忘记上线。</p><p id="bbd4" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated"><strong class="jk kk">版本明细查询及差异对比:</strong>您可以在版本管理页面查看各个版本的应用配置渲染结果。您还可以将版本配置与当前运行的配置或最新的本地配置进行比较。方便用户跟踪配置变更过程。</p><p id="c720" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">参考:【http://kubevela.net/docs/tutorials/multi-env T2】</p><h1 id="e09f" class="kx im in bd io ky kz la ir lb lc ld iu le lf lg iy lh li lj jc lk ll lm jg ln bi translated">提高应用程序引擎能力</h1><p id="1702" class="pw-post-body-paragraph ji jj in jk b jl jm jn jo jp jq jr js iv jt ju jv iz jw jx jy jd jz ka kb kc ig bi translated">除了前面的附加功能之外，对应用程序引擎进行了大量的更新。性能显著提升，工作流执行时的 CPU 消耗降低了 75%。平行处决的数量显著增加。下面列出了重要的变化:</p><p id="5c00" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">1.超时控制被添加到工作流中。在工作流步骤中，配置超时期限。当执行时间大于超时时间时，工作流将结束并终止。</p><p id="d729" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">2.工作流增加了条件判断。在工作流步骤中配置 If 字段，并支持从状态或输入中读取数据，以确定是否需要执行当前步骤。它还支持 If Always 机制，并支持在任何情况下都需要执行某些步骤的场景。</p><p id="35fa" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">3.工作流支持显示切换模式、DAG 或默认的分步。</p><p id="f627" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">4.添加共享资源策略。不同的应用程序可以描述相同的资源，如名称空间或配置图。如果将此参数设置为共享资源，则不会发生冲突。</p><p id="5a41" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">5.应用资源构造算法的优化提高了不同场景下的查询效率，也使得自定义规则的扩展更加容易。它还添加了一些默认规则。</p><p id="d66f" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">有关变更的更多信息，请参考<a class="ae kj" href="https://github.com/kubevela/kubevela/releases/tag/v1.5.0" rel="noopener ugc nofollow" target="_blank">此链接</a>。</p><h1 id="c411" class="kx im in bd io ky kz la ir lb lc ld iu le lf lg iy lh li lj jc lk ll lm jg ln bi translated">摘要</h1><p id="869a" class="pw-post-body-paragraph ji jj in jk b jl jm jn jo jp jq jr js iv jt ju jv iz jw jx jy jd jz ka kb kc ig bi translated">总体来看，KubeVela 1.5 在多个维度(如产品能力、社区生态、标杆用户)都有了显著进步。用户案例包括金融、智能制造、互联网等行业。我们期待更多用户分享实践经验，帮助 KubeVela 社区找到更准确的前进方向。1.6 版本计划带来更完整的应用程序可观察性、独立的应用程序工作流能力、多个应用程序的持续发布控制以及与可观察系统的协作。有相关需求和想法的开发者可以随时参与社区讨论。</p><p id="7941" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">您可以通过以下材料了解 KubeVela 和 OAM 项目的更多信息:</p><p id="ad68" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">项目代码库:github.com/oam-dev/kubevela 欢迎来到 Star/Watch/Fork！</p><p id="da73" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">项目官方主页和文件:kubevela.io ( <em class="kd">中文和英文文件从 1.1 版本开始提供。我们欢迎开发者翻译更多的语言文档。</em>)</p><p id="83c5" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">Slack:CNCF #库比韦拉频道</p><p id="7a67" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">来源</p><p id="feb7" class="pw-post-body-paragraph ji jj in jk b jl ke jn jo jp kf jr js iv kg ju jv iz kh jx jy jd ki ka kb kc ig bi translated">https://mp.weixin.qq.com/s/Ck5u_gNLtt_ngBqR3QAohg<a class="ae kj" href="https://mp.weixin.qq.com/s/Ck5u_gNLtt_ngBqR3QAohg" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>