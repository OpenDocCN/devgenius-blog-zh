<html>
<head>
<title>React Tips — Loading Data, Redux Stores, and Styled Links</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React 提示—加载数据、还原存储和样式化链接</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/react-tips-loading-data-redux-stores-and-styled-links-e5665c6f1f11?source=collection_archive---------14-----------------------#2020-07-28">https://blog.devgenius.io/react-tips-loading-data-redux-stores-and-styled-links-e5665c6f1f11?source=collection_archive---------14-----------------------#2020-07-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f4c46260d25f1c7d3b7d40a276acf954.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2w-xq5cxasXRc7qt"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Ramiz deda kovi 在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="1d11" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React 是一个用于创建 web 应用程序和移动应用程序的流行库。</p><p id="f2a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解一些编写更好的 React 应用程序的技巧。</p><h1 id="d07a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在子组件内的父组件上设置状态</h1><p id="8dd4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以将一个函数从父组件传递给子组件。</p><p id="6d59" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以在子进程中调用它来设置父进程的状态。</p><p id="6e47" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="66be" class="mn lc iq mj b gy mo mp l mq mr">import React, { useState, useEffect, useCallback, useRef } from "react";</span><span id="a359" class="mn lc iq mj b gy ms mp l mq mr">function Parent() {<br/>  const [parentState, setParentState] = useState(0);</span><span id="2c92" class="mn lc iq mj b gy ms mp l mq mr">  const wrapperSetParentState = useCallback(val =&gt; {<br/>    setParentState(val);<br/>  }, [setParentState]);</span><span id="562e" class="mn lc iq mj b gy ms mp l mq mr">  return (<br/>    &lt;div&gt;<br/>      &lt;Child<br/>        setParentState={wrapperSetParentState}<br/>      /&gt;<br/>      &lt;div&gt;{parentState}&lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span><span id="ccb1" class="mn lc iq mj b gy ms mp l mq mr">function Child({ setParentState }) {<br/>  const [childState, setChildState] = useState(0);</span><span id="dfce" class="mn lc iq mj b gy ms mp l mq mr">  useEffect(() =&gt; {<br/>    setParentState(childState);<br/>  }, [setParentState, childState]);</span><span id="06b4" class="mn lc iq mj b gy ms mp l mq mr">  const onSliderChange = e =&gt; {<br/>    setChildState(e.target.value);<br/>  };</span><span id="bd0f" class="mn lc iq mj b gy ms mp l mq mr">  return (<br/>    &lt;div&gt;<br/>      &lt;input<br/>        type="range"<br/>        min="1"<br/>        max="100"<br/>        value={childState}<br/>        onChange={onSliderChange}<br/>      &gt;&lt;/input&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="1045" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建了带有滑块输入的<code class="fe mt mu mv mj b">Child</code>组件，它接受一个取值范围。</p><p id="00ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们在<code class="fe mt mu mv mj b">onChange</code>属性中定义了<code class="fe mt mu mv mj b">onSliderChange</code>函数来观察变化。</p><p id="0e8a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们设置了<code class="fe mt mu mv mj b">e.target.value</code>，它将滑块的值作为<code class="fe mt mu mv mj b">childState.</code>的值</p><p id="66a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也关注<code class="fe mt mu mv mj b">childState</code>的变化，关注它的变化。</p><p id="5127" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe mt mu mv mj b">setParentState</code>来调用我们传递给道具的<code class="fe mt mu mv mj b">Parent</code>中的函数。</p><p id="adf5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它设置来自父节点的<code class="fe mt mu mv mj b">parentState</code>值，</p><p id="68da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们在<code class="fe mt mu mv mj b">Parent</code>中显示<code class="fe mt mu mv mj b">parentState</code>的最新值。</p><p id="44ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">useCallback</code>让我们缓存<code class="fe mt mu mv mj b">parentState</code>的值，如果它没有改变的话。</p><h1 id="71c4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">反应路由器 v4 <navlink> vs <link/></navlink></h1><p id="1cda" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe mt mu mv mj b">NavLink</code>在链接被导航到的时候添加一个活动类，这样我们就可以用不同于其他链接的方式来设计它。</p><p id="87c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">需要一个<code class="fe mt mu mv mj b">activeClassName</code>道具来让我们更改类名。</p><p id="f3a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8bee" class="mn lc iq mj b gy mo mp l mq mr">&lt;NavLink to="/" activeClassName="active"&gt;profile&lt;/NavLink&gt;</span></pre><p id="bc4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以动态地按照我们想要的方式来设计链接。</p><h1 id="e3e3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用不间断空格反应渲染字符串</h1><p id="a403" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以设置<code class="fe mt mu mv mj b">white-space: nowrap</code>样式来显示带有不间断空格的字符串。</p><p id="9035" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b719" class="mn lc iq mj b gy mo mp l mq mr">&lt;div style="white-space: nowrap"&gt;no breaks&lt;/div&gt;</span></pre><p id="6693" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4ae4" class="mn lc iq mj b gy mo mp l mq mr">&lt;div style={{ whiteSpace: 'nowrap' }}&gt;no breaks&lt;/div&gt;</span></pre><h1 id="4ad1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">React 组件的异步呈现</h1><p id="1350" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过提供在加载时显示的加载消息来呈现异步数据。</p><p id="3a6e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果有数据，我们就显示数据而不是加载消息。</p><p id="e3c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5ac1" class="mn lc iq mj b gy mo mp l mq mr">import React from 'react';</span><span id="63db" class="mn lc iq mj b gy ms mp l mq mr">class App extends React.PureComponent {<br/>  constructor(props){<br/>    super(props);<br/>    this.state = {<br/>      data: null<br/>    }       <br/>  }</span><span id="5ff6" class="mn lc iq mj b gy ms mp l mq mr">  componentDidMount(){<br/>    fetch('https://randomuser.me/api')<br/>      .then((resp) =&gt; resp.json())<br/>      .then((response) =&gt; {<br/>        const [data] = response.results;<br/>        setState({ data });<br/>      });<br/>    }</span><span id="1b72" class="mn lc iq mj b gy ms mp l mq mr">  render(){<br/>    return (&lt;div&gt;<br/>      {this.state.data === null ? <br/>        &lt;div&gt;Loading&lt;/div&gt;:<br/>        &lt;div&gt;{this.state.data.name.first}&lt;/div&gt;<br/>      }<br/>    &lt;/div&gt;);<br/>  }<br/>}</span></pre><p id="5f64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当<code class="fe mt mu mv mj b">data</code>状态为<code class="fe mt mu mv mj b">null</code>时，我们显示加载信息。</p><p id="50aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们从 API 中显示我们想要显示的数据。</p><p id="c34e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在<code class="fe mt mu mv mj b">componentDidMount</code>中获取数据，这意味着数据将在组件挂载时获取。</p><h1 id="b045" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用 React-Redux 调度应用程序加载操作</h1><p id="5835" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以调用<code class="fe mt mu mv mj b">mapStateToProps</code>将 Redux 存储中的状态映射为组件的道具。</p><p id="f2cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">mapDispatchToProps</code>将动作调度函数与组件的道具进行匹配。</p><p id="be2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="046c" class="mn lc iq mj b gy mo mp l mq mr">class App extends Component {<br/>  componentDidMount() {<br/>    this.props.getUser()<br/>  }</span><span id="2f18" class="mn lc iq mj b gy ms mp l mq mr">  render() {<br/>    return this.props.isReady<br/>      ? &lt;div&gt; ready &lt;/div&gt;<br/>      : &lt;div&gt;not ready&lt;/div&gt;<br/>  }<br/>}</span><span id="b9fe" class="mn lc iq mj b gy ms mp l mq mr">const mapStateToProps = (state) =&gt; ({<br/>  isReady: state.isReady,<br/>})</span><span id="93e8" class="mn lc iq mj b gy ms mp l mq mr">const mapDispatchToProps = dispatch =&gt; {<br/>  return {<br/>    getUser: () =&gt; dispatch(getUserActionCreator())<br/>  }<br/>}</span><span id="8f39" class="mn lc iq mj b gy ms mp l mq mr">export default connect(mapStateToProps, mapDispatchToProps)(App)</span></pre><p id="de39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建一个接受一个<code class="fe mt mu mv mj b">state</code>参数的<code class="fe mt mu mv mj b">mapStateToProps</code>函数，该函数有一个带有 Redux 状态的 state 参数。</p><p id="cb0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以从中获得<code class="fe mt mu mv mj b">isReady</code>状态，并将其映射到键中的<code class="fe mt mu mv mj b">isReady</code>道具。</p><p id="bbd5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">getUser</code>被映射到一个调用<code class="fe mt mu mv mj b">dispatch</code>来分派动作的函数。</p><p id="6e15" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">getUseractionCreator</code>返回一个具有<code class="fe mt mu mv mj b">type </code>和<code class="fe mt mu mv mj b">payload </code>属性的对象，将这些属性传递给 reducer 并运行正确的操作。</p><p id="2b0c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用函数组件，我们可以编写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6627" class="mn lc iq mj b gy mo mp l mq mr">import { appInit } from '../store/actions';<br/>import { useDispatch } from 'react-redux';</span><span id="0f70" class="mn lc iq mj b gy ms mp l mq mr">const appInit = () =&gt; ({ type: APP_INIT });</span><span id="ade4" class="mn lc iq mj b gy ms mp l mq mr">export default App() {<br/>  const dispatch = useDispatch();<br/>  useEffect(() =&gt; dispatch(appInit()), [ dispatch ]);</span><span id="37fb" class="mn lc iq mj b gy ms mp l mq mr">  return (&lt;div&gt;something&lt;/div&gt;);<br/>}</span></pre><p id="2a57" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe mt mu mv mj b">useDispatch</code>钩子让我们调度从<code class="fe mt mu mv mj b">appInit</code>函数返回的动作，该函数也有<code class="fe mt mu mv mj b">type</code>和<code class="fe mt mu mv mj b">payload</code>属性。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/17b8e1b4413615d6912550a9b11e549d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5UEr_KV7Ix1_qMG9"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Robina Weermeijer 在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="fec0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="b752" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用 React-Redux 调度操作来操纵存储。</p><p id="98e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以在子组件中调用父组件的函数。</p><p id="5b0b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们加载数据时，不同的东西可以按照我们的方式呈现。</p></div></div>    
</body>
</html>