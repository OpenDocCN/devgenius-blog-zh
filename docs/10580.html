<html>
<head>
<title>Smart Pointers in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust 中的智能指针</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/smart-pointers-in-rust-158046006f15?source=collection_archive---------3-----------------------#2022-11-13">https://blog.devgenius.io/smart-pointers-in-rust-158046006f15?source=collection_archive---------3-----------------------#2022-11-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/fc71e755e670991bb55f672cacf09ea2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rLe1eaLGAkOGTjroRfBoRg.png"/></div></div></figure><p id="f91a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">作为一个新手，你想在 Rust 中使用高阶函数，并且你几乎失去了尝试 trait object 来得到它的权利。</p><p id="e2de" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我想向您展示如何在 Rust 中使用智能指针的一种便捷方式，这非常方便，因为它使用了单点真模式。</p><p id="6ff4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，你想在代码中使用闭包作为函数参数，但是不知道怎么做，这就是我一直做的方式。</p><h1 id="c15f" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">创建类型别名</h1><pre class="lr ls lt lu gt lv lw lx bn ly lz bi"><span id="51c8" class="ma ku in lw b be mb mc l md me">pub type ProducerFn&lt;R&gt; = dyn Fn() -&gt; R;<br/><br/>pub type ConsumerFn&lt;T&gt; = dyn Fn(T);<br/><br/>// or anything like this here as an example<br/>pub type Function1&lt;T, R&gt; = dyn Fn(T) -&gt; R;<br/>pub type Function2&lt;T1, T2, R&gt; = dyn Fn(T1, T2) -&gt; R; // and so on</span></pre><p id="2ee6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将把函数定义包装成一个类型别名。它现在不工作，我会马上解释它。</p><p id="a4e4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我们在函数签名中使用这种类型。</p><pre class="lr ls lt lu gt lv lw lx bn ly lz bi"><span id="9f3b" class="ma ku in lw b be mb mc l md me">pub fn fun&lt;T&gt;(producer: ProducerFn&lt;T&gt;) {<br/>  let output = producer();<br/>  ... // do something with the output<br/>}</span></pre><p id="e1b4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这只是…的别名</p><pre class="lr ls lt lu gt lv lw lx bn ly lz bi"><span id="285b" class="ma ku in lw b be mb mc l md me">pub fn fun&lt;T&gt;(producer: dyn Fn() -&gt; T) {<br/>  let output = producer();<br/>  ... // do something with the output<br/>}</span></pre><p id="334e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是这不起作用，因为我们需要签名中的大小值，而一个<em class="mf"> dyn Something </em>是任意大小的。</p><p id="f8d2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，我们需要在编译时将它包装成某种给定大小的结构。</p><p id="167c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最好的选择是<em class="mf">智能指针</em>。</p><p id="9082" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Rust 中的智能指针可能是&amp;…，盒形<t>，或者弧形<t>。</t></t></p><p id="f0b0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以，这样做是有效的:</p><pre class="lr ls lt lu gt lv lw lx bn ly lz bi"><span id="163d" class="ma ku in lw b be mb mc l md me">pub type ProducerFn&lt;R&gt; = &amp;dyn Fn() -&gt; R;<br/><br/>pub type ConsumerFn&lt;T&gt; = Box&lt;dyn Fn(T)&gt;;<br/><br/>pub type Function1&lt;T, R&gt; = Arc&lt;dyn Fn(T) -&gt; R&gt;;</span></pre><p id="65ef" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为您使用的东西创建类型别名总是一个好习惯，比如</p><pre class="lr ls lt lu gt lv lw lx bn ly lz bi"><span id="0035" class="ma ku in lw b be mb mc l md me">pub type Millimeters = f64; // or the like</span></pre><p id="fd62" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以没什么好困惑的。(f64 又是什么意思？厘米？英寸？…)</p><h1 id="d1ae" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">高阶函数的使用</h1><p id="9f43" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">(不要迷惑霍夫；) )</p><p id="3d8d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们可以使用 Rust 中定义为闭包的高阶函数。</p><pre class="lr ls lt lu gt lv lw lx bn ly lz bi"><span id="d535" class="ma ku in lw b be mb mc l md me">fun(|| { return 42u8 }); // as the usage of the producer || { return 42u8 }</span></pre><p id="5c33" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是等等，不对劲！</p><p id="d3db" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们需要将它和我们的类型别名定义一起包装到一个智能指针中。</p><pre class="lr ls lt lu gt lv lw lx bn ly lz bi"><span id="e7ec" class="ma ku in lw b be mb mc l md me">// So for <br/>pub type ProducerFn&lt;T&gt; = Box&lt;dyn Fn() -&gt; T&gt;;<br/><br/>// we have to wrap it with<br/>fun(Box::new(||{ return 42u8 }));</span></pre><p id="a827" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你经常使用生产者，这很容易出错，而且很乏味，如果你决定以后改变智能指针。</p><h1 id="e50a" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">宏来了</h1><p id="ceeb" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">只需在类型别名旁边定义宏。</p><pre class="lr ls lt lu gt lv lw lx bn ly lz bi"><span id="b960" class="ma ku in lw b be mb mc l md me">pub type ProducerFn&lt;R&gt; = Box&lt;dyn Fn() -&gt; R&gt;;<br/>#[macro_export]<br/>macro_rules! producer {<br/>  ($e:expr) =&gt; {<br/>    Box::new($e);<br/>  }<br/>}<br/><br/>pub type ConsumerFn&lt;T&gt; = Box&lt;dyn Fn(T)&gt;;<br/>#[macro_export]<br/>macro_rules! consumer {<br/>  ($e:expr) =&gt; {<br/>    Box::new($e);<br/>  }<br/>}<br/></span></pre><p id="724f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是一个非常简单的规则，不要害怕重复。这将会带来巨大的回报，因为如果你需要将它从框改为弧，例如，只需要在代码中的一个位置就可以很容易地做到。</p><p id="f944" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你只需要在用法上保持一致。</p><pre class="lr ls lt lu gt lv lw lx bn ly lz bi"><span id="0a7e" class="ma ku in lw b be mb mc l md me">fun(producer!(|| { return 42u8 }));<br/>//or<br/>doit(consumer!(|value| { // do sumething with value }));</span></pre><h1 id="7081" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">只有一个补充</h1><pre class="lr ls lt lu gt lv lw lx bn ly lz bi"><span id="bf9d" class="ma ku in lw b be mb mc l md me">&amp;... // single-threaded, pointing to the stack<br/>Box... // single-threaded, pointing to the heap<br/>Arc... // multi-threaded, pointing to the heap</span></pre><p id="b8c2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">只要明智地选择你的智能指针。</p><h1 id="f74c" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结论</h1><p id="3bc3" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">使用这种简单的类型别名和宏定义方法，您将在开发程序时获得更安全和更快的速度。</p><p id="0d30" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我希望这篇文章能帮助您更好地理解如何将智能指针用于像闭包这样的特殊对象。</p></div></div>    
</body>
</html>