<html>
<head>
<title>Beyond the basics of GCD</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">超越GCD的基础</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/beyond-the-basics-of-gcd-e65d70720260?source=collection_archive---------14-----------------------#2020-06-10">https://blog.devgenius.io/beyond-the-basics-of-gcd-e65d70720260?source=collection_archive---------14-----------------------#2020-06-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/11a815b08548101cd9c1c16ad2154688.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mKyns1TwyKypSs0SG6clAA.jpeg"/></div></div></figure><p id="1a71" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们都知道iOS中的多线程概念。这都是关于我们如何在不干扰主线程的情况下同时完成多项任务。正如我们所知，主线程在一个串行队列中运行，而UI只在主线程上运行。我们有不同的概念来实现多线程。它们是大中央调度(GCD)、操作队列和线程。</p><h1 id="965a" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">中央车站调度</h1><p id="91af" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">GCD是一个流行的基本概念。但是，这仅限于将任务分派到一个并发队列。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/53b413bd39a8693c3305bd9a4e60723d.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*C1pI9ojI0AJn8IO2UDqrlQ.png"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">图1:调度队列示例</figcaption></figure><p id="31ec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">除了<em class="mf"> DispatchQueue之外，</em> GCD还有很多被大多数开发者忽略的API。让我们深入了解这些API。它们是DispatchGroup、DispatchWorkItem和DispatchSemaphore。</p><h2 id="960a" class="mg ku in bd kv mh mi dn kz mj mk dp ld kg ml mm lh kk mn mo ll ko mp mq lp mr bi translated">调度组</h2><p id="8af0" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">在开发一个iOS应用程序时，有时我们需要一些可以同时执行多项任务的架构。多个网络同时呼叫。在这种情况下，调度组起着至关重要的作用。我们可以同时进行多个网络调用，在所有网络调用完成后，我们可以在主线程上更新UI。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/b0c908c1fba05750ba94023d36588b64.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/format:webp/1*IOaZzyrhV_CxgfAHrn6BUA.png"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">图2:调度组示例</figcaption></figure><p id="5e97" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如您在上面的<em class="mf">图2 </em>中看到的，我们需要创建DispatchGroup的一个<em class="mf">实例。</em>每个任务在执行前需要进入群体，执行后需要离开群体。所有任务执行完毕后，小组会通知我们。</p><p id="92e0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">根据苹果公司的文件，</p><blockquote class="mt"><p id="ffb3" class="mu mv in bd mw mx my mz na nb nc ks dk translated">组允许您聚合一组任务并同步组上的行为。您可以将多个工作项目附加到一个组中，并安排它们在同一队列或不同队列中异步执行。当所有工作项执行完毕时，该组执行其完成处理程序。您还可以同步等待组中的所有任务执行完毕。</p></blockquote><h2 id="3791" class="mg ku in bd kv mh nd dn kz mj ne dp ld kg nf mm lh kk ng mo ll ko nh mq lp mr bi translated">分派工作项</h2><p id="9596" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">让我们考虑一个例子，在我们的应用程序中有一个UISearchBar。用户可以快速输入。但是，我们不想提出网络请求，在每个字符之后。我们能不能等一段时间，当用户几秒钟没有输入时，只发出一个网络请求？我们如何实现这一目标？或许，我们都会想到计时器和操作。</p><p id="3a78" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在是时候了解DispatchWorkItem了。我们将看到DispatchWorkItem如何帮助我们实现这个目标。iOS 8和macOS 10.10中引入了DispatchWorkItem</p><blockquote class="ni nj nk"><p id="824c" class="jv jw mf jx b jy jz ka kb kc kd ke kf nl kh ki kj nm kl km kn nn kp kq kr ks ig bi translated">当被问及OperationQueue和GCD的区别时，我看到许多开发人员说，OperationQueue更好，因为我们可以取消一个操作。然而，在GCD中我们不能这样做。</p></blockquote><p id="57e1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当没有引入分派工作项时，上面的陈述是正确的。它封装了我们希望在DispatchQueue和DispatchGroup中执行的任务。我们可以在安排好工作项<em class="mf">之后取消它。</em></p><p id="ee53" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以创建工作项实例并附加DispatchQueue。</p><pre class="lx ly lz ma gt no np nq nr aw ns bi"><span id="cb55" class="mg ku in np b gy nt nu l nv nw">let newWorkItem = DispatchWorkItem {<br/>    //do something...</span><span id="c8f5" class="mg ku in np b gy nx nu l nv nw">}</span><span id="a1eb" class="mg ku in np b gy nx nu l nv nw">DispatchQueue.main.async(execute: newWorkItem)</span></pre><p id="3b3c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们看看如何使用DispatchWorkItem实现这种情况。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ny"><img src="../Images/dca5858c224e3e31864bb70a3560b2cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1kQJTKYWr0-jfIf0RsRzrg.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">图3:分派工作项示例</figcaption></figure><h2 id="b9dd" class="mg ku in bd kv mh mi dn kz mj mk dp ld kg ml mm lh kk mn mo ll ko mp mq lp mr bi translated">调度信号量</h2><p id="cb2d" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">当我们试图阻止一个线程访问一个资源时，调度信号量可以帮助我们。换句话说，我们可以说，一个任务可以同步等待其他任务完成执行。</p><pre class="lx ly lz ma gt no np nq nr aw ns bi"><span id="0deb" class="mg ku in np b gy nt nu l nv nw">let semaphore = DispatchSemaphore(value: 1)</span><span id="8c1e" class="mg ku in np b gy nx nu l nv nw">semaphore.wait()<br/>task { (result) in<br/>    semaphore.signal()<br/>}</span></pre><h2 id="5429" class="mg ku in bd kv mh mi dn kz mj mk dp ld kg ml mm lh kk mn mo ll ko mp mq lp mr bi translated">结论</h2><p id="20a5" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">GCD是非常强大的框架。它为我们执行复杂的任务提供了更简单的方法。</p><p id="ad7d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">希望我们已经涵盖了所有这些API，我们应该在我们的iOS应用程序中使用。如果你发现其他有用的GCD API，请在评论区告诉我。也让我知道在评论部分，你的反馈，如果你有任何问题。</p></div><div class="ab cl nz oa hr ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ig ih ii ij ik"><p id="6fc9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">感谢阅读。希望你喜欢它。随意评论。</p><p id="3251" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你觉得这篇文章有帮助，请鼓掌，你知道每篇文章可以鼓掌50次😉，并鼓励我进一步写更多的文章。</p></div></div>    
</body>
</html>