<html>
<head>
<title>Design Pattern — Prototype</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计模式—原型</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/design-pattern-prototype-59bffd7d29ab?source=collection_archive---------4-----------------------#2021-06-27">https://blog.devgenius.io/design-pattern-prototype-59bffd7d29ab?source=collection_archive---------4-----------------------#2021-06-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="dbdb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">原型设计模式详解</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fea359839680cacf25728651dc4fa0fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0vcHIQZR8gUkY7ia"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Avi Werde 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="4d41" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">原型设计模式是由四人帮(g of)提出的另一种创造性的设计模式。当我们已经有了一个与我们想要创建的对象相同类型(原型)的对象时，就使用这个。我们可以克隆现有类型的对象来创建一个新的。</p><h1 id="acfc" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">原型设计模式是什么？</h1><p id="0e8b" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">当创建对象的成本很高，或者克隆一个现有的对象比从头创建一个更容易时，原型设计模式是最常用的。这可能是当我们试图重构和优化代码中的某个模块时，通常使用这种模式的原因。</p><p id="9765" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">原型设计模式中的对象是从另一个原型实例克隆的，而不是用“new”创建的。这不是规则，而是惯例。</p><p id="9030" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">原型模式是用一个称为<em class="mc">注册表</em>的支持或助手类创建的。这个类可以保存一组原型对象，并可以在需要时快速克隆一个。这个助手类本身可以使用其他设计模式，比如Singleton。</p><p id="e446" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">原型模式通常用一个<em class="mc">可克隆的</em>接口实现。这就是我们如何摆脱称<em class="mc">为新</em>的方法。</p><h1 id="a3bb" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">原型设计模式解决的问题</h1><ul class=""><li id="287a" class="md me in jm b jn lx jr ly jv mf jz mg kd mh kh mi mj mk ml bi translated">创建新对象的成本很高——这有助于隐藏创建新实例的复杂性。复制或克隆对象有时比创建新对象更有效。</li><li id="9bd6" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">不使用<em class="mc">新建</em>创建对象。</li><li id="306f" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">它有助于在不知道类型的情况下生成新对象。</li></ul><h1 id="6e28" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">原型设计模式的应用</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mr"><img src="../Images/f89c983d9be409530dff8b09b6d60a7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tUcZkSkKY-x2_2xs"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">杰里米·毕晓普在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="65ac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当实现原型设计模式时，您应该遵循某些指导原则。</p><ul class=""><li id="186a" class="md me in jm b jn jo jr js jv ms jz mt kd mu kh mi mj mk ml bi translated">对象的克隆——在原型设计模式中，我们克隆对象并且不使用<em class="mc">新的</em>操作符。即使对象是克隆的而不是新建的，每个克隆的实例都是唯一的。</li><li id="3821" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">可克隆接口——原型模式，因为它使用对象的克隆，所以通常用可克隆接口来实现。通常是原型对象的抽象类实现了这个接口。</li><li id="f455" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">注册表——原型模式通常伴随着一个注册表类。这个类保存了原型对象，需要时会克隆这些对象。</li></ul><p id="3168" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看一些代码—</p><h1 id="e965" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">抽象类—食物</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">抽象类食物</figcaption></figure><p id="3211" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里我们创建了一个抽象的食物类。这个类将是我们想要克隆的所有对象类型的超类。它实现了可克隆接口的clone()方法。它还可能包含一些成员变量和函数。</p><h1 id="424f" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">具体类</h1><p id="3c92" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">下面是Food类型的几个具体类的实现。这些是我们想要克隆对象的类的实现。它主要是成员变量及其getters和setters。在一个更真实的应用程序中，我们可以想象这些类可能不那么简单，因为正如我们所讨论的，它们的创建是昂贵的，这就是为什么我们使用这种设计模式。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">中餐</figcaption></figure><p id="0486" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一个具体的类—</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">意大利食品</figcaption></figure><h1 id="5559" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">登记处</h1><p id="a060" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">就像我们之前讨论的，原型模式通常有一个注册表类。这是我们存放克隆对象的地方。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">登记处</figcaption></figure><p id="cc6d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如你在代码中看到的，我们创建了一个原型图。这些原型是用<em class="mc">新</em>制造的。我们将在应用程序开始时创建所有这样的对象并保存它们。</p><p id="f2b1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个类还包含一个方法<em class="mc"> getNewItem() </em>。这个方法用一个类型(名称)来分类。此方法克隆所提供类型的对象并返回一个对象。我们将在下面的代码中看到，每当我们想要获取特定类型对象的新实例时，都会调用该方法。</p><h1 id="b492" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">演示代码</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">主要的</figcaption></figure><p id="4313" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在第6行，我们正在迎合注册中心。这很可能是一个单胎。我们选择保持我们的注册表简单。</p><p id="45ef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在在第7行，我们调用前面提到的<em class="mc"> getNewItem() </em>方法。这个方法需要一个参数，并返回一个新的克隆对象。我们在这里使用string来标识类型，它很可能是类本身类型的一个<em class="mc">枚举</em>。我们得到一个类型为<em class="mc"> ChineseFood </em>的新对象。类似地，我们在第17行再次调用<em class="mc"> getNewItem() </em>。它再次返回类型为<em class="mc"> ChineseFood </em>的新实例。</p><p id="946c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如你所见，我们在第12 &amp; 20行打印对象。从输出中可以看到，这两个对象有不同的ID。所以每次你克隆一个对象，你会得到一个从现有对象克隆的新对象。</p><h1 id="ec28" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">输出</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h1 id="64ec" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">何时使用原型设计模式？</h1><p id="eaa0" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">当创建一个新对象的成本很高时，通常使用原型设计模式。我们可以通过克隆相同类型的现有对象来获得对象的新实例。此克隆对象是同一类型的现有对象的副本。</p><h1 id="1c8d" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">限制</h1><ul class=""><li id="0cf6" class="md me in jm b jn lx jr ly jv mf jz mg kd mh kh mi mj mk ml bi translated">经常与其他模式一起使用——使用原型模式需要一个注册中心。这就变成了一个框架，你在另一个框架中使用一个设计模式。</li><li id="3d63" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">非常不常见——这与Singleton相反。Singleton是一种过度使用的模式，而Prototype并不经常使用。这可能是因为缺少我们可能想要使用这种设计模式的场景。</li><li id="41a9" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">浅层复制——Prototype进行浅层复制，这对于常见的字段类型来说是可以的，但是当我们在原型对象中有类似数组的东西时，可能会很麻烦。</li><li id="b36a" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">制作对象本身的副本有时很复杂。</li></ul><h1 id="983b" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">摘要</h1><p id="a2b2" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">当创建一个给定类的实例很昂贵或者很复杂时，可以使用原型模式。</p><p id="0a1c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">大多数情况下，它被用作重构的一部分，而不是工程师们一开始就想到的东西。</p></div><div class="ab cl mx my hr mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ig ih ii ij ik"><p id="f39c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mc">撰写&amp;编辑——维韦克·米塔尔</em></p><div class="ne nf gp gr ng nh"><a href="https://www.linkedin.com/in/vivekmittal06" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd io gy z fp nm fr fs nn fu fw im bi translated">Vivek Mittal -首席软件工程师- Nuance Communications | LinkedIn</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">我是一名经验丰富的软件工程师，在软件工程方面有超过10年的经验。我有广泛的…</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">www.linkedin.com</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv ks nh"/></div></div></a></div><h1 id="c598" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">附加阅读</h1><div class="ne nf gp gr ng nh"><a href="https://medium.com/dev-genius/software-design-patterns-1b41de14ab8b" rel="noopener follow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd io gy z fp nm fr fs nn fu fw im bi translated">软件设计模式</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">软件设计模式概述</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">medium.com</p></div></div><div class="nq l"><div class="nw l ns nt nu nq nv ks nh"/></div></div></a></div><div class="ne nf gp gr ng nh"><a href="https://medium.com/dev-genius/design-pattern-singleton-fa0f676a5d16" rel="noopener follow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd io gy z fp nm fr fs nn fu fw im bi translated">设计模式—单例</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">最常见的设计模式——单一模式的详细讨论</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">medium.com</p></div></div><div class="nq l"><div class="nx l ns nt nu nq nv ks nh"/></div></div></a></div><div class="ne nf gp gr ng nh"><a href="https://medium.com/dev-genius/design-pattern-builder-1ad55ed26120" rel="noopener follow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd io gy z fp nm fr fs nn fu fw im bi translated">设计模式—构建器</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">Builder设计模式的详细讨论</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">medium.com</p></div></div><div class="nq l"><div class="ny l ns nt nu nq nv ks nh"/></div></div></a></div><div class="ne nf gp gr ng nh"><a href="https://medium.com/dev-genius/design-pattern-state-e0ed37cd853a" rel="noopener follow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd io gy z fp nm fr fs nn fu fw im bi translated">设计模式—状态</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">状态设计模式的深入探讨</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">medium.com</p></div></div><div class="nq l"><div class="nz l ns nt nu nq nv ks nh"/></div></div></a></div></div></div>    
</body>
</html>