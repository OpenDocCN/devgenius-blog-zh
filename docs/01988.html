<html>
<head>
<title>Multiple Linear Regression</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">多元线性回归</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/multiple-linear-regression-b7eb053bcf9d?source=collection_archive---------39-----------------------#2020-07-15">https://blog.devgenius.io/multiple-linear-regression-b7eb053bcf9d?source=collection_archive---------39-----------------------#2020-07-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="b10c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上一篇文章中，我们学习了一元线性回归。它的假设函数是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/d944691d0020c72239ba3f2a6933544d.png" data-original-src="https://miro.medium.com/v2/resize:fit:458/format:webp/1*oxgsVwr3UbMD4Yyb7R6TyQ.jpeg"/></div></figure><p id="0ac7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是一条直线。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi kq"><img src="../Images/3abc59e1fbdd32e5c04d82d296417dc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*OR_SI9BLfVd-Sn7MlFj7nQ.jpeg"/></div></figure><p id="b137" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果，我们有不止一个自变量或特征。那么我们的假设函数可以是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi kr"><img src="../Images/079bae59160c8847dc330f30d0a92c0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*6XrnsoiRqzrBTNEYcxVCFA.jpeg"/></div></figure><p id="db13" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的(y 对 x 图)图表如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi ks"><img src="../Images/23161a88f90ba955537f6412489c34e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TuRFYBVTs9O4EG51DOzm4Q.png"/></div></div></figure><p id="d11b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如我们所看到的，由于有更多的独立变量，我们的模型完全符合训练数据。这叫做<strong class="jm io">过拟合</strong>。虽然特征较少，但它不太适合输入，这被称为<strong class="jm io">欠拟合</strong>。现在，虽然欠拟合会导致错误的预测，但过拟合对我们的机器学习模型也没有好处。因为虽然它会很好地匹配训练集，但它可能不会很好地处理测试或实际数据。因为它偏向于我们的训练集，并且只在相同或相似的输入下工作良好。在可变数据集上，它的性能会很差。</p><p id="b59c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">如何选择参数个数？</strong></p><p id="2681" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">很明显，为了解决欠拟合，我们可以引入更多的特性。但是我们如何解决<strong class="jm io">过拟合</strong>？</p><p id="6c3b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">避免过度拟合:</strong></p><ol class=""><li id="0d86" class="kx ky in jm b jn jo jr js jv kz jz la kd lb kh lc ld le lf bi translated">一种自然的方法是减少参数的数量并对它们进行调整，使其不仅仅适用于给定的数据集。</li><li id="13cd" class="kx ky in jm b jn lg jr lh jv li jz lj kd lk kh lc ld le lf bi translated">第二种方式是<strong class="jm io">规范化</strong>。这意味着在保持所有特征的同时减少参数𝜃𝑖的大小。</li></ol><p id="dcbf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">规范化</strong>:</p><p id="6233" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，如果我们的假设函数是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ll"><img src="../Images/067f29488e696d60a12fbb14e703dafb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*O1llIBLs_FHvlnIPb67kIA.jpeg"/></div></figure><p id="82af" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们惩罚成本函数中较高的项。所以我们的成本函数会变成这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/d9cb5e6740cf1961f371059daccc6ad1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*Z6c131l6YSjMb-gI0mQN0w.jpeg"/></div></figure><p id="4345" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里，最后一个术语是正则化术语。记住，我们的目标是最小化成本函数。现在，通过引入正则化，我们正在增加某些参数(𝜃𝑗)的成本函数值</p><p id="a165" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">选择正则化因子(𝜆 ) </strong></p><p id="f3fc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果𝜆太大，可能会导致拟合不足。如果𝜆太小，可能没有效果。所以我们必须根据我们的数据选择正则化因子。</p><p id="1aa6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">注意:在某些 ML 库中，如 XGBoost，正则化因子也被称为𝛼。</strong></p><p id="135c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">参考:<a class="ae ln" href="http://Coursera | Online Courses &amp; Credentials From Top Educators. Join for Free | Coursera" rel="noopener ugc nofollow" target="_blank"> Coursera </a></p></div></div>    
</body>
</html>