<html>
<head>
<title>Container — Namespace Introduction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">容器—名称空间介绍</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/container-namespace-introduction-6a1e26f8707a?source=collection_archive---------3-----------------------#2022-11-02">https://blog.devgenius.io/container-namespace-introduction-6a1e26f8707a?source=collection_archive---------3-----------------------#2022-11-02</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="591d" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">常见容器名称空间介绍</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/e52cfa8f95b23f420f5732ee9eba77cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RyWG68q5y6mgsEXFzTftlw.png"/></div></div></figure><h1 id="d354" class="ks kt ir bd ku kv kw kx ky kz la lb lc jx ld jy le ka lf kb lg kd lh ke li lj bi translated">什么是名称空间</h1><p id="3ec0" class="pw-post-body-paragraph lk ll ir lm b ln lo js lp lq lr jv ls lt lu lv lw lx ly lz ma mb mc md me mf ik bi translated">我们都知道操作系统使用虚拟内存技术，让每个用户进程都认为自己拥有所有的物理内存，这就是操作系统对内存的虚拟化。</p><p id="406b" class="pw-post-body-paragraph lk ll ir lm b ln mg js lp lq mh jv ls lt mi lv lw lx mj lz ma mb mk md me mf ik bi translated">还有，通过分时调度系统，可以公平地调度和执行每个进程，即每个进程都可以获得 CPU，使每个进程在进程活动期间都认为自己拥有所有的 CPU 时间，这就是操作系统对 CPU 的虚拟化。</p><p id="a3e5" class="pw-post-body-paragraph lk ll ir lm b ln mg js lp lq mh jv ls lt mi lv lw lx mj lz ma mb mk md me mf ik bi translated">但是，以上两种虚拟化技术只是虚拟化了<strong class="lm is">【物理资源】</strong>。其实在一台主机上，操作系统中有很多<strong class="lm is">【非物理资源】</strong>，比如用户权限、网络协议栈资源、文件系统挂载路径资源等。通过 Linux 的<strong class="lm is">命名空间</strong>特性，这些非物理的全局资源可以被虚拟化。</p><p id="7712" class="pw-post-body-paragraph lk ll ir lm b ln mg js lp lq mh jv ls lt mi lv lw lx mj lz ma mb mk md me mf ik bi translated">根据 wiki <strong class="lm is">的说法，名称空间</strong>是 Linux 内核的一个特性，它对内核资源进行分区，使得一组进程看到一组资源，而另一组进程看到一组不同的资源。</p><p id="dc4b" class="pw-post-body-paragraph lk ll ir lm b ln mg js lp lq mh jv ls lt mi lv lw lx mj lz ma mb mk md me mf ik bi translated">该功能通过为一组资源和进程分配相同的命名空间来工作，但是这些命名空间引用不同的资源。名称空间是 Linux 上容器的一个基本方面。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj ml"><img src="../Images/9473d67b2538782c286e230fe0664004.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y25tkScMS970O6YGUFqN-A.png"/></div></div></figure><h1 id="3316" class="ks kt ir bd ku kv kw kx ky kz la lb lc jx ld jy le ka lf kb lg kd lh ke li lj bi translated">名称空间如何工作</h1><p id="bbc1" class="pw-post-body-paragraph lk ll ir lm b ln lo js lp lq lr jv ls lt lu lv lw lx ly lz ma mb mc md me mf ik bi translated">名称空间是 Linux 系统的基本概念。它是在内核层实现的。</p><ul class=""><li id="a851" class="mm mn ir lm b ln mg lq mh lt mo lx mp mb mq mf mr ms mt mu bi translated">每个容器运行在相同的容器运行时进程中，并共享相同的主机系统内核。</li><li id="185a" class="mm mn ir lm b ln mv lq mw lt mx lx my mb mz mf mr ms mt mu bi translated">每个容器都必须有一个类似于虚拟机的隔离运行空间，但容器技术实现了一个进程内运行指定服务的运行环境，还可以保护主机内核免受其他进程的干扰和影响，如文件系统空间、网络空间、进程空间等。</li><li id="f6f2" class="mm mn ir lm b ln mv lq mw lt mx lx my mb mz mf mr ms mt mu bi translated">名称空间目前主要通过以下技术在容器运行空间中相互隔离:</li></ul><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj na"><img src="../Images/a11758e9c526b9b0f8851cb7a2cf4b42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NSWVd5cBZ0tPKizztUnXhA.png"/></div></div></figure><h1 id="bb60" class="ks kt ir bd ku kv kw kx ky kz la lb lc jx ld jy le ka lf kb lg kd lh ke li lj bi translated">容器中使用的常见名称空间</h1><h2 id="ad20" class="nb kt ir bd ku nc nd dn ky ne nf dp lc lt ng nh le lx ni nj lg mb nk nl li nm bi translated">MNT 命名空间</h2><p id="465e" class="pw-post-body-paragraph lk ll ir lm b ln lo js lp lq lr jv ls lt lu lv lw lx ly lz ma mb mc md me mf ik bi translated"><code class="fe nn no np nq b">MNT namespace</code>提供磁盘挂载点和文件系统的隔离:</p><ul class=""><li id="8e0d" class="mm mn ir lm b ln mg lq mh lt mo lx mp mb mq mf mr ms mt mu bi translated">每个容器必须有自己独立的根文件系统和独立的用户空间</li><li id="5546" class="mm mn ir lm b ln mv lq mw lt mx lx my mb mz mf mr ms mt mu bi translated">它为系统上的不同进程提供了拥有主机文件系统的不同视图的机会</li></ul><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj nr"><img src="../Images/9ff49bc0a0f3705d0c7ed1a0cc29beff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZcDDs-Md-V-suFPUGw737A.png"/></div></div></figure><p id="f159" class="pw-post-body-paragraph lk ll ir lm b ln mg js lp lq mh jv ls lt mi lv lw lx mj lz ma mb mk md me mf ik bi translated">使用带有<code class="fe nn no np nq b">CLONE_NEWNS</code>标志的<code class="fe nn no np nq b">clone</code>或<code class="fe nn no np nq b">unshare</code>系统调用创建一个新的挂载名称空间。创建新的装载命名空间时，其装载列表初始化如下:</p><ul class=""><li id="e28f" class="mm mn ir lm b ln mg lq mh lt mo lx mp mb mq mf mr ms mt mu bi translated">如果名称空间是使用<code class="fe nn no np nq b">clone</code>创建的，那么子名称空间的挂载列表是父进程的挂载名称空间中的挂载列表的副本。</li><li id="e7d8" class="mm mn ir lm b ln mv lq mw lt mx lx my mb mz mf mr ms mt mu bi translated">如果名称空间是使用<code class="fe nn no np nq b">unshare</code>创建的，那么新名称空间的挂载列表是调用者以前的挂载名称空间中的挂载列表的副本。</li></ul><p id="1749" class="pw-post-body-paragraph lk ll ir lm b ln mg js lp lq mh jv ls lt mi lv lw lx mj lz ma mb mk md me mf ik bi translated"><strong class="lm is">演示</strong></p><p id="f8e0" class="pw-post-body-paragraph lk ll ir lm b ln mg js lp lq mh jv ls lt mi lv lw lx mj lz ma mb mk md me mf ik bi translated">在新的<code class="fe nn no np nq b">mount</code>名称空间中运行 shell</p><pre class="kh ki kj kk gu ns nq nt nu aw nv bi"><span id="5425" class="nb kt ir nq b gz nw nx l ny nz">$ unshare --mount</span></pre><p id="7904" class="pw-post-body-paragraph lk ll ir lm b ln mg js lp lq mh jv ls lt mi lv lw lx mj lz ma mb mk md me mf ik bi translated">创建一个<code class="fe nn no np nq b">/tmp/mnt</code>目录</p><pre class="kh ki kj kk gu ns nq nt nu aw nv bi"><span id="f850" class="nb kt ir nq b gz nw nx l ny nz">$ mkdir /tmp/mnt<br/>$ ls /tmp/mnt</span></pre><p id="4445" class="pw-post-body-paragraph lk ll ir lm b ln mg js lp lq mh jv ls lt mi lv lw lx mj lz ma mb mk md me mf ik bi translated">坐骑<code class="fe nn no np nq b">/usr/local/bin</code></p><pre class="kh ki kj kk gu ns nq nt nu aw nv bi"><span id="bc86" class="nb kt ir nq b gz nw nx l ny nz">$ mount --bind /usr/local/bin /tmp/mnt/<br/>$ ls /tmp/mnt/<br/>2to3-3.10  idle3.10  pip3.10  pydoc3.10  python3.10  python3.10-config<br/>$ findmnt  | grep "tmp/mnt"<br/>└─/tmp/mnt                            /dev/xvda1[/usr/local/bin]                         xfs        rw,noatime,attr2,inode64,logbufs=8,logbsize=32k,noquota</span></pre><p id="a9b6" class="pw-post-body-paragraph lk ll ir lm b ln mg js lp lq mh jv ls lt mi lv lw lx mj lz ma mb mk md me mf ik bi translated">出口</p><pre class="kh ki kj kk gu ns nq nt nu aw nv bi"><span id="ac68" class="nb kt ir nq b gz nw nx l ny nz">$ exit<br/>$ ls /tmp/mnt/pydoc3.10<br/>ls: cannot access /tmp/mnt/pydoc3.10: No such file or directory</span></pre><h2 id="7cf0" class="nb kt ir bd ku nc nd dn ky ne nf dp lc lt ng nh le lx ni nj lg mb nk nl li nm bi translated">IPC 名称空间</h2><p id="2c3c" class="pw-post-body-paragraph lk ll ir lm b ln lo js lp lq lr jv ls lt lu lv lw lx ly lz ma mb mc md me mf ik bi translated">IPC 名称空间用于隔离 System V IPC 对象和 POSIX 消息队列。用于实现这一点的克隆标志是<code class="fe nn no np nq b">CLONE_NEWIPC</code>。每个 IPC 名称空间都有自己的一组 System V IPC 标识符和自己的 POSIX 消息队列文件系统。</p><p id="2fad" class="pw-post-body-paragraph lk ll ir lm b ln mg js lp lq mh jv ls lt mi lv lw lx mj lz ma mb mk md me mf ik bi translated"><strong class="lm is">在一个 IPC 命名空间中创建的对象对作为该命名空间成员的所有其他进程可见，但对其他 IPC 命名空间中的进程不可见</strong>。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj ml"><img src="../Images/9320611d7e82a0c5ae43a08a2f51c3a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CETwMb-OQM733MXzjXDnUw.png"/></div></div></figure><p id="1b27" class="pw-post-body-paragraph lk ll ir lm b ln mg js lp lq mh jv ls lt mi lv lw lx mj lz ma mb mk md me mf ik bi translated"><strong class="lm is">演示</strong></p><p id="c5ef" class="pw-post-body-paragraph lk ll ir lm b ln mg js lp lq mh jv ls lt mi lv lw lx mj lz ma mb mk md me mf ik bi translated">列出当前 IPC 名称空间</p><pre class="kh ki kj kk gu ns nq nt nu aw nv bi"><span id="f296" class="nb kt ir nq b gz nw nx l ny nz">$ lsns | grep ipc<br/>4026531839 ipc       112     1 root   /usr/lib/systemd/systemd --switched-root --system --deserialize 21</span></pre><p id="b8db" class="pw-post-body-paragraph lk ll ir lm b ln mg js lp lq mh jv ls lt mi lv lw lx mj lz ma mb mk md me mf ik bi translated">创建 IPC 命名空间:</p><pre class="kh ki kj kk gu ns nq nt nu aw nv bi"><span id="d227" class="nb kt ir nq b gz nw nx l ny nz">$ unshare --ipc<br/>$ lsns | grep ipc<br/>4026531839 ipc       110     1 root   /usr/lib/systemd/systemd --switched-root --system --deserialize 21<br/>4026532281 ipc         3 29447 root   -bash</span></pre><h2 id="fc38" class="nb kt ir bd ku nc nd dn ky ne nf dp lc lt ng nh le lx ni nj lg mb nk nl li nm bi translated">UTS 命名空间</h2><p id="5c13" class="pw-post-body-paragraph lk ll ir lm b ln lo js lp lq lr jv ls lt lu lv lw lx ly lz ma mb mc md me mf ik bi translated">UTS 命名空间用于隔离系统中与<code class="fe nn no np nq b">uname</code>系统调用相关的两个特定元素。UTS(UNIX Time Sharing)名称空间是以用于存储由<code class="fe nn no np nq b">uname</code>系统调用返回的信息的数据结构命名的。</p><p id="aef8" class="pw-post-body-paragraph lk ll ir lm b ln mg js lp lq mh jv ls lt mi lv lw lx mj lz ma mb mk md me mf ik bi translated">具体来说，UTS 名称空间隔离了主机名和 NIS 域名。它使容器能够拥有自己的主机名，该主机名独立于主机系统和其上的其他容器。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj oa"><img src="../Images/7aae2f59d7b60f5079920b1212b73fe7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ymukjikwryNbIpmCxVphFg.png"/></div></div></figure><p id="ba0f" class="pw-post-body-paragraph lk ll ir lm b ln mg js lp lq mh jv ls lt mi lv lw lx mj lz ma mb mk md me mf ik bi translated"><strong class="lm is">演示</strong></p><p id="a1a0" class="pw-post-body-paragraph lk ll ir lm b ln mg js lp lq mh jv ls lt mi lv lw lx mj lz ma mb mk md me mf ik bi translated">创建 UTS 命名空间:</p><pre class="kh ki kj kk gu ns nq nt nu aw nv bi"><span id="44bd" class="nb kt ir nq b gz nw nx l ny nz">$ unshare --fork --mount --uts /bin/bash</span><span id="e55e" class="nb kt ir nq b gz ob nx l ny nz"># Re-associate socket to new namespace<br/>$ mount -t tmpfs tmpfs /run </span><span id="8c86" class="nb kt ir nq b gz ob nx l ny nz">$ hostnamectl set-hostname test.com<br/>Failed to create bus connection: No such file or directory<br/>$ hostanme<br/>cloud-dev.com<br/>$ hostname test.com<br/>$ hostname<br/>test.com</span></pre><p id="14c1" class="pw-post-body-paragraph lk ll ir lm b ln mg js lp lq mh jv ls lt mi lv lw lx mj lz ma mb mk md me mf ik bi translated">现在，如果您使用新终端登录服务器:</p><pre class="kh ki kj kk gu ns nq nt nu aw nv bi"><span id="0df6" class="nb kt ir nq b gz nw nx l ny nz">$ ssh cloud-dev<br/>$ hostname<br/>cloud-dev.com</span></pre><h2 id="8160" class="nb kt ir bd ku nc nd dn ky ne nf dp lc lt ng nh le lx ni nj lg mb nk nl li nm bi translated">PID 命名空间</h2><p id="065c" class="pw-post-body-paragraph lk ll ir lm b ln lo js lp lq lr jv ls lt lu lv lw lx ly lz ma mb mc md me mf ik bi translated">PID 名称空间隔离了进程 ID 号空间，这意味着不同 PID 名称空间中的<br/>进程可以具有相同的 PID。PID 名字空间允许容器提供诸如暂停/恢复容器中的一组进程以及将容器迁移到新主机的功能，同时容器内的进程保持相同的 PID。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj oc"><img src="../Images/421b1941758974975ab08dae4d1053e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DrUp7a0h8MCcdR8jBxdkSQ.png"/></div></div></figure><p id="5ef9" class="pw-post-body-paragraph lk ll ir lm b ln mg js lp lq mh jv ls lt mi lv lw lx mj lz ma mb mk md me mf ik bi translated"><strong class="lm is">演示</strong></p><p id="2deb" class="pw-post-body-paragraph lk ll ir lm b ln mg js lp lq mh jv ls lt mi lv lw lx mj lz ma mb mk md me mf ik bi translated">检查当前 PID</p><pre class="kh ki kj kk gu ns nq nt nu aw nv bi"><span id="6067" class="nb kt ir nq b gz nw nx l ny nz">$ echo $$<br/>28877</span></pre><p id="f9fb" class="pw-post-body-paragraph lk ll ir lm b ln mg js lp lq mh jv ls lt mi lv lw lx mj lz ma mb mk md me mf ik bi translated">如您所见，当前的<code class="fe nn no np nq b">Bash</code> shell 具有 PID 28877，让我们创建一个新的 PID 名称空间。</p><pre class="kh ki kj kk gu ns nq nt nu aw nv bi"><span id="53cc" class="nb kt ir nq b gz nw nx l ny nz">$ unshare --pid -f<br/>$ echo $$<br/>1<br/>$ lsns | grep pid<br/>4026531836 pid       110     1 root   /usr/lib/systemd/systemd --switched-root --system --deserialize 21<br/>4026532281 pid         3 29479 root   -bash</span></pre><h2 id="d026" class="nb kt ir bd ku nc nd dn ky ne nf dp lc lt ng nh le lx ni nj lg mb nk nl li nm bi translated">Net 命名空间</h2><p id="e41d" class="pw-post-body-paragraph lk ll ir lm b ln lo js lp lq lr jv ls lt lu lv lw lx ly lz ma mb mc md me mf ik bi translated">网络命名空间可以虚拟化网络栈，每个网络命名空间都有自己的资源，比如网络接口、IP 地址、路由表、隧道、防火墙等。例如，由<code class="fe nn no np nq b">iptables</code>添加到网络名称空间的规则将只影响进出该名称空间的流量。</p><p id="8ebc" class="pw-post-body-paragraph lk ll ir lm b ln mg js lp lq mh jv ls lt mi lv lw lx mj lz ma mb mk md me mf ik bi translated">每个容器都类似于一个虚拟机。它有自己的网卡、监听端口、TCP/IP 协议栈等。比如 Docker 运行时使用网络命名空间启动一个<code class="fe nn no np nq b">vethX</code>接口，这样你的容器就会有自己的桥 IP 地址，通常是<code class="fe nn no np nq b">docker0</code>，<code class="fe nn no np nq b">docker0</code>本质上是一个 Linux 虚拟网桥。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj od"><img src="../Images/841ea46533232dd7db06f3244b38d91b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_rpvBrgqkDBx85r0QAkfWw.png"/></div></div></figure><p id="5c11" class="pw-post-body-paragraph lk ll ir lm b ln mg js lp lq mh jv ls lt mi lv lw lx mj lz ma mb mk md me mf ik bi translated"><strong class="lm is">演示</strong></p><p id="db34" class="pw-post-body-paragraph lk ll ir lm b ln mg js lp lq mh jv ls lt mi lv lw lx mj lz ma mb mk md me mf ik bi translated">创建网络命名空间</p><pre class="kh ki kj kk gu ns nq nt nu aw nv bi"><span id="8e49" class="nb kt ir nq b gz nw nx l ny nz">unshare --net=/var/run/netns/testns</span></pre><p id="11bb" class="pw-post-body-paragraph lk ll ir lm b ln mg js lp lq mh jv ls lt mi lv lw lx mj lz ma mb mk md me mf ik bi translated">列出当前网络命名空间</p><pre class="kh ki kj kk gu ns nq nt nu aw nv bi"><span id="ed5e" class="nb kt ir nq b gz nw nx l ny nz">$ lsns | grep net<br/>4026532088 net       113     1 root   /usr/lib/systemd/systemd --switched-root --system --deserialize 21<br/>4026532282 net         3 30639 root   -bash</span><span id="9fa0" class="nb kt ir nq b gz ob nx l ny nz">$ ip netns<br/>testns</span></pre><p id="c234" class="pw-post-body-paragraph lk ll ir lm b ln mg js lp lq mh jv ls lt mi lv lw lx mj lz ma mb mk md me mf ik bi translated">检查新的名称空间接口</p><pre class="kh ki kj kk gu ns nq nt nu aw nv bi"><span id="0d1b" class="nb kt ir nq b gz nw nx l ny nz">$ ip netns exec testns ip addr<br/>1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000<br/>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span></pre><h2 id="1d54" class="nb kt ir bd ku nc nd dn ky ne nf dp lc lt ng nh le lx ni nj lg mb nk nl li nm bi translated">用户名称空间</h2><p id="252c" class="pw-post-body-paragraph lk ll ir lm b ln lo js lp lq lr jv ls lt lu lv lw lx ly lz ma mb mc md me mf ik bi translated">用户名称空间隔离与安全相关的标识符和属性，特别是用户 id 和组 id、根目录、键和功能。在用户名称空间内部和外部，进程的用户和组 id 可以不同。</p><p id="4516" class="pw-post-body-paragraph lk ll ir lm b ln mg js lp lq mh jv ls lt mi lv lw lx mj lz ma mb mk md me mf ik bi translated">特别是，一个进程可以在用户名称空间之外拥有一个普通的非特权用户 ID，同时在名称空间之内拥有一个用户 ID 0；换句话说，该进程对用户名称空间内的操作具有完全特权，但对名称空间外的操作没有特权。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj oe"><img src="../Images/5217dc106c7166024ca9855682c36cc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TjVA24AjxaLIQNjAJ-w19w.png"/></div></div></figure><p id="3991" class="pw-post-body-paragraph lk ll ir lm b ln mg js lp lq mh jv ls lt mi lv lw lx mj lz ma mb mk md me mf ik bi translated"><strong class="lm is">演示</strong></p><p id="38cf" class="pw-post-body-paragraph lk ll ir lm b ln mg js lp lq mh jv ls lt mi lv lw lx mj lz ma mb mk md me mf ik bi translated">检查当前用户名称空间</p><pre class="kh ki kj kk gu ns nq nt nu aw nv bi"><span id="7604" class="nb kt ir nq b gz nw nx l ny nz">$ lsns | grep user<br/>4026531837 user      116     1 root   /usr/lib/systemd/systemd --switched-root --system --deserialize 21</span></pre><p id="b3a9" class="pw-post-body-paragraph lk ll ir lm b ln mg js lp lq mh jv ls lt mi lv lw lx mj lz ma mb mk md me mf ik bi translated">创建一个新的用户命名空间并附加它</p><pre class="kh ki kj kk gu ns nq nt nu aw nv bi"><span id="50ae" class="nb kt ir nq b gz nw nx l ny nz">$ unshare --map-root-user --user --fork<br/>$ lsns | grep user<br/>4026531835 cgroup      4 30413 root unshare --map-root-user --user --fork<br/>4026531836 pid         4 30413 root unshare --map-root-user --user --fork<br/>4026531838 uts         4 30413 root unshare --map-root-user --user --fork<br/>4026531839 ipc         4 30413 root unshare --map-root-user --user --fork<br/>4026531840 mnt         4 30413 root unshare --map-root-user --user --fork<br/>4026532088 net         4 30413 root unshare --map-root-user --user --fork<br/>4026532281 user        4 30413 root unshare --map-root-user --user --fork</span></pre><p id="8a33" class="pw-post-body-paragraph lk ll ir lm b ln mg js lp lq mh jv ls lt mi lv lw lx mj lz ma mb mk md me mf ik bi translated">尝试以新 root 用户的身份更新主机名</p><pre class="kh ki kj kk gu ns nq nt nu aw nv bi"><span id="78ac" class="nb kt ir nq b gz nw nx l ny nz">$ id<br/>uid=0(root) gid=0(root) groups=0(root)<br/>$ hostname test.com<br/>hostname: you must be root to change the host name</span></pre><h2 id="b077" class="nb kt ir bd ku nc nd dn ky ne nf dp lc lt ng nh le lx ni nj lg mb nk nl li nm bi translated">Linux 控制组(Cgroups)</h2><p id="f9ce" class="pw-post-body-paragraph lk ll ir lm b ln lo js lp lq lr jv ls lt lu lv lw lx ly lz ma mb mc md me mf ik bi translated">在 Linux 中，<code class="fe nn no np nq b">Cgroups</code>是由 Linux 内核提供的特殊机制，它允许我们为一个进程或一组进程分配各种资源，如处理器时间、每组进程的数量、每控制组的内存量或这些资源的组合。</p><p id="c647" class="pw-post-body-paragraph lk ll ir lm b ln mg js lp lq mh jv ls lt mi lv lw lx mj lz ma mb mk md me mf ik bi translated">与流程类似，<code class="fe nn no np nq b">Cgroups</code>是分层组织的，子<code class="fe nn no np nq b">cgroups</code>从其父级继承一组特定的参数。<code class="fe nn no np nq b">cgroups</code>与正常流程的主要区别在于，许多不同层次的控制组可能同时存在，而正常流程树总是单一的。</p><p id="f620" class="pw-post-body-paragraph lk ll ir lm b ln mg js lp lq mh jv ls lt mi lv lw lx mj lz ma mb mk md me mf ik bi translated">在容器中，如果不对它施加任何资源限制，宿主将允许它占用无限量的内存空间。有时候程序会因为代码 bug 一直申请内存，直到主机内存被占用。</p><p id="113c" class="pw-post-body-paragraph lk ll ir lm b ln mg js lp lq mh jv ls lt mi lv lw lx mj lz ma mb mk md me mf ik bi translated">为了避免这样的问题，主机有必要限制容器的资源分配，如 CPU、内存等。<code class="fe nn no np nq b">Cgroups</code>主要功能是限制一个进程组可以使用的资源上限，包括 CPU、内存、磁盘、网络带宽等。此外，可以对进程进行优先级排序，并且可以执行暂停和恢复进程之类的操作。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj of"><img src="../Images/73791a68a0e1209a94303c7e9c801f68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PwFS-Qe8cBYETvLEF9oGTg.png"/></div></div><figcaption class="og oh gk gi gj oi oj bd b be z dk translated">图片来自<a class="ae ok" href="http://linuxacademy.com" rel="noopener ugc nofollow" target="_blank"> LinuxAcademy </a></figcaption></figure></div></div>    
</body>
</html>