<html>
<head>
<title>Call with Current Continuation as Recursive Return</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以当前连续作为递归返回的调用</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/call-with-current-continuation-as-recursive-return-ac58244c445?source=collection_archive---------11-----------------------#2022-03-07">https://blog.devgenius.io/call-with-current-continuation-as-recursive-return-ac58244c445?source=collection_archive---------11-----------------------#2022-03-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="ff34" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">在方案中使用 Call/CC 从递归定义早期“返回”</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi kc"><img src="../Images/3a2d565f9cd6317c1192fd0eee830749.png" data-original-src="https://miro.medium.com/v2/resize:fit:792/format:webp/1*KvExxPTUtVKEcVNUE2_zoQ.png"/></div></figure><h2 id="3fc2" class="kk kl in bd km kn ko dn kp kq kr dp ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">什么是延续</h2><p id="1fc6" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo kt lp lq lr kx ls lt lu lb lv lw lx ly ig bi translated">当一个函数调用另一个函数时，它会等待一个返回值来做一些事情。例如:表达式<code class="fe lz ma mb mc b">(+ 1 (f x))</code>，<code class="fe lz ma mb mc b">(+ 1 _)</code>是执行<code class="fe lz ma mb mc b">(f x)</code>的延续。继续就是要处理的事情和等待<code class="fe lz ma mb mc b">(f x)</code>返回值的事情。</p><h2 id="3e7f" class="kk kl in bd km kn ko dn kp kq kr dp ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">呼叫/抄送</h2><p id="5d5e" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo kt lp lq lr kx ls lt lu lb lv lw lx ly ig bi translated">call/cc 获取一个带有单个参数的 lambda 表达式，并将当前的延续传递给该函数作为其参数。</p><pre class="kd ke kf kg gt md mc me mf aw mg bi"><span id="2927" class="kk kl in mc b gy mh mi l mj mk">(+ 1 (call/cc <br/>       (lambda (cont)<br/>         (cont 5))))</span></pre><p id="4da1" class="pw-post-body-paragraph lg lh in li b lj ml jo ll lm mm jr lo kt mn lq lr kx mo lt lu lb mp lw lx ly ig bi translated">这段代码相当简单，但是我们可以看到当前的延续<code class="fe lz ma mb mc b">( + 1 _) </code>被传递给λ表达式作为<code class="fe lz ma mb mc b">cont</code>。</p><p id="1c93" class="pw-post-body-paragraph lg lh in li b lj ml jo ll lm mm jr lo kt mn lq lr kx mo lt lu lb mp lw lx ly ig bi translated"><code class="fe lz ma mb mc b">cont</code>本身就是一个 lambda 表达式，如果我们用一个参数调用它，它将把这个参数作为延续的参数，并执行延续。我们可以像从函数返回一样使用它。我们可以直接将一个值传递给函数的延续，而不是等待函数正常退出。</p><p id="55cb" class="pw-post-body-paragraph lg lh in li b lj ml jo ll lm mm jr lo kt mn lq lr kx mo lt lu lb mp lw lx ly ig bi translated">在上例中，我们只需将 5 传递给<code class="fe lz ma mb mc b">cont</code>。<code class="fe lz ma mb mc b">( + 1 5)</code>然后被执行，这个片段以值 6 退出。</p><p id="d39d" class="pw-post-body-paragraph lg lh in li b lj ml jo ll lm mm jr lo kt mn lq lr kx mo lt lu lb mp lw lx ly ig bi translated">让我们看看另外两个代码片段</p><pre class="kd ke kf kg gt md mc me mf aw mg bi"><span id="fea4" class="kk kl in mc b gy mh mi l mj mk">(+ 1 (call/cc <br/>       (lambda (cont)<br/>         (+ 3 3))))</span></pre><p id="c3e9" class="pw-post-body-paragraph lg lh in li b lj ml jo ll lm mm jr lo kt mn lq lr kx mo lt lu lb mp lw lx ly ig bi translated">和</p><pre class="kd ke kf kg gt md mc me mf aw mg bi"><span id="83c3" class="kk kl in mc b gy mh mi l mj mk">(+ 1 (call/cc <br/>       (lambda (cont)<br/>         (cont 5)<br/>         (+ 3 3))))</span></pre><p id="cdfa" class="pw-post-body-paragraph lg lh in li b lj ml jo ll lm mm jr lo kt mn lq lr kx mo lt lu lb mp lw lx ly ig bi translated">第一个代码片段简单地以值 7 退出，不做任何延续。然而，当执行<code class="fe lz ma mb mc b">cont 5</code>时，第二个直接传递 5 到λ的延续。因此，这个 lambda 将永远不会实际执行<code class="fe lz ma mb mc b">(+ 3 3)</code>，并且代码片段将以值 6 退出。在这种情况下，<code class="fe lz ma mb mc b">cont 5</code>类似于另一种语言中的<code class="fe lz ma mb mc b"><strong class="li io">return</strong> 5</code>。我们已经很早就有效地从功能中恢复了。</p><p id="bf01" class="pw-post-body-paragraph lg lh in li b lj ml jo ll lm mm jr lo kt mn lq lr kx mo lt lu lb mp lw lx ly ig bi translated">延续有多种用途，但一个有趣的用途是递归函数的早期返回。</p><h2 id="bb6a" class="kk kl in bd km kn ko dn kp kq kr dp ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">列表乘法元素的应用</h2><p id="bafc" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo kt lp lq lr kx ls lt lu lb lv lw lx ly ig bi translated">首先定义一个函数<code class="fe lz ma mb mc b">multListNoCC</code>，该函数获取一个数字列表，并将它们递归相乘。</p><pre class="kd ke kf kg gt md mc me mf aw mg bi"><span id="4fbd" class="kk kl in mc b gy mh mi l mj mk">(define multListNoCC <br/>  (lambda (lat)<br/>    (cond<br/>      ((null? lat) 1)<br/>      (#t (* (car lat) (multListNoCC (cdr lat)))))))</span></pre><p id="ce97" class="pw-post-body-paragraph lg lh in li b lj ml jo ll lm mm jr lo kt mn lq lr kx mo lt lu lb mp lw lx ly ig bi translated">然而，这个算法可以变得更有效。如果列表中的任何元素是零，我们知道最终的乘积必须是零。因此，我们可以停止乘以元素，只返回零作为乘积，而不是继续遍历列表。然而，如果我们在函数中添加一个 case 来返回零，那么零将会被传递回递归堆栈。我们可以使用 call/cc 来“弹出”所有的递归调用，并向原始调用方返回 0。例如:</p><pre class="kd ke kf kg gt md mc me mf aw mg bi"><span id="db8a" class="kk kl in mc b gy mh mi l mj mk">(define multList <br/>  (lambda (lat)<br/>    (call/cc (lambda (cont)<br/>      (letrec ((helper (lambda (x)<br/>        (cond<br/>          ((null? x) 1)<br/>          ((eq? (car x) 0) (cont 0))<br/>          (#t (* (car x) (helper (cdr x))))))))<br/>        (helper lat))))))</span></pre><p id="5039" class="pw-post-body-paragraph lg lh in li b lj ml jo ll lm mm jr lo kt mn lq lr kx mo lt lu lb mp lw lx ly ig bi translated">在<code class="fe lz ma mb mc b">multList</code>功能中，<code class="fe lz ma mb mc b">helper</code>与<code class="fe lz ma mb mc b">multListNoCC</code>几乎完全相同。我们将 helper 封装在几个 lambdas 中，让它能够访问调用该函数的原始 CC 以及我们想要相乘的列表。然后，我们可以向 helper 添加另一个条件:当当前元素等于零时，立即停止递归，并向原始延续传递一个零。即:<code class="fe lz ma mb mc b">((eq? (car x) 0) (cont 0))</code> <br/> <code class="fe lz ma mb mc b">cont</code>是递归开始前的 CC——最初的调用者，因此向<code class="fe lz ma mb mc b">cont</code>传递一个值实际上停止了递归并直接返回一个值。</p><p id="c0f8" class="pw-post-body-paragraph lg lh in li b lj ml jo ll lm mm jr lo kt mn lq lr kx mo lt lu lb mp lw lx ly ig bi translated">如果从未遇到零，函数将通过沿递归堆栈向上传递值来正常返回。</p><h2 id="14a0" class="kk kl in bd km kn ko dn kp kq kr dp ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">更多示例和应用</h2><pre class="kd ke kf kg gt md mc me mf aw mg bi"><span id="aebf" class="kk kl in mc b gy mh mi l mj mk">(define isNumInList<br/>  (lambda (lat num)<br/>    (call/cc (lambda (cont)<br/>      (letrec ((helper (lambda (l n)<br/>        (cond<br/>          ((null? l) #f)<br/>          ((eq? (car l) n) (cont #t))<br/>          (#t (helper (cdr l) n ))))))<br/>        (helper lat num))))))</span></pre><p id="71e9" class="pw-post-body-paragraph lg lh in li b lj ml jo ll lm mm jr lo kt mn lq lr kx mo lt lu lb mp lw lx ly ig bi translated">如果我们已经找到了数字的一个实例，就没有必要继续遍历了。<br/>如果我们一直到列表的末尾，还没有找到元素，那么一直向上传递一个#f，表示我们还没有找到这个数字。</p><pre class="kd ke kf kg gt md mc me mf aw mg bi"><span id="68a8" class="kk kl in mc b gy mh mi l mj mk">(define findFirstNumInList<br/>  (lambda (lat num)<br/>    (call/cc (lambda (cont)<br/>      (letrec ((helper (lambda (l n index)<br/>        (cond<br/>          ((null? l) -1)<br/>          ((eq? (car l) n) (cont index))<br/>          (#t (helper (cdr l) n (+ index 1)))))))<br/>          (helper lat num 0))))))</span></pre><p id="c941" class="pw-post-body-paragraph lg lh in li b lj ml jo ll lm mm jr lo kt mn lq lr kx mo lt lu lb mp lw lx ly ig bi translated">很像 isNumInList，但是返回找到的元素的索引(如果元素不在列表中，则返回-1。</p></div><div class="ab cl mq mr hr ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ig ih ii ij ik"><h2 id="4de6" class="kk kl in bd km kn ko dn kp kq kr dp ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">关于作者</h2><p id="983f" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo kt lp lq lr kx ls lt lu lb lv lw lx ly ig bi translated">Eric Breyer 是莱斯大学的计算机科学本科生。你可以在他的<a class="ae mx" href="http://www.ericbreyer.com/" rel="noopener ugc nofollow" target="_blank">网站</a>，以及<a class="ae mx" href="https://github.com/ericbreyer" rel="noopener ugc nofollow" target="_blank"> GitHub </a>和<a class="ae mx" href="https://www.linkedin.com/in/eric-breyer/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上找到他。</p></div></div>    
</body>
</html>