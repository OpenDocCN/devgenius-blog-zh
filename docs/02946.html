<html>
<head>
<title>Flood Fill Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">洪水填充算法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/flood-fill-algorithm-f73817d6a707?source=collection_archive---------10-----------------------#2020-09-14">https://blog.devgenius.io/flood-fill-algorithm-f73817d6a707?source=collection_archive---------10-----------------------#2020-09-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="02be" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Hello medium，</p><p id="acdb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">今天我要讨论一个非常精彩的算法“<strong class="jm io">洪水填充算法</strong>”。它也被称为“<strong class="jm io">种子填充</strong>”。给我们一个2D屏幕<strong class="jm io">数组[][] </strong>，其中每个<strong class="jm io">数组[i][j] </strong>代表给定屏幕像素的颜色，现在给我们任意像素<strong class="jm io"> (X，Y) </strong>的位置和一个颜色<strong class="jm io"> K </strong>，要求我们用给定颜色<strong class="jm io"> K </strong>替换给定像素的颜色以及与给定像素相邻的所有具有相同颜色的像素的颜色。</p><p id="db1e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于ex:</p><p id="1b94" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们有一个5 * 5大小的数组，代表一个像素屏幕</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/1ba7865548e435b2f540d23428970a90.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/1*ZMnm52i9c83QsVSjqLWcpw.png"/></div></figure><p id="39d5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从0开始索引，在替换像素(2，2)及其所有相邻像素后，我们得到x=2，y=2和k=5</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi kq"><img src="../Images/32a6d2b97135d30b4b4d2f7747563af4.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*hh8C_0RKSNqtG2_vANrzJw.png"/></div></figure><p id="3a1d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">如何接近</strong>:</p><p id="d42b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以使用广度优先搜索。首先，我们将替换给定像素的颜色，然后我们将递归地转到它的所有相邻像素，并检查它是否具有相同的颜色，如果它与目标像素具有相同的颜色，那么我们将用新的颜色替换它，并再次调用它的所有相邻像素。</p><p id="1200" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">代码:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi kr"><img src="../Images/acae4d311b78acfd072cb759aa799d76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kXVsBHFnlaxkMWaJZjeJtQ.png"/></div></div></figure><p id="93eb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里，由于我们无法找到索引<strong class="jm io">小于</strong> <strong class="jm io">零或大于等于n的像素(因为它不存在)</strong>，所以我们的最佳情况是i==0||j==0||i==n-1||j==n-1</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi kw"><img src="../Images/87784bd3c19a85f6497b05304879cbae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*ffgghc64Dt6707TvejqTBg.png"/></div></figure><p id="3186" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后输出上述例子…..</p><p id="a10e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">谢谢你…</p></div></div>    
</body>
</html>