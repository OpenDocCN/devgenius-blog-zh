<html>
<head>
<title>Make Your WSL Environment Programmable</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让您的WSL环境可编程</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/make-your-wsl-environment-programmable-72be5907d1ff?source=collection_archive---------1-----------------------#2021-07-10">https://blog.devgenius.io/make-your-wsl-environment-programmable-72be5907d1ff?source=collection_archive---------1-----------------------#2021-07-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/81fd09bc07c9a8df6bc69327f8b6979e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lBTs7IGlx6R40IVc"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">在<a class="ae jz" href="https://unsplash.com/s/photos/penguin?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae jz" href="https://unsplash.com/@goosegrease?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Derek Oyen </a>拍照</figcaption></figure><p id="c8c5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi ky translated"><span class="l kz la lb bm lc ld le lf lg di">我</span>自从WSL架构首次亮相就被它迷住了。它拥有优雅漂亮的架构，可以实现Windows和Linux世界之间的互操作性。最后，我深入研究了WSL Win32 APIs、它的注册表模型和内部模型。</p><p id="4833" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是只有少量WSL API文档和示例。后来，我意识到微软并不打算将WSL API用于一般用途，而是WSL发行版开发者。此外，被称为WSL.exe和发行版启动器的CLI工具正在移动部件(因为每个Windows 10主要版本都有不同的功能和命令行选项)。所以这些情况使得WSL环境很难自动化。</p><p id="e8a9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">经过多次试验和错误，我开发了一个小而有效的自动化工具，叫做WSL SDK。这个工具是一个进程外风格的COM服务器，所以你可以用任何COM支持的语言访问SDK。</p><p id="c04c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本文中，我想分享WSL SDK的演练，以克服使用官方Win32 WSL APIs的困难。</p><h1 id="f9c9" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">WSL的隐藏宝藏</h1><p id="1200" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">如果您对WSL APIs感兴趣，您可能会得到关于该API的提示。例如，API WslLaunch返回一个HRESULT代码。一个与WSL相关的COM接口在其内部组成中称为LxssUserSession，这个API包装了COM对象。</p><p id="af27" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">可悲的是，内部的COM对象完全被微软隐藏了，看起来这是故意的。我想这个方向是有合理的决定的。但是，它的内部COM对象也没有很好的文档。</p><h1 id="d96f" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">WSL APIs不友好</h1><p id="c741" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">正因为如此，WSL APIs有一些众所周知的设计行为。如果您通过PowerShell、LINQPad或任何支持COM的环境使用P/Invoke调用WSL API，您将无法访问任何WSL API。许多爱好者尝试了API，但没有运气。</p><p id="96cc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是为什么呢？我提到的那些环境已经通过另一个CoInitializeSecurity调用启动了。遗憾的是，WSL APIs需要一个特定的初始化参数。并且CoInitializeSecurity在某处被调用；您再也不能调用CoInitializeSecurity。为了克服这个问题，不可避免地，我应该选择进程外模型。</p><h1 id="9f1b" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">挖掘旧样本</h1><p id="e841" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">然而，进程外模型使得使用API的步骤很繁琐。您应该检查该进程是否存在。您必须定义如何与外部进程(如管道、内部网络或任何封送协议)进行通信。此外，这种方法很难扩展和维护API调用和功能。</p><p id="385a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我在这一点上坚持了很长时间。但是，多亏了微软开发的名为All-In-One Code Framework的老项目，我找到了一个漂亮的解决方案。是的。进程外COM服务器模型！所以我修改了示例进程外COM服务器代码，它工作起来非常棒。</p><h1 id="be2b" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">在后台</h1><p id="b55c" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">当客户端应用程序通过COM API请求WSL SDK服务对象时，Windows会自动启动可执行文件以获取适当的对象引用。然后，用代理接口包装它，客户端应用程序检索该引用。为了更好的理解，请看下图。</p><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/aff6e1d603c826691937e5cd3c62454a.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/0*zMosfXzRbQ1NWN7g.jpg"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">摘自<a class="ae jz" href="http://docwiki.embarcadero.com/RADStudio/Sydney/en/In-process,_Out-of-process,_and_Remote_Servers" rel="noopener ugc nofollow" target="_blank">http://doc wiki . embarcadero . com/RADStudio/Sydney/en/In-process、_Out-of-process、_and_Remote_Servers </a></figcaption></figure><p id="132c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">WSL SDK可执行文件调用带有正确参数的CoInitializeAPI来与WSL APIs通信。然后启动一个消息泵来处理外部RPC请求和任何与Windows GUI相关的请求。当请求对象引用时，其引用计数将增加或减少。然后计数达到零；可执行进程将关闭。再次，另一个请求到达，相同的回合将再次发生，直到从注册表中注销COM信息。</p><p id="9ecf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以WSL SDK将COM安全模型从应用程序的安全模型和WSL的需求中分离出来。以及由操作系统的基础结构和引用计数机制处理的进程生命周期管理。每个WSL SDK客户端都不需要关心任何细节。他们像往常一样请求WSL SDK接口，一切进展顺利。</p><h1 id="b406" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">将直接P/Invoke与WSL API进行比较并使用WSL SDK</h1><p id="90bf" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">我将展示一个简单的演示。</p><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mp"><img src="../Images/9172888d27038cc92aa3d8e00c5279cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t1eZkrzaT_xOpkN0eO7EIA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">将直接P/Invoke与WSL API进行比较并使用WSL SDK</figcaption></figure><p id="c67b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">PowerShell示例代码如下所示。我摘录了GitHub问题【github.com】WSL API在PowerShell问题#4058中不起作用的示例代码微软/WSL(T3)。</p><pre class="ml mm mn mo gt mq mr ms mt aw mu bi"><span id="585f" class="mv li in mr b gy mw mx l my mz"># Excerpted from <a class="ae jz" href="https://github.com/microsoft/WSL/issues/4058" rel="noopener ugc nofollow" target="_blank">https://github.com/microsoft/WSL/issues/4058</a><br/>Write-Host 'Calling WslIsDistributionRegistered directrly (Ubuntu-20.04):'<br/>Add-Type -TypeDefinition @'<br/>using System.Runtime.InteropServices;</span><span id="5708" class="mv li in mr b gy na mx l my mz">public class wslutil<br/>{<br/> [DllImport("wslapi.dll", CharSet = CharSet.Unicode)]<br/> public static extern uint WslIsDistributionRegistered([In, MarshalAs(UnmanagedType.LPWStr)] string distributionName);</span><span id="48f3" class="mv li in mr b gy na mx l my mz">public static void Main(string[] args)<br/> {<br/>  System.Console.WriteLine(WslIsDistributionRegistered("Ubuntu-20.04"));<br/> }<br/>}<br/>'@<br/>[wslutil]::Main({})<br/>Write-Host</span></pre><p id="84ef" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">PowerShell代码引用了WSLAPI.dll的C-function。从表面上看，这是有道理的，而且应该很有效。但是代码返回零，不反映当前状态。</p><p id="a845" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是，WSL SDK会返回正确的值。</p><pre class="ml mm mn mo gt mq mr ms mt aw mu bi"><span id="ee29" class="mv li in mr b gy mw mx l my mz">Write-Host 'Calling WSL SDK API (Ubuntu-20.04):'<br/>$DistroName = 'Ubuntu-20.04'<br/>$obj = New-Object -ComObject 'WslSdk.WslService'<br/>$Result = $obj.IsDistroRegistered($DistroName)<br/>Write-Host "$Result"<br/>Write-Host</span></pre><p id="91b7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">本质上，这两个代码都依赖于WslIsDistributionRegistered函数，但是PowerShell已经调用了CoInitializeSecurity，这不符合WSL APIs的要求。因此，第一个示例不适用。</p><h1 id="5fbe" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">演示:沙盒WSL发行版</h1><p id="0cef" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">我将展示另一个更复杂的示例脚本。下面的代码将自动从官方镜像下载Alpine Linux根文件系统映像。然后，将VI改进的编辑器添加到发行版中。</p><pre class="ml mm mn mo gt mq mr ms mt aw mu bi"><span id="5bbe" class="mv li in mr b gy mw mx l my mz">$ErrorActionPreference = "Stop"<br/>$obj = New-Object -ComObject 'WslSdk.WslService'<br/>Write-Output 'A WslSdk.WslService object is created.'<br/>Pause</span><span id="1a54" class="mv li in mr b gy na mx l my mz"># Get installed distro list<br/>Write-Output 'Currently installed WSL distro list: '<br/>$list = $obj.GetDistroList()<br/>Write-Output $list<br/>Pause</span><span id="b49b" class="mv li in mr b gy na mx l my mz"># Generate Random Name<br/>$RandomName = $obj.GenerateRandomName($false)<br/>Write-Output "We will use $RandomName as a new distro"</span><span id="be37" class="mv li in mr b gy na mx l my mz"># Download Alpine Linux RootFS Image<br/>Write-Output 'Downloading alpine linux root file system image'<br/>$TargetUrl = '<a class="ae jz" href="https://dl-cdn.alpinelinux.org/alpine/v3.14/releases/x86_64/alpine-minirootfs-3.14.0-x86_64.tar.gz'" rel="noopener ugc nofollow" target="_blank">https://dl-cdn.alpinelinux.org/alpine/v3.14/releases/x86_64/alpine-minirootfs-3.14.0-x86_64.tar.gz'</a><br/>$RootfsFilePath = "$env:TEMP\alpine.tar.gz"<br/>$InstallPath = "C:\Distro\$RandomName"<br/>Invoke-WebRequest -UseBasicParsing -Uri $TargetUrl -OutFile $RootfsFilePath<br/>Pause</span><span id="d3ed" class="mv li in mr b gy na mx l my mz"># Register Distro<br/>Write-Output "Distro installation begins"<br/>Write-Output " - Distro Name: $RandomName"<br/>Write-Output " - Source RootFS File Path: $RootfsFilePath"<br/>Write-Output " - Destination Install Path: $InstallPath"<br/>$obj.RegisterDistro($RandomName, $RootfsFilePath, $InstallPath)<br/>Pause</span><span id="4e6d" class="mv li in mr b gy na mx l my mz"># Distro Register Check<br/>$Result = $obj.IsDistroRegistered($RandomName)<br/>Write-Output "Distro Name $RandomName Installed: $Result"<br/>Pause</span><span id="7b2d" class="mv li in mr b gy na mx l my mz"># Metadata Query<br/>Write-Output "Querying $RandomName metadata..."<br/>$o = $obj.QueryDistroInfo($RandomName)<br/>Write-Output " - Distro ID: $($o.DistroId())"<br/>Write-Output " - Distro Name: $($o.DistroName())"<br/>Write-Output " - Environment Variabls: $($o.DefaultEnvironmentVariables())"<br/>Write-Output " - Default Uid: $($o.DefaultUid())"<br/>Write-Output " - Flags: $($o.DistroFlags())"<br/>Write-Output " - Win32 Interop Enabled: $($o.EnableInterop())"<br/>Write-Output " - Drive Mounting Enabled: $($o.EnableDriveMounting())"<br/>Write-Output " - NT Path Append Enabled: $($o.AppendNtPath())"<br/>Write-Output " - WSL Version: $($o.WslVersion())"<br/>Pause</span><span id="b795" class="mv li in mr b gy na mx l my mz"># Run WSL command<br/>Write-Output "Installing vim..."<br/>$res = $obj.RunWslCommand($o.DistroName(), "apk add vim")<br/>Write-Output $res<br/>Pause</span><span id="490e" class="mv li in mr b gy na mx l my mz"># Revealing launcher executable<br/>Write-Output "Revealing launcher executable file"<br/>Start-Process -FilePath "$env:windir\explorer.exe" -ArgumentList "/select,$InstallPath\$RandomName.exe"<br/>Pause</span><span id="816c" class="mv li in mr b gy na mx l my mz"># Unregister Distro<br/>Write-Output "Unregister $RandomName distro..."<br/>$obj.UnregisterDistro($RandomName)<br/>Pause</span><span id="2824" class="mv li in mr b gy na mx l my mz"># Get installed distro list<br/>Write-Output 'Currently installed WSL distro list: '<br/>$list = $obj.GetDistroList()<br/>Write-Output $list<br/>Pause</span><span id="d918" class="mv li in mr b gy na mx l my mz">$obj = $null</span></pre><p id="c2d2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它是一个基本的根文件系统映像，不是为WSL设计的。正如您已经知道的，WSL支持导入任何符合处理器体系结构的Linux根文件系统映像。</p><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nb"><img src="../Images/14148294e9169c65775889286b45ffb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*53G-b0VoIRXnDs41O69YyQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">沙盒WSL发行版</figcaption></figure><p id="379d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">WSL SDK甚至可以在PowerShell环境中处理动态分发注册和操作。</p><p id="be8e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">只是为了好玩，即使在Microsoft Excel中，也可以与WSL环境进行交互。</p><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nc"><img src="../Images/5b15a5cdfff1a4c2d9ee44bb34c7f2eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eugEdfKTda7glDC56L1OEw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">使用VBA通过Excel运行WSL SDK</figcaption></figure><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nb"><img src="../Images/ba47461e5ec21255c9c62193a802342c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lfkVTrHGXLIgElDM7neo2A.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">在Microsoft VB for Applications中实现WSL自动化</figcaption></figure><p id="44ca" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可以在这里访问WSL SDKs的各种示例代码:<a class="ae jz" href="https://github.com/wslhub/wsl-sdk-com/tree/main/sample." rel="noopener ugc nofollow" target="_blank">https://github.com/wslhub/wsl-sdk-com/tree/main/sample.</a></p><h1 id="317e" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">未来路线图</h1><p id="0cdb" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">由于https://github.com/marketplace/actions/setup-wsl插件和GitHub团队决定在他们的Windows服务器工作负载中启用WSL组件，我最近创建了一个GitHub动作管道。</p><p id="5a37" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正因为如此，我可以为WSL SDK创建一个持续的集成，这使得发布更有信心。(https://github . com/WSL hub/WSL-SDK-com/actions/workflows/WSL-SDK-com-build . yml)这项工作是WSL SDK路线图的一项重大成就。</p><p id="01aa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此外，我的遗愿清单包含了这些目标。</p><ul class=""><li id="6a70" class="nd ne in kc b kd ke kh ki kl nf kp ng kt nh kx ni nj nk nl bi translated">免注册COM服务器(如果可能)</li><li id="d5c3" class="nd ne in kc b kd nm kh nn kl no kp np kt nq kx ni nj nk nl bi translated">ARM64原生支持</li><li id="69b3" class="nd ne in kc b kd nm kh nn kl no kp np kt nq kx ni nj nk nl bi translated">在我以前的另一个项目中采用WSL SDK(WSL Manager)</li><li id="0da7" class="nd ne in kc b kd nm kh nn kl no kp np kt nq kx ni nj nk nl bi translated">各种语言包装器(C#、Python、Go-lang、PowerShell或任何COM支持的语言)</li></ul><p id="4ec0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你对WSL SDK项目感兴趣，请过来为GitHub repo做贡献。(【https://github.com/wslhub/wsl-sdk-com】T4)</p></div></div>    
</body>
</html>