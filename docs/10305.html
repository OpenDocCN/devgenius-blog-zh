<html>
<head>
<title>How Will Amber Revamp Records for Better Usage</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">琥珀将如何修复记录以更好地使用</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-will-amber-revamp-records-for-better-usage-ef1ded930b85?source=collection_archive---------7-----------------------#2022-10-22">https://blog.devgenius.io/how-will-amber-revamp-records-for-better-usage-ef1ded930b85?source=collection_archive---------7-----------------------#2022-10-22</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="19bc" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">5 Java 记录更改，这将使您的开发更容易</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/a793823ae4962f53cb13463b09d41bbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bsbIPAfy-BrJBUZMHveZnw.png"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated">照片由来自<a class="ae kw" href="https://www.pexels.com/photo/man-person-people-woman-6914058/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">佩克斯</a>的<a class="ae kw" href="https://www.pexels.com/@tima-miroshnichenko?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">马体·米罗什尼琴科</a>拍摄</figcaption></figure><p id="3d90" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><strong class="kz is"> <em class="lt">爪哇的记录将来会改变。为了更好。</em> </strong></p><p id="a83a" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">如果你跟上了这些变化，你会得到很多好处。更快的重构、简洁的代码和更好的性能。</p><p id="7b6c" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">原始类型<a class="ae kw" href="https://www.youtube.com/watch?v=1H4vmT-Va4o&amp;t=915s&amp;ab_channel=Java" rel="noopener ugc nofollow" target="_blank">会带来布局优化、编译器优化等等</a>。如果我们能把这些和记录结合起来，那将会发生什么是显而易见的。</p><p id="51e6" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><strong class="kz is"> <em class="lt">哪 5 个记录变化会让你的代码更好？</em>T13】</strong></p><h1 id="8310" class="lu lv ir bd lw lx ly lz ma mb mc md me jx mf jy mg ka mh kb mi kd mj ke mk ml bi translated">1.你能在 API 中使用记录吗？</h1><p id="dab2" class="pw-post-body-paragraph kx ky ir kz b la mm js lc ld mn jv lf lg mo li lj lk mp lm ln lo mq lq lr ls ik bi translated"><strong class="kz is"> <em class="lt">你可以使用记录作为 API 的有效载荷。</em> </strong>这很好，直到<a class="ae kw" href="https://mail.openjdk.org/pipermail/amber-dev/2022-June/007373.html" rel="noopener ugc nofollow" target="_blank">你放弃某些字段</a>。</p><p id="c154" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">您可以弃用该字段，但要确保有一个向后兼容的构造函数。在未来，也需要解构者。</p><p id="4539" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">即使这样，源代码和二进制代码的兼容性也将得到满足。</p><p id="eee6" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><strong class="kz is"> <em class="lt">那么你需要使用类型模式和访问器来确保兼容性吗？或者一个记录模式就足够了？</em> </strong></p><p id="8672" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">只要我们小心使用构造函数和解构函数，这应该是可行的。</p><p id="98bb" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">例如，如果我们有以下内容。</p><pre class="kh ki kj kk gu mr ms mt mu aw mv bi"><span id="f727" class="mw lv ir ms b gz mx my l mz na">record Point(int x, int y, int z) {}<br/>// new version removes the z<br/>record Point(int x, int y) {<br/>    @Deprecated<br/>    Point(int x, int y, int z) { this(x,y); } //ignore the Z<br/>}</span></pre><p id="74c4" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">下面的每一个都有一个解构器。意思是如果我们想忽略 z，我们可以忽略它。</p><pre class="kh ki kj kk gu mr ms mt mu aw mv bi"><span id="66d2" class="mw lv ir ms b gz mx my l mz na">if(o instanceof Point(int x, int y, int z)) {// z will be 0 if this is new deconstructor}</span></pre><h1 id="a236" class="lu lv ir bd lw lx ly lz ma mb mc md me jx mf jy mg ka mh kb mi kd mj ke mk ml bi translated">2.您不会在注释中使用记录</h1><p id="391a" class="pw-post-body-paragraph kx ky ir kz b la mm js lc ld mn jv lf lg mo li lj lk mp lm ln lo mq lq lr ls ik bi translated">注释只允许在声明中包含常量。并且记录在注释中不可用。</p><p id="f328" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><strong class="kz is"> <em class="lt">反之亦然记录上的注释即使在今天也是可能的。</em> </strong></p><p id="bae0" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">现在就可以添加<a class="ae kw" href="https://github.com/projectlombok/lombok/issues/2356" rel="noopener ugc nofollow" target="_blank"> @Builder </a>为例。不过，如果我们在记录中得到萎顿，这就没有必要了。</p><h1 id="3a8f" class="lu lv ir bd lw lx ly lz ma mb mc md me jx mf jy mg ka mh kb mi kd mj ke mk ml bi translated">3.你需要原始记录吗？</h1><p id="00eb" class="pw-post-body-paragraph kx ky ir kz b la mm js lc ld mn jv lf lg mo li lj lk mp lm ln lo mq lq lr ls ik bi translated">记录是身份类。但是也有创造原始记录的可能性。那么这些记录是否有匹配的模式呢？</p><p id="7e9b" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><strong class="kz is"> <em class="lt">对于当前记录，将内置解构。对于其他特定的记录，比如原始记录，您需要定义显式的解构器。</em> </strong></p><p id="a0d9" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我们可以将这与任意的类进行比较。这意味着这些新定义的(原始)记录模仿任意的类。</p></div><div class="ab cl nb nc hv nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ik il im in io"><p id="5858" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><strong class="kz is"> <em class="lt">了解原始物体有什么重要的？</em> </strong></p><p id="5e6e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><strong class="kz is"> <em class="lt">原始物体被剥夺了身份。</em> </strong>这种特质使我们能够在记忆中展平物体。</p><p id="91ca" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">当我们剥离身份时，我们可以按需解构和构建对象。<strong class="kz is"> <em class="lt">当被这样询问时，对象表现得像一个对象。</em> </strong>在幕后，我们将这些存储为原语。</p><p id="7e18" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">因为没有身份，我们可以构造和解构物体。这些将是新的值相等的原语。他们没有任何身份。</p></div><div class="ab cl nb nc hv nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ik il im in io"><h1 id="76d2" class="lu lv ir bd lw lx ni lz ma mb nj md me jx nk jy mg ka nl kb mi kd nm ke mk ml bi translated">4.详尽无遗将使你的记录易于维护</h1><p id="2672" class="pw-post-body-paragraph kx ky ir kz b la mm js lc ld mn jv lf lg mo li lj lk mp lm ln lo mq lq lr ls ik bi translated">随着记录的改变，所有相关的方法也会改变。将这与密封类型结合起来，你在重构方面会快很多。</p><p id="0781" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">如果你添加了一个新的允许类型，就需要更新所有的开关表达式。这实现了更快的重构和类型安全。</p><p id="c845" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">让我们回顾一下你能做什么和不能做什么。</p></div><div class="ab cl nb nc hv nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ik il im in io"><p id="d7c4" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><strong class="kz is"> <em class="lt">你现在哪里得不到穷尽？</em> </strong></p><p id="8ff8" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><a class="ae kw" href="https://stackoverflow.com/questions/73787918/java-19-compiler-issues-when-trying-record-patterns-in-switch-expressions" rel="noopener ugc nofollow" target="_blank">混合枚举和记录，并期望穷尽工作。由于枚举没有解构，你会遇到编译问题。</a></p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nn no l"/></div></figure><p id="540b" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这里 enum 和 record 都实现了接口<code class="fe np nq nr ms b">Opt</code>。在这种情况下穷尽是行不通的。即便如此，这一场景的详尽性在未来很可能还会存在。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nn no l"/></div></figure><p id="3541" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">如果我们定义了以下接口，这将会起作用:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nn no l"/></div></figure><p id="c9d2" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">然而，如果我们添加枚举，它将失败，因为解构无法对枚举起作用。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nn no l"/></div></figure><p id="b05a" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">上面的错误意味着你想要解构一个任意的类。在这种情况下，是一个枚举，但也可以是您的自定义类。</p></div><div class="ab cl nb nc hv nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ik il im in io"><p id="050e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">您还可以将开关与记录及其类似元组的特性结合起来，以获得简洁的代码。</p><p id="175e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">您可以更改此代码:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nn no l"/></div></figure><p id="6f1f" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">到这段代码中:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nn no l"/></div></figure></div><div class="ab cl nb nc hv nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ik il im in io"><h1 id="e228" class="lu lv ir bd lw lx ni lz ma mb nj md me jx nk jy mg ka nl kb mi kd nm ke mk ml bi translated">5.威瑟斯会移除建筑者</h1><p id="bb3a" class="pw-post-body-paragraph kx ky ir kz b la mm js lc ld mn jv lf lg mo li lj lk mp lm ln lo mq lq lr ls ik bi translated">之前我们提到过<code class="fe np nq nr ms b">@Builder</code>。您可以添加这个并获取记录的构建器。</p><p id="81e6" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><em class="lt">建造者解决大建造者的问题。</em>大型构造函数的问题应该由 Java 来解决，而不是第三方。<a class="ae kw" href="https://mail.openjdk.org/pipermail/amber-spec-experts/2022-June/003461.html" rel="noopener ugc nofollow" target="_blank">威瑟斯</a>以后解决大施工员的麻烦。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nn no l"/></div></figure><p id="a1af" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我们会得到一个设置了 x 值的记录。否则，我们需要记录中的 setters。</p></div><div class="ab cl nb nc hv nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ik il im in io"><p id="0630" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">此外，威瑟斯应该删除建设者。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nn no l"/></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated"><a class="ae kw" href="https://mail.openjdk.org/pipermail/amber-spec-experts/2022-June/003461.html" rel="noopener ugc nofollow" target="_blank">信号源</a></figcaption></figure><p id="0213" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">如果需要，您可以根据其他字段计算某些字段。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nn no l"/></div></figure><p id="bb12" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这是目前的方法:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nn no l"/></div></figure><p id="21e2" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我们不再需要为每个自定义构造函数调用规范构造函数。</p></div><div class="ab cl nb nc hv nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ik il im in io"><h1 id="995b" class="lu lv ir bd lw lx ni lz ma mb nj md me jx nk jy mg ka nl kb mi kd nm ke mk ml bi translated">这些改进将全面改进我们的工作</h1><p id="abfc" class="pw-post-body-paragraph kx ky ir kz b la mm js lc ld mn jv lf lg mo li lj lk mp lm ln lo mq lq lr ls ik bi translated">琥珀项目还能实现什么？他们会试着把一些好的东西移到任意的类中。</p><p id="4ba0" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><strong class="kz is"> <em class="lt">未来的一个特点将是对任意类的解构</em> </strong>。解构现在只适用于唱片。</p><p id="d5d1" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">尝试解构枚举时的当前错误如下。未来任意的阶级解构应该也是有的。</p><pre class="kh ki kj kk gu mr ms mt mu aw mv bi"><span id="6cea" class="mw lv ir ms b gz mx my l mz na">Exception in thread "main" java.lang.InternalError: Exception during analyze - java.lang.NullPointerException: Cannot invoke "com.sun.tools.javac.code.Symbol$ClassSymbol.getRecordComponents()" because "deconstructionPatterns.head.record" is null</span></pre></div></div>    
</body>
</html>