<html>
<head>
<title>Object-Oriented Programming: Inheritance ( With a Ruby example)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向对象编程:继承(用一个Ruby例子)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/object-oriented-programming-inheritance-with-a-ruby-example-a498cf0d643f?source=collection_archive---------25-----------------------#2020-06-28">https://blog.devgenius.io/object-oriented-programming-inheritance-with-a-ruby-example-a498cf0d643f?source=collection_archive---------25-----------------------#2020-06-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/61a01bbe59cd6484c0032b2aef20d59e.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*5CZwLt-HSxgaztHi-lxs3g.gif"/></div></figure><h2 id="f2a9" class="jr js in bd jt ju jv dn jw jx jy dp jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">介绍</h2><p id="5141" class="pw-post-body-paragraph kn ko in kp b kq kr ks kt ku kv kw kx ka ky kz la ke lb lc ld ki le lf lg lh ig bi translated">什么是继承，为什么方便？为了更好地理解遗传，思考一下<strong class="kp io">现实生活中的例子</strong>，在现实生活中，有成千上万种不同的汽车、模型和特征，但它们都<strong class="kp io">有相同的东西它们都是汽车</strong>知道这一点给了我们一个优势，因为我们知道例如所有的汽车都有引擎、门、轮胎、方向盘等。我们可以对植物说同样的话，有成千上万的物种，但它们都需要湿度才能生存。</p><p id="4778" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated">当我们创建新对象时，我们分配它们的属性并创建它们的结构，有时继承可以节省我们的时间，例如，假设我们正在创建一个名为BMW的对象/类，我们知道BMW是一个汽车品牌，所以我们知道所有的BMW都是汽车，如果我们可以从另一个名为car的对象中给这个对象一些属性会怎么样呢？嗯，我们可以，这就是继承的含义，<strong class="kp io">将属性或方法从一个对象分配给另一个对象。继承可以节省我们很多时间，因为我们可以简单地从另一个类中继承它们，而不是一遍又一遍地编写相同的属性或方法。</strong></p></div><div class="ab cl ln lo hr lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ig ih ii ij ik"><h1 id="f936" class="lu js in bd jt lv lw lx jw ly lz ma jz mb mc md kd me mf mg kh mh mi mj kl mk bi translated">继承如何处理对象属性</h1><p id="7269" class="pw-post-body-paragraph kn ko in kp b kq kr ks kt ku kv kw kx ka ky kz la ke lb lc ld ki le lf lg lh ig bi translated">继承允许对象执行来自另一个对象的相同属性，例如，假设我们的汽车类是用型号和年份初始化的</p><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi ml"><img src="../Images/74aa94883839b7ee7758cc6de87fde67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KOWbTQn4xMW1vNDYuTLQbA.png"/></div></div></figure><p id="37a9" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated">现在让我们创建一个名为Ford的新类，让我们从Car类继承，继承的语法可能是"</p><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/33c7bd585bd4b7f3ee631b22b7ad302b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*koW4MghKTC-8xEXD55XHrQ.png"/></div></figure><p id="808d" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated">Here we are inheriting everything from the Car object, so let's create a new Ford instance and try to give it the attributes that were initialized for the class Car.</p><div class="mm mn mo mp gt ab cb"><figure class="mv jo mw mx my mz na paragraph-image"><img src="../Images/a73066a514ae01191af005c930637d57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*TJZr13YLjOsO57b706Dd9A.png"/></figure><figure class="mv jo nb mx my mz na paragraph-image"><img src="../Images/a8b9c2fbae3a46ca12e47855c5bc8c55.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/format:webp/1*KjdktH49Y6WbZHoDqsbC_g.png"/></figure></div><p id="9c52" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated">So now we can create a new instance if the Ford class without even having to set a getter or setter and without having to specify any attribute to initialize that is because the Ford object is inheriting everything from the Car class. If we choose to initialize the Ford class with other attributes we can but then <strong class="kp io">。该类不会从Car类继承属性结构</strong>,但它仍会从其他类继承方法，所以让我们看看继承如何与方法一起工作。</p><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/a98a6a6c5e3e5c83f6f4d04e172df688.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*Im2OQcVTWFYaTgecMcBhbA.gif"/></div></figure></div><div class="ab cl ln lo hr lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ig ih ii ij ik"><h1 id="4927" class="lu js in bd jt lv lw lx jw ly lz ma jz mb mc md kd me mf mg kh mh mi mj kl mk bi translated">继承如何与方法一起工作</h1><p id="4a95" class="pw-post-body-paragraph kn ko in kp b kq kr ks kt ku kv kw kx ka ky kz la ke lb lc ld ki le lf lg lh ig bi translated">继承也允许对象共享方法，例如，让我们将一些方法添加到我们的汽车类，然后通过我们的福特类来尝试它们。让我们创建一个名为Bmw的新类，并使它继承汽车类，但让我们为福特和Bmw类创建新的不同的方法，这些方法将区分这两个类，并使每个类都是唯一的。</p><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nd"><img src="../Images/b9a89b6b27478ef0cd83ce9078cb5e02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cwl97nVJtZaAEZhnvErEJA.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">这里我们添加名为“is_car？”</figcaption></figure><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/c36997f6e93b7a446a265e8712468ac2.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*2vHUlRtu1OmpsnDa59lZPg.png"/></div></figure><p id="9d65" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated">我们创建了Bmw类，现在让我们创建一个Ford实例和一个Bmw实例，并检查它们是否都有is_car？可用的方法。</p><div class="mm mn mo mp gt ab cb"><figure class="mv jo nj mx my mz na paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><img src="../Images/a2de0043097fdec92c49c395d0d6d5a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/format:webp/1*KvSsdqndNa21BuW4axJgmg.png"/></div></figure><figure class="mv jo nk mx my mz na paragraph-image"><img src="../Images/6f3f777a67d049c85c2d07ab639d6f65.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/format:webp/1*mbIdKP5BSoatwvW4ts-9dg.png"/></figure></div><p id="be69" class="pw-post-body-paragraph kn ko in kp b kq li ks kt ku lj kw kx ka lk kz la ke ll lc ld ki lm lf lg lh ig bi translated">瞧啊。这里我们可以看到两个类都有相同的方法从类Car开始工作。现在最酷的事情是，我们可以不同地定制每个类，给每个类特定和独特的方法，将它们分开，使它们独特。</p></div><div class="ab cl ln lo hr lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ig ih ii ij ik"><h1 id="9ff7" class="lu js in bd jt lv lw lx jw ly lz ma jz mb mc md kd me mf mg kh mh mi mj kl mk bi translated">结论</h1><p id="830b" class="pw-post-body-paragraph kn ko in kp b kq kr ks kt ku kv kw kx ka ky kz la ke lb lc ld ki le lf lg lh ig bi translated">继承意味着将一个对象的属性分配给另一个对象。继承是一个非常重要的概念，知道它可以节省时间并使我们的代码更有效是很重要的。感谢阅读！</p></div></div>    
</body>
</html>