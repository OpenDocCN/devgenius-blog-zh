<html>
<head>
<title>Different ways of writing Javascript functions and how they affect ‘this’</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写 Javascript 函数的不同方式以及它们如何影响“这”</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/different-ways-of-writing-javascript-functions-and-how-they-affect-this-a183aedfcddb?source=collection_archive---------11-----------------------#2022-01-23">https://blog.devgenius.io/different-ways-of-writing-javascript-functions-and-how-they-affect-this-a183aedfcddb?source=collection_archive---------11-----------------------#2022-01-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="166c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Javascript 函数中“这”是什么的简单规则</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3dfce9b015ec197328e12d5bb6646c8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YV6es2Q9C9i2ZwCQOaRxtg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</figcaption></figure><p id="c937" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe lr ls lt lu b">this</code>错综复杂。<code class="fe lr ls lt lu b">this</code>指的是函数内部的上下文，但是根据函数声明的方式不同，上下文也不同。</p><p id="b362" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将会看到写一个 Javascript 函数的无数种方法，以及里面的<code class="fe lr ls lt lu b">this</code>的值是什么。注意，如果您想要快速复制/粘贴代码并亲自尝试，您可以找到 Github gist 和我在文章中截屏的示例！</p><h1 id="59e7" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">匿名函数</h1><p id="7c96" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le mp lg lh li mq lk ll lm mr lo lp lq ij bi translated">匿名函数是没有名字的函数。例如:</p><pre class="kg kh ki kj gt ms lu mt mu aw mv bi"><span id="43e3" class="mw lw iq lu b gy mx my l mz na">function() {<br/>   console.log(this.constructor.name);<br/>}</span></pre><p id="8ba3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe lr ls lt lu b">this</code>匿名函数内部是全局对象(如浏览器中的窗口)。</p><p id="3d44" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是一个内部有匿名函数的 Javascript 对象的例子。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/ab1b4a858f4ee86d759b8686a52700a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pYp7b1x4fD2hUlLOW6cVUg.png"/></div></div></figure><p id="d197" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当你运行左边的代码时，你期望<code class="fe lr ls lt lu b">this</code>是全局窗口对象，如右边所示。</p><p id="8c45" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">匿名函数通常用于生命或者回调。</p><h1 id="f35e" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">箭头功能</h1><p id="0c2f" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le mp lg lh li mq lk ll lm mr lo lp lq ij bi translated">另一方面，箭头函数在创建时接收其周围范围的<code class="fe lr ls lt lu b">this</code>值。</p><p id="024d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在下面的例子中，创建时的封闭范围是龙对象。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/034123aa7955bf457e683cce358ff5a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SwjmH5SY7TOKdZkgoq41Pw.png"/></div></div></figure><p id="dadc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面的代码与匿名函数的例子相同，但是<code class="fe lr ls lt lu b">sayHello</code>是一个箭头函数，而<code class="fe lr ls lt lu b">forEach</code>中的回调也是一个箭头函数。在这种情况下，<code class="fe lr ls lt lu b">this</code>就是龙的对象。</p><p id="477e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">箭头功能防止通过</strong> <code class="fe lr ls lt lu b"><strong class="kx ir">.call</strong></code> <strong class="kx ir">和</strong> <code class="fe lr ls lt lu b"><strong class="kx ir">.apply</strong></code> <strong class="kx ir">控制上下文。</strong></p><p id="f643" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这意味着即使你试图将一个上下文绑定到一个函数，如果这个函数是一个箭头函数，它也不会工作。我将在本文的后面回到这个问题。</p><h1 id="d50f" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">作为方法调用的函数</h1><p id="f58a" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le mp lg lh li mq lk ll lm mr lo lp lq ij bi translated">如果函数被作为方法调用(例如<code class="fe lr ls lt lu b">myObj.myMethod()</code>)，即使它是一个匿名函数，<code class="fe lr ls lt lu b">this</code>仍然是函数属性所在的对象。在下面的例子中，如果我们将<code class="fe lr ls lt lu b">sayHello</code>指定为 dragon 的属性，<code class="fe lr ls lt lu b">this</code>将成为 Dragon 对象。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/08de4117b69247fcd919cc7e85bcc82b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fe1bRTc-Nx8c7vgH0Ic_TA.png"/></div></div></figure><p id="726d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe lr ls lt lu b">this</code>如果匿名函数是 dragon 对象的属性，则匿名函数内部是 Dragon 的实例。</p><h1 id="230e" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">Javascript 对象</h1><p id="9e08" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le mp lg lh li mq lk ll lm mr lo lp lq ij bi translated">然而，在 Javascript 对象内部，<code class="fe lr ls lt lu b">this</code>对于箭头函数和匿名函数是不同的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/47d1ef71aa7ef51b76827c2e7ff933b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9c3Rx4XE5y3e_nmvs8BfdQ.png"/></div></div></figure><p id="5118" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如你所见，箭头函数中的<code class="fe lr ls lt lu b">this</code>是<code class="fe lr ls lt lu b">Window</code>，而匿名函数中的<code class="fe lr ls lt lu b">this</code>仍然是我们的龙对象，Ysera。</p><p id="6f09" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里的原因是，在全局级别声明的 Javascript 对象中，arrow 函数的封闭词法范围仍然是全局窗口对象。</p><h1 id="c590" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">申请，打电话和这个</h1><p id="395c" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le mp lg lh li mq lk ll lm mr lo lp lq ij bi translated">应用和调用是在特定上下文中传递给函数的方法。“bound”函数中的<code class="fe lr ls lt lu b">this</code>是作为第一个参数传入的对象。</p><p id="a53c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，对于<code class="fe lr ls lt lu b">DragonBound</code>类，我们不按原样调用匿名函数<code class="fe lr ls lt lu b">sayHello()</code>，而是使用<code class="fe lr ls lt lu b">.call</code> — <code class="fe lr ls lt lu b">sayHello.call(this)</code>。这将 dragon 对象作为<code class="fe lr ls lt lu b">this</code>的上下文传递给了<code class="fe lr ls lt lu b">sayHello</code>函数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/576fd6171d7dda5d70b22319da1f626b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HjPQ5LMMheLdfS2lZDVXcw.png"/></div></div></figure><p id="c9da" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们希望控制台显示</p><pre class="kg kh ki kj gt ms lu mt mu aw mv bi"><span id="d33d" class="mw lw iq lu b gy mx my l mz na">“‘this’ is Window. My name is result”<br/>“‘this’ is DragonBound. My name is Alexstraza”</span></pre><p id="dfb7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">事实上，这就是我们所得到的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/8b9337a42b45927cda78deb24f78ad2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q0HSWUx9N80ocA9KhvC7Gw.png"/></div></div></figure><p id="be7b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe lr ls lt lu b">.apply()</code>工作原理类似。它们的不同之处在于<a class="ae nh" href="https://frontendinterviewhandbook.com/javascript-questions/#whats-the-difference-between-call-and-apply" rel="noopener ugc nofollow" target="_blank">如何将参数传递给函数</a>。</p><p id="fe76" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">同样，</strong> <code class="fe lr ls lt lu b"><strong class="kx ir">.call</strong></code> <strong class="kx ir">和</strong> <code class="fe lr ls lt lu b"><strong class="kx ir">.apply</strong></code> <strong class="kx ir">对箭头功能不起作用，如下图:</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/6b5facf30ee0e93c371c52446d846908.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pkLzEU0nuZN62MdCKPqJRg.png"/></div></div></figure><p id="4a6a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果方法是用箭头函数声明的，那么将 alexstraza 绑定到 ysera 的方法将不起作用。</p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><p id="b7e7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我计划在以后的文章中更详细地介绍如何实现<code class="fe lr ls lt lu b">.call</code>、<code class="fe lr ls lt lu b">.apply</code>和<code class="fe lr ls lt lu b">.bind</code>。敬请期待！</p><p id="516a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是 Github 要点，以及本文中的示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae nh" href="https://gist.github.com/lilychencodes/6e9ae62004b3a341c27d5769a671cac8" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/lilychencodes/6e 9 AE 62004 B3 a 341 c 27d 5769 a 671 CAC 8</a></figcaption></figure><p id="041a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">感谢您的阅读。如果你有什么特别的话题想让我介绍，请在下面评论。</p></div></div>    
</body>
</html>