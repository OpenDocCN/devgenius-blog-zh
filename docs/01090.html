<html>
<head>
<title>Floyd Warshall Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">弗洛伊德·沃肖尔算法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/floyd-warshall-algorithm-f004a01ae40e?source=collection_archive---------1-----------------------#2020-06-24">https://blog.devgenius.io/floyd-warshall-algorithm-f004a01ae40e?source=collection_archive---------1-----------------------#2020-06-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="fdec" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">最短路径算法</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/e3c898524f773baedbc35432d3033774.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DdqguI9FlBehCWALlFDEOw.png"/></div></div></figure><p id="fd84" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">困惑选择从您的位置到目的地的最短路径？。那么，你应该知道这个算法。</p><ul class=""><li id="1a21" class="lk ll in kq b kr ks ku kv kx lm lb ln lf lo lj lp lq lr ls bi translated">Floyd–Warshall算法用于查找图中所有顶点对之间的最短路径，其中图中的每条边都有一个正或负的权重。</li><li id="72d6" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">使用该算法的最大优点是任意两个顶点之间的所有最短距离都可以在O(V3)中计算，其中V是图中顶点的数目。</li><li id="615b" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">弗洛伊德-沃肖尔算法也被称为弗洛伊德算法、罗伊-弗洛伊德算法、罗伊-沃肖尔算法或WFI算法。</li><li id="1afc" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">该算法遵循动态规划方法来寻找最短路径。</li></ul><h2 id="4bd3" class="ly lz in bd ma mb mc dn md me mf dp mg kx mh mi mj lb mk ml mm lf mn mo mp mq bi translated">算法</h2><p id="fd9e" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">对于具有N个顶点的图:</p><p id="3fe9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">步骤1: </strong>初始化任意2个顶点之间的最短路径为无穷大。</p><p id="9862" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">步骤2: </strong>找出所有使用0个中间顶点的成对最短路径，然后找出使用1个中间顶点的最短路径，依此类推..直到使用所有N个顶点作为中间节点。</p><p id="e3f9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">第三步:</strong>在前一步操作中，最小化任意两对之间的最短路径。</p><p id="e54c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">步骤4: </strong>对于任意2个顶点(I，j)，实际上应该使用前K个节点最小化该对之间的距离，因此最短路径将是:min(dist[i][k]+dist[k][j]，dist[i][j])。</p><p id="e0c2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">dist[i][k]表示仅使用前K个顶点的最短路径，dist[k][j]表示对K，j之间的最短路径。因为最短路径将是从I到K，然后从K到j的最短路径的串联。</p><pre class="kd ke kf kg gt mw mx my mz aw na bi"><span id="263c" class="ly lz in mx b gy nb nc l nd ne">for(int k = 1; k &lt;= n; k++){<br/>    for(int i = 1; i &lt;= n; i++){<br/>        for(int j = 1; j &lt;= n; j++){<br/>            dist[i][j] = min( dist[i][j], dist[i][k] + dist[k][j] );<br/>        }<br/>    }<br/>}</span></pre><h2 id="66e8" class="ly lz in bd ma mb mc dn md me mf dp mg kx mh mi mj lb mk ml mm lf mn mo mp mq bi translated">例子</h2><p id="1703" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">设给定的图形为:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/961414a97dc39268613953f712c432d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/0*_xHqSgP179ftnEPB.png"/></div></figure><p id="4d0f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">按照下面的步骤找到所有顶点对之间的最短路径。</p><ol class=""><li id="cb81" class="lk ll in kq b kr ks ku kv kx lm lb ln lf lo lj ng lq lr ls bi translated">创建一个维度为<code class="fe nh ni nj mx b">n*n</code>的矩阵<code class="fe nh ni nj mx b">A0</code>，其中n是顶点的数量。行和列的索引分别为I和j。I和j是图的顶点。</li></ol><p id="98ec" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">每个单元格A[i][j]都填充了从<code class="fe nh ni nj mx b">ith</code>顶点到<code class="fe nh ni nj mx b">jth</code>顶点的距离。如果没有从<code class="fe nh ni nj mx b">ith</code>顶点到<code class="fe nh ni nj mx b">jth</code>顶点的路径，则该单元被保留为无穷大。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/9559e16eab7fb7eaf6e6c27bf83f87eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/0*zHEY97R1MtB27HdE.png"/></div></figure><p id="cee5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">2.现在，使用矩阵<code class="fe nh ni nj mx b">A0</code>创建一个矩阵<code class="fe nh ni nj mx b">A1</code>。第一列和第一行中的元素保持不变。其余的单元格按以下方式填充。</p><p id="24cf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">设k是从源到目的地的最短路径中的冻结顶点。在这一步，k是第一个顶点。<code class="fe nh ni nj mx b">A[i][j]</code>填的是<code class="fe nh ni nj mx b">(A[i][k] + A[k][j]) if (A[i][j] &gt; A[i][k] + A[k][j])</code>。</p><p id="6e51" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">也就是说，如果从源到目的地的直接距离大于通过顶点k的路径，那么用<code class="fe nh ni nj mx b">A[i][k] + A[k][j]</code>填充该单元。</p><p id="9d14" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这一步，k是顶点1。我们通过这个顶点k计算从源顶点到目的顶点的距离。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nl"><img src="../Images/a797221bb41c1a25afbb824e9515c606.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7vlvb6dwy2m_uFJZ.png"/></div></div></figure><p id="2a8c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">例如:对于<code class="fe nh ni nj mx b">A1[2, 4]</code>，从顶点2到4的直接距离是4，从顶点2到4通过顶点(即从顶点2到1和从顶点1到4)的距离之和是7。从<code class="fe nh ni nj mx b">4 &lt; 7</code>开始，<code class="fe nh ni nj mx b">A0[2, 4]</code>就充满了4。</p><p id="c092" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">3.以类似的方式，使用<code class="fe nh ni nj mx b">A3</code>创建<code class="fe nh ni nj mx b">A2</code>。第二列和第二行中的元素保持不变。</p><p id="b1af" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这个步骤中，k是第二个顶点(即顶点2)。其余步骤与<strong class="kq io">步骤2 </strong>相同。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nl"><img src="../Images/7bad32cef9d06565e0fb86768dd2d595.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pnBDaBhEWy5JsZLr.png"/></div></div></figure><p id="2d49" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">4.类似地，<code class="fe nh ni nj mx b">A3</code>和<code class="fe nh ni nj mx b">A4</code>也被创建。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nl"><img src="../Images/b419a821b219a31bbee4a72e30d507eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FDEA0qgqrEcYazxl.png"/></div></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nl"><img src="../Images/0f05e8fb10a576503bad61444e2fdc96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*k9Z0IpZfY9ORKYiV.png"/></div></div></figure><p id="ceeb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">5.<code class="fe nh ni nj mx b">A4</code>给出每对顶点之间的最短路径。</p><p id="bf43" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">困惑选择最短路径，然后使用下面的代码来找到它。但是输入正确的距离。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="01a7" class="ly lz in bd ma mb mc dn md me mf dp mg kx mh mi mj lb mk ml mm lf mn mo mp mq bi translated">时间复杂度</h2><p id="5c3e" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">有三个循环。每个循环都有恒定的复杂性。因此，Floyd-Warshall算法的时间复杂度为<strong class="kq io"> O(n3) </strong>。</p><h2 id="b4b6" class="ly lz in bd ma mb mc dn md me mf dp mg kx mh mi mj lb mk ml mm lf mn mo mp mq bi translated">空间复杂性</h2><p id="df76" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">Floyd-Warshall算法的空间复杂度为<strong class="kq io"> O(n2) </strong>。</p></div><div class="ab cl no np hr nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ig ih ii ij ik"><div class="kd ke kf kg gt nv"><a href="https://twitter.com/Sridharan_tsd" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd io gy z fp oa fr fs ob fu fw im bi translated">斯里达哈兰T</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">iOS开发者实习生@ivymobility |无神论者| F1粉丝</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">twitter.com</p></div></div><div class="oe l"><div class="of l og oh oi oe oj km nv"/></div></div></a></div></div></div>    
</body>
</html>