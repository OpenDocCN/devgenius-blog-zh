<html>
<head>
<title>State Management with MobX 6 — Creating Observable States</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MobX 6 的状态管理——创建可观察的状态</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/state-management-with-mobx-6-creating-observable-states-e553c8a7ab98?source=collection_archive---------3-----------------------#2021-06-20">https://blog.devgenius.io/state-management-with-mobx-6-creating-observable-states-e553c8a7ab98?source=collection_archive---------3-----------------------#2021-06-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/03c359c720995d674bd940ba0c58927c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ljo-SL0wX-lC3YCv"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">基特·苏曼在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="9402" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">MobX 是一个简单的 JavaScript 应用程序状态管理解决方案。</p><p id="d533" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解如何使用 MobX 6 将状态管理添加到我们的 JavaScript 应用程序中。</p><h1 id="6a58" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">创建可观察状态</h1><p id="4fce" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过创建存储来创建一个或多个可观察的状态。</p><p id="ff48" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b2bb" class="mn lc iq mj b gy mo mp l mq mr">import { makeObservable, observable, computed, action, autorun } from "mobx";</span><span id="1884" class="mn lc iq mj b gy ms mp l mq mr">class Count {<br/>  count = 0;<br/>  get doubleCount() {<br/>    return this.count * 2;<br/>  }<br/>  constructor(count) {<br/>    makeObservable(this, {<br/>      count: observable,<br/>      doubleCount: computed,<br/>      increment: action<br/>    });<br/>    this.count = count;<br/>  }</span><span id="abc2" class="mn lc iq mj b gy ms mp l mq mr">  increment() {<br/>    this.count++;<br/>  }<br/>}</span><span id="5d65" class="mn lc iq mj b gy ms mp l mq mr">const store = new Count(1);</span><span id="bfe6" class="mn lc iq mj b gy ms mp l mq mr">autorun(() =&gt; {<br/>  console.log(store.count);<br/>});</span><span id="7b7c" class="mn lc iq mj b gy ms mp l mq mr">store.increment();</span></pre><p id="a094" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有包含<code class="fe mt mu mv mj b">count</code>和<code class="fe mt mu mv mj b">doubleCount</code>状态的<code class="fe mt mu mv mj b">Count</code>类。</p><p id="2217" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">count</code>是一种我们可以操纵的可观察状态。</p><p id="05dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通过在<code class="fe mt mu mv mj b">makeObservable</code>调用中将<code class="fe mt mu mv mj b">count</code>属性设置为<code class="fe mt mu mv mj b">observable</code>来添加这个属性。</p><p id="df0a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">doubleCount</code> getter 用于创建一个<code class="fe mt mu mv mj b">computed</code>状态，这是一个从其他可观测状态派生出来的状态。</p><p id="ee5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">increment</code>方法是通过将<code class="fe mt mu mv mj b">increment</code>设置为<code class="fe mt mu mv mj b">action</code>来指示的动作。</p><p id="7c11" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在行动中操纵可观察的状态值。</p><p id="96db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在构造函数中，我们将<code class="fe mt mu mv mj b">this.count</code>设置为<code class="fe mt mu mv mj b">count</code>来初始化它。</p><p id="a2d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们创建<code class="fe mt mu mv mj b">Count</code>实例，它是商店。</p><p id="db2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用回调来调用<code class="fe mt mu mv mj b">autorun</code>以获得<code class="fe mt mu mv mj b">store.count</code>值。</p><p id="d500" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只要状态更新，回调就会运行。</p><p id="17fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以当调用<code class="fe mt mu mv mj b">store.increment</code>时，回调将运行以记录<code class="fe mt mu mv mj b">store.count</code>的最新值。</p><p id="4614" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这也适用于计算状态，因此我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5cb9" class="mn lc iq mj b gy mo mp l mq mr">import { makeObservable, observable, computed, action, autorun } from "mobx";</span><span id="e995" class="mn lc iq mj b gy ms mp l mq mr">class Count {<br/>  count = 0;<br/>  get doubleCount() {<br/>    return this.count * 2;<br/>  }<br/>  constructor(count) {<br/>    makeObservable(this, {<br/>      count: observable,<br/>      doubleCount: computed,<br/>      increment: action<br/>    });<br/>    this.count = count;<br/>  }</span><span id="00c6" class="mn lc iq mj b gy ms mp l mq mr">  increment() {<br/>    this.count++;<br/>  }<br/>}</span><span id="9445" class="mn lc iq mj b gy ms mp l mq mr">const store = new Count(1);</span><span id="b2ff" class="mn lc iq mj b gy ms mp l mq mr">autorun(() =&gt; {<br/>  console.log(store.count);<br/>  console.log(store.doubleCount);<br/>});</span><span id="684d" class="mn lc iq mj b gy ms mp l mq mr">store.increment();</span></pre><p id="0f25" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe mt mu mv mj b">autorun</code>回调中观察两种状态的值。</p><h1 id="6cd3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="96c4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用 MobX 为任何客户端 JavaScript 应用程序创建数据存储。</p></div></div>    
</body>
</html>