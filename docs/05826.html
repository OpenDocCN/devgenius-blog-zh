<html>
<head>
<title>Pivot query results in PostgreSQL using crosstab</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用交叉表透视PostgreSQL中的查询结果</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/pivot-query-results-in-postgresql-using-crosstab-3fc6915c1e94?source=collection_archive---------0-----------------------#2021-11-05">https://blog.devgenius.io/pivot-query-results-in-postgresql-using-crosstab-3fc6915c1e94?source=collection_archive---------0-----------------------#2021-11-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d6731e9c4c4eec829e79fea9f53d291d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mZqJOraV-JDkPi2Y"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">卡斯帕·卡米尔·鲁宾在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="f6bb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您使用过Microsoft Excel或SQL Server，您可能会遇到pivot函数，它允许您轻松地转换数据，以便进行比较和查看模式。PostgreSQL在交叉表函数中拥有相同的功能。</p><p id="e03a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这两个函数从本质上改变了通常垂直排列的数据的方向，使其水平显示。本教程将研究如何利用这个工具。</p><h2 id="39ff" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">目录</h2><ol class=""><li id="2239" class="lr ls in kc b kd lt kh lu kl lv kp lw kt lx kx ly lz ma mb bi translated"><a class="ae jz" href="#2513" rel="noopener ugc nofollow"> <em class="mc">先决条件</em> </a></li><li id="ad4f" class="lr ls in kc b kd md kh me kl mf kp mg kt mh kx ly lz ma mb bi translated"><a class="ae jz" href="#85e5" rel="noopener ugc nofollow"> <em class="mc">测试场景</em> </a></li><li id="6b4f" class="lr ls in kc b kd md kh me kl mf kp mg kt mh kx ly lz ma mb bi translated"><a class="ae jz" href="#f12f" rel="noopener ugc nofollow"> <em class="mc">设置数据库</em> </a></li><li id="1d40" class="lr ls in kc b kd md kh me kl mf kp mg kt mh kx ly lz ma mb bi translated"><a class="ae jz" href="#1eb0" rel="noopener ugc nofollow"> <em class="mc">了解交叉表功能</em> </a></li><li id="a0cc" class="lr ls in kc b kd md kh me kl mf kp mg kt mh kx ly lz ma mb bi translated"><a class="ae jz" href="#388e" rel="noopener ugc nofollow"> <em class="mc">应用交叉表功能</em> </a></li><li id="2bd6" class="lr ls in kc b kd md kh me kl mf kp mg kt mh kx ly lz ma mb bi translated"><a class="ae jz" href="#fa51" rel="noopener ugc nofollow"> <em class="mc">结论</em> </a></li></ol><h2 id="2513" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">先决条件</h2><p id="2888" class="pw-post-body-paragraph ka kb in kc b kd lt kf kg kh lu kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated">要阅读这篇文章，您需要对SQL有一个基本的了解，尤其是PostgreSQL。</p><h2 id="85e5" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">测试场景</h2><p id="6ae7" class="pw-post-body-paragraph ka kb in kc b kd lt kf kg kh lu kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated">该数据库将侧重于三个实体:商店，产品和产品的销售。有三个商店和三种产品，每个商店都可以销售任何一种产品。尽管sales表不包含created_at属性，但假设我们拥有的记录详细记录了一周内发生的销售额。</p><p id="4c1d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">本教程的目的是能够将此输出:</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="f2d8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">转换成以下输出:</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h2 id="f12f" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">设置数据库</h2><p id="aa46" class="pw-post-body-paragraph ka kb in kc b kd lt kf kg kh lu kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated">首先，通过首选客户端打开PostgreSQL并创建一个新数据库。</p><pre class="ml mm mn mo gt mr ms mt mu aw mv bi"><span id="55ba" class="ky kz in ms b gy mw mx l my mz">CREATE DATABASE crosstab_tutorial;</span></pre><p id="6a7a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">创建数据库后，设置您的表。如上所述，有三个关系:商店表、产品表和销售表。</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="0f8b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">创建好表后，运行查询来插入虚拟数据。</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h2 id="1eb0" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">了解交叉表函数</h2><p id="3362" class="pw-post-body-paragraph ka kb in kc b kd lt kf kg kh lu kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated">为了能够利用交叉表函数，需要为每个数据库启用一次tablefunc模块，这可以使用命令来完成</p><pre class="ml mm mn mo gt mr ms mt mu aw mv bi"><span id="a0d8" class="ky kz in ms b gy mw mx l my mz">CREATE EXTENSION IF NOT EXISTS tablefunc;</span></pre><p id="f603" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">交叉表函数有两种形式，一种简单的形式接受一个输入参数，另一种更具表现力的形式接受两个输入参数。</p><p id="4469" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在<strong class="kc io">简单表单</strong>中，交叉表的输出被限制为正好三列。因此，它对一个组中的所有值一视同仁，将每个值插入第一个可用的列中。但是，如果您的值中有一些空条目，并且您希望值列对应于特定的数据类别，则它不会按预期工作。</p><pre class="ml mm mn mo gt mr ms mt mu aw mv bi"><span id="00bf" class="ky kz in ms b gy mw mx l my mz">crosstab(text sql)</span></pre><p id="8a42" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">本教程将关注于<strong class="kc io">更具表现力的形式</strong>，它接受两个输入参数</p><pre class="ml mm mn mo gt mr ms mt mu aw mv bi"><span id="ea42" class="ky kz in ms b gy mw mx l my mz">crosstab(text source_sql, text category_sql)</span></pre><p id="d84e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">双参数变量提供了一种解决单参数变量所带来的空条目问题的方法。它通过接受对应于输出列的类别的显式列表来处理这个问题。这个显式列表是第二个参数。</p><p id="49df" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe na nb nc ms b">source_sql</code>产生源数据集。该数据必须包含一个将作为<code class="fe na nb nc ms b">row_name</code>的列。该列必须是第一列。数据必须有两个附加列:类别列<strong class="kc io">和数值列<strong class="kc io">。</strong>类别列和值列总是最后两个。</strong></p><p id="5090" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们的测试案例中，行名列将是商店名称，类别列将是产品名称，值列将是售出单位的总和。</p><p id="37f0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe na nb nc ms b">source_sql</code>可能有额外的列，但是上述三个基本列是必需的，并且按照上面所示的顺序排列。额外的列将出现在row_name列和category列之间，如下所示:</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="e010" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe na nb nc ms b">category_sql</code>按照应用于<code class="fe na nb nc ms b">source_sql</code>的相同顺序生成我们的类别列表。因此，如果<code class="fe na nb nc ms b">category_sql</code>以特定方式订购，相同的订购条件应适用于<code class="fe na nb nc ms b">source_sql</code>中的类别栏。</p><p id="6227" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe na nb nc ms b">category_sql</code>查询必须只产生一列和至少一行，否则将会产生错误。结果必须只包含不同的值，重复的值将导致错误。</p><p id="929f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe na nb nc ms b">crosstab</code>函数同样返回类型<code class="fe na nb nc ms b">setof</code>的结果，因此输出列的实际名称和类型必须在<code class="fe na nb nc ms b">FROM</code>子句中明确定义，并且必须对应于<code class="fe na nb nc ms b">source_sql.</code>中的列类型。<code class="fe na nb nc ms b">FROM</code>子句必须定义正确数量的输出列及其正确的数据类型。</p><p id="6a80" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果<code class="fe na nb nc ms b"><em class="mc">source_sql</em></code>查询的结果有n列，其中的前n-2列必须与输出的前n-2列匹配。剩余的输出列必须具有<code class="fe na nb nc ms b"><em class="mc">source_sql</em></code>查询结果的最后一列的类型，并且必须与<code class="fe na nb nc ms b"><em class="mc">category_sql</em></code>查询结果中的行数一样多。</p><p id="f3f7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，交叉表函数的输出应该包含行名列和任何额外的列。在这些之上，应该有一个由<code class="fe na nb nc ms b">category_sql.</code>产生的每个不同类别的列</p><p id="d2da" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe na nb nc ms b">source_sql</code>查询结果中具有相同row_name值的每组行将在输出结果中被压缩成一行。</p><p id="affd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，<code class="fe na nb nc ms b">source_sql</code>必须包含<code class="fe na nb nc ms b">order by 1</code>子句，以便将相同的row_names分组在一起。</p><h2 id="388e" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">应用交叉表函数</h2><p id="2200" class="pw-post-body-paragraph ka kb in kc b kd lt kf kg kh lu kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated">首先，我们需要使用以下命令来启用上一节中描述的tablefunc模块:</p><pre class="ml mm mn mo gt mr ms mt mu aw mv bi"><span id="b62d" class="ky kz in ms b gy mw mx l my mz">CREATE EXTENSION IF NOT EXISTS tablefunc;</span></pre><p id="f28c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看看<strong class="kc io"> source_sql </strong>，它将提供我们需要转换的结果集。我们将使用的语句是:</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="97e0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当查询运行时，它将产生:</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="9c9b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如上表所示，<strong class="kc io"> store_name </strong>列是我们的row_name，<strong class="kc io"> product_name </strong>对应于category列，<strong class="kc io"> total_units </strong>对应于value列。</p><p id="fe61" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">至于<strong class="kc io"> category_sql </strong>，我们将使用产品名称，并通过以下查询获得它们:</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="6ca3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这将产生如下所示的类别:</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="15c4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有了源sql和类别sql，我们现在可以通过下面的查询将交叉表函数应用到源结果中</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="94c2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这将把我们的数据转换成如下所示的格式:</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="8fdf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">输出值列由源数据集中具有匹配类别值的行的值字段填充。例如，在源数据集中，根据表中的第4行，Beatty Group销售了470单位的葡萄酒，这将出现在Beatty Group行和wine列下。</p><p id="a279" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">其匹配类别不存在于该组的任何输入行中的输出列用空值填充。</p><p id="8549" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如上所述，<code class="fe na nb nc ms b">source_sql</code>应该总是指定<code class="fe na nb nc ms b">ORDER BY 1</code>以确保具有相同row_name的值被分组在一起。然而，组内类别的排序并不重要。</p><p id="8967" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如交叉表查询所示，<code class="fe na nb nc ms b">FROM</code>子句中指定的订单应该与<code class="fe na nb nc ms b">category_sql</code>产生的订单相匹配。</p><h2 id="fa51" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">结论</h2><p id="6246" class="pw-post-body-paragraph ka kb in kc b kd lt kf kg kh lu kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated">交叉表在日常操作中起着重要的作用，一旦理解了，就很容易使用。</p><p id="5bbe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从PostgresSQl文档中找到更多关于交叉表函数的信息<a class="ae jz" href="https://www.postgresql.org/docs/12/tablefunc.html" rel="noopener ugc nofollow" target="_blank">https://www.postgresql.org/docs/12/tablefunc.html</a></p><p id="c0e1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mc"> PS:本教程中的虚拟数据是使用</em><a class="ae jz" href="https://www.mockaroo.com/" rel="noopener ugc nofollow" target="_blank"><em class="mc">【https://www.mockaroo.com/】</em></a>生成的</p></div></div>    
</body>
</html>