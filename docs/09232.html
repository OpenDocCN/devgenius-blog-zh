<html>
<head>
<title>Duplicates in SQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL 中的重复项</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/duplicates-in-sql-e7a146d0131?source=collection_archive---------4-----------------------#2022-08-08">https://blog.devgenius.io/duplicates-in-sql-e7a146d0131?source=collection_archive---------4-----------------------#2022-08-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/6bba6020c54cb32feeb009aaf7f46dc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZIwKUdoV5Rlyul1RvlVEzg.jpeg"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">照片由<a class="ae ja" href="https://unsplash.com/@norevisions?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">无修订</a>在<a class="ae ja" href="https://unsplash.com/s/photos/same?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">上展开</a></figcaption></figure><div class=""/><p id="89cb" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在 SQL 中处理重复项时，您需要知道的就是这些。</p><h2 id="5421" class="ky kz jd bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">识别重复条目</h2><p id="d390" class="pw-post-body-paragraph ka kb jd kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">第一步应该是定义哪个列或列的组合形成唯一的行。一旦我们有了决定行唯一性的列集，我们就可以使用以下两种策略来查找哪些列组合有重复条目。</p><h2 id="34d1" class="ky kz jd bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">1.分组依据</h2><p id="1d3c" class="pw-post-body-paragraph ka kb jd kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">我们可以使用 GROUP By 来找出分组列的组合在表中出现的次数。如果计数大于 1，则表示有两行所选列组合的值相同。因此给出了重复的值。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="0e75" class="ky kz jd mb b gy mf mg l mh mi">SELECT col1, col2<br/>FROM table_name<br/>WHERE (col1, col2) IN (<br/>    SELECT col1, col2 FROM table_name<br/>    GROUP BY col1, col2 <br/>    HAVING COUNT(*) &gt; 1<br/>    )</span></pre><h2 id="e024" class="ky kz jd bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">2.带窗口的行编号</h2><p id="6f1d" class="pw-post-body-paragraph ka kb jd kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">在 SQL 中，<code class="fe mj mk ml mb b">PARTITION BY</code>子句将结果集划分为多个分区，其中给定分区中的每一行对所选列都具有相同的值。如果列值集在表中是唯一的，则具有该列集的分区将具有单行。相反，具有多行的分区表示存在重复值。我们使用<code class="fe mj mk ml mb b">ROW_NUMBER()</code>为结果集分区内的每一行分配一个连续的整数。大于 1 的序列(出现/出现)意味着该值出现多次。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="545d" class="ky kz jd mb b gy mf mg l mh mi">WITH dedup AS (<br/> SELECT col1, col2,<br/>  ROW_NUMBER() OVER (PARTITION BY col1, col2 ORDER BY col3 ASC) AS occurrence<br/> FROM<br/>  table_name<br/> )<br/>SELECT<br/> col1, col2<br/>FROM<br/> dedup<br/>WHERE<br/> occurrence &gt; 1</span></pre><h2 id="b4fc" class="ky kz jd bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">选择重复记录</h2><p id="5d58" class="pw-post-body-paragraph ka kb jd kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">现在，我们想从数据集中选择唯一的记录。我们有很多方法去做。我列出了其中的 5 个。</p><h2 id="7944" class="ky kz jd bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">1.明显的</h2><p id="9858" class="pw-post-body-paragraph ka kb jd kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">SQL 中的<code class="fe mj mk ml mb b">DISTINCT</code>函数返回具有唯一值的结果。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="0346" class="ky kz jd mb b gy mf mg l mh mi">SELECT DISTINCT col1, col2<br/>FROM table_name</span></pre><h2 id="fc94" class="ky kz jd bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">2.联盟</h2><p id="65f9" class="pw-post-body-paragraph ka kb jd kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">在 SQL 中，<code class="fe mj mk ml mb b">UNION</code>结合了两个<code class="fe mj mk ml mb b">SELECT</code>语句的结果。同时，它会删除结果数据集中的多次出现的行，并且只保留每一行的一次出现。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="d38c" class="ky kz jd mb b gy mf mg l mh mi">SELECT col1, col2<br/>FROM table_name</span><span id="69d0" class="ky kz jd mb b gy mm mg l mh mi">UNION</span><span id="b788" class="ky kz jd mb b gy mm mg l mh mi">SELECT col1, col2<br/>FROM table_name</span></pre><h2 id="b988" class="ky kz jd bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">3.横断</h2><p id="6f32" class="pw-post-body-paragraph ka kb jd kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">在 SQL 中，<code class="fe mj mk ml mb b">INTERSECT</code>用于获取两个<code class="fe mj mk ml mb b">SELECT</code>查询的公共行。与<code class="fe mj mk ml mb b">UNION</code>类似，<code class="fe mj mk ml mb b">INTERSECT</code>也删除了结果数据集中的多次出现的行，并且每行只保留一次出现。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="a8ca" class="ky kz jd mb b gy mf mg l mh mi">SELECT col1, col2<br/>FROM table_name</span><span id="3b80" class="ky kz jd mb b gy mm mg l mh mi">INTERSECT</span><span id="7adf" class="ky kz jd mb b gy mm mg l mh mi">SELECT col1, col2<br/>FROM table_name</span></pre><h2 id="5ea3" class="ky kz jd bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">4.ROW_NUMBER</h2><p id="a826" class="pw-post-body-paragraph ka kb jd kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">如上所述，大于 1 的序列(出现/出现)意味着该值出现不止一次。值 1 表示列值集的第一次出现。因此，我们对<code class="fe mj mk ml mb b">occurrence </code>值设置为 1 的行进行过滤。这将产生唯一的行。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="518d" class="ky kz jd mb b gy mf mg l mh mi">WITH dedup AS (<br/> SELECT col1, col2,<br/>  <strong class="mb je">ROW_NUMBER() OVER (PARTITION BY col1, col2 ORDER BY col3 ASC) AS occurrence</strong><br/> FROM<br/>  table_name<br/> )<br/>SELECT<br/> col1, col2<br/>FROM<br/> dedup<br/>WHERE<br/> <strong class="mb je">occurrence </strong>= 1</span></pre><h2 id="398a" class="ky kz jd bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">5.分组依据</h2><p id="8522" class="pw-post-body-paragraph ka kb jd kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">在 SQL 中，<code class="fe mj mk ml mb b">GROUP BY</code>为<code class="fe mj mk ml mb b">GROUP BY</code>列的每个唯一组合返回一行。因此，如果我们简单地选择列并按相同的列对它们进行分组，我们将得到唯一的行。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="a9c4" class="ky kz jd mb b gy mf mg l mh mi">SELECT col1, col2<br/>FROM table_name<br/>GROUP BY col1, col2</span></pre><h2 id="44e4" class="ky kz jd bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">删除重复记录并保留一个</h2><p id="2044" class="pw-post-body-paragraph ka kb jd kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">现在我们想从数据集中删除重复的记录。这可以通过使用 ROW_NUMBER 和 PARTITION BY 来实现。要决定保留哪些行(最新/最早或基于其他列),我们可以在窗口中使用 ORDER BY。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="9190" class="ky kz jd mb b gy mf mg l mh mi">WITH dedup AS (<br/> SELECT col1, col2,<br/>  <strong class="mb je">ROW_NUMBER() OVER (PARTITION BY col1, col2 ORDER BY col3 ASC) AS occurrence</strong><br/> FROM<br/>  table_name<br/> )<br/>delete from dedup where <strong class="mb je">occurrence &gt; </strong>1 -- deletes the earliest (based on col3)</span></pre><p id="cdf6" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们希望保留最新的，我们可以将订单按值切换到<code class="fe mj mk ml mb b">DESC</code>。同样，如果我们想要保留两个副本，那么我们可以将 where 子句改为<code class="fe mj mk ml mb b">occurrence &gt; 2</code>。</p><p id="ef65" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">SQL 快乐！！！</p></div></div>    
</body>
</html>