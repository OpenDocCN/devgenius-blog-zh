# 他们没告诉你的是

> 原文：<https://blog.devgenius.io/constructors-ab888e0c566f?source=collection_archive---------21----------------------->

## 为什么构造函数在编程语言中是如此重要的元素，我们如何在提高性能的同时使用它们来增加可靠性？

自从引入**面向对象编程**概念以来，已经过去了许多年，许多编程语言已经决定采用这种方法，拒绝它或者选择它的某些部分，而忽略其他部分。然而，OOP 的**三原则的通用描述似乎几十年来都没有改变过，在各种课程、书籍甚至工作面试中依然坚定有效。很明显，这三个是**封装**、**继承**和**多态**。通常，它们甚至是按照这种顺序排列的，尽管以前规定这种顺序的逻辑在许多年内不再有效。**

尽管如此，在我看来，面向对象编程带来了一个更重要的概念:构造器**，简称 **ctor** 。**

**![](img/bf619a341bdf5a9c55830c8568e121da.png)**

***更重要？* *真的吗？*
是的，绝对；至少从编程语言的角度来看是这样。我将很快解释称上那个位置的原因。但在此之前，先说一下它是如何为我们服务的。**

# **构造函数**

**任何阅读这篇文章的人都知道，一个 ctor 函数创建了一个给定类型的**对象**。ctor 可能会创建一个`basic`对象，保存所有对象字段的默认值。例如，看到这样的代码是有意义的:**

```
RgbColor color = new RgbColor();
```

**这创建了一个名为`color`的`RgbColor`类型的对象，它的三个字段——`red`、`green`和`blue` ——被初始化为零，设置为默认值黑色。我们可能会为该类型考虑一个附加的 ctor，例如，以下形式的一些代码:**

```
RgbColor color = new RgbColor(50, 100, 150);
```

**这创建了一个`RgbColor`对象，它的`red`组件被初始化为 50，它的`green`组件被初始化为 100，它的`blue`组件被初始化为 150。还可以定义更复杂的构造函数。例如，接受单个参数的函数:**

```
RgbColor color = new RgbColor(128);
```

**并创建一个对象，其三个组件被初始化为相同的值，从而产生一些灰色阴影；或者可能使用不同类型的参数，比如说一个`String`类型，这样调用:**

```
RgbColor color = new RgbColor("baby-blue");
```

**根据选择的颜色名称创建具有一些预定义值的对象。有些类型的默认值为 all is required 其他人必须明确接受某些论点；有些类型配备了令人印象深刻的构造函数集合，允许以多种方式创建对象。**

# **那么，它值多少钱呢？**

**因此，许多开发人员将构造函数视为某种类型的**语法糖**:语言中的一个元素，它可能会节省我们一些击键次数，并使我们的代码更加优雅。举个例子，这个:**

```
RgbColor(128)
```

**可替换为**

```
RgbColor(128, 128, 128)
```

**和**

```
RgbColor("baby-blue")
```

**可能会被表示颜色#89cff0 的实际值替换。或者我们可以使用一些返回组件值的辅助函数，给定一个带有颜色名称的字符串。事实上，即使是这条线**

```
RgbColor color = new RgbColor(50, 100, 150);
```

**也可以写成**

```
RgbColor color = new RgbColor();
color.red = 50;
color.green = 100;
color.blue = 150;
```

**或者，如果我们确保不允许直接访问对象的内部(*封装，对吗？*)，大概是这样的:**

```
RgbColor color = new RgbColor();
color.setRed(50);
color.setGreen(100);
color.setBlue(150);
```

**嗯，正如我们所说:句法糖。
大事。
整整一个帖子，就为了这个？
或者，也许，这不仅仅是另一种句法糖？**

# **一个对象与一组数据**

**事实上，ctor 函数是将我们称之为“对象”的独立实体与给定的相关数据集合区分开来的最重要的特性之一。定义新类型最重要的一个方面是确定该类型的所有对象必须遵守的规则:类型的**不变量**。对于像`RgbColor`这样的类，有非常简单的规则，如果有的话。这三个部分中的任何一个都必须有一个 0-255 范围内的值，包括 0 和 255。事实上，如果每个组件的类型都是单字节无符号整数，那么即使我们非常努力，我们也不能产生一个违反规则的对象。**

**但是当我们试图创建一个具有更严格规则的类的对象时会发生什么呢？**

**例如，假设我们有一个`Triangle`类，表示一个三角形。这里，任何该类型的对象都有三个字段，每边一个。因此，我们可以使用一个类似的 ctor，它接受三个值作为参数，**

```
Triangle triangle = new Triangle(30, 40, 50);
```

**或者可能使用一些其他的构造函数作为简写，例如，如果三角形的所有边都相同，使用以下形式:**

```
Triangle equilateral = new Triangle(100);
```

**与`color`的成分不同，`Triangle`的两侧很可能不会是`uint8`或`unsigned char`，而更像是`float`、`double`或它们的亲戚。另一方面，三角形各边的值受到严格的限制:*不是任何三个值都能组成一个三角形*。正如三角形不等式的规则所述，任何两条边的长度之和必须大于剩余边的长度，才能形成三角形。例如，值 20、30、100 不能是欧几里得三角形的长度。**

**当然，我们可能会尽量避免使用 ctors，就像我们为 RgbColor 演示的那样:**

```
Triangle triangle = new Triangle();
triangle.setA(30);
triangle.setB(40);
triangle.setC(50);
```

**通过这种方式，我们将获得与之前使用 ctor 创建的完全相同的`Triangle`，保存值 30、40 和 50。然而，使用这种方法，我们可能会意外地构建一个*非*三角形，如下所示:**

```
Triangle triangle = new Triangle();
triangle.setA(20);
triangle.setB(30);
triangle.setC(100);
```

**该对象不符合三角形的不变量，因此**无效**。**

# **如何处理不合法的价值观？**

**正如我们已经看到的，三联体〈 20，30，100 〉不能形成三角形。但这不仅仅是一个逻辑问题。我们可能用一个`Triangle`参数调用的任何函数或方法，必须事先决定如何处理这种情况。例如，假设我们想画一个三角形或计算它的面积:**

```
x = triangle.getArea();
draw(triangle);
```

**这些函数有**前提条件**，它们的参数必须满足这些前提条件才能运行。**

**一种选择是让每个这样的函数首先验证这些值没有破坏三角形不等式。如果不是这样，函数将根本不会运行，而是返回一个错误值/抛出一个异常/用一个断言暂停程序。只有前提条件得到满足，功能才能继续发挥其实际作用。另一种选择是假设参数有效性的责任在调用者而不是函数本身。在这种情况下，函数内部不会进行任何验证。**

## **备选方案 1:先决条件核查**

**第一种选择有很多问题:**

*   **每次调用都会浪费很多时间:如果我们想画一百次`Triangle`，我们就必须验证它的有效性一百次。**
*   **它需要对对象导出的许多 API 进行这样的验证——许多方法可能需要这样做，导致大量的代码重复。**
*   **反过来，这可能会导致忘记“这里和那里”的验证的高概率。**
*   **它打破了**单一责任原则**，以及方法的可读性。**
*   **那些自己调用其他方法的方法呢？这可能会导致每次调用都要进行几次不必要的验证。**
*   **这些对方法来说都是正确的，但是其他函数怎么能做到呢？例如，函数`draw()`可能不会得到一个`Triangle`作为参数，但也可以以多态的方式得到任何其他的`Shape`。那么，这种情况下的验证也必须是多态的。**

## **备选方案 2:无先决条件核查**

**另一种方式同样是个问题:它将全部责任强加给函数/方法的调用者，而这种方式，正如我们所知的，永远不会有好结果。我们当然可以假设在*某个*点，*某人*会使用错误的值调用那些函数，而不进行任何验证。接下来会发生什么？没人知道。在极端语言中，如 c++(T14)，这可能会导致任何未定义的行为，这取决于实际的函数代码和进程状态。在某种程度上更安全的语言中，这可能有希望以一些异常抛出结束，但这也是不确定的。例如，如果我们处理的不是三角形区域，而是数据库操作，那么对不构成有效对象**的值集合调用函数的结果可能是灾难性的。****

# **解决方法:永远不要制造问题**

**在希伯来语中，有一句话是这样说的*“一个聪明的人永远不会陷入只有聪明人才能摆脱的困境中”*。那么，解决办法就是变得明智。如果我们写一个系统，其中任何一个`Triangle`确实是一个三角形，那么任何接受`Triangle` s 作为参数的函数或方法都可以正常工作。不需要前提条件验证，不怕意外结果。**

**实现这一点的方法是遵守这两个简单的规则:**

1.  **创建这样一个对象的唯一*方法是使用一个 ctor(或者其他一些承担这个角色的函数)，它永远不会返回一个无效的对象***
2.  **这两者之一必须存在:
    - *要么*没有办法改变对象，一旦创建，
    - *或*改变对象的唯一方法是通过特定的方法/函数，保持其类型不变。**

**如果我们的对象遵守这两条规则，我们就可以安全地编写像`draw()`或`getArea()`这样的函数，因为它们的`Triangle`参数肯定是**有效的**，所以我们知道它们总是会像预期的那样工作。**

# **等等，有什么大不了的？这只是封装！**

**如果你有 OOP 方面的经验，你可能会对这篇文章的观点感到疑惑；毕竟这只是封装原理的演示。*为什么要投入一整篇帖子呢？***

**事实证明，许多所谓的好节目都有点忽略了这一点。例如，C++社区中的许多人，尤其是那些“老派”的家伙，他们在多年的 C 编程之后才开始接触 OOP(当时包括我在内！)，喜欢他们的类拥有某种`init()`成员功能。这种方法将构造函数(其唯一目的是*创建*某种样板对象)与其实际的*初始化*分开。背后的理念是,“创建”一个对象应该是简单的，就像创建一些集合或其他数据结构一样。另一方面，初始化可能是一个有许多结果的复杂过程，习惯于过程语言的人有时会被这样的想法吓坏，即这将作为新变量定义的“副产品”而发生，而不是在一个明确的、受监督的调用中发生。**

## **使用`init()` 功能**

**假设我们有类型为`Configuration`的对象，我们从某个文件中生成这些对象，然后使用它们的数据来配置我们的系统。根据这种方法，并保持单一责任原则，一段适当的代码可能看起来或多或少像这样:**

```
Configuration conf;
if (filename)
    conf.init(filename);
else
    conf.init(); // Use defaults/* ... anything here ...*/setMaxConns(conf);
```

**实际上，使用文件名进行初始化可能不会成功。该文件可能丢失。我们可能没有所需的访问权限。该文件的格式可能不正确。或者它可能包含非法值。这是使用单独的`init()`函数/方法的基本原理。事实上，由于初始化可能失败，必须添加一些**错误处理**代码— `init()`要么返回一个错误值，要么抛出一个异常(你可能知道[我对这个问题的看法](https://swarch.blog/exception-handling/))。因此，代码应该是这样的:**

```
Configuration conf;
try {
    if (filename)
        conf.init(filename); // Init conf's vals from the file
    else
        conf.init(); // Init conf's vals to the hard-coded defaults
} catch (/* relevant exception types come here */) {
    /* relevant error handling comes here */
}/* ... anything here ...*/setMaxConns(conf);
```

**嗯，我们现在有一个代码，据称保持—**

*   **封装的原则:对象的内部结构是隐藏的，访问它的唯一方法是使用该类型公开的 API。**
*   **单一责任原则:我们已经把一个对象的“创建”和它的“初始化”分开了。**

**不幸的是，以这种方式编写的代码(出现在许多现实世界的系统中)非常危险。原因很简单:在完成了`try` - `catch`块之后，有一个名为`conf`的`Configuration`类型的对象，我们在另一个函数`setMaxConns()`中使用了它，该函数假定它的参数是有效的。但是，在某些情况下，`conf`的值可能无效！当然，我们希望错误处理代码确保这种情况永远不会发生，这种情况永远不会存在；但是我们无法控制那段代码！这个代码不是我们的。我们只负责`Configuration`类的代码，不负责调用它的代码。**

**事实上，不太细心的开发人员甚至可能就像这样写下这两行代码，而不理解获得完全有效的功能对象所需的步骤:**

```
Configuration conf;
setMaxConns(conf);
```

**结果是，一个人可能会使用一个“半生不熟的”`Configuration`实例，它不遵守类的不变量，从而导致系统灾难。**

# **使用构造函数**

**如果我们遵守我们之前描述的两条规则，我们在上一段中看到的问题将永远不会出现:(1)配置实例的创建将仅被验证其有效性的 ctor 函数允许，以及(2)对这种现有对象的任何操作仅可能通过 API 进行，该 API 仅允许保持对象有效的操作。如果我们遵循这些规则，我们可以安全地调用像`setMaxConns(conf)`这样的函数，知道没有办法给它们传递非法值。像这样的一行**

```
Configuration conf;
```

**如果我们决定必须明确定义一个`Configuration`，那么*将使用默认值创建一个有效的对象*，或者*从不编译*。同样，类似于下面的一行:**

```
Configuration conf(filename);
```

**也不会创建无效的对象。我们的责任是确保如果它创建了一个对象，那么它是有效的、功能性的并且准备好工作。如果该函数不能使用所提供的参数创建这样的对象，它必须*根本不创建对象* (例如，通过抛出异常)或者创建一些其他有效的对象(例如，使用默认值；当然，这通常不是我们的首选，因为它只保留了 [**的基本保证**](https://swarch.blog/exception-handling/) ，但可能会有需要的情况)。现在，如果我们提供一个包含类`Configuration`的库，我们可以确定对它的函数的任何调用将总是发生在有效的对象上。**

# **语言为我们做了什么？**

**正如我在这篇文章的开头所说的，面向对象的设计有几个原则，然而，我认为构造函数是一个独立的概念，在某些方面甚至比三个“公共”原则更重要(尽管它可能被认为是“封装”的一个子原则)。原因是，在这一点上，在这个原则中，对编程语言的支持是极其重要的。**

**例如，让我们来看看像 c 这样的过程语言。即使用这样的语言编程，通常也有可能实现面向对象的原则。完整的细节超出了本文的范围，但一般来说，可以这样做:**

1.  ***封装:*我们将所有相关的数据保存在一个单一的类型`A`中，由一个单一的数据结构组成(例如，一个 C 的`struct`)，并且只允许通过指向`A`的指针上的函数来访问那些数据。**
2.  ***继承:*我们可以定义一个新的类型，`B`，它是一个`struct`，它的一个字段是类型`A`，这样就有了一个非常接近继承的关系。**
3.  ***多态性:*我们可以在对象(类型为`A`、`B`或其他)中保存指向函数的指针；然后，我们使用对象指向的函数，而不是在对象上调用一些硬编码的函数。这样，根据对象的类型，相同的调用可能导致运行不同的函数(在函数是一等公民的语言中，我们可以保存函数本身而不是指针)。**

**我们刚刚描述的范例保持了所有三个面向对象的原则，但是总有但是！有一个条件:**

**如果我们定义了某个`A`类型的“对象”，它实际上将是一个`struct A`类型的变量。该语言将允许直接访问该对象的任何字段。换句话说，我们实际上并没有实现封装。如果我们想实现封装，我们不能允许这样做。嗯，像 C 这样的语言确实为我们提供了一些手段来实现这一点:如果我们只公开`struct A`的**声明**，而不公开它的**定义**，那么如果不使用实际上知道`A`内部的 API 函数集，就不可能创建或访问类型`A`“objects】的字段。事实上，我们创建`A`对象的函数就是它的构造函数。*任务完成*。**

**然而，使用这种设计，我们将只能在**堆**上定义`A`对象，而不能在**栈**上定义。对于使用高级语言的程序员来说，这可能没什么意义，但它会带来一些后果，其中至少有两个后果非常关键:**

1.  **如果一个`A`对象包含的数据非常少，但是我们使用了很多这样的对象，那么我们将会有难以想象的内存浪费。**
2.  **任何一个`A`对象的创建或删除可能需要一些未知的时间，这取决于堆的状态。**

**这是我们的权衡:**可靠性**与**性能**。**

**另一方面，对构造函数有内置支持的语言允许我们享受所有世界的精华。通过允许在堆栈上创建新对象来实现性能，这可能会将花费的时间减少到 O(1)或甚至根本不花费时间。与此同时，通过仅通过 ctors 强制创建，可靠性得到了提高，从而确保没有可访问对象会破坏其类型不变量。**

# **对技术总监来说，未来会怎样？**

**研究两种现代语言所采用的方法是很有趣的，这两种语言都声称支持性能和可靠性——**Go**和 **Rust** 。顺便说一句，这两者对数据和动作的建模与传统的由 C++(以及它的表亲，如 Java，T30 或 T31 c#，T32)提供的 OOP 有很大的不同，这也是它们的目标。**

## **锈**

**在 **Rust** 中，一个 ctor 函数在语法上看起来与经典 OOP 模型中的有很大不同。然而，从语义上来说，允许只使用专用构造函数创建给定类型变量的概念在 Rust 的编码文化中广泛传播，并且受到该语言及其编译器的支持。**

**![](img/1c871d0ebbc076f5af332df2ecd255ef.png)**

**该语言不提供异常抛出机制。相反，其独特的错误处理模式允许非常相似的行为。如果构造函数中有错误，将不会返回“对象”。因此，如果函数确实创建了对象，同时保持我们在本文中讨论的原则，它可以安全地用于任何函数，而不用担心它的有效性。因此，这种语言提供了变量定义的性能和正确的向量工程的可靠性。**

## **去**

**在**走**的时候，恰恰相反，在两个方面都采取了完全相反的做法。首先，可以直接创建任何类型的任何变量，而无需调用任何函数。该变量将自动获得该类型的默认“零值”。如果零值是非法的(比如，当使用类型`Triangle`)那么，这是不相关的。仍然可以很容易地创建一个无效的对象。**

**![](img/6133db25cd02ebd6a79e1dba7479f4bc.png)**

**此外，Go 的错误处理方法并不保证任何函数中的失败——无论是在变量创建期间还是在操作变量时——都会阻止无效对象存在于相关范围内。那么，责任几乎完全在使用我们的包的代码上，我们不能利用语言和它的编译器的能力来阻止它。(就像在 C 中一样，可以创建更复杂的模型来允许使用 ctors 的概念；但是如果没有编译器的直接支持，我们将不得不再次处理性能/可靠性的权衡。)**

**这些是 Rust 和 Go 之间差异的少数但非常有代表性的例子——但关于这一点，我将在其他一些帖子中详细阐述。**