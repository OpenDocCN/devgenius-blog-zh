<html>
<head>
<title>DIY Air Transfer: Transmit and Receive data using GNU Radio and a Microphone</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DIY空中传输:使用GNU无线电和麦克风传输和接收数据</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/diy-air-transfer-transmit-and-receive-data-using-gnu-radio-and-a-microphone-f0adc8f1f563?source=collection_archive---------2-----------------------#2020-07-15">https://blog.devgenius.io/diy-air-transfer-transmit-and-receive-data-using-gnu-radio-and-a-microphone-f0adc8f1f563?source=collection_archive---------2-----------------------#2020-07-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6475687c36b12a4c1969315653f8dde5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7WTGC3PUcWXN7xit"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">阿列克谢·鲁班在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="79b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">今天，没有人对通过WiFi或蓝牙传输数据感到惊讶。但是有没有可能直接通过航空发送数据<em class="lb">？我将展示如何发送和接收数据，为此我们将使用OFDM和<a class="ae kc" href="https://wiki.gnuradio.org/index.php/Guided_Tutorial_GRC" rel="noopener ugc nofollow" target="_blank"> GNU Radio </a>创建一个简单的调制解调器实现。</em></p><p id="1197" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将通过空中传送数据——一个扬声器和一个麦克风就足以接收和传送数据。如果有人不熟悉GNU Radio，那么之前阅读或观看一些教程是有意义的，比如<a class="ae kc" href="https://hackaday.com/2015/11/11/getting-started-with-gnu-radio/" rel="noopener ugc nofollow" target="_blank">这个</a>或<a class="ae kc" href="https://www.youtube.com/watch?v=ufxBX_uNCa0" rel="noopener ugc nofollow" target="_blank">那个</a>。GNU Radio是跨平台的，可以在Windows、Linux和OSX上工作。</p><p id="76c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们的任务是使最简单的调制解调器能够将数据从A点传输到b点。调制数字信号有多种方法，我们将使用<a class="ae kc" href="https://en.wikipedia.org/wiki/Orthogonal_frequency-division_multiplexing" rel="noopener ugc nofollow" target="_blank"> OFDM </a> —一种在现代通信系统中广泛使用的方法。在OFDM中，使用快速傅立叶变换(FFT)将数字信号转换成几个并行的子载波，这提供了信道的高速和高效使用。OFDM被大量使用，从数字电视和无线电到LTE。就参数而言，我们的音频通道窄得多，也更严格，因此速度会更低，但基本上本质上没有变化。严格地说，OFDM并不是为通过空中传输数据而设计的，尽管对于小距离，传统的麦克风和扬声器就足够了。</p><h1 id="8412" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">GNU无线电中的OFDM</h1><p id="b1e8" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">最小连接图显示在图像上:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/ee083201f4a1183754459f328518e925.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8CzLzz3tuSs5MxL2.png"/></div></div></figure><p id="1fab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个纯文本文件被用作数据源(它可以包含类似“Hello World”的字符串)，然后数据被分成块，并被馈送到<strong class="kf ir"> OFDM发射机</strong>。OFDM是一种相当复杂的调制类型，在OFDM编码器的设置中我们需要指定很多不明显的参数。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mk"><img src="../Images/7ded0dc088ec3aef3914e98cbfeaf32f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2yhzov_EmZQgOyR1.png"/></div></div></figure><p id="670c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更详细的数值分析可以在<a class="ae kc" href="https://wiki.gnuradio.org/index.php/Basic_OFDM_Tutorial" rel="noopener ugc nofollow" target="_blank">这里</a>找到。当然，<strong class="kf ir"> OFDM接收机</strong>模块的参数必须与传输参数相匹配。</p><p id="f700" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">信道模型</strong>模块用于模拟通信信道，<strong class="kf ir"> QT GUI频率接收器</strong>模块用于可视化频谱。同样值得注意的是低采样频率(s/r=2400)，这样做是为了使信号占用适合音频通道的一小部分频谱。</p><p id="2772" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">遗憾的是，我没有在GNU Radio中找到显示接收数据的内置单元，所以我必须使用UDP。<strong class="kf ir"> UDP接收器</strong>模块用于输出数据。一个小的Python程序用于接收它:</p><pre class="mg mh mi mj gt ml mm mn mo aw mp bi"><span id="a5d9" class="mq ld iq mm b gy mr ms l mt mu">import socket</span><span id="5da0" class="mq ld iq mm b gy mv ms l mt mu">UDP_IP = "127.0.0.1"<br/>UDP_PORT = 40868</span><span id="3941" class="mq ld iq mm b gy mv ms l mt mu">sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) <em class="lb"># UDP</em><br/>sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)<br/>sock.bind((UDP_IP, UDP_PORT))<br/>sock.settimeout(0.5)</span><span id="a558" class="mq ld iq mm b gy mv ms l mt mu">while True:<br/>    try:<br/>        data, addr = sock.recvfrom(128) <br/>        print("Msg:", data, 'Hex:', ' '.join('{:02x}'.format(x) for x in data))<br/>    except socket.timeout:<br/>        pass</span></pre><p id="d56c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这使得我们可以在控制台中显示接收到的数据，这非常方便。也许有更简单的方法输出到GNU Radio，如果有人知道，请写在评论里。</p><p id="bb45" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果一切都做得正确，我们可以运行GNU Radio和Python脚本进行接收，结果应该如下所示:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/d5ab44587d9654a358283bc26f7b61a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*c6MEjx3Lbttnt7yO.png"/></div></div></figure><p id="f271" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看来这个题目可以做了？不，所有有趣的才刚刚开始。</p><h1 id="d8be" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">开始直播</h1><p id="83d0" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">在上面的例子中，一切都很简单。但是有一个“但是”——GNU Radio的工作原理是所谓的“复数信号”，实际上是一对相位相差90度的浮点数。这便于计算机处理，但我们不能只接收和广播一个复数。</p><p id="1787" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有两个选择。<strong class="kf ir"> SDR发射机</strong>的拥有者(HackRF，LimeSDR，USRP等。)可能不会进一步阅读，只是简单拿一个现成的GNU Radio的block，里面的一切都是“开箱即用”的。但是，由于我们要使用声卡传输信号，我们必须自己进行转换，为此，我们将使用许多DSP相关文章中描述的方法:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/4596295e5d0b8373a2ea5e8c3747c9e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/0*8EzHhsCLfC0n0hqo.png"/></div></figure><p id="8546" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里<strong class="kf ir"> OFDM </strong>是我们的发射机，<strong class="kf ir"> Fc </strong>是载波频率，我们将它设置为4KHz，以便信号适合扬声器和麦克风的最大灵敏度。传输图的框图也因此变得复杂:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/4cd6fa54fd1b473fb2e58b52f6a1fafc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZkTq7cSRfuYo-pmF.png"/></div></div></figure><p id="b4b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了便于测试，我使用了<strong class="kf ir"> WAV文件接收器</strong>，这样保存的文件可以单独录制和播放。我们还可以打开文件并查看其频谱，我们可以确保中心频率确实等于4KHz:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mz"><img src="../Images/4b96e6817e18c0e38ab6d60d89b9bcfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PKIsxG99VWncoosL.png"/></div></div></figure><h1 id="3ccb" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">接受</h1><p id="707a" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">最后，也是最后一步:我们将创建一个接收信号的连接图。在这里，其实一切都是一样的，只是顺序相反。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi na"><img src="../Images/da85b9fabff9b749f258359f3644e0ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/0*LL47oIa8idbbY6UO.png"/></div></figure><p id="07a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将原始信号乘以相移参考信号，然后在LPF的帮助下，我们切断高频成分。输出是可用于进一步处理的复信号。</p><p id="937d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">GNU电台的接收图如下:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/0ca3f8303dfe8ca74c3d6394940cc8fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SZtE27rF2GQW1tXu.png"/></div></div></figure><p id="b87b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我们可以看到用于从声卡接收数据的<strong class="kf ir">音频源</strong>模块，<strong class="kf ir"> QT GUI频率接收器</strong>模块用于显示接收到的信号。</p><p id="e710" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了测试，我在智能手机上录制了一个WAV文件，当我把它带到电脑的麦克风前时，解码后的文本出现在屏幕上:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/065395eb02a40fe9a07c36f8c96f44fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EJf6N69Hn6qPIs_y.png"/></div></div></figure><h1 id="4e3d" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="e370" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">正如我们所看到的，使用GNU Radio接收和发送信号是非常有趣和直观的。OFDM有相当多的参数，希望的人可以独立试验FFT块的大小、载波数、传输频率等。</p><p id="a35e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢阅读，祝各位实验成功。</p></div></div>    
</body>
</html>