<html>
<head>
<title>Serve HTTPS with Node.js and Nginx</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Node.js 和 Nginx 服务 HTTPS</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/serve-https-with-node-js-and-nginx-a758bd4be8a1?source=collection_archive---------0-----------------------#2022-11-27">https://blog.devgenius.io/serve-https-with-node-js-and-nginx-a758bd4be8a1?source=collection_archive---------0-----------------------#2022-11-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="419f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">🚀<a class="ae kl" href="https://learnbackend.dev/books/build-layered-microservices" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">打造分层微服务</strong> </a>这本书出来了！现在就在<a class="ae kl" href="https://learnbackend.dev/books/build-layered-microservices" rel="noopener ugc nofollow" target="_blank"> learnbackend.dev </a>购买你自己的副本。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/a1482416bc1c8a5026157309d2b8fbc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hq70yoQVaYG_vKQsyQ6rfw.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">使用 Nginx 处理 Node.js 应用程序的 HTTPs 流量</figcaption></figure><p id="bae9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不可否认，Node.js 是创建 web 应用程序的一个很好的工具，现在几乎在所有基于微服务的架构中都有使用。然而，在提供静态内容、跨多个实例的负载平衡、处理快速流量增长或在多个服务之间共享 SSL 证书时，Node.js 显示出一些缺点和漏洞。</p><p id="2b3c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们将了解如何利用<strong class="jp ir"> Nginx </strong>(发音为“engine x”)——这是一个由伊戈尔·塞索耶夫创建的免费开源 web 服务器，也可以用作反向代理、负载平衡器、邮件代理和 HTTP 缓存——来处理互联网流量，并通过 HTTPS 将其转发到一个简单的 Node.js 应用程序。</p><h1 id="a2f5" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">简单的 Node.js 应用程序</h1><p id="6a0f" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">出于本文的目的，我们将使用下面的 Node.js 服务器，该服务器监听端口<code class="fe mf mg mh mi b">8000</code>，并实现一个单独的<code class="fe mf mg mh mi b">GET /health</code>路由，该路由用包含服务正常运行时间和当前日期的 HTTP <code class="fe mf mg mh mi b">200 OK</code>进行响应。</p><p id="1fba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，让我们安装 Express 框架。</p><pre class="kn ko kp kq gt mj mi mk bn ml mm bi"><span id="b772" class="mn ld iq mi b be mo mp l mq mr">$ npm install express</span></pre><p id="0dce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将这个脚本添加到名为<code class="fe mf mg mh mi b">app.js</code>的文件中。</p><pre class="kn ko kp kq gt mj mi mk bn ml mm bi"><span id="0fd4" class="mn ld iq mi b be mo mp l mq mr">const express = require('express');<br/><br/>const app = express();<br/><br/>app.get('/health', (req, res) =&gt; res.json({<br/>  uptime: process.uptime(),<br/>  timestamp: Date.now(),<br/>}));<br/><br/>app.listen(8000);</span></pre><p id="dfd2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<code class="fe mf mg mh mi b">node</code>实用程序运行它。</p><pre class="kn ko kp kq gt mj mi mk bn ml mm bi"><span id="1bd5" class="mn ld iq mi b be mo mp l mq mr">$ node app.js</span></pre><p id="d82d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并使用下面的 cURL 命令验证服务器是否正常工作。</p><pre class="kn ko kp kq gt mj mi mk bn ml mm bi"><span id="7b95" class="mn ld iq mi b be mo mp l mq mr">$ curl http://127.0.0.1:8000/health</span></pre><p id="77fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它应该用一个类似的对象来响应。</p><pre class="kn ko kp kq gt mj mi mk bn ml mm bi"><span id="c997" class="mn ld iq mi b be mo mp l mq mr">{"uptime":173.158353287,"timestamp":1668018207202}</span></pre><h1 id="fa17" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">关于反向代理服务器</h1><p id="92d2" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在软件工程中，<strong class="jp ir">反向代理服务器</strong>是一个中介服务器，其作用是将来自多个客户端的请求转发到适当的后端服务器或服务，并返回它们的响应。</p><p id="46b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种类型的服务器通常用于:</p><ul class=""><li id="5c47" class="ms mt iq jp b jq jr ju jv jy mu kc mv kg mw kk mx my mz na bi translated"><strong class="jp ir">负载平衡</strong> —这意味着将请求分布在可用的服务器上，以最大化速度，同时确保没有人过载。</li><li id="5e92" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk mx my mz na bi translated"><strong class="jp ir"> Web 加速</strong> —包括压缩数据、缓存经常请求的内容或使用 SSL 加速来加速入站和出站流量。</li><li id="5dfc" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk mx my mz na bi translated"><strong class="jp ir">安全性</strong> —允许多个服务共享并使用相同的 SSL 证书进行数据加密。</li><li id="5893" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk mx my mz na bi translated"><strong class="jp ir">匿名</strong>——通过将所有请求指向一个单一的公开地址，使原始服务器看起来像一个整体，从而隐藏原始服务器的特征；这反过来有助于减少安全缺陷和 DoS 攻击。</li></ul><h1 id="ede4" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">将 Nginx 设置为反向代理服务器</h1><p id="6f62" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">让我们从使用<code class="fe mf mg mh mi b">apt</code>命令安装 Nginx 开始。请注意，<code class="fe mf mg mh mi b">-y</code>标志用于自动确认 Nginx 正常运行所需的附加包的安装。</p><pre class="kn ko kp kq gt mj mi mk bn ml mm bi"><span id="5605" class="mn ld iq mi b be mo mp l mq mr">$ sudo apt install nginx -y</span></pre><p id="3da3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于我们将使用 Nginx 作为 internet 流量和 Node.js 应用程序之间的中介，我们将对其进行配置，以便在端口 443(HTTPS 使用的默认端口)上发送的任何传入请求都会自动转发到端口 8000(node . js 应用程序正在侦听的端口)。</p><p id="2947" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，让我们首先在 Nginx 目录中创建一个名为<code class="fe mf mg mh mi b">ssl</code>的新目录，它将包含 SSL 证书和私钥。</p><pre class="kn ko kp kq gt mj mi mk bn ml mm bi"><span id="4292" class="mn ld iq mi b be mo mp l mq mr">$ sudo mkdir /etc/nginx/ssl</span></pre><p id="aed2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们使用<code class="fe mf mg mh mi b">openssl</code>命令生成一个自签名 SSL 证书。</p><pre class="kn ko kp kq gt mj mi mk bn ml mm bi"><span id="165a" class="mn ld iq mi b be mo mp l mq mr">$ sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/nginx/ssl/server.key -out /etc/nginx/ssl/server.crt</span></pre><p id="a117" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们使用 Vim 命令行文本编辑器打开位于<code class="fe mf mg mh mi b">/etc/nginx/sites-available</code>目录中的默认 Nginx 配置文件。</p><pre class="kn ko kp kq gt mj mi mk bn ml mm bi"><span id="0f35" class="mn ld iq mi b be mo mp l mq mr">$ sudo vim /etc/nginx/sites-available/default</span></pre><p id="8f39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，让我们用以下值更新配置文件。</p><pre class="kn ko kp kq gt mj mi mk bn ml mm bi"><span id="d7fd" class="mn ld iq mi b be mo mp l ng mr">server {<br/>  listen 443 ssl;<br/>  server_name _;<br/><br/>  ssl_certificate /etc/nginx/ssl/server.crt;<br/>  ssl_certificate_key /etc/nginx/ssl/server.key;<br/><br/>  location / {<br/>    proxy_pass http://localhost:8000;<br/>  }<br/>}</span></pre><p id="1f57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其中:</p><ul class=""><li id="454d" class="ms mt iq jp b jq jr ju jv jy mu kc mv kg mw kk mx my mz na bi translated"><code class="fe mf mg mh mi b">listen</code>指令允许端口<code class="fe mf mg mh mi b">443</code>上的 TLS/SSL 流量。</li><li id="2882" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk mx my mz na bi translated"><code class="fe mf mg mh mi b">server_name</code>指令允许定义服务器块应该应用于哪个域名——在这种情况下，下划线字符充当通配符，允许所有请求。</li><li id="5167" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk mx my mz na bi translated"><code class="fe mf mg mh mi b">ssl_certificate</code>指令指定从哪里加载公共 SSL 证书。</li><li id="69cc" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk mx my mz na bi translated"><code class="fe mf mg mh mi b">ssl_certificate_key</code>指令指定从哪里加载私钥。</li><li id="97fc" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk mx my mz na bi translated"><code class="fe mf mg mh mi b">proxy_pass</code>指令允许定义传入请求应该被重定向到的地址。</li></ul><p id="a1f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们使用<code class="fe mf mg mh mi b">service</code>命令启动 Nginx 服务器。</p><pre class="kn ko kp kq gt mj mi mk bn ml mm bi"><span id="d424" class="mn ld iq mi b be mo mp l mq mr">$ sudo service nginx start</span></pre><p id="bf69" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并使用下面的 cURL 命令测试我们的设置。请注意，<code class="fe mf mg mh mi b">-k</code>标志用于在“不安全模式”下运行 cURL，否则它会因为使用自签名证书而抛出错误。</p><pre class="kn ko kp kq gt mj mi mk bn ml mm bi"><span id="1b03" class="mn ld iq mi b be mo mp l mq mr">$ curl -k https://127.0.0.1/health</span></pre><h1 id="fbfe" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">最后的想法</h1><p id="0e80" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">最后，我应该提到，在生产中，自签名 SSL 证书无法工作，需要从可信的证书颁发机构(如 Cloudfare、DigiCert、GeoTrust 等)获取。我还鼓励您查看 Nginx 的官方文档，了解更多关于指令和高级配置的信息。</p><h1 id="f36e" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">下一步是什么？</h1><p id="a4eb" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">👉你喜欢这种内容？在<a class="ae kl" href="https://learnbackend.dev/" rel="noopener ugc nofollow" target="_blank"> https://learnbackend.dev </a>查看《如何使用 Express framework 构建生产就绪的分层认证微服务》一书<a class="ae kl" href="https://learnbackend.dev/books/build-layered-microservices" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">构建分层微服务</strong> </a>，该书从第一行代码到最后一行文档都符合开发实践和软件架构方面的行业标准。</p></div></div>    
</body>
</html>