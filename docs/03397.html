<html>
<head>
<title>How to deal with sorting algorithms: Merge Sort</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何处理排序算法:合并排序</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-deal-with-sorting-algorithms-merge-sort-4308de4b84eb?source=collection_archive---------5-----------------------#2020-10-29">https://blog.devgenius.io/how-to-deal-with-sorting-algorithms-merge-sort-4308de4b84eb?source=collection_archive---------5-----------------------#2020-10-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/60bfe4c46ddc50efcddf8a8e3191010e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f5hFPjdDoxiDimN01dOGuA.png"/></div></div></figure><p id="5aee" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">说到排序算法，人们应该永远记住:方法不止一种。上次我们谈到了<a class="ae kt" href="https://medium.com/dev-genius/how-to-deal-with-sorting-algorithms-insertion-sort-1c14fd4fdb24" rel="noopener">插入排序</a>并使用了一个未排序的数组。这次我们将尝试一种不同的方法和更复杂的模式— <strong class="jx io">合并排序</strong>。我们的starter pack是两个排序数组，我们的任务是将它们组合成一个排序数组。</p><p id="d0cd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们粉碎它！</p><p id="d539" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">实际上，我们的方法和上次插入排序没什么不同。我们的第一步是找到一个最小整数，并将其从数组中移除，但这次我们检查两个数组，而不是一个。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="1364" class="ld le in kz b gy lf lg l lh li">let firstHalf =  [2, 6, 7, 8, 11]<br/>let secondHalf =  [3, 4, 5, 9, 10] //our two sorted arrays</span><span id="93f5" class="ld le in kz b gy lj lg l lh li">function findMinAndRemove(firstHalf, secondHalf) {<br/>    let minfirstHalf = firstHalf[0]; <br/>    let minsecondHalf = secondHalf[0]; <br/>//here is first item of each array   </span><span id="4c82" class="ld le in kz b gy lj lg l lh li">if(minfirstHalf &lt; minsecondHalf) {<br/>        return firstHalf.shift()<br/>    } else {<br/>        return secondHalf.shift()<br/>    }<br/>}<br/>//The <strong class="kz io">shift()</strong> method removes the first element from an array and returns that removed element. This method changes the length of the array. </span><span id="afad" class="ld le in kz b gy lj lg l lh li">findMinAndRemove(firstHalf, secondHalf)<br/>//2</span><span id="3106" class="ld le in kz b gy lj lg l lh li">firstHalf<br/>//[6, 7, 8, 11]</span></pre><p id="4aa7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的第二步是——惊喜！—实际合并。在merge函数内部，我们将调用findMinAndRemove函数，直到其中一个数组为空，</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="8b91" class="ld le in kz b gy lf lg l lh li">function merge(firstHalf, secondHalf) {<br/>    let sortedArr = [];<br/>    let currentMin;</span><span id="928c" class="ld le in kz b gy lj lg l lh li">while(firstHalf.length != 0 &amp;&amp; secondHalf.length != 0) {<br/>//we need BOTH condition to be true to make the loop run and when <strong class="kz io">one of the arrays is empty</strong>, we know that the other one has only sorted elements, because well, it was a sorted array from the very beginning :)<br/>   <br/>    let currentMin = findMinAndRemove(firstHalf, secondHalf)<br/>        sorted.push(currentMin)<br/>//we add the minimum integer of both arrays<br/>     }<br/>    return sorted.concat(firstHalf).concat(secondHalf)<br/>}</span><span id="399b" class="ld le in kz b gy lj lg l lh li">//The <strong class="kz io">concat()</strong> method is used to merge two or more arrays. This method does not change the existing arrays, but instead returns a new array.</span></pre><p id="0f32" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是我们合并两个有序数组的方法。现在，让我们用同样的逻辑来处理<strong class="jx io">的一个无序数组</strong>。</p><p id="ac48" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以，我们应该采取的第一步是将一个无序的数组分割成子数组，直到每个元素都是一个独立的子数组。</p><p id="e1bf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的第二步是合并这些子阵列。重要提示:merge只适用于排序后的数组，所以当一个数组只有一个元素时，它会被自动排序。然后我们可以合并，直到它成为一个有序的数组。</p><p id="183d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是代码。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="f9d9" class="ld le in kz b gy lf lg l lh li">function mergeSort(array){<br/>let midpoint = array.length/2<br/>//first step - we split array every time we call a function<br/>let firstHalf = array.slice(0, midpoint)<br/>let secondHalf = array.slice(midpoint, array.length)</span><span id="6a0b" class="ld le in kz b gy lj lg l lh li">    if(array.length &lt; 2){<br/>       return array //when it's just one element, we return this one-element-array<br/>    } else {<br/>    merge(mergeSort(firstHalf), mergeSort(secondHalf))<br/>      }<br/>    }</span></pre><p id="4b5b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是排序和合并的基础。玩得开心！</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi lk"><img src="../Images/7299835663d8f1592a26c17fbda8a7e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/1*mnWW1bf03yyFtuIFPfQLKg.gif"/></div></figure></div></div>    
</body>
</html>