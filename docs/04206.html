<html>
<head>
<title>JavaScript Scopes Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解释了 JavaScript 作用域</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/javascript-scopes-and-closures-explained-8125844a6ca6?source=collection_archive---------5-----------------------#2021-02-09">https://blog.devgenius.io/javascript-scopes-and-closures-explained-8125844a6ca6?source=collection_archive---------5-----------------------#2021-02-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="37f2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">大家好，今天我将尝试解释什么是 JavaScript 作用域和闭包，以及如何通过真正理解作用域来正确地编写代码。所以，事不宜迟，让我们直接进入示波器，看看它们是怎么回事。</p><h1 id="4424" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">范围是什么？</h1><p id="bd15" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">在 JavaScript 中，作用域通常是定义如何访问变量的方式。它基本上在全局变量和局部变量之间画了线。主要有两种作用域:局部作用域和全局作用域。</p><h1 id="7bb9" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">全球范围</h1><p id="42de" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">在 JavaScript 中，当你在任何括号或函数之外定义一个变量时，你的变量被定义为一个全局变量，这意味着它可以被全局访问。不管你尝试使用变量的地方是一个函数还是一个有很多外部函数的嵌套函数。</p><p id="f8cb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是一种不受欢迎的行为，因为它通常会导致一些不可预测且难以发现的错误。更好的做法是通过使用作用域来限制变量的可用性。现在让我们来看看如何使用示波器。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="gh gi ll"><img src="../Images/703a4d8167212dd2f0d729ec1b349226.png" data-original-src="https://miro.medium.com/v2/resize:fit:694/format:webp/0*4EYRY9Mbm66Bcp1-.png"/></div></figure><h1 id="44a1" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">功能范围</h1><p id="ab46" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">当你在一个函数中定义一个变量的时候，你的函数将自动属于这个函数的作用域。让我们看看例子。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/665bac41a99336b0fa76f35855446c90.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/0*Taio55Xx4vnO7s_S.png"/></div></figure><p id="ca20" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如我们在上面看到的，虽然我们可以在“作用域”函数内部达到“一、二、三”,但是我们不能在它的外部达到同样的效果。</p><h1 id="30fb" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">嵌套函数</h1><p id="f3b9" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">在另一个函数中定义一个新函数是许多编程语言中广泛使用的做法。当你在 JavaScript 中定义一个嵌套函数时，内部函数可以到达外部函数，反之则不可能。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/ab8b28edcd53bc31deb93b586cfe3696.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/0*DhJ1wxJgQvfpjLCr.png"/></div></figure><p id="7047" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从上面我们可以看到，当“innerNest”函数可以到达“outer”变量时，“outerNest”函数不能到达“inner”变量。</p><h1 id="55f3" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">块范围</h1><p id="8a83" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">在添加了“let”和“const”之后，JavaScript 创建作用域的能力也随之改变。当你在任何带有“const”或“let”关键字的括号内定义一个变量时，它将自动属于那个作用域，而“var”的行为就像一个全局变量。让我们来看看。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi lv"><img src="../Images/5e8718db9b0e6b8b20322b397964332d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zPMG5GNCxyJyiqT3.png"/></div></div></figure><p id="ed6d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如我们在上面看到的，虽然我们可以很容易地在我们定义的“if check”之外找到“insideOfIfVar”变量，但我们不能对其他变量做同样的事情。</p><h1 id="49c1" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">模块范围</h1><p id="d3ee" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">中声明的所有内容。js”文件属于该特定文件，如果它们没有被显式导出。当你试图在模块之外访问一个变量而不导出它时，你很可能会看到类似这样的情况。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/16020083f644881f76e9eae63c3f38f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/0*j9eqMKn35gq9BEsA.png"/></div></figure><h1 id="6ff2" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">结论</h1><p id="a589" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">作用域是 JavaScript 的一个基本部分，因为它们是大多数其他语言的一部分，因此学习如何正确使用它们来编写像样的代码非常重要。</p><p id="851e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好了，各位，今天就到这里。我希望你喜欢它。下次见，保重:)</p></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><p id="aba9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mi">最初发表于</em><a class="ae mj" href="https://blog.akbuluteren.com/blog/javascript-scopes-and-closures-explained" rel="noopener ugc nofollow" target="_blank"><em class="mi">【https://blog.akbuluteren.com】</em></a><em class="mi">。</em></p></div></div>    
</body>
</html>