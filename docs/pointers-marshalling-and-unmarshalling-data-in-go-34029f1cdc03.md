# Go 中的指针、编组和解组数据

> 原文：<https://blog.devgenius.io/pointers-marshalling-and-unmarshalling-data-in-go-34029f1cdc03?source=collection_archive---------9----------------------->

![](img/060f34f82a6874f6eea128d9fafccc32.png)

这是我每周系列*学习围棋*的第九篇。上周我讲述了如何在 Go 中编写递归函数。本周我将讨论指针、JSON 编组和解组。

# 两颗北极指极星

虽然我过去听说过*指针*，但由于来自 JavaScript，这对我来说是一个全新的领域。尽可能简单地定义一个*指针*，一个*指针*:

> “指向”内存中存储值的位置

听起来很有语义，对吧？我有一种感觉，大多数人会从这个词本身推断出这一点；然而，*指针*有更多的含义。在我开始在 Go 中使用*指针*之前，让我解释一下 Go 中*指针*语法的几个重要部分。

在 Go 中，使用*指针*时需要记住两个运算符:

`&`←——该操作符生成该值在内存中的地址(生成一个*指针*)

`*`←——该操作符允许您检索*指针*的底层值

> 注意:这通常被称为“解引用”

让我们看一个这两个操作符的例子，我们从`&`操作符开始:

我们已经创建了第一个*指针*！

让我们一步一步地看看这里发生了什么:

在`func` `main`内部，我们声明了一个标识符为`name`的变量，其值为`martin`类型的`string`

接下来，使用`fmt`包，我们打印出`name`的内存值的*地址*

这将输出以下地址:`0xc000010200`

这可能现在看起来不是非常有用，但是让我向您展示如何使用这个地址来检索一个值:

让我一行一行地介绍一下这里发生的事情:

首先，我们声明一个标识符为`name`的新变量，其值为`martin`，类型为`string`

接下来，我们声明一个标识符为`namePointer`的新变量，其值为指向`name`变量的*指针*

当我们在下一行打印出`namePointer`的值时，我们接收到这个地址`0xc000010200`

接下来，我们声明一个标识符为`underlyingValue`的新变量，注意我们使用了`*`操作符，这允许我们获得一个*指针*值的*底层值*；因此，`underlyingValue`的值就是`namePointer`的*基础值*

我们在下一行打印出`underlyingValue`的值，我们看到它的值是`martin`

很酷吧。

*指针*允许我们在底层存储对数据的引用，它们在内存中的地址。

# JSON

JSON ( *JavaScript 对象符号*)是一种广泛使用的格式，用于在各种应用程序中发送和接收数据。在 Go 中，发送 JSON 和接收 JSON 时通常使用两种方法，`Marshal`和`Unmarshal`。

像 Go 生态系统中的大多数东西一样，这些函数的命名非常语义化。我们来看看`Marshal`和`Unmarshal`的定义。

> 编组—将对象的内存表示转换为用于存储或传输的数据格式的过程。当数据必须在应用程序的不同部分之间移动时，通常使用这种方法。

本质上，当您对数据使用`Marshal`函数(通常称为*编组*)时，您正在将数据转换为更适合存储或传输到应用程序中其他地方的格式。

> 解组—将用于存储或传输的对象表示转换为可执行的对象表示的过程

因为对 JSON 数据进行`Marshal`是一种常见的做法，所以可以使用`Unmarshal`函数将这些数据转换成可执行的格式(可以在应用程序中使用的格式)。

你可以在这里阅读更多关于编组和解组[的内容。](https://en.wikipedia.org/wiki/Marshalling_(computer_science))

让我给你看几个使用`Marshal`和`Unmarshal`的例子。

`Marshal`

让我带你看看这里发生了什么:

在`package` `main`中，我们现在正在导入`encoding/json`包，这允许我们使用`json`包

接下来，我们用类型`struct`的标识符`person`创建自己的类型

我们给我们的`person`类型三个字段:`string`类型的`First`、`String`类型的`Last`和`int`类型的`Age`

在我们的`func` `main`中，使用短声明操作符，我们用标识符`me`创建了一个新变量

为了给`me`赋值，我们使用了一个`person`类型的*复合文字*

在我们的*复合文本中，*我们为`person``type`:`First`->-`martin`、`Last`->-`cartledge`和`Age`->-`29`中的每个字段赋值

接下来，我们使用标识符为`bff`的短声明操作符创建另一个变量

`bff`的值也属于`person`类型

在这个*复合文字*中，为我们的`person`类型的每个字段分配的值是:`First` - > `mikel`、`Last` - > `howarth`和`Age` - > `29`

接下来，我们使用标识符为`friends`的短声明操作符创建一个新变量

`friends`的值将是`person`类型的`slice`，我们将`me`和`bff`的值传递给我们的*复合文字*

使用`fmt`包，我们打印`friends`的值

> 快速提示:调用`json.Marshal`时有两个返回值:
> 
> 1)一个结果
> 
> 2)一个错误
> 
> **结果**是一个`byte` ( `[]byte` )
> 
> **类型的`slice`错误**是一个`error`

对于这个例子，我给*结果*标识符`res`，给*错误*标识符`err`

我将`friends`作为单个参数传递给`json.Marshal()`，记住`friends`是类型`person`的`slice`

> 快速注意:在使用封送或取消封送后立即检查错误被认为是最佳实践，这可以防止数据中的任何错误或不一致渗透到代码中

接下来，我们检查`err` *的值是否不是* `nil`，如果这个值等于`true`，我们就进入这个 if 语句并运行我们的错误处理代码

对于这个例子，我们没有错误，所以我们的代码继续执行

`func` `main`中的最后一行使用了`fmt`包并记录了`res`的值，这是我们新整理的数据

这就是`res`后整理的价值:

如你所见，我们有一个`byte`类型的`slice`值，非常酷！

`Unmarshal`

让我带你看看这里发生了什么:

你会注意到我们正在导入`encoding/json`包，就像我们在前面的例子中做的一样，我们需要`json`包来使用`Marshal`和`Unmarshal`

我们还创建了一个新的带有标识符`person`的定制类型，它有三个字段:`string`类型的`First`、`string`类型的`Last`和`int`类型的`Age`

使用短声明操作符，我创建了一个标识符为`rawData`的新变量，并将其赋给 JSON 字符串中表示的`person`值的`slice`

在下一行，使用`fmt`包，我们打印出`rawData`的值

接下来，使用短声明操作符，我们用标识符`byteString`声明一个新变量，知道我们下一步要做什么吗？

没错，我们将`byteString`的值设置为`byte`类型值的`slice`。一旦我们将`rawData`值传递到我们的*复合文字*中，这一行就完成了

使用`fmt`包，我们打印出`byteString`的值

使用`var`关键字，我们创建一个标识符为`people`的新变量，它将是类型`person`(我们创建的自定义类型)的值的`slice`

这就是有趣的地方。注意我们只分配了一个返回值。这是因为`json.Unmarshal()`有两个参数，您希望*解组*或*解码*的*值，以及您希望将*解组的*数据分配给的变量的*指针*(内存中的地址)。*

按照惯例，接下来，我们立即检查错误，如果我们有一个错误，我们打印出来

> 注意:根据您的应用程序和您在解组后采取的操作，您可能希望停止所有的执行。我将在以后的帖子中谈到这一点

使用`fmt`包，我们打印出`people`的值。看那个！我们的数据和我们开始时一样，非常酷。

为了最大限度地使用我们的自定义类型`person`，我想迭代我们新的*解组的*数据并打印出它们的值

上面，我们使用了`for`关键字来创建一个`for`语句

这个`for`循环将为每次迭代返回两个值，一个`index`和一个`value`，我们将这些值分别赋给变量`i`和`v`

在`for`循环内部，使用`fmt`包，我们打印出`i` ( `index`)的值，在下一行我们打印出`person`类型中每个字段的值:`First`、`Last`和`Age`

以上是我们的结果，很酷吧？

# 概括起来

Go 使得创建和读取内存地址(`Pointers`)、编码数据(`json.Marshal`)和解码数据(`json.Unmarshal`)变得轻而易举。借助 Go 编程语言的这些特性，在整个应用程序中传递数据变得更加容易和高效。我希望您喜欢学习这些特性，如果您已经熟悉它们，我希望您离开时能够学到一些新的东西。下周我将讨论在 Go 中对数据进行排序。再见，感谢您的阅读！