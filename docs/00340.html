<html>
<head>
<title>Git-Forking Workflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">git-分叉工作流</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/git-forking-workflow-bbba0226d39c?source=collection_archive---------0-----------------------#2020-06-03">https://blog.devgenius.io/git-forking-workflow-bbba0226d39c?source=collection_archive---------0-----------------------#2020-06-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="d3c2" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">开源项目的工作流</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/2fcf9f267dfd59e1a7ee86af7b887084.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zaoK3JsROPdE3qHvopzBpA.png"/></div></div></figure><p id="126c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">要了解什么是工作流，请看一下<a class="ae lk" href="https://medium.com/swlh/git-workflow-7134b4eb9e5c" rel="noopener">这个</a>。</p><p id="f81c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">分叉工作流程</strong>与其他工作流程稍有不同。因为它为每个开发人员提供了自己的服务器端存储库。分叉工作流在开源项目中更常见。</p><p id="3870" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">分叉工作流的主要优点是，不需要每个人都推到一个单一的中央存储库就可以完成贡献。开发者推送到他们<strong class="kq io">自己的服务器端仓库</strong>，只有<strong class="kq io">项目维护者</strong>才能推送到官方仓库。这允许维护者接受来自任何开发者的提交，而不给他们对官方代码库的写访问权。</p><h2 id="7c8e" class="ll lm in bd ln lo lp dn lq lr ls dp lt kx lu lv lw lb lx ly lz lf ma mb mc md bi translated">它是如何工作的？</h2><ol class=""><li id="f8e3" class="me mf in kq b kr mg ku mh kx mi lb mj lf mk lj ml mm mn mo bi translated">一个开发者分支一个服务器端的仓库。这将创建它们自己的服务器端副本。</li><li id="2d8d" class="me mf in kq b kr mp ku mq kx mr lb ms lf mt lj ml mm mn mo bi translated">新的服务器端副本被克隆到他们的本地系统。</li><li id="6958" class="me mf in kq b kr mp ku mq kx mr lb ms lf mt lj ml mm mn mo bi translated">存储库的Git远程路径被添加到本地克隆中。</li><li id="75f6" class="me mf in kq b kr mp ku mq kx mr lb ms lf mt lj ml mm mn mo bi translated">将创建一个新的局部特征分支。</li><li id="a09b" class="me mf in kq b kr mp ku mq kx mr lb ms lf mt lj ml mm mn mo bi translated">开发人员对新分支进行更改，并为这些更改创建新的提交。</li><li id="36b2" class="me mf in kq b kr mp ku mq kx mr lb ms lf mt lj ml mm mn mo bi translated">分支被推送到开发人员自己的服务器端副本。</li><li id="523d" class="me mf in kq b kr mp ku mq kx mr lb ms lf mt lj ml mm mn mo bi translated">开发人员打开从新分支到存储库的拉请求。</li><li id="38d1" class="me mf in kq b kr mp ku mq kx mr lb ms lf mt lj ml mm mn mo bi translated">拉请求被批准合并，并被合并到原始的服务器端存储库中。</li></ol><h2 id="c9b2" class="ll lm in bd ln lo lp dn lq lr ls dp lt kx lu lv lw lb lx ly lz lf ma mb mc md bi translated">什么是分叉？</h2><p id="ceb8" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx mu kz la lb mv ld le lf mw lh li lj ig bi translated">没有唯一的Git命令来创建分叉的存储库。因为<strong class="kq io">分叉</strong>不是特殊操作。分叉库是使用标准的<strong class="kq io"> git clone </strong>命令创建的。分叉库通常是服务器端克隆，通常由第三方Git服务管理和托管，如Github。</p><p id="8868" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们看看它是怎么做的，</p><p id="c00e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">首先，主存储库被克隆，计划贡献的补丁的主题分支被创建，工作完成。</p><h2 id="8a8b" class="ll lm in bd ln lo lp dn lq lr ls dp lt kx lu lv lw lb lx ly lz lf ma mb mc md bi translated"><strong class="ak">序列</strong>为<strong class="ak">这个看起来是这样的</strong></h2><pre class="kd ke kf kg gt mx my mz na aw nb bi"><span id="bc94" class="ll lm in my b gy nc nd l ne nf">$ <strong class="my io">git clone </strong>&lt;url&gt;<br/>$ <strong class="my io">cd </strong>project<br/>$ <strong class="my io">git checkout </strong>-<strong class="my io">b</strong> featureA<br/>… work …<br/>$ <strong class="my io">git commit</strong><br/>… work …<br/>$ <strong class="my io">git commit<br/>...</strong></span></pre><p id="ec1f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当分支工作完成并准备反馈给维护人员时，点击<strong class="kq io">原始项目页面</strong>中的<strong class="kq io"> Fork </strong>按钮，现在创建了项目自己的可写分支。</p><p id="bc61" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后，将这个存储库URL作为新的远程存储库添加到本地存储库中。在这里，它被称为myFork</p><pre class="kd ke kf kg gt mx my mz na aw nb bi"><span id="78c3" class="ll lm in my b gy nc nd l ne nf">$ <strong class="my io">git remote add </strong>myFork &lt;url&gt;</span></pre><p id="a649" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，新的工作将被推送到这个存储库。很容易将正在处理的主题分支推送到分叉的存储库，而不是将工作合并到主分支中。</p><p id="51eb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">原因是如果工作不被接受，那么主分支不需要重绕。<br/>在任何情况下，工作都可以通过以下方式推进:</p><pre class="kd ke kf kg gt mx my mz na aw nb bi"><span id="61d6" class="ll lm in my b gy nc nd l ne nf">$ <strong class="my io">git push -u</strong> myFork featureA</span></pre><p id="7ec9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">一旦工作被推到了存储库的分支，为了合并工作，必须通知原始项目的维护者。</p><p id="44a4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这通常被称为<strong class="kq io">拉请求</strong>，它是使用<strong class="kq io"> git请求-拉</strong>命令完成的。</p><h2 id="1403" class="ll lm in bd ln lo lp dn lq lr ls dp lt kx lu lv lw lb lx ly lz lf ma mb mc md bi translated"><strong class="ak">考虑一下这个场景:</strong></h2><p id="ae53" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx mu kz la lb mv ld le lf mw lh li lj ig bi translated">如果<strong class="kq io">开发人员1 </strong>想要发送<strong class="kq io">开发人员2 </strong>一个拉请求，并且开发人员1已经在刚刚推送的主题分支上完成了两次提交，那么开发人员1可以运行这个:</p><pre class="kd ke kf kg gt mx my mz na aw nb bi"><span id="d9f9" class="ll lm in my b gy nc nd l ne nf">$ <strong class="my io">git request</strong>-<strong class="my io">pull </strong>origin/master myFork</span></pre><p id="d2f7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这将显示自提交以来所做的更改</p><p id="1617" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这个输出可以被发送给维护者，它告诉他们工作是从哪里分支的，总结提交，并确定新工作将从哪里提取。</p><p id="46b2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在一个项目中，如果一个人不是项目的维护者，那么让一个像master这样的分支总是跟踪origin/master，并在主题分支中完成您的工作通常会更容易，如果它们被拒绝，您可以很容易地丢弃它们。</p><p id="553f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">将工作主题隔离到主题分支中也使得在主存储库的尖端已经移动并且您的提交不再适用的情况下，重新确定工作的基础变得容易。</p><h2 id="5360" class="ll lm in bd ln lo lp dn lq lr ls dp lt kx lu lv lw lb lx ly lz lf ma mb mc md bi translated"><strong class="ak">例如，考虑这个场景</strong></h2><p id="51b5" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx mu kz la lb mv ld le lf mw lh li lj ig bi translated">如果要提交项目的第二个工作主题，不建议继续从主存储库的master分支向上推的同一个主题分支。</p><pre class="kd ke kf kg gt mx my mz na aw nb bi"><span id="9e63" class="ll lm in my b gy nc nd l ne nf">$ <strong class="my io">git checkout -b</strong> featureB origin/master<br/>… work …<br/>$ <strong class="my io">git commit</strong><br/>$ <strong class="my io">git push </strong>myFork featureB<br/>$ <strong class="my io">git request</strong>-<strong class="my io">pull </strong>origin/master myFork<br/>… email generated request pull to maintainer …<br/>$ <strong class="my io">git fetch </strong>origin</span></pre><p id="7426" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，每一个主题都可以被重写、调整和修改，而不会相互干扰或相互依赖:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ng"><img src="../Images/a4fa49f027758201a4fbf2943cd15a6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*71Bd6u0kcaD5oGGxJNYQYA.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">功能b工作的初始提交历史记录</figcaption></figure><p id="d785" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">假设项目维护者引入了一堆其他补丁，并尝试了现在已经创建的第一个分支，但是它不再清晰地合并。在这种情况下，这个分支可以基于<strong class="kq io"> origin/master </strong>之上，为维护者解决冲突，然后重新提交变更。</p><pre class="kd ke kf kg gt mx my mz na aw nb bi"><span id="c64b" class="ll lm in my b gy nc nd l ne nf">$ <strong class="my io">git checkout </strong>featureA<br/>$ <strong class="my io">git rebase </strong>origin/master<br/>$ <strong class="my io">git push -f</strong> myFork featureA</span></pre><p id="fc11" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这重写了历史，现在看起来像是一个作品后提交历史。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nl"><img src="../Images/b2c2fbfcf9ac4dd5a7cd940d876ba42a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2nltFIApbwADA7PTWxZK6Q.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">在功能后提交历史一个作品</figcaption></figure><p id="2607" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">由于分支被重置，为了能够替换服务器上的featureA分支，必须将<strong class="kq io"> -f </strong>指定给push命令。另一种方法是将这个新作品推送到服务器上不同的分支(可能称为featureAv2)。</p><h2 id="05c0" class="ll lm in bd ln lo lp dn lq lr ls dp lt kx lu lv lw lb lx ly lz lf ma mb mc md bi translated"><strong class="ak">让我们再看一个可能的场景:</strong></h2><p id="acdb" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx mu kz la lb mv ld le lf mw lh li lj ig bi translated">维护人员查看了第二个分支中的工作，喜欢这个概念，但希望开发人员更改实现细节。</p><p id="2083" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">考虑到这个机会，移动的工作，以该项目的目前掌握分支机构。</p><p id="8000" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">基于当前的源/主分支开始一个新分支，压缩那里的featureB更改，解决任何冲突，进行实现更改，然后将其作为新分支推进</p><pre class="kd ke kf kg gt mx my mz na aw nb bi"><span id="503c" class="ll lm in my b gy nc nd l ne nf">$ <strong class="my io">git checkout -b</strong> featureBv2 origin/master<br/>$ <strong class="my io">git merge </strong>— <strong class="my io">squash </strong>featureB<br/>… change implementation …<br/>$ <strong class="my io">git commit</strong><br/>$ <strong class="my io">git push </strong>myFork featureBv2</span></pre><p id="9293" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> squash </strong>选项将合并分支上的所有工作压缩到一个变更集中，产生存储库状态，就像发生了真正的合并一样，而不需要实际提交合并。</p><p id="dad9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这意味着任何未来的提交将只有一个父，这允许从另一个分支引入所有的更改，然后在记录新的提交之前进行更多的更改。</p><p id="97d8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">此时，可以通知维护人员请求的更改已经完成，并且可以在featureBv2分支中找到这些更改。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nl"><img src="../Images/2771cbec63d8646edaf2521246340b63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LHN3BiZCOqZ1Z3mSFMqKNA.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">featureBv2工作后提交历史记录</figcaption></figure></div><div class="ab cl nm nn hr no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ig ih ii ij ik"><p id="809b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这让我们对什么是分叉工作流以及它是如何工作的有了一个全面的了解。</p><div class="nt nu gp gr nv nw"><a href="https://twitter.com/DhayalCuber" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd io gy z fp ob fr fs oc fu fw im bi translated">达亚尔·拉朱</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">iOS开发者实习生@ivymobility，Speed Cuber，游戏玩家</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">twitter.com</p></div></div><div class="of l"><div class="og l oh oi oj of ok km nw"/></div></div></a></div></div></div>    
</body>
</html>