<html>
<head>
<title>Dependency Injection with Hilt (Kotlin)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Hilt 的依赖注入(Kotlin)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/dependency-injection-with-hilt-kotlin-562963c6c779?source=collection_archive---------1-----------------------#2022-01-05">https://blog.devgenius.io/dependency-injection-with-hilt-kotlin-562963c6c779?source=collection_archive---------1-----------------------#2022-01-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/a787c41b9b7496d8cfd81c287503ecac.png" data-original-src="https://miro.medium.com/v2/resize:fit:594/format:webp/1*6tHWmspyG-13IWjPk6BbjA.png"/></div></figure><p id="a135" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">一直以来，<strong class="jt io"> <em class="kp">匕首</em> </strong>被用来做<strong class="jt io"> <em class="kp">依赖注入</em> </strong>的操作。然而，<strong class="jt io"> <em class="kp">剑柄</em> </strong>最近已经作为一个 Jetpack 元素被包含在<strong class="jt io"> <em class="kp">匕首</em> </strong>上。通过这种方式，我们有了一个可以在 Android 上使用的更加简单有效的<strong class="jt io">依赖注入</strong>框架。</p><p id="ac73" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">那么，什么是<strong class="jt io">依赖注射</strong>？</p><h1 id="f175" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">依赖注入</h1><p id="6dce" class="pw-post-body-paragraph jr js in jt b ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ls km kn ko ig bi translated">最简单的形式，我们可以把它想象成一个自动化<strong class="jt io"> <em class="kp">实例</em> </strong>创建的库。通过例子解释可能更容易。所以，让我们创建一个 Android 应用程序。</p><p id="f1eb" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">1-)首先，将<strong class="jt io"><em class="kp">hilt-Android-gradle</em></strong>插件添加到你项目的根<strong class="jt io"> <em class="kp"> build.gradle </em> </strong>文件中:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="8cfb" class="mc kr in ly b gy md me l mf mg">buildscript {<br/>    ...<br/>    dependencies {<br/>        ...<br/>        classpath 'com.google.dagger:hilt-android-gradle-plugin:2.38.1'<br/>    }<br/>}</span></pre><p id="e989" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">2-)然后，应用 Gradle 插件并将这些依赖项添加到您的<strong class="jt io"><em class="kp">app/build . Gradle</em></strong>文件中:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="d4b5" class="mc kr in ly b gy md me l mf mg">...<br/>plugins {<br/>  id 'kotlin-kapt'<br/>  id 'dagger.hilt.android.plugin'<br/>}</span><span id="9b11" class="mc kr in ly b gy mh me l mf mg">android {<br/>    ...<br/>}</span><span id="9721" class="mc kr in ly b gy mh me l mf mg">dependencies {<br/>    implementation "com.google.dagger:hilt-android:2.38.1"<br/>    kapt "com.google.dagger:hilt-compiler:2.38.1"<br/>}</span></pre><p id="96ad" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">注意:</strong>使用 Hilt 的项目需要 Android Studio 4.0 或更高版本。</p><p id="f911" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">3- ) Hilt 使用 Java 8 特性。要在您的项目中启用 Java 8，请将以下内容添加到<strong class="jt io"><em class="kp">app/build . gradle</em></strong>文件中:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="b0c0" class="mc kr in ly b gy md me l mf mg">android {<br/>    ...<br/>    compileOptions {<br/>        sourceCompatibility JavaVersion.VERSION_1_8<br/>        targetCompatibility JavaVersion.VERSION_1_8<br/>    }<br/>}</span></pre><p id="963d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">好了，我们准备了一个可以用 Hilt 的 Android 项目。那么，我们开始吧。</p><h1 id="7678" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">刀柄应用等级</h1><p id="0e99" class="pw-post-body-paragraph jr js in jt b ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ls km kn ko ig bi translated">首先，我们需要做的第一件事是创建一个类。然后，从 Application 类继承这个类，我们必须用<strong class="jt io"> <em class="kp">标注我们创建的这个类。</em>T48】</strong></p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="ff67" class="mc kr in ly b gy md me l mf mg">@HiltAndroidApp<br/>class MyApplication : Application()</span></pre><p id="3b21" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们必须在清单文件中定义下面的行。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="2a4a" class="mc kr in ly b gy md me l mf mg">&lt;application<br/>    android:name=".MyApplication"<br/>    ...</span></pre><p id="f9a2" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这个生成的 Hilt 组件被附加到应用程序对象的生命周期中，并提供对它的依赖。此外，它是应用程序的父组件，这意味着其他组件可以访问它提供的依赖项。</p><h1 id="ae0c" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">将依赖注入 Android 类</h1><p id="c2cd" class="pw-post-body-paragraph jr js in jt b ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ls km kn ko ig bi translated">使用<em class="kp">的地方——例如</em> <strong class="jt io"> <em class="kp">活动</em> </strong> <em class="kp">或</em> <strong class="jt io"> <em class="kp">片段</em> </strong> <em class="kp"> - </em>我们必须打开相关的类并创建一个入口点作为<strong class="jt io"><em class="kp"/></strong>。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="825c" class="mc kr in ly b gy md me l mf mg">@AndroidEntryPoint<br/>class MainActivity : AppCompatActivity(){<br/>      ...<br/>}</span></pre><p id="a38b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">Hilt 目前支持以下 Android 类:</p><ul class=""><li id="64e7" class="mi mj in jt b ju jv jy jz kc mk kg ml kk mm ko mn mo mp mq bi translated">应用程序(通过使用<code class="fe mr ms mt ly b">@HiltAndroidApp</code></li><li id="94b9" class="mi mj in jt b ju mu jy mv kc mw kg mx kk my ko mn mo mp mq bi translated">ViewModel(通过使用<code class="fe mr ms mt ly b">@HiltViewModel</code></li><li id="8f1d" class="mi mj in jt b ju mu jy mv kc mw kg mx kk my ko mn mo mp mq bi translated">活动</li><li id="726c" class="mi mj in jt b ju mu jy mv kc mw kg mx kk my ko mn mo mp mq bi translated">碎片</li><li id="25d8" class="mi mj in jt b ju mu jy mv kc mw kg mx kk my ko mn mo mp mq bi translated">视角</li><li id="f709" class="mi mj in jt b ju mu jy mv kc mw kg mx kk my ko mn mo mp mq bi translated">服务</li><li id="a094" class="mi mj in jt b ju mu jy mv kc mw kg mx kk my ko mn mo mp mq bi translated">广播接收机</li></ul><p id="705b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果你用<code class="fe mr ms mt ly b">@AndroidEntryPoint</code>注释一个 Android 类，那么你也必须注释依赖于它的 Android 类。例如，如果您注释一个片段，那么您也必须注释任何使用该片段的活动。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><p id="6810" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">让我们以一个例子来研究<strong class="jt io"> <em class="kp">喷射类型</em> </strong>以使其更容易理解。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="0fc7" class="mc kr in ly b gy md me l mf mg">class Car(brand: Brand, engine: Engine) {</span><span id="b43a" class="mc kr in ly b gy mh me l mf mg">    fun information(){<br/>        <em class="kp">println</em>("Car information...")<br/>    }<br/>}</span><span id="31f7" class="mc kr in ly b gy mh me l mf mg">class Engine {<br/>    <br/>}</span><span id="f110" class="mc kr in ly b gy mh me l mf mg">class Brand {<br/>    <br/>}</span></pre><p id="aaf4" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们有一个汽车类，这个类从另外两个类中获取参数。虽然我们需要从 car 类创建一个对象，但我们也需要从<strong class="jt io"> <em class="kp"> Brand </em> </strong>和<strong class="jt io"> <em class="kp"> Engine </em> </strong>类创建一个对象。</p><p id="27a9" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">为了自动创建<strong class="jt io"> <em class="kp">实例</em> </strong>，即使用<strong class="jt io"> <em class="kp">句柄</em> </strong>，我们必须使我们现有的<strong class="jt io"> <em class="kp">类可注入</em> </strong>。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="e4d5" class="mc kr in ly b gy md me l mf mg">class Car @Inject constructor(brand: Brand, engine: Engine) {</span><span id="cc03" class="mc kr in ly b gy mh me l mf mg">    fun information(){<br/>        <em class="kp">println</em>("Car information...")<br/>    }<br/>    <br/>}</span><span id="8608" class="mc kr in ly b gy mh me l mf mg">class Engine @Inject constructor() {</span><span id="3800" class="mc kr in ly b gy mh me l mf mg">}</span><span id="a62d" class="mc kr in ly b gy mh me l mf mg">class Brand @Inject constructor() {</span><span id="dc90" class="mc kr in ly b gy mh me l mf mg">}</span></pre><h1 id="3bec" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">注射剂的种类</h1><blockquote class="ng nh ni"><p id="42de" class="jr js kp jt b ju jv jw jx jy jz ka kb nj kd ke kf nk kh ki kj nl kl km kn ko ig bi translated"><strong class="jt io">现场注射</strong></p></blockquote><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="fcc5" class="mc kr in ly b gy md me l mf mg">@AndroidEntryPoint<br/>class MainActivity : AppCompatActivity() {<br/>    // Field Injection<br/>    @Inject<br/>    lateinit var firstCar : Car</span><span id="2d59" class="mc kr in ly b gy mh me l mf mg">...<br/>    override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        setContentView(R.layout.<em class="kp">activity_main</em>)</span><span id="3f60" class="mc kr in ly b gy mh me l mf mg">firstCar.information()</span><span id="a2ff" class="mc kr in ly b gy mh me l mf mg">}</span></pre><blockquote class="ng nh ni"><p id="039c" class="jr js kp jt b ju jv jw jx jy jz ka kb nj kd ke kf nk kh ki kj nl kl km kn ko ig bi translated"><strong class="jt io">构造函数注入</strong></p></blockquote><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="7795" class="mc kr in ly b gy md me l mf mg">// Constructor Injection<br/>class Brand @Inject constructor()</span></pre><h1 id="1679" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">什么是范围？</h1><p id="ce65" class="pw-post-body-paragraph jr js in jt b ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ls km kn ko ig bi translated"><strong class="jt io"> <em class="kp">作用域</em> </strong>不是我们必须使用的<strong class="jt io"> <em class="kp">标注</em> </strong>。</p><p id="4e64" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">但是如果我们要使用它，我们需要按照下表来使用它。</p><figure class="lt lu lv lw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nm"><img src="../Images/42dcf09f682ab5af38ab029690948d0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VzxL_TiKu2K5lDQpeUHqTw.png"/></div></div></figure><p id="8462" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果我们在范围中指定 Hilt 将创建的实例将依赖于哪个类，我们就可以创建更健康的项目。</p><p id="4142" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">让我们在上面展示的汽车类中指定一个范围。首先，看看我们在哪里创建了 Car 类的实例。</p><p id="c9d9" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们创建的实例在 MainActivity 类中。所以这是一个<strong class="jt io">活动课。</strong>因此，我们有 3 种不同的范围可供选择。</p><ul class=""><li id="e90c" class="mi mj in jt b ju jv jy jz kc mk kg ml kk mm ko mn mo mp mq bi translated"><code class="fe mr ms mt ly b">@Singleton</code></li><li id="7d85" class="mi mj in jt b ju mu jy mv kc mw kg mx kk my ko mn mo mp mq bi translated"><code class="fe mr ms mt ly b">@ActivityRetainedScoped</code></li><li id="6021" class="mi mj in jt b ju mu jy mv kc mw kg mx kk my ko mn mo mp mq bi translated"><code class="fe mr ms mt ly b">@ActivityScoped</code></li></ul><p id="7917" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果我们在它们下面选择一个作用域，例如@FragmentScoped，应用程序将抛出一个错误。因为我们使用了类，所以我们在活动中创建了一个实例，而不是在片段中。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><p id="8ff2" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">那么，下面的问题应该出现在我们的脑海中，如果我们使用我们将在活动类和片段中创建实例的类，我们会做什么？</p><p id="37f2" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">答案很简单。在这两个范围中，应选择表中较高的一个。例如，如果我们在视图类和片段类中创建一个实例，我们应该查看表并选择 FragmentScope。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h1 id="5cd7" class="kq kr in bd ks kt nr kv kw kx ns kz la lb nt ld le lf nu lh li lj nv ll lm ln bi translated">界面问题</h1><p id="bf97" class="pw-post-body-paragraph jr js in jt b ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ls km kn ko ig bi translated">如何使用<strong class="jt io"> <em class="kp">刀柄</em> </strong>与<strong class="jt io"> <em class="kp">接口</em> </strong>一起工作？</p><p id="6491" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">让我们首先创建一个接口和一个实现它的类。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="a26e" class="mc kr in ly b gy md me l mf mg">interface MyInterface {</span><span id="cc49" class="mc kr in ly b gy mh me l mf mg">    fun myPrintFunction(): String</span><span id="469e" class="mc kr in ly b gy mh me l mf mg">}</span><span id="4735" class="mc kr in ly b gy mh me l mf mg">class MyInterfaceImplementor @Inject constructor() : MyInterface {</span><span id="aabe" class="mc kr in ly b gy mh me l mf mg">    override fun myPrintFunction(): String {<br/>        return "My Interface Implementor"<br/>    }</span><span id="b147" class="mc kr in ly b gy mh me l mf mg">}</span></pre><p id="24c0" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在让我们打开另一个类，使用我们创建的这个接口。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="9e27" class="mc kr in ly b gy md me l mf mg">class ClassExample @Inject constructor(<br/>    private val myInterfaceImplementor: MyInterface<br/>) {<br/>    fun myFunction(): String {<br/>        return "Working:${myInterfaceImplementor.myPrintFunction()}"<br/>    }<br/>}</span></pre><p id="cd79" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们不能从接口创建对象。因此，我们需要我们创建的 InterfaceImplementor 类来使用 Interface。但是我们还没有在上面的类中做这样的定义。</p><p id="da00" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">因此，如果我们试图运行下面的活动，我们将得到一个错误。因为我们没有告诉<strong class="jt io"> <em class="kp">刀柄</em> </strong>如何初始化<strong class="jt io"> <em class="kp">接口。</em></strong></p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="f0e8" class="mc kr in ly b gy md me l mf mg">@AndroidEntryPoint<br/>class MainActivity : AppCompatActivity() {</span><span id="e2be" class="mc kr in ly b gy mh me l mf mg">    @Inject<br/>    lateinit var myClass : ClassExample</span><span id="5ab0" class="mc kr in ly b gy mh me l mf mg">    override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        setContentView(R.layout.<em class="kp">activity_main</em>)</span><span id="9bf1" class="mc kr in ly b gy mh me l mf mg"><em class="kp">println</em>(myClass.myFunction())</span></pre></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h1 id="cc01" class="kq kr in bd ks kt nr kv kw kx ns kz la lb nt ld le lf nu lh li lj nv ll lm ln bi translated">模块</h1><p id="e435" class="pw-post-body-paragraph jr js in jt b ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ls km kn ko ig bi translated">当使用<strong class="jt io">模块</strong>时，我们需要使用<strong class="jt io">安装注释</strong>。在 InstallIn 注释中，我们需要根据上面提到的表格给出一个<strong class="jt io">组件</strong>。</p><blockquote class="ng nh ni"><p id="a11a" class="jr js kp jt b ju jv jw jx jy jz ka kb nj kd ke kf nk kh ki kj nl kl km kn ko ig bi translated"><strong class="jt io">@绑定</strong></p></blockquote><p id="6d35" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果我们使用这个方法，我们将创建的类和函数必须是<strong class="jt io">抽象的</strong>。根据 InstallIn 注释中给出的组件，我们应该给出一个方便函数的作用域。</p><p id="bf96" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">例如:</p><ul class=""><li id="1cd7" class="mi mj in jt b ju jv jy jz kc mk kg ml kk mm ko mn mo mp mq bi translated">@ install in(Singleton component::class)= &gt; @ Singleton</li><li id="c593" class="mi mj in jt b ju mu jy mv kc mw kg mx kk my ko mn mo mp mq bi translated">@ install in(activity component::class)= &gt; @ activity scoped</li><li id="4306" class="mi mj in jt b ju mu jy mv kc mw kg mx kk my ko mn mo mp mq bi translated">@ InstallIn(fragment component::class)= &gt; @ FragmentScoped</li></ul></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="de14" class="mc kr in ly b gy md me l mf mg">@InstallIn(SingletonComponent::class)<br/>@Module<br/>abstract class MyModule {<br/>    <br/>    @Singleton<br/>    @Binds<br/>    abstract fun bindingFunction(myImplementor: MyInterfaceImplementor) : MyInterface</span><span id="ef90" class="mc kr in ly b gy mh me l mf mg">}</span></pre><blockquote class="ng nh ni"><p id="8d85" class="jr js kp jt b ju jv jw jx jy jz ka kb nj kd ke kf nk kh ki kj nl kl km kn ko ig bi translated"><strong class="jt io">@提供</strong></p></blockquote><p id="192f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这是 Android 希望我们使用的方法，在我看来，这比以前的方法更容易。我们所要做的就是告诉这个函数，它将返回一个<strong class="jt io"> <em class="kp">接口</em> </strong>，这个接口将是我们之前创建的<strong class="jt io"> <em class="kp">实现者</em> </strong>。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="55a3" class="mc kr in ly b gy md me l mf mg">@InstallIn(ActivityComponent::class)<br/>@Module<br/>class MyModule {</span><span id="0a47" class="mc kr in ly b gy mh me l mf mg">    @ActivityScoped<br/>    @Provides<br/>    fun providerFunction() : MyInterface {<br/>        return MyInterfaceImplementor()<br/>    }<br/>}</span></pre><p id="f554" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这种方法更适合与外部库一起使用。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h1 id="8107" class="kq kr in bd ks kt nr kv kw kx ns kz la lb nt ld le lf nu lh li lj nv ll lm ln bi translated">问题:接口被多次绑定！</h1><p id="2db9" class="pw-post-body-paragraph jr js in jt b ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ls km kn ko ig bi translated">我们只有一个接口和一个实现它的类。那么，如果我们有许多实现一个接口实现者类会怎么样呢？</p><p id="c778" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们必须使用更多的解释性注释。因此，我们必须创建自己的注释。</p><blockquote class="ng nh ni"><p id="0fdf" class="jr js kp jt b ju jv jw jx jy jz ka kb nj kd ke kf nk kh ki kj nl kl km kn ko ig bi translated">在这种情况下，我们有一个接口和两个实现者，如下所示:</p></blockquote><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="54b5" class="mc kr in ly b gy md me l mf mg">interface MyInterface {</span><span id="e6bf" class="mc kr in ly b gy mh me l mf mg">    fun myPrintFunction(): String</span><span id="8302" class="mc kr in ly b gy mh me l mf mg">}</span><span id="dc0c" class="mc kr in ly b gy mh me l mf mg">class MyInterfaceImplementor @Inject constructor(): MyInterface {</span><span id="281f" class="mc kr in ly b gy mh me l mf mg">    override fun myPrintFunction(): String {<br/>        return "My Interface Implementor"<br/>    }</span><span id="9729" class="mc kr in ly b gy mh me l mf mg">}</span><span id="f051" class="mc kr in ly b gy mh me l mf mg">class SecondInterfaceImplementor @Inject constructor() : MyInterface {</span><span id="23aa" class="mc kr in ly b gy mh me l mf mg">    override fun myPrintFunction(): String {<br/>        return "My Second Interface Implementor"<br/>    }</span><span id="b33b" class="mc kr in ly b gy mh me l mf mg">}</span></pre><p id="fd0a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">同样，我们使用这些<strong class="jt io">接口</strong>和<strong class="jt io">实现者</strong>的类应该如下。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="6f13" class="mc kr in ly b gy md me l mf mg">class ClassExample @Inject constructor(<br/>    private val myInterfaceImplementor: MyInterface,<br/>    private val mySecondInterfaceImplementor: MyInterface<br/>) {</span><span id="33ca" class="mc kr in ly b gy mh me l mf mg">    fun myFunction(): String {<br/>        return "Working: ${myInterfaceImplementor.myPrintFunction()}"<br/>    }</span><span id="c965" class="mc kr in ly b gy mh me l mf mg">    fun secondFunction(): String {<br/>        return "Working: ${mySecondInterfaceImplementor.myPrintFunction()}"<br/>    }</span><span id="a958" class="mc kr in ly b gy mh me l mf mg">}</span></pre><p id="1017" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">最后，在我们的<strong class="jt io"> <em class="kp">模块类</em> </strong>中，我们必须定义我们添加的第二个实现者类。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="5c59" class="mc kr in ly b gy md me l mf mg">@InstallIn(SingletonComponent::class)<br/>@Module<br/>class MyModule {</span><span id="95ac" class="mc kr in ly b gy mh me l mf mg">    @Singleton<br/>    @Provides<br/>    fun providerFunction() : MyInterface {<br/>        return MyInterfaceImplementor()<br/>    }</span><span id="53eb" class="mc kr in ly b gy mh me l mf mg">    @Singleton<br/>    @Provides<br/>    fun secondProviderFunction() : MyInterface {<br/>        return SecondInterfaceImplementor()<br/>    }<br/>}</span></pre><blockquote class="ng nh ni"><p id="b571" class="jr js kp jt b ju jv jw jx jy jz ka kb nj kd ke kf nk kh ki kj nl kl km kn ko ig bi translated">我们什么都做了。有什么问题吗？为什么我的应用程序无法运行？</p></blockquote><p id="f522" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">因为我们已经将两个不同的实现者连接到一个接口，并且我们使用了来自这些实现者的两个不同的函数。</p><p id="0d9a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们在<strong class="jt io">模块类</strong>中编写的函数返回 MyInterface。但是<strong class="jt io"> <em class="kp">句柄</em> </strong>从 MyInterface 中找不到使用哪个<strong class="jt io"> <em class="kp">实现者</em> </strong>。所以我们需要更详细的描述。</p><h1 id="433f" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">创建我们自己的注释</h1><p id="2b1e" class="pw-post-body-paragraph jr js in jt b ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ls km kn ko ig bi translated">我们为两个不同的实现者创建了两个不同的注释，如下所示。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="234e" class="mc kr in ly b gy md me l mf mg">@Qualifier<br/>@Retention(AnnotationRetention.<em class="kp">BINARY</em>)<br/>annotation class FirstImplementor</span><span id="0276" class="mc kr in ly b gy mh me l mf mg">@Qualifier<br/>@Retention(AnnotationRetention.<em class="kp">BINARY</em>)<br/>annotation class SecondImplementor</span></pre><p id="e146" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">使用这些注释，我们可以告诉<strong class="jt io"> <em class="kp">柄</em> </strong>实现者将使用哪些类。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="7222" class="mc kr in ly b gy md me l mf mg">@InstallIn(SingletonComponent::class)<br/>@Module<br/>class MyModule {</span><span id="7006" class="mc kr in ly b gy mh me l mf mg">    @FirstImplementor<br/>    @Singleton<br/>    @Provides<br/>    fun providerFunction() : MyInterface {<br/>        return MyInterfaceImplementor()<br/>    }</span><span id="e09f" class="mc kr in ly b gy mh me l mf mg">    @SecondImplementor<br/>    @Singleton<br/>    @Provides<br/>    fun secondProviderFunction() : MyInterface {<br/>        return SecondInterfaceImplementor()<br/>    }<br/>}</span></pre><p id="23e6" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">然后，在我们使用实现者的类中，我们需要告诉构造函数我们已经创建了这些注释。</p><p id="8bf6" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如下所示:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="f883" class="mc kr in ly b gy md me l mf mg">class ClassExample @Inject constructor(<br/>    @FirstImplementor private val myInterfaceImplementor: MyInterface,<br/>    @SecondImplementor private val mySecondInterfaceImplementor: MyInterface<br/>) {}</span></pre></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><p id="f3ee" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这就是使用 Hilt 进行依赖注入的目的。感谢您的阅读。我希望这是对你有用的内容。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><p id="de6d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在创建这个资源时，我使用了<a class="ae nw" href="https://developer.android.com/training/dependency-injection/hilt-android" rel="noopener ugc nofollow" target="_blank"> Android 开发者文档</a>。如果需要，您可以通过单击链接来查看源代码。</p><figure class="lt lu lv lw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nx"><img src="../Images/4e3939610e5a6e054dbbbe36d1383192.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NJ5MITp3uyNY6DRh"/></div></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk translated"><a class="ae nw" href="https://unsplash.com/@redaquamedia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">丹尼·米勒</a>在<a class="ae nw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure></div></div>    
</body>
</html>