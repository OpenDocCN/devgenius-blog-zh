<html>
<head>
<title>MCRTIP #1 / difficult about simple</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MCRTIP #1 /简单的困难</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/mcrtip-1-difficult-about-simple-2df82ad79e52?source=collection_archive---------5-----------------------#2022-05-21">https://blog.devgenius.io/mcrtip-1-difficult-about-simple-2df82ad79e52?source=collection_archive---------5-----------------------#2022-05-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/5887d3f8cee70820ae2f51906debe7f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XtoCyCJ5F-DgtTvGfUmOUQ.jpeg"/></div></div></figure><blockquote class="jv jw jx"><p id="d71e" class="jy jz ka kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> MCRTIP </strong>只是我对编程的一些想法的汇编。仅依我看。</p></blockquote><h2 id="5b4c" class="kx ky in bd kz la lb dn lc ld le dp lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">今天我们来谈谈:</h2><ol class=""><li id="e851" class="lt lu in kb b kc lv kg lw lg lx lk ly lo lz kw ma mb mc md bi translated">用<strong class="kb io">三元运算</strong>代替<strong class="kb io"> if/else 语句</strong></li><li id="ec35" class="lt lu in kb b kc me kg mf lg mg lk mh lo mi kw ma mb mc md bi translated"><strong class="kb io">对象【案例】</strong>而不是<strong class="kb io">开关/案例</strong></li><li id="99e8" class="lt lu in kb b kc me kg mf lg mg lk mh lo mi kw ma mb mc md bi translated"><strong class="kb io">合成</strong>和<strong class="kb io">分解</strong></li><li id="f6ee" class="lt lu in kb b kc me kg mf lg mg lk mh lo mi kw ma mb mc md bi translated"><strong class="kb io"> CSS-IN-JS </strong>和<strong class="kb io">原生 html 标签</strong></li><li id="930f" class="lt lu in kb b kc me kg mf lg mg lk mh lo mi kw ma mb mc md bi translated"><strong class="kb io">数学题<em class="ka">数学题</em>数学题</strong>而不是关于<strong class="kb io">数学题</strong></li></ol><h1 id="e120" class="mj ky in bd kz mk ml mm lc mn mo mp lf mq mr ms lj mt mu mv ln mw mx my lr mz bi translated">#1 |使用三元运算代替 if/else 语句。</h1><p id="23ac" class="pw-post-body-paragraph jy jz in kb b kc lv ke kf kg lw ki kj lg na km kn lk nb kq kr lo nc ku kv kw ig bi translated"><strong class="kb io">不喜欢 if/else 语句，</strong></p><p id="9a0e" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj lg kl km kn lk kp kq kr lo kt ku kv kw ig bi translated">这真的很难解释为什么，但当我看到<strong class="kb io"> <em class="ka"> if </em> </strong>语句时，我总是用三元运算重写它。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="85a3" class="kx ky in ni b gy nm nn l no np">if (condition) {<br/> action1()<br/>} else {<br/> action2()<br/>}</span></pre><p id="bba9" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj lg kl km kn lk kp kq kr lo kt ku kv kw ig bi translated">我认为<strong class="kb io"> <em class="ka"> if </em> </strong>语句看起来像一个肮脏的黑客，但这是一个非常有争议的案例。当你使用它的时候，你只是说你有一些特殊的情况，当默认计算不合适的时候。</p><blockquote class="jv jw jx"><p id="813d" class="jy jz ka kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">B <em class="in"> ut 当你</em>实现<em class="in">一个算法的时候——你可以使用它。</em></p></blockquote><h2 id="f560" class="kx ky in bd kz la lb dn lc ld le dp lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated"><strong class="ak"> <em class="nq">为什么我不喜欢 if 语句:</em> </strong></h2><ol class=""><li id="3a34" class="lt lu in kb b kc lv kg lw lg lx lk ly lo lz kw ma mb mc md bi translated"><strong class="kb io"> <em class="ka">如果</em> </strong>看起来像一个肮脏的黑客，我们使用另一个不适合其他规则的规则来处理当前值。</li><li id="97f5" class="lt lu in kb b kc me kg mf lg mg lk mh lo mi kw ma mb mc md bi translated"><strong class="kb io"> <em class="ka">如果</em> </strong>是语句，我喜欢用表达式代替语句。</li><li id="cffa" class="lt lu in kb b kc me kg mf lg mg lk mh lo mi kw ma mb mc md bi translated">当我声明一个变量时，我不能使用<strong class="kb io"> <em class="ka">如果</em> </strong> <em class="ka"> </em>但是使用三元运算对我有帮助。</li><li id="f15a" class="lt lu in kb b kc me kg mf lg mg lk mh lo mi kw ma mb mc md bi translated">对于自动化和给你的函数添加多态性- <strong class="kb io"> <em class="ka">切换</em> </strong>更容易理解。</li><li id="5f88" class="lt lu in kb b kc me kg mf lg mg lk mh lo mi kw ma mb mc md bi translated">通常低级编程语言不会为数据类型<strong class="kb io">提供内置方法，但是在高级编程语言中</strong>会提供内置方法，通常这些方法使用封装。<strong class="kb io"> <em class="ka">通常是</em> </strong>，如果你在类中传递一些参数——这个类建议你改变输入参数的方法<em class="ka">。</em> <strong class="kb io"> <em class="ka">接下来是</em> </strong>，你关于输入值的异常行为和为这些情况添加检查的想法已经实现，你所有的<strong class="kb io"> <em class="ka"> if </em> </strong>操作你也使用过。<strong class="kb io"> <em class="ka">随便用。</em>T79】</strong></li></ol><blockquote class="jv jw jx"><p id="a937" class="jy jz ka kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">当然，当我谈论<strong class="kb io"> if </strong>时，我指的是在 if 语句中不能使用 return 替换 else 块的情况<strong class="kb io">。</strong></p></blockquote><p id="6b52" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj lg kl km kn lk kp kq kr lo kt ku kv kw ig bi translated">我更喜欢三进制运算<strong class="kb io">，但是</strong>如果你只是在编程——你可以想:“只有在语句使用三进制时，我才能替换<strong class="kb io">？”。<strong class="kb io"> <em class="ka">没办法。不可能。酪</em> </strong>我用<strong class="kb io"> <em class="ka">逻辑运算</em> </strong>。</strong></p><p id="17f4" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj lg kl km kn lk kp kq kr lo kt ku kv kw ig bi translated">我不知道为什么，但我很少看到开发人员使用不带语句的逻辑运算的情况。同时，我在任何可能的地方和真正需要的地方使用它。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="d0b3" class="kx ky in ni b gy nm nn l no np">const fbi_bd = [<br/>  { name: "John Alvin", arrested: true, age: 35 },<br/>  { name: "John Paul", arrested: true, age: 21 },<br/>  { name: "John Doe", arrested: false, age: 23 }, <br/>  { name: "John Doe", arrested: false, age: 19 }, <br/>];</span><span id="21a4" class="kx ky in ni b gy nr nn l no np">const names = ["John Paul", "John Alvin"];<br/>const criminals = [];</span><span id="bc2a" class="kx ky in ni b gy nr nn l no np">const arrested = fbi_bd.forEach((criminal) =&gt; {<br/>  if (criminal.arrested === true &amp;&amp; criminal.age &gt;= 20) {<br/>    if (names.filter(name =&gt; name === criminal.name)) {<br/>      criminals.push(criminal);<br/>    } else {<br/>      criminals.push("-")<br/>    }<br/>  } else if (criminal.age &lt;= 20) {<br/>    criminals.push([criminal, "young"]);<br/>  } else {<br/>    return criminal;<br/>  }<br/>});</span><span id="e8ff" class="kx ky in ni b gy nr nn l no np">console.warn(criminals);</span></pre><p id="c52b" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj lg kl km kn lk kp kq kr lo kt ku kv kw ig bi translated">使用逻辑运算，我们可以更新这个。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="423c" class="kx ky in ni b gy nm nn l no np">const fbi_bd = [<br/>  { name: "John Alvin", arrested: true, age: 35 },<br/>  { name: "John Paul", arrested: true, age: 21 },<br/>  { name: "John Doe", arrested: false, age: 23 }, <br/>  { name: "John Doe", arrested: false, age: 19 }, <br/>];</span><span id="56c3" class="kx ky in ni b gy nr nn l no np">const names = ["John Paul", "John Alvin"];<br/>const criminals = [];</span><span id="55f1" class="kx ky in ni b gy nr nn l no np">const arrested = fbi_bd.forEach((criminal) =&gt; {<br/>  criminal.arrested === true &amp;&amp; criminal.age &gt;= 20<br/>  ?<br/>    names.filter(name =&gt; name === criminal.name) &amp;&amp; criminals.push(criminal)<br/>    || criminals.push("-")<br/>  : criminal.age &lt;= 20 <br/>    ? criminals.push([criminal, "young"])<br/>    : criminal<br/>});</span><span id="b933" class="kx ky in ni b gy nr nn l no np">console.warn(criminals);</span></pre><blockquote class="jv jw jx"><p id="77e0" class="jy jz ka kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我<!-- -->同意，这只是一个有争议的情况，你可以用<strong class="kb io"> if </strong>代替三元运算。</p></blockquote><h1 id="513b" class="mj ky in bd kz mk ml mm lc mn mo mp lf mq mr ms lj mt mu mv ln mw mx my lr mz bi translated">#2 |使用 object[key]而不是 switch/case</h1><p id="deb6" class="pw-post-body-paragraph jy jz in kb b kc lv ke kf kg lw ki kj lg na km kn lk nb kq kr lo nc ku kv kw ig bi translated">为了公平起见，我们来谈谈 switch/case 和 if/else 的区别。</p><figure class="nd ne nf ng gt jo gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/96a922fb0839bf68f49eb1af3a9ceccc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/1*9SwjeZ2zZ7BxFHxl6GS0Jg.png"/></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk translated"><a class="ae nx" href="https://www.javatpoint.com/java-switch" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="2ad8" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj lg kl km kn lk kp kq kr lo kt ku kv kw ig bi translated">当我们使用<strong class="kb io"> <em class="ka">开关</em> </strong>语句时，编译器使用<strong class="kb io"> <em class="ka">跳转/分支表</em> </strong>并且当<strong class="kb io"> <em class="ka">开关</em> </strong>得到一个数据——编译器将<strong class="kb io"> <em class="ka">开关</em> </strong>中的一个数据与其它情况下的值进行比较。同时，<strong class="kb io"> <em class="ka"> if </em> </strong>计算每种情况下的数值，并进行比较。</p><figure class="nd ne nf ng gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ny"><img src="../Images/e88e06283b186b6193afbf885d778b96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*75ixY6D5vU5hSNDdHm8ORQ.png"/></div></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk translated"><a class="ae nx" href="https://www.youtube.com/watch?v=1r6oflIjC6Q&amp;t=275s&amp;ab_channel=LuisCeze" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><blockquote class="jv jw jx"><p id="0814" class="jy jz ka kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">D <!-- -->不要害怕<strong class="kb io"> goto </strong>语句和<strong class="kb io"> C </strong>编程语言，这个例子只是展示了<strong class="kb io">跳转/分支表</strong>如何工作。</p></blockquote><h2 id="666c" class="kx ky in bd kz la lb dn lc ld le dp lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">我应该关心这个吗？</h2><p id="1f17" class="pw-post-body-paragraph jy jz in kb b kc lv ke kf kg lw ki kj lg na km kn lk nb kq kr lo nc ku kv kw ig bi translated"><strong class="kb io">不</strong>，这些微优化不太可能影响你的代码。</p><h2 id="f7af" class="kx ky in bd kz la lb dn lc ld le dp lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">您可能听说过 switch 中的真实模式。</h2><p id="305e" class="pw-post-body-paragraph jy jz in kb b kc lv ke kf kg lw ki kj lg na km kn lk nb kq kr lo nc ku kv kw ig bi translated"><em class="ka">我也是</em> <strong class="kb io"> <em class="ka">我不喜欢</em> </strong> <em class="ka">。</em></p><figure class="nd ne nf ng gt jo gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/218f5158bd79b5fea042b2966ef3b38a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*dFT0dkfz0rh5L8M7dsq4MQ.png"/></div></figure><p id="a71c" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj lg kl km kn lk kp kq kr lo kt ku kv kw ig bi translated">关于这种模式的争议比没有更重要。如果有孩子问我<strong class="kb io"><em class="ka">` if 和 switch 有什么区别？`</em> </strong>下面我来回答一下:</p><blockquote class="jv jw jx"><p id="84bd" class="jy jz ka kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们想象我们在图书馆里。</p></blockquote><ol class=""><li id="e664" class="lt lu in kb b kc kd kg kh lg oa lk ob lo oc kw ma mb mc md bi translated"><strong class="kb io"><em class="ka">/</em></strong><br/>当你知道谁写了<strong class="kb io"><em class="ka">'</em>'<em class="ka">'</em></strong>-<strong class="kb io"><em class="ka"/></strong>时，你会发现书立上有字母<strong class="kb io"><em class="ka">【G】。<br/>‘戈尔丁’</em></strong>是值为<strong class="kb io"> <em class="ka">的开关</em> </strong>，其他书立用字母从’<strong class="kb io"><em class="ka">一个</em> </strong>到<em class="ka"><strong class="kb io">【Z】</strong></em>都是<strong class="kb io"> <em class="ka">的情况为开关</em> </strong>。<br/> <em class="ka">我们用</em> <strong class="kb io"> <em class="ka">切换</em> </strong> <em class="ka">因为</em> <strong class="kb io"> <em class="ka">所有情况下都是静态的</em> </strong> <em class="ka">和</em> <strong class="kb io"> <em class="ka">我们不应该做任何计算</em> </strong> <em class="ka">因为我们已经把</em> <strong class="kb io"> <em class="ka">中的所有字母都摊上了</em> </strong> <em class="ka">。</em></li><li id="11b1" class="lt lu in kb b kc me kg mf lg mg lk mh lo mi kw ma mb mc md bi translated"><strong class="kb io"> <em class="ka"> IF / <br/> </em> </strong>当你不知道这是谁写的时候——打开你的阅读书单找到它，当你找到的时候——发现这是谁写的。之后，像第一个例子一样做同样的动作。<br/> <strong class="kb io"> <em class="ka">让我们想象一下</em> </strong>，那个<strong class="kb io"> <em class="ka">阅读书单是数组，</em> </strong>我们迭代它，为<strong class="kb io"> <em class="ka">添加条件如果</em> </strong>并且当我们找到书名相当于'<strong class="kb io">《蝇王》</strong> -我们返回作者的姓氏。</li></ol><p id="3c36" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj lg kl km kn lk kp kq kr lo kt ku kv kw ig bi translated">我希望你明白 switch 和 if 之间的区别，但有些人不明白。有些人在开关中使用<strong class="kb io"> <em class="ka">真实模式</em> </strong>:</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="1f81" class="kx ky in ni b gy nm nn l no np">switch(true) {<br/> case 2 + 1 === 3:<br/>  return "yep";<br/> case 2 + 1 === 4:<br/>  return "nope";<br/> default:<br/>  return "wait";<br/>}</span></pre><blockquote class="jv jw jx"><p id="be2c" class="jy jz ka kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我不喜欢这种模式，我有一些理由:</p></blockquote><ol class=""><li id="74db" class="lt lu in kb b kc kd kg kh lg oa lk ob lo oc kw ma mb mc md bi translated">我们在<strong class="kb io"> <em class="ka">用例</em> </strong>中没有任何静态值，编译器必须计算每个<strong class="kb io"><em class="ka"/></strong>用例，并将此与<strong class="kb io"><em class="ka"/></strong>真值进行比较——它会杀死<strong class="kb io">j<em class="ka">UMP/分支表结构</em> </strong>。</li><li id="1f0e" class="lt lu in kb b kc me kg mf lg mg lk mh lo mi kw ma mb mc md bi translated"><strong class="kb io"><em class="ka">your object【key】</em></strong>完全取代了<strong class="kb io"> <em class="ka"> switch </em> </strong>并使用<strong class="kb io"> <em class="ka"> nullish 聚结</em> </strong>可以取代<strong class="kb io"> <em class="ka">默认</em> </strong>行为。<br/> <strong class="kb io"> <em class="ka">我下面谈谈吧(2) </em> </strong></li><li id="89e2" class="lt lu in kb b kc me kg mf lg mg lk mh lo mi kw ma mb mc md bi translated"><strong class="kb io"> <em class="ka">开关</em> </strong>更多的是关于可读代码而不是代码速度，并且在<strong class="kb io"> <em class="ka">情况下包含这个单静态值</em> </strong>优于表达式。</li><li id="2bd7" class="lt lu in kb b kc me kg mf lg mg lk mh lo mi kw ma mb mc md bi translated">使用这种模式，你不用等待哪种情况是真的，这种逻辑杀死你的应用系统。</li></ol><p id="69ae" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj lg kl km kn lk kp kq kr lo kt ku kv kw ig bi translated"><strong class="kb io">在第二点(2) </strong>，我写了关于<em class="ka">对象</em>和<em class="ka">开关</em>。我经常用 object 代替 switch。这种模式我称之为<strong class="kb io"> <em class="ka">开关——对象</em> </strong>。</p><figure class="nd ne nf ng gt jo gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/a9892d75304b8ae10e0a76230aaf1a43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*DyzptaRilpcm6Db3f9Ro9A.png"/></div></figure><p id="5459" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj lg kl km kn lk kp kq kr lo kt ku kv kw ig bi translated">让我们举一些例子</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="c37c" class="kx ky in ni b gy nm nn l no np">// using true pattern<br/>switch(true){<br/> case 2 + 3 === 5:<br/>  action();<br/>  return "Yes";<br/> default:<br/>  return false;<br/>}</span><span id="fdf2" class="kx ky in ni b gy nr nn l no np">// using switch-object pattern<br/>const keys = {<br/> 5: () =&gt; {<br/>  action()<br/>  return "yes"<br/> } <br/>}</span><span id="f9c0" class="kx ky in ni b gy nr nn l no np">// make some operations<br/>keys[5]() ?? false // default behavior</span></pre><h2 id="bc7f" class="kx ky in bd kz la lb dn lc ld le dp lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">总的来说:</h2><ol class=""><li id="9740" class="lt lu in kb b kc lv kg lw lg lx lk ly lo lz kw ma mb mc md bi translated">switch/case 比 if/else 可读性更强，速度更快。</li><li id="72ea" class="lt lu in kb b kc me kg mf lg mg lk mh lo mi kw ma mb mc md bi translated"><strong class="kb io"> <em class="ka">真实模式</em> </strong>不好，用<strong class="kb io"> <em class="ka">切换-对象模式</em> </strong>。</li></ol><h2 id="0084" class="kx ky in bd kz la lb dn lc ld le dp lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">汇编</h2><p id="d698" class="pw-post-body-paragraph jy jz in kb b kc lv ke kf kg lw ki kj lg na km kn lk nb kq kr lo nc ku kv kw ig bi translated">如果说实话，如果你不在乎怎么切换作品——不在乎。当编译器读取开关/case 时，它创建相同的 if/else 语句。</p><h1 id="f402" class="mj ky in bd kz mk ml mm lc mn mo mp lf mq mr ms lj mt mu mv ln mw mx my lr mz bi translated">#3 |成分和分解</h1><p id="7a23" class="pw-post-body-paragraph jy jz in kb b kc lv ke kf kg lw ki kj lg na km kn lk nb kq kr lo nc ku kv kw ig bi translated">我每天都在创建应用程序的<strong class="kb io"><em class="ka"/></strong>。<strong class="kb io"><em class="ka">Piece</em></strong>——是组件、新功能、类以及一切我们可以用来创建应用的东西。<strong class="kb io"> <em class="ka">通常是</em> </strong>，当你在开发一个<em class="ka">片- </em>时，你分解你的功能。</p><p id="1393" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj lg kl km kn lk kp kq kr lo kt ku kv kw ig bi translated"><strong class="kb io">即</strong>你需要创建<em class="ka">新闻页面</em>——你创建<em class="ka">文章组件</em>，在<em class="ka">文章组件</em>——你渲染/更改/删除一个数据<strong class="kb io">和<em class="ka">为这个</em> </strong>你使用函数。</p><p id="9d33" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj lg kl km kn lk kp kq kr lo kt ku kv kw ig bi translated"><strong class="kb io"> <em class="ka">你到处用函数。</em> </strong>当你<strong class="kb io"> <em class="ka"> </em> </strong>编写大组件并分解它们以便更好地理解时，通常你也试图按含义分解不同的东西，即你不应该为<strong class="kb io"> <em class="ka">新闻页面</em> </strong>和<em class="ka"/><strong class="kb io"><em class="ka">用户页面</em> </strong>中的<strong class="kb io"><em class="ka"/></strong><strong class="kb io"><em class="ka">get 但是有些情况下你应该忘记这一点。<strong class="kb io"> <em class="ka">例如</em> </strong>，你创建<strong class="kb io"> <em class="ka"> NewsProvider </em> </strong>，它建议你使用<strong class="kb io"> <em class="ka"> News page </em> </strong>的函数，同时在<strong class="kb io"> <em class="ka"> News page </em> </strong>中你创建<strong class="kb io"> <em class="ka">文章组件</em> </strong>，它也需要一个用于本地工作的函数——你提供它们。最后，<strong class="kb io"> <em class="ka"> NewsProvider </em> </strong>有 10 多个函数，而<strong class="kb io"><em class="ka">article Provider</em></strong>只有 2 个函数:<strong class="kb io"><em class="ka">‘我应该为这个案例创建一个新的提供者吗？’。</em>T101】</strong></em></strong></p><p id="ac6e" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj lg kl km kn lk kp kq kr lo kt ku kv kw ig bi translated"><strong class="kb io">否</strong>。提供商将你的应用程序包装在一个布局中，以获得两个功能，这是<strong class="kb io">不允许的</strong>。只要把两个你的供应商合二为一，顺其自然不是分解而是有时常识取胜。</p><blockquote class="jv jw jx"><p id="2e27" class="jy jz ka kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果<!-- -->你明白你的作品用途超出了建议的范围——不要分解它。</p></blockquote><h1 id="8d90" class="mj ky in bd kz mk ml mm lc mn mo mp lf mq mr ms lj mt mu mv ln mw mx my lr mz bi translated">#4 | <strong class="ak"> CSS-IN-JS </strong>和<strong class="ak">原生 html 标签</strong></h1><p id="74de" class="pw-post-body-paragraph jy jz in kb b kc lv ke kf kg lw ki kj lg na km kn lk nb kq kr lo nc ku kv kw ig bi translated">在我们的项目中，我们在可能的地方到处使用<strong class="kb io"> <em class="ka"> CSS-IN-JS 模式</em> </strong>。通常，当你使用<strong class="kb io"> <em class="ka"> CSS 模块模式</em> </strong>或者不同的模式时。你可能会使用一种命名方式，可以是<strong class="kb io"> <em class="ka"> BEM、SMACSS、SMACSS </em> </strong>和其他。我没有看到<em class="ka"> </em> <strong class="kb io"> <em class="ka"> CSS-IN-JS 的相同模式，只有</em> </strong>是这样的:</p><ol class=""><li id="a36d" class="lt lu in kb b kc kd kg kh lg oa lk ob lo oc kw ma mb mc md bi translated"><strong class="kb io">包装器</strong>——组件中的主标签。</li><li id="13e0" class="lt lu in kb b kc me kg mf lg mg lk mh lo mi kw ma mb mc md bi translated"><strong class="kb io">内容</strong> -包装标签后的标签。</li></ol><p id="eb5e" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj lg kl km kn lk kp kq kr lo kt ku kv kw ig bi translated"><em class="ka">和不同的标记。</em></p><p id="9fc1" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj lg kl km kn lk kp kq kr lo kt ku kv kw ig bi translated">但是如果你在某些情况下不改变标签的一个原始行为- <strong class="kb io">为它们创建样式化的标签。我总是为它们创建标签，因为另一个开发人员在看到你的代码时可能不明白这是什么。</strong></p><blockquote class="jv jw jx"><p id="27a3" class="jy jz ka kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">创建一个风格化的标签而不是本地标签，即使本地标签的行为适合你。</p></blockquote><h1 id="698a" class="mj ky in bd kz mk ml mm lc mn mo mp lf mq mr ms lj mt mu mv ln mw mx my lr mz bi translated"># 5 |<strong class="ak"><em class="nq">math . functions</em></strong>但不约<strong class="ak"> <em class="nq"> math </em> </strong></h1><p id="0d73" class="pw-post-body-paragraph jy jz in kb b kc lv ke kf kg lw ki kj lg na km kn lk nb kq kr lo nc ku kv kw ig bi translated">当我们创建<strong class="kb io"> <em class="ka">应用程序/网站/微控制器/人工智能时，我们到处都在使用数学函数。</em> </strong>许多开发者认为<strong class="kb io"> <em class="ka">数学函数</em> </strong>仅仅是关于数学，但是<strong class="kb io">数学函数是 clean 函数的例子。为什么？</strong></p><h2 id="a75b" class="kx ky in bd kz la lb dn lc ld le dp lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated"><em class="nq">首先我们应该定义什么意思——明确功能？</em></h2><p id="09fa" class="pw-post-body-paragraph jy jz in kb b kc lv ke kf kg lw ki kj lg na km kn lk nb kq kr lo nc ku kv kw ig bi translated">清晰函数是包含<strong class="kb io"><em class="ka"/></strong><strong class="kb io"><em class="ka">确定性</em> </strong>和<strong class="kb io"> <em class="ka">无副作用的函数。来说说这些:</em> </strong></p><h2 id="b2d3" class="kx ky in bd kz la lb dn lc ld le dp lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">副作用</h2><p id="5283" class="pw-post-body-paragraph jy jz in kb b kc lv ke kf kg lw ki kj lg na km kn lk nb kq kr lo nc ku kv kw ig bi translated">当你的函数执行退出函数上下文，然后改变全局环境:<strong class="kb io"> <em class="ka">更新状态，可变值等</em> </strong>。这就是所谓的<strong class="kb io"> <em class="ka">副作用。</em>T75】</strong></p><h2 id="4b33" class="kx ky in bd kz la lb dn lc ld le dp lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">决定论</h2><p id="4169" class="pw-post-body-paragraph jy jz in kb b kc lv ke kf kg lw ki kj lg na km kn lk nb kq kr lo nc ku kv kw ig bi translated">这种函数返回相同值的可能性，即使参数不变。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="452c" class="kx ky in ni b gy nm nn l no np">console.warn(“Test”); // "Test"<br/>console.warn("Test"); // "Test"</span><span id="6e83" class="kx ky in ni b gy nr nn l no np">Math.abs(-3); // 3<br/>Math.abs(-3); // 3</span></pre><p id="3a9a" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj lg kl km kn lk kp kq kr lo kt ku kv kw ig bi translated">如你所见，我们可以随意调用这些函数——结果不会改变。</p><h2 id="8d9e" class="kx ky in bd kz la lb dn lc ld le dp lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated"><strong class="ak">幂等的</strong></h2><p id="bf8d" class="pw-post-body-paragraph jy jz in kb b kc lv ke kf kg lw ki kj lg na km kn lk nb kq kr lo nc ku kv kw ig bi translated">这种函数返回相同值的可能性没有副作用。如果说实话，我看不出任何<strong class="kb io"><em class="ka"/></strong>的决定论函数使<strong class="kb io"><em class="ka"/></strong>产生副作用，但这是值得了解的。</p><p id="3fe9" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj lg kl km kn lk kp kq kr lo kt ku kv kw ig bi translated">在这之后，我们可以说<strong class="kb io"> <em class="ka"> Math.functions </em> </strong>的价值不仅在于它们封装了数学运算的算法，而且它们也是 c<strong class="kb io"><em class="ka">lear function</em></strong>的好例子。</p><blockquote class="jv jw jx"><p id="4219" class="jy jz ka kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如你所知<strong class="kb io"><em class="in">math . random()</em></strong>不清楚，希望你知道原因。</p></blockquote><h1 id="c203" class="mj ky in bd kz mk ml mm lc mn mo mp lf mq mr ms lj mt mu mv ln mw mx my lr mz bi translated">结论</h1><p id="bdda" class="pw-post-body-paragraph jy jz in kb b kc lv ke kf kg lw ki kj lg na km kn lk nb kq kr lo nc ku kv kw ig bi translated">我希望你喜欢它，并为自己发现一些新的东西。</p><p id="3156" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj lg kl km kn lk kp kq kr lo kt ku kv kw ig bi translated">谢谢，祝你好运！</p></div></div>    
</body>
</html>