<html>
<head>
<title>A Glance into Java Data Structure — Collection &amp; Map</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 数据结构一瞥——集合与映射</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/java-data-structure-collection-map-79f5d5b14dc3?source=collection_archive---------12-----------------------#2022-07-11">https://blog.devgenius.io/java-data-structure-collection-map-79f5d5b14dc3?source=collection_archive---------12-----------------------#2022-07-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4aa1f1169759c588c97e07905de1b5e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rOlKfuWlNAtszhr01vYfgg.jpeg"/></div></div></figure><p id="02a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我们将研究常见的 java 数据结构接口和类。我们不会涵盖每个类及其特定的用例。不过，我总结了一些工作经验和想法作为参考，希望能对你适用。</p><p id="175c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">开发人员在日常开发中最常使用的接口主要有 4 种——列表、队列、集合和映射。其中，List、Queue 和 Set 扩展了集合接口，Map 不扩展集合接口。</p><p id="b641" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是每个接口及其用例的简要总结。</p><ul class=""><li id="7060" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><strong class="ka ir">列表</strong>在处理<strong class="ka ir">订单</strong>时很有用。列表中存储的元素是有序的和可重复的。</li><li id="3ac9" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><strong class="ka ir">队列</strong>可用于<strong class="ka ir"> FIFO </strong>(先进先出)处理。添加的元素总是在队列的末尾。</li><li id="8d6b" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><strong class="ka ir">集合</strong>关注的是元素的<strong class="ka ir">唯一性</strong>，是无序的，不可重复的。</li><li id="394a" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><strong class="ka ir">映射</strong>使用<strong class="ka ir">键值对</strong>来存储元素。它类似于数学中的 y=f(x)，其中 x 代表键，y 代表值。键是无序且不可重复的，而值是无序但可重复的。</li></ul><p id="453a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下面的图中，你可以从上面的接口中更清楚地了解到常见的 Java 实现类，比如 ArrayList、HashMap 等。</p><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lk"><img src="../Images/4ca616dd7387d526dffc47f2d528f436.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k-46KUNHivRUPejx_YIm2A.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">集合框架</figcaption></figure><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/b09dd5be9d5c15f104784b3deaf260cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*aIguw7AEG-jb0Qy2djosxw.png"/></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">地图框架</figcaption></figure><h2 id="850d" class="lu lv iq bd lw lx ly dn lz ma mb dp mc kj md me mf kn mg mh mi kr mj mk ml mm bi translated">如何选择存储数据的类？</h2><p id="d5bd" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">应该根据类别的特征做出决定。例如，如果我们想使用一个键来检索/存储一个元素，我们可以使用 Map 接口下的类。如果我们需要对键值对进行排序，我们可以使用 TreeMap。如果不需要排序，可以用 HashMap。如果想保证线程安全，可以使用 ConcurrentHashMap。或者，在另一种情况下，当我们想要存储唯一的元素时，我们可以只使用 TreeSet 或 HashSet。如果重点是顺序而不是唯一性，我们可以使用 ArrayList 或者 LinkedList，然后再进一步决定。</p><h2 id="fc93" class="lu lv iq bd lw lx ly dn lz ma mb dp mc kj md me mf kn mg mh mi kr mj mk ml mm bi translated">数组列表与链接列表</h2><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/bb1e8ed0c9fbe7290fcfc09b675fb42b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8vsxBRd3XZcHr1yUvKGdbQ.jpeg"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated"><a class="ae mt" href="https://codegym.cc/quests/lectures/questsyntax.level08.lecture05" rel="noopener ugc nofollow" target="_blank">https://code gym . cc/quests/lectures/quest syntax . level 08 . lecture 05</a></figcaption></figure><p id="2108" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">元素检索</strong></p><p id="a168" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我们想在索引<em class="mu"> i </em>处获取一个元素。在 ArrayList 中，通过调用<em class="mu"> get </em>()方法并返回该元素，帮助我们直接定位元素，给出 O(1)的时间复杂度。相反，LinkedList 需要从索引 0 遍历到<em class="mu"> i </em>并返回元素，平均时间复杂度为 O(n)。</p><p id="75c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">元素插入/删除</strong></p><p id="e256" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我们想要在长度为<em class="mu"> n </em>的列表中的索引<em class="mu"> i </em>处插入一个元素。底层数组列表，我们首先将索引<em class="mu"> i </em>后的元素向右移动，并将新元素放在<em class="mu"> i </em>处。在 LinkedList 中，我们需要将列表遍历到 index <em class="mu"> i </em>之前的元素，并将节点<em class="mu"> i-1 </em>中的<strong class="ka ir"> next </strong>值更改为新节点。此外，新节点中的<em class="mu">上一个/下一个</em>值以及索引<em class="mu"> i </em>处的原始节点中的<em class="mu">上一个</em>值也被更新，但其余节点保持不变。</p><p id="d391" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于删除的情况，我们将对 ArrayList 做相反的操作，将<em class="mu"> i </em>之后的其余元素都向左移动。在 LinkedList 中，我们仍然从索引 0 开始遍历，删除索引<em class="mu"> i </em>处的元素，并更新相邻节点。对于元素插入和删除，由于 LinkedList 影响列表中的一小部分，所以与 ArrayList 相比，它的操作开销更少。</p><p id="1a3a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简而言之，如果列表很小，这两个类的性能是相似的。如果列表很大，并且我们知道它是动态的(不断地添加/删除)，LinkedList 可能是更好的选择。相反，如果列表保持相对静态，我们只需要检索值，那么 ArrayList 是更好的方法。</p><h2 id="e6c4" class="lu lv iq bd lw lx ly dn lz ma mb dp mc kj md me mf kn mg mh mi kr mj mk ml mm bi translated">哈希表 vs 哈希表</h2><ul class=""><li id="f4ea" class="kw kx iq ka b kb mn kf mo kj mv kn mw kr mx kv lb lc ld le bi translated">空键/值支持:HashMap 可以存储空键和空值。但是 HashMap 最多只能有一个 null 键。HashTable 不允许空键和空值。</li><li id="196b" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">线程安全:HashMap 是线程不安全的，但是 HashTable 是线程安全的。这是因为 HashTable 中的方法是用 synchronized 关键字修饰的。</li><li id="4bea" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">效率:由于同步的关键字，HashTable 在操作上不如 HashMap 高效。</li></ul><p id="c534" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，HashMap 是默认的，也是使用 Map 的首选方式。ConcurrentHashMap 代替 HashTable 提供了更好的同步访问性能。</p><h2 id="fbd4" class="lu lv iq bd lw lx ly dn lz ma mb dp mc kj md me mf kn mg mh mi kr mj mk ml mm bi translated">什么是 TreeMap？</h2><p id="9e19" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">与 HashMap 相比，TreeMap 通常较少使用。TreeMap 的主要特性是允许根据键对元素进行排序，这是 HashMap 所没有的。我们可以定义在构建树形图的过程中如何对元素进行排序。</p><p id="6014" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，我们有一个<em class="mu">用户</em>类，它只有两个字段——年龄和姓名。我们希望创建一个树形图，能够根据用户的年龄以升序排序。</p><pre class="ll lm ln lo gt my mz na nb aw nc bi"><span id="6756" class="lu lv iq mz b gy nd ne l nf ng">public void createTreeMap() {<br/>    final TreeMap&lt;User, String&gt; userMap = new TreeMap&lt;&gt;(<br/>            new Comparator&lt;User&gt;() {<br/>                @Override<br/>                public int compare(User u1, User u2) {<br/>                    return Integer.<em class="mu">compare</em>(u1.getAge(), u2.getAge());<br/>                }<br/>            }<br/>    );<br/>    final User user1 = new User(15, "Alice");<br/>    final User user2 = new User(16, "Bob");<br/>    final User user3 = new User(13, "Calvin");<br/><br/>    userMap.put(user1, user1.getName());<br/>    userMap.put(user2, user2.getName());<br/>    userMap.put(user3, user3.getName());<br/><br/>    userMap.entrySet()<br/>            .stream()<br/>            .map(userEntry -&gt; userEntry.getValue())<br/>            .forEach(System.<em class="mu">out</em>::println);<br/><br/>}</span></pre><p id="3aa1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">树形图使用<em class="mu">用户</em>对象作为键，用户名作为值。当我们在代码中定义一个树形图时，我们创建了一个<em class="mu">比较器</em>，它接收两个用户并在整数类中比较他们的年龄。这样，当插入新用户时，TreeMap 将进行比较，并将其放在合适的位置。</p><p id="4e5d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们用他们的年龄和名字创建一些用户，并把它们放入树形图中——“Calvin”是最年轻的，“Bob”是最年长的。然后，我们将按顺序打印出树形图的值，以查看结果。</p><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/97a6665a63359a6bea99e9613aa38f45.png" data-original-src="https://miro.medium.com/v2/resize:fit:590/format:webp/1*MP4dFnRhMA4z0Qqpk36v4A.png"/></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">结果</figcaption></figure><p id="68cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">结果给出了正确的顺序:加尔文-&gt;爱丽丝-&gt;鲍勃(从年轻到年老)。</p><h2 id="deb0" class="lu lv iq bd lw lx ly dn lz ma mb dp mc kj md me mf kn mg mh mi kr mj mk ml mm bi translated">哪些类是线程不安全的，我们如何处理它们？</h2><p id="6fc5" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">ArrayList、LinkedList、HashMap、HashSet、TreeSet、TreeMap 和 PriorityQueue 是线程不安全的。在并发的情况下，我们可以用一些其他的类来代替它们，例如:</p><ul class=""><li id="ea43" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">ConcurrentHashMap 代替 HashMap</li><li id="bcd4" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">CopyOnWriteArrayList 代替 ArrayList</li><li id="fe9e" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">代替 LinkedList 的 ConcurrentLinkedQueue</li><li id="3cb8" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">BlockingQueue 可用于与生产者-消费者结构共享数据</li></ul></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><p id="7f4c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望这篇文章对你有所帮助。如果你像我一样，渴望学习一些与技术相关的东西或定期反思工作和生活，请关注我的频道，了解我日常工作和生活中的最新灵感。</p><blockquote class="np nq nr"><p id="1c07" class="jy jz mu ka b kb kc kd ke kf kg kh ki ns kk kl km nt ko kp kq nu ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="iq">阅读更多:</em></strong><em class="iq"><br/></em><a class="ae mt" href="https://medium.com/geekculture/java-coding-tip-functional-programming-1b6278e48efa" rel="noopener"><em class="iq">Java 编码技巧—函数式编程</em></a><em class="iq"><br/></em><a class="ae mt" href="https://medium.com/geekculture/how-to-auto-generate-repetitive-java-code-to-save-your-time-c89a57652e90" rel="noopener"><em class="iq">如何自动生成重复的 Java 代码以节省您的时间</em> </a></p></blockquote></div></div>    
</body>
</html>