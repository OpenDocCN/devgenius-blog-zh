<html>
<head>
<title>Does JavaScript “constructor” really create the object?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript“构造函数”真的会创建对象吗？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/does-javascript-constructor-really-create-the-object-f47bae4c616?source=collection_archive---------6-----------------------#2022-05-07">https://blog.devgenius.io/does-javascript-constructor-really-create-the-object-f47bae4c616?source=collection_archive---------6-----------------------#2022-05-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b621ebd2c27ff22af5860589c50fa47f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sOfTtN2OWhkrOc4d1CxgMg.png"/></div></div></figure><p id="d55d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="kt">什么是建造师？</em> </strong></p><blockquote class="ku kv kw"><p id="a08b" class="jv jw kt jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">在基于类的编程的现实世界中，构造函数是实例化对象的方法。</p></blockquote><p id="d89c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">大多数基于类编程的开发人员都有同样的想法，我在学习 JavaScript 之前也有同样的想法。</p><p id="d35a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们没有解开谜语，我们总是称之为“神秘”, JavaScript 语言也是如此。</p><p id="294e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">先来看一个来自<a class="ae la" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/constructor" rel="noopener ugc nofollow" target="_blank"> MDN </a>的正式定义。</p><blockquote class="ku kv kw"><p id="a496" class="jv jw kt jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated"><strong class="jx io"/><code class="fe lb lc ld le b"><strong class="jx io">constructor</strong></code><strong class="jx io">方法是一个类的特殊方法，用于创建和初始化该类的对象实例。</strong></p></blockquote><p id="1d03" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们更深入地了解 JavaScript 中构造函数的作用。</p><blockquote class="ku kv kw"><p id="45bb" class="jv jw kt jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated"><strong class="jx io">在 JavaScript 中，构造函数只是用 new 关键字调用的函数。</strong></p><p id="0bc0" class="jv jw kt jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">它们不附属于类，也不实例化一个类。</p><p id="5931" class="jv jw kt jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated"><strong class="jx io">它们甚至不是特殊类型的函数。</strong></p><p id="7e74" class="jv jw kt jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated"><strong class="jx io">它们只是普通的函数，每当被调用时都会与 new 关键字一起使用。</strong></p></blockquote><p id="3049" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们试图使用 new 关键字创建对象时，会发生四种情况，这反过来劫持了构造函数。</p><figure class="lg lh li lj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lf"><img src="../Images/9cca1d852891b393b3cc6c1940533e9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T7pRuqUInLGzB1kVIo35lQ.png"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated">当调用构造函数时。</figcaption></figure><blockquote class="ku kv kw"><p id="8fb6" class="jv jw kt jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated"><strong class="jx io">注意:对于 JavaScript 来说，实例化一个对象的“构造函数”的概念是完全不同的。</strong></p></blockquote><p id="f9ca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们通过构造函数调用模式继续深入理解。</p><p id="fe04" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下图是一个构造函数调用模式的例子。</p><figure class="lg lh li lj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lo"><img src="../Images/1fb270ba5c1a14445d896e19b0fa30d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dbLw9BVoKD0fl281i_qB4A.png"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated">构造函数调用模式</figcaption></figure><p id="4769" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，当您尝试 console.log person1 和 person2 时，它将显示它自己绑定到上下文的值，并且在使用 new 关键字时执行上述四个步骤。</p><p id="3cf8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们现在的目的是看看一个构造函数在 JavaScript 对象中起什么作用。</p><p id="7b46" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">可视化上面的代码会给你更清晰的画面。这可能会令人困惑，但慢慢地，随着时间的推移，理解会带来更多的意义。</p><figure class="lg lh li lj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lp"><img src="../Images/a05986648bff06b55d7a1bc65e203583.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rVTf2iWXXPuRkAzH4Rg-gg.png"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated">构造函数原型链接</figcaption></figure><p id="216f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，如果你看到人对象有两个属性，即姓名和年龄。</p><p id="583f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">两个对象 person1 和 person2 有自己的绑定。</p><p id="6068" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们创建一个函数时，一个构造函数被附加到它的原型上。</p><p id="c4ab" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">默认情况下，Person.prototype 对象获取一个公共的、不可枚举的属性，称为“constructor ”,该属性引用回与该对象关联的函数。</p><figure class="lg lh li lj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lq"><img src="../Images/e91235a601489435bfb88a90dc93f8ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B0IE3cx_l7A9EdBj7AfaSA.png"/></div></div></figure><p id="0373" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您看到，即使 person1 上不存在构造函数属性，但构造函数试图解析为 person 函数。</p><p id="dc47" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">同样，在对象上，附加了 __proto__(又名<strong class="jx io"> dunder proto </strong>)。</p><p id="d314" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">什么是[[原型]]？</p><blockquote class="ku kv kw"><p id="9f9d" class="jv jw kt jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated"><strong class="jx io">JavaScript 中的对象有一个内部属性，在规范中表示为[[Prototype]]，它只是对另一个对象的引用。几乎所有对象在创建时都被赋予了一个非空的属性值。</strong></p></blockquote><p id="3ad3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以，这里的要点是，由人创造的物体，实际上是由人的原型创造的。</p><p id="dfc0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这一点上可能会令人困惑，但是让我们来想想是什么让我这么说的。</p><figure class="lg lh li lj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lr"><img src="../Images/cf422baf83ae69c220edc9a4f8977985.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-qkOxg4s9EzZAMBhH2l1Gw.png"/></div></div></figure><p id="229c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你在上图中看到，它就是<strong class="jx io">人。原型。构造者</strong>不过是<strong class="jx io">人</strong>本身。</p><p id="73fd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里，重点就像“<strong class="jx io">构造函数</strong>”正在创建一个返回到 Person 函数的引用链接。</p><figure class="lg lh li lj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ls"><img src="../Images/e0caa46c0832a844b3158b23d8f747fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8djeQX01ynqBl6lTjUFIqA.png"/></div></div></figure><p id="744d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你试着把对象和构造函数联系起来，事情会变得更清楚。</p><p id="d21a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> __proto__ </strong>关键字无非就是<strong class="jx io"> constructor.prototype </strong>。你可以看到第 14 和 15 行。这是 Mozilla 在编写构造函数时给出的。将 prototype 放在原型链的顶端会让它看起来很麻烦。所以，他们发明了一个新的关键字 dunder proto。</p><p id="6f71" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第 17 行显示您正在遍历原型链，它会停止，直到发现 null。</p><p id="b95d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">简单地说，一个对象“构造者”Person 可以访问指向 Person 的. constructor 属性。</p><p id="1f86" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">谁创建了该对象？</strong></p><blockquote class="ku kv kw"><p id="70a2" class="jv jw kt jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated"><strong class="jx io"> person1 没有构造函数属性，所以它委托给[[Prototype]]链，即 Person.prototype。但是，该对象没有“构造函数”属性。因此，它再次将其原型链委托给它的顶层，即 Object.prototype，它确实有一个“构造函数”，指向内置的 Object(…)函数。</strong></p></blockquote><p id="68c5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">突出显示“<strong class="jx io">构造器</strong>”关键字的目的是为了读出真正的目的。</p><blockquote class="ku kv kw"><p id="cd61" class="jv jw kt jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">注意:在传统的基于类的语言中,“super”是子类的构造函数引用其父类的构造函数的直接方式。这在很大程度上是正确的，因为对于真实的类，构造函数属于该类。</p><p id="30f9" class="jv jw kt jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">然而，在 JS 中，情况正好相反——实际上，认为“类”属于构造函数(Person.prototype…类型引用)更合适。孩子和父母的关系只存在于两者之间。各自构造函数的原型对象，构造函数本身并不直接相关。</p></blockquote><p id="1e88" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以，我希望如果有人在面试中问到“构造函数”的用法，你至少不要说“实例化对象”。</p><p id="5d5e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">快乐编码。不断学习。继续探索。😊</p></div></div>    
</body>
</html>