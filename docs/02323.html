<html>
<head>
<title>Professional Illustrate the Specifications before Jumping to Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">专业人员在开始编写代码之前先说明规格</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/professional-illustrate-the-specifications-before-jumping-to-code-34304a85c756?source=collection_archive---------13-----------------------#2020-07-28">https://blog.devgenius.io/professional-illustrate-the-specifications-before-jumping-to-code-34304a85c756?source=collection_archive---------13-----------------------#2020-07-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b894cd9164174e2ca21928973b6c2c89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Jtd0vYxDKqZLGRIe"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><a class="ae jz" href="https://unsplash.com/@sctgrhm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">斯科特·格雷厄姆</a>在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="d2d1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你想设计一个程序，你可能首先想知道这个程序应该做什么。</p><p id="dbb8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这些指令被称为规范，它们可能来自客户、最终用户或分析师团队。</p><p id="ff27" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">他们可能会以非正式文本、结构化文档或使用正式数学符号的形式提供给你。</p><p id="3fbf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这篇文章中，我将重点介绍数学符号。我会用两种符号，数理逻辑和OCL。</p><p id="b923" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将使用的数学逻辑有不同的名称，包括一阶逻辑、FOL和谓词演算。</p><p id="3840" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">FOL，使您能够精确地表达命题，使用like and and，or or not组合它们。</p><p id="9a07" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">用逻辑连接词来量化它们，用运算符来表示所有存在的东西。</p><p id="fae9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">OCL，对象约束语言，是UML的一部分。</p><p id="c0f0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">OCL为FOL提供了一个语法，可以用来注释UML图。</p><p id="cdf5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通常将规范分为三部分，称为签名、前置条件和后置条件。</p><h2 id="343e" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">签名:</h2><p id="6632" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">给出程序的名称、输入参数的名称和类型以及结果的名称和类型。</p><p id="f4fa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">示例:</p><p id="7a8c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">向量<int> Y =排序(向量<int> X)。</int></int></p><p id="532d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">排序接受一个名为X的参数，该参数具有数据类型向量<int>，并产生一个结果向量y。</int></p><p id="9626" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">x和Y有明确的名称，所以我们可以在前置和后置条件中使用它们。</p><h2 id="5138" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">前提条件:</h2><p id="19d1" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">我们必须确保传递到那里的x元素不是负的。</p><p id="66e5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以，x &gt; 0。</p><p id="4d88" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们指定函数的行为，当它得到预期的参数时，这个函数意味着什么？</p><p id="dad6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你想有一个变体，它适用于任何论点。但是如果x小于0，就会引发异常或产生返回代码。我们也可以指定这一点。</p><h2 id="49e1" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">后置条件:</h2><p id="dc00" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">后置条件也是插入。</p><p id="1f58" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它说明了函数产生的输出必须为真。</p><p id="0ba4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通常这意味着表达输出与输入的关系。</p><p id="714f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">排序的后置条件:</p><p id="5235" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">1-输出向量Y必须是有序的。</p><p id="17ef" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2-Y的内容必须与x的内容相同。</p><h1 id="3fdf" class="lw kz in bd la lx ly lz ld ma mb mc lg md me mf lj mg mh mi lm mj mk ml lp mm bi translated">OCL(对象约束语言)</h1><p id="159e" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">所以，当我们看UML时，我们看的是图。但是，图表并不能说明全部情况。在系统的规格和设计中，有些地方需要更多的细节。这就是OCL被设计提供给设计师的东西。</p><p id="9ba0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">OCL是一种语言，不是编程语言。这是一种规范语言。它是声明性的，是强类型的，允许你指定系统属性的功能细节。</p><p id="e3a1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">OCL包括表达约束的方法，加上一些集合类，增加了在图中各种关系类之间导航的能力。</p><p id="4372" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">约束+集合类+ UML图导航。</strong></p><p id="68f2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">OCL是一项成熟的技术，是UML的官方组成部分，并得到各种工具的支持，如Rational Rose、ArgoUML、Eclipse、Poseidon、Enterprise Architect等等。</p><p id="193d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们为什么需要OCL？</p><p id="8921" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">图表在描述结构关系和行为描述方面非常棒。</p><p id="0d3f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是，有些时候你需要更加精确，尤其是关于功能的细节。</p><p id="04bf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">确切地说，这个特定的组件完成这个特定的任务意味着什么。</p><p id="f53f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">OCL扩展了UML，具有:</p><p id="6b93" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">1-类不变性。</p><p id="a916" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2-描述，根据前置和后置条件对操作进行精确描述。</p><p id="e3ba" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">3-它们也可以用作状态图中转换的防护。</p><h1 id="2b36" class="lw kz in bd la lx ly lz ld ma mb mc lg md me mf lj mg mh mi lm mj mk ml lp mm bi translated">结论:</h1><p id="229c" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">OCL有三个方面需要注意:它是声明性的，它不是一种过程语言，它不是一种编程语言。这是一种指定属性的方式。</p><p id="3e99" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">作为这篇文章的额外收获，我想与您分享一些改变了我在软件设计工程领域的生活的书籍:</p><p id="5ab8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">1- <a class="ae jz" href="https://amzn.to/2XSyWbg" rel="noopener ugc nofollow" target="_blank">干净的代码:敏捷软件技术手册</a></p><p id="692e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2- <a class="ae jz" href="https://amzn.to/30BYfzR" rel="noopener ugc nofollow" target="_blank">干净的架构:软件结构和设计的工匠指南(Robert C. Martin系列)</a></p><p id="eda9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">3- <a class="ae jz" href="https://amzn.to/3fgZmJr" rel="noopener ugc nofollow" target="_blank">务实的程序员:你的精通之旅，20周年纪念版</a></p><p id="502e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个故事起源于:<a class="ae jz" href="http://selcote.com/2020/07/28/professional-illustrate-the-specifications-before-jumping-to-code/" rel="noopener ugc nofollow" target="_blank">selcote.com</a></p></div></div>    
</body>
</html>