<html>
<head>
<title>Service Discovery &amp; why it is so important in Microservices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">服务发现&amp;为什么它在微服务中如此重要</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/service-discovery-importance-in-microservices-17970569685?source=collection_archive---------0-----------------------#2021-12-26">https://blog.devgenius.io/service-discovery-importance-in-microservices-17970569685?source=collection_archive---------0-----------------------#2021-12-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/4493cd57e9119a01bd84eeab4a87dc5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s60xISHjsZUXjP-1h1wXWQ.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><a class="ae jz" href="https://unsplash.com/@henniestander?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">亨尼斯坦德</a>在<a class="ae jz" href="https://unsplash.com/s/photos/discovery?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="549c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在一个单片应用中，我们可能都有一些<em class="ky">服务</em>的概念，比如<code class="fe kz la lb lc b">User</code>服务、<code class="fe kz la lb lc b">Invoicing</code>服务等等；它们基本上是独立的类/库，存在于相同的代码库中。</p><p id="2e03" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设我们收到一个请求，请求获取特定用户的所有发票。该请求由我们的框架路由，其中<strong class="kc io">发票</strong>服务可能需要调用<strong class="kc io">用户</strong>服务来获取用户相关信息。所有这一切都发生在我们的巨石边界内。</p><h2 id="bd0b" class="ld le in bd lf lg lh dn li lj lk dp ll kl lm ln lo kp lp lq lr kt ls lt lu lv bi translated">劈开整块石头</h2><p id="3679" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">但是，现在如果我们将这个整体应用程序分割成更小的代码块，即<code class="fe kz la lb lc b">User</code>服务和<code class="fe kz la lb lc b">Invoicing</code>服务，假设我们将它们部署到不同的服务器中，那么我们不能让它们通过简单的函数调用进行通信，因为在这种情况下，<code class="fe kz la lb lc b">User</code>和<code class="fe kz la lb lc b">Invoicing</code>服务是两个独立的实体，它们驻留在不同的代码库中，或者更具体地说，驻留在不同的应用程序服务和不同的服务器中。但是我们需要<code class="fe kz la lb lc b">Invoicing</code>服务调用<code class="fe kz la lb lc b">User</code>服务来获取用户相关信息。在这种情况下，我们需要进行API调用。</p><h2 id="37c4" class="ld le in bd lf lg lh dn li lj lk dp ll kl lm ln lo kp lp lq lr kt ls lt lu lv bi translated">如果事情出了差错怎么办？</h2><p id="3fe7" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">现在，事情可能会出错，因为当我们进行API调用时，有一个额外的事情要考虑。这一次，网络是游戏的一部分，尽管它非常复杂和不可靠。下面我们将讨论服务架构的一些常见的最坏情况。</p><p id="0e30" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最坏情况1。假设，我们调用<code class="fe kz la lb lc b">Invoicing </code>服务，这个服务将调用<code class="fe kz la lb lc b">User</code>服务来获取用户相关信息。现在，如果<code class="fe kz la lb lc b">User </code>服务由于某种原因关闭，它将无法满足请求。</p><p id="7cf2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最坏的情况2。为了解决前面的问题，我们现在有了多个<code class="fe kz la lb lc b">User</code>服务实例，但是现在我们如何知道哪个是正确的<code class="fe kz la lb lc b">User </code>服务实例来获取数据。</p><p id="169d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最坏情况3。如果第一个服务实例出现故障，服务如何向集群宣布已经部署了新的服务，并从第二个服务实例获取数据？</p><p id="aa6f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了解决上述问题，我们使用服务发现模式。</p><h1 id="8999" class="mb le in bd lf mc md me li mf mg mh ll mi mj mk lo ml mm mn lr mo mp mq lu mr bi translated">什么是服务发现？</h1><p id="8b2c" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">服务发现是自动发现哪些服务实例来满足给定查询的模式。服务发现具有自动定位网络的能力，因此不需要长时间的配置设置过程。</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ms"><img src="../Images/3851710e1884e4a05229f606f365bbc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KNgSUTjpS36XkYXAvCc5xg.png"/></div></div></figure><p id="9065" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">服务发现的工作原理是设备通过网络上的公共语言进行连接，允许设备或服务在没有任何人工干预的情况下进行连接。(即Kubernetes服务发现、AWS服务发现)。</p><h1 id="ff4a" class="mb le in bd lf mc md me li mf mg mh ll mi mj mk lo ml mm mn lr mo mp mq lu mr bi translated">服务发现的类型</h1><p id="da4b" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">服务发现有两种类型:<strong class="kc io">服务器端</strong>和<strong class="kc io">客户端。</strong></p><p id="96bf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">服务器端服务发现允许客户端应用程序通过路由器或负载平衡器来发现服务。服务器端服务发现的优点是，它使客户端应用程序变得更轻便，因为它不必处理查找过程并向路由器发出服务请求。</p><p id="7371" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">客户端服务发现允许客户端应用程序通过查看或查询服务注册中心来找到服务，其中服务实例和端点都在服务注册中心内。客户端服务发现的优势在于，客户端应用程序不必通过路由器或负载平衡器进行通信，因此可以避免额外的一跳。</p><h1 id="f8de" class="mb le in bd lf mc md me li mf mg mh ll mi mj mk lo ml mm mn lr mo mp mq lu mr bi translated">服务发现是如何工作的？</h1><p id="6e86" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">服务发现有三个组件:服务提供者、服务消费者和服务注册中心。</p><p id="1697" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">1)<strong class="kc io">服务提供者</strong>在进入系统时向服务注册中心注册，在离开系统时注销。</p><p id="dd57" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2)<strong class="kc io">服务消费者</strong>从服务注册中心(可用服务实例的数据库)获取提供者的位置，然后将其连接到服务提供者。</p><p id="848c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">3)<strong class="kc io">服务注册中心</strong>需要高度可用并且是最新的，以便客户端可以通过从服务注册中心获得的网络位置。服务注册中心由一个使用复制协议来保持一致性的服务器集群组成。</p><h1 id="cac4" class="mb le in bd lf mc md me li mf mg mh ll mi mj mk lo ml mm mn lr mo mp mq lu mr bi translated">微服务中的服务发现需求？</h1><p id="ea83" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">微服务本质上是动态的。这意味着单个微服务的多个实例可以共存。最有可能的是，服务实例要么有不同的IP地址，要么有不同的端口，或者两者都有。之前，我们已经讨论了没有服务发现的微服务的一些最坏情况。简而言之，我们需要服务发现</p><ul class=""><li id="c9a6" class="mx my in kc b kd ke kh ki kl mz kp na kt nb kx nc nd ne nf bi translated">了解任何微服务实例的位置。</li><li id="45c9" class="mx my in kc b kd ng kh nh kl ni kp nj kt nk kx nc nd ne nf bi translated">跟踪所有的实例。</li><li id="cb5a" class="mx my in kc b kd ng kh nh kl ni kp nj kt nk kx nc nd ne nf bi translated">选择微服务实例。</li><li id="dc07" class="mx my in kc b kd ng kh nh kl ni kp nj kt nk kx nc nd ne nf bi translated">如果另一个实例由于某种原因而关闭，则重定向到同一服务的另一个实例。</li></ul><p id="b1df" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">微服务架构发现中的服务发现实施包括以下两个方面:</p><ul class=""><li id="1aea" class="mx my in kc b kd ke kh ki kl mz kp na kt nb kx nc nd ne nf bi translated">维护地址全局视图的中央服务器(或多个服务器)。</li><li id="b625" class="mx my in kc b kd ng kh nh kl ni kp nj kt nk kx nc nd ne nf bi translated">连接到中央服务器以更新和检索地址的客户端。</li></ul><h1 id="5efb" class="mb le in bd lf mc md me li mf mg mh ll mi mj mk lo ml mm mn lr mo mp mq lu mr bi translated">服务发现工具</h1><p id="1caf" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">在微服务领域，有许多技术可以用来实现服务发现模式。他们主要是两种类型，1。<strong class="kc io">通用发现工具</strong>和2。<strong class="kc io">单一用途发现工具</strong>。</p><p id="beea" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通用发现工具实际上是通用数据存储。它们通常用于协调。一些通用的发现工具有Apache ZooKeeper、HashiCorp Consul。</p><p id="158f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最常见的单一用途发现工具是Airbnb SmartStack(它是两个定制工具的组合)，即<em class="ky">神经</em>和<em class="ky">突触</em>和网飞尤里卡(基于REST的服务注册中心)。</p><p id="7c1a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这有帮助吗？不要忘记为这个帖子鼓掌，给我们一些灵感！</p></div><div class="ab cl nl nm hr nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ig ih ii ij ik"><h1 id="8512" class="mb le in bd lf mc ns me li mf nt mh ll mi nu mk lo ml nv mn lr mo nw mq lu mr bi translated">你对全栈开发感兴趣吗？</h1><p id="1c8b" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated"><em class="ky">我写的是关于fullstack Web Development REST API、微服务、LinkedIn中的架构、Medium的循序渐进的编码教程。</em> <a class="ae jz" href="https://www.linkedin.com/in/spsarkar-appxive/" rel="noopener ugc nofollow" target="_blank"> <em class="ky">这里是我的Linkedin简介</em> </a> <em class="ky">。</em></p></div></div>    
</body>
</html>