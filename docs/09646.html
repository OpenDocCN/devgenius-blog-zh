<html>
<head>
<title>Before Starting a Full Stack Project, Consider this About Your Database</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在开始一个全栈项目之前，考虑一下您的数据库</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/before-starting-a-full-stack-project-consider-this-about-your-database-f85aaa503a80?source=collection_archive---------16-----------------------#2022-09-02">https://blog.devgenius.io/before-starting-a-full-stack-project-consider-this-about-your-database-f85aaa503a80?source=collection_archive---------16-----------------------#2022-09-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d9544f3bdc5ce34c079bdbc9906678b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_BAxF3uIeHfFsvT9"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">照片由<a class="ae jz" href="https://unsplash.com/@iiris_lepmets?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Iiris L </a>在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="596d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你听说过数据库。一个保存所有骆驼(或普通人数据)的中心。也许你选择了 sqlite、PostgreSQL 或 Microsoft SQL。更好的是包含一个<a class="ae jz" href="http://sqlalchemy.org" rel="noopener ugc nofollow" target="_blank"> ORM </a>或<a class="ae jz" href="https://github.com/Masterminds/squirrel" rel="noopener ugc nofollow" target="_blank"> sql 元编译器</a>，这样如果您的项目需求发生变化，您可以轻松地切换到另一个数据库。</p><p id="6903" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">等等，换到另一个数据库？你为什么要这么做？</p><p id="234f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">很多原因。对于项目来说，在 NoSQL 数据库上开始时很强大，认为他们没有定义模式就飞得很高，然后当他们发现没有他们预期的那么高效时，让开发人员拔头发是很常见的。</p><p id="82db" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">或者，也许你正处于需要切换到数据库的痛苦之中，并且你现在喘不过气来。</p><p id="2ca7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这篇文章是写给那些还没到那一步的人的，但是如果你喘不过气来，喘口气，然后回来读这篇文章。可能还是有帮助的。</p><p id="576b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那么，您需要在与数据库相关的全栈应用中加入哪一项内容呢？</p><p id="de96" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">迁移！</p><h1 id="1ff0" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">为什么需要迁移？</h1><p id="9ebf" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">如果您的项目就像许多处于起步阶段的项目一样，那么您可能没有过多考虑数据库。您可能看到了原始连接库，并认为在最初的应用程序连接上编写一堆数据库代码会很方便。</p><p id="0bca" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，考虑下面的代码片段:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="b046" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">到目前为止一切顺利。这正是客户想要的，所以我们点击了大的“部署”按钮，然后回家了。</p><p id="dabd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但之后又说要更新产品。也许客户想要一个与他们的客户相关联的调色板(不仅仅是一种颜色)，并且他们想要说出他们最喜欢的颜色。</p><p id="0dc3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，现在我们需要对原始语句进行两处修改:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="5cca" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">漂亮！就是好看！</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/31cb9d6533409d2bfd7e973f7417a26f.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*ln5hbsjw8tSX5Pf1UV51TA.gif"/></div></figure><p id="7fe0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">或者也许不是？因为请记住，我们在第一次运行时执行这个启动代码，这意味着每次都会创建表。这对于<code class="fe mi mj mk ml b">color</code>表来说很好，但是对于<code class="fe mi mj mk ml b">user</code>表，特别是<code class="fe mi mj mk ml b">favoriteColor</code>列来说呢？</p><p id="7cde" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">永远不会被创造出来。</p><p id="6c84" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，我们有 3 个选择(好吧，包括第四个，这就是本文要讨论的):</p><ol class=""><li id="5cfb" class="mm mn in kc b kd ke kh ki kl mo kp mp kt mq kx mr ms mt mu bi translated">包含代码来<code class="fe mi mj mk ml b">DROP</code>表，然后重新创建，这意味着所有数据都将丢失。这对于初始开发来说是没问题的，但是请记住，这些代码已经部署到生产中了。</li><li id="d81d" class="mm mn in kc b kd mv kh mw kl mx kp my kt mz kx mr ms mt mu bi translated">通知其他开发人员他们需要包含代码<code class="fe mi mj mk ml b">UPDATE User ADD COLUMN favoriteColor CHAR(10)</code>。但是你也需要通知客户/用户。你创建了这个应用程序，这样用户<em class="na">就不用</em>运行 SQL 代码了。</li><li id="74ea" class="mm mn in kc b kd mv kh mw kl mx kp my kt mz kx mr ms mt mu bi translated">在初始 sql 代码中包含#3 中的代码。这是最好的选择，因为它对已经存在的表有弹性，用户不必运行 sql 代码。</li></ol><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="7cc8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是还有一个问题。如果程序重启了呢？我们遇到了一个逻辑问题:</p><ul class=""><li id="c5a3" class="mm mn in kc b kd ke kh ki kl mo kp mp kt mq kx nb ms mt mu bi translated">表<code class="fe mi mj mk ml b">users</code>已经存在。</li><li id="bbc8" class="mm mn in kc b kd mv kh mw kl mx kp my kt mz kx nb ms mt mu bi translated">列<code class="fe mi mj mk ml b">favoriteColor</code>已经存在。</li><li id="5279" class="mm mn in kc b kd mv kh mw kl mx kp my kt mz kx nb ms mt mu bi translated">因此，如果我们再次尝试修改<code class="fe mi mj mk ml b">users</code>来添加<code class="fe mi mj mk ml b">favoriteColor</code>列，查询将会失败。</li><li id="3a82" class="mm mn in kc b kd mv kh mw kl mx kp my kt mz kx nb ms mt mu bi translated">这意味着我们包含的任何其他 SQL 都不会执行。</li></ul><p id="4820" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就目前情况来看，这个问题只有一个解决方案:</p><p id="8294" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不要把 SQL 查询包含在一个很长的字符串中，而是把它分解成一个数组。然后一次执行一条语句，忽略出现的任何错误。这是个坏主意！因为我们假设在列冲突中唯一的错误是。我们可能有一个语法错误，或者丢失了一个<code class="fe mi mj mk ml b">CHAR</code>长度。</p><p id="4c38" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">作为一般的经验法则，永远不要吞下错误。</p><p id="228c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">相反，让我们跟踪变化。</p><h1 id="1656" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">迁移简介</h1><p id="9920" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">坏消息是数据库中没有解决这个问题的方法。数据库的强大之处在于它能够快速索引和检索数据，而不是跟踪数据库的变化。</p><p id="332b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此外，我们可能会认为 SQLite 不够强大(它通常不够强大)，我们可能会决定改用 PostgreSQL。语法有很大的不同，我们不能用 PostgreSQL 连接器替换 SQLite 连接器并运行相同的 SQL 代码。</p><p id="c317" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个包通常使用一个<a class="ae jz" href="https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping" rel="noopener ugc nofollow" target="_blank"> ORM，或者对象关系映射器</a>来实现简单的模式创建。如果你还不熟悉 ORM，如果你在<a class="ae jz" href="https://duckduckgo.com" rel="noopener ugc nofollow" target="_blank">duckduckgo.com</a>搜索你的语言+“ORM ”,你应该能够找到一个与你的 SQL 数据库兼容的编程语言的 ORM(大多数试图覆盖 90%的用例，如 SQLite、MySQL、PostgreSQL、Microsoft SQL，甚至 Mongo！)</p><p id="ed68" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">许多 ORM(对象关系模型)包包括迁移基础设施(或者您可能会发现一个针对特定架构的迁移包<em class="na">)。以下是 Python 中的一个迁移示例:</em></p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="d01e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这种情况下，您可以使用<code class="fe mi mj mk ml b">alembic</code>命令升级/降级数据库。</p><p id="c8dd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是 Alembic 如何知道应用什么迁移呢？</p><p id="d1a2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意到文件顶部的<code class="fe mi mj mk ml b">revision</code>和<code class="fe mi mj mk ml b">down_revision</code>了吗？这些被 alembic 读取以构建修订的有向图。当前迁移的状态记录在数据库自己的表中，以便迁移器可以有效地应用<code class="fe mi mj mk ml b">upgrade</code>或<code class="fe mi mj mk ml b">downgrade</code>命令。</p><p id="780f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">很整洁，是吧？</p><h1 id="fef1" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">包括迁移策略！</h1><p id="2b34" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">因此，在您开始项目开发之旅之前，花一点时间为您的项目寻找一个好的迁移策略。</p><p id="4af6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好消息是，你不是第一个使用你正在使用的技术堆栈的人。有人以前做过，也经历过那些烦人的事情。因此，人们创造了一种解决方案，让你我都更轻松！</p></div><div class="ab cl nc nd hr ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ig ih ii ij ik"><p id="fc6f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我希望这篇文章对你有所帮助。请与你认为会从中发现价值的人分享。</p><p id="44aa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">如果你的团队正在寻找团队领导或高级开发人员，请联系我。可以在</strong><a class="ae jz" href="https://damngood.tech" rel="noopener ugc nofollow" target="_blank">https://damn good . tech</a>预约免费咨询。</p></div></div>    
</body>
</html>