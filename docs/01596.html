<html>
<head>
<title>JavaScript Problems — Bad Promises, Stack Trace, NPX, and void</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript 问题——不良承诺、堆栈跟踪、NPX 和 void</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/javascript-problems-bad-promises-stack-trace-npx-and-void-f888bd33b9ed?source=collection_archive---------24-----------------------#2020-07-07">https://blog.devgenius.io/javascript-problems-bad-promises-stack-trace-npx-and-void-f888bd33b9ed?source=collection_archive---------24-----------------------#2020-07-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c558359109d26ea24aa54e30cc968678.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Xywewn9kGFnIaj8o"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">安妮·斯普拉特在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="c7ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，当我们编写 JavaScript 应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些常见 JavaScript 问题的解决方案。</p><h1 id="2e87" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">承诺反模式</h1><p id="ab23" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">写 promise 代码有一些不好的方法。</p><p id="f812" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">编写 promise 代码的一个不好的方法是在调用<code class="fe me mf mg mh b">resolve</code>的构造函数中有一个回调。</p><p id="29c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们不应该这样写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="23d8" class="mq lc iq mh b gy mr ms l mt mu">new Promise((resolve) =&gt; {<br/>  otherPromise()<br/>  .then((result) =&gt; {<br/>    resolve(result);<br/>  });<br/>})</span></pre><p id="e88a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在承诺中有一个承诺，在回调中调用<code class="fe me mf mg mh b">resolve</code>。</p><p id="709f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这很糟糕，因为如果承诺被拒绝，我们不会得到一个错误，因为我们从未在传递给<code class="fe me mf mg mh b">Promise</code>构造函数的回调中调用过<code class="fe me mf mg mh b">reject</code>。</p><h1 id="212c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在 Node.js 中打印堆栈跟踪</h1><p id="d96c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以在带有<code class="fe me mf mg mh b">stack</code>属性的节点应用程序中打印堆栈跟踪。</p><p id="81aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ab61" class="mq lc iq mh b gy mr ms l mt mu">const stack = new Error().stack;<br/>console.log(stack);</span></pre><p id="8871" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用<code class="fe me mf mg mh b">console.log</code>获取堆栈跟踪并打印。</p><p id="357d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以使用<code class="fe me mf mg mh b">console.trace</code>方法来记录堆栈跟踪:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f624" class="mq lc iq mh b gy mr ms l mt mu">console.trace("hello")</span></pre><p id="0533" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到下面有堆栈跟踪的<code class="fe me mf mg mh b">'hello'</code>。</p><h1 id="ca96" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将数组拆分成块</h1><p id="e323" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用普通的 JavaScript，通过使用一个常规的 for 循环，将一个数组分割成块。</p><p id="90b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8451" class="mq lc iq mh b gy mr ms l mt mu">let temp;<br/>const chunk = 10;<br/>for (let i = 0; i &lt; array.length; i += chunk) {<br/>  temp = array.slice(i, i + chunk);<br/>}</span></pre><p id="a8c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一个 for 循环，它通过增加<code class="fe me mf mg mh b">chunk</code>的大小而不是 1 来遍历<code class="fe me mf mg mh b">for </code>循环。</p><p id="a974" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在循环体内部，我们使用<code class="fe me mf mg mh b">slice</code>方法获取数组的块，并将其分配给<code class="fe me mf mg mh b">temp</code>。</p><h1 id="87eb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将数组转换为对象</h1><p id="a4fa" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过使用<code class="fe me mf mg mh b">Object.assign</code>方法或 spread 操作符将一个数组转换成一个对象，其中的键是索引。</p><p id="93b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4b42" class="mq lc iq mh b gy mr ms l mt mu">const obj = <!-- -->Object.assign({}, ['a', 'b', 'c']);</span></pre><p id="d8a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="03ff" class="mq lc iq mh b gy mr ms l mt mu">{ ...['a', 'b', 'c'] }</span></pre><h1 id="3c71" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">制作一个不提交表单的按钮</h1><p id="6883" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">要制作一个不提交表单的按钮，我们可以将按钮的<code class="fe me mf mg mh b">type</code>属性设置为<code class="fe me mf mg mh b">'button'</code>。</p><p id="8333" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ee6e" class="mq lc iq mh b gy mr ms l mt mu">&lt;button type="button"&gt;button&lt;/button&gt;</span></pre><p id="4d22" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建一个不触发提交操作的按钮。</p><h1 id="b0e1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在数组的开头添加一个元素</h1><p id="dd25" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以调用<code class="fe me mf mg mh b">unshift</code>方法将一个元素添加到数组的开头。</p><p id="8c51" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="69ac" class="mq lc iq mh b gy mr ms l mt mu">arr.unshift(obj);</span></pre><p id="0d57" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们添加<code class="fe me mf mg mh b">obj</code>作为数组的第一个元素，现有的条目被移动以适应它。</p><h1 id="f525" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将数字转换为字符串的最佳方式</h1><p id="d746" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">要将数字转换成字符串，我们可以使用<code class="fe me mf mg mh b">toString</code>方法。</p><p id="73e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以用一个空字符串连接我们的数字。</p><p id="ff93" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a952" class="mq lc iq mh b gy mr ms l mt mu">const str = num.toString();</span></pre><p id="72b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="87af" class="mq lc iq mh b gy mr ms l mt mu">const str = '' + num;</span></pre><h1 id="0287" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">npx 和 npm 的区别</h1><p id="00e4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">NPX 是从版本 5.2 开始与 NPM 捆绑在一起的一个新程序</p><p id="97ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它让我们不用安装就可以运行一个包。</p><p id="0bd5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">NPM 本身不运行任何软件包。</p><p id="42eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要在 NPM 运行某些东西，我们必须向<code class="fe me mf mg mh b">package.json</code>文件添加一个脚本。</p><p id="62be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">NPX 让我们通过在<code class="fe me mf mg mh b">npx</code>后面添加一个包名来运行一个包。</p><p id="1cad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们想用<code class="fe me mf mg mh b">create-react-app</code>创建一个新的 React 项目，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1f59" class="mq lc iq mh b gy mr ms l mt mu">npx create-react-app example-app</span></pre><p id="3684" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们运行<code class="fe me mf mg mh b">create-react-app</code>而不先安装它。</p><p id="1c84" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">create-react-app</code>总是运行最新版本，我们想运行最新版本就不用升级了。</p><h1 id="8870" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">“void 0”的含义</h1><p id="5525" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">void</code>是一个前缀关键字，它接受一个参数并总是返回<code class="fe me mf mg mh b">undefined</code>。</p><p id="eb35" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，以下所有返回<code class="fe me mf mg mh b">undefined</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="cf80" class="mq lc iq mh b gy mr ms l mt mu">void 1<br/>void 'foo'<br/>void false<br/>void (new Date())</span></pre><p id="be5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它在我们的代码中毫无用处，但是它存在是因为<code class="fe me mf mg mh b">undefined</code>在旧版本的 JavaScript 中不是保留字。</p><p id="266e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">undefined</code>是全局对象的属性。</p><p id="af84" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">undefined</code>是一个允许的变量名。</p><p id="9847" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们可以做任何事情。</p><p id="f31c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">ES5 或更早版本阻止我们使用<code class="fe me mf mg mh b">undefined</code>作为变量。</p><p id="d56f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，<code class="fe me mf mg mh b">void 0</code>是有用的，因为它总是返回实际的<code class="fe me mf mg mh b">undefined</code>值。</p><p id="7127" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于<code class="fe me mf mg mh b">void 0</code>比<code class="fe me mf mg mh b">undefined</code>短，所以缩小器用<code class="fe me mf mg mh b">void 0</code>代替<code class="fe me mf mg mh b">undefined</code>以节省空间。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/87e95b19e8bcc2d734389d31bc528683.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0vE2cgfaBuqxtGR3"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@lidyanada?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Lidya Nada </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="228a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="5516" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">void</code>始终返回<code class="fe me mf mg mh b">undefined</code>。</p><p id="4dc8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不应该退回那些里面有承诺的承诺，那些承诺只会召唤<code class="fe me mf mg mh b">resolves</code>。</p><p id="fee9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">NPX 是 NPM 的一部分，我们可以用它来运行最新版本的软件包。</p></div></div>    
</body>
</html>