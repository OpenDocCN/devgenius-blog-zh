# 依赖注入 101

> 原文：<https://blog.devgenius.io/dependency-injection-101-a56cb6ef639a?source=collection_archive---------4----------------------->

![](img/dabbd5a52db40eefcbb1a3383072e4f4.png)

[图片致谢名单](https://unsplash.com/@markusspiske)

## 框架的核心。

> “依赖注入是一种使类独立于其依赖项的编程技术。它通过将对象的使用与创建分离来实现这一点。’—[设计模式讲解](https://stackify.com/dependency-injection/)

这是最受推崇的设计模式之一，也是许多框架(如 Spring 和 ASP.NET 核心)的基本方面之一。虽然已经有很多资源在讨论如何用特定的语言实现依赖注入，以及有哪些不同的方法，但是这篇文章将试图把重点放在非依赖注入世界(我曾经面对过)固有的一些问题上，以便更好地理解为什么框架吹嘘自己有现成的解决方案。

# 易测性

测试是任何软件项目的关键。为了验证和确认我们系统的功能，我们努力编写可测试的代码。

为了测试任何给定的功能，我们模拟它的依赖关系，以便它可以被“单元”测试。然而，当我们使用*新的*操作符创建一个对象时，我们不再有能力模仿它，因此函数变得不可测试，或者你依赖[黑客](https://stackoverflow.com/questions/5920153/test-class-with-a-new-call-in-it-with-mockito/5920394#5920394)。

> 注意:移动对象创建可以转移到一些工厂和模仿将工作。但是，这仍然是一项工作，同样的工作必须在所有地方重复，以实现我们代码的真正可测试性，这违反了 DRY(不要重复自己)原则。

# 单一责任原则

> "一个类应该有且只有一个改变的理由."

一个类应该有单一的责任。依赖关系的实例化只是应该避免的额外责任。

这一开始似乎没什么大不了的。但是当一个类专注于一个单一的职责时，它使得代码更容易理解和维护。

# 搬运生命周期

框架为我们提供了处理这些依赖关系的生命周期的现成功能。您可以请求一个**单例**、**瞬态**或**作用域**实例，这种配置对象生命周期的能力使我们能够更好地控制我们的需求，并有助于节省内存使用(通过不在每次请求时创建新对象)。创建对象的开销可能很大，对于数百万个请求，一个对象对一百万个对象会对内存消耗产生重大影响。

当您使用 *new* 操作符实例化一个依赖项时，您就立刻失去了这种优势。

# 结论

依赖注入背后的意图是实现对象构造和使用的[关注点分离](https://en.wikipedia.org/wiki/Separation_of_concerns)。这是一个简单却难以置信的概念，它提高了可测试性、可读性和可重用性。

# 参考

*   [依赖注入—维基百科](https://en.wikipedia.org/wiki/Dependency_injection#Advantages)
*   [解释设计模式——代码示例依赖注入](https://stackify.com/dependency-injection/)