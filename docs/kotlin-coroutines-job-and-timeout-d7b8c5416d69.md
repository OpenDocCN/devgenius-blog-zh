# Kotlin 协同程序-作业和超时

> 原文：<https://blog.devgenius.io/kotlin-coroutines-job-and-timeout-d7b8c5416d69?source=collection_archive---------3----------------------->

> 你有工作要及时完成！

![](img/7376945190384b8448555018a3a9a38a.png)

[https://all f1 . in/the-dominance-of-Hamilton-bad-for-the-sport/](https://allf1.in/the-dominance-of-hamilton-bad-for-the-sport/)

协程是在 Android 应用程序开发和 Ktor 中执行后台进程的现代方式。在这个协程系列的一篇文章中，我们试图理解协程的基础知识。如果你还没看过，看看这里的。

在本文中，我们将对这个问题有一些基本的理解:

*   为什么要控制协程的生命周期？
*   控制协程生命周期的方法？

> 如果你还没有选择它们，是时候开始了。

# 为什么要控制协程的生命周期？

考虑这样一个场景，我们为某个进程启动了一个协程，但是用户离开了屏幕，该进程不再需要。在这种情况下，我们的协程将一直运行，直到它完成。

另一个场景可能是，我们的最大执行时间限制是 3 秒，但该过程花费了更长时间，我们的过程目的现在是无效的。

还有一个可能是，一些计算正在无限期地进行，我们需要出于任何原因退出。

在所有上述和更多类似的场景中，我们需要某种机制来控制我们的协同程序继续运行。不这样做可能会泄漏我们的资源，或者会导致我们的应用程序崩溃或不稳定。

这就引出了我们的下一个问题。

# 控制协程生命周期的方法？

## 使用工单

我们知道协程是使用协程构建器启动的。协程生成器返回给我们一个作业对象。该作业对象的类型为 ***作业*** ，可用于取消协程。

如上所示，使用 job 对象，我们取消了作业，然后等待它完成。运行上面的代码将导致

我们启动了一项工作，将 0.5 秒的延迟重复了 1000 次。该作业与其父协程同时启动，父协程延迟 2 秒，然后取消该作业。事件是这样发生的:

*   *首先启动 runBlocking】*
*   *然后与父代码*同时启动发射模块
*   *父代码等待了 2 秒，同时作业执行了 4 次 0 到 3*
*   *父作业取消了作业，等待它安全完成并退出*
*   *工作取消*
*   *返回主线程*

这就是我们如何使用作业对象控制协程执行的。

## 使用合作抵消

取消协程应该是合作的，这意味着任何挂起的计算都应该检查协程在执行时是否被取消。如果一个协程正在计算并且没有被取消检查，那么它不能被取消。让我们举一个例子如下

运行这个作业并取消它不会停止我们的协程，因为它不会检查调用它的协程是否被取消。它会继续运行。

要解决这个问题，我们需要通过检查协程的取消状态来确保每个计算都是可取消的，如下所示:

现在，我们添加了一个由协程作用域本身提供的 ***isActive*** 标志。一旦作业被取消，该标志将停止执行。

在某些情况下，如果作业被取消，我们需要执行一些步骤，我们可以在 ***finally {}*** 块中执行这些步骤，因为被取消的作业会抛出***cancellation exception***异常，这是协程程序中的预期行为。这就是为什么我们这里不需要抓块。

## 使用超时

我们可能需要取消一个作业，因为它超过了时间限制。协程提供了 withTimeout 函数，它为我们做了完全相同的事情。超过时限抛出 ***超时取消异常*** 。

如果不需要异常，那么使用函数***with time out or Null***，超时返回 null。

Bamn！我们现在知道如何管理我们的协程执行，并更好地控制我们的后台任务。实现代码并进行试验，以便更好地理解。

目前就这些了！敬请期待！

在 medium(如果内容对你有帮助)或 [github](https://github.com/aqua30) 上关注我，并订阅电子邮件以同步了解更多关于 Android 的有趣话题。

直到下一次…

干杯！