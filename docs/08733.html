<html>
<head>
<title>Java 8: 7 Features You Must Know and Examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你必须知道的 Java 8: 7 特性和例子</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/java-8-seven-features-you-must-know-and-examples-1c3964ae7fe8?source=collection_archive---------4-----------------------#2022-07-06">https://blog.devgenius.io/java-8-seven-features-you-must-know-and-examples-1c3964ae7fe8?source=collection_archive---------4-----------------------#2022-07-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2a10f950e736a30f34c1f5a2681433e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*86BMe76jRb_g-DEGGJu4Pw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://number8.com/software-developer-salary-trends-2022/" rel="noopener ugc nofollow" target="_blank">来自 number8.com 的图片</a></figcaption></figure><h1 id="48cf" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">JAVA 8 概述</h1><p id="c43a" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">2014 年 3 月 18 日，甲骨文发布 Java 8。虽然这是很久以前的事了，但 Java 8 仍然在许多应用程序和项目中使用，因为 Java 8 得到了重大更新，增加了几个新特性。让我们用示例代码来看看 Java 8 的所有特性。本文列出了 Java 8 的重要特性和示例代码，如 lambda 表达式、Java 流、函数接口、默认方法和日期时间 API 变化等。</p><h1 id="af60" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">JAVA 8 特性</h1><h2 id="6198" class="lz ke iq bd kf ma mb dn kj mc md dp kn lm me mf kr lq mg mh kv lu mi mj kz mk bi translated">λ表达式</h2><p id="db61" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">Lambda 表达式在 Scala 等其他流行的编程语言中也很常见。这是 Java 第一次在 Java 8 上支持 Lambda 表达式。在 Java 中，Lambda expression 只是一个<em class="ml">匿名函数(</em>函数，没有名字，也没有绑定到标识符)。以下是 lambda 表达式的一些基本语法:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="5b9a" class="lz ke iq mr b gy mv mw l mx my">(parameters) -&gt; expression<br/> <br/>(parameters) -&gt; { statements; }<br/> <br/>() -&gt; expression</span></pre><p id="6109" class="pw-post-body-paragraph lb lc iq ld b le mz lg lh li na lk ll lm nb lo lp lq nc ls lt lu nd lw lx ly ij bi translated">一个著名的 lambda 表达式示例如下:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="b4c5" class="lz ke iq mr b gy mv mw l mx my"><em class="ml">//This function takes two parameters and return their a+b</em><br/>(a, b) -&gt; a+b</span></pre><p id="d02c" class="pw-post-body-paragraph lb lc iq ld b le mz lg lh li na lk ll lm nb lo lp lq nc ls lt lu nd lw lx ly ij bi translated">Lambda 表达式通过实现函数接口中提供的单个抽象函数来实现函数接口。正如我们上面提到的 Lambda 表达式的基本示例，上面的公式接受两个参数:“A”和“b”，并返回它们的总和“a+b”。根据“a”和“b”的数据类型，该函数可能会在不同的位置使用多次。参数“a”和“b”将根据上下文匹配“int”或“Integer”和“string”。如果参数是“int/Integer ”,它会将两个数字相加；如果参数是“String ”,它会将两个字符串连接起来。</p><p id="b4e7" class="pw-post-body-paragraph lb lc iq ld b le mz lg lh li na lk ll lm nb lo lp lq nc ls lt lu nd lw lx ly ij bi translated">这是一个如何在 Java 8 中使用 Lambda 表达式的示例:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="8949" class="lz ke iq mr b gy mv mw l mx my"><strong class="mr ir">interface I</strong>CalculationInterface {<br/>  <strong class="mr ir">void </strong>abstractFunc(<strong class="mr ir">int </strong>x, <strong class="mr ir">int </strong>y);<br/>}<br/><br/><strong class="mr ir">public class </strong>TechIsBeautiful {<br/>  <strong class="mr ir">public static void </strong>main(String args[]) {<br/>    ICalculationInterface output = (<strong class="mr ir">int </strong>x, <strong class="mr ir">int </strong>y) -&gt; System.<strong class="mr ir"><em class="ml">out</em></strong>.println(x+y);<br/>    System.<strong class="mr ir"><em class="ml">out</em></strong>.print(<strong class="mr ir">"Output: "</strong>);<br/>    output.abstractFunc(100,100);<br/>  }<br/>}</span></pre><p id="b33e" class="pw-post-body-paragraph lb lc iq ld b le mz lg lh li na lk ll lm nb lo lp lq nc ls lt lu nd lw lx ly ij bi translated">上面代码的输出:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="adde" class="lz ke iq mr b gy mv mw l mx my">Output: 200</span><span id="37df" class="lz ke iq mr b gy ne mw l mx my">Process finished with exit code 0</span></pre><p id="8b81" class="pw-post-body-paragraph lb lc iq ld b le mz lg lh li na lk ll lm nb lo lp lq nc ls lt lu nd lw lx ly ij bi translated">注意，数据类型在 Lambda 中不是必需的，您可以只使用它:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="6b68" class="lz ke iq mr b gy mv mw l mx my"><strong class="mr ir">interface I</strong>CalculationInterface {<br/>  <strong class="mr ir">void </strong>abstractFunc(<strong class="mr ir">int </strong>x, <strong class="mr ir">int </strong>y);<br/>}<br/><br/><strong class="mr ir">public class </strong>TechIsBeautiful {<br/>  <strong class="mr ir">public static void </strong>main(String args[]) {<br/>    ICalculationInterface output = (x, y) -&gt; System.<strong class="mr ir"><em class="ml">out</em></strong>.println(x+y);<br/>    System.<strong class="mr ir"><em class="ml">out</em></strong>.print(<strong class="mr ir">"Output: "</strong>);<br/>    output.abstractFunc(100,100);<br/>  }<br/>}</span></pre><h2 id="d8a0" class="lz ke iq bd kf ma mb dn kj mc md dp kn lm me mf kr lq mg mh kv lu mi mj kz mk bi translated">功能界面</h2><p id="e388" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">Java 8 中引入了一个名为“函数接口”的强大新特性。函数接口是只有一个抽象方法的接口。@FunctionalInterface 注释防止抽象方法被意外添加到函数接口中。函数接口最吸引人的特性之一是使用 lambda 表达式创建对象。我们可以使用匿名类创建一个接口，如下所示:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="486a" class="lz ke iq mr b gy mv mw l mx my">@FunctionalInterface<br/>public interface IMyFunctionalInterface<br/>{<br/>    public void myMethod();<br/>    @Override<br/>    public String toString(); <br/>    @Override<br/>    public boolean equals(Object obj);<br/>}</span></pre><h2 id="5ced" class="lz ke iq bd kf ma mb dn kj mc md dp kn lm me mf kr lq mg mh kv lu mi mj kz mk bi translated">接口支持默认和静态方法</h2><p id="a75a" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在 Java 8 之前，接口不能有方法实现。从 Java 8 开始，我们可以向接口添加非抽象方法，从而允许用方法实现来声明接口。要使用具有方法实现的接口，可以使用“default”关键字。此外，Lambda 表达式功能主要是通过默认方法实现的。这是一个使用接口声明的示例，包括方法实现:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="4997" class="lz ke iq mr b gy mv mw l mx my"><strong class="mr ir">interface </strong>IMyInterface {<br/>  <strong class="mr ir">default void </strong>defaultMethod(){<br/>    <em class="ml">// Detail implementation of method which does not allow before Java 8<br/>    </em>System.<strong class="mr ir"><em class="ml">out</em></strong>.println(<strong class="mr ir">"default method of interface"</strong>);<br/>  }<br/>}<br/><br/><strong class="mr ir">public class </strong>TechIsBeautiful <strong class="mr ir">implements </strong>IMyInterface{<br/>  <strong class="mr ir">public static void </strong>main(String[] args){<br/>    TechIsBeautiful techIsBeautiful = <strong class="mr ir">new </strong>TechIsBeautiful();<br/>    techIsBeautiful.defaultMethod();<br/>  }<br/>}</span></pre><p id="37d6" class="pw-post-body-paragraph lb lc iq ld b le mz lg lh li na lk ll lm nb lo lp lq nc ls lt lu nd lw lx ly ij bi translated">上面代码的输出:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="85d6" class="lz ke iq mr b gy mv mw l mx my">default method of interface</span><span id="c892" class="lz ke iq mr b gy ne mw l mx my">Process finished with exit code 0</span></pre><h2 id="da68" class="lz ke iq bd kf ma mb dn kj mc md dp kn lm me mf kr lq mg mh kv lu mi mj kz mk bi translated">选修课</h2><p id="2ad5" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">Java 8 在“java.util”包中包含了一个可选类。公共最终类“Optional”有助于避免 Java 应用程序中的 NullPointerException。有助于减少运行时避免 nullPointerException 所需的空检查次数的可选帮助。我们可以使用可选的类来防止应用程序在生产中意外崩溃和终止。可选类具有检查给定变量的值是否存在的方法。</p><p id="12b1" class="pw-post-body-paragraph lb lc iq ld b le mz lg lh li na lk ll lm nb lo lp lq nc ls lt lu nd lw lx ly ij bi translated">下面的示例代码演示了可选类的工作方式。为了验证这个应用程序中的字符串是否为空，我们利用可选类的“ofNullable”属性向用户抛出错误消息:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="e1e9" class="lz ke iq mr b gy mv mw l mx my"><strong class="mr ir">import </strong>java.util.Optional;<br/><br/><strong class="mr ir">public class </strong>TechIsBeautiful {<br/>  <strong class="mr ir">public static void </strong>main(String[] args) {<br/>    String[] string = <strong class="mr ir">new </strong>String[100];<br/>    Optional&lt;String&gt; isNull = Optional.<em class="ml">ofNullable</em>(string[1]);<br/><br/>    <strong class="mr ir">if </strong>(isNull.isPresent()) {<br/>      String word = string[1].toUpperCase();<br/>      System.<strong class="mr ir"><em class="ml">out</em></strong>.print(string);<br/>    }<br/>    <strong class="mr ir">else</strong>{<br/>      System.<strong class="mr ir"><em class="ml">out</em></strong>.println(<strong class="mr ir">"null string"</strong>);<br/>    }<br/>  }<br/>}</span></pre><p id="faf9" class="pw-post-body-paragraph lb lc iq ld b le mz lg lh li na lk ll lm nb lo lp lq nc ls lt lu nd lw lx ly ij bi translated">上面代码的输出:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="3a35" class="lz ke iq mr b gy mv mw l mx my">null string</span><span id="cb88" class="lz ke iq mr b gy ne mw l mx my">Process finished with exit code 0</span></pre><h2 id="c747" class="lz ke iq bd kf ma mb dn kj mc md dp kn lm me mf kr lq mg mh kv lu mi mj kz mk bi translated">可迭代接口中的 forEach()方法</h2><p id="96ae" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在 Java 8 中，Java.lang 接口支持一个“forEach”函数，这样它就可以迭代集合的项目。集合类使用它来迭代项，这扩展了 Iterable 接口。这种“forEach”帮助开发人员在编写代码时专注于业务逻辑。这是下面的示例代码，forEach 方法将 java.util.function.Consumer 对象作为参数，因此我们可以在一个可以重用的单独类中实现我们的逻辑。让我们看看“forEach”在一个简单的代码中是如何工作的:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="d105" class="lz ke iq mr b gy mv mw l mx my"><strong class="mr ir">import </strong>java.util.ArrayList;<br/><strong class="mr ir">import </strong>java.util.Iterator;<br/><strong class="mr ir">import </strong>java.util.List;<br/><strong class="mr ir">import </strong>java.util.function.Consumer;<br/><strong class="mr ir">import </strong>java.lang.Integer;<br/><br/><strong class="mr ir">public class </strong>TechIsBeautiful {<br/>  <strong class="mr ir">public static void </strong>main(String[] args) {<br/>    <em class="ml">// Sample ArrayList<br/>    </em>List&lt;Integer&gt; sampleIntegerList = <strong class="mr ir">new </strong>ArrayList&lt;Integer&gt;();<br/>    <br/>    <em class="ml">// Add element to ArrayList<br/>    </em><strong class="mr ir">for</strong>(<strong class="mr ir">int </strong>i=0; i&lt;10; i++) {<br/>      sampleIntegerList.add(i);<br/>    }<br/><br/>    <em class="ml">// Traverse using Iterator<br/>    </em>Iterator&lt;Integer&gt; iterator = sampleIntegerList.iterator();<br/>    <strong class="mr ir">while</strong>(iterator.hasNext()){<br/>      Integer i = iterator.next();<br/>      System.<strong class="mr ir"><em class="ml">out</em></strong>.println(<strong class="mr ir">"Value in iterator: "</strong>+i);<br/>    }<br/><br/>    <em class="ml">// Traverse through forEach method of Iterable with anonymous class<br/>    </em>sampleIntegerList.forEach(<strong class="mr ir">new </strong>Consumer&lt;Integer&gt;() {<br/>      <strong class="mr ir">public void </strong>accept(Integer t) {<br/>        System.<strong class="mr ir"><em class="ml">out</em></strong>.println(<strong class="mr ir">"Value in forEach anonymous class: "</strong>+t);<br/>      }<br/>    });<br/><br/>    <em class="ml">// Traverse with Consumer interface implementation<br/>    </em>CustomConsumer customConsumer = <strong class="mr ir">new </strong>CustomConsumer();<br/>    sampleIntegerList.forEach(customConsumer);<br/>  }<br/>}<br/><br/><em class="ml">// Custom Consumer that can be reused<br/></em><strong class="mr ir">class </strong>CustomConsumer <strong class="mr ir">implements </strong>Consumer&lt;Integer&gt;{<br/>  <strong class="mr ir">public void </strong>accept(Integer t) {<br/>    System.<strong class="mr ir"><em class="ml">out</em></strong>.println(<strong class="mr ir">"Value in Custom Consumer implementation: "</strong>+t);<br/>  }<br/>}</span></pre><p id="ed3e" class="pw-post-body-paragraph lb lc iq ld b le mz lg lh li na lk ll lm nb lo lp lq nc ls lt lu nd lw lx ly ij bi translated">上面代码的输出:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="cb96" class="lz ke iq mr b gy mv mw l mx my">Value in iterator: 0<br/>Value in iterator: 1<br/>Value in iterator: 2<br/>Value in iterator: 3<br/>Value in iterator: 4<br/>Value in iterator: 5<br/>Value in iterator: 6<br/>Value in iterator: 7<br/>Value in iterator: 8<br/>Value in iterator: 9<br/>Value in forEach anonymous class: 0<br/>Value in forEach anonymous class: 1<br/>Value in forEach anonymous class: 2<br/>Value in forEach anonymous class: 3<br/>Value in forEach anonymous class: 4<br/>Value in forEach anonymous class: 5<br/>Value in forEach anonymous class: 6<br/>Value in forEach anonymous class: 7<br/>Value in forEach anonymous class: 8<br/>Value in forEach anonymous class: 9<br/>Value in Custom Consumer implementation: 0<br/>Value in Custom Consumer implementation: 1<br/>Value in Custom Consumer implementation: 2<br/>Value in Custom Consumer implementation: 3<br/>Value in Custom Consumer implementation: 4<br/>Value in Custom Consumer implementation: 5<br/>Value in Custom Consumer implementation: 6<br/>Value in Custom Consumer implementation: 7<br/>Value in Custom Consumer implementation: 8<br/>Value in Custom Consumer implementation: 9</span><span id="9586" class="lz ke iq mr b gy ne mw l mx my">Process finished with exit code 0</span></pre><h2 id="a494" class="lz ke iq bd kf ma mb dn kj mc md dp kn lm me mf kr lq mg mh kv lu mi mj kz mk bi translated">用于集合上批量数据操作的 Java 流 API</h2><p id="66fd" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">Java 8 的另一个重要特性是新的流 API。java 8 中的“java.util.stream”包引入了一个新的 Streams API，可以并行处理 Java 集合的组件。Java 8 中增加了“java.util.stream”来对集合执行 filter/map/reduce 之类的操作。流 API 将允许顺序和并行执行，因此这非常有用。</p><p id="3d56" class="pw-post-body-paragraph lb lc iq ld b le mz lg lh li na lk ll lm nb lo lp lq nc ls lt lu nd lw lx ly ij bi translated">Java 集合接口已经用<em class="ml"> stream() </em>和<em class="ml"> parallelStream() </em>默认方法进行了扩展，以获得用于顺序和并行执行的流。以下示例将展示流的特征:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="60a2" class="lz ke iq mr b gy mv mw l mx my"><strong class="mr ir">import </strong>java.util.ArrayList;<br/><strong class="mr ir">import </strong>java.util.List;<br/><strong class="mr ir">import </strong>java.util.stream.Stream;<br/><br/><strong class="mr ir">public class </strong>TechIsBeautiful {<br/><br/>  <strong class="mr ir">public static void </strong>main(String[] args) {<br/><br/>    List&lt;Integer&gt; list = <strong class="mr ir">new </strong>ArrayList&lt;&gt;();<br/>    <strong class="mr ir">for</strong>(<strong class="mr ir">int </strong>i=0; i&lt;100; i++) list.add(i);<br/><br/>    <em class="ml">//sequential stream<br/>    </em>Stream&lt;Integer&gt; seqStream = list.stream();<br/><br/>    <em class="ml">//parallel stream<br/>    </em>Stream&lt;Integer&gt; parStream = list.parallelStream();<br/><br/>    <em class="ml">//using lambda with Stream API, filter example<br/>    </em>Stream&lt;Integer&gt; highNums = parStream.filter(a -&gt; a &gt; 95);<br/><br/>    <em class="ml">//using lambda in forEach<br/>    </em>highNums.forEach(a -&gt; System.<strong class="mr ir"><em class="ml">out</em></strong>.println(<strong class="mr ir">"Lambda in forEach with parallel: "</strong>+a));<br/><br/>    Stream&lt;Integer&gt; highNumsSeq = seqStream.filter(a -&gt; a &gt; 95);<br/>    highNumsSeq.forEach(a -&gt; System.<strong class="mr ir"><em class="ml">out</em></strong>.println(<strong class="mr ir">"Lambda in forEach with sequential: "</strong>+a));<br/><br/>  }<br/><br/>}</span></pre><p id="4ae3" class="pw-post-body-paragraph lb lc iq ld b le mz lg lh li na lk ll lm nb lo lp lq nc ls lt lu nd lw lx ly ij bi translated">上面代码的输出:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="dd03" class="lz ke iq mr b gy mv mw l mx my">Lambda in forEach with parallel: 96<br/>Lambda in forEach with parallel: 98<br/>Lambda in forEach with parallel: 97<br/>Lambda in forEach with parallel: 99<br/>Lambda in forEach with sequential: 96<br/>Lambda in forEach with sequential: 97<br/>Lambda in forEach with sequential: 98<br/>Lambda in forEach with sequential: 99</span><span id="fc7b" class="lz ke iq mr b gy ne mw l mx my">Process finished with exit code 0</span></pre><h2 id="34af" class="lz ke iq bd kf ma mb dn kj mc md dp kn lm me mf kr lq mg mh kv lu mi mj kz mk bi translated">Java 日期时间 API</h2><p id="0559" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">过去，在 Java 中处理日期、时间和时区非常不方便。Java 中没有处理日期和时间的标准方法。Java 8 中一个很好的新增功能是<code class="fe nf ng nh mr b">java.time</code>包，它将简化 Java 中处理时间的过程。Java 8 为“日期”和“时间”引入了新的 API，以解决旧的“java.util.Date”和“java.util.Calendar”的缺点。</p><h2 id="77f2" class="lz ke iq bd kf ma mb dn kj mc md dp kn lm me mf kr lq mg mh kv lu mi mj kz mk bi translated">集合，Java IO API 改进</h2><p id="ac1b" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><strong class="ld ir">采集 API </strong></p><p id="d729" class="pw-post-body-paragraph lb lc iq ld b le mz lg lh li na lk ll lm nb lo lp lq nc ls lt lu nd lw lx ly ij bi translated">正如我们在 Java 8 中探索集合的“forEach”方法和流 API 一样，集合 API 中还有许多其他改进:</p><ul class=""><li id="3fb4" class="ni nj iq ld b le mz li na lm nk lq nl lu nm ly nn no np nq bi translated">HashMap 类的性能改进。</li><li id="763d" class="ni nj iq ld b le nr li ns lm nt lq nu lu nv ly nn no np nq bi translated">地图新增<code class="fe nf ng nh mr b">replaceAll()</code>、<code class="fe nf ng nh mr b">compute()</code>、<code class="fe nf ng nh mr b">merge()</code>方法。</li><li id="3af9" class="ni nj iq ld b le nr li ns lm nt lq nu lu nv ly nn no np nq bi translated"><code class="fe nf ng nh mr b">Iterator</code>默认方法<code class="fe nf ng nh mr b">forEachRemaining(Consumer action)</code>对每个剩余的元素执行给定的动作，直到所有的元素都被处理完或者动作抛出异常。</li><li id="7896" class="ni nj iq ld b le nr li ns lm nt lq nu lu nv ly nn no np nq bi translated"><code class="fe nf ng nh mr b">Collection</code>默认方法<code class="fe nf ng nh mr b">removeIf(Predicate filter)</code>删除集合中满足给定谓词的所有元素</li></ul><p id="22ad" class="pw-post-body-paragraph lb lc iq ld b le mz lg lh li na lk ll lm nb lo lp lq nc ls lt lu nd lw lx ly ij bi translated"><strong class="ld ir"> Java IO API </strong></p><p id="d318" class="pw-post-body-paragraph lb lc iq ld b le mz lg lh li na lk ll lm nb lo lp lq nc ls lt lu nd lw lx ly ij bi translated">Java 8 中 Java IO API 有一些改进:</p><ul class=""><li id="edda" class="ni nj iq ld b le mz li na lm nk lq nl lu nm ly nn no np nq bi translated"><code class="fe nf ng nh mr b">Files.lines(Path path)</code>从一个文件中读取所有行作为一个流。</li><li id="b23f" class="ni nj iq ld b le nr li ns lm nt lq nu lu nv ly nn no np nq bi translated"><code class="fe nf ng nh mr b">Files.find()</code>它返回一个流，该流通过在以给定的起始文件为根的文件树中搜索文件来惰性地填充 Path。</li><li id="1328" class="ni nj iq ld b le nr li ns lm nt lq nu lu nv ly nn no np nq bi translated">返回一个流，其元素是从 BufferedReader 中读取的行。</li></ul><h1 id="1304" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">摘要</h1><p id="3d69" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在本文中，我们通过示例代码了解了 Java 8 的一些新特性和改进。当然，在 Java 8 JDK 包和类中还有许多其他的改进。然而，本文中分享的信息是探索和学习 Java 8 的一些新特性的一个很好的切入点。你可以阅读更多我的 Java 版本系列的新特性:</p><ul class=""><li id="52a3" class="ni nj iq ld b le mz li na lm nk lq nl lu nm ly nn no np nq bi translated"><a class="ae kc" href="https://medium.com/@techisbeautiful/java-17-top-5-features-you-must-know-bbed2afaea3d" rel="noopener">你必须知道的 Java 17: 5 特性</a></li><li id="76cf" class="ni nj iq ld b le nr li ns lm nt lq nu lu nv ly nn no np nq bi translated"><a class="ae kc" href="https://medium.com/@techisbeautiful/new-features-you-must-know-in-java-11-and-examples-3fda2ad26def" rel="noopener">你必须知道的 Java 11: 8 特性</a></li><li id="4ad4" class="ni nj iq ld b le nr li ns lm nt lq nu lu nv ly nn no np nq bi translated"><a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/java-8-seven-features-you-must-know-and-examples-1c3964ae7fe8">你必须知道的 Java 8 : 7 特性</a></li></ul></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><p id="c103" class="pw-post-body-paragraph lb lc iq ld b le mz lg lh li na lk ll lm nb lo lp lq nc ls lt lu nd lw lx ly ij bi translated">如果你喜欢这个故事，请<a class="ae kc" href="https://medium.com/@techisbeautiful" rel="noopener">关注</a>，<a class="ae kc" href="https://medium.com/subscribe/@techisbeautiful" rel="noopener">让我</a>成为第一个收到我下一个故事邮件的人。</p><p id="9af3" class="pw-post-body-paragraph lb lc iq ld b le mz lg lh li na lk ll lm nb lo lp lq nc ls lt lu nd lw lx ly ij bi translated"><a class="ae kc" href="https://medium.com/@techisbeautiful/membership" rel="noopener">你可以在这里</a>成为媒介会员，拥有<strong class="ld ir">无限访问</strong>媒介平台上的每一个故事。如果你使用上面的链接，它也支持我，因为我有一个来自 Medium 的小佣金。谢谢大家！</p></div></div>    
</body>
</html>