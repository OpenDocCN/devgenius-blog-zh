<html>
<head>
<title>Building a low-code platform with Neo4j (3/4) — Frames and Views</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Neo4j (3/4)构建低代码平台—框架和视图</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/building-a-low-code-platform-with-neo4j-3-4-frames-and-views-ae7441eb051a?source=collection_archive---------9-----------------------#2020-06-12">https://blog.devgenius.io/building-a-low-code-platform-with-neo4j-3-4-frames-and-views-ae7441eb051a?source=collection_archive---------9-----------------------#2020-06-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/ad7138be91994177a62bcf593aedb72d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wqG6kxn7ct8HpMlyuoS-6A.png"/></div></div></figure><div class=""/><p id="4ac7" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">关于如何开始创建一个低代码平台的本系列的第3/4部分解释了创建页面的设计和功能。正是平台的UI“引擎”让(低代码)开发者和最终用户真正使用平台。</p><h2 id="1cd1" class="kt ku iy bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">要求</h2><p id="f167" class="pw-post-body-paragraph jv jw iy jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">灵活性是重中之重。让我们把它变得更加有形。实现这一目标的两个主要方面是:</p><p id="90ca" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">以任何方式显示任何类型的数据— </strong>泛型至关重要。这里应该忽略任何细节，因为那会使<em class="lr">低位代码</em>变得无用。因此，页面应该能够以任何方式显示任何类型的数据。因为我们已经有了树枝，工作已经完成了一半。另一半是让这些小枝模板以合理的方式使用数据。</p><p id="a93d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">内联数据加载/动作— </strong>行为也是需要的:当用户点击一些东西时，需要发生一些事情。通常加载更多/不同的数据或执行动作。(我们将在不同的时间进行操作:-)。</p><h2 id="f8d2" class="kt ku iy bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">屏幕的元模型</h2><p id="a00f" class="pw-post-body-paragraph jv jw iy jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">这里可以有很多方向。这一个远未完成，但很好地表达了观点。它展示了使用几个基本概念可以做些什么:</p><figure class="lt lu lv lw gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi ls"><img src="../Images/0c2d271898215ce1cd5ecb4a151ad27e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-KlycZ1J5UR0hEpw70DRuA.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">屏幕的元模型</figcaption></figure><p id="79aa" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在Symfony中，通过URL加载的页面可以是普通的html或symfony/twig类型的页面。在概念验证中，我添加了框架的概念../框架/..和../FrameN/..-路线)。使用框架时，将执行以下操作:</p><ul class=""><li id="2f79" class="mb mc iy jx b jy jz kc kd kg md kk me ko mf ks mg mh mi mj bi translated">该帧及其startView被加载、呈现并发送到浏览器。</li><li id="1672" class="mb mc iy jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated">浏览器可能会执行onLoad，这可能会触发加载其他视图(通过ajax-call)。</li><li id="8ff3" class="mb mc iy jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated">一旦完全加载，用户可以点击触发加载另一个视图/框架的东西。(对于每个视图，需要给出上下文(元类型),因此后端知道将什么参数传递给视图查询。)</li></ul><p id="46c1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因为PoC使用了Screens元模型的功能，所以twig非常有用。它的多功能性有助于快速创建框架和视图。使用它的包含方法，这些部分可以被分割成任何粒度。</p><p id="12c3" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每个视图都有一个附加的查询。这就是视图中数据的来源。如果这不是PoC，就不会是原始的Neo4j查询。为了创建一个查询，我设想您点击您的元模型，选择您想要显示的节点、关系和属性，并选择您想要如何显示它们。</p><h2 id="28c0" class="kt ku iy bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">看起来怎么样？</h2><p id="60ae" class="pw-post-body-paragraph jv jw iy jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">PoC中的所有内容都是框架和视图。databrowser本身的列表页面(在第2部分中提到过)由框架和视图组成。因为它都是基于html/twig构建的，所以它可以是你想要的任何样子。对于那些没有尝试过的人来说，概念验证是这样的:</p><figure class="lt lu lv lw gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mp"><img src="../Images/bd4a6b9b8e4e7ee10d97c7ab743df2d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-bNBtsQJhAh16dg2wJNZwg.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">Inception:数据浏览器是由框架和视图组成的，所以它是使用自己的功能定义的</figcaption></figure><p id="ca47" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">是的，标准引导。:-)</p><p id="0513" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">更重要的是，功能模块、框架和视图基本上形成了用于所有数据结构的独立数据输入和查看应用程序。就像你看到的那样。</p><h2 id="beb8" class="kt ku iy bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">将屏幕元模型推进了一步</h2><p id="20f1" class="pw-post-body-paragraph jv jw iy jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">为了演示屏幕元模型的一些功能，我写了:</p><p id="e04a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">视图控制器(功能模块)</strong> —包含结构和实例的默认框架和视图。</p><p id="60f5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">repo中有一个F1示例(在/examples文件夹中),可以真正理解这些框架和视图的要点。我在这里解释一下，但是最好看一下实际操作。相信我。</p><p id="4b01" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">示例中的url以如下所示的页面开始。</p><p id="7b25" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它会自动选择2020年，但没有数据，因为还没有任何比赛……:-(所以选择2019年。这将执行为元类型赛季找到的第一个视图，即<em class="lr">构造者锦标赛结果</em>，并在右侧面板中显示结果。现在，如果你点击赛季中的<em class="lr">比赛，你的页面将看起来像这样:</em></p><figure class="lt lu lv lw gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mq"><img src="../Images/3f35951325b9f3cec385ae42aaa83785.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qQrKx0ccEmFBy5o177DIqQ.png"/></div></div></figure><p id="9a4f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这才是有趣的开始。点击西班牙大奖赛(右下角)。这样做之后，右视图将替换左视图，中间的上下文(元类型)将切换到<em class="lr"> Race(因为您已经单击了Race类型的项目)。</em>因此，该上下文的视图将被加载。在这种情况下，2019年西班牙大奖赛的比赛结果是:</p><figure class="lt lu lv lw gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mr"><img src="../Images/dc54a59ee8b211457e57b87ff09cff4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n8NWUKkyb7ma4ZyvmnZ2bg.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">点击“西班牙大奖赛”将中间视图的上下文切换到这场比赛(并显示相应的比赛视图)</figcaption></figure><p id="42d5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您也可以单击电路名称(Circuit de Barcelona-Catalunya ),上下文将切换到电路并显示该上下文的视图:</p><figure class="lt lu lv lw gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi ms"><img src="../Images/ebc841a63aaf68b4923c91867404cf7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6PfxnWzKZfPBf5OSK9Ijtw.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">单击回路名称会将中间视图的上下文切换到回路(并显示回路的相应视图)</figcaption></figure><p id="13c7" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这显示了一场比赛在那里举行的所有季节，以及哪个车手赢得了那场比赛…你可以点击所有的数据。点击任何赛季，赛道，车手，制造商或比赛。如果你热爱F1，你会忙上一阵子。:-)</p><p id="188c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过创建一个新视图、编写一个Neo4j查询并选择它的元类型，您可以很容易地将视图添加到任何上下文中。带有查询的<em class="lr">节点视图将检索与该元类型相关的所有视图，视图模板将制作按钮，以便您可以加载它们。</em></p><h2 id="d0ca" class="kt ku iy bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">最后一步:无限多功能</h2><p id="2922" class="pw-post-body-paragraph jv jw iy jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">这显示了屏幕和视图控制器协同工作的元模型的多功能性。现在，您脑海中的某个地方应该有这样一个问题:当这不是一个简单的概念验证，而是一个成熟的应用程序时，可以做些什么？</p><p id="4fe2" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">提示模块化或功能模块。完全由你来想象你希望系统做什么，把它通用化(或具体化)并放到一个功能模块里。</p><p id="8f32" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">构建功能模块在第4部分的<a class="ae mt" href="https://medium.com/@stefan.dreverman/building-a-low-code-platform-with-neo4j-4-4-the-rabbit-hole-1dbf376c452" rel="noopener">中解释。</a></p><blockquote class="mu mv mw"><p id="52ef" class="jv jw lr jx b jy jz ka kb kc kd ke kf mx kh ki kj my kl km kn mz kp kq kr ks ig bi translated"><strong class="jx iz"> <em class="iy"> …看一看:</em> </strong> <em class="iy">我为你发布了一个PoC，让你发现它的内部工作原理，然后决定构建你自己的PoC。可以在</em><a class="ae mt" href="http://github.com/sfdreverman/infonotion" rel="noopener ugc nofollow" target="_blank"><em class="iy">GitHub—info opinion</em></a><em class="iy">上找到。</em>(想贡献或建立真正的交易？请给我发个短信！)</p></blockquote></div></div>    
</body>
</html>