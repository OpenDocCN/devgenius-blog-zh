<html>
<head>
<title>Circuit Breakers in Microservices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务中的断路器</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/circuit-breakers-in-microservices-625654df0830?source=collection_archive---------2-----------------------#2020-06-12">https://blog.devgenius.io/circuit-breakers-in-microservices-625654df0830?source=collection_archive---------2-----------------------#2020-06-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ce5ee3094246a34ebd51931ca8741296.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4uscBdP2RYi95nmT"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@ffstop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Fotis Fotopoulos </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="6331" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://en.wikipedia.org/wiki/Circuit_breaker_design_pattern#:~:text=Circuit%20breaker%20is%20a%20design,failure%20or%20unexpected%20system%20difficulties." rel="noopener ugc nofollow" target="_blank">断路器</a>是一种设计模式，广泛用于分布式系统中，以防止级联故障。在本帖中，我们将讨论级联故障的问题，并回顾断路器模式是如何使用的。</p><h1 id="c053" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">动机:级联故障的问题</h1><p id="4b06" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在进入断路器模式之前，让我们试着理解它试图解决什么问题。<br/>当服务A试图与服务B通信时，它会分配一个线程来进行调用。打电话时可能会出现两种故障。我们使用一个<code class="fe me mf mg mh b">user</code>服务调用<code class="fe me mf mg mh b">friends</code>服务的例子。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f0ec" class="mq lc iq mh b gy mr ms l mt mu">''' user service ''' <br/>def get_user_info(user_id: str):  <br/>    try:    <br/>        friends_service.get_friends(user_id)  <br/>    except Exception as e:    <br/>        raise InternalServerError</span></pre><p id="e631" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">立即失败</strong>:在立即失败中，会立即引发一个异常(比如:连接被拒绝)并释放服务A线程。</p><p id="0b44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">超时失败</strong>:如果service_b需要很长时间来响应，当我们收到服务A的新请求时，我们会有越来越多的线程等待service_b。如果在等待超时时发出几个请求，这可能会耗尽服务A的线程池，并使服务A停止运行。</p><blockquote class="mv mw mx"><p id="ccf9" class="kd ke my kf b kg kh ki kj kk kl km kn mz kp kq kr na kt ku kv nb kx ky kz la ij bi translated">你的代码不能永远等待一个可能永远不会出现的响应，迟早，它需要放弃。希望不是一种设计方法。“——迈克尔·t·尼加德，释放它！</p></blockquote><p id="e706" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们通过一个社交媒体应用程序的例子来更好地理解这一点。这里我们有一个<code class="fe me mf mg mh b">aggregator</code>服务，它是客户端与之交互的对象，它聚集了包括<code class="fe me mf mg mh b">user</code>服务在内的一系列服务的结果。<code class="fe me mf mg mh b">User</code>服务调用<code class="fe me mf mg mh b">photo</code>服务，<code class="fe me mf mg mh b">friends</code>服务又调用<code class="fe me mf mg mh b">friends_db</code>。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/f5fadea0a352e81d654182c0ff44d7d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ATpjXiqpzrSlG_wF.jpg"/></div></div></figure><p id="209c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，friends服务试图向friends_db发出请求，但是，friends_db并没有立即失败，而是让来自“friends”服务的线程等待。朋友服务尝试重试，从而使用更多的线程。当它收到新的请求时，更多的线程等待friends_db响应。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/c52e36b9d810d5353dcb4ee03b0cdda4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lpwDvhvIzAd8YAjU.jpg"/></div></div></figure><p id="5c04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在可以看到朋友服务是如何成为用户服务超时的来源的。用户服务耗尽它的线程池等待来自朋友服务的请求，就像朋友服务等待friends_db一样。我们现在可以看到friends_db中的故障是如何导致间接依赖它的服务中的<em class="my">级联故障</em>的。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/f4bf54b4dfcd6a46025a6be20a16bd99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0o6T8HLvtOLMkKJn.jpg"/></div></div></figure><p id="21cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最终，聚合器服务也会因为同样的原因而关闭。客户端调用聚合器服务，因此我们的系统对于用户来说是有效关闭的。我们看到我们架构中一个组件的一个错误如何导致级联故障，使所有其他服务停止。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/6b87b2a14795607a00dc8b73cf887adf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hpLNR3kVpr7DbvoV.jpg"/></div></div></figure><h1 id="09cf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">断路器模式</h1><p id="4766" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">断路器通常被实现为<a class="ae kc" href="https://en.wikipedia.org/wiki/Interceptor_pattern" rel="noopener ugc nofollow" target="_blank">拦截器模式</a>/责任链/过滤器。它由3个状态组成:</p><ul class=""><li id="4edd" class="ne nf iq kf b kg kh kk kl ko ng ks nh kw ni la nj nk nl nm bi translated">Closed:允许所有请求传递给上游服务，拦截器将上游服务的响应传递给调用者。</li><li id="3c09" class="ne nf iq kf b kg nn kk no ko np ks nq kw nr la nj nk nl nm bi translated">Open:不允许将任何请求传递给上游响应和拦截器响应，默认响应通常是错误响应。</li><li id="ac64" class="ne nf iq kf b kg nn kk no ko np ks nq kw nr la nj nk nl nm bi translated">半开:一些请求被允许传递给上游，其他请求被终止并以默认响应响应。</li></ul><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ns"><img src="../Images/c5685ba2e5d28194b018cb33598efc0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iVNtomiB2iOEjgbs.jpg"/></div></div></figure><p id="c13d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下图显示了断路器拦截器的三种状态</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/66339630f4bcafcccf60ef9e80039c47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4o6YzFo61UV1OwUx.jpg"/></div></div></figure><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/d39afca2ed2ac4549283c5ebed6d8c33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5MG1tmS4T-0gwdoH.jpg"/></div></div></figure><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/ae59b97a3fad05b3aaf5446c1ca069f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*b6WLM8YlHTkQbfxH.jpg"/></div></div></figure><p id="a12f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看一个关于断路器的Python例子。您可以使用以下工具创建自己的断路器:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="afa8" class="mq lc iq mh b gy mr ms l mt mu">from circuitbreaker import CircuitBreaker</span><span id="e860" class="mq lc iq mh b gy nt ms l mt mu">class MyCircuitBreaker(CircuitBreaker):<br/>    FAILURE_THRESHOLD = 20<br/>    RECOVERY_TIMEOUT = 60<br/>    EXPECTED_EXCEPTION = RequestException</span><span id="9db1" class="mq lc iq mh b gy nt ms l mt mu">@MyCircuitBreaker()<br/>def get_user_info(user_id):<br/>  try:<br/>    friends_service.get_friends(user_id)<br/>  except Exception as e:<br/>    raise InternalServerError</span></pre><p id="7ec5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以利用边车模式来实现这一点。在这种方法中，我们不必通过包装断路器来修改我们的服务，相反，我们用像<a class="ae kc" href="https://www.envoyproxy.io/" rel="noopener ugc nofollow" target="_blank">特使</a>这样的边车来运送我们的应用程序。该服务的所有出站流量都是通过envoy代理的。特使支持打破常规。以下是使用Envoy断开电路的配置示例:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="99b4" class="mq lc iq mh b gy mr ms l mt mu">circuit_breakers:<br/>  thresholds:<br/>    - priority: DEFAULT<br/>      max_connections: 1000<br/>      max_requests: 1000<br/>    - priority: HIGH<br/>      max_connections: 2000<br/>      max_requests: 2000</span></pre><p id="cc50" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">原贴:<a class="ae kc" href="http://iyer.ai/circuit-breakers-in-microservices/" rel="noopener ugc nofollow" target="_blank">http://iyer.ai/circuit-breakers-in-microservices/</a></p><p id="d699" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢尼尚·甘地的投入。</p><h1 id="fa75" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">资源</h1><ul class=""><li id="27a7" class="ne nf iq kf b kg lz kk ma ko nw ks nx kw ny la nj nk nl nm bi translated"><a class="ae kc" href="http://martinfowler.com/bliki/CircuitBreaker.html" rel="noopener ugc nofollow" target="_blank">http://martinfowler.com/bliki/CircuitBreaker.html</a></li><li id="c352" class="ne nf iq kf b kg nn kk no ko np ks nq kw nr la nj nk nl nm bi translated"><a class="ae kc" href="https://pypi.org/project/circuitbreaker/" rel="noopener ugc nofollow" target="_blank">https://pypi.org/project/circuitbreaker/</a></li><li id="3700" class="ne nf iq kf b kg nn kk no ko np ks nq kw nr la nj nk nl nm bi translated"><a class="ae kc" href="https://books.google.com/books/about/Release_It.html?id=Ug9QDwAAQBAJ&amp;source=kp_book_description" rel="noopener ugc nofollow" target="_blank">https://books.google.com/books/about/Release_It.html?发布它(书)id = ug 9 qdwaaqbaj&amp;source = KP _ book _ description</a></li><li id="bb32" class="ne nf iq kf b kg nn kk no ko np ks nq kw nr la nj nk nl nm bi translated">特使断路:<a class="ae kc" href="https://www.envoyproxy.io/learn/circuit-breaking" rel="noopener ugc nofollow" target="_blank">https://www.envoyproxy.io/learn/circuit-breaking</a></li></ul></div></div>    
</body>
</html>