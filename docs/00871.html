<html>
<head>
<title>Why Shouldn’t We Program by Coincidence?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么我们不能通过巧合来编程呢？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/why-shouldnt-we-program-by-coincidence-d1b3e2239ba0?source=collection_archive---------17-----------------------#2020-06-18">https://blog.devgenius.io/why-shouldnt-we-program-by-coincidence-d1b3e2239ba0?source=collection_archive---------17-----------------------#2020-06-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1d0543b4cc10fc10f5fcdd9266919d98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OR_NcMuerKynAmgC"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">迈克尔·泽兹奇在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="903d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">写程序不是一个机械的过程。这是因为在编写程序时，我们有很多事情要考虑。</p><p id="e586" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们看看什么是巧合编程，为什么我们不应该这样做，我们应该做什么。</p><h1 id="35be" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">巧合编程</h1><p id="8617" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">巧合编程是指我们只写了一些代码，然后在看起来运行正常后停止编程，却不知道我们当初为什么要写这些代码。</p><p id="cd83" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">巧合地编程是个坏主意，因为我们不知道我们在做什么。</p><p id="33d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只是写一些代码，并希望它能工作。</p><p id="3f42" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这浪费了很多时间，因为我们只是猜测和测试。此外，可能会有我们没有发现的错误。</p><p id="2a2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个过程中，我们可能也没有想到任何边缘情况。</p><p id="297d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们应该做的是有意识地编程。当我们编程时，我们必须知道我们在做什么，为什么要做。</p><h1 id="9320" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">隐含假设</h1><p id="83d4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">巧合会在任何地方误导我们。当我们做出改变时，产生测试需求会误导我们。</p><p id="63be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们在测试中做出错误的假设，那么我们可能会得到错误的肯定或否定，这是不好的。</p><p id="1a40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不能假设任何事情，我们必须向他们清楚地证明这些问题确实存在或者已经被消除。</p><h1 id="8379" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">如何有意识地编程</h1><p id="b05e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了产生更少的错误，花更少的时间编写和修改代码，我们必须有意识地编程。</p><p id="e3e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着我们应该知道自己在做什么。</p><p id="c537" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不要在蒙着眼睛的情况下工作，不要试图做一些我们不完全理解的事情，不要不假思索地使用我们不熟悉的东西。</p><p id="d163" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另外，我们需要一个计划。它可能存在于我们的脑海中或其他地方。</p><p id="17e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们必须依靠可靠的东西。我们永远不要把我们的思想建立在任何假设的基础上。我们能做的就是假设最坏的情况会发生。</p><p id="bcdd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">记录我们的假设也很重要。我们必须在自己的头脑中澄清我们的假设，并帮助将它们传达给其他人。</p><p id="7665" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们要测试我们的代码和我们的假设。他们可能都是错的或者有问题。</p><p id="2d97" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">努力要有轻重缓急。我们应该先把时间花在更重要的事情上。这些可能是困难的部分。</p><p id="fea0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得把基本原则搞对。</p><p id="2c61" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现有的代码应该决定未来的代码是什么样子。我们应该从一开始就以正确的方式编写自己的代码。</p><p id="3da1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着我们应该随时准备重构我们的代码。这可能会影响我们的项目进度，但不应该认为现在更快地完成工作不会在以后减慢我们的速度。</p><h1 id="e40e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">算法速度</h1><p id="3fe9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当我们设计代码时，我们必须考虑算法的速度。</p><p id="bab2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对用户来说，它必须足够快，这样他们才会是快乐的用户。几乎每个人都会对缓慢的代码不满意。</p><p id="351a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们需要估计我们的算法在现实世界中会如何运行。</p><p id="a459" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大多数重要的算法不是线性的。其中许多更糟，它们可能是正在处理的数据量的指数或幂。</p><p id="5e65" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对算法速度的估计用 O(n)表示，其中 n 是正在处理的项目数。n 可以用其他多项式、阶乘或对数代替。</p><p id="9f6c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">O(n)表示时间随 n 线性增加的代码，O(log n)表示我们算法的运行时间与 n 的对数成正比。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/028a409711287871082db9c5690f7981.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*H3GDvx6uygxW4dMR"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@andrewtneel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">安德鲁·尼尔</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><h1 id="96cf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">常识估计</h1><p id="d613" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用这些常识来估计算法的运行时间:</p><ul class=""><li id="4deb" class="mj mk iq kf b kg kh kk kl ko ml ks mm kw mn la mo mp mq mr bi translated">简单循环— O(n)</li><li id="b314" class="mj mk iq kf b kg ms kk mt ko mu ks mv kw mw la mo mp mq mr bi translated">嵌套循环— O(m x n)，其中 m 和 n 是循环的极限</li><li id="810f" class="mj mk iq kf b kg ms kk mt ko mu ks mv kw mw la mo mp mq mr bi translated">combinatoric — O(n！)</li><li id="f5b4" class="mj mk iq kf b kg ms kk mt ko mu ks mv kw mw la mo mp mq mr bi translated">二进制 chop(一种在每次迭代中我们将考虑的事情减半的算法)— O(log n)</li></ul><h1 id="370b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">估计我们算法的顺序</h1><p id="87a2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">从我们写的代码中，我们已经可以对算法的时间复杂度有一个粗略的概念。</p><p id="e4af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，如果我们使用的算法太慢，那么我们就要考虑如何让它们更快。</p><p id="0928" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不希望我们的生产代码太慢或占用太多资源。</p><p id="8323" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们完成了我们的解决方案，我们必须测试我们的估计，以确认我们是正确的。</p><h1 id="162a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="04af" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当我们写代码的时候，我们必须知道我们为什么要做。这也意味着我们应该在代码中做太多的假设。</p><p id="915e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们应该在编写任何代码之前估计算法的时间复杂度，以确保它们不会太慢。</p></div></div>    
</body>
</html>