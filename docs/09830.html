<html>
<head>
<title>How to estimate algorithms? Part I, Watch and notice</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何估计算法？第一部分，观察和注意</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-estimate-algorithms-part-i-watch-and-notice-e3eaa1788d6a?source=collection_archive---------20-----------------------#2022-09-15">https://blog.devgenius.io/how-to-estimate-algorithms-part-i-watch-and-notice-e3eaa1788d6a?source=collection_archive---------20-----------------------#2022-09-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6e89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大家好。在本系列文章中，我将尝试总结一些关于算法估计的想法，希望能帮助您更好地理解它。</p><p id="4c4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将尝试一套由历史上的计算机科学家开发的系统方法，比较数字，做一些数学计算，看看每一种方法的优缺点。</p><p id="354d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通常情况下，我们并不认为这样的话题会很有趣，因为那不是一堆数学和情节用来给我们生活带来的东西，但我在这里的工作是让它比你在书中所能找到的更简单😄</p><p id="7300" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于代码示例，我将使用 Java 编程语言，但我不会深入研究标准库，只会有在您认为更方便的另一种语言上可再现的基本用法。</p><p id="acdf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl">注意:</em> </strong> <em class="kl">如果你熟悉增长顺序这个术语，看到下面描述的原始方法你可能会有些痛苦，但我的目标是通过历史展示这种方法的发展，我计划在该系列的最新文章中介绍更复杂和精确的估计方法。</em></p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="00ce" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">问题陈述❓</h1><p id="7c0c" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">Elvis 是一名软件开发人员，他试图想出一个解决简单排序问题的方法:输入<em class="kl"> N </em>个数字，目标是按升序对这些数字进行排序..</p><p id="c761" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于这个问题，埃尔维斯有一个解决方案，但他不知道它是好是坏。坦率地说，他不知道在这种情况下“坏”和“好”是什么意思，因为他不知道如何<em class="kl">测量</em>或<strong class="jp ir">估计</strong>他的解决方案的质量。</p><p id="db42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看下面<strong class="jp ir"> <em class="kl">非常熟悉的</em> </strong>代码。</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">简单的冒泡排序实现</figcaption></figure></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="1b65" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">测量执行时间⏰</h1><p id="6b1a" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">首先，假设 Elvis 已经用 Java 实现了他的解决方案，我们可以提出，程序的运行时间将是最合适的质量度量:如果它很慢——那么它是一个糟糕的解决方案，否则——它是一个好的解决方案。这是最重要的指标，也是最容易实现的指标。让我们试着观察跑步时间的结果。请记住，执行时间可能取决于输入元素的大小，所以让我们对代表输入数组初始大小的<em class="kl"> N </em>的递增序列进行采样，并尝试使用该输入运行程序。</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="32bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是如果<em class="kl"> N </em>非常大呢？那么我们可以测量执行时间吗？等待结果可能非常耗时(当然也是不可持续的)，而且它只显示了特定的<em class="kl"> N </em>的时间。如果我们能够以某种方式推断出任何<em class="kl"> N、</em>的执行时间，不管它有多长，这将是完美的。</p><p id="fcd6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们是科学家，第一个想法是绘制一个图并寻找可能的相关性。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/fcc0d61269a5761521673645847832da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*fJNJo3FTA56cWQyIp57Prg.png"/></div></figure><p id="2ef4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">嗯，结果不太有代表性。我们无法确定<em class="kl"> N </em>和<em class="kl"> T(N) </em>之间是什么依赖关系。因此，我们既不能将其形式化为一条定律，也不能因此预测超大<em class="kl"> N </em>的运行时间，因为，正如它通常在繁琐的程序中发生的那样，这可能需要几个小时(对于更昂贵的算法，可能需要几年)。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="dd41" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">闭嘴，直线前进📈</h1><p id="3106" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">在实用科学中，许多量可以描述为幂律。让我们假设我们是数学家，并假设数字遵循定律:</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/1436c0408306041cdcbfa0bfe6bcc882.png" data-original-src="https://miro.medium.com/v2/resize:fit:246/format:webp/1*Co6up-yJyVhem4pmaJ-zHQ.png"/></div></figure><p id="6a77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是定义一个<em class="kl"> n </em>有一个小问题，因为我们不确定它如何影响一个<em class="kl"> x-y </em>依赖关系，以及我们现在有什么幂律。</p><p id="bb5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们做一些数学计算，对两边都应用对数。我们将使用<em class="kl"> log2 </em>来完成它，就像我们在计算机科学中使用的一样，但是实际上，在这里，我相信基数并不重要。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/37d2daae95e077331cc2f6ff0e5ad367.png" data-original-src="https://miro.medium.com/v2/resize:fit:564/format:webp/1*KNcAUX6Ngm7ZnFoon042KQ.png"/></div></figure><p id="fe77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是啊！这样更好看，对吧？线性定律似乎更适合定义<em class="kl"> b </em>和<em class="kl"> N </em>来解开我们的幂律之谜。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="d5b7" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">可疑加倍</h1><p id="1129" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">最快速的方法是遵循加倍的方法:我们简单地将输入大小加倍，然后测量执行时间，然后找到比率<em class="kl"> 2N/N。</em></p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/a310e178ba6a53415e9fd3e682ec5e6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*cmEsF2ioidFG3ecW6_hYAQ.png"/></div></figure><p id="88f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里最重要的是定义一个对数(比率)在哪个点会有一个稳定的值，比如+-常数(是的，这种方法非常经验性)，然后假设这是我们的目标值。</p><p id="37fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的例子中，n 等于 2，这在这里实际上是有意义的，如果你看代码(如果你熟悉增长顺序的话题，你会发现，这个函数有二次复杂度😛).</p><p id="6034" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好吧，假设我们的依赖关系是一个幂律——剩下的唯一事情就是猜测一个<em class="kl"> C </em>值，当我们知道 n 和<em class="kl"> C </em>时，计算起来相当简单。最终会有这样的东西。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mn"><img src="../Images/84218ab0c8cca7766c190d500f37b05b.png" data-original-src="https://miro.medium.com/v2/resize:fit:414/format:webp/1*p-FE9KTnNV_NerwDXdHPMA.png"/></div></div></figure><p id="3367" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我不想说这是否准确，当我们谈论任何评估时，有太多的事情需要我们考虑，比如您在哪个硬件上运行该代码，以及您使用哪个软件，等等。但至少它说了一些关于依赖函数的顺序，这让我们可以在未来做一些有用的假设。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="a95e" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">总结和承认</h1><p id="a071" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">不管怎样，那是一次相当好的经历，坦率地说，我第一次写这个话题，所以我很高兴能够深入研究并试图理解最基本的东西。</p><p id="6e6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一次我将写增长的顺序，以及人们对待算法估计有多认真，所以请继续关注！</p><p id="d96b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，注意安全，❤️</p></div></div>    
</body>
</html>