<html>
<head>
<title>HTML5 RSS Reader: writing specialized web components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">HTML5 RSS 阅读器:编写专门的 web 组件</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/html5-rss-reader-writing-specialized-web-components-8c8a972e681a?source=collection_archive---------11-----------------------#2022-05-04">https://blog.devgenius.io/html5-rss-reader-writing-specialized-web-components-8c8a972e681a?source=collection_archive---------11-----------------------#2022-05-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/db32c5bafa97d1226e2fb0c4b8a43d2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Odx_-0eiatakPZiz"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@sigmund?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">西格蒙德</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="7a6c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上次我们为我们的 RSS 阅读器<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/the-responsive-layout-for-our-rust-web-application-8fb46fe14c8f">响应式</a> web <a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/initial-setup-for-a-rust-web-application-using-web-components-and-native-javascript-modules-ee832c062e8a">应用程序</a>使用了<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/html5-rss-reader-writing-the-first-web-components-949eec88dbf9">第一个 web 组件</a>。到目前为止，我们讨论了 web 资源的延迟加载:CSS 和 Javascript 引用都是由需要它们的组件进行的，而不是由<code class="fe lb lc ld le b">index.html</code>进行的。我们还解释了现代 Javascript 如何在不需要任何编译器、捆绑器、框架或任何其他第三方系统的情况下做到这一点。</p><p id="01d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还学习了如何使用扩展 HTML 元素<code class="fe lb lc ld le b">&lt;ul is=”custom-list”&gt;</code>的<code class="fe lb lc ld le b">is</code>属性来应用 web 组件。不是说<code class="fe lb lc ld le b">&lt;custom-list&gt;</code>不正确，但是在 Firefox 中，至少这种语法会产生实例化错误。此外，当前的 web 组件文档更喜欢使用<code class="fe lb lc ld le b">is</code>语法。</p><p id="b907" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们剩下一个<code class="fe lb lc ld le b">CustomListItem</code>组件，它能够显示一行文本，但不能处理特定的对象。<code class="fe lb lc ld le b">FeedListItem</code>需要一个<code class="fe lb lc ld le b">name</code>和一个<code class="fe lb lc ld le b">address</code>，而<code class="fe lb lc ld le b">ArticleListItem</code>需要一个<code class="fe lb lc ld le b">title</code>和一个<code class="fe lb lc ld le b">summary</code>。另外，<code class="fe lb lc ld le b">ArticleListItem</code>需要是一个<code class="fe lb lc ld le b">&lt;details&gt;</code>元素，以便在单击时显示<code class="fe lb lc ld le b">summary</code>。所以我们来延伸一下我们的<code class="fe lb lc ld le b">CustomList</code>。</p><h2 id="c0a0" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">自定义 FeedListItem</h2><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ly"><img src="../Images/6ff2a1c33d44117331963d3bc96f0fdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mDAEldE5ljSl5i7QKKvGmA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">项目结构的变化</figcaption></figure><p id="7bc8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">FeedListItem</code>将是一个具有一些特殊性的<code class="fe lb lc ld le b">CustomListItem</code>:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="13f7" class="lf lg iq le b gy mh mi l mj mk">import { CustomListItem } from "./custom-list-item.js";</span><span id="1169" class="lf lg iq le b gy ml mi l mj mk">export class FeedListItem extends CustomListItem {<br/>  set data(newValue) {<br/>    this.innerText = newValue.name;</span><span id="811a" class="lf lg iq le b gy ml mi l mj mk">    this.dataset.item = newValue.name;<br/>    this.dataset.address = newValue.address;<br/>  }</span><span id="3d17" class="lf lg iq le b gy ml mi l mj mk">  constructor() {<br/>    super();<br/>    this.classList.add("feed-list-item");<br/>  }<br/>}</span><span id="9369" class="lf lg iq le b gy ml mi l mj mk">customElements.define("feed-list-item", FeedListItem, { extends: "li" });</span></pre><p id="fb77" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意<code class="fe lb lc ld le b">extends: “li”</code>。<code class="fe lb lc ld le b">is=”feed-list-item”</code>仍然适用于<code class="fe lb lc ld le b">li</code>标签，但是在内部我们知道它扩展了<code class="fe lb lc ld le b">CustomListItem</code>。</p><p id="bb71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个组件没有额外的样式，因为它仍然只显示一行文本。因为它扩展了<code class="fe lb lc ld le b">CustomListItem</code>，所以首先它导入它。它唯一改变的是构造函数，我们在其中添加了<code class="fe lb lc ld le b">feed-list-item</code>类来标识它和<code class="fe lb lc ld le b">data</code>设置器。<code class="fe lb lc ld le b">FeedListItem</code>需要具有<code class="fe lb lc ld le b">name</code>和<code class="fe lb lc ld le b">address</code>属性的数据。我们显示<code class="fe lb lc ld le b">name</code>并将<code class="fe lb lc ld le b">address</code>存储在元素的数据集中。要使用它，我们需要改变<code class="fe lb lc ld le b">index.html</code>:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="ec73" class="lf lg iq le b gy mh mi l mj mk">&lt;nav&gt;<br/>  &lt;ul id="feeds" is="custom-list"&gt;<br/>    &lt;template&gt;<br/>      &lt;li is="feed-list-item"&gt;&lt;/li&gt;<br/>    &lt;/template&gt;<br/>  &lt;/ul&gt;<br/>&lt;/nav&gt;</span></pre><p id="929d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">feeds</code>列表将不再使用<code class="fe lb lc ld le b">custom-list-item</code>，而是使用<code class="fe lb lc ld le b">feed-list-item</code>。此外，我们需要导入<code class="fe lb lc ld le b">FeedListItem</code>并在<code class="fe lb lc ld le b">index.js</code>中加载带有适当数据的列表:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="e8d3" class="lf lg iq le b gy mh mi l mj mk">import { FeedListItem } from "../shared/components/feed-list-item.js";</span><span id="6ceb" class="lf lg iq le b gy ml mi l mj mk">document.getElementById("feeds").setItems([<br/>  { name: "The Verge", address: "https://www.theverge.com/rss/index.xml" },<br/>  { name: "Ars Technica", address: "https://feeds.arstechnica.com/arstechnica/features" },<br/>  { name: "Hacker News", address: "https://news.ycombinator.com/rss" }]);</span></pre><h2 id="d671" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">自定义文章列表项</h2><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ly"><img src="../Images/2d8ea55b793a5205482464faa8842e66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y8bpC8q5dI6A8o52YIiEUA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">更多项目结构变更</figcaption></figure><p id="24f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">ArticleListItem</code>还有更多的事情要做。它也有一些自定义的 HTML 和样式。让我们写我们的类:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="0957" class="lf lg iq le b gy mh mi l mj mk">import { CustomListItem } from "./custom-list-item.js";</span><span id="262f" class="lf lg iq le b gy ml mi l mj mk">export class ArticleListItem extends CustomListItem {<br/>  set data(newValue) {<br/>    this.dataset.item = newValue.title;<br/>    this.dataset.summary = newValue.summary;</span><span id="f992" class="lf lg iq le b gy ml mi l mj mk">    this.querySelector("section").innerText = newValue.summary;<br/>    this.querySelector("span").innerText = newValue.title;<br/>  }</span><span id="31aa" class="lf lg iq le b gy ml mi l mj mk">  constructor() {<br/>    super();<br/>    <br/>    this.classList.add("article-list-item");<br/>    this.innerHTML = "&lt;details&gt;<br/>      &lt;summary&gt;<br/>        &lt;span&gt;&lt;/span&gt;<br/>      &lt;/summary&gt;<br/>      &lt;section&gt;&lt;/section&gt;<br/>    &lt;/details&gt;";<br/>  }<br/>}</span><span id="57d5" class="lf lg iq le b gy ml mi l mj mk">customElements.define("article-list-item", ArticleListItem, { extends: "li" });</span></pre><p id="5035" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">主要的变化是在构建组件 UI 的构造函数中。它有一个<code class="fe lb lc ld le b">&lt;details&gt;</code>元素，为<code class="fe lb lc ld le b">title</code>保存一个<code class="fe lb lc ld le b">&lt;span&gt;</code>，为<code class="fe lb lc ld le b">summary</code>保存一个<code class="fe lb lc ld le b">&lt;section&gt;</code>。我们可以看到如何在<code class="fe lb lc ld le b">data</code>设置器中添加<code class="fe lb lc ld le b">title</code>和<code class="fe lb lc ld le b">summary</code>，在这里我们得到内部<code class="fe lb lc ld le b">section</code>和<code class="fe lb lc ld le b">span</code>并设置它们的<code class="fe lb lc ld le b">innerText</code>。我们还将<code class="fe lb lc ld le b">title</code>和<code class="fe lb lc ld le b">summary</code>保存在元素的数据集中，以便于在 Javascript 中检索。</p><p id="cc46" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">article-list-item.css</code>将为该元素添加自定义样式:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="ea01" class="lf lg iq le b gy mh mi l mj mk">@import url(./custom-list-item.css);</span><span id="edb9" class="lf lg iq le b gy ml mi l mj mk">li.article-list-item summary {<br/>  cursor: pointer;<br/>}</span><span id="af6e" class="lf lg iq le b gy ml mi l mj mk">li.article-list-item summary::marker {<br/>  content: none;<br/>}</span></pre><p id="cc84" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于<code class="fe lb lc ld le b">ArticleListItem</code>使用了<code class="fe lb lc ld le b">CustomListItem</code>样式，我们在这里将其导入，即使只是为了完整性，因为它也在<code class="fe lb lc ld le b">index.css</code>中被导入。接下来，我们简单地移动我们留在<code class="fe lb lc ld le b">index.css</code>中的内容，并使用我们专门为此目的定义的适当的<code class="fe lb lc ld le b">ArticleListItem</code> CSS 类。要使用<code class="fe lb lc ld le b">ArticleListItem</code>，让我们再次更改<code class="fe lb lc ld le b">index.html</code>:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="e981" class="lf lg iq le b gy mh mi l mj mk">&lt;main&gt;<br/>  &lt;ul id="articles" is="custom-list"&gt;<br/>    &lt;template&gt;<br/>      &lt;li is="article-list-item"&gt;&lt;/li&gt;<br/>    &lt;/template&gt;<br/>  &lt;/ul&gt;</span><span id="3f56" class="lf lg iq le b gy ml mi l mj mk">  &lt;a class="back" href="#"&gt;Back&lt;/a&gt;<br/>&lt;/main&gt;</span></pre><p id="d823" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们导入<code class="fe lb lc ld le b">ArticleListItem</code>，并在<code class="fe lb lc ld le b">index.js</code>中填入适当的数据:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="99c6" class="lf lg iq le b gy mh mi l mj mk">import { ArticleListItem } from "../shared/components/article-list-item.js";</span><span id="ec19" class="lf lg iq le b gy ml mi l mj mk">document.getElementById("articles").setItems([<br/>  { title: "Article1", summary: "Something" },<br/>  { title: "Article2", summary: "Another thing" },<br/>  { title: "Article3", summary: "Whatever" },<br/>  { title: "Article4", summary: "Yet another one" }]);</span></pre><p id="0b40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，<code class="fe lb lc ld le b">index.js</code>此时不再需要导入<code class="fe lb lc ld le b">CustomListItem</code>，因为它被<code class="fe lb lc ld le b">ArticleListItem</code>和<code class="fe lb lc ld le b">FeedListItem</code>引用。还要注意，Javascript 很聪明，即使引用了两次，也只加载一次。让我们也清理一下<code class="fe lb lc ld le b">index.css</code>，因为我们移动了一些定义:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="46af" class="lf lg iq le b gy mh mi l mj mk">@import url(/shared/styles/base.css);<br/>@import url(/shared/components/custom-list.css);<br/>@import url(/shared/components/custom-list-item.css);<br/>@import url(/shared/components/article-list-item.css);</span><span id="05f8" class="lf lg iq le b gy ml mi l mj mk">a.back {<br/>  display: none;<br/>  padding-top: 2em;<br/>}</span><span id="d1aa" class="lf lg iq le b gy ml mi l mj mk">@media (max-width: 710px) {<br/>  main {<br/>    display: none;<br/>  }</span><span id="3ed8" class="lf lg iq le b gy ml mi l mj mk">  body.feed-selected nav {<br/>    display: none;<br/>  }<br/>  body.feed-selected main {<br/>    display: block;<br/>  }</span><span id="7b05" class="lf lg iq le b gy ml mi l mj mk">  a.back {<br/>    display: block;<br/>  }<br/>}</span></pre><p id="ef45" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们将所有的 web 组件样式移到了它们自己的位置，所以<code class="fe lb lc ld le b">index.css</code>只剩下了<code class="fe lb lc ld le b">index.html</code>特定的样式，这是应该的。它还会在我们需要时导入所有组件样式。使用这种架构，我们可以随心所欲地改变样式，即使组件可能附带了“推荐的”样式。如果我们愿意的话，这可以使组件既保持样式，同时又保持非样式。</p><h2 id="7eb2" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">应用程序</h2><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mm"><img src="../Images/9eb33e95af06012d512974109ebcc4f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XaSyR28vTrORrEPMayCf6w.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">使用我们的定制组件运行的应用程序</figcaption></figure><p id="ffb3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以让我们看看我们做了什么。如上面的屏幕截图所示，我们又回到了最初的地方，只是这次我们使用了自定义 web 组件，并且我们还重新获得了正确的文章布局，一个可点击的细节元素:</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mn"><img src="../Images/146cbfe739ce8ba0702b9d2b0fb96fbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mBoZtJbzesAScVEgKPSn4g.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">可点击的细节元素</figcaption></figure><p id="c325" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们也来看看加载图，因为我喜欢每个部分在需要时加载其依赖关系的方式:</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/d4c3ac0b8b6776aa006bbf446d7375e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nyo_i_BWG46xBPpoZ79e2A.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">按需延迟加载依赖项</figcaption></figure><p id="8097" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看看<code class="fe lb lc ld le b">index.html</code>如何加载<code class="fe lb lc ld le b">index.css</code>和<code class="fe lb lc ld le b">index.js</code>，然后<code class="fe lb lc ld le b">index.css</code>加载其余的 CSS 文件，接着<code class="fe lb lc ld le b">index.js</code>加载 web 组件。<code class="fe lb lc ld le b">custom-list-item.js</code>最后加载，因为当<code class="fe lb lc ld le b">article-list-item.js</code>和<code class="fe lb lc ld le b">feed-list-item.js</code>需要时，它们会调用它。</p><p id="fb35" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，你可以用<code class="fe lb lc ld le b">required.js</code>和其他第三方 Javascript 模块系统得到这样的加载图，但是这一次它是由浏览器按照 Javascript 的指示完成的，不需要第三方。没有 Webpack，没有<code class="fe lb lc ld le b">node_modules</code>，没有 web 应用程序特别要求的任何东西。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><p id="879f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们到达了本教程的另一部分的结尾。我希望你读得开心，也希望你喜欢所提出的架构，一个最新 Javascript 特性的演示。和往常一样，代码可以在<a class="ae kc" href="https://github.com/raduzaharia-medium/html5-rss-reader-extended-components" rel="noopener ugc nofollow" target="_blank"> Github </a>获得。<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/html5-rss-reader-filtering-the-custom-list-component-c3ba366c08fd">下一次</a>我们将为<code class="fe lb lc ld le b">CustomList</code>添加更多的功能，我们将更接近最后的部分，在那里我们用 Rust 加载实际的 RSS 数据。到时候见！</p></div></div>    
</body>
</html>