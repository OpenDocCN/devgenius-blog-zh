<html>
<head>
<title>Is Spring WebFlux a Myth?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring WebFlux 是神话吗？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/is-spring-webflux-a-myth-4526c2f92413?source=collection_archive---------0-----------------------#2021-08-02">https://blog.devgenius.io/is-spring-webflux-a-myth-4526c2f92413?source=collection_archive---------0-----------------------#2021-08-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f3d5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">真的胜过 Spring Servlet 吗？让我们找出真相</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/300d39a817194f6c59d8389210e6af3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JGOlrBr4_DpH0AZ9kXdoHA.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Boris Stefanik 在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="06fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如何构建一个高性能的系统一直是开发者感兴趣的话题。许多业内人士倡导非阻塞编程的范式，认为基于非阻塞编程的应用比传统的命令式编程(一种阻塞技术)更有效地利用资源，实现更高的性能。</p><p id="e5c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">许多文章解释了非阻塞编程的好处，它似乎是一个优越的、面向未来的解决方案。然而，在没有第一手经验证明的情况下，我并不信服。为了找出真相，我使用两种不同的框架构建了同一个 Java 应用程序——Spring web flux(非阻塞)和 Spring Servlet(阻塞),然后运行了一系列实验来比较这两种实现的系统性能。令人惊讶的是，研究结果表明，在某些环境设置中，非阻塞编程并不总是比阻塞编程好。</p><p id="be4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，您将了解 Spring WebFlux 的真相。我将与你分享我的实验细节和性能测试结果的分析。</p><h2 id="7a09" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">什么是堵和不堵？</h2><p id="f45f" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">回到基础。什么是屏蔽？在传统的计算机编程中，每一行程序代码都是一条同步执行的指令。换句话说，机器一个接一个地运行程序逻辑，直到当前指令被完全执行，下一行代码才被执行。</p><p id="f13f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种使用模块化编程实现的系统通常表现很好。然而，如果任何进程的执行需要时间来完成，系统线程就会被卡住，如果情况恶化，就会导致系统崩溃。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/bbbde114843da870f017a748c26e957a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TRuydETTz3Xsk0B9_T5GPw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">基于线程的阻塞过程</figcaption></figure><p id="f960" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相反，非阻塞编程以发布-订阅模式实现程序逻辑。主程序流运行该流程并订阅结果。主程序没有被当前的进程执行“阻塞”，而是继续流程，并立即运行下一个进程。在进程执行完成后，通过回调通知主程序，以便继续执行程序逻辑。</p><p id="a55d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">理论上，非阻塞编程实现了并发。更重要的是，它不阻塞任何不是专用于任何请求的系统线程，线程池处理任何发布的回调。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/8a792b11e7cd653acefe42a410c922c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pwCgDOq4ALLPQCkpxRBqBA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">非阻塞编程的事件循环</figcaption></figure><h2 id="0939" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">Java Spring 是如何支持两种范式的？</h2><p id="d2f2" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">Java Spring 在两个独立的技术栈中支持阻塞和非阻塞编程——Spring Servlet(阻塞)和 Spring WebFlux(非阻塞)。由于系统线程模型的不同机制，这两种实现的底层技术有很大的不同。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ms"><img src="../Images/43bf9e2f6e942dd7fa7cec2d30712111.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m9I4YDCukWr-_HJ7exmIbQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">反应式堆栈与 Servlet 堆栈(<a class="ae kv" href="https://spring.io/reactive" rel="noopener ugc nofollow" target="_blank">https://spring.io/reactive</a>)</figcaption></figure></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="839b" class="na lt iq bd lu nb nc nd lx ne nf ng ma jw nh jx md jz ni ka mg kc nj kd mj nk bi translated">关于应用程序—外汇应用程序</h1><p id="5551" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">示例应用程序是一个 Spring Boot API，它提供了外汇汇率查询和外汇交易的功能。该系统依赖外部 API 来获取最新汇率，并提供货币对的买入和卖出价格。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/411e108352eaa797413334fa4bde627c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bs2Pn5FUt4mddQN9EV_xFQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">外汇交易 API</figcaption></figure><p id="137b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你有兴趣了解更多关于这个应用的信息，请参考<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/spring-a-faster-way-to-build-production-ready-api-in-a-well-defined-structure-5b1730fa81dd">这篇文章</a>。另外，你可以在<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/uplift-your-java-spring-boot-to-webflux-non-blocking-application-7b207999e669">这篇文章</a>中找到关于 Spring WebFlux 实现的细节。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="10bd" class="na lt iq bd lu nb nc nd lx ne nf ng ma jw nh jx md jz ni ka mg kc nj kd mj nk bi translated">性能测试实现</h1><p id="f785" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">现在，让我们看看性能测试设计。负载测试是使用强大的工具 Gatling 构建的。容积曲线设计是在 30 秒内将每秒用户注入量从 10 增加到 40，然后在 30 秒内保持每秒 40 个用户的恒定注入量。</p><p id="ea62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了模拟真实的情况，每个用户都被分配了一个用户旅程来提交 API 请求，以进行汇率查询、汇率预订和交易提交。</p><p id="5fe2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于测试场景设计以及如何使用 Gatling 构建负载测试的细节，请参考本文。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/a93bd73cd8ec9b304b2d334497f2a4a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*frxFSKeQ7qUCUIjmzv4cbA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">加特林负载测试场景</figcaption></figure><h2 id="e683" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">测试环境设置</h2><p id="88d6" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">负载测试运行程序和测试目标(即 Spring Boot 外汇交易 API)驻留在不同的机器上。外汇交易 API 将在 docker 容器中运行；准备了不同版本的 docker 映像来模拟以下部分中提到的一系列场景。</p><p id="fe74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要执行 Gatling 负载测试，从这个 GitHub 存储库中克隆源代码。在我们讨论每个测试场景时，将提供命令行。</p><div class="nn no gp gr np nq"><a href="https://github.com/gavinklfong/forex-trade-gatling" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd ir gy z fp nv fr fs nw fu fw ip bi translated">GitHub-gavinklfong/forex-trade-Gatling:对外汇交易 API 进行负载测试</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">这是 Forex Trade API 的负载测试实现。参考这篇文章一步一步的指导加特林…</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">github.com</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe kp nq"/></div></div></a></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/f3c787eb2497dadc230b784038ea407a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F15v059-UXDnh-r-voH-Rw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">负载测试环境设置</figcaption></figure></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="da78" class="na lt iq bd lu nb nc nd lx ne nf ng ma jw nh jx md jz ni ka mg kc nj kd mj nk bi translated">性能测试场景和结果</h1><p id="3481" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">为了实验外部 API 的响应时间和请求量这些因素如何影响 Spring Servlet 和 Spring WebFlux 的系统性能，我们进行了一系列测试。</p><ol class=""><li id="1748" class="og oh iq ky b kz la lc ld lf oi lj oj ln ok lr ol om on oo bi translated">理想情况—快速的外部 API</li><li id="0e9c" class="og oh iq ky b kz op lc oq lf or lj os ln ot lr ol om on oo bi translated">缓慢的外部 API</li><li id="5261" class="og oh iq ky b kz op lc oq lf or lj os ln ot lr ol om on oo bi translated">一个非常慢的外部 API</li><li id="b84a" class="og oh iq ky b kz op lc oq lf or lj os ln ot lr ol om on oo bi translated">非常慢的外部 API +双倍请求量</li></ol></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h2 id="a3bb" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">实验# 1——当 I/O 过程很快时，Spring WebFlux 实现了更快的响应吗？</h2><p id="7b0e" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在每秒 40 个用户的请求量和 10ms 内的外部 API 响应时间的情况下，Spring WebFlux 并没有胜过 Spring Servlet。两个版本的平均响应时间都在 20 毫秒到 50 毫秒之间。这表明非阻塞编程并不总是优于阻塞编程。</p><p id="902f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为什么？在正常情况下，当一切正常时，外部 API 等 I/O 进程的性能会很快。WebFlux 和 Servlet 在响应时间上的差异是微不足道的，因为两个版本的程序逻辑都可以很快从 I/O 进程获得响应并触发下一个进程。</p><p id="7bbb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在 docker 中运行这个<strong class="ky ir"> Spring Servlet </strong>外汇交易 API</p><pre class="kg kh ki kj gt ou ov ow ox aw oy bi"><span id="cca8" class="ls lt iq ov b gy oz pa l pb pc">docker run — rm -p 8080:8080 whalebig27/servlet-spring-forex-trade</span></pre><p id="61dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在 docker 中运行这个<strong class="ky ir"> Spring WebFlux </strong>外汇交易 API</p><pre class="kg kh ki kj gt ou ov ow ox aw oy bi"><span id="6c09" class="ls lt iq ov b gy oz pa l pb pc">docker run — rm -p 8080:8080 whalebig27/reactive-spring-forex-trade</span></pre><p id="055f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行此命令行来触发上面每个 API 版本的负载测试。API_HOST 的参数是测试目标(即外汇交易 API)的 IP 地址</p><pre class="kg kh ki kj gt ou ov ow ox aw oy bi"><span id="2d98" class="ls lt iq ov b gy oz pa l pb pc">mvn gatling:test -DAPI_HOST=&lt;IP Address of Forex Trade API&gt;</span></pre><p id="2fcb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">Spring Servlet 的响应时间</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pd"><img src="../Images/3732cbf36360c1ae8dbc11662e38840f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IkyQoYokpzbwCmjkFYGOrg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">响应时间— Spring Servlet —理想情况</figcaption></figure><p id="d916" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">弹簧流量响应时间</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pe"><img src="../Images/1f8dfe2ea92e36990489ad03f9e460dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aNEb4zu0PC-Z1nTVmgDq5g.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">响应时间— Spring WebFlux—理想情况</figcaption></figure></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h2 id="da42" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">实验 2——如果外部 API 有点慢怎么办？</h2><p id="1557" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">实际上，外部 API 的性能和稳定性超出了我们的控制范围。由于网络延迟、系统不稳定或其他原因，速度可能会很慢。让我们通过添加 3 秒钟的延迟来模拟一个缓慢的外部 API，看看系统性能如何。</p><p id="1abe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用这两个 docker 映像分别运行 Spring Servlet 和 Spring WebFlux，以 3 秒的延迟模拟外部 API:</p><ul class=""><li id="c470" class="og oh iq ky b kz la lc ld lf oi lj oj ln ok lr pf om on oo bi translated">whalebig 27/servlet-spring-forex-trade:slow</li><li id="37e5" class="og oh iq ky b kz op lc oq lf or lj os ln ot lr pf om on oo bi translated">whalebig 27/无功-春季-外汇-贸易:缓慢</li></ul><p id="464b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Spring WebFlux 的性能非常出色，它的响应比 Spring Servlet 快得多。Spring WebFlux 的第 90 百分位大约是 6 秒，而 Spring Servlet 慢了 2 倍多，大约 20 秒。</p><p id="3cf8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个实验中，您可以看到非阻塞编程的强大功能，资源利用更加高效，从而带来更好的性能。</p><p id="7bff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">Spring Servlet 的响应时间</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pg"><img src="../Images/55f76e116bd2d1ca1d0d2cff73483c44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rl1LSAupcWrjJ1jQ8g8tiA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">响应时间— Spring Servlet —一个缓慢的外部 API</figcaption></figure><p id="fe4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">弹簧流量响应时间</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ph"><img src="../Images/468bdac7da46a47451dd9f2e4006e427.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lwPncsBJb6XRERfXepenFg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">响应时间— Spring WebFlux —一个缓慢的外部 API</figcaption></figure></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h2 id="361e" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">实验 3——如果外部 API 更慢，性能会如何？</h2><p id="af27" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">让我们看看如果外部 API 非常慢，比如说延迟 6 秒，会发生什么。两个版本的响应时间都是之前测试的两倍，延迟 3 秒。Spring Servlet 的响应时间大约是 45 秒，而 Spring WebFlux 能够将响应时间保持在 15 秒以内。尽管如此，Spring WebFlux 比 Spring Servlet 有更好的性能。</p><p id="e5db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用这两个 docker 映像分别运行 Spring Servlet 和 Spring WebFlux，以模拟具有 6 秒延迟的外部 API</p><ul class=""><li id="cb58" class="og oh iq ky b kz la lc ld lf oi lj oj ln ok lr pf om on oo bi translated">whalebig 27/servlet-spring-forex-trade:非常慢</li><li id="a18e" class="og oh iq ky b kz op lc oq lf or lj os ln ot lr pf om on oo bi translated">whalebig 27/reactive-spring-外汇交易:非常缓慢</li></ul><p id="3452" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">Spring Servlet 的响应时间</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ph"><img src="../Images/a6201916a505926c6eaf10dcbf5bf0be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_h08KUpLlud3yzhgI2yy4w.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">响应时间— Spring Servlet—一个非常慢的外部 API</figcaption></figure><p id="c321" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">Spring web flux 的响应时间</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pi"><img src="../Images/8c009b89d40ab540cad61cd4172a2ed0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o42TMTgCBsMvtoKwdvwVSw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">响应时间— Spring WebFlux —一个非常慢的外部 API</figcaption></figure></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h2 id="0655" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">实验 4——给定一个非常慢的外部 API，在较重的工作负载下会有什么不同？</h2><p id="c145" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">预计当工作负载加倍而外部 API 仍然非常慢时，情况会恶化。哪种实现能够在严峻的形势下生存下来？</p><p id="297e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要加倍工作负载，运行以下命令行来触发 Gatling 负载测试，并使用参数来指定每秒的初始用户数和每秒的目标用户数:</p><pre class="kg kh ki kj gt ou ov ow ox aw oy bi"><span id="2ba3" class="ls lt iq ov b gy oz pa l pb pc">mvn gatling:test -DAPI_HOST=&lt;IP Address of Forex Trade API&gt; -DINITIAL_USER_PER_SEC=20 -DTARGET_USER_PER_SEC=80</span></pre><p id="5d44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结果显示，Spring Servlet 无法处理大多数请求，失败率高达 89%。相反，Spring WebFlux 仍然可以在恶劣的条件下生存，尽管故障率增加到 17%，响应时间大约为 30 秒。</p><p id="5570" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">Spring Servlet 的测试结果</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pj"><img src="../Images/30887c90d20e23139959e05a49f12ab8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Ldp06EE_o8rOqIgLFzCBw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">spring Servlet——极端环境中的故障率</figcaption></figure><p id="4ebf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">测试结果 Spring WebFlux </strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pk"><img src="../Images/ccf7b2bf5eafc3217f7adfea9d34187a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NYn3uiVuTxUm4NHTNd1esw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Spring WebFlux—极端环境下的故障率</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pl"><img src="../Images/85ad01394da64872c6566858e36af5c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xgqIWqm14qUz4FRm_Ph7TQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">响应时间— Spring WebFlux —非常慢的外部 API +高请求量</figcaption></figure></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="a2b1" class="na lt iq bd lu nb nc nd lx ne nf ng ma jw nh jx md jz ni ka mg kc nj kd mj nk bi translated">结论</h1><p id="1b96" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">测试证明，基于非阻塞技术的应用程序总体上优于传统的阻塞技术。虽然在 I/O 处理速度很快的理想环境中看不到非阻塞技术的威力，但这种技术是有优势的，在现实生活中肯定可以实现更快的响应时间和更低的故障率，因为外部 API 和持久性存储可能由于各种原因而不总是达到预期的服务级别，尤其是服务被大量的传入流量所淹没。</p><p id="225d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，在使用 Java 进行 API 开发时，Spring WebFlux 是一个优于 Spring Servlet 的推荐框架。在新的 API 开发中投入时间和资源来采用这个框架是值得的。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="41e6" class="na lt iq bd lu nb nc nd lx ne nf ng ma jw nh jx md jz ni ka mg kc nj kd mj nk bi translated">参考</h1><div class="nn no gp gr np nq"><a rel="noopener  ugc nofollow" target="_blank" href="/spring-a-faster-way-to-build-production-ready-api-in-a-well-defined-structure-5b1730fa81dd"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd ir gy z fp nv fr fs nw fu fw ip bi translated">spring——一种在定义良好的结构中构建生产就绪 API 的更快方法</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">以可维护且一致的结构构建您的应用程序</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">blog.devgenius.io</p></div></div><div class="nz l"><div class="pm l ob oc od nz oe kp nq"/></div></div></a></div><div class="nn no gp gr np nq"><a rel="noopener  ugc nofollow" target="_blank" href="/uplift-your-java-spring-boot-to-webflux-non-blocking-application-7b207999e669"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd ir gy z fp nv fr fs nw fu fw ip bi translated">将您的 Java Spring Boot 升级到 WebFlux 非阻塞应用程序</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">构建反应式 Spring WebFlux 快速指南</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">blog.devgenius.io</p></div></div><div class="nz l"><div class="pn l ob oc od nz oe kp nq"/></div></div></a></div><div class="nn no gp gr np nq"><a href="https://medium.com/devtechtoday/how-to-build-performance-tests-to-validate-your-apis-using-gatling-b91adaf08222" rel="noopener follow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd ir gy z fp nv fr fs nw fu fw ip bi translated">如何使用 Gatling 构建性能测试来验证您的 API</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">负载测试设计和实现的权威指南</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">medium.com</p></div></div><div class="nz l"><div class="po l ob oc od nz oe kp nq"/></div></div></a></div></div></div>    
</body>
</html>