<html>
<head>
<title>Creating CRUD GraphQL API with Nodejs, Express &amp; MongoDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Nodejs、Express和MongoDB创建CRUD GraphQL API</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/creating-crud-graphql-api-with-nodejs-express-mongodb-16c97e20e212?source=collection_archive---------1-----------------------#2021-09-13">https://blog.devgenius.io/creating-crud-graphql-api-with-nodejs-express-mongodb-16c97e20e212?source=collection_archive---------1-----------------------#2021-09-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0a89" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在本教程中，我们将了解GraphQL，并使用NodeJS、Express和MongoDB构建一个简单的CRUD GraphQL API。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1be41c8de4d89cabd9930bf5955ea121.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OHEXyBI8lihwKAiV926muw.png"/></div></div></figure><p id="63e0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">今天，我将带您进入一个平行世界，探索GraphQL。</p><p id="5748" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在过去的20年里，REST APIs已经在web应用程序领域占据了一席之地，而GraphQL则体现了这一流派的复兴。我们将立即找出原因！</p><blockquote class="ln"><p id="264e" class="lo lp iq bd lq lr ls lt lu lv lw lm dk translated">GraphQL，设计API的另一种方式</p></blockquote><p id="ebb7" class="pw-post-body-paragraph kr ks iq kt b ku lx jr kw kx ly ju kz la lz lc ld le ma lg lh li mb lk ll lm ij bi translated">让我们从头说起。</p><p id="bb16" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通常，为了设计一个API，我们会关注于创建由端点和数据表示物化的资源。</p><p id="4795" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下是通过curl命令在<a class="ae mc" href="https://www.themoviedb.org/documentation/api" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> TMDB API </strong> </a>上查找电影《人类之怒》的描述的查询示例:</p><pre class="kg kh ki kj gt md me mf mg aw mh bi"><span id="ac21" class="mi mj iq me b gy mk ml l mm mn">curl — location — request GET 'https://api.themoviedb.org/3/search/movie?api_key={YOUR_API_KEY}&amp;query=Wrath%20Of%20Man'</span><span id="36f8" class="mi mj iq me b gy mo ml l mm mn">=&gt; {<br/> “page”: 1,<br/> “results”: [<br/> {<br/>   “adult”: false,<br/>   “backdrop_path”: “/9DZlZvgh9dIGcri79hv3KtHiq5K.jpg”,<br/>   “genre_ids”: [<br/>           28,<br/>           80,<br/>           53<br/>    ],<br/>    “id”: 637649,<br/>    “original_language”: “en”,<br/>    “original_title”: “Wrath of Man”,<br/>    “overview”: “A cold and mysterious new security guard for a Los Angeles cash truck company surprises his co-workers when he unleashes precision skills during a heist. The crew is left wondering who he is and where he came from. Soon, the marksman’s ultimate motive becomes clear as he takes dramatic and irrevocable steps to settle a score.”,<br/>    “popularity”: 665.016,<br/>    “poster_path”: “/M7SUK85sKjaStg4TKhlAVyGlz3.jpg”,<br/>    “release_date”: “2021–04–22”,<br/>    “title”: “Wrath of Man”,<br/>    “video”: false,<br/>    “vote_average”: 7.8,<br/>    “vote_count”: 2148<br/>  }<br/> ],<br/>  “total_pages”: 1,<br/>  “total_results”: 1<br/>}</span></pre><p id="ec45" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个例子说明了今天在web上可以找到的大多数API。我们请求一个端点访问一个预定义的数据结构(我们隐式地使用HTTP GET here)。如果您想要访问其他资源，则需要请求另一个端点，可能需要传递其他参数。当然，其他动作也是可能的，但是今天web APIs的基本作用是提供一个CRUD。</p><p id="5252" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">GraphQL为我们提供了一种完全不同的方法，允许我们只检索我们需要的数据。</p><p id="a128" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由脸书在2012年创建，用于处理其API设计中反复出现的问题，第一次公开发布将在三年后进行。</p><p id="3f05" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">GraphQL不仅仅是一个新标准，它还是一种web APIs的查询语言。</p><p id="4603" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你发现了，这里有两件重要的事情需要考虑:</p><ul class=""><li id="7e0b" class="mp mq iq kt b ku kv kx ky la mr le ms li mt lm mu mv mw mx bi translated">我们只定义一个端点(例如<code class="fe my mz na me b">http://example/graphql</code>)。</li><li id="ffe7" class="mp mq iq kt b ku nb kx nc la nd le ne li nf lm mu mv mw mx bi translated">由于这是一种查询语言，所有的动作都是通过一个<code class="fe my mz na me b">POST</code>来完成的。</li></ul><p id="e33a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，GraphQL将允许您消除端点管理——有时很难记录和维护——并创建适合您需要的查询来处理数据，同时在代码本身中添加文档。</p><p id="6b32" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，前端开发人员在工作中获得了灵活性，因为他们能够以他们认为合适的方式操纵查询和处理数据。</p><h2 id="5ad4" class="mi mj iq bd ng nh ni dn nj nk nl dp nm la nn no np le nq nr ns li nt nu nv nw bi translated"><strong class="ak">整合？让我们更深入地理解</strong></h2><p id="fd77" class="pw-post-body-paragraph kr ks iq kt b ku nx jr kw kx ny ju kz la nz lc ld le oa lg lh li ob lk ll lm ij bi translated">GraphQL定义了三种查询方式:</p><ul class=""><li id="d5eb" class="mp mq iq kt b ku kv kx ky la mr le ms li mt lm mu mv mw mx bi translated">查询:我们将寻找特定的数据(相当于一个<code class="fe my mz na me b">GET</code>，但是选择我们选择的属性)</li><li id="ae65" class="mp mq iq kt b ku nb kx nc la nd le ne li nf lm mu mv mw mx bi translated">突变:我们想要改变数据(我们可以将其与<code class="fe my mz na me b">POST, PUT, and DELETE</code>动作进行比较)</li><li id="c017" class="mp mq iq kt b ku nb kx nc la nd le ne li nf lm mu mv mw mx bi translated">订阅:有点特殊的情况，允许你通过使用<em class="oc"> WebSockets </em>来保持与远程服务器的连接</li></ul><p id="a638" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后一种情况在<strong class="kt ir">web API</strong>领域相当新颖，因为它允许我们克服无状态的概念。提醒一下，这个概念指的是服务器缺乏对客户机状态的管理。因此，在传统的<em class="oc"> REST </em>架构中，有必要随每个请求发送信息(例如认证)，这往往会增加通过网络的信息量，并显著影响性能。</p><p id="c833" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">GraphQL主要基于模式的概念。模式包括几个元素，包括查询等操作的定义、允许您定义对象属性的对象类型的定义，我们将能够使用GraphQL操作这些属性，甚至允许您列出字段的输入。可作为请求的参数访问。</p><p id="ac7a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，<a class="ae mc" href="https://graphql.org/learn/schema/" rel="noopener ugc nofollow" target="_blank"> GraphQL有它自己的SDL </a>，但是没有什么可以阻止您以其他方式声明它，如下例所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="4285" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是使用GraphQL的SDL的同一个例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="21db" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请注意，这里使用了JavaScript中的文字模板来包装我们的模式定义，还使用了引号来附加一个描述，这个描述将在本教程后面的GraphQL开发接口中找到。</p><p id="84dc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，有必要建立解析器，其目标是检索和处理数据。</p><h2 id="2d32" class="mi mj iq bd ng nh ni dn nj nk nl dp nm la nn no np le nq nr ns li nt nu nv nw bi translated">说够了，表演时间到了:</h2><p id="618e" class="pw-post-body-paragraph kr ks iq kt b ku nx jr kw kx ny ju kz la nz lc ld le oa lg lh li ob lk ll lm ij bi translated">正如所料，我们将使用Node.js甚至Express.js框架和MongoDB来体验GraphQL的乐趣。我们的任务是制作一个API，允许我们创建帖子并将它们存储在MongoDB数据库中，并且我们也能够获取和删除它们。</p><p id="2576" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为此，我们首先创建一个新的节点项目</p><ul class=""><li id="333b" class="mp mq iq kt b ku kv kx ky la mr le ms li mt lm mu mv mw mx bi translated">创建一个新目录并转到那里</li><li id="a1e8" class="mp mq iq kt b ku nb kx nc la nd le ne li nf lm mu mv mw mx bi translated">运行<code class="fe my mz na me b">npm init</code>来配置新项目</li><li id="4517" class="mp mq iq kt b ku nb kx nc la nd le ne li nf lm mu mv mw mx bi translated">运行<code class="fe my mz na me b">npm install</code>来创建我们的package.json文件</li><li id="73bd" class="mp mq iq kt b ku nb kx nc la nd le ne li nf lm mu mv mw mx bi translated">创建一个server.js文件(另一个名字也可以),作为我们服务器的入口点。</li><li id="0dc0" class="mp mq iq kt b ku nb kx nc la nd le ne li nf lm mu mv mw mx bi translated">创建一个<code class="fe my mz na me b">src/schema</code>目录和一个包含业务逻辑的index.js文件</li><li id="8d88" class="mp mq iq kt b ku nb kx nc la nd le ne li nf lm mu mv mw mx bi translated">创建一个<code class="fe my mz na me b">src/resolvers</code>目录和一个index.js文件。</li><li id="b6a3" class="mp mq iq kt b ku nb kx nc la nd le ne li nf lm mu mv mw mx bi translated">创建一个<code class="fe my mz na me b">src/models</code>目录和一个post.js来保存一篇文章的样子。</li></ul><p id="b054" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我将在本教程中使用<code class="fe my mz na me b">npm</code>，但你也可以用<code class="fe my mz na me b">yarn</code>来代替。一切都取决于你。</p><pre class="kg kh ki kj gt md me mf mg aw mh bi"><span id="3636" class="mi mj iq me b gy mk ml l mm mn">mkdir graphql-crud-api <strong class="me ir">&amp;&amp;</strong> cd $_<br/>npm init<br/>npm i<br/>touch server.js<br/>mkdir -p src/schema <strong class="me ir">&amp;&amp;</strong> touch src/schema/index.js<br/>mkdir src/resolvers <strong class="me ir">&amp;&amp;</strong> touch src/resolvers/index.js<br/>mkdir src/models <strong class="me ir">&amp;&amp;</strong> touch src/models/post.js</span></pre><p id="4d26" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您项目的结构应该如下:</p><pre class="kg kh ki kj gt md me mf mg aw mh bi"><span id="962e" class="mi mj iq me b gy mk ml l mm mn">├── src<br/>│   ├── schema<br/>│   │   └── index.js<br/>│   ├── resolvers<br/>│   │   └── index.js<br/>│   └── models<br/>│       └── index.js<br/>├── package-lock.json<br/>├── package.json<br/>└── server.js</span></pre><p id="7c60" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在是时候添加这个项目所需的依赖项了:</p><pre class="kg kh ki kj gt md me mf mg aw mh bi"><span id="2439" class="mi mj iq me b gy mk ml l mm mn">npm install --save express express-graphql graphql body-parser<br/><br/><em class="oc"># Bonus =&gt;</em> you can also install Nodemon locally to avoid having to restart your server with each change<br/>npm install --save-dev nodemon</span></pre><blockquote class="of og oh"><p id="82af" class="kr ks oc kt b ku kv jr kw kx ky ju kz oi lb lc ld oj lf lg lh ok lj lk ll lm ij bi translated">注意:如果您使用的是<strong class="kt ir"> nodemon </strong>，不要忘记通过添加一个命令来更新package.json以启动服务器，如下所示。你只需要运行<strong class="kt ir"> <em class="iq"> npm start </em> </strong>命令来启动你的服务器。</p></blockquote><pre class="kg kh ki kj gt md me mf mg aw mh bi"><span id="56d9" class="mi mj iq me b gy mk ml l mm mn">“scripts”: { “start”: “nodemon server.js”, … }</span></pre><p id="f95f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们将从定义API的模式开始。</p><h1 id="4fc3" class="ol mj iq bd ng om on oo nj op oq or nm jw os jx np jz ot ka ns kc ou kd nv ov bi translated">(计划或理论的)纲要</h1><p id="527b" class="pw-post-body-paragraph kr ks iq kt b ku nx jr kw kx ny ju kz la nz lc ld le oa lg lh li ob lk ll lm ij bi translated">该模式将允许我们定义我们的GraphQL对象，并通过我们的API列出不同的可用操作。</p><p id="106e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里我们将设置两个查询:</p><ul class=""><li id="cb3a" class="mp mq iq kt b ku kv kx ky la mr le ms li mt lm mu mv mw mx bi translated">一个获取所有帖子的函数，它应该返回一个数组，并且每个帖子必须匹配类型<code class="fe my mz na me b">Post</code>。</li><li id="0408" class="mp mq iq kt b ku nb kx nc la nd le ne li nf lm mu mv mw mx bi translated">另一种是通过id检索帖子。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oe l"/></div><figcaption class="ow ox gj gh gi oy oz bd b be z dk translated">。/src/schema/索引. js</figcaption></figure><p id="1220" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们试着看得更清楚一点。</p><p id="c3be" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们声明一个PostType类型，它将包含我们想要的属性列表。请注意不同的标量类型，如“ID”或“String”以及“！”的使用以指示该字段不能为空。要了解更多信息，我邀请您查阅有关<a class="ae mc" href="https://graphql.org/learn/schema/#scalar-types" rel="noopener ugc nofollow" target="_blank"> <em class="oc">标量类型</em> </a>和<a class="ae mc" href="https://graphql.org/learn/schema/#object-types-and-fields" rel="noopener ugc nofollow" target="_blank"> <em class="oc">对象类型</em> </a>的GraphQL官方文档。</p><p id="5320" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后是输入类型，它指定预期的输入应该如何出现。这是用户创建新帖子时应该输入的信息。</p><p id="5671" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">顾名思义，GraphQL查询用于指定查询类型。为了获得数据，我们将使用查询<em class="oc">‘posts’</em>。</p><p id="1990" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了能够检索文章，我们必须首先将它们保存在我们的数据库中。这意味着我们必须创造它们。我们在GraphQl突变的帮助下实现了这一点。这是一个在数据存储中(创建/更新/删除)数据并返回值的查询。</p><ul class=""><li id="abb0" class="mp mq iq kt b ku kv kx ky la mr le ms li mt lm mu mv mw mx bi translated">在这种情况下,<code class="fe my mz na me b">createPost</code>突变用于生成新帖子。它接受一个PostInput类型的条目，并从中创建一篇文章。</li><li id="442e" class="mp mq iq kt b ku nb kx nc la nd le ne li nf lm mu mv mw mx bi translated"><code class="fe my mz na me b">deletePost</code>通过id来删除帖子的突变。</li><li id="6c77" class="mp mq iq kt b ku nb kx nc la nd le ne li nf lm mu mv mw mx bi translated"><code class="fe my mz na me b">updatePost</code>变异用于更新帖子，它需要两个参数<code class="fe my mz na me b">_id</code>和新的<code class="fe my mz na me b">body</code>。</li></ul><p id="05ca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，我们需要建立另一个模式，或者更准确地说，一个模型，以保证发送到MongoDB的数据符合GraphQL模式。</p><h1 id="4798" class="ol mj iq bd ng om on oo nj op oq or nm jw os jx np jz ot ka ns kc ou kd nv ov bi translated">制作我们的猫鼬模型</h1><p id="56ff" class="pw-post-body-paragraph kr ks iq kt b ku nx jr kw kx ny ju kz la nz lc ld le oa lg lh li ob lk ll lm ij bi translated">我们将使用<code class="fe my mz na me b">mongoose</code>与我们的MongoDB数据库进行交互，这将使事情变得更容易。</p><p id="f5c2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们需要在终端上运行以下命令来安装<code class="fe my mz na me b">mongoose</code>包:</p><pre class="kg kh ki kj gt md me mf mg aw mh bi"><span id="7731" class="mi mj iq me b gy mk ml l mm mn">npm install <!-- -->mongoose</span></pre><p id="c92a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们可以通过将下面的代码添加到文件<code class="fe my mz na me b">src/model/post.js</code>来创建我们的模型</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oe l"/></div><figcaption class="ow ox gj gh gi oy oz bd b be z dk translated">。/src/models/post.js</figcaption></figure><p id="14a6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要做一个数据模型，首先要导入mongoose并访问Schema方法。现在，我们可以为特定的帖子构建一个模式。我们的GraphQL模式包括一些必填字段"！"，所以我们将使用必要的属性来遵守GraphQL标准。除了<code class="fe my mz na me b">_id</code>之外，我们不必将它作为字段添加到我们的模式中，因为它会自动生成。</p><p id="8404" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们再次使用<code class="fe my mz na me b">mongoose</code>并将模型的名称和模式作为参数传递给model()方法。</p><h1 id="74af" class="ol mj iq bd ng om on oo nj op oq or nm jw os jx np jz ot ka ns kc ou kd nv ov bi translated">分解器</h1><p id="f7bd" class="pw-post-body-paragraph kr ks iq kt b ku nx jr kw kx ny ju kz la nz lc ld le oa lg lh li ob lk ll lm ij bi translated">解析器是一组生成GraphQL查询响应的函数。简单地说，这是一个GraphQL查询处理程序。每个查询或变异的名称必须与解析函数的名称完全匹配。这意味着如果我们有一个名为<code class="fe my mz na me b">posts</code>的查询，我们应该有一个名为<code class="fe my mz na me b">posts()</code>的解析函数。</p><p id="2be4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，在我们完成了所有的工作之后，看起来我们已经拥有了为API创建GraphQL解析器所需的一切。</p><p id="c7c3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以，我们开始吧。</p><p id="c443" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">帮我把下面这段代码添加到<code class="fe my mz na me b">src/resolvers/index.js</code>文件中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oe l"/></div><figcaption class="ow ox gj gh gi oy oz bd b be z dk translated">。/src/resolvers/index.js</figcaption></figure><p id="b469" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">等一下，首先，我们需要弄清楚这个代码是什么意思。如果您还记得在我们的模式(<code class="fe my mz na me b">src/shcema/index.js</code>)中，我们创建了一个名为posts的查询，它返回一组帖子。<br/>posts方法使用用<code class="fe my mz na me b">mongoose</code>创建的模型向MongoDB发送请求。因此，我们现在可以使用find()从数据库中检索所有文章。因为返回的响应是一个数组，所以我们必须对它进行循环并返回文档，用<code class="fe my mz na me b">mongoose</code>覆盖<code class="fe my mz na me b">_id</code>，并将createdAt字段更改为每个条目的更用户友好的日期。您可能知道，这个过程可能需要一段时间，这就是为什么我们使用async/await来处理请求。</p><p id="398a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的模式中前面描述的变异将由第二个解析器函数createPost处理。它将post对象作为输入，并使用它根据post模型创建一个新的Post。<br/>为了将它保存在MongoDB中，我们只需要使用另一个mongoose助手,<code class="fe my mz na me b">save()</code>函数，并按照模式中的预期返回新生成的post。</p><p id="2ed8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">MongoDB响应有一些元数据，这就是为什么我在两个方法中都直接返回了<code class="fe my mz na me b">_doc</code>属性。</p><p id="df52" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要删除一篇文章，作为一个参数，我们只声明id的字段。在解析器中，我们执行助手<code class="fe my mz na me b">findByIdAndDelete</code>，允许我们删除帖子，并返回已删除的帖子。</p><p id="8801" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于<code class="fe my mz na me b">updatePost</code>，我们通过<code class="fe my mz na me b">_id</code>和新的身体作为参数，然后，当然，我们将再次使用另一个<code class="fe my mz na me b">mongoose</code>助手，<code class="fe my mz na me b">findByIdAndUpdate</code>就像变魔术一样。但是这一次我们将只返回一个成功的消息。</p><p id="e284" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在有了API的模式和解析器，这几乎是我们进入下一阶段并构建服务器和端点所需的一切。</p><h1 id="57bb" class="ol mj iq bd ng om on oo nj op oq or nm jw os jx np jz ot ka ns kc ou kd nv ov bi translated">创建服务器并连接MongoDB</h1><p id="f5e4" class="pw-post-body-paragraph kr ks iq kt b ku nx jr kw kx ny ju kz la nz lc ld le oa lg lh li ob lk ll lm ij bi translated">将这段代码添加到<code class="fe my mz na me b">server.js</code>文件中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oe l"/></div><figcaption class="ow ox gj gh gi oy oz bd b be z dk translated"><code class="fe my mz na me b">server.js</code></figcaption></figure><p id="83ee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如您所见，我们已经导入了之前创建的模式和解析器。需要使用它们。这是一个需要一些选项的<code class="fe my mz na me b">express-graphql</code>方法，在本例中，是模式和解析器。我还启用了<code class="fe my mz na me b">graphiql</code>，这是一个用于查询测试的有用工具。<br/>代码的最后一部分是建立到MongoDB的连接，但是首先，您需要在<a class="ae mc" href="https://www.mongodb.com/fr-fr/cloud/atlas" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> MongoDB Atlas </strong> </a>上创建一个新的集群，并获得数据库名称、登录名和密码。</p><p id="1f24" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">之后，在你的项目文件夹的根目录下创建一个新的文件<code class="fe my mz na me b">nodemon.json</code>，这个文件将被用来存储我们的环境变量。</p><pre class="kg kh ki kj gt md me mf mg aw mh bi"><span id="9bc2" class="mi mj iq me b gy mk ml l mm mn">{ <br/>  “env”: { <br/>            “MONGO_USER”: “your_username”, <br/>            “MONGO_PASSWORD”: “your_password”, <br/>            “MONGO_DB”: “your_database” <br/>         }<br/>}</span></pre><p id="6441" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">答对了。我们已经把所有的部分放在一起，现在我们有一个功能API。</p><h1 id="ac05" class="ol mj iq bd ng om on oo nj op oq or nm jw os jx np jz ot ka ns kc ou kd nv ov bi translated">考验的时候到了！</h1><p id="e64b" class="pw-post-body-paragraph kr ks iq kt b ku nx jr kw kx ny ju kz la nz lc ld le oa lg lh li ob lk ll lm ij bi translated">现在我们已经完成了代码，我们将能够通过GraphQL提供的开发接口来测试我们的查询。</p><p id="6833" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们从控制台启动服务器:</p><pre class="kg kh ki kj gt md me mf mg aw mh bi"><span id="3e32" class="mi mj iq me b gy mk ml l mm mn">npm start</span></pre><p id="7723" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那我们就去下面这个地址我们最喜欢的浏览器:<code class="fe my mz na me b">http://localhost:4000:graphql</code></p><p id="de55" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">关于这个接口，需要知道一些事情:</p><ul class=""><li id="51a2" class="mp mq iq kt b ku kv kx ky la mr le ms li mt lm mu mv mw mx bi translated">自动完成:在Mac上，我们用<code class="fe my mz na me b">CTRL+SPACE</code>激活自动完成</li><li id="c454" class="mp mq iq kt b ku nb kx nc la nd le ne li nf lm mu mv mw mx bi translated">文档(从代码中检索)可通过右侧的侧菜单获得</li><li id="76a2" class="mp mq iq kt b ku nb kx nc la nd le ne li nf lm mu mv mw mx bi translated">其余的都是关于快乐:语法高亮、实时错误报告、查询结果等。</li></ul><p id="a8f9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在可以直接从界面尝试我们的查询:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pa"><img src="../Images/abfa6c8b2f9cf4d8571d79ea514eb182.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kpnca9evHl1U8V3Th7wsuw.png"/></div></div><figcaption class="ow ox gj gh gi oy oz bd b be z dk translated">获取所有帖子</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pa"><img src="../Images/3a7c0b2f2df9af19dabd5e2909f3f73e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pBUPXkaloaLc9fvzJqj7Mg.png"/></div></div><figcaption class="ow ox gj gh gi oy oz bd b be z dk translated">获取发布bu ID</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pa"><img src="../Images/47d1d7ec594f1999b9078c77b4bb44cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IYkq-fDlQSam9jACPqaftQ.png"/></div></div><figcaption class="ow ox gj gh gi oy oz bd b be z dk translated">创建新帖子</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pa"><img src="../Images/85cc636726c28053757ca1a8d87de1b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pggUxKIzgRjTNJLaywGTWw.png"/></div></div><figcaption class="ow ox gj gh gi oy oz bd b be z dk translated">更新帖子</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pa"><img src="../Images/a97cf02f2df721abd56780f729c5eb5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rSwG8LPbv8mbA0Pv7CBEBw.png"/></div></div><figcaption class="ow ox gj gh gi oy oz bd b be z dk translated">按ID删除帖子</figcaption></figure><p id="3391" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以随心所欲地进行试验，通过创建突变来添加其他数据持久性逻辑，甚至尝试订阅！也有可能像流行的<a class="ae mc" href="https://www.apollographql.com/docs/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> Apollo </strong> </a>一样利用第三方库。</p><p id="8c4c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好了，我希望你喜欢这篇介绍，甚至让你想尝试GraphQL，在我看来它有真正的潜力。</p><blockquote class="of og oh"><p id="fbb7" class="kr ks oc kt b ku kv jr kw kx ky ju kz oi lb lc ld oj lf lg lh ok lj lk ll lm ij bi translated">你可以在<a class="ae mc" href="https://github.com/crayOmn/graphql-crud-api" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到源代码。</p></blockquote></div></div>    
</body>
</html>