<html>
<head>
<title>Angular pipe tricky moments</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角管棘手的时刻</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/angular-pipe-tricky-moments-7681af7fdb47?source=collection_archive---------4-----------------------#2022-05-12">https://blog.devgenius.io/angular-pipe-tricky-moments-7681af7fdb47?source=collection_archive---------4-----------------------#2022-05-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="fd71" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">只是一些 pipe 的练习思路在开发的时候出现在我面前。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b75014497e0bba3e7d2f0753f8649e10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uBD7YErWoUxkhO3GJi7srQ.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">帕提亚骑士全面保护(古罗马时代)</figcaption></figure><p id="9737" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">发明 angular pipe 是为了提供一个实例，该实例将运行一次，直到状态发生变化。管道接受输入，并将其转换为另一种类型，以在模板中生成输出。要在模板中使用管道，我们只需要符号|</p><p id="f67f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Pipe 像一只斗牛犬一样捕捉对象值，不想刷新状态。有时候会变得很烦。要避免这种情况，请向管道添加附加参数，并在数组更改后立即更改它。即使使用纯管道，状态也会被刷新。</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="0ea3" class="ld le in kz b gy lf lg l lh li">refreshValue: number = 0;</span><span id="38d4" class="ld le in kz b gy lj lg l lh li">// every new call will set new value <br/>updateChargeCode(charge: ChargeObject): void {<br/>  this.refreshValue++;<br/>}</span></pre><p id="b08d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从 component.html 调用管道，并将<strong class="jm io"> refreshValue </strong>变量作为参数传递:</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="6ac3" class="ld le in kz b gy lf lg l lh li">&lt;div [ngClass]="(charge.priceData | TariffChecker : refreshValue) ? 'charge-none' : ''"&gt;<br/>&lt;/div&gt;</span></pre><p id="aaa4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在看看管道，<strong class="jm io"> refreshValue </strong>没有被使用，我们只是传递它以避免缓存:</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="750d" class="ld le in kz b gy lf lg l lh li">@Pipe({<br/>  name: "TariffChecker"<br/>})<br/>export class TariffCheckerPipe implements PipeTransform {<br/>  transform(priceData: ChargeData, refreshValue?: number): boolean {</span><span id="5363" class="ld le in kz b gy lj lg l lh li">    return treatPassedParam(priceData);  <br/>  }<br/>}<br/>private treatPassedParam(priceData: ChargeData): boolean {<br/>  ...<br/>  return false;<br/>}</span></pre><p id="6914" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">纯管道</strong></p><p id="1b87" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它是一种没有内在状态和副作用的方法。所有实现的计算都不依赖于状态，我们有相同的输入参数并返回相同的值。这是因为我们不想为每个变更检测执行管道。</p><ol class=""><li id="2cc8" class="lk ll in jm b jn jo jr js jv lm jz ln kd lo kh lp lq lr ls bi translated">输入参数的值定义了输出。如果输入保持不变，那么输出也不会改变。</li><li id="73ca" class="lk ll in jm b jn lt jr lu jv lv jz lw kd lx kh lp lq lr ls bi translated">它可以传播到其他物体上，输出保持不变。</li></ol><p id="1d13" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">不纯管道</strong></p><p id="244d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Angular 将在每次更改检测时执行不纯管道。他会经常在管道对象上调用 transform 方法。</p><ol class=""><li id="cecf" class="lk ll in jm b jn jo jr js jv lm jz ln kd lo kh lp lq lr ls bi translated">输入参数不会帮助我们理解，输出将如何被改变。</li><li id="0ee0" class="lk ll in jm b jn lt jr lu jv lv jz lw kd lx kh lp lq lr ls bi translated">它不能传播，因为内部状态可以从外部改变。</li></ol><p id="f3c4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">AsyncPipe 是包“@angular/common”中的标准管道。AsyncPipe 使用广泛，但它是不纯的，因为它有一个内部状态，即作为参数传递给管道的对可观察对象的订阅。</p><p id="8307" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">管道中的多个参数</strong></p><p id="39c5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从 UI component.html 调用管道:多个参数可以用冒号分隔:</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="88f9" class="ld le in kz b gy lf lg l lh li">&lt;div [readonly]="<!-- -->{{myArg | myPipe: 'anotherArg', refreshValue }}" /&gt;</span></pre><p id="7a91" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，您可以链接不同的管道，如下所示:</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="ceff" class="ld le in kz b gy lf lg l lh li">&lt;div [ngClass]="<!-- -->{{ myArgument | myPipe: param1,<br/> myArgument2 | myPipe2: param2 }}" /&gt;</span></pre><p id="e76d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以在组件类型脚本中定义管道</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="d065" class="ld le in kz b gy lf lg l lh li">private result = 0;<br/>constructor(private readonly dtFormatterPipe: DateFormatterPipe) {}</span><span id="e33b" class="ld le in kz b gy lj lg l lh li">private DateChangeSubscription() {<br/>  result = this.dtFormatterPipe.transform(minDate, maxDate);<br/>}</span></pre><p id="f8ab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">将多个管道组合成一个变量:</strong></p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="d03f" class="ld le in kz b gy lf lg l lh li">&lt;ng-container *ngIf="{ name: myPipe | async,<br/>   surname: myPipe2 | async } as personType"&gt;<br/>  {{ personType.name}}<br/>&lt;/ng-container&gt;</span></pre><p id="d14c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">什么时候用管子？原因是什么？举几个例子。</strong></p><p id="f517" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">管道只是另一种分割 Angular 应用程序源代码的机制。举例来说，我们有一个组件来管理 UI 逻辑，我们还使用一个服务来进行基于数据的操作。并且额外的逻辑处理和错误处理可以移到管道中。它使代码更可读和可测试。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/24d655f3c1d444756dc0b489b18efc56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*oYJsy8OlP0TpIij66nwDtQ.png"/></div></figure><ol class=""><li id="b054" class="lk ll in jm b jn jo jr js jv lm jz ln kd lo kh lp lq lr ls bi translated">可能返回默认值:</li></ol><p id="c88c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果输入值不合适，使用默认值。我们向管道传递多个参数。</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="22ea" class="ld le in kz b gy lf lg l lh li">&lt;my-component [value]="myValue | calculate: myDefaultValue"&gt;&lt;/my-component&gt;</span></pre><p id="9038" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">并在管道层面上做出一些处理:</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="1281" class="ld le in kz b gy lf lg l lh li">@Pipe({name: 'calculate', pure: true})<br/>export class CalculatePipe {<br/>  transform(value: string, myDefaultValue: string): string {<br/>    return value || defaultValue;<br/>  }<br/>}</span></pre><p id="fe6e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">或者，如果输入值为空，则可能是三元校验:</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="afaa" class="ld le in kz b gy lf lg l lh li">return value ? value : defaultValue;</span></pre><p id="f8bf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.以某种方式制作日期格式:</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="e1be" class="ld le in kz b gy lf lg l lh li">@Pipe({<br/>  name: "formatMyDate"<br/>})<br/>export class FormatMyDatePipe implements PipeTransform {<br/>  transform(date: Date): string {<br/>    const dateOptions: Intl.DateTimeFormatOptions = { timeZone: "UTC", day: "numeric", month: "long", year: "numeric" };</span><span id="4ed6" class="ld le in kz b gy lj lg l lh li">    const result = date.toLocaleDateString("en-US", dateOptions);<br/>    return formatDate(result, <strong class="kz io"><em class="lz">DATE_LONG_PATTERN</em></strong>, "en_US");<br/>  }<br/>}</span></pre><p id="8ae8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.用于检查空数组的管道:</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="da99" class="ld le in kz b gy lf lg l lh li">@Pipe({<br/>  name: "arrayNotEmpty"<br/>})<br/>export class ArrayNotEmptyPipe implements PipeTransform {<br/>  transform&lt;T&gt;(arr: T[]): boolean {<br/>    return arr?.length &gt; 0;<br/>  }<br/>}</span></pre><p id="0750" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">4.验证管道。</p><p id="728d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，让我们定义一些数组项:</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="4223" class="ld le in kz b gy lf lg l lh li">export interface RouteCharges {<br/>  chargeId?: string;<br/>  chargeName: string;<br/>}<br/>const routeCharge1: RouteCharges = {<br/>  chargeId: "1",<br/>  chargeName: "Test"<br/>}<br/>const routeCharge2: RouteCharges = undefined;</span><span id="a960" class="ld le in kz b gy lj lg l lh li">const pipe: ValidateChargePipe = new ValidateChargePipe();<br/>pipe.transform([routeCharge1, routeCharge2]);</span></pre><p id="12f8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后用数组参数调用管道进行过滤:</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="2247" class="ld le in kz b gy lf lg l lh li">@Pipe({<br/>  name: "validateCharge"<br/>})<br/>export class ValidateChargePipe implements PipeTransform {<br/>  transform(routeCharges: RouteCharges[]): boolean {<br/>    return routeCharges?.some(route =&gt; route?.chargeId);<br/>  }<br/>}</span></pre><p id="b896" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">管道异步 vs 订阅</strong></p><p id="c231" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">异步管道将创建订阅并保持可观察的最新值。异步管道将自动更新模板内的值。</p><p id="9cbe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用 dollar $ char 来区分可观察变量。</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="e392" class="ld le in kz b gy lf lg l lh li">data$: Observable&lt;<!-- -->PersonData<!-- -->[]&gt;;</span><span id="396c" class="ld le in kz b gy lj lg l lh li">constructor(private readonly store: Store&lt;State&gt;) {}<br/>ngOnInit() {<br/>  this.data$ = this.store.pipe(...);<br/>}</span></pre><p id="f552" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 template.html 称之为</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="1c0e" class="ld le in kz b gy lf lg l lh li">&lt;ul&gt;&lt;li *ngFor="let item of data$ | async"&gt;{{ item.id }}&lt;/li&gt;&lt;/ul&gt;</span></pre><p id="3a10" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">订阅的工作方式与此类似，但需要花费更多精力来更新机制并手动取消订阅:</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="d406" class="ld le in kz b gy lf lg l lh li">ngOnInit() {<br/>  this.data$ = this.service.data$.subscribe(item =&gt; {<br/>    this.myServiceData = item;<br/>  });<br/>}<br/>ngOnDestroy() {<br/>  this.data$.unsubscribe();<br/>}</span></pre><p id="f1d7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以，简短地说说<strong class="jm io"> subscribe() </strong>:</p><ol class=""><li id="21a0" class="lk ll in jm b jn jo jr js jv lm jz ln kd lo kh lp lq lr ls bi translated">为了避免 ngOnDestroy()中的内存泄漏，总是需要取消对对象的订阅。</li><li id="011d" class="lk ll in jm b jn lt jr lu jv lv jz lw kd lx kh lp lq lr ls bi translated">当我们在 ngOnInit()中订阅 Observable 时，它不会在模板中更新值。OnPush 更改检测策略不适用。需要手动调用 changedectitionref . markforcheck()。</li></ol><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="ddae" class="ld le in kz b gy lf lg l lh li">    private readonly destroy$: Subject = new Subject&lt;boolean&gt;();<br/>    isSaving: boolean; // variable for template html<br/>    <br/>    constructor(<br/>        private myService: MyService,<br/>        private cdr: ChangeDetectorRef<br/>    ) {<br/>      super(cdr);<br/>      this.destroy$ = new Subject&lt;boolean&gt;();<br/>    }<br/>    <br/>    ngOnInit() {<br/>      this.myService.getTariffData()<br/>            .takeUntil(this.destroy$)<br/>            .subscribe(next =&gt; {<br/>                 console.log(next));<br/>                 this.isSaving = next;<br/>                 <!-- -->this.cdr.markForCheck()<br/>            <!-- -->});<br/>    }<br/>    <br/>    ngOnDestroy() {<br/>        this.destroy$.next(true);<br/>        this.destroy$.complete();<br/>        this.destroy$.unsubscribe();<br/>    }</span></pre><p id="afc6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以，关于<strong class="jm io">异步</strong>的艰难时刻:</p><ol class=""><li id="dbde" class="lk ll in jm b jn jo jr js jv lm jz ln kd lo kh lp lq lr ls bi translated">对象必须潜在地在多个不同的地方在单个模板中被展开多次。喜欢<code class="fe ma mb mc kz b">*ngIf="data$ | async as PersonType"</code></li><li id="5535" class="lk ll in jm b jn lt jr lu jv lv jz lw kd lx kh lp lq lr ls bi translated">在真条件下可以访问<code class="fe ma mb mc kz b">*ngIf</code>或<code class="fe ma mb mc kz b">*ngFor</code>内的变量。例如，如果<code class="fe ma mb mc kz b">*ngIf </code>为 false，那么在组件方法中，内部的属性等于 null。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi md"><img src="../Images/7b1639fd3f1d92f59ffce01fb84802ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rQb8_bCaWx25TdYhQIF34A.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">华金·索罗拉，1910 年，印象派绘画</figcaption></figure><p id="af67" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">结论</strong></p><p id="e789" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当创建一个有很多副作用复杂处理时，我们应该使用 subscribe to Observable，否则，“异步管道”可以很好地根据某些条件在 UI 中显示项目。</p><p id="d9fa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">链接</strong></p><div class="me mf gp gr mg mh"><a href="https://angular.io/guide/pipes" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd io gy z fp mm fr fs mn fu fw im bi translated">有角的</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">Angular 是一个构建移动和桌面 web 应用程序的平台。加入数百万开发者的社区…</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">angular.io</p></div></div></div></a></div></div></div>    
</body>
</html>