<html>
<head>
<title>An efficient way to compare strings in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">围棋中比较字符串的有效方法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/an-efficient-way-to-compare-strings-in-go-66b61844071f?source=collection_archive---------1-----------------------#2020-04-19">https://blog.devgenius.io/an-efficient-way-to-compare-strings-in-go-66b61844071f?source=collection_archive---------1-----------------------#2020-04-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="dd01" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">权威指南</h2><div class=""/><div class=""><h2 id="af34" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">有没有比在Golang中使用==更好的比较字符串的方法？让我们看看</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/517182b6ccdeb3a3006814feb7a0911a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NhooIXz5bjDr4LMBzJonKQ.jpeg"/></div></div></figure><h1 id="7e73" class="la lb iq bd lc ld le lf lg lh li lj lk kf ll kg lm ki ln kj lo kl lp km lq lr bi translated">介绍</h1><p id="0d6f" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">最容易被忽略的操作之一是比较两个字符串，这可能不会导致系统开销，但可以肯定的是，尽可能编写高效的代码是一个很好的实践。当应用程序在生产中面临真正的压力时，这些小红利最终肯定会得到回报。</p><p id="9219" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated"><strong class="lu ja">注:</strong>我是围棋业余爱好者，如果你是一名经验丰富的围棋专业人士，在这里发现任何错误都不要生气。如果你能指出错误，我会相应地改正。</p><p id="bea1" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">经常使用的字符串比较之一是:</p><pre class="kp kq kr ks gt mt mu mv mw aw mx bi"><span id="68a1" class="my lb iq mu b gy mz na l nb nc">strings.ToLower(stringA) == strings.ToLower(stringB)</span></pre><p id="7fcb" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">但是这种比较方式每次操作都要花费很多时间，原因是，在围棋中，字符串是不可变的符文序列。<a class="ae nd" href="https://blog.golang.org/strings" rel="noopener ugc nofollow" target="_blank"> <em class="ne">围棋中的符文</em> </a>是一个代表<a class="ae nd" href="https://en.wikipedia.org/wiki/Code_point" rel="noopener ugc nofollow" target="_blank"> <em class="ne">码位的整数值</em> </a></p><p id="c1ba" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">Rob Pike在博客中给出了更详细、更明智的解释:<a class="ae nd" href="https://blog.golang.org/strings" rel="noopener ugc nofollow" target="_blank">https://blog.golang.org/strings</a>这是一本非常好的睡前读物，它概括了编程语言中字符串的基础知识。</p><p id="2d91" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">这里<a class="ae nd" href="https://golang.org/src/strings/strings.go?s=14301:14330#L574" rel="noopener ugc nofollow" target="_blank"><em class="ne">to lower</em></a>strings包中的一个标准函数，当使用它遍历整个字符串时，将它转换成小写并返回一个新的字符串，因为Go中的strings是不可变的，这意味着<a class="ae nd" href="https://golang.org/pkg/strings/#ToLower" rel="noopener ugc nofollow" target="_blank"> <em class="ne"> strings。ToLower </em> </a>为这两个字符串分配新的内存空间。</p><p id="0dbf" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated"><strong class="lu ja">样本代码:</strong></p><pre class="kp kq kr ks gt mt mu mv mw aw mx bi"><span id="dc11" class="my lb iq mu b gy mz na l nb nc">func CompareStringsInCrudeWay(stringA, stringB string) (bool, error) {<br/>	if strings.ToLower(stringA) == strings.ToLower(stringB) {<br/>		return true, nil<br/>	} else {<br/>		return false, nil<br/>	}<br/>}</span></pre><p id="fc8b" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated"><strong class="lu ja">基准:</strong></p><pre class="kp kq kr ks gt mt mu mv mw aw mx bi"><span id="0b59" class="my lb iq mu b gy mz na l nb nc">Input:</span><span id="db65" class="my lb iq mu b gy nf na l nb nc">  stringA = "rakesh123456789mothukuri123456789"</span><span id="4b67" class="my lb iq mu b gy nf na l nb nc">  stringB = "ramesh123456789mothukuri123456789"</span><span id="56f1" class="my lb iq mu b gy nf na l nb nc">BenchmarkCompare-8       8304722               151 ns/op               0 B/op          0 allocs/op</span></pre><p id="d0a9" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">如果我们注意到在早期的性能指标评测数据中，每次操作都需要<code class="fe ng nh ni mu b">151 nanoseconds</code>。但是我们需要谈论的太多了吗？不，但是如果字符串比较的方式有一个简单的改变，我们可以把它降低到30纳秒，为什么不呢？</p><p id="40a3" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated"><strong class="lu ja">优化</strong></p><p id="546b" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">为了优化，我们可以找到一种方法，而不是遍历每个字符串的符文，比较字符串中的每个字符，如果符文不匹配，我们会将符文转换为小写，然后再次比较，如果它们仍然不匹配，我们打破循环，打破循环，并返回字符串不相同。此过程将节省比较字符串所花费的操作时间。</p><p id="3b65" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated"><strong class="lu ja">伪代码</strong></p><pre class="kp kq kr ks gt mt mu mv mw aw mx bi"><span id="175d" class="my lb iq mu b gy mz na l nb nc">func Compare(stringA, stringB string) bool {<br/>	for i := 0; i &lt; len(stringA); i++ {<br/>		if stringA[i] == stringB[i] {<br/>			continue<br/>		}<br/>		if unicode.ToLower(stringA[i]) != unicode.ToLower(stringB[i]) {<br/>			return false<br/>		}<br/>	}<br/>	return true<br/>}</span></pre><p id="632e" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">但是这有更多的逻辑需要记住，并且在每次我们比较字符串的时候，如果有一个简单的方法的话。Go <a class="ae nd" href="https://golang.org/pkg/strings/" rel="noopener ugc nofollow" target="_blank"> <em class="ne"> strings </em> </a>包有一个以这种方式执行的方法，就是<a class="ae nd" href="https://golang.org/src/strings/strings.go?s=24780:24812#L964" rel="noopener ugc nofollow" target="_blank"> strings。相等倍数</a></p><p id="dc7a" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated"><strong class="lu ja">使用EqualFold的示例代码</strong></p><pre class="kp kq kr ks gt mt mu mv mw aw mx bi"><span id="c845" class="my lb iq mu b gy mz na l nb nc">func CompareStringsInEfficientWay(stringA, stringB string) (bool, error) {<br/>   if strings.EqualFold(stringA, stringB) {<br/>      return true, nil<br/>   } else {<br/>      return false, nil<br/>   }<br/>}</span></pre><p id="e3d5" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated"><strong class="lu ja">基准:</strong></p><pre class="kp kq kr ks gt mt mu mv mw aw mx bi"><span id="03f0" class="my lb iq mu b gy mz na l nb nc">Input:<br/>  stringA = "rakesh123456789mothukuri123456789"<br/>  stringB = "ramesh123456789mothukuri123456789"<br/>BenchmarkCompare-8      76842292                17.1 ns/op             0 B/op          0 allocs/op</span></pre><p id="e5dc" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">现在，每个操作花费了<strong class="lu ja"> 17纳秒</strong>秒，这些小的成功在一段时间内肯定会有回报，不仅他们有回报，它还有助于促进编写代码的有效方式。</p><p id="7df2" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">博客到此结束。如果你认为在Go中比较字符串有更有效的方法，请给我留言，我会给你添加属性并修改内容。</p></div></div>    
</body>
</html>