<html>
<head>
<title>C# Tip: SQL Executor Service</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C#提示:SQL Executor服务</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/c-problem-sql-executor-service-deb459132a50?source=collection_archive---------4-----------------------#2022-01-22">https://blog.devgenius.io/c-problem-sql-executor-service-deb459132a50?source=collection_archive---------4-----------------------#2022-01-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1f1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我不自称是周围最好的开发人员，但有时我会享受这些“啊哈”时刻，即使只是为了我自己。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/789826a5c2f5a63040e5bf4fe4ceceb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EUboWyiiXIeu0Z6KDyKLEQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">样品依赖性注入</figcaption></figure><h1 id="33eb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">系列目录</h1><p id="2349" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated"><strong class="jp ir">第1部分:SQL执行器服务</strong> <br/> <a class="ae me" href="https://medium.com/dev-genius/c-tip-sql-executor-service-dependency-injection-4455efb453b0" rel="noopener">第2部分:依赖注入</a> <br/> <a class="ae me" href="https://justin-coulston.medium.com/c-tip-sql-executor-service-extending-functionality-edad1c554f" rel="noopener">第3部分:扩展功能</a></p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="c3d1" class="lb lc iq bd ld le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly bi translated">问题</h1><p id="1ce7" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">我写了很多和SQL Server交互的软件。当然，我们可以走原始的ADO.NET路线，但是谁还想做那么多的工作呢？是的，实体框架(EF)有它的位置，但是正确地使用你期望的性能需要对内部工作有更深的了解。所以这些年来我一直倾向于使用<a class="ae me" href="https://github.com/DapperLib/Dapper" rel="noopener ugc nofollow" target="_blank"> Dapper </a>，这是一种奇妙的小微虫。</p><p id="1b58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我的问题来自不得不将基本选项注入服务类(如<code class="fe mr ms mt mu b">string connectionString</code>)以及不得不围绕创建连接、事务并确保它们被关闭编写样板代码。</p><blockquote class="mv mw mx"><p id="ae98" class="jn jo my jp b jq jr js jt ju jv jw jx mz jz ka kb na kd ke kf nb kh ki kj kk ij bi translated">在这些低年级的班级里，我不喜欢利用。NET Core的选项模式，因为它创建了一个强大的依赖性。如果我有很强的依赖性，我宁愿是我自己的代码。</p></blockquote><p id="1afd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，假设我有一个查询服务:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="ccea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，还有实现本身:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="815e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我一遍又一遍地努力写这个…这很耗时，当有将近100个类和方法使用这种类型的样板文件时，它确实开始变得乏味了…</p><blockquote class="mv mw mx"><p id="8650" class="jn jo my jp b jq jr js jt ju jv jw jx mz jz ka kb na kd ke kf nb kh ki kj kk ij bi translated">我们也不要忘记，我们已经限制了我们执行跨存储库事务的能力，这可能是可取的。</p></blockquote><h1 id="4a86" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">解决方案1:简单的代码重用</h1><p id="be6d" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">最简单的解决方案是从重用一些代码和创建一些助手方法开始。一种自然的方法是将下面的帮助器添加到每个类中，或者将方法添加到一些公共区域进行共享(可以是静态类、扩展或基类)。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="8876" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但这对我来说还是感觉不对。我想要更多的灵活性…</p><h1 id="b7a3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">解决方案2: SQL Executor服务</h1><p id="3f64" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">不如，我创建一个单独的服务来为我做这件事？然后，我可以控制服务的生命周期，何时提交或拒绝使用事务。这种灵活性对我来说听起来不错！</p><p id="f7aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来看看SQL Executor服务:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="80b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">命名可能会更好一点，但我现在保持不变。</p><p id="5c6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这使我们能够将一个服务注入到所有设置了不同特性的存储库中。例如，下面是一个简单的非事务性实现:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="1d86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，不会为每个调用创建事务，而是将null传递给函数。这在与Dapper一起工作时效果很好。但是，任何其他用户可能需要先检查交易。</p><p id="aefa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，添加事务版本很简单:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="c089" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我已经有了一些可以使用的实现(选择您喜欢使用的)，我们需要使用它。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="d74d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">没什么复杂或神奇的。很简单。并且节省了一大堆代码。</p><h1 id="f89f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="6874" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">我喜欢这种方法的一点是，我们可以在任何地方轻松地注入这个<code class="fe mr ms mt mu b">ISqlExecutor</code>。我们可以重用它，忽略与创建连接和事务相关的一切。这大大减少了我的存储库中的代码量，使我能够专注于Transact-SQL优化。</p><p id="c387" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">希望您发现这个小技巧对您自己的代码有用！这并不意味着有创意或疯狂。我发现许多和我一起工作的开发人员(包括我自己)会一遍又一遍地做同样的事情，而忘记了我们可以创建小的抽象来提高代码的效率。</p><p id="2d22" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下次见！</p><h1 id="67e8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">额外收获:跨存储库事务</h1><p id="64dd" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">差点忘了这最后一个实现。下面可以提供一种跨存储库事务管理的方法。这在更复杂的web API调用中特别有用，在这种情况下，您需要多个存储库在一个业务服务中作为一个存储库工作。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="5006" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不过，要做到这一点，您必须能够在您的DI容器中适当地注入这个服务<code class="fe mr ms mt mu b">Scoped</code>。如果处理不当，这可能会非常棘手。所以我将不得不把实现讨论留到下一天。但是如果有兴趣，请告诉我！</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="5771" class="lb lc iq bd ld le mm lg lh li mn lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly bi translated">相关故事</h1><p id="932a" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated"><a class="ae me" href="https://justin-coulston.medium.com/c-tip-sql-executor-service-dependency-injection-4455efb453b0" rel="noopener"> C#提示:SQL执行器服务—依赖注入</a> <br/> <a class="ae me" rel="noopener ugc nofollow" target="_blank" href="/advanced-c-sql-server-bulk-upload-57ad6be6e6a1">高级C# — SQL Server批量上传</a> <br/> <a class="ae me" rel="noopener ugc nofollow" target="_blank" href="/advanced-c-common-sql-table-structures-bb7f7149b887">高级C# —常用SQL表结构</a></p></div></div>    
</body>
</html>