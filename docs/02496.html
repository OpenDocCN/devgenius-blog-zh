<html>
<head>
<title>Caching Eloquent queries with Redis in Laravel</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Laravel 中用 Redis 缓存有说服力的查询</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/caching-eloquent-queries-with-redis-in-laravel-b8872d8eeb18?source=collection_archive---------0-----------------------#2020-08-08">https://blog.devgenius.io/caching-eloquent-queries-with-redis-in-laravel-b8872d8eeb18?source=collection_archive---------0-----------------------#2020-08-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0fcdb89bfbcb827e7c36fef12bf58ae6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5B7CTk21y9QmHYKG"/></div></div></figure><p id="021c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们都见过许多网站<strong class="ka ir">太慢，</strong>不够快让我们抓狂，我们最终离开了它们，再也不会回来。</p><p id="19de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">想象一下，拥有一个对数据库有大量请求的网站，迟早你将不得不投入大量的计算能力来响应数据库请求，并且你将不得不为此付出大量的金钱。</p><h2 id="9600" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">那么，有什么方法可以在请求数量不变的情况下减少数据库查询呢？</h2><p id="97b5" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">是的，<strong class="ka ir">缓存</strong>可以帮助解决这个问题。</p><p id="17aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你使用 Laravel 框架作为你的网站/web 应用程序的后端栈，这是很容易配置的。Laravel 有一些现成的驱动程序，其中一些是:</p><ol class=""><li id="1021" class="lu lv iq ka b kb kc kf kg kj lw kn lx kr ly kv lz ma mb mc bi translated"><strong class="ka ir">文件</strong></li><li id="dd07" class="lu lv iq ka b kb md kf me kj mf kn mg kr mh kv lz ma mb mc bi translated"><strong class="ka ir"> Redis </strong></li><li id="4638" class="lu lv iq ka b kb md kf me kj mf kn mg kr mh kv lz ma mb mc bi translated"><strong class="ka ir"> Memcached </strong></li></ol><p id="73d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">文件驱动是一个很好的选择，但是如果你想在更大的范围内，更快地做一些事情，你应该使用 Redis 或者 Memcached。</p><h2 id="8556" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">在本文中，我们将通过两个简单的步骤来了解高速缓存如何与 Redis 一起工作:</h2><p id="7947" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">我假设您已经在本地环境中安装并运行了 Laravel 和 Redis。</p><ol class=""><li id="dde6" class="lu lv iq ka b kb kc kf kg kj lw kn lx kr ly kv lz ma mb mc bi translated">添加 Redis 配置，并将缓存驱动程序设置为使用 Redis(在。环境文件):</li></ol><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/a38710d8da723edf820934eaddc32f67.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/1*etP5UpNkqXp-cqVT0RwmLw.png"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">。环境文件</figcaption></figure><p id="20cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所知，Redis 是一个内存中的键值数据库。这是向其添加键和值对的方法:</p><pre class="mj mk ml mm gt mr ms mt mu aw mv bi"><span id="7a2b" class="kw kx iq ms b gy mw mx l my mz">Cache::put($key, $value, $ttl);<br/>Cache::put('foo', 'bar', 600);</span></pre><p id="dc8b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将保存值为“bar”的“foo ”,该值将保留 10 分钟(600 秒)。要获得缓存的值，我们可以使用:</p><pre class="mj mk ml mm gt mr ms mt mu aw mv bi"><span id="e276" class="kw kx iq ms b gy mw mx l my mz">$foo = Cache::get('foo');</span></pre><p id="5156" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我们从数据库中检索帖子的方式。</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div class="gh gi na"><img src="../Images/8f125210691e85a5eb3bbd9aae341065.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*662Nac24BWat2nNw3ucSmg.png"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">app/Http/PostController.php 文件</figcaption></figure><p id="f2dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.我们可以在第一次请求后缓存这些帖子，这样我们就不再查询数据库，因为数据将来自 Redis:</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/98ffbe1ac55d7976112ad8b0b73f6e93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*LZuJp3TT4_cVzf4k_t0SRw.png"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">app/Http/PostController.php 文件</figcaption></figure><p id="c730" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将检查缓存中是否存在“posts”键，如果存在，它将使用缓存，否则，它将查询数据库，然后将数据保存到缓存中，以供下一次请求使用 33600 秒。</p><p id="dd23" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请记住，当您<strong class="ka ir">创建、更新、删除</strong>一个帖子时，您必须<strong class="ka ir">删除(忘记)带有该键的缓存(在本例中为“posts”</strong>，否则，它将向您显示<strong class="ka ir">旧数据，这些数据将被缓存到 TTL 时间结束</strong>。</p></div></div>    
</body>
</html>