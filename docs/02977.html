<html>
<head>
<title>Advanced use of Regex Groups</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">正则表达式组的高级用法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/advanced-use-of-regex-groups-147ebfcbb139?source=collection_archive---------1-----------------------#2020-09-17">https://blog.devgenius.io/advanced-use-of-regex-groups-147ebfcbb139?source=collection_archive---------1-----------------------#2020-09-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="5611" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正则表达式是一个很有用的学习工具。本质上，它们是一个解析文本的工具。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/84d4d00171249bedaed0ce94479705c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lZHtgsqo0gww25bLcpjTqQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">正则表达式是Python的基础</figcaption></figure><p id="a1ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它们存在于几乎每一种语言中，尽管有些差异。因此，正则表达式是可以在不同技术之间转移的知识。本文将关注Python版本的Regex。</p><p id="3d77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我是在我读过的阿菲尼亚·德查尔特和T2的萨德拉赫·皮耶博士的文章的基础上写的。相应文章的链接在底部。</p><p id="4b2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它们可以在没有任何协议的情况下应用于解析数据结构。JSON或XML等格式通常都有自定义的解析器。然而，有时您可能会遇到不熟悉的格式，在这种情况下，只有正则表达式可以拯救您。此外，正则表达式对于解析日志非常有用。</p><p id="9ef4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天我将试着介绍群的高级用法。这些用于从字符串中获取信息。它们被括在括号()中。</p><pre class="km kn ko kp gt ld le lf lg aw lh bi"><span id="c3d1" class="li lj iq le b gy lk ll l lm ln">m=re.search("(Trump)","Trump will win the election")<br/>m.groups()</span></pre><blockquote class="lo lp lq"><p id="41e9" class="jn jo lr jp b jq jr js jt ju jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj kk ij bi translated">(‘川普’，)</p></blockquote><p id="3485" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个在字符串中查找单词的简单例子。括号内的名称表示要捕获的名称。</p><h2 id="f52d" class="li lj iq bd lv lw lx dn ly lz ma dp mb jy mc md me kc mf mg mh kg mi mj mk ml bi translated">向前和向后正则表达式断言</h2><p id="f49a" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">我们正在转向更高级的组的使用。假设您想要查找前面有一系列字符的内容，但是您不希望将它们包含在组中。这种情况需要后视和前瞻断言。</p><pre class="km kn ko kp gt ld le lf lg aw lh bi"><span id="042d" class="li lj iq le b gy lk ll l lm ln">txt=”Date: 03/07/20 We saw him on 04/05/20"<br/>m=re.search(“(?&lt;=Date: )(\d{2}/\d{2}/\d{2})”,txt)</span></pre><blockquote class="lo lp lq"><p id="8ce9" class="jn jo lr jp b jq jr js jt ju jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj kk ij bi">(‘03/07/20’,)</p></blockquote><p id="f244" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个例子中，我们试图捕获字符串开头的日期。具体来说，我们正在寻找“日期:”一词后面的日期。在上面的模式中，这是由“？&lt; = "开头。如你所见，文本中有两个日期(即，txt)，由于后视断言，我们的搜索只捕获第一个。这种表达也可以用“？”来否定。</p><h2 id="242d" class="li lj iq bd lv lw lx dn ly lz ma dp mb jy mc md me kc mf mg mh kg mi mj mk ml bi translated">非捕获正则表达式组</h2><p id="31ad" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">我们还知道所谓的非捕获组，它们需要在模式匹配的字符串中，但是它们没有被捕获。您可能认为这看起来类似于后视和前瞻断言。您的想法是正确的，因为您可以执行大多数任务，否则您会使用断言。</p><pre class="km kn ko kp gt ld le lf lg aw lh bi"><span id="cea7" class="li lj iq le b gy lk ll l lm ln">txt=”Date: 03/07/20 We saw him on 04/05/20"<br/>m=re.search(“(?:Date: )(\d{2}/\d{2}/\d{2})”,txt)</span></pre><blockquote class="lo lp lq"><p id="0f3e" class="jn jo lr jp b jq jr js jt ju jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj kk ij bi">(‘03/07/20’,)</p></blockquote><p id="3ee5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">非捕获组，而不是后视断言，否则示例和结果都是一样的。</p><p id="3eeb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，使用其他功能时会有一些不同。也就是说，当使用match和sub时，它们的行为是不同的。sub函数用于用新的字符串替换找到的模式。</p><pre class="km kn ko kp gt ld le lf lg aw lh bi"><span id="8177" class="li lj iq le b gy lk ll l lm ln">m1=re.sub(“(?:Date: )(\d{2}/\d{2}/\d{2})”,”02/02/20”,txt)<br/>m2=re.sub(“(?&lt;=Date: )(\d{2}/\d{2}/\d{2})”,”02/02/20”,txt)<br/>print(m1)<br/>print(m2)</span></pre><blockquote class="lo lp lq"><p id="d468" class="jn jo lr jp b jq jr js jt ju jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj kk ij bi translated">我们在04/05/20见到了他</p></blockquote><p id="42a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你所看到的，sub方法是有区别的。即，非捕获组包括替换中的非捕获材料。因此，当你想交换前面有指定符号的东西时，最好使用后视断言。</p><p id="ec0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">match函数总是在字符串的开头寻找模式，因此，如果在字符串的开头包含一个后视断言，就不会有匹配。</p><p id="3e32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">小组也可以捕捉替代方案。“|”表示左边或右边的表达式。断言的一个令人讨厌的特性是替代项必须等长，这迫使您在某些场景中使用非捕获组。例如，我们假设在一些文本中，除了使用序列“日期:”的其他文本之外，我们正在寻找的日期前面是序列“开始:”的。</p><pre class="km kn ko kp gt ld le lf lg aw lh bi"><span id="640f" class="li lj iq le b gy lk ll l lm ln"><br/>m=re.search(“(?&lt;=Date: |Start: )(\d{2}/\d{2}/\d{2})”,txt)</span></pre><blockquote class="lo lp lq"><p id="9452" class="jn jo lr jp b jq jr js jt ju jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj kk ij bi translated">raise错误("后视需要固定宽度模式")<br/> re.error:后视需要固定宽度模式</p></blockquote><p id="a9c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于后视断言需要固定宽度的模式，因此返回一个错误。因此，我们应该在这里使用非捕获组。</p><h2 id="a14d" class="li lj iq bd lv lw lx dn ly lz ma dp mb jy mc md me kc mf mg mh kg mi mj mk ml bi translated">结论</h2><p id="eda6" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">我们看了一下正则表达式中两个有用的概念。我们将继续这个系列的一篇文章，重点关注命名组。</p><div class="mr ms gp gr mt mu"><a href="https://medium.com/madhash/the-basics-of-regular-expressions-explained-simply-c65fff886608" rel="noopener follow" target="_blank"><div class="mv ab fo"><div class="mw ab mx cl cj my"><h2 class="bd ir gy z fp mz fr fs na fu fw ip bi translated">正则表达式的基础——简单解释</h2><div class="nb l"><h3 class="bd b gy z fp mz fr fs na fu fw dk translated">帮你弄清楚这一切意味着什么</h3></div><div class="nc l"><p class="bd b dl z fp mz fr fs na fu fw dk translated">medium.com</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni kv mu"/></div></div></a></div><div class="mr ms gp gr mt mu"><a href="https://towardsdatascience.com/regular-expressions-in-python-7c991daab100" rel="noopener follow" target="_blank"><div class="mv ab fo"><div class="mw ab mx cl cj my"><h2 class="bd ir gy z fp mz fr fs na fu fw ip bi translated">Python中的正则表达式</h2><div class="nb l"><h3 class="bd b gy z fp mz fr fs na fu fw dk translated">数据科学的正则表达式</h3></div><div class="nc l"><p class="bd b dl z fp mz fr fs na fu fw dk translated">towardsdatascience.com</p></div></div><div class="nd l"><div class="nj l nf ng nh nd ni kv mu"/></div></div></a></div></div></div>    
</body>
</html>