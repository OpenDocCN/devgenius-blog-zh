<html>
<head>
<title>Ignorant Java Developers Don’t Understand These 3 Feature Benefits</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无知的 Java 开发人员不理解这 3 个特性的好处</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/ignorant-java-developers-dont-understand-these-3-feature-benefits-8034d458edea?source=collection_archive---------1-----------------------#2022-07-02">https://blog.devgenius.io/ignorant-java-developers-dont-understand-these-3-feature-benefits-8034d458edea?source=collection_archive---------1-----------------------#2022-07-02</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="132d" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated"><strong class="ak">这就是为什么 Java 开发人员不要低估 Lambdas、Optional 和 Enums 的威力</strong></h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj kg"><img src="../Images/afe6f601227b8266aa1177e5125ad805.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VN_JKb4-i5pxDRh7.png"/></div><figcaption class="ko kp gk gi gj kq kr bd b be z dk translated">来自<a class="ae ks" href="https://www.pexels.com/photo/photo-of-man-sitting-in-front-of-people-3184299/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">派克斯</a>的<a class="ae ks" href="https://www.pexels.com/@fauxels?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">派克斯</a>的照片</figcaption></figure><p id="f5b6" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">无知的 Java 开发人员日复一日，编写代码，继续他们的生活。T11】</p><p id="896f" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">探险者知道为什么某个变化是重要的。并理解为什么改进很重要。这就是有经验的 Java 开发人员每天提高知识的方式。</p><p id="9577" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><strong class="kv is"> <em class="lp">有哪些 Java 特性是理所当然的？</em> </strong>带着下面的问题来看看。</p><p id="66fe" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">为什么 lambda 不仅仅是语法糖？为什么<code class="fe lq lr ls lt b">Optional</code>在某些场合不好？为什么只有接口的常量已经过时了？</p><p id="231d" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">让我们找出无知的开发人员没有注意到的问题。</p><h1 id="a280" class="lu lv ir bd lw lx ly lz ma mb mc md me jx mf jy mg ka mh kb mi kd mj ke mk ml bi translated">1.你为什么用兰姆达斯？</h1><p id="e3eb" class="pw-post-body-paragraph kt ku ir kv b kw mm js ky kz mn jv lb lc mo le lf lg mp li lj lk mq lm ln lo ik bi translated">我们现在都用 Java lambdas。以至于我们甚至为了使用兰姆达斯而使用它们。</p><p id="74a6" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">在 lambdas 之前，有匿名类。你应该像这样创造它们。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mr ms l"/></div></figure><p id="6c1f" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">如今，你会得到一个即时通知，切换到兰姆达斯。那么 lambdas 带来了什么，匿名类没有的呢？为什么如今它们如此重要？</p></div><div class="ab cl mt mu hv mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ik il im in io"><p id="bfef" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">假设调用类有很多标量和非标量字段。</p><p id="c5be" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><strong class="kv is"> <em class="lp"> Lambda 激励纯函数开发。</em>T19】</strong></p><p id="aa26" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">Lambdas 和匿名类也会捕获调用类。您可以从这两个实现中调用非静态方法。由于 lambdas 可以受益于内联缓存命中，所以最好引用静态方法和有效的最终变量。</p><p id="fdbb" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><strong class="kv is"> <em class="lp"> Lambda 速度快，重量轻。每次都会创建匿名类。</em> </strong></p><p id="0696" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">Lambda 应该是一个纯函数，所以 JVM 很容易内联和缓存。因此，只有第一次调用将是“昂贵的”，但随后的每次调用都将对此行为进行摊销。</p><p id="c57f" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><strong class="kv is"><em class="lp">lambda 是 JVM 匿名类。匿名类是 Java 匿名类。</em> </strong></p><p id="9dc8" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">lambdas 的这个属性支持延迟计算的调用点。这就是为什么只有第一个电话是昂贵的。每个下一个调用都更快，因为<code class="fe lq lr ls lt b">ConstantCallSite</code>被缓存了。本质上，“懒惰”让兰姆达斯跑得更快。</p></div><div class="ab cl mt mu hv mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ik il im in io"><p id="5403" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><strong class="kv is"> <em class="lp">除了性能属性之外，还增强了可读性。</em> </strong></p><p id="714b" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">你应该让兰姆达斯越小越好。此外，在 lambdas 中避免外部引用，这样<a class="ae ks" href="https://blogs.oracle.com/javamagazine/post/behind-the-scenes-how-do-lambda-expressions-really-work-in-java" rel="noopener ugc nofollow" target="_blank"> indy 可以尽可能高效地完成工作</a>。如果可能的话，使用方法引用，因为它们比 lambdas 更有效，并且节省代码行。</p><p id="2452" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">我在<a class="ae ks" href="https://medium.com/javarevisited/experienced-developers-use-these-quirks-to-create-better-java-lambdas-4ae656148274" rel="noopener">上深入写过 lambdas 如何打败匿名类</a>。因此，也可以查看一下，以填补空白或更深入地探索 lambdas。</p><h1 id="6829" class="lu lv ir bd lw lx ly lz ma mb mc md me jx mf jy mg ka mh kb mi kd mj ke mk ml bi translated">2.为什么你不应该误用<code class="fe lq lr ls lt b">Optional</code>？</h1><p id="8234" class="pw-post-body-paragraph kt ku ir kv b kw mm js ky kz mn jv lb lc mo le lf lg mp li lj lk mq lm ln lo ik bi translated">一些开发商滥用可选。</p><p id="caed" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">他们在没有上下文的情况下过度使用 Optional。</p><p id="b1b2" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">Optional 提供了良好的 API，吸引了许多懒惰的开发人员。所以他们链接方法，而一个简单的空检查就足够了。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mr ms l"/></div><figcaption class="ko kp gk gi gj kq kr bd b be z dk translated"><a class="ae ks" href="https://www.govnokod.ru/24731" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="e180" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">你可以看到的另一件事是<code class="fe lq lr ls lt b">ofNullable</code>的误用。即使这种方法已经存在，仍然需要空检查。因此，如果空检查就足够了，就不要插入可选的。</p><p id="07bc" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">Optional 带来的另一个东西是可选包装器。<code class="fe lq lr ls lt b">OptionalLong</code>就是一个例子。<br/>从基准测试中我们可以看出，包装器比普通可选的要快。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gi gj na"><img src="../Images/a39479b2ca4cf44d12afbb3cead85528.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tH2SxQdS0DHerRR8OEGajA.png"/></div></div><figcaption class="ko kp gk gi gj kq kr bd b be z dk translated">基准<a class="ae ks" href="https://jmh.morethan.io/?gist=7a9da3ea312be8fc6f5716e63caeb6eb" rel="noopener ugc nofollow" target="_blank">详细信息</a></figcaption></figure></div><div class="ab cl mt mu hv mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ik il im in io"><p id="e5eb" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">还有<a class="ae ks" href="https://gist.github.com/xfix/34b8c8717191c191e577a843cfc9e15b" rel="noopener ugc nofollow" target="_blank"> </a> <code class="fe lq lr ls lt b"><a class="ae ks" href="https://gist.github.com/xfix/34b8c8717191c191e577a843cfc9e15b" rel="noopener ugc nofollow" target="_blank">MyOptionalLong</a></code> <a class="ae ks" href="https://gist.github.com/xfix/34b8c8717191c191e577a843cfc9e15b" rel="noopener ugc nofollow" target="_blank"> </a>由<code class="fe lq lr ls lt b">Optional</code>提炼而来，如这位<a class="ae ks" href="https://www.reddit.com/r/rust/comments/q99eqe/rust_option_30x_more_efficient_to_return_than/hgynrll/?utm_source=share&amp;utm_medium=web2x&amp;context=3" rel="noopener ugc nofollow" target="_blank"> Redditor </a>所暗示的。</p><p id="edc9" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><code class="fe lq lr ls lt b">MyOptionalLong</code>给<code class="fe lq lr ls lt b">isPresent</code>增加了一点改进。这使用引用相等来查看 Optional 是否有值。区别就在这里。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gi gj nf"><img src="../Images/14b52c0f37edab09117e9c856888b2c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q0uGG3RZ1M-REPASVBygpQ.png"/></div></div></figure><p id="5ca1" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">这消除了对布尔变量<code class="fe lq lr ls lt b">isPresent</code>的需要。因此，这个方法让 JVM 执行积极的内联。小改进和思考的食粮！</p></div><div class="ab cl mt mu hv mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ik il im in io"><p id="7d73" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">关于第一个例子，你能做得更好吗？ </p><p id="ac49" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">去掉无用的拳击。此外，在不需要的时候移除空可选的返回。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mr ms l"/></div></figure><p id="e748" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">这种行为上的小变化导致了更好的单次触发时间，以及更好的整体吞吐量。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gi gj ng"><img src="../Images/ec853dc8f781cf93881d58b307f818f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6lriAbTKaYevJ8ZImewz7A.png"/></div></div><figcaption class="ko kp gk gi gj kq kr bd b be z dk translated"><a class="ae ks" href="https://jmh.morethan.io/?gist=98fd37eda2ddcc819ac8c485ce5d7c35" rel="noopener ugc nofollow" target="_blank">详情</a></figcaption></figure><p id="4ca5" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">以后要问的好问题是:<strong class="kv is"> <em class="lp">“为什么可选？简单的空值检查能完成这项工作吗？”</em> </strong></p><p id="b74e" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">可选的好处是<code class="fe lq lr ls lt b">map</code>函数。这应该会使代码有点混乱。所以不需要下面的序列:</p><ul class=""><li id="d084" class="nh ni ir kv b kw kx kz la lc nj lg nk lk nl lo nm nn no np bi translated">检查是否为空</li><li id="2da9" class="nh ni ir kv b kw nq kz nr lc ns lg nt lk nu lo nm nn no np bi translated">null -&gt;返回 null</li><li id="96c2" class="nh ni ir kv b kw nq kz nr lc ns lg nt lk nu lo nm nn no np bi translated">非空-&gt;获取值</li></ul><p id="b8a4" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">同样，如果你用<code class="fe lq lr ls lt b">orElse</code>添加一个默认值，你会得到一个更清晰的代码。</p></div><div class="ab cl mt mu hv mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ik il im in io"><p id="a69b" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><em class="lp">那么什么时候使用可选呢？</em></p><p id="faf4" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">检查斯图尔特·马克斯的<a class="ae ks" href="https://stuartmarks.files.wordpress.com/2016/09/optionalmotherofallbikesheds3.pdf" rel="noopener ugc nofollow" target="_blank">演示文稿</a>。因为他更博学，创造了可选择的。</p><p id="6826" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">要点:<strong class="kv is"> <em class="lp">避免可选 API 的引力，保持简单。</em> </strong></p><h1 id="03f5" class="lu lv ir bd lw lx ly lz ma mb mc md me jx mf jy mg ka mh kb mi kd mj ke mk ml bi translated">3.你不需要常量，只需要接口</h1><p id="4a2c" class="pw-post-body-paragraph kt ku ir kv b kw mm js ky kz mn jv lb lc mo le lf lg mp li lj lk mq lm ln lo ik bi translated">到目前为止，您可能已经看到了这段代码。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mr ms l"/></div><figcaption class="ko kp gk gi gj kq kr bd b be z dk translated"><a class="ae ks" href="https://stackoverflow.com/a/14419212/5999670" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="2a21" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">你应该使用枚举来代替只有常量的接口。</p><p id="c504" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><strong class="kv is"> <em class="lp">枚举提供自定义方法，</em> </strong> <a class="ae ks" href="https://richardstartin.github.io/posts/5-java-mundane-performance-tricks#dont-iterate-over-enumvalues" rel="noopener ugc nofollow" target="_blank"> <strong class="kv is"> <em class="lp">缓存机会</em> </strong> </a> <strong class="kv is"> <em class="lp">，以及</em> </strong> <a class="ae ks" href="https://richardstartin.github.io/posts/5-java-mundane-performance-tricks" rel="noopener ugc nofollow" target="_blank"> <strong class="kv is"> <em class="lp">适当枚举结构</em> </strong> </a> <strong class="kv is"> <em class="lp">。</em>T44】</strong></p><p id="db39" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><em class="lp">枚举内聚性地把常量放在一个地方。这里有个很好的例子:<code class="fe lq lr ls lt b"><a class="ae ks" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/HttpStatus.html" rel="noopener ugc nofollow" target="_blank">HttpStatus</a></code>。只有常量的接口不会像该枚举那样提供所需的安全性。可以只实现常量接口，而 enum 是 final。这个属性很好地包装了常数，防止了任何滥用。</em></p><p id="e89c" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">你是如何从仅包含常量的接口中提取所有常量的？T50】</p><p id="f2f9" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">Enum 在这里使用<code class="fe lq lr ls lt b">values()</code>方法。这样你就可以提取所有的常量，并随心所欲地使用它们。此外，您可以缓存这些值并提高性能。这已经用<a class="ae ks" href="https://github.com/spring-projects/spring-framework/commit/7f1062159ee9926d5abed7cadc2b36b6b7fc242e" rel="noopener ugc nofollow" target="_blank">这个变更集</a>中的<code class="fe lq lr ls lt b">HttpStatus</code>完成了。</p></div><div class="ab cl mt mu hv mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ik il im in io"><p id="5666" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">您可能不需要提高性能或一次获取所有常量。即便如此，如果需要的话，你也要为枚举做好准备。</p><p id="9f6b" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">举个例子，<strong class="kv is"> <em class="lp">枚举并不仅仅局限于 Java 代码</em> </strong>。您可以使用 JPA 和 Hibernate 将 enums 映射到 PostgreSQL。这意味着您可以将它们与实体一起使用，并在需要时添加额外的枚举逻辑。</p></div></div>    
</body>
</html>