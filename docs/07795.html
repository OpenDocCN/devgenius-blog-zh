<html>
<head>
<title>Introduction to Docker — Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker 简介—第 3 部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/introduction-to-docker-part-3-9034ba335250?source=collection_archive---------11-----------------------#2022-04-23">https://blog.devgenius.io/introduction-to-docker-part-3-9034ba335250?source=collection_archive---------11-----------------------#2022-04-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="2bdc" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如果你曾经面临“它在我的机器上工作”的问题，Docker 可能是一个简单的解决方案</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/1a593fdfef1b205b0012898446ffaaae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*esc8YyBEBkhF1m5ppDyozA.png"/></div></div></figure><h1 id="9d7c" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">介绍</h1><p id="2e9c" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">欢迎回到我介绍 Docker 的第三部分。本系列的第一部分介绍了什么是容器以及容器和虚拟机之间的区别。第二部分处理 Docker CLI 最重要的命令。如果您还没有阅读前两部分，请点击此处查看:</p><div class="mc md gp gr me mf"><a rel="noopener  ugc nofollow" target="_blank" href="/introduction-to-docker-part-1-7646c995282c"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd io gy z fp mk fr fs ml fu fw im bi translated">Docker 简介—第 1 部分</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">如果你曾经面临“它在我的机器上工作的问题”，Docker 可能是一个简单的解决方案</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">blog.devgenius.io</p></div></div><div class="mo l"><div class="mp l mq mr ms mo mt km mf"/></div></div></a></div><div class="mc md gp gr me mf"><a rel="noopener  ugc nofollow" target="_blank" href="/introduction-to-docker-part-2-73b36d0722e0"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd io gy z fp mk fr fs ml fu fw im bi translated">Docker 简介—第 2 部分</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">如果你曾经面临“它在我的机器上工作的问题”, Docker 可能是解决方案。</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">blog.devgenius.io</p></div></div><div class="mo l"><div class="mu l mq mr ms mo mt km mf"/></div></div></a></div><p id="d3b5" class="pw-post-body-paragraph lg lh in li b lj mv jo ll lm mw jr lo lp mx lr ls lt my lv lw lx mz lz ma mb ig bi translated">在阅读本系列的前两部分时，您可能想知道如何设置一个包含多个容器的环境。这部分将是这个问题的答案。基本上，有两种处理这种情况的方法:</p><ul class=""><li id="57ee" class="na nb in li b lj mv lm mw lp nc lt nd lx ne mb nf ng nh ni bi translated">Docker 网络</li><li id="e507" class="na nb in li b lj nj lm nk lp nl lt nm lx nn mb nf ng nh ni bi translated"><strong class="li io"> Docker 撰写</strong></li></ul><h2 id="00e9" class="no kp in bd kq np nq dn ku nr ns dp ky lp nt nu la lt nv nw lc lx nx ny le nz bi translated">Docker 网络</h2><p id="be0b" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">Docker 提供了为容器创建网络的功能。因此，必须用<code class="fe oa ob oc od b">docker network create &lt;network name&gt;</code>创建一个 Docker 网络。之后，在启动容器时，必须添加标志<code class="fe oa ob oc od b">--network &lt;network name&gt;</code>。</p><p id="eef4" class="pw-post-body-paragraph lg lh in li b lj mv jo ll lm mw jr lo lp mx lr ls lt my lv lw lx mz lz ma mb ig bi translated">另一种方式是用标志<code class="fe oa ob oc od b">--link</code>代表<code class="fe oa ob oc od b">docker run</code>。尽管该功能不应再使用，但详情可在<a class="ae oe" href="https://docs.docker.com/network/links/" rel="noopener ugc nofollow" target="_blank">此处</a>找到。</p><h2 id="a626" class="no kp in bd kq np nq dn ku nr ns dp ky lp nt nu la lt nv nw lc lx nx ny le nz bi translated">Docker 撰写</h2><p id="e4ca" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">Docker Compose 是多容器 Docker 应用的标准。为了组合，必须创建一个单独的<code class="fe oa ob oc od b">docker-compose.yml</code>，它包含容器的所有信息。因此定义了不同的关键字。</p><p id="0b7e" class="pw-post-body-paragraph lg lh in li b lj mv jo ll lm mw jr lo lp mx lr ls lt my lv lw lx mz lz ma mb ig bi translated">文件的开始总是<code class="fe oa ob oc od b">version</code>的定义。关于版本之间差异的详细信息可以在<a class="ae oe" href="https://docs.docker.com/compose/compose-file/compose-versioning/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="c533" class="pw-post-body-paragraph lg lh in li b lj mv jo ll lm mw jr lo lp mx lr ls lt my lv lw lx mz lz ma mb ig bi translated">然后，定义所需的服务。每个服务都需要所用 Docker 映像的定义。这可以通过关键字<code class="fe oa ob oc od b">image</code>和之后的图像定义来完成。需要的语法是<code class="fe oa ob oc od b">image: &lt;Imagename&gt;:&lt;Tag&gt;</code>，比如<code class="fe oa ob oc od b">image: httpd:2</code>。第二种方法是定义本地 docker 文件的路径。这显示在以下示例中:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="d56b" class="pw-post-body-paragraph lg lh in li b lj mv jo ll lm mw jr lo lp mx lr ls lt my lv lw lx mz lz ma mb ig bi translated">此<code class="fe oa ob oc od b">docker-compose.yml</code>定义了由两个容器组成的多容器设置:</p><ul class=""><li id="0359" class="na nb in li b lj mv lm mw lp nc lt nd lx ne mb nf ng nh ni bi translated"><code class="fe oa ob oc od b">ubuntu_curl</code>:带 curl 的 Linux Ubuntu</li><li id="c451" class="na nb in li b lj nj lm nk lp nl lt nm lx nn mb nf ng nh ni bi translated"><code class="fe oa ob oc od b">web</code> : Apache 网络服务器</li></ul><p id="45bb" class="pw-post-body-paragraph lg lh in li b lj mv jo ll lm mw jr lo lp mx lr ls lt my lv lw lx mz lz ma mb ig bi translated">对于服务<code class="fe oa ob oc od b">web</code>，使用预定义图像<code class="fe oa ob oc od b">httpd</code>。对于<code class="fe oa ob oc od b">ubuntu_curl</code>,使用本地图像。这是通过使用关键字<code class="fe oa ob oc od b">build</code>和 Dockerfile 的路径来完成的。用于此目的的 Dockerfile 仅使用图像<code class="fe oa ob oc od b">ubuntu</code>作为基础图像并安装<code class="fe oa ob oc od b">curl</code>。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="a04d" class="pw-post-body-paragraph lg lh in li b lj mv jo ll lm mw jr lo lp mx lr ls lt my lv lw lx mz lz ma mb ig bi translated">使用命令<code class="fe oa ob oc od b">docker-compose up</code>启动完整的多容器设置。之后<code class="fe oa ob oc od b">docker ps</code>应该显示两个容器都在运行。为了执行容器中的命令，使用命令<code class="fe oa ob oc od b">docker exec &lt;Container&gt; &lt;Command&gt;</code>。为了验证设置，可以基于<code class="fe oa ob oc od b">ubuntu</code>从容器向 web 服务器发出 HTTP 请求。预期输出为<code class="fe oa ob oc od b">It works!</code>，因为这是图像<code class="fe oa ob oc od b">httpd</code>的默认输出。这显示在以下示例中:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="00d6" class="pw-post-body-paragraph lg lh in li b lj mv jo ll lm mw jr lo lp mx lr ls lt my lv lw lx mz lz ma mb ig bi translated">基本上，本系列前一部分描述的所有标志也可以用 Docker Compose 设置。这将用一个例子来说明。该示例在我的另一篇文章中使用过，所需的多容器设置由两部分组成:</p><ul class=""><li id="6055" class="na nb in li b lj mv lm mw lp nc lt nd lx ne mb nf ng nh ni bi translated">InfluxDB:时间序列数据库</li><li id="1959" class="na nb in li b lj nj lm nk lp nl lt nm lx nn mb nf ng nh ni bi translated">Grafana:分析和可视化 web 应用程序</li></ul><div class="mc md gp gr me mf"><a href="https://levelup.gitconnected.com/do-you-pay-too-much-for-your-network-contract-e768e489b0bb" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd io gy z fp mk fr fs ml fu fw im bi translated">你为你的网络合同支付太多吗？</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">你也是那些为家里网速慢而苦恼的人之一吗？这篇文章可以帮助你！</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="mo l"><div class="oh l mq mr ms mo mt km mf"/></div></div></a></div><p id="58a0" class="pw-post-body-paragraph lg lh in li b lj mv jo ll lm mw jr lo lp mx lr ls lt my lv lw lx mz lz ma mb ig bi translated">这里显示了所需的<code class="fe oa ob oc od b">docker-compose.yml</code>:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="8c90" class="pw-post-body-paragraph lg lh in li b lj mv jo ll lm mw jr lo lp mx lr ls lt my lv lw lx mz lz ma mb ig bi translated">版本为<code class="fe oa ob oc od b">2</code>的<code class="fe oa ob oc od b">docker-compose.yml</code>定义了两个服务。对于这两种服务，都使用关键字<code class="fe oa ob oc od b">ports</code>来将容器的端口转发到容器的本地端口，就像使用<code class="fe oa ob oc od b">-p</code>标志时一样。此外，容器所需的环境变量用关键字<code class="fe oa ob oc od b">environment</code>设置，就像用<code class="fe oa ob oc od b">-e</code>设置<code class="fe oa ob oc od b">docker run</code>一样。作为<code class="fe oa ob oc od b">depends_on</code>的值<code class="fe oa ob oc od b">influxdb</code>的结果，当服务<code class="fe oa ob oc od b">influxdb</code>准备好时，服务<code class="fe oa ob oc od b">grafana</code>开始。为了持久存储，需要使用数据卷。</p><h1 id="888d" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">结论</h1><p id="f2e7" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">本文展示了 Docker Compose 如何用于处理多容器设置。<code class="fe oa ob oc od b">.yml</code>中的定义足以轻松管理设置。因此，使用几乎相同的关键字，就像使用命令<code class="fe oa ob oc od b">docker start</code>一样。</p><p id="13dd" class="pw-post-body-paragraph lg lh in li b lj mv jo ll lm mw jr lo lp mx lr ls lt my lv lw lx mz lz ma mb ig bi translated">更多关于 Docker Compose 的细节可以在<a class="ae oe" href="https://docs.docker.com/compose/compose-file/" rel="noopener ugc nofollow" target="_blank">这里</a>找到</p><p id="d317" class="pw-post-body-paragraph lg lh in li b lj mv jo ll lm mw jr lo lp mx lr ls lt my lv lw lx mz lz ma mb ig bi translated">查看本系列的下一部分:</p><div class="mc md gp gr me mf"><a rel="noopener  ugc nofollow" target="_blank" href="/introduction-to-docker-part-4-c487ebf4bdaf"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd io gy z fp mk fr fs ml fu fw im bi translated">Docker 简介—第 4 部分</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">如果你认为你知道关于 Docker 的一切，你应该看看这些资源！</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">blog.devgenius.io</p></div></div><div class="mo l"><div class="oi l mq mr ms mo mt km mf"/></div></div></a></div></div><div class="ab cl oj ok hr ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="ig ih ii ij ik"><p id="2378" class="pw-post-body-paragraph lg lh in li b lj mv jo ll lm mw jr lo lp mx lr ls lt my lv lw lx mz lz ma mb ig bi translated">如果你觉得这篇文章和内容有用，请与你的朋友分享，留着以后看，并留下你的👏甚至是 5️⃣0️⃣</p><p id="30e9" class="pw-post-body-paragraph lg lh in li b lj mv jo ll lm mw jr lo lp mx lr ls lt my lv lw lx mz lz ma mb ig bi translated">如果你对软件开发和 IT 领域的其他话题感兴趣，请跟我来💯</p></div></div>    
</body>
</html>