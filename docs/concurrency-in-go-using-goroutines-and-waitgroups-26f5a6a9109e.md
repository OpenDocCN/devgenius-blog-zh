# Go 中的并发性—使用 Goroutines 和 WaitGroups

> 原文：<https://blog.devgenius.io/concurrency-in-go-using-goroutines-and-waitgroups-26f5a6a9109e?source=collection_archive---------2----------------------->

![](img/1755d15e01b3133c765290a2b5d5dd74.png)

这是我每周系列*学习围棋*的第十一篇。上周我谈到了在围棋中[排序数据。本周我将讨论 Go 中的并发性是如何工作的。在我真正深入到并发这个主题之前，我觉得我需要区分一下并发和并行，因为它们经常被混淆。我还将解释一些允许我们使用并发性的 Go 语言。这些部分是 Go 例程和 Go 语句。](https://www.martincartledge.io/sorting-data-in-go/)

# 并发

> 一个程序的各个部分不按顺序或按部分顺序运行(执行)而不影响最终结果的能力

*   设计用于同时处理多个任务
*   能够同时在多项任务上取得进展，但不能同时进行*和*
*   可以和 1 核 CPU 一起工作；但是，系统决定何时开始每项任务
*   跨共享变量正确实现所需的微妙之处使得并发变得困难

# 平行

> 同时执行多项计算的能力

*   旨在同时完成多项任务
*   能够在多核 CPU 中执行多项任务
*   必须拥有多核 CPU

# Go 中的并发性

*   共享值在[通道](https://gobyexample.com/channels)上传递
*   从不在单独的执行线程上共享
*   不是通过共享内存来交流，而是通过交流来共享内存

# 围棋套路

*   [多路复用](https://en.wikipedia.org/wiki/Multiplexing)
*   与函数或方法一起使用
*   与`go`关键字一起使用

# Go 语句

*   在同一个地址空间内，作为控制或 Go 例程的独立并发线程，从函数调用的执行开始
*   必须是函数或方法调用
*   如果函数有返回值，那么当函数完成时，返回值将被丢弃

在我们开始讨论如何在 Go 中使用*并发*之前，我想我们应该讨论一下在 Go 中编写*并发*代码的几个要点。其中几个支柱是 *Goroutines* 和*频道*

# 戈鲁廷斯

> *一个轻量级的执行线程*

那么，什么是 Goroutine？我为什么要关心它们？以下是一些需要考虑的事项:

*   Goroutines 是非阻塞的(*异步*)
*   由于是异步的，多个 goroutines 可以并发运行*(多个片段同时运行，不会影响最终结果)*
*   *如果你想等你的 *Goroutine* 完成后再继续，你可以使用一个 *WaitGroup* (我们将在后面的文章中介绍)*

*让我们看一个使用传统函数(阻塞)和一些 *Goroutines* (非阻塞)的例子，以更好地说明它们在我们的 Go 代码中的位置*

*让我们回顾一下正在发生的事情:*

> **快速提示:我们正在导入* `*time*` *包，因为我们需要等待一秒钟，以便让我们的* Goroutines *完成。记住，他们不是阻塞(同步)；因此，我们需要*等待*他们完成计算。**

*我们导入将在本例中使用的`time`包，只是为了等待我们的 *Goroutines* 完成。我发现使用等待组更加普遍，我们将在后面的文章中讨论这些*

*接下来，我们创建两个函数，`countToFive`和`countToThree`，这两个函数都需要一个类型为`string`的参数`wasCalledBy`。*

*用`wasCalledBy`参数调用我们的 *Goroutine* 将有助于说明 Go 如何执行这些*Go routine**

*在`func` `main`内部，我直接调用`countToFive`函数，没有使用 *Goroutine**

*正如论点所说，我没有使用`go`关键字并创建一个*go routine*；因此，这段代码将是同步的，并阻塞我们的执行线程*

*在下一行，我创建了一个 *Goroutine* 。通过调用同一个函数并将关键字`go`放在函数标识符的前面，我很容易做到这一点*

*接下来，我通过将关键字`go`放在函数标识符前面来启动另一个 *Goroutine* 。*

*为了确保我们的 *Goroutines* 完成，我们正在使用`time`包以便让*休眠*一秒钟。*

*您希望在我们的日志中看到什么？你希望这些 *Goroutines* 以什么顺序运行？*

*输出可能会让你吃惊，但是，我希望它能阐明 *Goroutines* 能给你的一些力量。*

*前 5 行不应该让你感到惊讶，我们正在调用一个没有使用 *Goroutine* 的函数；因此，它以同步(阻塞)方式运行。*

*然而，接下来的几行应该会引起一些人的注意。您是否注意到我们的`countToThree`函数在`countToFive`之前记录了一个项目？*

*这就是 T21 的力量。Go 运行时允许我们编写能够以并发方式执行的代码。*

# *等待组*

*使用 Go 时，使用 *WaitGroups* 等待多个 *Goroutines* 结束是常见的做法。 *WaitGroup* 是*型*，是`sync`包的一部分。*

**WaitGroups* 附带了一些您会经常使用的功能。其中最重要的是`Add`和`Done`。让我来告诉你如何使用这些。*

*让我们一行一行地回顾一下正在发生的事情:*

*正如我前面提到的，由于 *WaitGroup* 是从`sync`包中调用的，我们需要确保导入它*

*接下来，我们用标识符`countRoutine`创建一个函数，它有两个参数:`string`类型的`upTo`和指向`sync.WaitGroup`的指针`wg`*

> **注意:* WaitGroups *只能作为指针*传递给函数*

*在这个函数内部，我们创建了一个 for 循环，并进行迭代，直到达到传递给函数的`upTo`值。为了让*等待组*知道 *Goroutine* 已经完成，我们运行`Done()`函数*

*然后我们创建一个标识符为`count`的函数，带有一个类型为`int`的参数`upTo`。我们在这个函数中有相同的 for 循环，唯一的区别是我们没有使用 *WaitGroup* ，因为这是*而不是*一个 *Goroutine**

*在`main`函数内部，我们使用`var`关键字创建一个变量，并给这个变量赋予类型`sync.WaitGroup`的标识符`wg`*

*为了告诉 Go 运行时关于我们的 *WaitGroup* 我们必须添加一个。我们可以通过使用`Add()`函数轻松做到这一点，该函数接受一个类型为`int`的参数，该参数表示您想要添加多少个*等待组*。对于这个例子，我们只有一个 *Goroutine* ，所以我们将只添加一个:*

*接下来，我们使用`go`关键字来启动`countRoutine`作为 *Goroutine* ，并传递`10`作为我们的`upTo`参数，传递 *WaitGroup* 指针(`&wg`作为我们的`wg`参数*

*我们调用`count`函数，它将是一个同步的阻塞函数*

*这可能是需要记住的最重要的部分之一。正如你看到的，我们在`main`的最后一行调用了一个`Wait()`函数。这个函数让 Go 运行时知道我们还有 *Goroutines* 没有完成，并让我们的程序继续运行。*

*正如我前面提到的，我们让 Go 运行时知道我们的 *Goroutine* 已经完成的方法是在我们的 *Goroutine* 的末尾调用`Done()`函数。一旦我们这样做了，Go 运行时知道它可以退出程序。*

# *概括起来*

*通过使用 *Goroutines* 的能力，配合 *WaitGroups* 的帮助，我们可以在 Go 中编写*并发*代码。很酷吧。我把这个话题分成了两部分，因为我还有很多关于编写并发 Go 代码和 Go 提供给我们使用的工具的内容要向你展示。下周我将谈论*通道、互斥和竞争条件*。到时候见！*