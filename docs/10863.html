<html>
<head>
<title>Exploring the Capabilities of Prolog: Logical Deduction and Backtracking in “Nani Search”</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索 Prolog 的能力:在“纳尼亚搜索”中的逻辑演绎和回溯</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/exploring-the-capabilities-of-prolog-logical-deduction-and-backtracking-in-nani-search-35be6a4d916d?source=collection_archive---------10-----------------------#2022-12-04">https://blog.devgenius.io/exploring-the-capabilities-of-prolog-logical-deduction-and-backtracking-in-nani-search-35be6a4d916d?source=collection_archive---------10-----------------------#2022-12-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/255d1e700b96bd190ff7749cfcb54bac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1O0RTWlZGD1VxKwmD81Ulw.jpeg"/></div></div></figure><h1 id="6dc6" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">什么是“纳尼搜索”？</h1><p id="4810" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">游戏“纳尼搜索”是一个简单的基于文本的冒险游戏，用 Prolog 实现。该游戏通过输入简单英语句子的命令来控制玩家的动作，玩家是一个三岁的孩子，试图找到他们的安全毯(“纳尼”)。玩家可以在房间之间移动，观察周围环境，拿取和放下物品，吃东西，并以各种方式与环境互动。当玩家找到纳尼或者放弃时，游戏结束。要理解这个游戏，你必须知道 Prolog 编程的基础。你可以在这里看到完整的游戏:</p><div class="lr ls gp gr lt lu"><a href="https://www.amzi.com/AdventureInProlog/appendix.php" rel="noopener  ugc nofollow" target="_blank"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd io gy z fp lz fr fs ma fu fw im bi translated">阿姆兹！in Prolog 教程中的冒险</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">本附录包含书中描述的四个程序的示例版本。这些是冒险游戏(纳尼…</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">www.amzi.com</p></div></div></div></a></div><h1 id="8a95" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">游戏逻辑</h1><p id="66da" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">该游戏使用一系列 Prolog 谓词来实现，这些谓词定义了控制游戏世界和玩家可以采取的行动的规则和事实。序言代码定义了控制游戏世界的规则和事实，以及玩家可以采取的行动。该程序使用一系列谓词来表示游戏中可用的不同房间、对象和动作。</p><p id="0cfb" class="pw-post-body-paragraph kt ku in kv b kw md ky kz la me lc ld le mf lg lh li mg lk ll lm mh lo lp lq ig bi translated">程序从定义<code class="fe mi mj mk ml b">main</code>谓词开始，它充当游戏的入口点。<code class="fe mi mj mk ml b">main</code>谓词调用<code class="fe mi mj mk ml b">nani_search</code>谓词，后者初始化一些动态事实，然后打印游戏简介。然后它调用<code class="fe mi mj mk ml b">command_loop</code>谓词，该谓词反复提示玩家输入命令并执行相应的动作，直到玩家要么找到 Nani，要么退出游戏。</p><p id="a928" class="pw-post-body-paragraph kt ku in kv b kw md ky kz la me lc ld le mf lg lh li mg lk ll lm mh lo lp lq ig bi translated"><code class="fe mi mj mk ml b">command_loop</code>谓词使用<code class="fe mi mj mk ml b">repeat</code>控制结构重复读取来自玩家的命令，并调用<code class="fe mi mj mk ml b">do/1</code>谓词来执行命令。<code class="fe mi mj mk ml b">do/1</code>谓词使用一系列子句将玩家的命令与执行动作的相应谓词匹配起来。比如玩家输入命令<code class="fe mi mj mk ml b">take(X)</code>，<code class="fe mi mj mk ml b">do/1</code>谓词会调用<code class="fe mi mj mk ml b">take/1</code>谓词来执行取物的动作。</p><p id="abb0" class="pw-post-body-paragraph kt ku in kv b kw md ky kz la me lc ld le mf lg lh li mg lk ll lm mh lo lp lq ig bi translated"><code class="fe mi mj mk ml b">do/1</code>谓词还包括用于<code class="fe mi mj mk ml b">nshelp</code>、<code class="fe mi mj mk ml b">hint</code>、<code class="fe mi mj mk ml b">inventory</code>、<code class="fe mi mj mk ml b">quit</code>、<code class="fe mi mj mk ml b">look</code>、<code class="fe mi mj mk ml b">turn_on</code>、<code class="fe mi mj mk ml b">turn_off</code>和<code class="fe mi mj mk ml b">look_in</code>谓词的子句，这些子句为玩家提供附加信息和功能。</p><p id="8ebf" class="pw-post-body-paragraph kt ku in kv b kw md ky kz la me lc ld le mf lg lh li mg lk ll lm mh lo lp lq ig bi translated">当玩家找到纳尼(通过拿走它)或者退出游戏时，游戏结束。</p><p id="8eea" class="pw-post-body-paragraph kt ku in kv b kw md ky kz la me lc ld le mf lg lh li mg lk ll lm mh lo lp lq ig bi translated">如果你难以理解谓词和对象的概念，请随意查看我们关于 prolog 基础的文章。</p><div class="lr ls gp gr lt lu"><a href="https://pipsworld.medium.com/introduction-to-prolog-a-programming-language-for-artificial-intelligence-320b75455381" rel="noopener follow" target="_blank"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd io gy z fp lz fr fs ma fu fw im bi translated">Prolog 介绍:一种人工智能编程语言</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">了解 Prolog，这是一种用于开发人工智能应用程序的编程语言，可以处理不确定或不完整的…</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">pipsworld.medium.com</p></div></div><div class="mn l"><div class="mo l mp mq mr mn ms jt lu"/></div></div></a></div><h1 id="0362" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">入口点</h1><p id="743d" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">代码的第一部分定义了游戏的主入口点，即<code class="fe mi mj mk ml b">main</code>谓词:</p><pre class="mt mu mv mw gt mx ml my bn mz na bi"><span id="f920" class="nb jw in ml b be nc nd l ne nf">main:- nani_search.       % main entry point</span></pre><p id="9bba" class="pw-post-body-paragraph kt ku in kv b kw md ky kz la me lc ld le mf lg lh li mg lk ll lm mh lo lp lq ig bi translated">这个谓词简单地调用<code class="fe mi mj mk ml b">nani_search</code>谓词，它初始化一些动态事实，然后打印游戏的简要介绍:</p><pre class="mt mu mv mw gt mx ml my bn mz na bi"><span id="6f4d" class="nb jw in ml b be nc nd l ne nf">nani_search:-<br/>  init_dynamic_facts,     % predicates which are not compiled<br/>write('NANI SEARCH - A Sample Adventure Game'),nl,<br/>  write('Copyright (C) Amzi! inc. 1990-2010'),nl,<br/>  write('No rights reserved, use it as you wish'),nl,<br/>  nl,<br/>  ...</span></pre><h1 id="9600" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">命令循环</h1><p id="94e0" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">介绍完后，<code class="fe mi mj mk ml b">nani_search</code>谓词调用<code class="fe mi mj mk ml b">command_loop</code>谓词，这是游戏的主循环:</p><pre class="mt mu mv mw gt mx ml my bn mz na bi"><span id="593d" class="nb jw in ml b be nc nd l ne nf">command_loop:-<br/>  repeat,<br/>  get_command(X),<br/>  do(X),<br/>  (nanifound; X == quit).</span></pre><p id="5dd5" class="pw-post-body-paragraph kt ku in kv b kw md ky kz la me lc ld le mf lg lh li mg lk ll lm mh lo lp lq ig bi translated"><code class="fe mi mj mk ml b">command_loop</code>谓词使用<code class="fe mi mj mk ml b">repeat</code>控制结构重复读取来自使用<code class="fe mi mj mk ml b">get_command/1</code>谓词的玩家的命令，然后使用<code class="fe mi mj mk ml b">do/1</code>谓词执行该命令。<code class="fe mi mj mk ml b">do/1</code>谓词使用一系列子句将玩家的命令与执行动作的相应谓词匹配起来。比如玩家输入命令<code class="fe mi mj mk ml b">take(X)</code>，<code class="fe mi mj mk ml b">do/1</code>谓词会调用<code class="fe mi mj mk ml b">take/1</code>谓词来执行取物的动作。</p><pre class="mt mu mv mw gt mx ml my bn mz na bi"><span id="736a" class="nb jw in ml b be nc nd l ne nf">do(goto(X)):-goto(X),!.<br/>do(nshelp):-nshelp,!.<br/>do(hint):-hint,!.<br/>do(inventory):-inventory,!.<br/>do(take(X)):-take(X),!.<br/>do(drop(X)):-drop(X),!.<br/>do(eat(X)):-eat(X),!.<br/>do(look):-look,!.<br/>do(turn_on(X)):-turn_on(X),!.<br/>do(turn_off(X)):-turn_off(X),!.<br/>do(look_in(X)):-look_in(X),!.<br/>do(quit):-quit,!.</span></pre><p id="b12e" class="pw-post-body-paragraph kt ku in kv b kw md ky kz la me lc ld le mf lg lh li mg lk ll lm mh lo lp lq ig bi translated"><code class="fe mi mj mk ml b">command_loop</code>谓词还包括一个检查，看看玩家是否找到了纳尼或者退出了游戏。如果这些条件中的任何一个为真，<code class="fe mi mj mk ml b">command_loop</code>谓词将终止，游戏将结束。</p><p id="64b3" class="pw-post-body-paragraph kt ku in kv b kw md ky kz la me lc ld le mf lg lh li mg lk ll lm mh lo lp lq ig bi translated"><em class="mm">除了</em> <code class="fe mi mj mk ml b"><em class="mm">command_loop</em></code> <em class="mm">谓词，代码还包括许多其他谓词，这些谓词定义了游戏世界的规则和事实以及玩家可以采取的行动。</em></p><p id="7c90" class="pw-post-body-paragraph kt ku in kv b kw md ky kz la me lc ld le mf lg lh li mg lk ll lm mh lo lp lq ig bi translated">例如，<code class="fe mi mj mk ml b">goto/1</code>、<code class="fe mi mj mk ml b">take/1</code>、<code class="fe mi mj mk ml b">drop/1</code>、<code class="fe mi mj mk ml b">eat/1</code>、<code class="fe mi mj mk ml b">look</code>、<code class="fe mi mj mk ml b">turn_on/1</code>、<code class="fe mi mj mk ml b">turn_off/1</code>和<code class="fe mi mj mk ml b">look_in/1</code>谓词定义了玩家在游戏中可以采取的动作。这些谓词使用事实和规则的组合来确定对玩家动作的适当响应，并向玩家打印一条描述动作结果的消息。</p><pre class="mt mu mv mw gt mx ml my bn mz na bi"><span id="c003" class="nb jw in ml b be nc nd l ne nf">% goto - move the player to a new room<br/>%<br/>%  The "is_a" structure relates rooms to their types and<br/>%  possible exits.  The dynamic database is used to store<br/>%  the room type and exit information for each room as it<br/>%  is encountered.<br/>goto(X):-<br/>  location(here),<br/>  can_go(here,X),<br/>  retract(location(here)),<br/>  asserta(location(X)),<br/>  look.<br/>goto(_):-<br/>  write('You can''t go that way.'),nl.<br/>% can_go - can the player go in that direction<br/>%<br/>%  The rule expresses the "is_a" relationship between rooms<br/>%  and the directions you can go in them.<br/>can_go(R,X):-<br/>  room_exit(R,X),<br/>  write('You go '),write(X),write('.'),nl.<br/>% take - take an object<br/>%<br/>%  The rule expresses the relationship between the objects<br/>%  and the rooms they are in.<br/>take(X):-<br/>  here(R),<br/>  in_</span></pre><h1 id="d1b0" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">解释其他谓词</h1><p id="b812" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">在<code class="fe mi mj mk ml b">command_loop</code>谓词之后，代码定义了一系列谓词，代表玩家在游戏中可以采取的不同动作。例如，<code class="fe mi mj mk ml b">look</code>谓词描述了玩家的当前位置以及该位置中存在的对象:</p><pre class="mt mu mv mw gt mx ml my bn mz na bi"><span id="e05f" class="nb jw in ml b be nc nd l ne nf">look:-<br/>  here(X),<br/>  describe(X),<br/>  nl,<br/>  write('You see:'),nl,<br/>  list_things(X),<br/>  nl.</span></pre><p id="1baa" class="pw-post-body-paragraph kt ku in kv b kw md ky kz la me lc ld le mf lg lh li mg lk ll lm mh lo lp lq ig bi translated"><code class="fe mi mj mk ml b">take/1</code>谓词允许玩家从当前位置拿走一个物体:</p><pre class="mt mu mv mw gt mx ml my bn mz na bi"><span id="088d" class="nb jw in ml b be nc nd l ne nf">take(X):-<br/>  can_take(X),<br/>  retract(here(X)),<br/>  assert(have(X)),<br/>  write('taken'),nl.</span></pre><p id="6cdd" class="pw-post-body-paragraph kt ku in kv b kw md ky kz la me lc ld le mf lg lh li mg lk ll lm mh lo lp lq ig bi translated"><code class="fe mi mj mk ml b">drop/1</code>谓词允许玩家放下他们携带的物体:</p><pre class="mt mu mv mw gt mx ml my bn mz na bi"><span id="ad33" class="nb jw in ml b be nc nd l ne nf">drop(X):-<br/>  have(X),<br/>  retract(have(X)),<br/>  assert(here(X)),<br/>  write('done'),nl.</span></pre><p id="41bd" class="pw-post-body-paragraph kt ku in kv b kw md ky kz la me lc ld le mf lg lh li mg lk ll lm mh lo lp lq ig bi translated">这些谓词只是玩家在游戏中可以采取的动作的几个例子。完整的代码包括更多的谓词，这些谓词定义了游戏的世界和玩家可以采取的行动。</p><p id="43d2" class="pw-post-body-paragraph kt ku in kv b kw md ky kz la me lc ld le mf lg lh li mg lk ll lm mh lo lp lq ig bi translated">除了定义玩家可以采取的动作的谓词之外，代码还包括一系列定义游戏世界以及其中存在的对象和位置的谓词。例如，<code class="fe mi mj mk ml b">locations</code>谓词定义了游戏中可用的房间和其他位置:</p><pre class="mt mu mv mw gt mx ml my bn mz na bi"><span id="6f98" class="nb jw in ml b be nc nd l ne nf">locations:-<br/>  livingroom,<br/>  kitchen,<br/>  yard,<br/>  garden,<br/>  bedroom,<br/>  hall,<br/>  attic.</span></pre><p id="c3a6" class="pw-post-body-paragraph kt ku in kv b kw md ky kz la me lc ld le mf lg lh li mg lk ll lm mh lo lp lq ig bi translated">这些位置中的每一个都由一个单独的谓词定义，该谓词描述了位置和其中存在的对象。例如，<code class="fe mi mj mk ml b">livingroom</code>谓词定义了起居室的位置和那里的对象:</p><pre class="mt mu mv mw gt mx ml my bn mz na bi"><span id="0b47" class="nb jw in ml b be nc nd l ne nf">livingroom:-<br/>  assert(here(chair)),<br/>  assert(here(table)),<br/>  assert(here(sofa)),<br/>  assert(here(rug)),<br/>  assert(here(lamp)),<br/>  assert(here(television)),<br/>  assert(here(remote_control)),<br/>  assert(here(book)),<br/>  assert(here(magazine)).</span></pre><p id="f0ba" class="pw-post-body-paragraph kt ku in kv b kw md ky kz la me lc ld le mf lg lh li mg lk ll lm mh lo lp lq ig bi translated">这些谓词用于定义游戏的世界以及其中可用的对象和位置。当玩家采取行动时，谓词用于确定该行动的后果，并相应地更新游戏的世界。</p><p id="3823" class="pw-post-body-paragraph kt ku in kv b kw md ky kz la me lc ld le mf lg lh li mg lk ll lm mh lo lp lq ig bi translated">总的来说，<em class="mm">纳尼搜索</em>是一个简单的基于文本的冒险游戏的完整实现。代码定义了管理游戏世界的规则和事实以及玩家可以采取的行动，并使用这些规则和事实来允许玩家探索游戏世界并与之互动。</p><h1 id="d6a5" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">我们如何实现这一点？</h1><p id="de48" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated"><em class="mm">要在 Prolog 中创建一个类似“纳尼搜索”的游戏，可以使用以下步骤:</em></p><ol class=""><li id="115c" class="ng nh in kv b kw md la me le ni li nj lm nk lq nl nm nn no bi translated">定义支配游戏世界的事实和规则，以及玩家可以采取的行动。这可以包括关于游戏中的位置、游戏中存在的对象以及这些位置和对象之间的关系的事实。它还可以包括指定玩家行为后果的规则，例如移动到一个新的位置或拿走一个对象。</li><li id="b170" class="ng nh in kv b kw np la nq le nr li ns lm nt lq nl nm nn no bi translated"><strong class="kv io">实现游戏的主入口。</strong>这可以包括任何必要的设置，例如初始化动态事实或打印欢迎消息。它还可以包括主游戏循环，该循环提示玩家输入命令，并使用您在步骤 1 中定义的谓词处理该命令。</li><li id="314f" class="ng nh in kv b kw np la nq le nr li ns lm nt lq nl nm nn no bi translated"><strong class="kv io">实现处理玩家动作的谓词。这些谓词应该使用您在步骤 1 中定义的事实和规则进行逻辑推理，并确定玩家行为的后果。这些谓词可以包括诸如移动到一个新位置、拿走一个对象或查看玩家周围环境之类的动作。</strong></li><li id="b73f" class="ng nh in kv b kw np la nq le nr li ns lm nt lq nl nm nn no bi translated"><strong class="kv io">测试游戏以确保它的行为符合预期。</strong>这可以包括手动玩游戏，并验证游戏是否正确响应玩家的动作。它还可以包括运行自动化测试来验证游戏在不同场景下的行为。</li></ol><p id="f4ec" class="pw-post-body-paragraph kt ku in kv b kw md ky kz la me lc ld le mf lg lh li mg lk ll lm mh lo lp lq ig bi translated">总的来说，在 Prolog 中创建一个类似于“Nani Search”的游戏需要定义控制游戏世界的事实和规则以及玩家可以采取的行动，实现主游戏循环和处理玩家行动的谓词，并测试游戏以确保其行为符合预期。</p><h1 id="a922" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">除了基于文本的游戏，我可以用“纳尼搜索”和 Prolog 上的这些信息做什么？</h1><p id="e23f" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">除了基于文本的游戏，Prolog 还有许多其他可能的应用，如自然语言处理、自动推理和人工智能。</p><p id="77cb" class="pw-post-body-paragraph kt ku in kv b kw md ky kz la me lc ld le mf lg lh li mg lk ll lm mh lo lp lq ig bi translated">Prolog 在基于文本的游戏之外的一个可能应用是自然语言处理。<strong class="kv io"> Prolog 对逻辑推理和回溯的支持使其非常适合于实现能够分析和理解自然语言输入的算法。</strong>例如，Prolog 程序可用于处理和理解以自然语言表达的命令或问题，例如在“Nani Search”中使用的那些。</p><p id="0afc" class="pw-post-body-paragraph kt ku in kv b kw md ky kz la me lc ld le mf lg lh li mg lk ll lm mh lo lp lq ig bi translated">Prolog 的另一个可能的应用是自动推理。例如，这可以用于实现专家系统，该专家系统可以对知识领域进行推理，并基于该知识提供建议或推荐。</p><p id="1c7b" class="pw-post-body-paragraph kt ku in kv b kw md ky kz la me lc ld le mf lg lh li mg lk ll lm mh lo lp lq ig bi translated">最后，它非常适合实现人工智能算法。例如，这些算法可以用来实现智能代理，这些智能代理可以对其环境进行推理，并基于该推理做出决策。Prolog 处理复杂数据结构和执行递归计算的能力使其非常适合于实现广泛的人工智能算法，包括搜索算法、规划算法和机器学习算法。</p><p id="ae4b" class="pw-post-body-paragraph kt ku in kv b kw md ky kz la me lc ld le mf lg lh li mg lk ll lm mh lo lp lq ig bi translated">你准备好释放 Prolog 的力量了吗？Prolog 支持逻辑推理和回溯，是实现智能算法和解决复杂问题的强大工具。尝试“Nani Search”游戏或其他 Prolog 教程和示例，看看您可以用这种通用语言创建什么。现在就开始使用 Prolog，亲自发现它的强大功能！</p></div></div>    
</body>
</html>