<html>
<head>
<title>TCP Life Cycle (Demo using Wireshark)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TCP 生命周期(使用 Wireshark 演示)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/tcp-life-cycle-demo-using-wireshark-715171eeceb6?source=collection_archive---------4-----------------------#2022-06-29">https://blog.devgenius.io/tcp-life-cycle-demo-using-wireshark-715171eeceb6?source=collection_archive---------4-----------------------#2022-06-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="6b57" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">读者们好，</p><p id="6a8c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 OSI 模型中有一层处理协议，TCP，UDP 等等。接下来我们可以找到应用层。当我们编写 http 应用程序时，我们的 HTTP 应用程序运行在第七层。但是 HTTP 建立在 TCP 之上。让我们看看这些到底是如何工作的。</p><h2 id="46d2" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">什么是 TCP？</h2><p id="2b8f" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">传输控制协议(TCP)是互联网协议族的主要协议之一。它起源于最初的网络实施，其中它补充了互联网协议(IP)。</p><h2 id="037a" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">TCP 报头格式？</h2><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/0643eeccf32f8790a1834064a10b39de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XgSh0hJVhAW_YLvjhi9Dxg.png"/></div></div></figure><p id="41a3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里我们可以看到一些重要的部分，如<strong class="jm io">源端口</strong>和<strong class="jm io">目的端口。</strong>有<strong class="jm io">序列号</strong>和<strong class="jm io">确认号</strong>也有 6 个标志被调用</p><p id="9cd0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">URG —紧急<br/> ACK —确认<br/> PSH —按下<br/> RST —复位<br/> SYN — Sync <br/> FIN —完成</p><p id="d297" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">还有一个<strong class="jm io">窗口大小。我们需要看看这些联系到底是如何运作的。</strong></p><h2 id="d91d" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">TCP 三次握手</h2><p id="9771" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated"><strong class="jm io">三次握手</strong>或 TCP 三次握手是在 TCP/IP 网络中用于在服务器和客户端之间建立连接的过程。这是一个包含三个步骤的过程，要求客户端和服务器在真正的数据通信过程开始之前交换同步和确认数据包。</p><p id="6433" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">三向握手过程的设计方式是两端同时帮助您发起、协商和分离 TCP 套接字连接。它允许您同时双向传输多个 TCP 套接字连接。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi ls"><img src="../Images/9e09d483b81c8dfee7660bd3ba7c7584.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EUMxTNE8ohOMw1BX41BC7Q.png"/></div></div></figure><p id="74b3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在第一种情况下<strong class="jm io">客户端发送消息 SYN </strong>作为建立连接的第一个请求。其中 SYN 设置为 1</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/7a5ac53bfe3a02d962136de6f4ef5c31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*A-LwfU_1IYRWKUujkHb7mA.png"/></div></figure><p id="8291" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在第二个实例<strong class="jm io">中，服务器发送 ACK 和 SYN </strong>作为回复消息，其中 ACK 和 SYN 设置为 1</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/b3295988eb0ff049dbc248e0ee770add.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*MzWFiH09luP6PMRedaosCw.png"/></div></figure><p id="2303" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在第三种情况下<strong class="jm io">客户端发送 ACK </strong>作为回复消息，其中 ACK 设置为 1。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/a7526e96d535f630e6857564f719c9f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*m8IXPi7LqUrRkspMjYelJA.png"/></div></figure><p id="61a8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在连接成功建立。<strong class="jm io">轰！！！</strong></p><p id="d71d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有一个可选的叫做<strong class="jm io">的窗口更新。</strong>无论是客户端还是服务器端进行通信时，他们的通信窗口大小。在我的缓冲区失败之前可以发送多少字节。一旦你的应用程序消耗了缓冲区，缓冲区就会获得一些空间来接收来自另一端的消息。</p><h2 id="8a67" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">它是如何传递信息的</h2><p id="d9eb" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">连接建立后，服务器发送一个名为“Hello Client”的消息并断开连接。</p><p id="d8d5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下图解释了客户端和服务器如何建立连接和断开连接。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lw"><img src="../Images/731f5407b019f5b78d335bb411d885d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fXk63C8cowyBvDNx5WfbIQ.png"/></div></div></figure><h2 id="6a38" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">TCP 如何实际工作</h2><p id="b417" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">打开 Wireshark 后，选择环回接口。接下来我们有一个代码节点 js，它有客户端和服务器文件。</p><p id="3fcd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae lx" href="https://github.com/BlackHawk1212/learn-with-krish/blob/main/TCP_IP_Demo/client.js" rel="noopener ugc nofollow" target="_blank">在 main black hawk 1212/learn-with-krish(github.com)的 learn-with-krish/client . js</a></p><p id="d3e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在客户端连接到服务器上的端口号 42181。当断开来临时，它将断开。</p><p id="b1ce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">服务器文件</p><p id="6f23" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">【github.com】</p><p id="b238" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里我有运行端口号 42181 的服务器。当客户端连接时，说 Hello Client 并断开会话。</p><p id="993e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在运行代码之前，我们需要过滤端口 42181 中的流量。我们的做法是，<br/>在搜索栏中键入—<strong class="jm io"><em class="ly">TCP . port = = 42181<br/></em></strong>。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lz"><img src="../Images/794742d0857fdf4d097c451e73a7dcdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uhvzi1TH7182iKx_uM3csQ.png"/></div></div></figure><p id="e0a9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">之后，一旦我们首先运行代码，我们需要首先运行服务器，然后运行客户端。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi ma"><img src="../Images/f2025b6a9490bdfcc46da511eff04838.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dxgiGIpEGQFYNj7Mx81OSA.png"/></div></div></figure><p id="92d7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">启动服务器后，我们可以看到客户端和服务器在 Wireshark 中是如何相互连接的。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lz"><img src="../Images/794742d0857fdf4d097c451e73a7dcdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uhvzi1TH7182iKx_uM3csQ.png"/></div></div></figure><p id="8cba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">资源—<a class="ae lx" href="https://youtu.be/UpUd5zEUUgI" rel="noopener ugc nofollow" target="_blank">https://youtu.be/UpUd5zEUUgI</a></p></div></div>    
</body>
</html>