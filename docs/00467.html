<html>
<head>
<title>Insertion Sort Program in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的插入排序程序</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/insertion-sort-program-in-swift-31740a454573?source=collection_archive---------17-----------------------#2020-06-08">https://blog.devgenius.io/insertion-sort-program-in-swift-31740a454573?source=collection_archive---------17-----------------------#2020-06-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="bb36" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">作者将用Swift编程语言向你逐行解释插入程序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4e5ee494469ba9a95f299f4da62d98ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MRA6cpIYuqrLCDaIaUpKJQ.jpeg"/></div></div></figure><blockquote class="ku kv kw"><p id="a6fb" class="jk jl kx jm b jn jo jp jq jr js jt ju ky jw jx jy kz ka kb kc la ke kf kg kh ig bi translated">E <strong class="jm io">每次重复插入排序都会从输入数据中删除一个元素，并将其插入到已经排序的列表中的正确位置，直到没有输入元素存在。</strong></p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/576c8a2421f2ed9ba118dfc8b71b8cd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*X3bnbAg3hkhaqS5QCDOPpA.png"/></div></figure><p id="471c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第3行:- </strong>这里我们声明一个数组为<em class="kx"> arr </em>，里面有一些元素。</p><p id="0a32" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第6行:- </strong>现在我们从第二个索引开始遍历数组，因为在插入算法中我们认为数组的第一个元素是有序的。我们使用范围方法，从第二个索引开始，即从1到最后一个，使用数组方法计数。</p><p id="adb0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第7行:- </strong>这里我们创建一个常量键<em class="kx">存储数组的第二个元素。将<em class="kx">键</em>视为临时常量。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/576c8a2421f2ed9ba118dfc8b71b8cd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*X3bnbAg3hkhaqS5QCDOPpA.png"/></div></figure><p id="b9e0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第8行:- </strong>现在创建一个变量作为<em class="kx"> j </em>并给出一个比第I个元素小的值。这样做的原因是在数组中向后移动，并使用while循环比较ith元素和。</p><p id="6cb4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第9行:- </strong>这里给出了while循环的两个条件，首先是检查<em class="kx"> j </em>的值是否小于零，原因就像，它们应该是一个极限，这样while循环就会停止，因为数组的最小值可能是0。第二件事是比较元素。</p><p id="4a9e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第10行:- </strong>在检查了while循环中给出的条件后，如果这些条件为真，那么我们将在这一行进行移位。</p><p id="24c9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第11行:- </strong>这里我们减少了j的值，这样我们可以在数组中向后移动。</p><p id="6b14" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第13行:- 在这里，我们终于将元素定位到了正确的位置。</p><p id="65f3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第17行:- </strong>打印数组的最后一个排序元素。</p><p id="7ed0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是代码的全部解释，你如何在swift中为插入算法编码。值得注意的重要一点是，我们总是比较和转移，而不是交换。我们只是在正确的位置插入元素。</p></div></div>    
</body>
</html>