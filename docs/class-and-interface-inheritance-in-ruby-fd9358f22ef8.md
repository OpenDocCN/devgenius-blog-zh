# Ruby 中的类和接口继承

> 原文：<https://blog.devgenius.io/class-and-interface-inheritance-in-ruby-fd9358f22ef8?source=collection_archive---------13----------------------->

## Ruby 中不同类型的继承，何时使用它们，以及 Ruby 如何在方法查找路径中遵循继承链。

![](img/f16ecfae5265550183eba8bf53037e9d.png)

Edvard Alexander lvaag 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

面向对象编程中的继承是一个概念，指的是类从其他类继承行为的能力。然而，它不是双向继承。换句话说，一个类，一个子类，继承了另一个类，一个超类的行为；超类不从子类继承行为。

在 Ruby 中有两种类型的继承:类继承和接口继承。这两者同等重要，它们一起拓宽了我们为对象提供功能的能力，同时为我们的代码增加了简单性、灵活性和可伸缩性的好处。

# 类继承

当公共行为(方法)被提取到一个超类中，一个或多个子类从该超类中继承这些行为时，就创建了类继承。这意味着子类的对象可以调用超类中定义的方法，而不需要在子类中定义方法。我们可以把超类想象成一个方法库，当被继承时，它扩展了子类的功能；换句话说，一个子类不仅有其自身定义的功能，还有其超类的功能。指示类继承的语法很简单:当定义一个类时，我们在类名后使用`<`字符，后面是超类名。

例如，假设我们有一家餐馆，我们想要定义一个`Employee`超类，其中包含不同类型雇员的多个子类。下面是我们如何表明一个类`Host`是超类`Employee`的子类:

为了查看在上面的代码中继承是如何实现的，我们可以简单地在`Host`类的对象上调用`Employee`类的`clocked_in`方法。

为了进一步展示继承的实现和好处，我们可以给我们的例子增加一些复杂性。

如前所述，继承允许我们将公共行为提取到单个超类中。这意味着我们可以编写一次代码，然后根据需要在尽可能多的子类中重用相同的代码，而不必一次又一次地重写相同的代码。我们在上面的代码中从`Employee`超类的`clock_in`和`clock_out`方法中看到了这一点:我们已经定义了一次这些方法，并且可以从我们在它之后定义的任何子类中调用它们。如果没有继承，我们将不得不在每个需要这些行为的类中定义`clock_in`和`clock_out`方法。

此外，通过继承，我们仍然可以在子类中定义更多微调的行为，这些行为可能不适用于子类所继承的超类的所有子类。为了进一步阐述我们上面的例子，虽然每个员工都有能力在开始和结束一个班次时打卡上班和打卡下班，但是每个员工也有特定于该员工角色的行为。例如，服务器可以为来宾提供服务，而主机则不能。

在从一个公共超类继承行为的类中构造代码，使我们编写的代码具有很大的灵活性。有了这样的灵活性，我们可以很容易地重用提取到超类中的公共行为，同时仍然在需要的地方在子类中定义更具体的行为。例如，我们可以根据需要定义尽可能多的`Employee`类的子类——执行官、经理、营销人员、洗碗工等等——而不必重写和重复从`Employee`超类继承的任何行为。

但是，如果我们在多个子类之间有共同的行为，而不是所有的子类，那该怎么办呢？例如，假设服务器能够执行与主机相同的功能——记下客人的姓名、安排客人入座并给客人一份菜单。这是否意味着我们需要在两个类中定义所有这些行为？或者有没有办法将这些行为提取到一个共同的、可继承的位置？

第二种类型的继承——*接口*继承——允许我们这样做。

# 接口继承

在我们深入讨论接口继承之前，让我们继续我们的假想餐厅的思想实验。为了做到这一点，让我们假设一个`Server`类的对象能够执行许多与`Host`类的对象相同的功能，特别是与让客人入座相关的功能。例如，主机和服务器都能够记下客人的名字，安排客人入座，给客人一份菜单，并在客人入座时通知客人每日特色菜。然而，因为这些不是在`Employee`超类的所有子类中共享的行为，我们不希望这些行为在那个类中定义，然后被那些行为不适合的子类继承(比如厨师和服务员)。

让我们修改我们的代码，给我们的`Host`和`Server`类这些新的行为。

这是一大堆重复的代码，这让我们不禁要问:有没有一种方法可以将代码提取到一个公共的位置，这样`Host`和`Server`类就可以继承那些行为，就像我们从`Employee`类继承类一样？继承使我们能够做到这一点。不同之处在于，这些行为可以从*模块*中继承，而不是从超类中继承。

模块类似于类，因为它是相关行为的集合；然而，一个关键的区别是对象*不能从模块中实例化。虽然类为从类实例化的对象的状态和行为提供了蓝图，但模块只是向包含该模块的类添加功能。作为行为的集合，一个模块可以通过调用`include`方法“混合”到一个类中，后面跟着模块的名称。当一个模块以这种方式使用时，它被恰当地称为 *mixin 模块*。除了使用关键字`module`之外，模块的定义类似于类。*

让我们回到上面的例子，将`Host`和`Server`类共有的方法提取到一个名为`Hostable`的模块中。

正如您在上面的示例中所看到的，我们已经删除了与安排游客入座相关的所有功能，并将其提取到一个名为`Hostable`的模块中。然后，我们通过调用`include`方法，在`Hostable`模块中混合使用`Host`和`Server`类中的功能。事实上，我们可以包含尽可能多的适合于所讨论的类的模块。例如，假设主人和服务员都可以在客人生日时唱生日歌，但服务员和厨师不行。我们可以在一个`Singable`模块中定义方法，然后将该模块包含在两个类中，而不是在`Host`和`Server`类中都编写一个`sing_birthday_song`方法，就像我们对`Hostable`模块所做的那样。

通过模块构造继承赋予了 Ruby 类从多个地方继承的能力。虽然一些编程语言有多重继承，这意味着一个子类可以从多个超类继承，但 Ruby 严格来说是一种*单一继承*语言。然而，通过使用模块和接口继承，Ruby 可以模仿多种继承。

# 类继承与接口继承

到目前为止，我们已经在实际例子中看到了类和接口继承，但是还不清楚什么时候可以使用其中一个来构造行为和继承它们的类。

在我们前面的讨论中，您可能还记得，继承就是将常见的行为组合到一个地方，多个类可以从这个地方继承这些行为，这个地方可以是超类，也可以是模块。在这两种情况下，目标都是将可以定义一次的常见行为分组，然后根据需要多次重用，而不会不必要地重复代码。然而，我们希望以这样一种方式对行为进行分组，即被继承的行为适合于继承它们的类。这样做，我们可以编写更加灵活、高度可伸缩且更易于维护的代码。

一般来说，如果类之间存在“是-a”关系，那么类继承通常是最好的起点。类继承允许我们将类和行为组织成逻辑层次，通常是以一种模拟我们在现实世界中看到的层次的方式。回到我们之前使用的例子，主人是雇员，服务员、服务员和厨师也是雇员。自然地，作为一个更一般的`Employee`类的成员，他们中的每个人都会有一些共同的行为，比如在一个班次的开始和结束时打卡。

然而，这种层次化建模通常也有例外，比如可能存在一些*子类共有的行为，但不是全部。我们在`Host`和`Server`类中看到了这一点，这两个类都能够执行主机的功能(例如，为客人安排座位)。因为这样的行为只对它们通用，而对`Employee`超类的其他子类不通用，所以我们不应该在`Employee`类中定义这些行为，因为这将导致子类(如餐馆服务员和厨师)继承不适合它们的行为。*

当然，另一种方法是在需要它们的各个子类中定义这些方法；但是这不是一个很好的选择，因为我们的代码变得不必要的重复。这就是通过 mixin 模块实现接口继承的原因。当公共行为不一定适合我们通过子类化创建的层次模型，并且在这些行为和需要它们的类之间存在“有-有”关系时，在这种情况下，接口继承通常是更好的选择。这正是我们在`Host`和`Server`类和`Hostable`模块中看到的，其中的行为不适合`Employee`超类，而`Host`和`Server`类都“拥有”了`Hostable`模块中的行为。

# 继承链和方法查找路径

尽管 Ruby 是一种单一继承的语言，其中一个类只能有一个超类，但是一个类也继承了它的超类所继承的行为。这有点拗口，但它只是意味着当从一个类中继承另一个类时，总会涉及到一个继承链。就像水从链的顶部流到底部一样，水(行为)流经链中通过子类化附加类创建的任何链接(类)，直到到达序列中的最后一个链接。

对于我们的餐馆思想实验，我们创建了一个`Employee`超类，其中包含许多雇员类型子类。为了演示这个继承链，我们现在要定义一个`Person`超类，从这个超类中产生了`Employee`类的子类。此外，我们还将创建一个类`Guest`，它也是`Person`类的子类，此外还有从`Guest`子类化的`Adult`和`Child`类。

为了更容易理解，让我们提取我们在类之间创建的结构。

```
Person < Guest < Adult
Person < Guest < Child
Person < Employee < Host
Person < Employee < Server
Person < Employee < Busser
Person < Employee < Cook
```

有了这个结构，我们创建的链中的最后一个子类继承了定义在链顶端的行为，以及它们之间的任何类。例如，`Host`类继承了`Person`类中的行为，因为这些行为是在`Employee`类中继承的，而`Host`类继承了`Employee`类的行为。

为了在实践中看到这个继承链，我们将从`Adult`类创建一个对象，然后调用`name`类中定义的方法`Person`。

正如我们在讨论类继承时看到的，我们能够调用在`Adult`类的对象上的`Person`类中定义的`name`方法，即使`name`方法既没有在`Adult`类中定义，也没有在`Guest`类中定义。这也是遗传在起作用。

为了进一步说明继承链，考虑一下常用的`object_id`方法。该方法可以在任何 Ruby 对象上调用，即使该方法没有在我们通常调用该方法的任何对象类中定义(例如，字符串、整数和数组)。这是因为`object_id`方法是`Object`类的实例方法，在继承链中，所有 Ruby 对象最终都继承自`Object`类。

例如，如果我们要在一个`Cook`类的对象上调用`object_id`方法，继承链将如下所示:

```
Object < Person < Employee < Cook
```

在 Ruby 中，这个继承链的底层有一个特定的机制，叫做方法查找路径。这是 Ruby 定位方法定义以执行同名方法调用的方法。用更通俗的话来说，这就是问题的答案:当一个方法被调用时，Ruby 如何知道在哪里可以找到它的定义？顾名思义，我们可以认为方法查找路径是 Ruby 在继承链中为被调用的方法寻找方法定义的路径。

对于任何方法调用，Ruby 寻找匹配方法定义的一般顺序如下:

```
Class (of the object upon which the method was invoked)
  ↓
Module(s)
  ↓
Superclass
  ↓
[repeat w/the Superclass now in the beginning position taken by Class]
```

正如您在上面的大纲中所看到的，Ruby 首先查找调用该方法的对象的类。如果 Ruby 在那里没有找到匹配的方法定义，那么 Ruby 就会在包含的模块中查找，如果有的话。如果类中包含两个或更多的模块，Ruby 首先查找最近包含的模块(可能是最后一个包含的模块)，然后向后查找剩余的模块。如果仍然没有找到方法定义，Ruby 就会在类的超类中查找，根据需要多次重复相同的循环。一旦 Ruby 用尽了所有的定制类和模块，而没有找到匹配的方法定义，那么 Ruby 将继续下面的类和模块:

```
Object
  ↓
Kernel (module in the Object class)
  ↓
BasicObject
```

如果 Ruby 在方法查找路径中找不到匹配的方法定义，就会引发一个`NoMethodError`。

为了在实践中看到方法查找路径，让我们考虑下面的代码。

在上面的例子中，我们创建了两个对象，一个是`Host`类，一个是`Server`类。在我们的`host`对象上，我们调用了`seat_guest`方法。

在`host`上调用`seat_guest`方法时，这里是 Ruby 用来定位匹配方法定义的方法查找路径。

```
Host
  ↓
Singable
  ↓
Hostable

[seat_guest method definition found in Hostable module]
```

如果发现了一个`seat_guest`方法*而不是*，Ruby 将会在抛出一个`NoMethodError`之前用尽整个方法查找路径。

```
Host
  ↓
Singable
  ↓
Hostable
  ↓
Employee
  ↓
Person
  ↓
Object
  ↓
Kernel
  ↓
BasicObject
  ↓
[NoMethodError]
```

# 结论

总而言之，继承是指一个类继承另一个类的行为的能力，这允许我们将公共代码提取到一个可继承的位置。因为 Ruby 是单继承语言，这意味着一个类只能从单个超类继承子类，所以 Ruby 有两种类型的继承:类继承和接口继承。虽然类继承允许我们在类之间创建层次关系，但是对于某些只在一些子类之间共享的行为来说，从超类继承并不总是有意义的。结果，通过 mixin 模块的接口继承给了我们模仿多重继承的能力。为了执行方法调用，Ruby 使用方法查找路径来查找匹配的方法定义。

1.  mixin 模块的常见命名约定是在模块名后面加上'-able '后缀。