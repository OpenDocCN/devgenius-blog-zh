<html>
<head>
<title>Node.js Tips — Auto-Scrolling, Delays, Hashing, and Get Updated Mongo Document</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js技巧——自动滚动、延迟、散列和更新Mongo文档</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/node-js-tips-auto-scrolling-delays-hashing-and-get-the-latest-mongo-document-91c13ba1de43?source=collection_archive---------18-----------------------#2020-07-22">https://blog.devgenius.io/node-js-tips-auto-scrolling-delays-hashing-and-get-the-latest-mongo-document-91c13ba1de43?source=collection_archive---------18-----------------------#2020-07-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/533b14fb3561ca4fb2967d2336ebb26b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NOYk4bsDGgSA6WmW"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@theflouffy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">弗洛菲</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="b6fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，当我们编写节点应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些编写节点应用程序时常见问题的解决方案。</p><h1 id="4657" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在Node.js中使用Q延迟</h1><p id="d757" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Q promise库有一个<code class="fe me mf mg mh b">delay</code>方法，可以异步延迟代码的执行。</p><p id="9cdc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以通过连线来使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3d8d" class="mq lc iq mh b gy mr ms l mt mu">const Q = require('q');</span><span id="d914" class="mq lc iq mh b gy mv ms l mt mu">const asyncDelay = (ms) =&gt; {<br/>  return Q.delay(ms);<br/>}</span><span id="bb3f" class="mq lc iq mh b gy mv ms l mt mu">asyncDelay(1000)<br/>.then(() =&gt; {<br/>  //...<br/>});</span></pre><p id="3607" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有返回<code class="fe me mf mg mh b">Q.delay(ms)</code>承诺的<code class="fe me mf mg mh b">asyncDelay</code>函数。</p><p id="3cbd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它返回一个承诺，将某事的执行延迟给定的毫秒数。</p><p id="f832" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以调用它，然后在<code class="fe me mf mg mh b">then</code>回调中的<code class="fe me mf mg mh b">asyncDelay</code>完成后，调用<code class="fe me mf mg mh b">then</code>并运行我们想要的代码。</p><p id="d1e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以传入第二个参数，它可以被称为解析值。</p><p id="e37d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d487" class="mq lc iq mh b gy mr ms l mt mu">const Q = require('q');</span><span id="b361" class="mq lc iq mh b gy mv ms l mt mu">Q.delay(1000, "Success")<br/>  .then((value) =&gt; {<br/>      console.log(value);<br/>  });</span></pre><p id="ef9e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe me mf mg mh b">value</code>就是<code class="fe me mf mg mh b">'Success'</code>，因为那是我们作为<code class="fe me mf mg mh b">delay</code>的第二个参数传入的。</p><h1 id="6324" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将图像转换为base64编码的数据URL</h1><p id="7472" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">要将图像转换成base64编码的数据URL，我们可以使用<code class="fe me mf mg mh b">readFileSync</code>方法来读取文件的数据。</p><p id="7096" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们将内容传递给<code class="fe me mf mg mh b">Buffer</code>构造函数。</p><p id="ae05" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以调用<code class="fe me mf mg mh b">toString</code>将其转换为base64字符串。</p><p id="052a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="dda1" class="mq lc iq mh b gy mr ms l mt mu">const fs = require('fs');</span><span id="5a82" class="mq lc iq mh b gy mv ms l mt mu">const file = 'img.jpg';<br/>const bitmap = fs.readFileSync(file);<br/>const dataUrl = new Buffer(bitmap).toString('base64');</span></pre><p id="cea7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将文件路径传递给<code class="fe me mf mg mh b">readFileSync</code>。</p><p id="09ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们将返回的内容传递给<code class="fe me mf mg mh b">Buffer</code>构造函数。</p><p id="c673" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用<code class="fe me mf mg mh b">'base64'</code>调用<code class="fe me mf mg mh b">toString</code>将其转换为base64字符串。</p><h1 id="5e50" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用MongoDB findOneAndUpdate返回更新的文档</h1><p id="cde2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该在options对象中将<code class="fe me mf mg mh b">returnOriginal</code>属性设置为<code class="fe me mf mg mh b">false</code>,以便在回调中返回更新后的文档。</p><p id="8735" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="308b" class="mq lc iq mh b gy mr ms l mt mu">db.collection('user_setting').findOneAndUpdate({<br/>  user_id: data.userId<br/>}, {<br/>  $set: data<br/>}, {<br/>  returnOriginal: false<br/>}, (err, res) =&gt; {<br/>  if (err) {<br/>    return console.log(err);<br/>  } else {<br/>    console.log(res);<br/>  }<br/>});</span></pre><p id="7a2a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个参数是查找要更新的对象的查询。</p><p id="875e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个参数是用来更新对象的数据。</p><p id="f851" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第三是更新选项。</p><p id="8a26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在第三个参数中将<code class="fe me mf mg mh b">returnOriginal</code>选项设置为<code class="fe me mf mg mh b">false</code>。</p><p id="2ed8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后一个参数是回调。</p><p id="331a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">res</code>应该有更新的结果。</p><h1 id="3839" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在快速应用程序中使用与NPM一起安装的jQuery</h1><p id="6e69" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">要在Express应用程序中使用与NPM一起安装的jQuery，我们可以用<code class="fe me mf mg mh b">express.static</code>服务jQuery的<code class="fe me mf mg mh b">dist</code>文件夹。</p><p id="785e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d1eb" class="mq lc iq mh b gy mr ms l mt mu">const path = require('path');</span><span id="9d2f" class="mq lc iq mh b gy mv ms l mt mu">app.use('/jquery', express.static(path.join(__dirname,  '/node_modules/jquery/dist/')));</span></pre><p id="bc50" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以通过编写以下代码在HTML文件中使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b819" class="mq lc iq mh b gy mr ms l mt mu">&lt;script src="/jquery/jquery.js"&gt;&lt;/script&gt;</span></pre><h1 id="0a89" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">向下滚动，直到我们不能用木偶师滚动</h1><p id="391c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以检查我们是否在页面的末尾，并使用<code class="fe me mf mg mh b">scrollBy</code>方法来滚动。</p><p id="98c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="407b" class="mq lc iq mh b gy mr ms l mt mu">const distance = 100;<br/>const delay = 100;<br/>while (document.scrollingElement.scrollTop + window.innerHeight &lt; document.scrollingElement.scrollHeight) {<br/>  document.scrollingElement.scrollBy(0, distance);<br/>  await new Promise(resolve =&gt; { setTimeout(resolve, delay); });<br/>}</span></pre><p id="7d5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们检查是否可以滚动:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="de8a" class="mq lc iq mh b gy mr ms l mt mu">document.scrollingElement.scrollTop + window.innerHeight &lt; document.scrollingElement.scrollHeight</span></pre><p id="8d2a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当<code class="fe me mf mg mh b">scrollTop</code>和<code class="fe me mf mg mh b">innerHeight</code>小于<code class="fe me mf mg mh b">scrollHeight</code>时，我们可以滚动。</p><h1 id="777b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在Node.js中查找操作系统用户名</h1><p id="0786" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">os</code>模块得到当前用户的用户名。</p><p id="394b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5ea5" class="mq lc iq mh b gy mr ms l mt mu">require("os").userInfo().username</span></pre><p id="9921" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要获取用户名</p><p id="4ea4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Windows 10中，它返回已使用的所有者帐户的名字。</p><p id="a4d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有<code class="fe me mf mg mh b">username</code>模块。</p><p id="1be2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过运行以下命令来安装它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ef7c" class="mq lc iq mh b gy mr ms l mt mu">npm install username</span></pre><p id="b2cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过写来使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6dc9" class="mq lc iq mh b gy mr ms l mt mu">const username = require('username');</span><span id="d06c" class="mq lc iq mh b gy mv ms l mt mu">(async () =&gt; {<br/>  console.log(await username());<br/>})();</span></pre><h1 id="8eaa" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">散列JavaScript对象</h1><p id="fbd9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了散列JavaScript对象，我们可以使用<code class="fe me mf mg mh b">object-hash</code>模块。</p><p id="9cb2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7db3" class="mq lc iq mh b gy mr ms l mt mu">const hash = require('object-hash');</span><span id="5587" class="mq lc iq mh b gy mv ms l mt mu">const obj = {a: 1, b: 2};<br/>const hashed = hash(obj);</span></pre><p id="bd53" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只是从包中调用<code class="fe me mf mg mh b">hash</code>函数来返回一个散列字符串。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/dc472aa652d4936de984abf5a50cce54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*I1e2GDi3VPKnwsaL"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@charliegreen998?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">查理·格林</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="cbb5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="080e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">object-hash</code>模块散列JavaScript对象。</p><p id="3d44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以通过<code class="fe me mf mg mh b">os</code>或第三方模块获得用户名。</p><p id="f614" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Q promise库有一个<code class="fe me mf mg mh b">delay</code>方法来延迟函数的执行。</p><p id="5d0d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">findOneAndUpdate</code>得到更新后的对象。</p><p id="527c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过检查高度来滚动，直到我们不能用木偶师滚动。</p></div></div>    
</body>
</html>