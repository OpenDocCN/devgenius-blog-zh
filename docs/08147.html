<html>
<head>
<title>How to create a workspace generator as a library in Nx workspace?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在 Nx workspace 中创建一个工作空间生成器作为库？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-create-a-workspace-generator-as-a-library-in-nx-workspace-1b312c88b543?source=collection_archive---------6-----------------------#2022-05-20">https://blog.devgenius.io/how-to-create-a-workspace-generator-as-a-library-in-nx-workspace-1b312c88b543?source=collection_archive---------6-----------------------#2022-05-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/5a10cfee59008c89f1f119d50983dcaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5hC0PHqf5iRG_QgG"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">有序的 Nx 工作空间将帮助您完成更多任务。<em class="ja">照片由</em> <a class="ae jb" href="https://unsplash.com/@carlheyerdahl?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> <em class="ja">卡尔·海尔达尔</em> </a> <em class="ja">上</em><a class="ae jb" href="https://unsplash.com/s/photos/workspace-generator?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"><em class="ja">Unsplash</em></a></figcaption></figure><div class=""/><p id="c6fd" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">如何创建 Nx 生成器？如何在你的 Nx 工作区使用？我们如何将工作区生成器转换成可发布的库？无聊怎么会对你有好处呢？</p><p id="81ec" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">Nx 是一个强大的 monorepo 管理工具。它帮助您利用最强大的 monorepo 优势(IMO)之一—标准。我所说的标准是指——无论你开发什么，或者你来自哪个团队，作为一名开发人员，你都会有宾至如归的感觉。</p><h1 id="0144" class="kz la je bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">标准优势或:为什么无聊是好的？</h1><p id="83ab" class="pw-post-body-paragraph kb kc je kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky ig bi translated">为了运行库的构建过程，开发人员可以在 cli 中键入以下内容:</p><p id="f6ed" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated"><code class="fe mc md me mf b">npx nx run myLibrary:build</code></p><p id="0da5" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">如果所述开发者想要运行测试？</p><p id="c722" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated"><code class="fe mc md me mf b">npx nx run myLibrary:test</code></p><p id="eef3" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">但是如果这个开发者想要运行超级服务器呢？</p><p id="fad4" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated"><code class="fe mc md me mf b">npx nx run mySuperDuperServer:serve</code></p><p id="f04a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">如果我想用 docker goodies 为生产构建它呢？</p><p id="a1b0" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated"><code class="fe mc md me mf b">npx nx run mySuperDuperServer:build</code></p><p id="996b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">以及如何测试所述服务器？</p><p id="37c1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated"><code class="fe mc md me mf b">npx nx run mySuperDuperServer:test</code></p><p id="3184" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">这很无聊吧？您可以用同样的方式构建、测试和服务。即使运行<code class="fe mc md me mf b">e2e</code>测试看起来也是这样:</p><p id="74d1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated"><code class="fe mc md me mf b">npx nx run components:e2e</code></p><p id="43fe" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">无聊！</p><p id="2fc6" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">但这就是标准的力量。假设一个开发者从<code class="fe mc md me mf b">components</code>团队到<code class="fe mc md me mf b">super duper server</code>团队？很简单！无需解释基础设施、安装等。只要记住<code class="fe mc md me mf b">npx</code>、<code class="fe mc md me mf b">nx run</code>、你正在工作的组件的名字和你想要运行的目标(e2e/服务/构建/测试等等)就行了。).</p><p id="78fd" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">你现在明白为什么无聊是好的了吧？这就是标准的力量。当开发人员需要记住不太麻烦的事情时，他们的工作效率会更高。现在我们可以专注于最重要的事情:)</p><h1 id="4835" class="kz la je bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">什么是工作空间生成器？</h1><p id="7dc0" class="pw-post-body-paragraph kb kc je kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky ig bi translated">如构建/测试/e2e 等。执行者，我们也有发电机。发电机是让我们产生(嗯…啊！！！)来自模板的新代码片段。</p><p id="f461" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">假设您正在创建 ui 组件或可注入服务或角度模块…您不希望总是从头开始编写相同的样板文件。或者更糟的是…从不同的文件夹复制并手动更改文件名、类名、测试名、观察名…</p><p id="d02d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">而且，为了让它变得无趣，我们希望所有东西都有相同的语法:</p><p id="070e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated"><code class="fe mc md me mf b">npx nx generate @nrwl/angular:library</code></p><p id="e7da" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">这将使用预先构建的 nrwl angular 插件生成一个 angular 库。如果我们有自己的需求，想要自己的发电机呢？进入工作区生成器！</p><p id="ad1f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">使用工作区生成器，您可以构建自己的生成器，并像这样运行它们:</p><p id="987f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated"><code class="fe mc md me mf b">npx nx workspace-generator vivid-component my-component</code></p><p id="64c8" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">这看起来有点像，但不完全一样。为什么？因为<code class="fe mc md me mf b">workspace generator</code>是一个单独的命令。因此，您正在运行一个不同的命令，该命令运行一个不属于插件的生成器。这打破了我们的无聊(例如，我们有另一个模式要记住)。为什么我们不能:</p><p id="81a1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated"><code class="fe mc md me mf b">npx nx g @vonage/nx-vivid:component my-component</code></p><p id="c856" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">嗯……我们可以，只是现在它不是一个工作区生成器——它是一个在我们的 Nx 工作区内使用的 Nx 插件！</p><h1 id="2cd2" class="kz la je bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">如何在 Nx 工作区内部构建一个 Nx 插件？</h1><p id="63a9" class="pw-post-body-paragraph kb kc je kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky ig bi translated">这是容易的部分。我们开始吧。</p><ol class=""><li id="f9a9" class="mg mh je kd b ke kf ki kj km mi kq mj ku mk ky ml mm mn mo bi translated">将 Nx 插件库添加到工作区:<code class="fe mc md me mf b">npm i -D @nrwl/nx-plugin</code></li><li id="0545" class="mg mh je kd b ke mp ki mq km mr kq ms ku mt ky ml mm mn mo bi translated">在工作区生成插件库:<code class="fe mc md me mf b">npx nx g @nrwl/nx-plugin:plugin nx-vivid --import-path @vonage/nx-vivid</code></li></ol><p id="50ac" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">这两个步骤产生了一个名为<code class="fe mc md me mf b">nx-vivid</code>的新库，它包含一个存根生成器和一个存根执行器。它还为发电机增加了一个<code class="fe mc md me mf b">e2e</code>测试。<code class="fe mc md me mf b">e2e</code>测试帮助您测试通常由生成器完成的文件操作。</p><p id="7fc0" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">现在剩下的就是实际编写插件了。</p><h1 id="69d1" class="kz la je bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">an Nx 插件怎么写？</h1><p id="9d48" class="pw-post-body-paragraph kb kc je kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky ig bi translated">就像编写任何其他代码一样。先看看我们要做什么。在我们的存储库中，我们有一个保存 UI 组件库的<code class="fe mc md me mf b">components</code>库。</p><p id="c644" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">我们所有的组件都存在于<code class="fe mc md me mf b">src/lib</code>文件夹中。</p><p id="645f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">它们看起来都差不多，或者至少开始是一样的:</p><ol class=""><li id="15a9" class="mg mh je kd b ke kf ki kj km mi kq mj ku mk ky ml mm mn mo bi translated">索引条目文件</li><li id="97e5" class="mg mh je kd b ke mp ki mq km mr kq ms ku mt ky ml mm mn mo bi translated">基类文件</li><li id="3dc1" class="mg mh je kd b ke mp ki mq km mr kq ms ku mt ky ml mm mn mo bi translated">模板填充</li><li id="59e2" class="mg mh je kd b ke mp ki mq km mr kq ms ku mt ky ml mm mn mo bi translated"><code class="fe mc md me mf b">scss</code>文件</li><li id="b58b" class="mg mh je kd b ke mp ki mq km mr kq ms ku mt ky ml mm mn mo bi translated">自述文件</li><li id="295b" class="mg mh je kd b ke mp ki mq km mr kq ms ku mt ky ml mm mn mo bi translated">UI 测试文件</li></ol><p id="33bb" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">他们的内容也相当重复。因为我是一个<code class="fe mc md me mf b">test first</code>类型的人，所以让我们从<code class="fe mc md me mf b">e2e</code>测试开始。</p><h1 id="3b11" class="kz la je bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">写 Nx 插件 E2E</h1><p id="6157" class="pw-post-body-paragraph kb kc je kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky ig bi translated"><code class="fe mc md me mf b">Nx</code>有很多实用程序来编写和测试插件。因此，测试非常简单:</p><pre class="mu mv mw mx gt my mf mz na aw nb bi"><span id="fc87" class="nc la je mf b gy nd ne l nf ng">import {<br/>  checkFilesExist,<br/>  ensureNxProject,<br/>  readJson,<br/>  runNxCommandAsync,<br/>  uniq,<br/>} from '@nrwl/nx-plugin/testing';</span><span id="945b" class="nc la je mf b gy nh ne l nf ng">describe('nx-vivid e2e', () =&gt; {<br/>  beforeAll(() =&gt; {<br/>    ensureNxProject('@vonage/nx-vivid', 'dist/libs/nx-vivid');<br/>  });</span><span id="b9b6" class="nc la je mf b gy nh ne l nf ng">  afterAll(() =&gt; {<br/>    runNxCommandAsync('reset');<br/>  });</span><span id="8f8f" class="nc la je mf b gy nh ne l nf ng">  describe('--directory', () =&gt; {<br/>    it('should create src in the specified directory', async () =&gt; {<br/>      const project = uniq('nx-vivid');<br/>      await runNxCommandAsync(<br/>        `generate @vonage/nx-vivid:component ${project}`<br/>      );<br/>      expect(() =&gt;<br/>        checkFilesExist(`libs/components/src/lib/${project}/index.ts`)<br/>      ).not.toThrow();<br/>      expect(() =&gt;<br/>        checkFilesExist(`libs/components/src/lib/${project}/ui.test.ts`)<br/>      ).not.toThrow();<br/>      expect(() =&gt;<br/>        checkFilesExist(`libs/components/src/lib/${project}/README.md`)<br/>      ).not.toThrow();<br/>      expect(() =&gt;<br/>        checkFilesExist(`libs/components/src/lib/${project}/${project}.ts`)<br/>      ).not.toThrow();<br/>      expect(() =&gt;<br/>        checkFilesExist(`libs/components/src/lib/${project}/${project}.template.ts`)<br/>      ).not.toThrow();<br/>      expect(() =&gt;<br/>        checkFilesExist(`libs/components/src/lib/${project}/${project}.spec.ts`)<br/>      ).not.toThrow();<br/>      expect(() =&gt;<br/>        checkFilesExist(`libs/components/src/lib/${project}/${project}.scss`)<br/>      ).not.toThrow();<br/>    }, 120000);<br/>  });<br/>});</span></pre><p id="ced1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">事情是这样的:</p><ol class=""><li id="df1f" class="mg mh je kd b ke kf ki kj km mi kq mj ku mk ky ml mm mn mo bi translated">上面的代码启动了一个新的 Nx 工作空间(<code class="fe mc md me mf b">ensureNxProject('@vonage/nx-vivid', 'dist/libs/nx-vivid');</code>)。</li><li id="fac9" class="mg mh je kd b ke mp ki mq km mr kq ms ku mt ky ml mm mn mo bi translated">然后它运行我们想要的命令:<br/> <code class="fe mc md me mf b">await runNxCommandAsync( generate @vonage/nx-vivid:component ${project} );</code>。相当于跑了<code class="fe mc md me mf b">npx nx generate @vonage/nx-vivid:component my-project</code>，这就是我们想要的！</li><li id="a77b" class="mg mh je kd b ke mp ki mq km mr kq ms ku mt ky ml mm mn mo bi translated">之后，它希望在库的文件夹中生成所有文件。</li></ol><p id="4066" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">相当简单！</p><p id="07ce" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated"><a class="ae jb" href="https://github.com/Vonage/vivid-3/pull/393/commits/a0dc62a0ab362b653d788aa771cecc15202c6645" rel="noopener ugc nofollow" target="_blank">这是对那个</a>的提交</p><p id="773d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">你能猜到如何运行 e2e 测试吗？准备好你无聊的哈欠:<code class="fe mc md me mf b">npx nx run nx-vivid-e2e:e2e</code>。测试失败是因为我们还没有设置组件的生成器！</p><h1 id="d8cb" class="kz la je bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">向 Nx 插件添加生成器</h1><p id="40b5" class="pw-post-body-paragraph kb kc je kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky ig bi translated">发电机由三个主要部分组成:</p><ol class=""><li id="f445" class="mg mh je kd b ke kf ki kj km mi kq mj ku mk ky ml mm mn mo bi translated">模式-生成器输入的模式</li><li id="1c96" class="mg mh je kd b ke mp ki mq km mr kq ms ku mt ky ml mm mn mo bi translated">模板文件——带有占位符的文件，将被复制和操作到一个完整的工作库/应用程序/组件/无论什么</li><li id="153c" class="mg mh je kd b ke mp ki mq km mr kq ms ku mt ky ml mm mn mo bi translated">实际的逻辑和它的测试文件(在我们的例子中是<code class="fe mc md me mf b">index.ts</code>和<code class="fe mc md me mf b">index.spec.ts</code>)文件——我们告诉什么应该去哪里。</li></ol><p id="7dcb" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">如果您想在逻辑文件中进行类型检查，模式是一个<code class="fe mc md me mf b">json</code>文件和一个可选的<code class="fe mc md me mf b">d.ts</code>文件。</p><pre class="mu mv mw mx gt my mf mz na aw nb bi"><span id="6622" class="nc la je mf b gy nd ne l nf ng">{<br/>  "$schema": "http://json-schema.org/schema",<br/>  "cli": "nx",<br/>  "$id": "vivid-component",<br/>  "type": "object",<br/>  "properties": {<br/>    "name": {<br/>      "type": "string",<br/>      "description": "Component name",<br/>      "$default": {<br/>        "$source": "argv",<br/>        "index": 0<br/>      }<br/>    }<br/>  },<br/>  "required": ["name"]<br/>}</span></pre><p id="246e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">这是它看起来的样子。有许多类型的属性，<code class="fe mc md me mf b">Nx</code>机制还允许您向消费者提问(比如使用<code class="fe mc md me mf b">express</code>或<code class="fe mc md me mf b">nestjs</code>)。你可以在<a class="ae jb" href="https://nx.dev/generators/generator-options" rel="noopener ugc nofollow" target="_blank">的 Nx 文档中了解更多。</a></p><p id="707b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">模板文件就是您期望在输出中看到的内容——带有占位符。例如，您在文件名和文件夹名中设置<code class="fe mc md me mf b">__fileName__</code>作为组件相关文件名的占位符。在文件中，你使用标签如<code class="fe mc md me mf b">{&lt;%= className %&gt;}</code>或<code class="fe mc md me mf b">&lt;%= name %&gt;</code>作为动态属性的占位符。</p><p id="4124" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">最后，<code class="fe mc md me mf b">logic</code>文件将它们全部绑定。它导出一个异步函数，在调用生成器时使用:</p><pre class="mu mv mw mx gt my mf mz na aw nb bi"><span id="1c76" class="nc la je mf b gy nd ne l nf ng">import {<br/>  Tree,<br/>  formatFiles,<br/>  names,<br/>  joinPathFragments,<br/>  getWorkspaceLayout,<br/>  generateFiles, offsetFromRoot<br/>} from '@nrwl/devkit';<br/>import {VividComponentGeneratorOptions} from "./schema";<br/>import {join} from "path";</span><span id="66e7" class="nc la je mf b gy nh ne l nf ng">export interface NormalizedSchema extends VividComponentGeneratorOptions {<br/>  fileName: string;<br/>  className: string;<br/>  projectRoot: string;<br/>}</span><span id="7d0b" class="nc la je mf b gy nh ne l nf ng">function normalizeOptions(tree: Tree, options: VividComponentGeneratorOptions): NormalizedSchema {<br/>  const projectDirectory = names(options.name).fileName;<br/>  const className = names(options.name).className;</span><span id="01b2" class="nc la je mf b gy nh ne l nf ng">  const name = projectDirectory.replace(new RegExp('/', 'g'), '-');<br/>  const fileName = names(projectDirectory).fileName;</span><span id="9d37" class="nc la je mf b gy nh ne l nf ng">  const { libsDir, npmScope } = getWorkspaceLayout(tree);</span><span id="59b5" class="nc la je mf b gy nh ne l nf ng">  const projectRoot = joinPathFragments(libsDir, 'components/src/lib', projectDirectory);</span><span id="3bdf" class="nc la je mf b gy nh ne l nf ng">  return {<br/>    ...options,<br/>    fileName,<br/>    name,<br/>    className,<br/>    projectRoot<br/>  };<br/>}</span><span id="cdb8" class="nc la je mf b gy nh ne l nf ng">function createFiles(tree: Tree, options: NormalizedSchema) {<br/>  const {className, name, propertyName} = names(options.name);</span><span id="4334" class="nc la je mf b gy nh ne l nf ng">  generateFiles(tree, join(__dirname, './files'), options.projectRoot, {<br/>    ...options,<br/>    dot: '.',<br/>    className,<br/>    name,<br/>    propertyName,<br/>    cliCommand: 'nx',<br/>    strict: undefined,<br/>    tmpl: '',<br/>    offsetFromRoot: offsetFromRoot(options.projectRoot)<br/>  });<br/>}</span><span id="25b5" class="nc la je mf b gy nh ne l nf ng">export default async function vividComponentGenerator(tree: Tree, schema: VividComponentGeneratorOptions) {<br/>  const options = normalizeOptions(tree, schema);<br/>  createFiles(tree, options);<br/>  await formatFiles(tree);<br/>}</span></pre><p id="3ad7" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">在上面的例子中，函数<code class="fe mc md me mf b">vividComponentGenerator</code>被导出。它处理从用户那里收到的选项，创建文件，然后运行<code class="fe mc md me mf b">formatFiles</code>...格式化文件(主要是林挺)。</p><p id="aaf0" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">最后，我们需要告诉插件生成器的存在以及如何到达它。这是在主插件的<code class="fe mc md me mf b">generators.json</code>文件中完成的:</p><pre class="mu mv mw mx gt my mf mz na aw nb bi"><span id="191d" class="nc la je mf b gy nd ne l nf ng">{<br/>  "$schema": "http://json-schema.org/schema",<br/>  "name": "nx-vivid",<br/>  "version": "0.0.1",<br/>  "generators": {<br/>    "component": {<br/>      "factory": "./src/generators/component/index",<br/>      "schema": "./src/generators/component/schema.json",<br/>      "description": "nx-vivid component generator"<br/>    }<br/>  }<br/>}</span></pre><p id="eed7" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">添加完所有这些之后，<code class="fe mc md me mf b">e2e</code>测试通过。</p><p id="c192" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated"><a class="ae jb" href="https://github.com/Vonage/vivid-3/pull/393/commits/300128442bf4025f1ce9a175bcdeb0998aa9aebd#diff-a90080815abcb99f4ed3dbf945b04e2975d952c14972536df29691a87196eb68" rel="noopener ugc nofollow" target="_blank">查看本部分</a>提交的代码。</p><h1 id="cbab" class="kz la je bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">测试你的 Nx 插件</h1><p id="2f35" class="pw-post-body-paragraph kb kc je kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky ig bi translated">我们看到了插件的<code class="fe mc md me mf b">e2e</code>测试。注意，我还写了<code class="fe mc md me mf b">unit tests</code>(在<a class="ae jb" href="https://github.com/Vonage/vivid-3/pull/393/commits/300128442bf4025f1ce9a175bcdeb0998aa9aebd#diff-a90080815abcb99f4ed3dbf945b04e2975d952c14972536df29691a87196eb68" rel="noopener ugc nofollow" target="_blank">提交</a>中)。我实际上是在写真正的代码之前写的。虽然<a class="ae jb" href="https://yonatankra.com/5-tdd-lessons-when-writing-javascript-algorithm/" rel="noopener ugc nofollow" target="_blank"> TDD </a>超出了本文的范围，但是让我们来谈谈插件的测试。</p><p id="d886" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">在这种情况下，单元测试做的事情和<code class="fe mc md me mf b">e2e</code>测试做的事情是一样的——当我们给出一个特定的输入(例如组件的名字)时，它们确保生成正确的文件:</p><figure class="mu mv mw mx gt ip"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="3a24" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">在上面的代码片段中，我们使用 Nx devkit 来生成工作区的虚拟文件树。然后，我们用所需的选项运行生成器。我们希望生成的树包含替换了占位符的模板文件。</p><p id="4511" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">测试的经验法则是这样的:如果你可以用单元测试和 E2E 覆盖同样的事情，那么最好用单元测试。他们要快得多。就这么简单。</p><p id="8bf3" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">那为什么 Nx 给我们设置了一个 E2E 插件基础设施呢？在与 Nrwl<a class="ae jb" href="https://nrwl.io/" rel="noopener ugc nofollow" target="_blank">的</a><a class="ae jb" href="https://twitter.com/EnderAgent" rel="noopener ugc nofollow" target="_blank"> Craigory </a>交谈时，他给出了一个相当肯定的答案:</p><figure class="mu mv mw mx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nk"><img src="../Images/f73ddf4caf287642e2f4ae575e140b01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*k5nmpPGhY_XAYy3E.png"/></div></div></figure><p id="438e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">这个答案非常适合喜欢经验法则的人:</p><ol class=""><li id="1fa2" class="mg mh je kd b ke kf ki kj km mi kq mj ku mk ky ml mm mn mo bi translated">它支持我们的经验法则“更多单位—更少 e2e”</li><li id="3fc1" class="mg mh je kd b ke mp ki mq km mr kq ms ku mt ky ml mm mn mo bi translated">我给出了另一个针对 Nx 插件的经验法则——“e2e 是执行者——单元是生成器”</li></ol><h1 id="20e9" class="kz la je bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">摘要</h1><p id="08a7" class="pw-post-body-paragraph kb kc je kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky ig bi translated">标准很重要。它们有助于开发人员体验、可伸缩性、敏捷性，我可能忘记了标准的一些好处。</p><p id="08f7" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated"><code class="fe mc md me mf b">Nx</code>允许您利用标准，不仅如此，其机制还迫使您标准化工作空间。</p><p id="766d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">我们从 Lerna 迁移到 Nx，祝福这一天。一切都是标准化的。甚至定制的生成器、linters 和其他对所有开发者来说看起来都是一样的。处理文档的开发人员使用与处理组件或任何其他部分的开发人员相同的命令语法。甚至生成器插件本身也有同样的开发者体验。</p><p id="2717" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">我没有提到您可以获得的其他好处，如依赖图、几乎所有东西的模拟运行、并行执行、缓存、云缓存等等。</p><p id="d8f8" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">我们将何去何从？这个生成器用于在我们自己的库中生成内部代码片段。由于一些构建限制，这是我们的第一个设计。我们相信我们克服了这些限制，并打算从库中提取组件——因此每个组件都将“独立”存在。</p><p id="c6e6" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">这意味着，我们的生成器将为组件生成完整的库，而不是在现有的库中生成代码片段。或者更好的是，我们可以组成一个<code class="fe mc md me mf b">component library</code>发电机，在引擎盖下使用我们的<code class="fe mc md me mf b">component generator</code>。</p><p id="6c5f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">非常感谢来自<a class="ae jb" href="https://nrwl.io/" rel="noopener ugc nofollow" target="_blank"> Nrwl </a>的<a class="ae jb" href="https://twitter.com/EnderAgent" rel="noopener ugc nofollow" target="_blank"> Craigory </a>的精彩评论和讨论！</p></div></div>    
</body>
</html>