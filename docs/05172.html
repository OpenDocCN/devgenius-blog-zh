<html>
<head>
<title>Memory Management Part 2: Reference Cycles, Closures and Debugging</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">内存管理第2部分:引用周期、闭包和调试</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/memory-management-part-2-reference-cycles-closures-and-debugging-59b917dc064b?source=collection_archive---------1-----------------------#2021-06-27">https://blog.devgenius.io/memory-management-part-2-reference-cycles-closures-and-debugging-59b917dc064b?source=collection_archive---------1-----------------------#2021-06-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><blockquote class="jk jl jm"><p id="ce92" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">这篇文章基于我在柏林和T2的演讲。</p></blockquote><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/f06ae3b0fb71f17116e856294f5c900c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*th7UcepA1hcPWlaYKJnjxQ.jpeg"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">我的儿子“优素福”曾经告诉我，大象能够记住水源几十年。由<a class="ae km" href="https://unsplash.com/@photosbybeks?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">拍摄的照片由<a class="ae km" href="https://unsplash.com/s/photos/elephant?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的Beks </a>拍摄。</figcaption></figure><p id="4035" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi lg translated">欢迎阅读这个关于内存管理的小系列的第二部分！本部分接续<a class="ae km" rel="noopener ugc nofollow" target="_blank" href="/memory-management-part-1-regions-types-and-leaks-884c231f5135">第1部分:区域、结构和泄漏</a>。我建议您从本系列文章的第一部分开始，以便从中获得最大收益。</p><p id="b78d" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">在本文中，您将了解到:</p><ul class=""><li id="70bd" class="lp lq in jq b jr js jv jw ld lr le ls lf lt kl lu lv lw lx bi translated">打破类和闭包中的引用循环</li><li id="6e93" class="lp lq in jq b jr ly jv lz ld ma le mb lf mc kl lu lv lw lx bi translated">转义和非转义闭包</li><li id="162f" class="lp lq in jq b jr ly jv lz ld ma le mb lf mc kl lu lv lw lx bi translated">延迟解除分配</li><li id="bfbb" class="lp lq in jq b jr ly jv lz ld ma le mb lf mc kl lu lv lw lx bi translated">Xcode内存调试器</li><li id="8cab" class="lp lq in jq b jr ly jv lz ld ma le mb lf mc kl lu lv lw lx bi translated">定位泄漏的🕵🏽‍♂️</li></ul><h1 id="b680" class="md me in bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">跟进！</h1><p id="630f" class="pw-post-body-paragraph jn jo in jq b jr nb jt ju jv nc jx jy ld nd kb kc le ne kf kg lf nf kj kk kl ig bi translated">在前一部分；书、作者和编辑被困在堆内存区域，他们的内存槽不可重用。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi ng"><img src="../Images/87ea0be711b67f0cdbdf0fd66107d295.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GCmYS7VOWgXJBZlUZ8Y3Gg.png"/></div></div></figure><p id="740d" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">因为书和作者相互引用，每个实例都使另一个实例保持活力，对于书和编辑器也是如此。</p><p id="6173" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">我们通过结束作用域使事情变得更糟，堆栈列表项将被释放，不再有对初始对象的引用。</p><p id="544a" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">这是一个典型的引用周期案例，它导致了一个被称为<strong class="jq io">内存泄漏</strong>的软件错误。由于内存泄漏，即使内存的实际生命周期已经结束，内存也不会被释放。</p><h1 id="3bce" class="md me in bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">中断参考循环</h1><p id="b528" class="pw-post-body-paragraph jn jo in jq b jr nb jt ju jv nc jx jy ld nd kb kc le ne kf kg lf nf kj kk kl ig bi translated">那么，你能猜出我们应该去哪个班级🛠吗👷🏽‍♂️👷🏽‍♀️?</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi nh"><img src="../Images/a0c6ebbb15d13a402f1a28b38d1fb361.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TZnEM7uAmf30E8Dv9mwewA.png"/></div></div></figure><p id="68e7" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">确切地说，<strong class="jq io"> book </strong>类，因为它不是owner类，它在属性中存储对其所有者的引用。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi ng"><img src="../Images/6bf78bc9ba728a6ad267c2df4d6fe002.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YEeBXyqpVqW-VyiDViF7Ew.png"/></div></div></figure><p id="7831" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">一本<strong class="jq io">书</strong>并不总是分配给一个<strong class="jq io">编辑</strong>，所以让我们把它建模为一个<strong class="jq io">可选</strong>类型。而且<strong class="jq io">书</strong>不拥有<strong class="jq io">编辑</strong>，所以让它成为<strong class="jq io">弱引用</strong>也是有道理的。</p><p id="af73" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated"><strong class="jq io">弱表示</strong>该变量中的引用不参与引用计数。当引用不是弱引用时，它被称为<strong class="jq io">强引用</strong>，这是Swift中的默认设置。</p><p id="09a5" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">使用<strong class="jq io">弱</strong>变量的好处在于，当底层对象离开时，它们会自动检测到。这就是为什么<em class="jp">总是用可选类型和变量</em>来声明它们。因为一旦引用计数达到零，它们就变为零。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi ni"><img src="../Images/f6a58f1bb9fcfca1071cb1f9d17cd13c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jWCBsukGya9hOP_lmcUUfQ.png"/></div></div></figure><p id="1a56" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated"><strong class="jq io">无主引用</strong>是<strong class="jq io"> </strong>打破引用循环的另一种方式，其行为很像<strong class="jq io">弱引用</strong>，因为它们不改变对象的引用计数。但是与弱引用不同，它们总是期望有一个值——你不能将它们声明为可选的。</p><p id="bd5c" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">这样想:一本书没有作者就不可能存在。同时，一本书并不“拥有”作者，因此引用应该是<strong class="jq io">无主的</strong>。</p><p id="a479" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">这里我们保证一本书总是有一个作者，因此，作者不是可选的。一本书在某个时间可以有一个编辑，因此，这个编辑被声明为可选的。</p><p id="25c6" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">另一方面，books是一个变量，所以它可以在初始化后被修改。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi nj"><img src="../Images/1ff0ef357b942448feb486a9b0aec4a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ldy0BZqDh5TeJaULco852w.png"/></div></div></figure><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi nk"><img src="../Images/bddec2b82b6d1cfa41f40940481d480e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o_BvSingr3vfhI1oft0XCQ.png"/></div></div></figure><p id="803e" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">瞧啊。我们的代码用<strong class="jq io">弱</strong>和<strong class="jq io">无主</strong>关键字打破了引用循环。</p><p id="0714" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">所有的deinit方法都将运行，它们将被取消分配。</p><h1 id="203a" class="md me in bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">关闭</h1><p id="7aa5" class="pw-post-body-paragraph jn jo in jq b jr nb jt ju jv nc jx jy ld nd kb kc le ne kf kg lf nf kj kk kl ig bi translated">闭包只是一个没有名字的函数；您可以将它赋给一个变量，并像其他值一样传递。</p><p id="9d97" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">它们被命名为“闭包”，因为它们可以“封闭”闭包范围内的变量和常量。</p><p id="9429" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">这仅仅意味着closure可以从周围的上下文中访问、存储和操作任何变量或常量的值。</p><p id="56dc" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">闭包体内使用的变量和常量据说已经被闭包捕获。</p><p id="9d78" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">封闭有两种，非逃逸和逃逸。</p><h2 id="f791" class="nl me in bd mf nm nn dn mj no np dp mn ld nq nr mr le ns nt mv lf nu nv mz nw bi translated">非转义闭包</h2><p id="4ce2" class="pw-post-body-paragraph jn jo in jq b jr nb jt ju jv nc jx jy ld nd kb kc le ne kf kg lf nf kj kk kl ig bi translated">在Swift中，闭包在默认情况下是非转义的，它们是:</p><ul class=""><li id="b2f8" class="lp lq in jq b jr js jv jw ld lr le ls lf lt kl lu lv lw lx bi translated">不可储存。</li><li id="dcee" class="lp lq in jq b jr ly jv lz ld ma le mb lf mc kl lu lv lw lx bi translated">在范围内执行。</li><li id="783a" class="lp lq in jq b jr ly jv lz ld ma le mb lf mc kl lu lv lw lx bi translated">不会导致参考循环。</li></ul><p id="ed75" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">如果你不介意延迟释放，不需要使用[弱或无主自我]进行非转义闭包。</p><h2 id="294e" class="nl me in bd mf nm nn dn mj no np dp mn ld nq nr mr le ns nt mv lf nu nv mz nw bi translated">逃脱关闭</h2><ul class=""><li id="cf04" class="lp lq in jq b jr nb jv nc ld nx le ny lf nz kl lu lv lw lx bi translated">可储存的</li><li id="2022" class="lp lq in jq b jr ly jv lz ld ma le mb lf mc kl lu lv lw lx bi translated">可以传递给其他闭包。</li><li id="476e" class="lp lq in jq b jr ly jv lz ld ma le mb lf mc kl lu lv lw lx bi translated">可以在未来执行。</li><li id="caae" class="lp lq in jq b jr ly jv lz ld ma le mb lf mc kl lu lv lw lx bi translated">导致<strong class="jq io">参考周期。</strong></li></ul><p id="0a97" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">🤔逃避闭包会如何导致引用循环？</p></div><div class="ab cl oa ob hr oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ig ih ii ij ik"><p id="b828" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">Swift是一种安全的语言，闭包延长了它们使用的任何对象的生命周期，以保证这些对象是活的和有效的。</p><p id="6fcf" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">这种自动安全很酷，但是如果你延长一个本身捕获闭包的对象的生命周期，这就是引用周期的原因。</p><p id="b246" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">让我们看一个例子！</p><h1 id="f5dc" class="md me in bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">转义闭包中的引用循环</h1><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi oh"><img src="../Images/98ccd0f2eb3621b2810d52a7b3682ae0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1yHWvCpftnJUiJJsu70WTw.png"/></div></div></figure><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi oi"><img src="../Images/30cd97c13ce618dfcc309bbd329f58fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9VvwS-LEPu-mPo10sJyIKA.png"/></div></div></figure><p id="f5ff" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">例如，如果您为book类添加一个计算图书描述的惰性属性。</p><p id="52ce" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated"><strong class="jq io">注意:</strong>一个<strong class="jq io">懒惰属性</strong>直到第一次使用时才被赋值，而self只有在初始化后才可用。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi oj"><img src="../Images/4082737b6fdbfdab8e7643ce623abbb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0sIDWBSusiCYl_iXbvRPZA.png"/></div></div></figure><p id="9f88" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">当我们在我们的作用域中调用<em class="jp"> book.description() </em>时，book对象为<em class="jp"> description() </em>创建一个内存块，并保存它的引用。同时<em class="jp"> description() </em>通过标题和作者强烈地捕捉自我，这反过来增加了图书对象的引用计数。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi ok"><img src="../Images/dcb06140f53c8d873193139a23d7ba1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XbUjaMXea1hWlt-jgd9uqQ.png"/></div></div></figure><p id="7f28" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">我们又有一个参考循环，现在在书和<em class="jp">描述()</em>之间。在作用域的末尾，只调用作者的deinit方法。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi ol"><img src="../Images/f233e9f6d1ea60359837d348d5bac055.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6eci64QQuuNR4ti9Oo9F5Q.png"/></div></div></figure><h1 id="642c" class="md me in bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">断开闭合参考循环</h1><p id="a49e" class="pw-post-body-paragraph jn jo in jq b jr nb jt ju jv nc jx jy ld nd kb kc le ne kf kg lf nf kj kk kl ig bi translated">为了打破这个循环，你需要了解一个叫做<strong class="jq io">捕获列表</strong>的语言特性。</p><p id="9153" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated"><strong class="jq io"> Capture list是</strong>一种语言特性，帮助你精确地控制闭包如何扩展它所引用的对象的生命周期。它们是由闭包捕获的变量列表。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi om"><img src="../Images/398d004f674313f4b7043ca307a7122e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*tFigzjf2T3UGMvX20-nWMQ.png"/></div></figure><p id="bdfc" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">由于在从内存中释放book对象后闭包不应该存在，self永远不会为零，所以我们可以使用捕获列表将强引用改为一个<strong class="jq io">无主的</strong>对象。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi on"><img src="../Images/3dbf3e485d239faf7715d6126143fd99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b7CoE9Um_4-vGYvuvd2Jig.png"/></div></div></figure><p id="0d8c" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">没有引用循环，Swift将在范围结束时取消分配描述对象。</p><h2 id="83ad" class="nl me in bd mf nm nn dn mj no np dp mn ld nq nr mr le ns nt mv lf nu nv mz nw bi translated">【软弱的自己】</h2><p id="d8e6" class="pw-post-body-paragraph jn jo in jq b jr nb jt ju jv nc jx jy ld nd kb kc le ne kf kg lf nf kj kk kl ig bi translated">有些时候你不能捕获self作为一个无主引用，因为self可能会变成nil，应用程序会因为读取nil对象而崩溃。</p><p id="414d" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated"><strong class="jq io"> <em class="jp">【弱自我】</em> </strong>表示闭包不会延长自我的生存期，但是如果代表自我的底层对象消失了，它就会被设置为零。</p><p id="3ad0" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">如果self离开，应用程序不会崩溃，但会生成一个“字符串插值”警告，您可以通过<strong class="jq io">强弱模式修复该警告。</strong></p><p id="99b6" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated"><strong class="jq io">注:</strong>用<em class="jp">【弱自】</em>代替无主是明智的，一直推荐。</p><h1 id="cc1f" class="md me in bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">什么时候该用【弱自我】？</h1><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi oo"><img src="../Images/defb3e9997c0d2dbb873bdc2896a3fdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VxmOjobeJkPQhkWVaS66ug.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">你并不总是需要一个软弱的自己，贝希尔·艾尔·马勒</figcaption></figure><p id="eab2" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">这里有一个综合流程图，由<a class="ae km" href="https://medium.com/flawless-app-stories/you-dont-always-need-weak-self-a778bec505ef" rel="noopener"><strong class="jq io">Besher Al Maleh</strong></a>来决定你的封闭是否在逃避，是否需要<strong class="jq io"><em class="jp"/></strong>。</p><h1 id="5908" class="md me in bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">参考循环— GCD</h1><p id="b5fe" class="pw-post-body-paragraph jn jo in jq b jr nb jt ju jv nc jx jy ld nd kb kc le ne kf kg lf nf kj kk kl ig bi translated">GCD不会导致引用循环，除非您存储它以备将来执行。</p><h1 id="f91c" class="md me in bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">参考循环-动画</h1><p id="5d93" class="pw-post-body-paragraph jn jo in jq b jr nb jt ju jv nc jx jy ld nd kb kc le ne kf kg lf nf kj kk kl ig bi translated"><em class="jp"> UIView.animate() </em>不会导致引用循环，除非您存储了一个<em class="jp">uiviewpropertyimator</em>供将来执行。</p><h1 id="c5ca" class="md me in bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">参考循环—计时器</h1><p id="18eb" class="pw-post-body-paragraph jn jo in jq b jr nb jt ju jv nc jx jy ld nd kb kc le ne kf kg lf nf kj kk kl ig bi translated">计时器就不同了。它可以保留一个对象，即使它没有存储在属性中。</p><p id="20f2" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">只要计时器重复并且self没有在其中被捕获，计时器将防止被引用对象由于无限期延迟的释放而被释放，而不是内存泄漏。</p><p id="12af" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">记住在不需要计时器的时候让它无效，并在其中微弱地捕捉自我。</p><h1 id="8492" class="md me in bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">延迟解除分配</h1><p id="3ced" class="pw-post-body-paragraph jn jo in jq b jr nb jt ju jv nc jx jy ld nd kb kc le ne kf kg lf nf kj kk kl ig bi translated">这不是内存泄漏，这是转义和非转义闭包都会发生的副作用。这种副作用会导致不良行为。</p><p id="0ecc" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">正如我们前面所说的，如果您没有弱地捕获自我<em class="jp">，</em>闭包会强有力地捕获周围环境中的任何变量或常量。这意味着只要闭包体还活着，闭包就会阻止被强捕获的对象被释放。</p><p id="9992" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated"><a class="ae km" href="https://medium.com/flawless-app-stories/you-dont-always-need-weak-self-a778bec505ef" rel="noopener">查看这篇文章</a>了解可以保持封闭体存活的场景。</p><h1 id="3231" class="md me in bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">书店</h1><p id="355e" class="pw-post-body-paragraph jn jo in jq b jr nb jt ju jv nc jx jy ld nd kb kc le ne kf kg lf nf kj kk kl ig bi translated">最后，是时候使用Xcode内存调试器显示参考周期了。我将用一个演示app BookShop(从<a class="ae km" href="https://github.com/ysadiq/BookShop/tree/develop/Final" rel="noopener ugc nofollow" target="_blank">下载BookShop app<strong class="jq io">这里</strong> </a>)给大家展示一下内存可视化和泄露。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi op"><img src="../Images/cef4ea39d3f168652abb7f777b30b2cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IMz-v5Ew4AjhoD9faDJZCg.png"/></div></div></figure><p id="c89a" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">演示应用程序是一个简单的两个视图和一个表格应用程序。它包含一个图书数据存根，带有我在<a class="ae km" rel="noopener ugc nofollow" target="_blank" href="/memory-management-part-1-regions-types-and-leaks-884c231f5135">第1部分:区域、结构和漏洞</a>中提到的出版社模型。</p><h1 id="71b3" class="md me in bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">Xcode内存调试器</h1><p id="5a45" class="pw-post-body-paragraph jn jo in jq b jr nb jt ju jv nc jx jy ld nd kb kc le ne kf kg lf nf kj kk kl ig bi translated">苹果在Xcode 8中引入了新的视觉内存调试器。运行书店应用程序并调试内存图。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi oq"><img src="../Images/dd0e57281fa8ccb605ab576e7852fed6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*3B_5RZ3CIU-5Y59jjfnt-A.gif"/></div></div></figure><p id="64ab" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">内存调试器中断应用程序的执行，并构建当前内存使用情况的可视化，使查找、诊断和修复内存泄漏变得更加容易。请注意，根据应用程序的大小，绘制图表可能需要一点时间。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi or"><img src="../Images/c0d515703723669e06c693eafa14fdd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tc56GtnZfxSGiK0k5rpNAA.png"/></div></div></figure><p id="a7e1" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">左侧的导航窗口显示了在堆上创建的对象，这些对象按类型和实例进行组织。</p><p id="a8ff" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">当您在导航器中选择一个对象时，中间部分将向您显示所选对象的内存图，以及它与其他对象的关系。关系的类型由箭头的样式表示。如果箭头是粗体的，这是强关系，否则是保守关系(🤔Swift不认，可能弱也可能强)。</p><p id="480b" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">有时，它是一个大图，有时，它是一个只有几个对象的小图。右侧的内存检查器显示了诸如大小、类层次结构和分配回溯等细节。</p><p id="a6d2" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">厉害！内存目前没有显示任何泄漏。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi oq"><img src="../Images/9b4485871230c51a63d10ed90753c8c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*5i8UhdlI4z8qiJWH6qB2Lg.gif"/></div></div></figure><p id="01a8" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">现在，取消暂停应用程序，并通过返回到根视图来释放当前视图和对象。然后再打开内存图。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi os"><img src="../Images/e7df04eb9f223a39b9ed8f06a0996390.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sp2MdB9JfE_vIMiVRYS8Kw.png"/></div></div></figure><p id="736e" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">哎呀！这本书既没有作者对象也没有被释放。发生这种情况是因为书强持有作者，而作者强持有数组列表中的书。这是一个导致内存泄漏的引用循环。你打开的书店视图越多，内存泄漏就越多。</p><p id="0483" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">正如我前面提到的，内存泄漏是指内存在某个时候被分配，但从未被释放，并且不再被您的应用程序引用。因为没有对它的引用，所以没有办法释放它，并且那个内存位置不能再次使用。</p><h1 id="0d65" class="md me in bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">定位泄漏源🕵🏽‍♂️</h1><p id="e53c" class="pw-post-body-paragraph jn jo in jq b jr nb jt ju jv nc jx jy ld nd kb kc le ne kf kg lf nf kj kk kl ig bi translated">如果您不知道从哪里开始查找，调试与内存相关的错误可能会非常耗时。幸运的是，Xcode包含了一些选项，可以在内存问题发生时识别这些问题。</p><p id="c771" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">Apple有Malloc库，它提供了调试功能来帮助跟踪:</p><ul class=""><li id="4dd5" class="lp lq in jq b jr js jv jw ld lr le ls lf lt kl lu lv lw lx bi translated">内存粉碎错误</li><li id="6197" class="lp lq in jq b jr ly jv lz ld ma le mb lf mc kl lu lv lw lx bi translated">堆损坏</li><li id="d4bf" class="lp lq in jq b jr ly jv lz ld ma le mb lf mc kl lu lv lw lx bi translated">对释放内存的引用</li><li id="890d" class="lp lq in jq b jr ly jv lz ld ma le mb lf mc kl lu lv lw lx bi translated">缓冲区溢出。</li></ul><p id="308c" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">默认情况下不启用此功能，您可以通过一组环境变量来启用这些调试选项。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi oq"><img src="../Images/a36645f528cb46c0abaaf41717cef52a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*eS04rCr1QixricWMHLvOpg.gif"/></div></div></figure><p id="e891" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">有很多Malloc环境变量，我现在关心的一个是<strong class="jq io"> Malloc堆栈日志，</strong> it <strong class="jq io"> </strong>允许<strong class="jq io"> </strong> malloc在每次分配时记住函数调用堆栈。</p><p id="b3e3" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">这是每个方案都支持的。不调试内存泄漏时，应该关闭malloc堆栈日志记录。因为它需要大量的记录过程，并且在调试过程中有些属性没有被完全记录下来。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi ot"><img src="../Images/51cc0a290f75294ddd5bd52302139212.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*agi_SvTx1M6fHOM8rrKvEA.png"/></div></div></figure><p id="51c1" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">如果您启用了malloc堆栈日志记录，回溯将向您显示代码中内存图中每个对象的分配行。通常，分配行是无害的，问题是在该行之前或之后。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi oq"><img src="../Images/46b3e4c0fab89b11c4394bd75d7774cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*jf6ZzWmkL-rkeFJtdLArZQ.gif"/></div></div></figure><p id="fbbe" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">正如我们在本文开头的图表中提到的，要修复这个内存泄漏，您必须将图书-作者关系更改为一个<strong class="jq io">无主关系</strong>。一本<strong class="jq io">书</strong>不能没有一个<strong class="jq io">作者，同时，一本书并不“拥有”作者。</strong></p><h1 id="d819" class="md me in bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">从这里去哪里？</h1><p id="c09c" class="pw-post-body-paragraph jn jo in jq b jr nb jt ju jv nc jx jy ld nd kb kc le ne kf kg lf nf kj kk kl ig bi translated">帮助您消除内存错误的3个最终提示:</p><ol class=""><li id="b43a" class="lp lq in jq b jr js jv jw ld lr le ls lf lt kl ou lv lw lx bi translated">为你的项目定义一个强大的代码风格，并尊重它。</li><li id="17a8" class="lp lq in jq b jr ly jv lz ld ma le mb lf mc kl ou lv lw lx bi translated">使用<a class="ae km" href="https://github.com/realm/SwiftLint" rel="noopener ugc nofollow" target="_blank">快速棉绒</a>。它是在编译时检测早期问题的一个很好的工具。</li><li id="67b7" class="lp lq in jq b jr ly jv lz ld ma le mb lf mc kl ou lv lw lx bi translated">经常分析应用程序，尤其是在使用Xcode内存调试器创建功能或修复请求之前。</li></ol><p id="7ae0" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">厉害！你已经到达这个迷你系列的结尾。</p><p id="e585" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">在本文中，您学习了如何打破类和闭包中的引用循环，Xcode内存调试器，以及如何使用Apple的Malloc库定位泄漏。</p><h2 id="bb54" class="nl me in bd mf nm nn dn mj no np dp mn ld nq nr mr le ns nt mv lf nu nv mz nw bi translated">参考</h2><p id="6f56" class="pw-post-body-paragraph jn jo in jq b jr nb jt ju jv nc jx jy ld nd kb kc le ne kf kg lf nf kj kk kl ig bi translated"><strong class="jq io">书籍<br/>-</strong>-<a class="ae km" href="https://www.raywenderlich.com/books/swift-apprentice" rel="noopener ugc nofollow" target="_blank">雨燕学徒</a>，Raywenderlich</p><p id="f54c" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated"><strong class="jq io">文章<br/> - </strong> <a class="ae km" href="https://swiftrocks.com/memory-management-and-performance-of-value-types.html" rel="noopener ugc nofollow" target="_blank">内存管理与值类型性能</a>、Swift Rocks <br/> <strong class="jq io"> - </strong> <a class="ae km" href="https://deepu.tech/memory-management-in-programming/" rel="noopener ugc nofollow" target="_blank">编程中的内存管理</a>、Deepu Tech <br/> <strong class="jq io"> - </strong> <a class="ae km" href="https://gribblelab.org/CBootCamp/7_Memory_Stack_vs_Heap.html" rel="noopener ugc nofollow" target="_blank">内存栈vs堆</a>、Gribble lab <br/> <strong class="jq io"> - </strong> <a class="ae km" href="https://medium.com/young-coder/an-illustrated-guide-to-memory-the-stack-the-heap-and-pointers-40a604f7bc53" rel="noopener">内存、栈、堆和指针图解指南</a>、年轻的编码者<br/> <strong class="jq io"> - </strong> <a class="ae km" href="https://useyourloaf.com/blog/xcode-visual-memory-debugger/" rel="noopener ugc nofollow" target="_blank"> Xcode 动动脑筋<br/> <strong class="jq io"> - </strong> </a><a class="ae km" href="https://doordash.engineering/2019/05/22/ios-memory-leaks-and-retain-cycle-detection-using-xcodes-memory-graph-debugger/" rel="noopener ugc nofollow" target="_blank">内存泄漏和保留周期检测</a>、DoorDash工程<br/>-<strong class="jq io">-</strong><a class="ae km" href="https://medium.com/flawless-app-stories/you-dont-always-need-weak-self-a778bec505ef" rel="noopener">你并不总是需要一个软弱的自我</a>，贝希尔·阿尔·马勒</p><p id="d839" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">我希望你喜欢这篇文章。如果你有任何问题或意见，不要犹豫，就把它们写在这里🤗。</p></div></div>    
</body>
</html>