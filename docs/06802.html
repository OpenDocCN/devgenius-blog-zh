<html>
<head>
<title>Design 101 : What is the Simple Factory Pattern?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计 101:简单工厂模式是什么？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/design-101-what-is-the-simple-factory-pattern-919d957458c8?source=collection_archive---------11-----------------------#2022-02-04">https://blog.devgenius.io/design-101-what-is-the-simple-factory-pattern-919d957458c8?source=collection_archive---------11-----------------------#2022-02-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="7a3e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">工厂设计模式基于一个简单的设计原则，即<strong class="jm io">我们必须识别可能改变的代码部分并封装它们</strong>，这样改变代码的可变部分就不需要改变代码库的其他部分。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/60ad7e8dbb0ce17158121f363b6bff85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*Wt6hkA0OTQpLuP49kFEE5Q.jpeg"/></div></figure><blockquote class="kq kr ks"><p id="1bfa" class="jk jl kt jm b jn jo jp jq jr js jt ju ku jw jx jy kv ka kb kc kw ke kf kg kh ig bi translated"><strong class="jm io">等等！封装是什么意思</strong>？<br/>在这种情况下，这具体意味着整个代码库不知道代码的特定部分是如何实现的，而是仅仅依赖于它所公开的接口，也就是说，在公开的接口改变之前，整个代码库不需要重构。</p></blockquote><p id="8644" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我将首先描述<strong class="jm io">简单工厂模式</strong>,并为单独的文章保留工厂方法和抽象工厂模式。<br/>我们可以通过 PizzaStore 的<strong class="jm io"> orderPizza() </strong>方法来理解这个模式</p><pre class="kj kk kl km gt kx ky kz la aw lb bi"><span id="20f8" class="lc ld in ky b gy le lf l lg lh">Pizza OrderPizza(String type) {<br/>    Pizza pizza;</span><span id="8724" class="lc ld in ky b gy li lf l lg lh">    /**<br/>     * This portion of the code is bound to change.<br/>     */<br/>    <strong class="ky io">if(type == "cheese") {<br/>        pizza = new CheesePizza();<br/>    } else if(type == "veg") {<br/>        pizza =  new VegPizza();<br/>    } else if(type == "chocochip") {<br/>        pizza =  new ChocoChipPizza();<br/>    } else {<br/>        pizza =  new BasicPizza();<br/>    }</strong></span><span id="e4c8" class="lc ld in ky b gy li lf l lg lh">    pizza.prepare();<br/>    pizza.bake();<br/>    pizza.cut();<br/>    pizza.box();<br/>    <br/>    return pizza;<br/>}</span></pre><p id="9421" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每当我们尝试引入任何新的比萨饼类型或删除任何旧的比萨饼类型时，使用 string 参数创建的比萨饼必定会发生变化。所以我们应该封装这部分代码。<br/>让我们把这部分封装成一个披萨工厂。</p><pre class="kj kk kl km gt kx ky kz la aw lb bi"><span id="d681" class="lc ld in ky b gy le lf l lg lh">Public Class SimplePizzaFactory {<br/>    Public Pizza createPizza(String type) {<br/>        Pizza pizza = null;<br/>        <strong class="ky io">if(type == "cheese") {<br/>            pizza = new CheesePizza();<br/>        } else if(type == "veg") {<br/>            pizza =  new VegPizza();<br/>        } else if(type == "chocochip") {<br/>            pizza =  new ChocoChipPizza();<br/>        } else {<br/>            pizza =  new BasicPizza();<br/>        }</strong><br/>        return pizza;<br/>    }<br/>}</span></pre><p id="a088" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">需要注意的细节！<br/> </strong> 1。看来我们只是打包了垃圾，把它埋得更深了。<br/> 2。披萨的创建现在是集中的，所以任何需要的更改都可以在这里完成，不需要在多个地方进行重构。<br/> 3。字符串参数看起来仍然很难看。</p><p id="de0e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">如果我们想要更多的参数，比如印度奶酪披萨和中国奶酪披萨不一样怎么办？<br/> </strong>如果我们再次使用简单工厂，除了类型参数之外，我们还需要添加另一个参数。更多字符串🤕！！</p><pre class="kj kk kl km gt kx ky kz la aw lb bi"><span id="7665" class="lc ld in ky b gy le lf l lg lh">Public Class SimplePizzaFactory {<br/>    Public Pizza createPizza(<strong class="ky io">String type, String place</strong>) {<br/>        Pizza pizza = null;<br/>        <br/>        if(place == "india") {<br/>            if(type == "cheese") {<br/>                pizza = new CheesePizza();<br/>            } else if(type == "veg") {<br/>                pizza =  new VegPizza();<br/>            } else if(type == "chocochip") {<br/>                pizza =  new ChocoChipPizza();<br/>            } else {<br/>                pizza =  new BasicPizza();<br/>            }<br/>        } else if(place == "china") {<br/>            //..<br/>        }</span><span id="3533" class="lc ld in ky b gy li lf l lg lh">        return pizza;<br/>    }<br/>}</span></pre><p id="2a09" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">工厂方法模式解决了这个问题，<strong class="jm io">将具体 Pizza 的实例化委托给子类。<br/> </strong>在本<a class="ae lj" href="https://lug0.medium.com/design-102-why-do-we-need-factory-method-pattern-a272385731e6" rel="noopener"> <strong class="jm io">篇</strong> </a> <strong class="jm io">中写的更多！</strong></p><p id="56f0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你觉得这篇文章很有见地，请给我一个掌声😄，快乐阅读！</p></div></div>    
</body>
</html>