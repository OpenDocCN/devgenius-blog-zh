<html>
<head>
<title>Feature: Ramming Enemy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">特点:冲撞敌人</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/feature-ramming-enemy-39984b3f5983?source=collection_archive---------14-----------------------#2021-05-13">https://blog.devgenius.io/feature-ramming-enemy-39984b3f5983?source=collection_archive---------14-----------------------#2021-05-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="4e6a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这篇文章将展示如何创造一个攻击性的敌人，当它在射程之内时会试图冲撞玩家。此外，敌人将确保玩家在他们面前，以避免向后移动，并有一个恢复期，如果没有被摧毁时，与玩家碰撞。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9a18f0e3c653314fc14ca263f6c14e36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*pRNh7Jx6tC0phKummUEO9Q.gif"/></div></div></figure><p id="f501" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">侵略敌人脚本将从抽象的阶级敌人继承。现在我们需要一些变量。首先是四个浮动，一个是检查敌人是否应该撞击的范围，第二个是撞击时的移动速度，第三个是恢复期的长度，最后一个是敌人看到的到达玩家的距离。还需要两个bools，一个用来知道玩家是否在射程内，另一个用来知道敌人是否正在恢复。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ku"><img src="../Images/1c51b67ba220b6a6e0484a93ee83400d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zyVQq2inWI49hb-5bPedKQ.png"/></div></div></figure><p id="66b1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们需要一个简单的用于恢复期的协程，它在恢复期之后关闭恢复。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi kv"><img src="../Images/b0c20544f98a190d2d82f025c80595a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qI9Ldp3DMj_a59WrbuiOpQ.png"/></div></div></figure><p id="f641" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们创建一个方法，返回一个与玩家距离的浮点数，并检查他们是否在敌人后面。首先null检查玩家，如果null返回正无穷大，然后检查玩家是否在敌人后面，如果是则返回正无穷大。如果玩家不是空的或者在敌人后面，我们返回敌人和玩家的距离。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi kw"><img src="../Images/a345ea822c9c0502a7a2982a44e3aad7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BIi7gJEb-6M2Fr0s1CK-9w.png"/></div></div></figure><p id="373d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来是一个方法，根据ram范围和与玩家的距离来改变敌人是否试图ram。首先，我们检查玩家的距离是否小于命中偏移量。如果是，我们将停止撞击，如果敌人没有死，我们将开始恢复期，并在两者之后结束这个方法。之后，我们检查玩家是否在击打范围内，并相应地改变球。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi kx"><img src="../Images/8dfcf7e9fdecf64e2584140f6a12864d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5L3vjLsWOGhACCKjRGJRgA.png"/></div></div></figure><p id="cbc3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当敌人在冲击范围内时，这个方法控制敌人向玩家的移动。为此，我们将使用Vector2 MoveTowards函数以撞击速度将敌人的位置移动到玩家的位置。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ky"><img src="../Images/2c1122939e5ef19a579639acee9ae490.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9gMX6RMeaFwDSDRY_yeMgg.png"/></div></div></figure><p id="63e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在敌人基地开始后，我们会检查玩家是否在攻击范围内。检查必须在之后调用，因为否则我们就没有玩家参考来检查。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi kz"><img src="../Images/184dbc955cdc6911008c6c0c592eedfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vmq7OYYvXEL9HUoU4hr_nw.png"/></div></div></figure><p id="fe43" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在被覆盖的更新中，在呼叫检查玩家是否在范围内之前，我们将确保敌人没有恢复。接下来，我们将根据玩家是否在攻击范围内以及敌人是否死亡来决定敌人的移动。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi la"><img src="../Images/46f875150359309d98e3985b353e2013.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fg2YBzDXuLgiUtepOwVLkw.png"/></div></div></figure><p id="5106" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在玩游戏时，这个新的敌人会在攻击范围内攻击玩家，但是当玩家在攻击范围之外，在敌人后面，或者当敌人正在恢复时，它会表现正常。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4c5d8cb8cfa48148f4b6f33c0435dbfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*XW2E8XzMeR2DhWTsjLhyQw.gif"/></div></div></figure></div></div>    
</body>
</html>