<html>
<head>
<title>Become a JavaScrip Guru | Array Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">成为 JavaScrip 大师|数组函数</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/become-a-javascrip-guru-array-functions-34be176033b0?source=collection_archive---------7-----------------------#2022-04-22">https://blog.devgenius.io/become-a-javascrip-guru-array-functions-34be176033b0?source=collection_archive---------7-----------------------#2022-04-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="3ccb" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">掌握基本的 JavaScript 数组函数</h2></div><p id="8167" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">学习利用 JavaScript 必须提供的各种数组方法对于成为一名优秀的 JavaScript 开发人员至关重要。因此，没有比现在更好的时间来发现每一个的复杂性，并将它们添加到您的开发工具带上。</p><p id="279c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本指南中，我们将讨论我认为最基本的数组方法:</p><ul class=""><li id="ba99" class="ky kz in ke b kf kg ki kj kl la kp lb kt lc kx ld le lf lg bi translated"><em class="lh"> Array.forEach() </em></li><li id="e5d6" class="ky kz in ke b kf li ki lj kl lk kp ll kt lm kx ld le lf lg bi translated"><em class="lh"> Array.sort() </em></li><li id="a843" class="ky kz in ke b kf li ki lj kl lk kp ll kt lm kx ld le lf lg bi translated"><em class="lh"> Array.find() </em></li><li id="2f3f" class="ky kz in ke b kf li ki lj kl lk kp ll kt lm kx ld le lf lg bi translated"><em class="lh"> Array.filter() </em></li><li id="0361" class="ky kz in ke b kf li ki lj kl lk kp ll kt lm kx ld le lf lg bi translated"><em class="lh"> Array.map() </em></li><li id="ea3c" class="ky kz in ke b kf li ki lj kl lk kp ll kt lm kx ld le lf lg bi translated"><em class="lh"> Array.reduce() </em></li><li id="26e8" class="ky kz in ke b kf li ki lj kl lk kp ll kt lm kx ld le lf lg bi translated"><em class="lh"> Array.join() </em></li><li id="4b90" class="ky kz in ke b kf li ki lj kl lk kp ll kt lm kx ld le lf lg bi translated"><em class="lh"> Array.slice() </em></li></ul><h1 id="0919" class="ln lo in bd lp lq lr ls lt lu lv lw lx jt ly ju lz jw ma jx mb jz mc ka md me bi translated">为每一个</h1><p id="b94c" class="pw-post-body-paragraph kc kd in ke b kf mf jo kh ki mg jr kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">ForEach 是相当于卑微的<code class="fe mk ml mm mn b">for</code>循环的新时代。<code class="fe mk ml mm mn b">for (let i = 0; i &lt; arr.length; i++) {}</code>的时代已经一去不复返了，因为 forEach 方法会在它所应用的数组中的每个连续索引处自然地循环遍历每个元素。arrow 函数中的代码在数组中的每个索引处运行一次。此数组方法没有返回值。例如:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi mo"><img src="../Images/2e19a032ebd9eaab8ec1f6c0478967b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-NFm26SicN3dnhs0ioKmAw.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">forEach 方法接收匿名箭头函数作为其参数。</figcaption></figure><h1 id="6a3f" class="ln lo in bd lp lq lr ls lt lu lv lw lx jt ly ju lz jw ma jx mb jz mc ka md me bi translated">分类</h1><p id="5160" class="pw-post-body-paragraph kc kd in ke b kf mf jo kh ki mg jr kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">排序方法<strong class="ke io"> <em class="lh">返回</em> </strong>一个新数组，该数组是其前一个数组排序后的等价数组。该方法接收一个箭头函数作为参数，其中箭头函数本身有两个参数。第一个“a”是给定索引处的当前元素，第二个“b”是下一个元素。这个数组方法自然理解数组的边界，因此不会溢出。arrow 函数的返回值通常是“a”和“b”的比较，并确定应用于数组的排序机制。例如:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi mo"><img src="../Images/9bef85e8ed14c758f62e33e49c24e04f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uo8VMb0A_2U0hH1XHQbWJQ.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">Array.sort()返回一个新的有序数组。</figcaption></figure><p id="87e4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一般来说，净返回值有三种排序含义:</p><ul class=""><li id="9327" class="ky kz in ke b kf kg ki kj kl la kp lb kt lc kx ld le lf lg bi translated">如果<strong class="ke io"> <em class="lh">返回值&gt;0</em></strong>；将“b”排在“a”之前。</li><li id="8f52" class="ky kz in ke b kf li ki lj kl lk kp ll kt lm kx ld le lf lg bi translated">如果<strong class="ke io"> <em class="lh">返回值&lt;0</em></strong>；将 a 排在 b 之前。</li><li id="52fe" class="ky kz in ke b kf li ki lj kl lk kp ll kt lm kx ld le lf lg bi translated">if<strong class="ke io">T31】returned value = = 0T33】；让‘a’&amp;‘b’保持原来的顺序。</strong></li></ul><p id="2cce" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该方法也可以应用于文本字符串，例如，您可能希望按字母顺序排列给定数组中的元素。</p><h1 id="703d" class="ln lo in bd lp lq lr ls lt lu lv lw lx jt ly ju lz jw ma jx mb jz mc ka md me bi translated">发现</h1><p id="f1d3" class="pw-post-body-paragraph kc kd in ke b kf mf jo kh ki mg jr kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">有时当我们有很长的数组时，特定元素的位置可能会非常模糊。幸运的是，我们可以使用 JavaScript 从数组中动态地查找、获取并返回所述元素；我们只需要具体说明我们在找什么。Find 方法还接收一个 arrow 函数，其中 arrow 函数接收当前索引处的元素作为其参数，并返回满足返回条件的第一个元素。</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ne"><img src="../Images/6b250ef19c2013afab33d1d18ba4f366.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Md0aaLyYUMVCdAWuNnO6AA.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">当返回的条件为<strong class="bd lp">真</strong>时，find 方法返回第一个值。</figcaption></figure><p id="2950" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">find 方法在功能上类似于 Filter，因为 Filter 方法返回一个新数组，其中包含满足给定条件的每个值。Find 方法只返回第一个遇到的真实实例的实际值。</p><h1 id="746d" class="ln lo in bd lp lq lr ls lt lu lv lw lx jt ly ju lz jw ma jx mb jz mc ka md me bi translated">过滤器</h1><p id="7592" class="pw-post-body-paragraph kc kd in ke b kf mf jo kh ki mg jr kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">Filter 方法遍历数组中的每个元素，并返回一个新数组，该数组包含满足返回条件的所有元素；即返回值为真。</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ne"><img src="../Images/e6c8a676c19e1f2704e06d5b5e7e0fb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c2QsvYjfvKsLz0nFp22YZw.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">不幸的是，“詹姆斯”不包含字母 n，因此被排除在外。</figcaption></figure><h1 id="173e" class="ln lo in bd lp lq lr ls lt lu lv lw lx jt ly ju lz jw ma jx mb jz mc ka md me bi translated">地图</h1><p id="f288" class="pw-post-body-paragraph kc kd in ke b kf mf jo kh ki mg jr kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">我喜欢想象 Map array 函数对数组中的每个元素进行转换，并返回一个包含这些转换后的元素的新数组。转换后的元素是从 arrow 函数返回的任何内容，其中 arrow 函数作为 Map 方法的参数给出。两个例子可能是:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nf"><img src="../Images/d03cc090251245bc7b0b35f18f74b553.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ld0jnMDHps1cOq799r3xEg.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">我们可以看到返回的元素构造了转换后的数组。</figcaption></figure><p id="d820" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这里我们可以看到，第一个 Map 方法返回一个修改后的字符串，其中每个元素都有一个“Dr”作为前缀，第二个 Map 返回一个新数组，其中所有原始值都经过转换，值中增加了 4。</p><h1 id="74e7" class="ln lo in bd lp lq lr ls lt lu lv lw lx jt ly ju lz jw ma jx mb jz mc ka md me bi translated">减少</h1><p id="d384" class="pw-post-body-paragraph kc kd in ke b kf mf jo kh ki mg jr kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">Reduce 可能是最复杂的数组方法，也是统治所有数组的方法之一。对于任何开发人员来说，Reduce 方法都是一个真正有价值的资产，它是您想要的任何东西的最终累积构建器。此外，Reduce 方法可以模拟大多数其他数组方法的行为；最值得注意的是 Map、Filter 和 ForEach 方法。</p><p id="4768" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">reduce 方法有两个参数。第一个是箭头函数，它本身有两个参数；累积项和当前元素项:</p><pre class="mp mq mr ms gt ng mn nh ni aw nj bi"><span id="f7ee" class="nk lo in mn b gy nl nm l nn no">(accumulator, current) =&gt; { ... }</span><span id="7463" class="nk lo in mn b gy np nm l nn no">//or</span><span id="62f4" class="nk lo in mn b gy np nm l nn no">(acc, curr) =&gt; { ... }</span></pre><p id="9a9e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">其中累加器项假定从先前迭代返回的值。第二个 Reduce 参数是一个初始值，由 Reduce 循环的第一个索引上的累加器项假定。</p><p id="131e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一个简单的例子就是对一组数字求和:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nf"><img src="../Images/689b1cac57c75208ab6933bb147c6ee3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A8grtaTQru6vgliKOT9rqg.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">我们可以看到累加器项假设了前一次迭代的返回值。</figcaption></figure><p id="4794" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">“acc”或累加器项实际上是累加整个数组中每个索引处的当前值。它本质上允许我们构建自定义输出。</p><p id="de16" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们还可以在 sum 中包含一个过滤器功能；例如，如果我们想对除数字 5 之外的所有值求和:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nf"><img src="../Images/12ac30d425351cc6f22f5fe707b1c5ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2AkltS8t3Qx5ctN4DZhbZw.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">在本例中，我们将当前元素添加到累加项中，除非它等于 5。</figcaption></figure><p id="c2cf" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">arrow 函数还可以接收第三个可选参数，即当前迭代索引。</p><p id="4c1c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以下是我们应用 Reduce 方法的另外三种独特方式:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nf"><img src="../Images/69b32127a35be698dc3e77ec32ee3689.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P6XDZgJpET7QE1qoSyeZjA.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">我们如何产生字符串、数组和对象的三个独立的例子。</figcaption></figure><p id="3dd6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这些示例显示了应用 Reduce 方法的灵活性。我们可以用它来调整 JavaScript 对象和数组，并产生各种不同类型的输出。这是对我们开发人员工具带的一个真正伟大的补充。</p><h1 id="d85e" class="ln lo in bd lp lq lr ls lt lu lv lw lx jt ly ju lz jw ma jx mb jz mc ka md me bi translated">加入</h1><p id="8350" class="pw-post-body-paragraph kc kd in ke b kf mf jo kh ki mg jr kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">Join 方法构造并返回一个数组中所有不同元素的字符串。我们可以简单地应用该方法，而不传递参数:<code class="fe mk ml mm mn b">[...array].join()</code>，在这种情况下，我们将产生一个带有逗号分隔条目的字符串，或者我们可以将一个字符串作为参数传递，其中字符串的内容将用于分隔每个术语。</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nf"><img src="../Images/30a1f4934fa7dc9ce940e3877410bccf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jhF53WCQFYLGgPO_0iNvWg.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">我们将元素连接成一个字符串，每个元素之间用“香蕉”术语分隔。</figcaption></figure><h1 id="c89f" class="ln lo in bd lp lq lr ls lt lu lv lw lx jt ly ju lz jw ma jx mb jz mc ka md me bi translated">薄片</h1><p id="87e0" class="pw-post-body-paragraph kc kd in ke b kf mf jo kh ki mg jr kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">最后但同样重要的是，我们有切片方法。这个数组方法根据提供给它的索引参数返回一个分片的副本数组。如果提供单个索引作为参数，slice 方法将返回一个新数组，该数组包含该数组中的所有值，但不包括指定索引处的值。如果提供了两个数字索引，将返回一个数组，其中包含从第一个索引(含)到第二个索引(不含)的元素。需要注意的是，切片法支持<strong class="ke io"> <em class="lh">负索引。</em> </strong>这种方法不会变异原来的阵列。</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nf"><img src="../Images/6f2e77f9b3aeaa532a8d5c9c8b65c9c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6FFsVtzHS-Jg0XvXDfyVtw.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">根据指定的索引创建一个新数组。</figcaption></figure><p id="d306" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">恭喜你，你现在是 JavaScript 数组大师了。这个数组方法的列表并不详尽，所以如果你想知道如何实现任何其他独特的数组方法，一定要留下评论。</p></div></div>    
</body>
</html>