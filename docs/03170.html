<html>
<head>
<title>Best Features of ES2019 — Catch, Sort, and toString</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ES2019的最佳特性—捕捉、排序和toString</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/best-features-of-es2019-catch-sort-and-tostring-2b8a0d4b8ad8?source=collection_archive---------2-----------------------#2020-10-07">https://blog.devgenius.io/best-features-of-es2019-catch-sort-and-tostring-2b8a0d4b8ad8?source=collection_archive---------2-----------------------#2020-10-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0ef9a33a769cd3a2219acfa060c0dc58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3HjRbPRLqlSSdJTG"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@fbazanegue?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杨奇煜·巴赞内格</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="ac18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自2015年以来，JavaScript有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解ES2019的最佳特性。</p><h1 id="7b4e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">捕捉绑定</h1><p id="4323" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在ES2019中，绑定现在是可选的。</p><p id="2a65" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="dda1" class="mq lc iq mh b gy mr ms l mt mu">let jsonData;<br/>try {<br/>  jsonData = JSON.parse(str);<br/>} catch {<br/>  jsonData = {};<br/>}</span></pre><p id="366b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们就不需要在<code class="fe me mf mg mh b">catch</code>后面的括号里得到被抛出的对象。</p><p id="0870" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，其他与解析无关的错误将被忽略，因为我们只是将<code class="fe me mf mg mh b">jsonData</code>对象设置为一个空对象。</p><p id="baf1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个例子是获取深度嵌套的属性。</p><p id="f4ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以这样写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="fb33" class="mq lc iq mh b gy mr ms l mt mu">function logId(item) {<br/>  let id;<br/>  try {<br/>    id = item.data.id;<br/>  } catch {<br/>    console.log(id);<br/>  }<br/>}</span></pre><p id="5445" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了让我们安全地获得<code class="fe me mf mg mh b">item</code>到<code class="fe me mf mg mh b">id</code>的深度嵌套的<code class="fe me mf mg mh b">id</code>属性(如果它存在的话)。</p><p id="d520" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果不存在，那么运行<code class="fe me mf mg mh b">catch</code>块中的代码。</p><h1 id="cd18" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe me mf mg mh b">Stable Array.prototype.sort()</code></h1><p id="8d52" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">Array.prototype.sort</code>方法现在保证是稳定的。</p><p id="cc8f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，如果在排序时某些东西被认为是相同的，那么它们将在支持ES2019的引擎中保持相同的顺序。</p><p id="20d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="51cf" class="mq lc iq mh b gy mr ms l mt mu">const arr = [{<br/>    key: 'foo',<br/>    value: 1<br/>  },<br/>  {<br/>    key: 'bar',<br/>    value: 2<br/>  },<br/>  {<br/>    key: 'foo',<br/>    value: 3<br/>  },<br/>];<br/>arr.sort((x, y) =&gt; x.key.localeCompare(y.key, 'en'));</span></pre><p id="a26d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe me mf mg mh b">arr</code>将处于相同的顺序，不管它在哪个环境中。</p><h1 id="0748" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe me mf mg mh b">JSON.stringify</code></h1><p id="7603" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">JSON.stringify</code>现在可以单独代孕了。</p><p id="a314" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c263" class="mq lc iq mh b gy mr ms l mt mu">JSON.stringify('\u{D800}')</span></pre><p id="d572" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8e83" class="mq lc iq mh b gy mr ms l mt mu">""\ud800""</span></pre><h1 id="1915" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">JSON超集</h1><p id="04e4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">JSON字符串现在可以有<code class="fe me mf mg mh b">'"\u2028"'</code>字符。</p><h1 id="ddcd" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe me mf mg mh b">Function.prototype.toString Changes</code></h1><p id="164d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">Function.prototype.toString</code>现在从ES2019开始有一些变化。</p><p id="d19d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们定义的函数返回一个带有原始源代码的字符串。</p><p id="7a16" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们用内置函数调用<code class="fe me mf mg mh b">toString</code>，那么我们会看到<code class="fe me mf mg mh b">[native code]</code>。</p><p id="4190" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9c7c" class="mq lc iq mh b gy mr ms l mt mu">isNaN.toString()</span></pre><p id="dfca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="26cb" class="mq lc iq mh b gy mr ms l mt mu">"function isNaN() { [native code] }"</span></pre><p id="f1b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用<code class="fe me mf mg mh b">Function</code>和<code class="fe me mf mg mh b">GeneratorFunction</code>引擎动态创建的函数必须创建适当的源代码并将其附加到函数上。</p><p id="21c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有其他情况都会引发类型错误。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/5c84e9c336f0d6ae4330279d16b2bbd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bxffbfrh8mPLSbCE"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@acfb5071?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">基思·约翰斯顿</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="f2f1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="013d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Catch绑定，函数<code class="fe me mf mg mh b">toString</code>，<code class="fe me mf mg mh b">sort</code>方法都和ES2019有变化。</p></div></div>    
</body>
</html>