<html>
<head>
<title>Singly linked list in GoLang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GoLang中的单链表</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/singly-linked-list-in-golang-bb90a96c9933?source=collection_archive---------9-----------------------#2020-06-11">https://blog.devgenius.io/singly-linked-list-in-golang-bb90a96c9933?source=collection_archive---------9-----------------------#2020-06-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="d058" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大家好。在过去的几个月里，我一直在尝试golang，这是非常有趣的学习。我正在分享一个实现链表的代码片段。</p><p id="76e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">众所周知，链表是一种包含值和指向下一个值的指针(或指向下一个值的位置)的数据结构。只要堆空间没有用完，链表可以动态增长。一个链表看起来大概是这样的:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/85f17d2517228148e167f8c1161e9c6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*8q2VCw7NAgO_j7u7i5WXSw.png"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">我的漂亮链表</figcaption></figure><p id="0613" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们看看如何在golang中实现这个简单的单链表，我们将在其中插入新值并打印它们。</p><pre class="km kn ko kp gt kx ky kz la aw lb bi"><span id="f704" class="lc ld iq ky b gy le lf l lg lh">type Node struct {<br/> Data int<br/> Next *Node<br/>}</span></pre><p id="73d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是非常常见的节点定义。第一行声明<code class="fe li lj lk ky b">Node</code>是用户定义的数据类型。它包含两个字段<code class="fe li lj lk ky b">Data</code>和<code class="fe li lj lk ky b">Next</code>。关于结构，需要了解的几件事是:</p><ol class=""><li id="ccaa" class="ll lm iq jp b jq jr ju jv jy ln kc lo kg lp kk lq lr ls lt bi translated">这些是复合数据类型。</li><li id="983e" class="ll lm iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">可以包含不同类型的值。</li><li id="b059" class="ll lm iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">这些值被称为<em class="lz">字段</em>。</li></ol><p id="62c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们看看如何添加一个节点:</p><pre class="km kn ko kp gt kx ky kz la aw lb bi"><span id="d0f3" class="lc ld iq ky b gy le lf l lg lh">func (n *Node) AddNode(data int) {<br/> newNode := Node{data, nil}<br/> iter := n<br/> for iter.Next != nil {<br/>  iter = iter.Next<br/> }<br/> iter.Next = &amp;newNode<br/>}</span></pre><p id="63d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一行将函数<code class="fe li lj lk ky b">AddNode</code>声明为类型<code class="fe li lj lk ky b">*Node</code>。<code class="fe li lj lk ky b">n *Node</code>被称为<em class="lz">接收器</em>。<code class="fe li lj lk ky b">AddNode</code>接受<code class="fe li lj lk ky b">int</code>类型的参数。<code class="fe li lj lk ky b">newNode := Node{data, nil}</code>定义了一个<code class="fe li lj lk ky b">Node</code>类型的变量<code class="fe li lj lk ky b">newNode</code>，并用两个值<code class="fe li lj lk ky b">data</code>和<code class="fe li lj lk ky b">nil</code>初始化。接下来的4行在链表中为<code class="fe li lj lk ky b">newNode</code>对象找到一个合适的位置，并把它放在那里。</p><p id="2f19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过用接收方<code class="fe li lj lk ky b">n *Node</code>声明<code class="fe li lj lk ky b">AddNode</code>，我们确保了<code class="fe li lj lk ky b">AddNode</code>只能用<code class="fe li lj lk ky b">*Node</code>类型的变量来调用。简单来说，这就是golang定义成员函数的风格。</p><p id="85b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看如何显示这些值:</p><pre class="km kn ko kp gt kx ky kz la aw lb bi"><span id="be29" class="lc ld iq ky b gy le lf l lg lh">func (n *Node) PrintNode() {<br/> iter := n<br/> for iter != nil {<br/>  fmt.Println(iter.Data)<br/>  iter = iter.Next<br/> }<br/>}</span></pre><p id="69f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经用<code class="fe li lj lk ky b">n *Node</code>接收器声明了<code class="fe li lj lk ky b">PrintNode</code>。它迭代通过<code class="fe li lj lk ky b">n</code>指向的<code class="fe li lj lk ky b">Node</code>打印每个<code class="fe li lj lk ky b">Data</code>。现在让我们看看主要方法:</p><pre class="km kn ko kp gt kx ky kz la aw lb bi"><span id="034b" class="lc ld iq ky b gy le lf l lg lh">func main() {<br/> newNode := Node{10, nil}<br/> newNode.AddNode(20)<br/> newNode.AddNode(30)<br/> newNode.AddNode(40)<br/> newNode.PrintNode()<br/>}</span></pre><p id="7b56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们所见，<code class="fe li lj lk ky b">AddNode</code>和<code class="fe li lj lk ky b">PrintNode</code>必须使用<code class="fe li lj lk ky b">Node</code>类型的变量(或接收器)来调用。如果我们尝试在没有任何接收器的情况下调用<code class="fe li lj lk ky b">AddNode</code>,将会导致以下错误:</p><pre class="km kn ko kp gt kx ky kz la aw lb bi"><span id="bfaf" class="lc ld iq ky b gy le lf l lg lh">func main() {<br/> newNode := Node{10, nil}<br/> newNode.AddNode(20)<br/> newNode.AddNode(30)<br/> newNode.AddNode(40)<br/> AddNode(10) //Will result in compilation error<br/> newNode.PrintNode()<br/>}</span><span id="df09" class="lc ld iq ky b gy ma lf l lg lh">go build -o linkedlist.out linkedlist.go</span><span id="932f" class="lc ld iq ky b gy ma lf l lg lh">./linkedlist.go:34:2: undefined: AddNode</span></pre><p id="6152" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完整代码可在此处获得<a class="ae mb" href="https://gist.github.com/sandeep-sarkar/dc6a04884638f04dda9f852e7735cae9" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/sandeep-sarkar/dc6a 04884638 f 04 DDA 9 f 852 e 7735 CAE 9</a></p><p id="743a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">目前就这些。希望你喜欢它。请随意发表评论。这将有助于我提高。</p></div></div>    
</body>
</html>