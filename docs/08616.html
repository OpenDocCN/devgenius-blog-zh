<html>
<head>
<title>An Introduction to Service Discovery</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">服务发现简介</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/introduction-to-service-discovery-34c5149f1587?source=collection_archive---------4-----------------------#2022-06-28">https://blog.devgenius.io/introduction-to-service-discovery-34c5149f1587?source=collection_archive---------4-----------------------#2022-06-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="caaf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">🚀<a class="ae kl" href="https://learnbackend.dev/books/build-layered-microservices" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">打造分层微服务</strong> </a>这本书出来了！现在就在<a class="ae kl" href="https://learnbackend.dev/books/build-layered-microservices" rel="noopener ugc nofollow" target="_blank"> learnbackend.dev </a>购买你自己的副本。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/19f56c12adc99af2f188d2b085af677b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mGVK5EdCKj9z77uSXfBWUw.jpeg"/></div></div></figure><p id="3978" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在传统的应用程序中，服务实例的网络位置通常是相当静态的，可以从配置文件中加载，而配置文件是由系统管理员不时手动更新的。</p><p id="9a9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不幸的是，对于在虚拟化或容器化环境中运行的现代基于微服务的应用程序，这种解决方案几乎不起作用，因为实例的数量及其位置会动态变化。</p><p id="5e07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种动态性源于这样一个事实，即服务的生命周期通常是以秒或分钟来衡量的，因为它们会被放大或缩小、升级或干脆失效。</p><p id="cfee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们必须实现一种机制，使服务能够相互定位，以便通过它们的 API 进行通信，这种机制称为<strong class="jp ir">服务发现</strong>。</p><p id="21f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管有许多可能的实现，但它们通常包括一个维护服务网络位置列表的中央服务器，称为<strong class="jp ir">服务注册表</strong>，以及连接到该中央服务器以更新和解析它们的客户端。</p><h1 id="f45c" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">服务注册</h1><p id="09b1" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated"><strong class="jp ir">服务注册中心</strong>是一个高度可用的数据库，包含各种服务实例的网络位置，并且是<strong class="jp ir">服务发现</strong>机制的主要组件，但是与基础设施的其他服务不同，它需要部署在一个固定且众所周知的 IP 地址上，以便于访问。</p><p id="7957" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简而言之，它允许服务在启动和关闭时通过发送它们的网络位置和其他信息(例如它们的名称或版本号)来注册和注销它们自己，以便让其他服务知道它们的存在。</p><p id="a206" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除此之外，服务还可以定期发送一种特殊类型的消息，称为<strong class="jp ir">心跳</strong>，这样服务注册中心就知道它们仍然可用并准备好接收请求。</p><p id="7e16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也就是说，注册服务有两种方式。</p><h2 id="da9f" class="mb kz iq bd la mc md dn le me mf dp li jy mg mh lm kc mi mj lq kg mk ml lu mm bi translated">自行注册</h2><p id="435a" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">第一种是最简单的，称为<strong class="jp ir">自注册</strong>，因为它通过直接连接到注册中心，让服务负责管理自己的注册。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mn"><img src="../Images/a7b9d5152a998a89b0badbe05fa6b95c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BxqmeA7nwjHsRDC_Y3VWGw.png"/></div></div></figure><p id="da23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，这种方法将服务耦合到注册中心，因为注册代码必须在每个服务中以每种编程语言实现。</p><h2 id="f2e3" class="mb kz iq bd la mc md dn le me mf dp li jy mg mh lm kc mi mj lq kg mk ml lu mm bi translated">第三方注册</h2><p id="251f" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">第二种方法是第三方注册，其中一个名为<strong class="jp ir">注册器</strong>的组件跟踪运行环境中服务的变化，并根据它们的状态自动注册或注销它们。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mo"><img src="../Images/1af7772e10aa008148aa558bb89b07ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-w5YPgAodHs2hhXCGYxEpg.png"/></div></div></figure><p id="bdad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从不再需要在每个服务中实现注册逻辑的意义上来说，这是非常好的，但是它向需要正确设置和管理的基础设施中引入了一个具有高可用性的附加组件。</p><h1 id="c3d6" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">服务发现模式</h1><h2 id="5cf6" class="mb kz iq bd la mc md dn le me mf dp li jy mg mh lm kc mi mj lq kg mk ml lu mm bi translated">客户端发现</h2><p id="d2ad" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">当使用<strong class="jp ir">客户端发现模式</strong>时，客户端负责通过查询<strong class="jp ir">服务注册中心获取可用服务实例的网络位置。</strong></p><p id="af81" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它允许客户端通过<strong class="jp ir">负载平衡</strong>请求来做出特定于应用的决定，例如使用像<strong class="jp ir">循环</strong>这样的算法。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mp"><img src="../Images/a6b414a84f4a29e85a7c77194f97a043.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c8BbGLFrcAC8tSVz4EFg3w.png"/></div></div></figure><p id="9fb2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">主要的问题是，每个客户端必须有一个查询逻辑的实现，因此可能每个语言或框架都有一个。例如，一个用 JavaScript 实现你的网站，另一个用 Java 实现你的 Android 应用。</p><h2 id="ba9e" class="mb kz iq bd la mc md dn le me mf dp li jy mg mh lm kc mi mj lq kg mk ml lu mm bi translated">服务器端发现</h2><p id="cd40" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">当使用<strong class="jp ir">服务器端发现模式</strong>时，客户端将其请求发送到<strong class="jp ir">路由器</strong>，路由器将负责查询<strong class="jp ir">注册服务</strong>，并使用自己的负载平衡算法将该请求重新路由到可用的实例。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mq"><img src="../Images/36eb847d3a4d46e6c92869872037bfee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y_8qTvDj0F_NvAmqo6Jyyg.png"/></div></div></figure><p id="057d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种模式的优点是发现逻辑从客户机中移除，但是您必须记住，它引入了一个需要小心管理的新的敏感组件，因为负载平衡器必须高度可用，因为没有它，任何请求都不会到达任何服务。</p><h1 id="fc88" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">下一步是什么？</h1><p id="70dc" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">不要忘记👏🏻x50 如果你喜欢读我的作品！</p><p id="f1b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">👉你喜欢这种内容？查看 https://learnbackend.dev 上的书<a class="ae kl" href="https://learnbackend.dev/books/build-layered-microservices" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">Build Layered micro services</strong></a>了解如何使用 Express framework 构建一个生产就绪的分层认证微服务，从第一行代码到最后一行文档，它在开发实践和软件架构方面符合行业标准。</p></div></div>    
</body>
</html>