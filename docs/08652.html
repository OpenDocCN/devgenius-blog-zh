<html>
<head>
<title>Redis Optimization: 1 % at a time</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redis 优化:一次 1 %</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/redis-optimization-1-at-a-time-3c3c5084be7b?source=collection_archive---------13-----------------------#2022-06-30">https://blog.devgenius.io/redis-optimization-1-at-a-time-3c3c5084be7b?source=collection_archive---------13-----------------------#2022-06-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="153b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Redis 一般来说很快。它每秒可以处理大约 50 万到 1 百万个查询。然而，总有一些改进的余地。每个变更背后都涉及到各种各样的因素，这取决于开发人员在给定时间点的优先级。总的来说，在 Salvatore 维护 Redis 时，重点是可读性和简单性。我将讨论一个小的改进，它不会妨碍可读性，并且仍然有一些性能增益。我们走吧。</p><h1 id="2529" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">问题</h1><p id="e9bb" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">Redis 的核心是单线程的，因此热路径上的任何优化都有利于更快的执行。Redis 事务允许在一个步骤中执行一组命令。事务中的所有命令都被缓冲并一起顺序执行。这保证了其他客户端不会在正在进行的操作之间受到服务。通过发送一个<code class="fe ll lm ln lo b">MULTI</code>命令来启动一个事务，然后跟随一组命令，这些命令被排队，直到服务器接收到<code class="fe ll lm ln lo b">EXEC</code>命令。</p><p id="e427" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文的剩余部分，我将重点关注命令的排队。</p><p id="bbf4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">来自<a class="ae lp" href="https://github.com/redis/redis/blob/7.0/src/multi.c#L59-L88" rel="noopener ugc nofollow" target="_blank"> redis </a> <code class="fe ll lm ln lo b">multi.c</code>文件的代码片段:</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="9e26" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每当一个命令在事务中排队时，就会执行上面的<code class="fe ll lm ln lo b">queueMultiCommand</code>方法。如果我们观察第 12 行，会发现有一个<code class="fe ll lm ln lo b">zrealloc</code>方法会依次调用<code class="fe ll lm ln lo b">realloc</code>系统调用。随后，命令的状态被初始化。</p><p id="a34b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">快速浏览一下 syscall 是什么。</p><p id="db53" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">系统调用(syscall)是一种编程方式，在这种方式下，计算机程序向执行它的操作系统内核请求服务。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/fb107e45fa21fb6bc73c1d048bb57b4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*NQ2s63dg_HOTtqN59K4MPQ.png"/></div></figure><p id="1b0e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的例子中，服务器正在系统调用 RAM 中的额外空间。</p><p id="a855" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在回到 Redis 代码段，对于每个执行服务器，将内存分配扩展一定的大小。“realloc”将根据它所在的内存段表现不同。当我们在这种情况下进行扩展时，重新分配可以通过两种方式进行:</p><ol class=""><li id="f768" class="ma mb in jm b jn jo jr js jv mc jz md kd me kh mf mg mh mi bi translated">扩展当前内存，旧数据保持在同一位置，新的内存区域未定义。</li><li id="1f6c" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">新的内存块被分配到所请求的大小，旧的数据被复制到该位置的起始处，旧的内存块被释放。</li></ol><p id="309e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以，这个手术可能会很贵。为了避免这种情况，我想不出什么解决办法。我们来讨论一下。</p><h1 id="ecb8" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">解决方案</h1><ol class=""><li id="7aa9" class="ma mb in jm b jn lg jr lh jv mo jz mp kd mq kh mf mg mh mi bi translated"><strong class="jm io">使用线性增长</strong> <strong class="jm io"> <br/> </strong>代替请求单个额外的分配块，我们可以一起请求 X 个块的内存。当保留的内存块完全用完时，我们可以请求更多的 X 块，依此类推。</li><li id="2cc2" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated"><strong class="jm io">使用指数增长<br/> </strong>或者，我们可以使用指数增长，也就是说，我们以 2 次方的增量请求内存。这将把系统调用次数从 O(N)次减少到 O(logN)次。</li><li id="ca3f" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated"><strong class="jm io">使用静态内存块+上述<br/> </strong>中的任何一个我们也可以避免动态分配内存，我们可以选择静态分配内存。我们可以根据过去使用的数据点选择一些常数。假设在 MULTI/EXEC 块中排队的命令的平均数量是 16 个命令，我们可以保留(16 * <code class="fe ll lm ln lo b">multiCmd</code>)的静态存储器块，并且如果排队的 MULTI 命令少于 16 个，则不会发生存储器分配/解除分配。如果它超过 16，那么我们将不得不退回到上述方法之一。</li></ol><p id="f7e2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是下面的代码片段，我已经修改了代码，以使用我们刚刚讨论过的指数增长方法。我从大小为 2 的默认预留开始，作为大小为&lt; 2, would be same as single command execution and then increase the size in multiple of 2.</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="b325" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">You could also find the entire change over here:</p><div class="mr ms gp gr mt mu"><a href="https://github.com/hpatro/redis/commit/25bb6e9ebde5c0c7b1da810335d5e9afdc707475" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab fo"><div class="mw ab mx cl cj my"><h2 class="bd io gy z fp mz fr fs na fu fw im bi translated">Optimize number of realloc syscall during multi/exec flow. · hpatro/redis@25bb6e9</h2><div class="nb l"><h3 class="bd b gy z fp mz fr fs na fu fw dk translated">Redis is an in-memory database that persists on disk. The data model is key-value, but many different kind of values…</h3></div><div class="nc l"><p class="bd b dl z fp mz fr fs na fu fw dk translated">github.com</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni ly mu"/></div></div></a></div><p id="9664" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">You could also take this as an exercise and implement the remaining approach(es) and profile to see if there is a gain.</p><h1 id="38d6" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">Profiling</h1><p id="416c" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">Theoretically it looks like we are going to reduce the number of syscalls however we need to prove the gain by profiling or benchmarking. So, I’m going to profile the  【T1】  process while sending continuous requests of  【T2】  blocks with  【T3】  commands within them. In order to do profiling, I’m going to use few of the linux tools like  【T4】  and  【T5】  to visualize the data.</p><p id="4540" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Redis provides a nice blog around how to do <a class="ae lp" href="https://redis.io/docs/reference/optimization/cpu-profiling/" rel="noopener ugc nofollow" target="_blank">的 multi/exec CPU 配置文件</a>，我还将对其进行一些讨论。</p><h2 id="1e8e" class="nj kj in bd kk nk nl dn ko nm nn dp ks jv no np kw jz nq nr la kd ns nt le nu bi translated">脚本</h2><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="10f2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个脚本是用 python 编写的，并使用了<code class="fe ll lm ln lo b">redis-py</code>库。在这个脚本中，<code class="fe ll lm ln lo b">r.pipeline()</code>启动一个<code class="fe ll lm ln lo b">MULTI</code>块并对 100 个<code class="fe ll lm ln lo b">MSET</code>命令进行排队，然后在一个无限循环中执行。*</p><p id="e8b9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了分析<code class="fe ll lm ln lo b">redis-server</code>的用户和内核堆栈，我们将使用以下命令捕获 3 分钟的性能数据。</p><pre class="lq lr ls lt gt nv lo nw nx aw ny bi"><span id="79a3" class="nj kj in lo b gy nz oa l ob oc">$ perf record -g --pid $(pgrep redis-server) -F 999 -- sleep 180</span></pre><p id="4159" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦捕获了性能数据，我们可以使用以下命令使用<code class="fe ll lm ln lo b">flamegraph</code>来可视化它。</p><pre class="lq lr ls lt gt nv lo nw nx aw ny bi"><span id="ad85" class="nj kj in lo b gy nz oa l ob oc">$ perf script &gt; redis.perf.stacks<br/>$ stackcollapse-perf.pl redis.perf.stacks &gt; redis.folded.stacks<br/>$ flamegraph.pl redis.folded.stacks &gt; redis.svg</span></pre><p id="7f29" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是结果(svg 文件的快照):</p><p id="c7e7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">未经优化</strong></p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="oe of di og bf oh"><div class="gh gi od"><img src="../Images/a2c12b2c230c59f86c3da14ecc5d1196.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AX3DDI6xqslrtR9lFaE-ng.png"/></div></div></figure><p id="7064" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">同优化</strong></p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="oe of di og bf oh"><div class="gh gi oi"><img src="../Images/6a42c17ef1d8da5a84db6757028112fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WCQsD_jtmeCsSmZzjUAnyQ.png"/></div></div></figure><p id="84d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从上面的图中我们可以清楚地看到，对“zrealloc”的调用数量下降了，CPU 使用率也下降了 1%多一点。</p><p id="16d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">更新:上面的修改被合并到 Redis 库，耶！！！</p><div class="mr ms gp gr mt mu"><a href="https://github.com/redis/redis/commit/a3704d4e87b65a9c071b9dd1ead04cc338d3bc18" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab fo"><div class="mw ab mx cl cj my"><h2 class="bd io gy z fp mz fr fs na fu fw im bi translated">优化 multi/exec 流期间 realloc syscall 的数量(#10921) redis/redis@a3704d4</h2><div class="nb l"><h3 class="bd b gy z fp mz fr fs na fu fw dk translated">Redis 是持久存储在磁盘上的内存数据库。数据模型是键值，但是许多不同种类的值…</h3></div><div class="nc l"><p class="bd b dl z fp mz fr fs na fu fw dk translated">github.com</p></div></div><div class="nd l"><div class="oj l nf ng nh nd ni ly mu"/></div></div></a></div><p id="a3f9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是我在这篇文章中要写的内容。我计划写一篇关于 Redis 7 中分片发布订阅特性的文章，这是我最近写的。如果您喜欢这篇文章，请关注我，获取关于系统软件、Redis 等的有趣文章。</p></div></div>    
</body>
</html>