<html>
<head>
<title>C++ Exception Handling Best Practices: 7 Things To Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++异常处理最佳实践:需要知道的 7 件事</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/7-best-practices-for-exception-handling-in-c-with-example-daa92d90fb3d?source=collection_archive---------1-----------------------#2019-11-09">https://blog.devgenius.io/7-best-practices-for-exception-handling-in-c-with-example-daa92d90fb3d?source=collection_archive---------1-----------------------#2019-11-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/9127fc9806dba55a3b1b9d4191cc8735.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y07msVVc_-9zFlZhX-bOIQ.jpeg"/></div></div></figure><p id="c06d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你观察学习曲线的初始阶段，C++中的异常处理是一个很好的非学校主题。网上有很多关于 C++异常处理的教程和例子。但是很少有人解释你不应该做什么&amp;围绕它的错综复杂。所以在这里，我们将看到一些错综复杂的东西，从哪里&amp;为什么你不应该抛出一个异常，以及在<a class="ae kt" href="http://www.vishalchovatiya.com/21-new-features-of-modern-cpp-to-use-in-your-project/" rel="noopener ugc nofollow" target="_blank"> Modern C++ </a>中引入的一些新特性，比如异常处理。我不是专家，但这是我从各种渠道、课程和行业经验中获得的。</p><p id="e092" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，我们将通过一个快速基准测试代码看到使用异常的<a class="ae kt" href="https://dev.to/visheshpatel/7-best-practices-for-exception-handling-in-c-with-example-2n6c-temp-slug-7895093?preview=1e2652c454694a8cb8808781d22f19dd8afcd01a55784bbb8e0597db971dbc34e2103b38673cdf8a59dbafd8f5f3420c84d297da2fac5ddf8fcdc2fd#Runtime-cost-of-exceptions-with-quick-benchmark" rel="noopener ugc nofollow" target="_blank">性能成本。最后，我们将以</a><a class="ae kt" href="https://dev.to/visheshpatel/7-best-practices-for-exception-handling-in-c-with-example-2n6c-temp-slug-7895093?preview=1e2652c454694a8cb8808781d22f19dd8afcd01a55784bbb8e0597db971dbc34e2103b38673cdf8a59dbafd8f5f3420c84d297da2fac5ddf8fcdc2fd#Best-practices-&amp;-some-CPP-Core-Guidelines-on-exception-handling" rel="noopener ugc nofollow" target="_blank">最佳实践&amp;关于异常处理的一些 CPP 核心指南</a>来结束这篇文章。</p><blockquote class="ku kv kw"><p id="2ee8" class="jv jw kx jx b jy jz ka kb kc kd ke kf ky kh ki kj kz kl km kn la kp kq kr ks ig bi translated">/!\:顺便说一下，这是我的<a class="ae kt" href="http://www.vishalchovatiya.com/7-best-practices-for-exception-handling-in-cpp-with-example/" rel="noopener ugc nofollow" target="_blank">博客</a>的交叉帖子。</p></blockquote><p id="8b8b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="kx">注意</em> </strong> <em class="kx">:我们不会看到任何关于动态异常的东西，因为它在 C++11 中已被弃用，在 C++17 中已被移除。</em></p><h1 id="6944" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">您可能面临的术语/行话/习语</h1><ul class=""><li id="beec" class="lz ma in jx b jy mb kc mc kg md kk me ko mf ks mg mh mi mj bi translated"><strong class="jx io">潜在抛出</strong>:可能抛出也可能不抛出异常。</li><li id="82cc" class="lz ma in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated"><strong class="jx io"> noexcept </strong>:这是说明符，也是运算符，取决于你在哪里使用它。稍后会看到<a class="ae kt" href="https://dev.to/visheshpatel/7-best-practices-for-exception-handling-in-c-with-example-2n6c-temp-slug-7895093?preview=1e2652c454694a8cb8808781d22f19dd8afcd01a55784bbb8e0597db971dbc34e2103b38673cdf8a59dbafd8f5f3420c84d297da2fac5ddf8fcdc2fd#noexcept-specifier-vs-operator" rel="noopener ugc nofollow" target="_blank">和</a>。</li><li id="76b2" class="lz ma in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated"><a class="ae kt" href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Resource_Acquisition_Is_Initialization" rel="noopener ugc nofollow" target="_blank"><strong class="jx io">RAII</strong></a>:<strong class="jx io">R</strong>esource<strong class="jx io">A</strong>acquisition<strong class="jx io">I</strong>s<strong class="jx io">I</strong>初始化是一种限定范围的资源管理机制，这意味着在对象的定义范围内，资源分配由构造函数完成&amp;资源释放由析构函数完成。我知道这是一个可怕的名字，但非常强大的概念。</li><li id="ff96" class="lz ma in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated"><a class="ae kt" href="https://stackoverflow.com/questions/11671282/implicitly-declared-special-member-functions" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">隐式声明的特殊成员函数</strong> </a>:我想这个不用介绍了。</li></ul><h1 id="7afc" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">1.抛出用户定义的类型对象时复制并移动构造函数</h1><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="9647" class="my lc in mu b gy mz na l nb nc">struct demo<br/>{<br/>    demo() = default;<br/>    demo(demo &amp;&amp;) = delete;<br/>    demo(const demo &amp;) = delete;<br/>};</span><span id="4b6c" class="my lc in mu b gy nd na l nb nc">int main()<br/>{<br/>    throw demo{};<br/>    return 0;<br/>}</span></pre><ul class=""><li id="f629" class="lz ma in jx b jy jz kc kd kg ne kk nf ko ng ks mg mh mi mj bi translated">在 throw 表达式中，当原始对象在堆栈展开过程中超出范围时，总是需要创建异常对象的副本。</li><li id="ed8a" class="lz ma in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated">在初始化过程中，我们可能会期望<a class="ae kt" href="https://en.wikipedia.org/wiki/Copy_elision" rel="noopener ugc nofollow" target="_blank">复制省略</a>(参见<a class="ae kt" href="https://wg21.cmeerw.net/cwg/issue1493" rel="noopener ugc nofollow" target="_blank">这个</a> ) —省略<a class="ae kt" href="http://www.vishalchovatiya.com/move-constructor-assignment-operator-with-shared-ptr/" rel="noopener ugc nofollow" target="_blank">复制或移动构造函数</a>(对象被直接构造到目标对象的存储中)。</li><li id="4054" class="lz ma in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated">但是即使复制省略可能被应用，也可能不被应用，你应该提供正确的复制构造函数和/或移动构造函数，这是 C++标准要求的(见 15.1)。请参见下面的编译错误以供参考。</li></ul><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="7993" class="my lc in mu b gy mz na l nb nc">error: call to deleted constructor of 'demo'<br/>    throw demo{};<br/>          ^~~~~~<br/>note: 'demo' has been explicitly marked deleted here<br/>    demo(demo &amp;&amp;) = delete;<br/>    ^<br/>1 error generated.<br/>compiler exit status 1</span></pre><ul class=""><li id="2ca3" class="lz ma in jx b jy jz kc kd kg ne kk nf ko ng ks mg mh mi mj bi translated">如果我们通过值来捕获异常，我们可能还会遇到复制省略(编译器允许这样做，但不是强制的)。初始化 catch 子句参数时，exception 对象是一个左值参数。</li></ul><blockquote class="ku kv kw"><p id="9236" class="jv jw kx jx b jy jz ka kb kc kd ke kf ky kh ki kj kz kl km kn la kp kq kr ks ig bi translated"><em class="in">TL；用于抛出异常对象的类 DR <br/>需要复制和/或移动构造函数</em></p></blockquote><h1 id="6f04" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">2.从构造函数中引发异常</h1><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="c878" class="my lc in mu b gy mz na l nb nc">struct base<br/>{<br/>    base(){cout&lt;&lt;"base\n";}<br/>    ~base(){cout&lt;&lt;"~base\n";}<br/>};</span><span id="393e" class="my lc in mu b gy nd na l nb nc">struct derive : base<br/>{<br/>    derive(){cout&lt;&lt;"derive\n"; throw -1;}<br/>    ~derive(){cout&lt;&lt;"~derive\n";}<br/>};</span><span id="0273" class="my lc in mu b gy nd na l nb nc">int main()<br/>{<br/>    try{<br/>        derive{};<br/>    }<br/>    catch (...){}<br/>    return 0;<br/>}</span></pre><ul class=""><li id="48e2" class="lz ma in jx b jy jz kc kd kg ne kk nf ko ng ks mg mh mi mj bi translated">当构造函数抛出一个异常时，栈展开开始，对象的析构函数将被调用&amp;只有当一个对象被成功创建时。所以这里要小心动态内存分配。在这种情况下，您应该使用 RAII。</li></ul><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="3c39" class="my lc in mu b gy mz na l nb nc">base<br/>derive<br/>~base</span></pre><ul class=""><li id="23d8" class="lz ma in jx b jy jz kc kd kg ne kk nf ko ng ks mg mh mi mj bi translated">正如你在上面的例子中看到的，<code class="fe nh ni nj mu b">derive</code>的析构函数没有被执行，因为，它没有被成功创建。</li></ul><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="9f36" class="my lc in mu b gy mz na l nb nc">struct base<br/>{<br/>    base() { cout &lt;&lt; "base\n"; }<br/>    ~base() { cout &lt;&lt; "~base\n"; }<br/>};</span><span id="2960" class="my lc in mu b gy nd na l nb nc">struct derive : base<br/>{<br/>    derive() = default;<br/>    derive(int) : derive{}<br/>    {<br/>        cout &lt;&lt; "derive\n";<br/>        throw - 1;<br/>    }<br/>    ~derive() { cout &lt;&lt; "~derive\n"; }<br/>};</span><span id="6bf4" class="my lc in mu b gy nd na l nb nc">int main()<br/>{<br/>    try{<br/>        derive{0};<br/>    }<br/>    catch (...){}<br/>    return 0;<br/>}</span></pre><ul class=""><li id="d64e" class="lz ma in jx b jy jz kc kd kg ne kk nf ko ng ks mg mh mi mj bi translated">在构造函数委托的情况下，它被认为是对象的创建，因此将调用<code class="fe nh ni nj mu b">derive</code>的析构函数。</li></ul><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="8455" class="my lc in mu b gy mz na l nb nc">base<br/>derive<br/>~derive<br/>~base</span></pre><blockquote class="ku kv kw"><p id="7d88" class="jv jw kx jx b jy jz ka kb kc kd ke kf ky kh ki kj kz kl km kn la kp kq kr ks ig bi translated"><em class="in">TL；DR <br/>当一个异常从一个构造函数抛出时，只有当一个对象被成功创建时，才会调用这个对象的析构函数&amp;</em></p></blockquote><h1 id="e4df" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">3.从析构函数中抛出异常</h1><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="3101" class="my lc in mu b gy mz na l nb nc">struct demo<br/>{<br/>    ~demo() { throw std::exception{}; }<br/>};</span><span id="d3db" class="my lc in mu b gy nd na l nb nc">int main()<br/>{<br/>    try{<br/>        demo d;<br/>    }<br/>    catch (const std::exception &amp;){}<br/>    return 0;<br/>}</span></pre><ul class=""><li id="7e0f" class="lz ma in jx b jy jz kc kd kg ne kk nf ko ng ks mg mh mi mj bi translated">上面的代码看起来很简单，但是当你运行它的时候，它会像下面这样被终止，而不是捕捉异常。原因是析构函数默认为<code class="fe nh ni nj mu b">noexcept</code>(即不抛出)</li></ul><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="2c42" class="my lc in mu b gy mz na l nb nc">$ clang++-7 -o main main.cpp<br/>warning: '~demo' has a non-throwing exception specification but can still<br/>      throw [-Wexceptions]<br/>    ~demo() { throw std::exception{}; }<br/>              ^<br/>note: destructor has a implicit non-throwing exception specification<br/>    ~demo() { throw std::exception{}; }<br/>    ^<br/>1 warning generated.<br/>$<br/>$ ./main<br/>terminate called after throwing an instance of 'std::exception'<br/>  what():  std::exception<br/>exited, aborted</span></pre><ul class=""><li id="dfca" class="lz ma in jx b jy jz kc kd kg ne kk nf ko ng ks mg mh mi mj bi translated"><code class="fe nh ni nj mu b">noexcept(false)</code>将如下解决我们的问题</li></ul><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="5e20" class="my lc in mu b gy mz na l nb nc">struct X<br/>{<br/>    ~X() noexcept(false) { throw std::exception{}; } <br/>};</span></pre><ul class=""><li id="95e3" class="lz ma in jx b jy jz kc kd kg ne kk nf ko ng ks mg mh mi mj bi translated">但是不要这样做。析构函数默认是不抛出的，这是有原因的，我们不能在析构函数中抛出异常，除非我们在析构函数内部捕捉到它们。</li></ul><p id="7beb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">为什么不应该从析构函数中抛出异常？</strong></p><p id="e186" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因为当抛出一个异常时，析构函数在栈展开过程中被调用，并且我们不允许在前一个异常未被捕获时抛出另一个异常——在这种情况下，将调用<code class="fe nh ni nj mu b">std::terminate</code>。</p><ul class=""><li id="d44c" class="lz ma in jx b jy jz kc kd kg ne kk nf ko ng ks mg mh mi mj bi translated">为了更清楚起见，考虑下面的例子。</li></ul><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="ebc8" class="my lc in mu b gy mz na l nb nc">struct base<br/>{<br/>    ~base() noexcept(false) { throw 1; }<br/>};</span><span id="74e5" class="my lc in mu b gy nd na l nb nc">struct derive : base<br/>{<br/>    ~derive() noexcept(false) { throw 2; }<br/>};</span><span id="313a" class="my lc in mu b gy nd na l nb nc">int main()<br/>{<br/>    try{<br/>        derive d;<br/>    }<br/>    catch (...){ }<br/>    return 0;<br/>}</span></pre><ul class=""><li id="7544" class="lz ma in jx b jy jz kc kd kg ne kk nf ko ng ks mg mh mi mj bi translated">当 RAII 导致对象<code class="fe nh ni nj mu b">d</code>被销毁时，将抛出异常。但同时也会调用<code class="fe nh ni nj mu b">base</code>的析构函数，因为<code class="fe nh ni nj mu b">derive</code>的<a class="ae kt" href="http://www.vishalchovatiya.com/memory-layout-of-cpp-object/" rel="noopener ugc nofollow" target="_blank">子对象</a>会再次抛出异常。现在我们同时有两个异常，将调用无效场景&amp; <code class="fe nh ni nj mu b">std::terminate</code>。</li></ul><p id="2476" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有一些类型特征工具，如<code class="fe nh ni nj mu b">std::is_nothrow_destructible</code>、<code class="fe nh ni nj mu b">std::is_nothrow_constructible</code>等。从<code class="fe nh ni nj mu b">#include&lt;type_traits&gt;</code>可以检查特殊成员函数是否是异常安全的。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="6ae3" class="my lc in mu b gy mz na l nb nc">int main()<br/>{<br/>    cout &lt;&lt; std::boolalpha &lt;&lt; std::is_nothrow_destructible&lt;std::string&gt;::value &lt;&lt; endl;<br/>    cout &lt;&lt; std::boolalpha &lt;&lt; std::is_nothrow_constructible&lt;std::string&gt;::value &lt;&lt; endl;<br/>    return 0;<br/>}</span></pre><blockquote class="ku kv kw"><p id="141a" class="jv jw kx jx b jy jz ka kb kc kd ke kf ky kh ki kj kz kl km kn la kp kq kr ks ig bi translated"><em class="in">TL；博士</em></p></blockquote><ul class=""><li id="a040" class="lz ma in jx b jy jz kc kd kg ne kk nf ko ng ks mg mh mi mj bi translated">默认情况下，析构函数没有异常(即不抛出)</li><li id="6daa" class="lz ma in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated">您不应该从析构函数中抛出异常，因为当抛出异常时，析构函数是在堆栈展开期间调用的，并且我们不允许在未捕捉到前一个异常时抛出另一个异常——在这种情况下，将调用 std::terminate。</li></ul><h1 id="24f3" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">4.用 std::exception_ptr 重新抛出和嵌套异常</h1><p id="c0cd" class="pw-post-body-paragraph jv jw in jx b jy mb ka kb kc mc ke kf kg nk ki kj kk nl km kn ko nm kq kr ks ig bi translated">下面的例子演示了使用<code class="fe nh ni nj mu b">std::exception_ptr</code>(在 C++11 中引入)的嵌套异常场景。虽然您可以简单地使用<code class="fe nh ni nj mu b">std::exception</code>而不会使事情变得复杂，但是<code class="fe nh ni nj mu b">std::exception_ptr</code>将为我们提供处理<code class="fe nh ni nj mu b">try</code> / <code class="fe nh ni nj mu b">catch</code>子句之外的异常的杠杆作用。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="48dc" class="my lc in mu b gy mz na l nb nc">void print_nested_exception(const std::exception_ptr &amp;eptr=std::current_exception(), size_t level=0)<br/>{<br/>    static auto get_nested = [](auto &amp;e) -&gt; std::exception_ptr {<br/>        try { return dynamic_cast&lt;const std::nested_exception &amp;&gt;(e).nested_ptr(); }<br/>        catch (const std::bad_cast&amp;) { return nullptr; }<br/>    };</span><span id="a02c" class="my lc in mu b gy nd na l nb nc">    try{<br/>        if (eptr) std::rethrow_exception(eptr);<br/>    }<br/>    catch (const std::exception &amp;e){<br/>        std::cerr &lt;&lt; std::string(level, ' ') &lt;&lt; "exception: " &lt;&lt; e.what() &lt;&lt; '\n';<br/>        print_nested_exception(get_nested(e), level + 1);// rewind all nested exception<br/>    }<br/>}<br/>// -----------------------------------------------------------------------------------------------<br/>void func2(){<br/>    try         { throw std::runtime_error("TESTING NESTED EXCEPTION SUCCESS"); }<br/>    catch (...) { std::throw_with_nested(std::runtime_error("func2() failed")); }<br/>}</span><span id="b61c" class="my lc in mu b gy nd na l nb nc">void func1(){<br/>    try         { func2(); }<br/>    catch (...) { std::throw_with_nested(std::runtime_error("func1() failed")); }<br/>}</span><span id="4ed4" class="my lc in mu b gy nd na l nb nc">int main()<br/>{<br/>    try                             { func1(); }<br/>    catch (const std::exception&amp;)   { print_nested_exception(); }<br/>    return 0;<br/>}<br/>// Will only work with C++14 or above</span></pre><ul class=""><li id="3911" class="lz ma in jx b jy jz kc kd kg ne kk nf ko ng ks mg mh mi mj bi translated">上面的例子初看起来很复杂，但是一旦你实现了嵌套的异常处理程序(即<code class="fe nh ni nj mu b">print_nested_exception</code>)。然后你只需要关注使用<code class="fe nh ni nj mu b">std::throw_with_nested</code>函数抛出异常。</li></ul><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="81b8" class="my lc in mu b gy mz na l nb nc">exception: func1() failed<br/> exception: func2() failed<br/>  exception: TESTING NESTED EXCEPTION SUCCESS</span></pre><ul class=""><li id="5e66" class="lz ma in jx b jy jz kc kd kg ne kk nf ko ng ks mg mh mi mj bi translated">这里主要关注的是<code class="fe nh ni nj mu b">print_nested_exception</code>函数，我们在其中使用<code class="fe nh ni nj mu b">std::rethrow_exception</code> &amp; <code class="fe nh ni nj mu b">std::exception_ptr</code>来倒回嵌套异常。</li><li id="dfff" class="lz ma in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated"><code class="fe nh ni nj mu b">std::exception_ptr</code>是一个共享的指针类型，尽管解引用它是未定义的行为。它可以保存<code class="fe nh ni nj mu b">nullptr</code>或指向一个异常对象，可以被构造为:</li></ul><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="5609" class="my lc in mu b gy mz na l nb nc">std::exception_ptr e1;                                             // null<br/>std::exception_ptr e2 = std::current_exception();                  // null or a current exception<br/>std::exception_ptr e3 = std::make_exception_ptr(std::exception{}); // std::exception</span></pre><ul class=""><li id="45ae" class="lz ma in jx b jy jz kc kd kg ne kk nf ko ng ks mg mh mi mj bi translated">一旦<code class="fe nh ni nj mu b">std::exception_ptr</code>被创建，我们可以通过调用<code class="fe nh ni nj mu b">std::rethrow_exception(exception_ptr)</code>来使用它来抛出或重新抛出异常，就像我们上面所做的那样，这将抛出指向的异常对象。</li></ul><blockquote class="ku kv kw"><p id="39b7" class="jv jw kx jx b jy jz ka kb kc kd ke kf ky kh ki kj kz kl km kn la kp kq kr ks ig bi translated"><em class="in">TL；博士</em></p></blockquote><ul class=""><li id="4c2a" class="lz ma in jx b jy jz kc kd kg ne kk nf ko ng ks mg mh mi mj bi translated">std::exception_ptr 将指向的异常对象的生存期扩展到 catch 子句之外。</li><li id="8441" class="lz ma in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated">我们可以使用 std::exception_ptr 来延迟当前异常的处理，并将其转移到其他一些地方。特别是，我们还可以在线程之间传递 std::exception_ptr。</li></ul><h1 id="d213" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">5.noexcept 说明符 vs 运算符</h1><ul class=""><li id="d03b" class="lz ma in jx b jy mb kc mc kg md kk me ko mf ks mg mh mi mj bi translated">我认为在 C++异常的其他概念中，这是一个被遗忘的概念。</li><li id="547e" class="lz ma in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated"><code class="fe nh ni nj mu b">noexcept</code> <a class="ae kt" href="https://en.cppreference.com/w/cpp/language/noexcept_spec" rel="noopener ugc nofollow" target="_blank">说明符</a> &amp; <a class="ae kt" href="https://en.cppreference.com/w/cpp/language/noexcept" rel="noopener ugc nofollow" target="_blank">运算符</a>在 C++11 中出现，以取代已弃用(从 C++17 中移除)的动态异常规范。</li></ul><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="6324" class="my lc in mu b gy mz na l nb nc">void func() throw(std::exception);                   // dynamic excpetions, removed from C++17</span><span id="25af" class="my lc in mu b gy nd na l nb nc">void potentially_throwing();                         // may throw<br/>void non_throwing() noexcept;                        // "specifier" specifying non-throwing function</span><span id="05a8" class="my lc in mu b gy nd na l nb nc">void print() {}                                  <br/>void (*func_ptr)() noexcept = print;                 // Not OK from C++17, `print()` should be noexcept too, works in C++11/14</span><span id="8cd2" class="my lc in mu b gy nd na l nb nc">void debug_deep() noexcept(false) {}                 // specifier specifying throw<br/>void debug() noexcept(noexcept(debug_deep())) {}     // specifier &amp; operator, will follow exception rule of `debug_deep`</span><span id="6414" class="my lc in mu b gy nd na l nb nc">auto l_non_throwing = []() noexcept {};              // Yeah..! lambdas are also in party</span></pre><h1 id="1ec0" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">无异常说明符</h1><p id="c37a" class="pw-post-body-paragraph jv jw in jx b jy mb ka kb kc mc ke kf kg nk ki kj kk nl km kn ko nm kq kr ks ig bi translated">我认为这不需要介绍，顾名思义。因此，让我们快速浏览一些要点:</p><ul class=""><li id="7f84" class="lz ma in jx b jy jz kc kd kg ne kk nf ko ng ks mg mh mi mj bi translated">可用于普通函数、<a class="ae kt" href="http://www.vishalchovatiya.com/learn-lambda-function-in-cpp-with-example/" rel="noopener ugc nofollow" target="_blank">方法、</a>lambda 函数、&amp;函数指针。</li><li id="baf2" class="lz ma in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated">从 C++17 开始，没有异常的函数指针不能指向潜在的抛出函数。</li><li id="5a83" class="lz ma in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated">最后，不要对基类/接口中的<a class="ae kt" href="http://www.vishalchovatiya.com/part-1-all-about-virtual-keyword-in-cpp-how-virtual-function-works-internally/" rel="noopener ugc nofollow" target="_blank">虚函数</a>使用<code class="fe nh ni nj mu b">noexcept</code>说明符，因为它会对所有重写施加限制。</li><li id="f137" class="lz ma in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated">除非真的需要，否则不要使用 noexcept。“当它有用并且正确的时候指定它”——谷歌的 CPP guide<a class="ae kt" href="https://google.github.io/styleguide/cppguide.html#noexcept" rel="noopener ugc nofollow" target="_blank">。</a></li></ul><h1 id="be18" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">noexcept 操作符&amp;它有什么用途？</h1><ul class=""><li id="e19f" class="lz ma in jx b jy mb kc mc kg md kk me ko mf ks mg mh mi mj bi translated">在 C++11 中增加了，<code class="fe nh ni nj mu b">noexcept</code>操作符接受一个表达式(不一定是常量)并执行编译时检查，确定该表达式是不抛出(<code class="fe nh ni nj mu b">noexcept</code>)还是可能抛出。</li><li id="72a0" class="lz ma in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated">例如，这种编译时检查的结果可用于将<code class="fe nh ni nj mu b">noexcept</code>说明符添加到同一类别、更高级的函数<code class="fe nh ni nj mu b">(noexcept(noexcept(expr)))</code>或 in if <code class="fe nh ni nj mu b"><a class="ae kt" href="http://www.vishalchovatiya.com/when-to-use-const-vs-constexpr-in-cpp/" rel="noopener ugc nofollow" target="_blank">constexpr</a></code>。</li><li id="38cb" class="lz ma in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated">我们可以使用 noexcept 运算符来检查某个类是否有 noexcept 构造函数、noexcept 复制构造函数、noexcept 移动构造函数等等，如下所示:</li></ul><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="01e5" class="my lc in mu b gy mz na l nb nc">class demo<br/>{<br/>public:<br/>    demo() {}<br/>    demo(const demo &amp;) {}<br/>    demo(demo &amp;&amp;) {}<br/>    void method() {}<br/>};</span><span id="e114" class="my lc in mu b gy nd na l nb nc">int main()<br/>{<br/>    cout &lt;&lt; std::boolalpha &lt;&lt; noexcept(demo()) &lt;&lt; endl;                        // C<br/>    cout &lt;&lt; std::boolalpha &lt;&lt; noexcept(demo(demo())) &lt;&lt; endl;                  // CC<br/>    cout &lt;&lt; std::boolalpha &lt;&lt; noexcept(demo(std::declval&lt;demo&gt;())) &lt;&lt; endl;    // MC<br/>    cout &lt;&lt; std::boolalpha &lt;&lt; noexcept(std::declval&lt;demo&gt;().method()) &lt;&lt; endl; // Methods<br/>}<br/>// std::declval&lt;T&gt; returns an rvalue reference to a type</span></pre><ul class=""><li id="12bb" class="lz ma in jx b jy jz kc kd kg ne kk nf ko ng ks mg mh mi mj bi translated">您一定想知道为什么&amp;这些信息会有用吗？当您在函数中使用库函数来提示编译器您的函数是抛出还是不抛出(取决于库的实现)时，这就更有用了。</li><li id="3165" class="lz ma in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated">如果您移除构造函数，<a class="ae kt" href="http://www.vishalchovatiya.com/all-about-copy-constructor-in-cpp/" rel="noopener ugc nofollow" target="_blank">复制构造函数</a> &amp; <a class="ae kt" href="http://www.vishalchovatiya.com/move-constructor-assignment-operator-with-shared-ptr/" rel="noopener ugc nofollow" target="_blank">移动构造函数</a>，它将打印<code class="fe nh ni nj mu b">true</code>原因被隐式声明的特殊成员函数总是不抛出。</li></ul><blockquote class="ku kv kw"><p id="4e4c" class="jv jw kx jx b jy jz ka kb kc kd ke kf ky kh ki kj kz kl km kn la kp kq kr ks ig bi translated"><em class="in">TL；DR <br/> noexcept 说明符&amp;运算符是两回事。noexcept 运算符执行编译时检查&amp;不计算表达式。While noexcept 说明符只能接受计算结果为 true 或 false 的常量表达式。</em></p></blockquote><h1 id="0899" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">6.使用移动语义和异常安全移动</h1><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="59e9" class="my lc in mu b gy mz na l nb nc">struct demo<br/>{<br/>    demo() = default;<br/>    demo(const demo &amp;) { cout &lt;&lt; "Copying\n"; }<br/>    // Exception safe move constructor<br/>    demo(demo &amp;&amp;) noexcept { cout &lt;&lt; "Moving\n"; }<br/>private:<br/>    std::vector&lt;int&gt;    m_v;<br/>};</span><span id="64cd" class="my lc in mu b gy nd na l nb nc">int main()<br/>{<br/>    demo obj1;</span><span id="e9c1" class="my lc in mu b gy nd na l nb nc">    if (noexcept(demo(std::declval&lt;demo&gt;()))){  // if moving safe<br/>        demo obj2(std::move(obj1));             // then move it<br/>    }<br/>    else{<br/>        demo obj2(obj1);                        // otherwise copy it<br/>    }</span><span id="f696" class="my lc in mu b gy nd na l nb nc">    demo obj3(std::move_if_noexcept(obj1));     // Alternatively you can do this----------------<br/>    return 0;<br/>}</span></pre><ul class=""><li id="320f" class="lz ma in jx b jy jz kc kd kg ne kk nf ko ng ks mg mh mi mj bi translated">我们可以使用<code class="fe nh ni nj mu b">noexcept(T(std::declval&lt;T&gt;()))</code>来检查<code class="fe nh ni nj mu b">T</code>的 move 构造函数是否存在并且是<code class="fe nh ni nj mu b">noexcept</code>，以便决定我们是否想要通过移动<code class="fe nh ni nj mu b">T</code>的另一个实例来创建<code class="fe nh ni nj mu b">T</code>的一个实例(使用<code class="fe nh ni nj mu b">std::move</code>)。</li><li id="154f" class="lz ma in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated">或者，我们可以使用<code class="fe nh ni nj mu b">std::move_if_noexcept</code>，它使用<code class="fe nh ni nj mu b">noexcept</code>操作符并转换为<a class="ae kt" href="http://www.vishalchovatiya.com/lvalue-rvalue-and-their-references-with-example-in-cpp/" rel="noopener ugc nofollow" target="_blank">右值或左值</a>。此类检查用于<code class="fe nh ni nj mu b">std::vector</code>和其他容器。</li><li id="3ac8" class="lz ma in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated">当您处理不想丢失的关键数据时，这将非常有用。例如，我们有从服务器接收的关键数据，我们不希望在处理过程中不惜任何代价丢失这些数据。在这种情况下，我们应该使用<code class="fe nh ni nj mu b">std::move_if_noexcept</code>，它将只移动关键数据的所有权，并且只有在移动构造函数是异常安全的情况下。</li></ul><blockquote class="ku kv kw"><p id="e359" class="jv jw kx jx b jy jz ka kb kc kd ke kf ky kh ki kj kz kl km kn la kp kq kr ks ig bi translated"><em class="in">TL；DR <br/>使用 std::move_if_noexcept </em>安全移动关键对象</p></blockquote><h1 id="39bd" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">7.基准异常的性能成本</h1><p id="0dfc" class="pw-post-body-paragraph jv jw in jx b jy mb ka kb kc mc ke kf kg nk ki kj kk nl km kn ko nm kq kr ks ig bi translated">尽管有很多好处，大多数人仍然不喜欢使用异常，因为它的开销很大。所以让我们澄清一下:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="0928" class="my lc in mu b gy mz na l nb nc">static void without_exception(benchmark::State &amp;state){<br/>    for (auto _ : state){<br/>        std::vector&lt;uint32_t&gt; v(10000);<br/>        for (uint32_t i = 0; i &lt; 10000; i++) v.at(i) = i;        <br/>    }<br/>}<br/>BENCHMARK(without_exception);//----------------------------------------</span><span id="c20b" class="my lc in mu b gy nd na l nb nc">static void with_exception(benchmark::State &amp;state){<br/>    for (auto _ : state){<br/>        std::vector&lt;uint32_t&gt; v(10000);<br/>        for (uint32_t i = 0; i &lt; 10000; i++){<br/>            try{<br/>                v.at(i) = i;<br/>            }<br/>            catch (const std::out_of_range &amp;oor){}<br/>        }<br/>    }<br/>}<br/>BENCHMARK(with_exception);//--------------------------------------------</span><span id="5c92" class="my lc in mu b gy nd na l nb nc">static void throwing_exception(benchmark::State &amp;state){<br/>    for (auto _ : state){<br/>        std::vector&lt;uint32_t&gt; v(10000);<br/>        for (uint32_t i = 1; i &lt; 10001; i++){<br/>            try{<br/>                v.at(i) = i;<br/>            }<br/>            catch (const std::out_of_range &amp;oor){}<br/>        }<br/>    }<br/>}<br/>BENCHMARK(throwing_exception);//-----------------------------------------</span></pre><ul class=""><li id="d2e2" class="lz ma in jx b jy jz kc kd kg ne kk nf ko ng ks mg mh mi mj bi translated">从上面可以看出，<code class="fe nh ni nj mu b">with_exception</code> &amp; <code class="fe nh ni nj mu b">without_exception</code>只有一个区别即语法异常。但是它们都没有抛出任何异常。</li><li id="d70f" class="lz ma in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated">而<code class="fe nh ni nj mu b">throwing_exception</code>执行相同的任务，只是在最后一次迭代中抛出了一个<code class="fe nh ni nj mu b">std::out_of_range</code>类型的异常。</li><li id="9b0a" class="lz ma in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated">正如您在下面的条形图中看到的，最后一个条形图比前两个略高，显示了抛出异常的成本。</li><li id="2cc7" class="lz ma in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated">但是使用 exception 的<strong class="jx io">成本在这里是零</strong>，因为前两个条是相同的。</li><li id="b84f" class="lz ma in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated">我在这里不考虑优化，这是一个单独的例子，因为它完全修改了一些汇编指令。顺便说一下，如果你想了解更多，我正在使用一个内部使用<a class="ae kt" href="https://github.com/google/benchmark" rel="noopener ugc nofollow" target="_blank"> Google 基准</a>的<a class="ae kt" href="http://quick-bench.com/qgpMiwVmHomfDmoLsPkb_i-Qw7M" rel="noopener ugc nofollow" target="_blank">快速基准</a> &amp;。</li></ul><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nn"><img src="../Images/376261b346bc3d2097eb1a1db3a62562.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2Ue6HzkCiUuPSWVi.png"/></div></div></figure><ul class=""><li id="1017" class="lz ma in jx b jy jz kc kd kg ne kk nf ko ng ks mg mh mi mj bi translated">首先，记住使用<code class="fe nh ni nj mu b">try</code>和<code class="fe nh ni nj mu b">catch</code>实际上不会降低性能，除非抛出异常。</li><li id="b8e4" class="lz ma in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated">这是“零成本”的异常处理——在抛出一条指令之前，不会执行任何与异常处理相关的指令。</li><li id="5a18" class="lz ma in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated">但是，与此同时，由于展开例程，它增加了可执行文件的大小，这对于嵌入式系统来说是很重要的。</li></ul><blockquote class="ku kv kw"><p id="0bdf" class="jv jw kx jx b jy jz ka kb kc kd ke kf ky kh ki kj kz kl km kn la kp kq kr ks ig bi translated"><em class="in">TL；在抛出一条指令之前，不会执行与异常处理相关的指令，所以使用 try / catch 实际上不会降低性能。</em></p></blockquote><h1 id="4d56" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">关于异常处理的最佳实践和一些 CPP 核心指南</h1><p id="fce4" class="pw-post-body-paragraph jv jw in jx b jy mb ka kb kc mc ke kf kg nk ki kj kk nl km kn ko nm kq kr ks ig bi translated"><strong class="jx io">c++异常处理的最佳实践</strong></p><ul class=""><li id="ccb9" class="lz ma in jx b jy jz kc kd kg ne kk nf ko ng ks mg mh mi mj bi translated"><strong class="jx io">理想情况下，你不应该从析构函数抛出异常，移动构造函数或者</strong> <a class="ae kt" href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Non-throwing_swap" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">交换</strong> </a> <strong class="jx io">之类的函数。</strong></li><li id="214d" class="lz ma in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated"><strong class="jx io">为了例外的安全，我更喜欢 RAII 习语，因为在例外的情况下，你可能会离开</strong></li><li id="4a0f" class="lz ma in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated">-处于无效状态的数据，即无法进一步读取和使用的数据；<br/> -泄漏的资源，如内存、文件、id 或任何其他需要分配和释放的资源；<br/> -内存损坏；<br/> -不变量被破坏，例如 size 函数返回的元素比容器中实际保存的多。</li><li id="ddea" class="lz ma in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated"><strong class="jx io">忌用</strong> <a class="ae kt" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-new" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">生</strong></a><code class="fe nh ni nj mu b"><a class="ae kt" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-new" rel="noopener ugc nofollow" target="_blank"><strong class="jx io">new</strong></a></code><a class="ae kt" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-new" rel="noopener ugc nofollow" target="_blank"><strong class="jx io">&amp;</strong></a><code class="fe nh ni nj mu b"><a class="ae kt" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-new" rel="noopener ugc nofollow" target="_blank"><strong class="jx io">delete</strong></a></code><strong class="jx io">。使用标准库中的解决方案，如</strong><code class="fe nh ni nj mu b"><a class="ae kt" href="http://www.vishalchovatiya.com/understanding-unique-ptr-with-example-in-cpp11/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io">std::unique_pointer</strong></a></code><strong class="jx io"/><code class="fe nh ni nj mu b"><strong class="jx io">std::make_unique</strong></code><strong class="jx io"/><code class="fe nh ni nj mu b"><strong class="jx io">std::fstream</strong></code><strong class="jx io"/><code class="fe nh ni nj mu b"><strong class="jx io">std::lock_guard</strong></code><strong class="jx io">等。</strong></li><li id="0b97" class="lz ma in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated">此外，将代码分成修改部分和非修改部分是很有用的，只有非修改部分可以抛出异常。</li><li id="b68e" class="lz ma in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated">拥有某些资源时，永远不要抛出异常。</li></ul><p id="bdd8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">一些 CPP 核心指南</strong></p><ul class=""><li id="21fd" class="lz ma in jx b jy jz kc kd kg ne kk nf ko ng ks mg mh mi mj bi translated"><a class="ae kt" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-design" rel="noopener ugc nofollow" target="_blank"> E.1:在设计早期制定错误处理策略</a></li><li id="f43a" class="lz ma in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated"><a class="ae kt" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-errors" rel="noopener ugc nofollow" target="_blank"> E.3:仅将异常用于错误处理</a></li><li id="bf1a" class="lz ma in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated"><a class="ae kt" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-raii" rel="noopener ugc nofollow" target="_blank"> E.6:使用 RAII 防止泄漏</a></li><li id="2478" class="lz ma in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated"><a class="ae kt" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-never-throw" rel="noopener ugc nofollow" target="_blank"> E.13:作为物品的直接拥有者，永远不要扔东西</a></li><li id="b69c" class="lz ma in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated"><a class="ae kt" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-never-fail" rel="noopener ugc nofollow" target="_blank"> E.16:析构函数、解除分配和</a> <code class="fe nh ni nj mu b"><a class="ae kt" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-never-fail" rel="noopener ugc nofollow" target="_blank">swap</a></code> <a class="ae kt" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-never-fail" rel="noopener ugc nofollow" target="_blank">决不能失败</a></li><li id="16c4" class="lz ma in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated"><a class="ae kt" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-not-always" rel="noopener ugc nofollow" target="_blank"> E.17:不要试图捕捉每个函数中的每个异常</a></li><li id="20db" class="lz ma in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated"><a class="ae kt" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-catch" rel="noopener ugc nofollow" target="_blank"> E.18:尽量减少使用显式</a> <code class="fe nh ni nj mu b"><a class="ae kt" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-catch" rel="noopener ugc nofollow" target="_blank">try</a></code> <a class="ae kt" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-catch" rel="noopener ugc nofollow" target="_blank"> / </a> <code class="fe nh ni nj mu b"><a class="ae kt" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-catch" rel="noopener ugc nofollow" target="_blank">catch</a></code></li><li id="874d" class="lz ma in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated"><a class="ae kt" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-no-throw-crash" rel="noopener ugc nofollow" target="_blank"> 26:如果不能抛出异常，考虑快速失败</a></li><li id="f0a8" class="lz ma in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated"><a class="ae kt" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re_catch" rel="noopener ugc nofollow" target="_blank"> E.31:合理安排你的</a><code class="fe nh ni nj mu b"><a class="ae kt" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re_catch" rel="noopener ugc nofollow" target="_blank">catch</a></code><a class="ae kt" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re_catch" rel="noopener ugc nofollow" target="_blank">-条款</a></li></ul><h1 id="800b" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">你可能也会喜欢这些</h1><ul class=""><li id="853d" class="lz ma in jx b jy mb kc mc kg md kk me ko mf ks mg mh mi mj bi translated"><a class="ae kt" href="https://dev.to/visheshpatel/21-new-features-of-modern-c-to-use-in-your-project-3f87" rel="noopener ugc nofollow" target="_blank">现代 C++的 21 项新特性将在您的项目中使用</a></li><li id="6673" class="lz ma in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated"><a class="ae kt" href="https://dev.to/visheshpatel/all-about-lambda-function-in-c-j4e" rel="noopener ugc nofollow" target="_blank">关于 C++中 lambda 函数的所有内容</a></li><li id="13f8" class="lz ma in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated"><a class="ae kt" href="https://dev.to/visheshpatel/c-type-casting-with-example-for-c-developers-29b8" rel="noopener ugc nofollow" target="_blank"> C++类型转换与 C 开发人员示例</a></li></ul></div></div>    
</body>
</html>