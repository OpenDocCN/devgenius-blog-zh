<html>
<head>
<title>How to Build Message Driven Applications Using Spring Cloud Stream</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Spring Cloud Stream构建消息驱动的应用</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-build-message-driven-applications-using-spring-cloud-stream-e7ec2af24690?source=collection_archive---------0-----------------------#2021-06-26">https://blog.devgenius.io/how-to-build-message-driven-applications-using-spring-cloud-stream-e7ec2af24690?source=collection_archive---------0-----------------------#2021-06-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="153d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">探索注释和函数式编程模型的方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7107c31cb193857b2c39e6ab934ed08f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ftwujMA8YDKyLtJ7EOB72g.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@amaitu?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">史蒂夫·巴克</a>在<a class="ae kv" href="https://unsplash.com/s/photos/color-shopping?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="259c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">消息驱动处理是基于服务的架构中广泛采用的设计模式。这种设计有效地支持大量的请求处理，因为服务集成是基于无阻塞的消息通信。</p><p id="efef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">消息代理是在服务之间传递消息的关键基础设施组件。然而，对于开发人员来说，为了编写与消息代理集成的代码而学习特定消息代理的API是一件苦差事，因为业界有许多流行的消息代理，如ActiveMQ、RabbitMQ和Kafka。</p><p id="58e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于Java Spring framework的惊人特性，它的Spring Cloud Stream组件提供了一个抽象，这样软件工程师就可以专注于应用程序逻辑的开发，而不必担心与消息代理交互的细节。</p><p id="7902" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">遵循Spring框架的习惯用法和实践，基于Spring Cloud Stream的应用程序开发最初使用注释来定义消息发送者和接收者。然而，从版本3开始，注释已经被弃用，函数式编程模型现在是构建基于Spring Cloud Stream的系统的唯一合适的方式。</p><p id="be26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将分享使用Spring Cloud Stream构建具有消息传递集成的消息驱动应用程序的分步指南。即使注释不再是推荐的方法，我仍然会强调注释和函数式编程模型，作为那些想过渡到新方法的人的参考。</p><h2 id="fa41" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">基于注释的实现</h2><p id="d1ab" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">如果您习惯于基于Spring framework构建应用程序，那么您应该熟悉注释的使用。通过添加注释，您可以简单地将特性添加到类和方法中。例如，annotation @Streamlistener将指定由传入消息触发的方法。虽然注释在一段时间内仍可用于开发，但这种方法已经被否决，并且从Spring Cloud Stream版开始不再推荐使用。</p><h2 id="9e9c" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">函数编程模型</h2><p id="5954" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">另一方面，函数式编程模型是一种新的方法。函数是函数式编程范例中的基本单位。每个功能都是解决特定问题的独立模块，而它们的组合可以解决复杂的问题。Java Stream是函数式编程的典型例子。以下示例使用函数filer()、map()和average()来计算2021年3月15日下的所有订单的平均价格</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="832d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与传统的命令式编程模型相比，程序代码更简单，更容易阅读。</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="326e" class="mz lt iq bd lu na nb nc lx nd ne nf ma jw ng jx md jz nh ka mg kc ni kd mj nj bi translated">示例消息驱动应用程序</h1><p id="7574" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">让我们从一个带有消息传递集成的示例应用程序开始。我们有一个库存管理系统来记录库存。电子商务系统和仓库发出事件，并通过消息代理提交给库存管理。库存系统随后将执行业务逻辑，例如针对传入事件的库存更新。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/50a529000cc2c40b9b9b610abd009d84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ado_UCJtiPLutaeVjRkcTA.png"/></div></div></figure></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="0638" class="mz lt iq bd lu na nb nc lx nd ne nf ma jw ng jx md jz nh ka mg kc ni kd mj nj bi translated">消息发布者—基于注释的实现</h1><p id="1d83" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">订单提交逻辑通过消息传递网关向消息代理发送消息，消息传递网关依赖于消息通道进行通信。绑定由指定目标主题交换的配置组成。要构建一个消息发布器，您需要分别用注释@Gateway和@ Ouptut为消息传递网关和消息通道定义两个接口。然后，框架将在系统初始化期间提供实现。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/3b07a65918b0af9381f09aac9646b8a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*wUy8JsJ3pFpbME71EyEeng.png"/></div></figure><h2 id="6885" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak">消息通道</strong></h2><p id="94c1" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">使用绑定名称定义输出消息通道。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h2 id="b7b1" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak">消息网关</strong></h2><p id="5f81" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">将@Gateway批注标记到请求通道链接到相同绑定名称的接口方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h2 id="c5a8" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak">应用代码发布消息</strong></h2><p id="7037" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">应用程序代码可以通过调用消息传递网关接口来发送消息。默认情况下，框架将对象序列化到JSON中进行消息传输。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h2 id="4594" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">配置</h2><p id="23d6" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在application.yml中，将目标主题exchange设置为绑定名称“orderSubmissionOutput”下的destination参数。当我们指定主机、端口和访问信息时，我们将应用程序连接到RabbitMQ。应用程序初始化时，框架会自动在RabbitMQ上创建主题交换“orderSubmitted.exchange”。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="d1f2" class="mz lt iq bd lu na nb nc lx nd ne nf ma jw ng jx md jz nh ka mg kc ni kd mj nj bi translated">消息发布者—基于功能的实现</h1><p id="74a5" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">基于函数的编程模型更简单，因为您不再需要为消息传递网关和消息通道定义样板代码。只需利用StreamBridge将消息直接发送到目标绑定名称。然后，框架将根据配置发送到相关的主题交换。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/e825ad94060591944425ee860c9df62d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*cDt_CUbQnL0il15Cp2-k3Q.png"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h2 id="8b22" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">配置</h2><p id="9360" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">应用程序配置与基于注释的实现相同。它只是从绑定名称到目的地(即主题交换名称)的映射。</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="05a6" class="mz lt iq bd lu na nb nc lx nd ne nf ma jw ng jx md jz nh ka mg kc ni kd mj nj bi translated">消息监听器—基于注释的实现</h1><p id="c708" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">Spring Cloud Stream自动为相关消息队列中准备好的任何消息触发消息监听器。其概念是让框架知道处理传入消息的方法，并将其链接到目标消息队列，因此框架会自动将传入消息提供给该方法。</p><p id="74a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与publisher的实现类似，您需要一个消息通道来接收消息。消息通道是带有@input注释的订阅通道。将@StreamListener标记到消息处理程序方法中，然后框架将为传入的消息执行该方法</p><p id="da08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本例中，库存管理系统监听2个单独的消息队列，分别用于接收从仓库和电子商务系统发出的事件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/85d14b8543a1e8fb7070a4b046e51c64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GZWsqjx7l3IhziAv6DtApw.png"/></div></div></figure><h2 id="5a01" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">信息通道</h2><p id="9e1a" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们有两个消息渠道用于订单提交和仓库移动。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h2 id="5b35" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">消息监听器</h2><p id="53db" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">使用@StreamListener指定传入消息处理逻辑的类方法。如果目标消息队列中有任何传入的消息，那么框架会将消息反序列化为Java对象POJOs，然后执行handler方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h2 id="b9a2" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">配置</h2><p id="9795" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">通过为每个绑定配置目的地和组来定义目标消息队列。Destination是目标主题交换，而group通常是应用程序名或函数名。框架将自动创建一个名为<strong class="ky ir"> <em class="no"> &lt;目的地&gt;的消息队列。&lt;分组&gt; </em> </strong> <em class="no"> </em>并将队列绑定到话题交换。例如，消息队列为“order submitted . exchange . inventory”带有<strong class="ky ir"> <em class="no"> &lt;目的地&gt;</em></strong><em class="no">= order submitted . exchange</em>和<strong class="ky ir"> <em class="no"> &lt;组&gt; </em> </strong> <em class="no"> =库存</em>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="6bd2" class="mz lt iq bd lu na nb nc lx nd ne nf ma jw ng jx md jz nh ka mg kc ni kd mj nj bi translated">消息监听器—基于功能的实现</h1><p id="7051" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">基于函数的实现不需要定义消息通道，因为框架直接将绑定链接到函数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/2c77376c6cc999470659fd7240df6732.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*Ae7xTeu6yiuIRER0nO7HGg.png"/></div></div></figure><h2 id="3e88" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">消息监听器</h2><p id="c6c3" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们没有使用@StreamListener注释，而是使用消费者函数实现来定义消息处理程序，并将它们注册为beans。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h2 id="3c7f" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">配置</h2><p id="5bc8" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">该配置类似于基于注释的方法，但是绑定名称由框架根据以下命名约定确定:<strong class="ky ir"> <em class="no"> &lt;函数名称&gt; -in- &lt;索引&gt; </em> </strong>其中<em class="no"> &lt;索引&gt; </em>在大多数情况下总是为0，除非<a class="ae kv" href="https://docs.spring.io/spring-cloud-stream/docs/3.1.3/reference/html/spring-cloud-stream.html#_functions_with_multiple_input_and_output_arguments" rel="noopener ugc nofollow" target="_blank">函数具有多个输入和输出</a>。</p><p id="a49d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其次，在<strong class="ky ir">spring . cloud . function . definition</strong>中注册函数名，使用流绑定。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="6d3e" class="mz lt iq bd lu na nb nc lx nd ne nf ma jw ng jx md jz nh ka mg kc ni kd mj nj bi translated">最后的想法</h1><p id="b009" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">Spring Cloud Stream简化了消息驱动系统的开发，使得开发变得更加容易，并且有助于轻松地与消息代理集成。此外，该框架自动提供主题交换、消息队列和基于配置的绑定，实现代码作为基础设施，这大大减少了对环境设置的依赖。显然，使用函数式编程模型进行系统开发是一种很棒的方法，因为它用较少的样板代码产生了更简单的代码库。此外，这种方法与Spring Cloud函数一起工作，因此可以通过创建可重用函数管道来实现更复杂的逻辑，如数据转换。</p></div></div>    
</body>
</html>