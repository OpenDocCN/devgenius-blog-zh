<html>
<head>
<title>Single responsibility principle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单一责任原则</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/solid-single-responsibility-principle-61f2c4b3d982?source=collection_archive---------5-----------------------#2020-09-08">https://blog.devgenius.io/solid-single-responsibility-principle-61f2c4b3d982?source=collection_archive---------5-----------------------#2020-09-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/5a2c0c16802c62820681c1842e1418c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZnUE8Z63LvMLJn9m"/></div></div></figure><div class=""/><blockquote class="jy jz ka"><p id="0555" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一个类应该有且只有一个改变的理由</p></blockquote><p id="159b" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">这个原理在汤姆·狄马克和梅里尔·佩奇-琼斯的著作中有所描述。他们称之为内聚，他们将其定义为模块的元素的<strong class="ke jc">功能相关性。</strong></p><p id="412e" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">例如，考虑下面的矩形类。这个类有一个在屏幕上绘制矩形的方法和另一个计算矩形面积的方法。</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="eae6" class="lm ln jb li b gy lo lp l lq lr">public class Rectangle<br/>{<br/>  public double Area()<br/>  {<br/>    ...<br/>  }</span><span id="c6d0" class="lm ln jb li b gy ls lp l lq lr">  public void Draw()<br/>  {<br/>    ...	<br/>  }<br/>}</span></pre><p id="ca3c" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">现在假设两个不同的应用程序使用 rectangle 类。</p><p id="e14f" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">一个应用程序是计算几何(使用 Rectangle 来执行一些几何操作，但从不在屏幕上绘制矩形)，另一个应用程序是纯图形的，其主要目的是在屏幕上绘制矩形。</p><p id="bc3e" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">这个设计违反了单责任原则，因为矩形类有<strong class="ke jc">两个责任</strong>。第一个职责是提供矩形几何的数学模型，第二个职责是在 GUI 上呈现矩形。</p><p id="44db" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">这种违反的后果将是:</p><ul class=""><li id="6725" class="lt lu jb ke b kf kg kj kk la lv lb lw lc lx kz ly lz ma mb bi translated">我们必须在计算几何应用中包含 GUI。英寸 NET 中，GUI 组件必须用计算几何应用程序来构建和部署。</li><li id="82ad" class="lt lu jb ke b kf mc kj md la me lb mf lc mg kz ly lz ma mb bi translated">如果对 GraphicalApplication 的更改由于某种原因导致矩形发生变化，这种变化可能会迫使我们重新构建、重新测试和重新部署 ComputationalGeometryApplication。如果我们忘记这样做，应用程序可能会以不可预知的方式崩溃。</li></ul><p id="dba2" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">为了解决这个问题并遵守这个原则，我们应该将 Rectangle 的计算部分移到 GeometricRectangle 类中。现在，对矩形渲染方式的更改不会影响 ComputationalGeometry 应用程序。</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="f475" class="lm ln jb li b gy lo lp l lq lr">public class GeometricRectangle<br/>{<br/>  public double Area()<br/>  {<br/>    ...<br/>  }</span><span id="55f5" class="lm ln jb li b gy ls lp l lq lr">}</span><span id="0770" class="lm ln jb li b gy ls lp l lq lr">public class Rectangle<br/>{<br/>  public void Draw()<br/>  {<br/>    ...	<br/>  }</span><span id="fbc5" class="lm ln jb li b gy ls lp l lq lr">}</span></pre><h1 id="dcbd" class="mh ln jb bd mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd bi translated">为什么有必要将这两种责任分成不同的类？</h1><p id="6787" class="pw-post-body-paragraph kb kc jb ke b kf ne kh ki kj nf kl km la ng kp kq lb nh kt ku lc ni kx ky kz ij bi translated">原因是每个责任都是变化的轴心。当需求发生变化时，这种变化将通过类之间职责的变化来体现。如果一个类承担了不止一个责任，那么这个类就有不止一个理由去改变。</p><p id="5e2d" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">如果一个类有不止一个责任，那么这些责任就成了一对。改变一项职责可能会损害或抑制班级完成其他职责的能力。这种耦合导致脆弱的设计，当改变时会以意想不到的方式破裂。</p></div></div>    
</body>
</html>