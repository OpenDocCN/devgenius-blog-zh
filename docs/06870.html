<html>
<head>
<title>Android Paintflags Configuration, Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android Paintflags 配置，已解释</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/behind-android-paintflags-configuration-ef1f694bc679?source=collection_archive---------12-----------------------#2022-02-08">https://blog.devgenius.io/behind-android-paintflags-configuration-ef1f694bc679?source=collection_archive---------12-----------------------#2022-02-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jp jq jr js gh gi paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gh gi jo"><img src="../Images/2bdc5f5755df2cbc9ce7966009a75a34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6lb-nVbLQaXesuHGSicgag.png"/></div></div></figure><p id="ed59" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">当我在做一个 Android Kotlin 项目时，我偶然发现了这段代码:</p><figure class="kx ky kz la gt js"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="9dea" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">目的很简单。我们需要在复选框被选中时删除文本，或者在复选框未被选中时删除删除线。但出于某种原因，Android 配置它的方式很奇怪，至少对我来说是这样。</p><p id="0a4d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我之所以觉得奇怪，是因为这是我第一次在任何框架或者 SDK 中遇到以 bitmask 作为配置的情况。有几个框架/库不使用位掩码的例子:</p><ul class=""><li id="8763" class="ld le in kb b kc kd kg kh kk lf ko lg ks lh kw li lj lk ll bi translated">CSS:如果你想显示一些东西，你可以直接在 CSS 文件中给类或者<code class="fe jk jl jm jn b">id</code>配置添加一个属性。</li><li id="e2ea" class="ld le in kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">Laravel:完成的大部分配置都是用 PHP 的数组。</li><li id="1093" class="ld le in kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">Tailwind:你只需要在自己的视图中使用已有的类。</li><li id="3a1c" class="ld le in kb b kc lm kg ln kk lo ko lp ks lq kw li lj lk ll bi translated">Flutter:要么构建小部件类，要么以通常的方式设置现有的属性(使用类的属性)。</li></ul><p id="6000" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">然后我意识到，这实际上是一个很酷的方式来使用他们的配置位掩码。</p><h1 id="37cf" class="lr ls in bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">我们来谈谈位掩码</h1><p id="f717" class="pw-post-body-paragraph jz ka in kb b kc mp ke kf kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw ig bi translated">位掩码只是修改一个或多个位的行为。更多细节可以在<a class="ae mu" href="https://en.wikipedia.org/wiki/Mask_(computing)" rel="noopener ugc nofollow" target="_blank">维基百科</a>找到，但是如果你愿意，你可以留在这里继续阅读我的解释。</p><h2 id="48e0" class="mv ls in bd lt mw mx dn lx my mz dp mb kk na nb mf ko nc nd mj ks ne nf mn ng bi translated">等等…先说 Bit 吧</h2><p id="9463" class="pw-post-body-paragraph jz ka in kb b kc mp ke kf kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw ig bi translated">那么，什么是比特呢？一位(二进制数字的缩写)是计算中最基本的单位或信息。它用两个值表示逻辑值:0(或假)和 1(或真)。在特定状态下，计算机只能保存其中一个值(不能同时保存两个值)。</p><p id="b373" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这位在计算机中也用来表示数字。我们每次处理一个数，计算机总是以二进制为基数(2 为基数)进行处理。由于计算机已经使用位，二进制比日常的十进制更容易处理。</p><pre class="kx ky kz la gt nh jn ni nj aw nk bi"><span id="7505" class="mv ls in jn b gy nl nm l nn no">+-----------+--------------+<br/>|  Decimal  | 8-Bit Binary |<br/>+-----------+--------------+<br/>| 0         |     00000000 |<br/>| 1         |     00000001 |<br/>| 2         |     00000010 |<br/>| 3         |     00000011 |<br/>| 4         |     00000100 |<br/>| 5         |     00000101 |<br/>| 6         |     00000110 |<br/>| 7         |     00000111 |<br/>| 8         |     00001000 |<br/>| and so on |              |<br/>+-----------+--------------+</span></pre><p id="ac69" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">上表描述了十进制和二进制之间的比较。每当二进制系统每 10 个数字(从 0 到 10)重复一个数字，二进制系统每 2 个数字(从 0，1，然后 10)重复一个数字。请注意，我在实数前面附加了零，只是为了向您展示计算机内存中的数字表示。</p><p id="3ce5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我在这里不打算深入谈论 bit，只是向你们展示数字是如何以 bit 存储的。你可以在这里了解更多关于读取二进制数<a class="ae mu" href="https://www.lifewire.com/how-to-read-binary-4692830" rel="noopener ugc nofollow" target="_blank">的知识。之后，我们再回头讨论比特操作。</a></p><h2 id="80ae" class="mv ls in bd lt mw mx dn lx my mz dp mb kk na nb mf ko nc nd mj ks ne nf mn ng bi translated">位操作和位掩码</h2><p id="8a80" class="pw-post-body-paragraph jz ka in kb b kc mp ke kf kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw ig bi translated">你知道你可以操纵钻头<code class="fe jk jl jm jn b">by hand</code> ( <code class="fe jk jl jm jn b">by hand</code>我的意思是你可以在某个位置操纵钻头)？有一种特殊的方法，叫做位掩码。</p><p id="79b6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">位掩码是一种位操作类型，可用于更改一个或多个位。具体来说，它是一个辅助数据(在我们的例子中是数字)，可以用来更改原始数字。</p><p id="769b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为了学习位操作，我们必须先学习位操作符。就像算术计算一样，有许多位操作符可以和位掩码一起使用来改变整数。</p><pre class="kx ky kz la gt nh jn ni nj aw nk bi"><span id="7f10" class="mv ls in jn b gy nl nm l nn no">+-------------+----------+-------------------+--------------+<br/>|    Name     | Operator | Kotlin equivalent | Truth table? |<br/>+-------------+----------+-------------------+--------------+<br/>| AND         | &amp;        | and               | yes          |<br/>| OR          | |        | or                | yes          |<br/>| XOR         | ^        | xor               | yes          |<br/>| Shift left  | &lt;&lt;       | shl               | no           |<br/>| Shift right | &gt;&gt;       | shr               | no           |<br/>| Invert      | ~        | .inv() method     | no           |<br/>+-------------+----------+-------------------+--------------+</span></pre><p id="835f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在这篇文章中，我将关注除了<code class="fe jk jl jm jn b">xor</code>之外的所有操作符，因为我们需要知道那些用于<code class="fe jk jl jm jn b">Paintflags</code>配置的操作符。</p><h2 id="3466" class="mv ls in bd lt mw mx dn lx my mz dp mb kk na nb mf ko nc nd mj ks ne nf mn ng bi translated"><code class="fe jk jl jm jn b">AND</code>与或运算</h2><p id="01c6" class="pw-post-body-paragraph jz ka in kb b kc mp ke kf kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw ig bi translated"><code class="fe jk jl jm jn b">AND</code>和<code class="fe jk jl jm jn b">OR</code>操作是位操作中最基本的操作。每个运算取两个数字，并根据真值表产生结果:</p><pre class="kx ky kz la gt nh jn ni nj aw nk bi"><span id="7a29" class="mv ls in jn b gy nl nm l nn no">+-----------+-----------+------------+-----------+<br/>| Operand 1 | Operand 2 | AND result | OR result |<br/>+-----------+-----------+------------+-----------+<br/>|         0 |         0 |          0 |         0 |<br/>|         0 |         1 |          0 |         1 |<br/>|         1 |         0 |          0 |         1 |<br/>|         1 |         1 |          1 |         1 |<br/>+-----------+-----------+------------+-----------+</span></pre><p id="ac20" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">正如你所看到的，<code class="fe jk jl jm jn b">AND</code>操作只在两个操作数都为 1 时产生 1，而<code class="fe jk jl jm jn b">OR</code>操作在其中一个操作数为 1 时产生 1。基于此，我们可以使用:</p><ol class=""><li id="5482" class="ld le in kb b kc kd kg kh kk lf ko lg ks lh kw np lj lk ll bi translated"><code class="fe jk jl jm jn b">AND</code>将任一位更改为 0 的操作(也称为<code class="fe jk jl jm jn b">unset</code>)。例:5&amp;3 = 000000101&amp;00000011 = 00000001 = 1。</li><li id="2c40" class="ld le in kb b kc lm kg ln kk lo ko lp ks lq kw np lj lk ll bi translated"><code class="fe jk jl jm jn b">OR</code>将任一位变为 1 的操作(又称<code class="fe jk jl jm jn b">set</code>)。例如:5 | 3 = 00000101 | 00000011 = 00000111 = 7。</li></ol><h2 id="7b8e" class="mv ls in bd lt mw mx dn lx my mz dp mb kk na nb mf ko nc nd mj ks ne nf mn ng bi translated">倒置</h2><p id="651c" class="pw-post-body-paragraph jz ka in kb b kc mp ke kf kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw ig bi translated">假设你有一个数字 7，用比特表示为<code class="fe jk jl jm jn b">00000111</code>。如果我想反转所有的位(从 0 到 1，从 1 到 0)，该怎么办？我们使用反演算子。在 Java 中，您可以像这样反转这些位:</p><figure class="kx ky kz la gt js"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="7f87" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">但是，在 Kotlin 中，不使用<code class="fe jk jl jm jn b">~</code>操作符，而是使用<code class="fe jk jl jm jn b">.inv()</code>方法:</p><figure class="kx ky kz la gt js"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="7a89" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">万一你问为什么显示<code class="fe jk jl jm jn b">-8</code>，那是因为反位是<code class="fe jk jl jm jn b">11111000</code>。如果变量是<em class="nq">无符号</em>整数(没有负值)，会显示<code class="fe jk jl jm jn b">4294967288</code>。但是，因为我们使用带符号的整数(带正/负号的整数)，计算机会显示负整数。你可以在这里了解更多关于负整数表示<a class="ae mu" href="https://www.bbc.co.uk/bitesize/guides/zjfgjxs/revision/5" rel="noopener ugc nofollow" target="_blank">的知识。</a></p><h2 id="d215" class="mv ls in bd lt mw mx dn lx my mz dp mb kk na nb mf ko nc nd mj ks ne nf mn ng bi translated">移位</h2><p id="ed79" class="pw-post-body-paragraph jz ka in kb b kc mp ke kf kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw ig bi translated">假设你有一个数字 6，用位<code class="fe jk jl jm jn b">00000110</code>表示。您想要乘以 2 的幂(例如 4)，但是出于性能原因，您不想使用乘法运算符。嗯，这种情况下可以左移<code class="fe jk jl jm jn b">sqrt(N)</code>倍。每向左移动一次意味着你要乘以 2。如果你向左移动 2 次，这意味着你要乘以<code class="fe jk jl jm jn b">2 to the power of 2</code>，也就是 4。</p><pre class="kx ky kz la gt nh jn ni nj aw nk bi"><span id="cb9f" class="mv ls in jn b gy nl nm l nn no">+------------+----------+<br/>| Shift left |   Bit    |<br/>+------------+----------+<br/>|          0 | 00000110 |<br/>|          1 | 00001100 |<br/>|          2 | 00011000 |<br/>|          3 | 00110000 |<br/>+------------+----------+</span></pre><p id="85b4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">"等等，但是这意味着，如果我右移，我将这个数除以 2 的幂？"是的，你是对的！如果你把这位向右移，情况正好相反。</p><p id="c992" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">但是，位移法不仅仅用于数的乘/除。我们可以用它来控制特定的位。我们将在 Paintflags 配置中看到更多这样的内容。</p><h1 id="6ec4" class="lr ls in bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">Paintflags 配置</h1><p id="48e4" class="pw-post-body-paragraph jz ka in kb b kc mp ke kf kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw ig bi translated">让我们回到文章开头的片段:</p><figure class="kx ky kz la gt js"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="d675" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe jk jl jm jn b">paintFlags</code>属性是一个有符号整数，所以它包含 64 位。<code class="fe jk jl jm jn b">STRIKE_THRU_TEXT_FLAG</code>是一个值为 16 的常数。你知道如何用比特来表示数字 16 吗？让我们记住 16 是 2 的 4 次方，或者换句话说是<code class="fe jk jl jm jn b">1 &lt;&lt; 4</code>。这就是 64 位整数中的数字 16:</p><pre class="kx ky kz la gt nh jn ni nj aw nk bi"><span id="2225" class="mv ls in jn b gy nl nm l nn no">00000000 00000000 00000000 00010000</span></pre><p id="1635" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在，最初，<code class="fe jk jl jm jn b">paintFlags</code>配置不设置任何东西。这意味着，<code class="fe jk jl jm jn b">paintFlags</code>中的所有位都是<code class="fe jk jl jm jn b">0</code>。</p><p id="b933" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">但是，现在我们想要应用删除线，所以我们决定设置显示删除线的位。在这种情况下，它是第 5 个最低有效位(意思是:从右数第 5 位)。所以，我们必须左移 4 次。幸运的是，Kotlin 已经有了常量，所以我们只需使用<code class="fe jk jl jm jn b">OR</code>操作符来激活设置:</p><pre class="kx ky kz la gt nh jn ni nj aw nk bi"><span id="04aa" class="mv ls in jn b gy nl nm l nn no">00000000 00000000 00000000 00000000<br/>00000000 00000000 00000000 00010000<br/>----------------------------------- OR<br/>00000000 00000000 00000000 00010000</span></pre><p id="5d55" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">还记得我说过的“设置”吗？为此我们使用了<code class="fe jk jl jm jn b">OR</code>操作符。</p><p id="c905" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">但是，关于<code class="fe jk jl jm jn b">else</code>条款呢？如果我们想取消贯穿配置呢？我们只需要“复位”第 5 个最低有效位。我们如何取消设置？我们使用 AND 运算符，并确保位掩码中的第 5 个最低有效位被反转，因此该位将被“设置为 0”。不要担心，其他位不会受到影响，因为这就是<code class="fe jk jl jm jn b">AND</code>操作符的性质:只有当位掩码为 0 时，它才会改变。</p><pre class="kx ky kz la gt nh jn ni nj aw nk bi"><span id="91f3" class="mv ls in jn b gy nl nm l nn no">00000000 00000000 00000000 00010000<br/>11111111 11111111 11111111 11101111<br/>----------------------------------- AND<br/>00000000 00000000 00000000 00000000</span></pre><p id="f9b6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在，如果我们错误地使用了<code class="fe jk jl jm jn b">OR</code>操作符，会发生什么呢？这意味着我们激活了要显示的其他属性:</p><pre class="kx ky kz la gt nh jn ni nj aw nk bi"><span id="631c" class="mv ls in jn b gy nl nm l nn no">00000000 00000000 00000000 00010000<br/>11111111 11111111 11111111 11101111<br/>----------------------------------- OR<br/>11111111 11111111 11111111 11111111</span></pre><p id="3007" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">好吧，现在我们(可能)得到了混乱的用户界面。</p><h2 id="c051" class="mv ls in bd lt mw mx dn lx my mz dp mb kk na nb mf ko nc nd mj ks ne nf mn ng bi translated">为什么使用位掩码？</h2><p id="83fb" class="pw-post-body-paragraph jz ka in kb b kc mp ke kf kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw ig bi translated">现在你可能想知道，为什么配置要使用位掩码？为什么不用通常的方式设置或取消设置呢？</p><p id="e297" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">事实证明，在一个整数中可以存储多个配置。这有助于 Android 节省存储空间。由于 Android 是一个移动系统，对存储的贪婪不是一件明智的事情。因此，也许 Android SDK 开发人员认为，从长远来看，让它更紧凑更好(这是一个有效的论点)。</p></div><div class="ab cl nr ns hr nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ig ih ii ij ik"><p id="d4b3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我希望现在您已经对位和位掩码有了很高的理解。位操作不仅对这类问题有用，对其他问题也有用，比如厄拉多塞的<a class="ae mu" href="https://cp-algorithms.com/algebra/sieve-of-eratosthenes.html" rel="noopener ugc nofollow" target="_blank">筛子、</a><a class="ae mu" href="https://www.youtube.com/watch?v=JE0JE8ce1V0" rel="noopener ugc nofollow" target="_blank">旅行售货员问题</a>等等。</p><p id="e9d6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">不过，这只是介绍。随着您对底层系统的深入研究，我敢肯定您会遇到很多位操作。</p></div></div>    
</body>
</html>