<html>
<head>
<title>JavaScript Unit Test Best Practices — Test Data and Logic</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript 单元测试最佳实践—测试数据和逻辑</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/javascript-unit-test-best-practices-test-data-and-logic-43258a4410e5?source=collection_archive---------5-----------------------#2020-08-29">https://blog.devgenius.io/javascript-unit-test-best-practices-test-data-and-logic-43258a4410e5?source=collection_archive---------5-----------------------#2020-08-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f253d160c0611958711faeb0781203c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rp6aoB5t1DY_PSZ7"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">兰迪·拜恩在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="8a99" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">单元测试对于检查我们的应用程序是如何工作的非常有用。</p><p id="9a1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们以后会遇到各种各样的问题。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究在编写 JavaScript 单元测试时应该遵循的一些最佳实践。</p><h1 id="4162" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">孤立地测试中间件</h1><p id="5d86" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该孤立地测试中间件，以便我们可以测试应用程序的关键部分。</p><p id="edb9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">各种各样的东西都在使用中间件，所以我们应该对它们进行测试。</p><p id="8c36" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为它们是函数，所以我们可以单独测试它们。</p><p id="5d07" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以直接调用它。</p><p id="a85c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们还可以使用 node-mock-http 来监视中间件的行为。</p><p id="b1c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以这样写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d154" class="mn lc iq mj b gy mo mp l mq mr">const unitUnderTest = require("./middleware");<br/>const httpMocks = require("node-mocks-http");<br/><br/>test("should return http status 403 when request header is empty", () =&gt; {<br/>  const request = httpMocks.createRequest({<br/>    method: "GET",<br/>    url: "/user/1",<br/>    headers: {<br/>      authentication: ""<br/>    }<br/>  });<br/>  const response = httpMocks.createResponse();<br/>  unitUnderTest(request, response);<br/>  expect(response.statusCode).toBe(403);<br/>});</span></pre><p id="e9cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用节点模型 http 来提出我们的请求。</p><p id="f3f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以将请求和响应对象传递到中间件中。</p><p id="2750" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后得到回应。</p><h1 id="bc6f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用静态分析工具进行度量和重构</h1><p id="7557" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该使用静态分析工具来提高我们的代码质量并保持我们的代码可维护性。</p><p id="77eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它对于检测重复、代码复杂性和其他问题非常有用。</p><p id="a878" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用<a class="ae kc" href="https://www.sonarqube.org/" rel="noopener ugc nofollow" target="_blank"> Sonarqube </a>和<a class="ae kc" href="https://codeclimate.com/" rel="noopener ugc nofollow" target="_blank"> Code Climate </a>等工具来检查静态分析我们的应用。</p><h1 id="e4ab" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">检查我们对节点相关混乱的准备情况</h1><p id="143a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们还应该检查服务器或进程何时死亡，或者内存何时过载等问题。</p><p id="735f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">速度问题也是重要的检查。</p><p id="abdf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了定期释放资源，我们可以使用工具定期扼杀我们的应用实例。</p><p id="2171" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过性能测试来发现这些问题。</p><p id="db10" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">APM 工具也将帮助我们找到它们。</p><h1 id="ba27" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">避免全局测试装置和种子</h1><p id="53ce" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">全局测试设备不是好的，因为它们在多个测试之间共享。</p><p id="42cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不想在多个测试之间共享它们，因为我们想要独立的测试。</p><p id="55b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">测试不应该从被其他代码片段操纵的数据开始。</p><p id="4835" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们应该在每次测试之后重置数据，以便我们始终能够使用干净的数据进行测试。</p><p id="3944" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的测试应该能够以任何顺序运行，并且仍然给我们相同的结果。</p><p id="045c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们还使我们的测试保持简单，因为它们更容易跟踪。</p><p id="2bd2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们写的内容如下:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4cbd" class="mn lc iq mj b gy mo mp l mq mr">it("should return true if we can log in with valid username and password", async () =&gt; {<br/>  const username = 'james';<br/>  const password = 'password';<br/>  await addUser({ username, password });<br/>  const result = login(username, password);<br/>  expect(result).to.be(true);<br/>});</span></pre><p id="bc10" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建一个新用户，然后使用该用户登录，以便我们知道我们正在测试的用户是否存在。</p><h1 id="53f6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">前端测试</h1><p id="4d8b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">前端测试也很重要。</p><h1 id="e79e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将用户界面与功能分开</h1><p id="a4c6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该将 UI 与功能分开进行测试。</p><p id="9d26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们测试组件逻辑时，UI 就变成了应该被提取的噪音。</p><p id="a1fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们的测试可以只关注于操纵数据。</p><p id="e5e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">UI 可以单独进行测试。</p><p id="faff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以禁用动画，只检查测试中的数据。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/470aec4a17a68d353e12fd23efc9fc42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EMbHRI7yf1NHRmIQ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@stayandroam?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杰玛·埃文斯</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="12a2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="9275" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以将逻辑测试与 UI 测试分开。</p><p id="7501" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们单独测试中间件。</p><p id="b355" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于每个测试，还应该从头开始创建数据。</p></div></div>    
</body>
</html>