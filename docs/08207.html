<html>
<head>
<title>Build a REST API with Rust and MongoDB — Actix web Version</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Rust 和 MongoDB 构建一个 REST API—Actix web 版</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/build-a-rest-api-with-rust-and-mongodb-actix-web-version-a275215c262a?source=collection_archive---------1-----------------------#2022-05-26">https://blog.devgenius.io/build-a-rest-api-with-rust-and-mongodb-actix-web-version-a275215c262a?source=collection_archive---------1-----------------------#2022-05-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/416ce00afb98dd48c5faf80777e07862.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v7JE1DpuU_NVb86WKJZ-9Q.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">封面照片</figcaption></figure><p id="40e0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">REST API 已经成为从一个数据源到另一个数据源连接和传输数据的事实。它为设计和开发 web 服务提供了一套指导方针和架构模式。</p><p id="3081" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这篇文章将讨论使用<a class="ae kx" href="https://actix.rs/" rel="noopener ugc nofollow" target="_blank"> Actix web </a>框架和<a class="ae kx" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>用 Rust 构建一个用户管理应用。在本教程的最后，我们将学习如何构建一个 Rust 应用程序，构建一个 REST API 并使用 MongoDB 持久化我们的数据。</p><p id="c45b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">Actix web 是一个用 Rust 编写的 HTTP web 框架，具有性能和生产力支持。Actix web 附带了类型安全、可重用性、日志、静态文件服务等特性，开发人员可以利用这些特性来构建可伸缩的应用程序。</p><p id="d432" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">MongoDB 是一个基于文档的数据库管理程序，用作关系数据库的替代方案。MongoDB 支持处理大型分布式数据集，并提供无缝存储或检索信息的选项。</p><p id="1bbe" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">完整的源代码可以在这个<a class="ae kx" href="https://github.com/Mr-Malomz/actix-mongo-api" rel="noopener ugc nofollow" target="_blank">库</a>中找到。</p><h1 id="8201" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">先决条件</h1><p id="097d" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">要完全掌握本教程中介绍的概念，需要有 Rust 方面的经验。使用 MongoDB 的经验不是必需的，但是拥有它是很好的。</p><p id="f673" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们还需要以下物品:</p><ul class=""><li id="878e" class="mb mc in kb b kc kd kg kh kk md ko me ks mf kw mg mh mi mj bi translated">一个<a class="ae kx" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> MongoDB 帐户</a>来托管数据库。<a class="ae kx" href="https://www.mongodb.com/cloud/atlas/register" rel="noopener ugc nofollow" target="_blank"> <strong class="kb io">报名</strong> </a> <strong class="kb io">完全免费</strong>。</li><li id="e1d3" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated"><a class="ae kx" href="https://www.postman.com/downloads/" rel="noopener ugc nofollow" target="_blank"> Postman </a>或任何 API 测试应用</li></ul><h1 id="2199" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">让我们编码</h1><h2 id="fb73" class="mp kz in bd la mq mr dn le ms mt dp li kk mu mv lm ko mw mx lq ks my mz lu na bi translated">入门指南</h2><p id="6e0f" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">首先，我们需要导航到所需的目录，并在我们的终端中运行下面的命令</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="dd42" class="mp kz in ng b gy nk nl l nm nn">cargo new actix-mongo-api &amp;&amp; cd actix-mongo-api</span></pre><p id="35f3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">该命令创建一个名为<code class="fe no np nq ng b">actix-mongo-api </code>的 Rust 项目，并导航到项目目录。</p><p id="a647" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">接下来，我们通过修改<code class="fe no np nq ng b">Cargo.toml</code>文件的<code class="fe no np nq ng b">[dependencies] </code>部分来安装所需的依赖项，如下所示:</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="f1a0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe no np nq ng b">actix-web ="4"</code>是一个基于 Rust 的框架，用于构建 web 应用。</p><p id="9cec" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe no np nq ng b">serde ="1.0.136"</code>是一个序列化和反序列化 Rust 数据结构的框架。例如，将 Rust 结构转换为 JSON。</p><p id="d36c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe no np nq ng b">dotenv ="0.15.0"</code>是一个管理环境变量的库。</p><p id="48a2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe no np nq ng b">futures ="0.3"</code>是一个在 rust 中做异步编程的库。</p><p id="4cc6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe no np nq ng b">[dependencies.mongodb]</code>是连接 MongoDB 的驱动。它还指定了所需的版本和特性类型(异步 API)。</p><p id="9907" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们需要运行下面的命令来安装依赖项:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="5477" class="mp kz in ng b gy nk nl l nm nn">cargo build</span></pre><h1 id="5e42" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">应用程序入口点</h1><p id="6718" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">安装好项目依赖项后，将<code class="fe no np nq ng b">src</code>文件夹中的<code class="fe no np nq ng b">main.rs</code>文件修改如下:</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="ac55" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="a308" class="mb mc in kb b kc kd kg kh kk md ko me ks mf kw mg mh mi mj bi translated">导入所需的依赖项</li><li id="ef15" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">创建一个<code class="fe no np nq ng b">hello</code>处理程序，它使用 Rust 宏来指定 HTTP 方法、路由路径<code class="fe no np nq ng b">/</code>，并返回一个<code class="fe no np nq ng b">Hello from rust and mongoDB</code>的 JSON。</li><li id="5372" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">使用<code class="fe no np nq ng b">#[actix_web::main]</code>宏在 actix 运行时中异步运行<code class="fe no np nq ng b">main</code>函数。main 函数执行以下操作:<br/> -使用<code class="fe no np nq ng b">HttpServer</code> struct 创建一个新的服务器，该服务器使用一个闭包来服务使用<code class="fe no np nq ng b">App</code>实例的传入请求。<code class="fe no np nq ng b">App</code>也注册<code class="fe no np nq ng b">hello</code>处理器。<code class="fe no np nq ng b">HttpServer</code>是我们应用程序的主干；它负责处理请求、允许的最大连接数、分层安全等，而<code class="fe no np nq ng b">App</code>处理应用程序逻辑，如请求处理程序、中间件、路由等<br/> -配置服务器异步运行并处理<code class="fe no np nq ng b">localhost:8080</code>上的 HTTP 请求。</li></ul><p id="6ad8" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">接下来，我们可以通过在终端中运行下面的命令来测试我们的应用程序。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="21bc" class="mp kz in ng b gy nk nl l nm nn">cargo run</span></pre><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nt"><img src="../Images/bc85d88731a3a3bb4af7a460f72b3c66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qkYa28JyvglqzfoT.png"/></div></div></figure><h1 id="87d7" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">生锈的模块系统</h1><p id="0622" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">Rust 中的模块是一种将代码分割成可重用组件并管理它们之间可见性的机制。模块帮助我们为我们的项目保持一个良好的项目结构。</p><p id="a1f2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为此，我们需要导航到<code class="fe no np nq ng b">src</code>文件夹，并使用相应的<code class="fe no np nq ng b">mod.rs</code>文件创建<code class="fe no np nq ng b">api</code>、<code class="fe no np nq ng b">models</code>和<code class="fe no np nq ng b">repository</code>文件夹来管理可见性。</p><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/b8b1f1c823a38a3ed50b68128e096c67.png" data-original-src="https://miro.medium.com/v2/resize:fit:522/format:webp/0*exuXK9ui5wI0tMeA.png"/></div></figure><p id="4539" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe no np nq ng b">api</code>用于模块化 API 处理程序。</p><p id="e3a5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe no np nq ng b">models</code>用于模块化数据逻辑。</p><p id="b180" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe no np nq ng b">repository</code>用于模块化数据库逻辑。</p><p id="4e42" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">添加对模块的引用</strong></p><p id="e018" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">要使用模块中的代码，我们需要将它们声明为一个模块，并将它们导入 main.rs 文件。</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h1 id="32ef" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">设置 MongoDB</h1><p id="e0bd" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">完成后，我们需要登录或注册我们的<a class="ae kx" href="http://" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>账户。点击项目下拉菜单并点击<strong class="kb io">新项目</strong>按钮。</p><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nv"><img src="../Images/505b3ed20c6f1ae89f40b1c75aaa4551.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*m1W13O0qBIcE9BOR.png"/></div></div></figure><p id="4087" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">输入<code class="fe no np nq ng b">rust-api</code>作为项目名称，点击<strong class="kb io">下一个</strong>，点击<strong class="kb io">创建项目..</strong></p><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nw"><img src="../Images/839bfd0264d4ad940c71d4adfdb1950e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yqSxzSL4ItvcHY_J.png"/></div></div></figure><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nv"><img src="../Images/8400eb2d97e0405a9138b504edd89bf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zlZ99PYwSE5Zu7Bx.png"/></div></div></figure><p id="87e6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">点击<strong class="kb io">建立数据库</strong></p><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nw"><img src="../Images/7d4452e75970853ce15b2462b2995f40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Nz30OrfJrB_4rivV.png"/></div></div></figure><p id="f34b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">选择<strong class="kb io">共享</strong>作为数据库类型。</p><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nv"><img src="../Images/0e460c176427d6e4591ec12a5ca52ee9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ujNJtFB2Xt9hCeXy.png"/></div></div></figure><p id="c537" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">点击<strong class="kb io">创建</strong>以设置集群。这可能需要一些时间来设置。</p><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nv"><img src="../Images/fad12087fbce02b6293406df3fb17a13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*X0Sv_i9qR3xqQNxI.png"/></div></div></figure><p id="3425" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">接下来，我们需要通过输入<strong class="kb io">用户名</strong>、<strong class="kb io">密码</strong>然后点击<strong class="kb io">创建用户</strong>来创建一个从外部访问数据库的用户。我们还需要添加我们的 IP 地址，以便通过点击<strong class="kb io">添加我当前的 IP 地址</strong>按钮安全地连接到数据库。然后点击<strong class="kb io">完成并关闭</strong>保存更改。</p><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nw"><img src="../Images/87c16548833b67c56eae72260ecb2c6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gC6XRMKZ3tpvHyzE.png"/></div></div></figure><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nw"><img src="../Images/887453c843905a0e4085a74efd04c291.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ouWxw5BNzlBHznmP.png"/></div></div></figure><p id="fc99" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">保存更改后，我们应该会看到一个数据库部署屏幕，如下所示:</p><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nw"><img src="../Images/906da34920e544b0c1d7803413e2e0a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5fhTjf9ugc9GMUVl.png"/></div></div></figure><h1 id="eb48" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">将我们的应用程序连接到 MongoDB</h1><p id="b45f" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">配置完成后，我们需要将应用程序与创建的数据库连接起来。为此，点击<strong class="kb io">连接</strong>按钮</p><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nv"><img src="../Images/0696f659da212d7a804acd4c0517e0fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MAj7hFNbmI_vSiiV.png"/></div></div></figure><p id="7765" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">点击<strong class="kb io">连接你的应用</strong>，将<strong class="kb io">驱动</strong>改为 Rust，并将<strong class="kb io">版本</strong>如下图所示。然后点击复制图标<strong class="kb io">复制连接字符串。</strong></p><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nv"><img src="../Images/49d45b001a9802654343b4b45ba46e73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qf8DO_iBCx6SRFjB.png"/></div></div></figure><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nx"><img src="../Images/9eea31f0c7c33affef35ea16b1ebe192.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RQy81cl9Jd83q0IY.png"/></div></div></figure><p id="5dcd" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">设置环境变量<br/> </strong>接下来，我们必须用我们之前创建的用户密码修改复制的连接字符串，并更改数据库名称。为此，首先，我们需要在根目录中创建一个. env 文件，并在该文件中添加复制的代码片段:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="a30d" class="mp kz in ng b gy nk nl l nm nn">MONGOURI=mongodb+srv://&lt;YOUR USERNAME HERE&gt;:&lt;YOUR PASSWORD HERE&gt;@cluster0.e5akf.mongodb.net/myFirstDatabese?retryWrites=true&amp;w=majority</span></pre><p id="e2a3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">下面是正确填充的连接字符串示例:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="1db8" class="mp kz in ng b gy nk nl l nm nn">MONGOURI=mongodb+srv://malomz:malomzPassword@cluster0.e5akf.mongodb.net/golangDB?retryWrites=true&amp;w=majority</span></pre><h1 id="1dae" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">创建 REST APIs</h1><p id="4e6b" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">设置完成后，我们需要创建一个模型来表示我们的应用程序数据。为此，我们需要导航到<code class="fe no np nq ng b">models</code>文件夹，在这个文件夹中，创建一个<code class="fe no np nq ng b">user_model.rs</code>文件，并添加下面的代码片段:</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="4621" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="bcef" class="mb mc in kb b kc kd kg kh kk md ko me ks mf kw mg mh mi mj bi translated">导入所需的依赖项</li><li id="ca60" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">使用<code class="fe no np nq ng b">derive</code>宏生成对格式化输出、序列化和反序列化数据结构的实现支持。</li><li id="4700" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">创建一个具有所需属性的<code class="fe no np nq ng b">User</code>结构。我们还向<code class="fe no np nq ng b">id</code>属性添加了字段属性，以便重命名并在字段为空时忽略它。</li></ul><p id="998e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">PS</strong>:<em class="ny"/><code class="fe no np nq ng b"><em class="ny">pub</em></code><em class="ny">修饰符将结构体及其属性公开，可以从其他文件/模块中访问。</em></p><p id="f87b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">接下来，我们必须将<code class="fe no np nq ng b">user_model.rs</code>文件注册为<code class="fe no np nq ng b">models</code>模块的一部分。为此，打开<code class="fe no np nq ng b">models</code>文件夹中的<code class="fe no np nq ng b">mod.rs</code>，添加下面的代码片段:</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="aed3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">创建一个用户端点<br/> </strong>模型完全建立并可供使用后，我们现在可以创建我们的数据库逻辑来创建一个用户。为此，首先，我们需要导航到<code class="fe no np nq ng b">repository</code>文件夹，在这个文件夹中，创建一个<code class="fe no np nq ng b">mongodb_repo.rs</code>文件并添加下面的代码片段:</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="e0fa" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="0733" class="mb mc in kb b kc kd kg kh kk md ko me ks mf kw mg mh mi mj bi translated">导入所需的依赖项</li><li id="e9d2" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">创建一个带有<code class="fe no np nq ng b">col</code>字段的<code class="fe no np nq ng b">MongoRepo</code>结构来访问 MongoDB 集合</li><li id="bb93" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">创建一个将方法添加到<code class="fe no np nq ng b">MongoRepo</code>结构的实现块</li><li id="8051" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">向实现块添加一个<code class="fe no np nq ng b">init</code>方法来加载环境变量，创建到数据库的连接，并返回一个<code class="fe no np nq ng b">MongoRepo</code>结构的实例</li><li id="e0c9" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">添加一个<code class="fe no np nq ng b">create_user</code>方法，该方法接受一个<code class="fe no np nq ng b">self</code>和<code class="fe no np nq ng b">new_user</code>作为参数，并返回创建的用户或一个错误。在方法内部，我们使用<code class="fe no np nq ng b">User</code>结构创建了一个新文档。然后，我们使用引用<code class="fe no np nq ng b">MongoRepo</code>结构的<code class="fe no np nq ng b">self</code>从集合中访问<code class="fe no np nq ng b">insert_one</code>函数，以创建一个新用户并处理错误。最后，我们返回了创建的用户信息。</li></ul><p id="b176" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> PS: </strong> <em class="ny">新建文档时指定的</em> <code class="fe no np nq ng b"><em class="ny">None</em></code> <em class="ny">告诉 MongoDB 自动生成用户的</em> <strong class="kb io"> <em class="ny"> id </em> </strong> <em class="ny">。</em></p><p id="a392" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">接下来，我们必须将<code class="fe no np nq ng b">mongodb_repo.rs</code>文件注册为<code class="fe no np nq ng b">repository</code>模块的一部分。为此，打开<code class="fe no np nq ng b">repository</code>文件夹中的<code class="fe no np nq ng b">mod.rs</code>并添加以下代码片段:</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="38f5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">其次，我们需要创建一个处理程序，它使用存储库中的<code class="fe no np nq ng b">create_user</code>方法来创建用户。为此，我们需要导航到<code class="fe no np nq ng b">api</code>文件夹，在这个文件夹中，创建一个<code class="fe no np nq ng b">user_api.rs</code>文件，并添加下面的代码片段:</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="7797" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="b1e3" class="mb mc in kb b kc kd kg kh kk md ko me ks mf kw mg mh mi mj bi translated">导入所需的依赖项</li><li id="b24a" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">使用路由宏指定 HTTP 方法和相应的路由</li><li id="4b12" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">创建一个<code class="fe no np nq ng b">create_user</code>处理程序，它接受<code class="fe no np nq ng b">db</code>、一个类型到<code class="fe no np nq ng b">MongoRepo</code>和一个<code class="fe no np nq ng b">new_user</code>作为参数。在处理程序内部，我们创建了一个用于创建用户的<code class="fe no np nq ng b">data</code>变量，使用<code class="fe no np nq ng b">db.create_user</code>方法将其插入到数据库中，如果插入成功，则返回正确的响应，如果有错误，则返回错误。</li></ul><p id="2fc5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> PS: </strong> <em class="ny">用于定义参数的</em> <code class="fe no np nq ng b"><em class="ny">Data</em></code> <em class="ny">和</em> <code class="fe no np nq ng b"><em class="ny">Json</em></code> <em class="ny"> struct 分别用于管理跨路由共享的应用状态和从请求净荷中提取 JSON 数据。</em></p><p id="c8fc" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">最后，我们需要修改我们的应用程序入口点，以包含<code class="fe no np nq ng b">create_user</code>处理程序。为此，我们需要导航到<code class="fe no np nq ng b">main.rs</code>文件并修改它，如下所示:</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="25d5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="2e3b" class="mb mc in kb b kc kd kg kh kk md ko me ks mf kw mg mh mi mj bi translated">导入所需的依赖项</li><li id="9707" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">通过调用<code class="fe no np nq ng b">init()</code>方法创建一个<code class="fe no np nq ng b">db</code>变量来建立到 MongoDB 的连接，并将其添加到<code class="fe no np nq ng b">Data</code> struct 的一个新实例中，以便数据库状态可以在整个应用程序范围内可用。</li><li id="b972" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">使用<code class="fe no np nq ng b">app_data</code>和<code class="fe no np nq ng b">service</code>函数将应用程序数据和处理程序添加到<code class="fe no np nq ng b">App</code>实例中。</li></ul><p id="c404" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">PS:闭包附带的<code class="fe no np nq ng b">move</code>关键字赋予了它对 MongoDB 配置的所有权。</p><p id="5664" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">获取一个用户端点<br/> </strong>要获取一个用户的详细信息，我们必须首先通过向实现块添加一个<code class="fe no np nq ng b">get_user</code>方法来修改<code class="fe no np nq ng b">mongodb_repo.rs</code>文件。</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="1265" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="b511" class="mb mc in kb b kc kd kg kh kk md ko me ks mf kw mg mh mi mj bi translated">修改依赖关系以包括<code class="fe no np nq ng b">oid::ObjectId</code>和<code class="fe no np nq ng b">doc</code></li><li id="29b3" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">添加一个<code class="fe no np nq ng b">get_user</code>方法，它接受一个<code class="fe no np nq ng b">self</code>和<code class="fe no np nq ng b">id</code>作为参数，并返回用户详细信息或一个错误。在该方法中，我们将<code class="fe no np nq ng b">id</code>转换为<code class="fe no np nq ng b">ObjectId</code>，并将其用作<code class="fe no np nq ng b">filter</code>来获取匹配的文档。然后，我们使用引用<code class="fe no np nq ng b">MongoRepo</code>结构的<code class="fe no np nq ng b">self</code>从集合中访问<code class="fe no np nq ng b">find_one</code>函数，以获取用户的详细信息并处理错误。最后，我们返回了创建的用户信息。</li></ul><p id="4586" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">其次，我们需要通过创建一个处理程序来修改<code class="fe no np nq ng b">user_api.rs</code>，该处理程序使用来自<code class="fe no np nq ng b">repository</code>的<code class="fe no np nq ng b">get_user</code>方法来获取用户。</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="4b8e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="6d99" class="mb mc in kb b kc kd kg kh kk md ko me ks mf kw mg mh mi mj bi translated">修改依赖关系以包括<code class="fe no np nq ng b">get</code>和<code class="fe no np nq ng b">Path</code></li><li id="ae82" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">使用路由宏指定 HTTP 方法、相应的路由和路由参数</li><li id="3d09" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">创建一个<code class="fe no np nq ng b">get_user</code>处理程序，它接受<code class="fe no np nq ng b">db</code>、一个到<code class="fe no np nq ng b">MongoRepo</code>的类型和一个用于访问路由路径的<code class="fe no np nq ng b">path</code>作为参数。在处理程序内部，我们创建了一个<code class="fe no np nq ng b">id</code>变量来获取用户的<strong class="kb io"> id </strong>，使用<code class="fe no np nq ng b">db.get_user method</code>从数据库中获取用户的详细信息。如果请求成功，我们返回正确的响应，如果有错误，则返回错误。</li></ul><p id="a1d9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">最后，我们需要修改我们的应用程序入口点(<code class="fe no np nq ng b">main.rs</code>)，通过导入处理程序并为其添加一个新的<code class="fe no np nq ng b">service</code>来包含<code class="fe no np nq ng b">get_user</code>处理程序。</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="30f7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">编辑一个用户端点<br/> </strong>要编辑一个用户，我们必须首先通过在实现块中添加一个<code class="fe no np nq ng b">edit_user</code>方法来修改<code class="fe no np nq ng b">mongodb_repo.rs</code>文件。</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="d17c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="ec0b" class="mb mc in kb b kc kd kg kh kk md ko me ks mf kw mg mh mi mj bi translated">修改依赖关系以包括<code class="fe no np nq ng b">UpdateResult</code></li><li id="dc6d" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">添加一个<code class="fe no np nq ng b">update_user</code>方法，该方法接受一个<code class="fe no np nq ng b">self</code>、<code class="fe no np nq ng b">id</code>和<code class="fe no np nq ng b">new_user</code>参数，并返回更新的用户详细信息或一个错误。在该方法中，我们将<code class="fe no np nq ng b">id</code>转换为<code class="fe no np nq ng b">ObjectId</code>，创建了一个<code class="fe no np nq ng b">filter</code>变量来获取我们想要更新的匹配文档，并使用<code class="fe no np nq ng b">doc</code>宏来更新文档字段。然后，我们使用引用<code class="fe no np nq ng b">MongoRepo</code>结构的<code class="fe no np nq ng b">self</code>从集合中访问<code class="fe no np nq ng b">update_one</code>函数，以更新匹配指定过滤器的用户并处理错误。最后，我们返回了更新后的用户信息。</li></ul><p id="fbd0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">其次，我们需要通过创建一个处理程序来修改<code class="fe no np nq ng b">user_api.rs</code>，该处理程序使用来自<code class="fe no np nq ng b">repository</code>的<code class="fe no np nq ng b">update_user</code>方法来更新用户。</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="e703" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="c086" class="mb mc in kb b kc kd kg kh kk md ko me ks mf kw mg mh mi mj bi translated">修改依赖关系以包括<code class="fe no np nq ng b">put</code>和<code class="fe no np nq ng b">ObjectId</code></li><li id="5441" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">使用路由宏指定 HTTP 方法、相应的路由和路由参数</li><li id="f6f1" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">创建一个<code class="fe no np nq ng b">update_user</code>处理程序，它接受一个类型<code class="fe no np nq ng b">db</code>、<code class="fe no np nq ng b">path</code>和<code class="fe no np nq ng b">new_user</code>作为参数。在处理程序内部，我们创建了一个<code class="fe no np nq ng b">id</code>变量来获取用户的<strong class="kb io"> id </strong>，通过传递更新后的用户信息，使用<code class="fe no np nq ng b">db.update_user</code>方法从数据库中更新用户的详细信息。最后，我们检查更新是否成功，并返回更新后的用户或错误(如果有)。</li></ul><p id="5b97" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">最后，我们需要修改我们的应用程序入口点(<code class="fe no np nq ng b">main.rs</code>)，通过导入处理程序并为其添加一个新的<code class="fe no np nq ng b">service</code>来包含<code class="fe no np nq ng b">update_user</code>处理程序。</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="2386" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">删除用户端点<br/></strong></p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="aac9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="76a4" class="mb mc in kb b kc kd kg kh kk md ko me ks mf kw mg mh mi mj bi translated">修改依赖关系以包括<code class="fe no np nq ng b">DeleteResult</code></li><li id="4665" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">添加一个<code class="fe no np nq ng b">delete_user</code>方法，该方法接受一个<code class="fe no np nq ng b">self</code>和<code class="fe no np nq ng b">id</code>作为参数，并返回删除的用户详细信息或一个错误。在该方法中，我们将<code class="fe no np nq ng b">id</code>转换为<code class="fe no np nq ng b">ObjectId</code>，并创建了一个<code class="fe no np nq ng b">filter</code>变量来获取我们想要删除的匹配文档。然后，我们使用引用<code class="fe no np nq ng b">MongoRepo</code>结构的<code class="fe no np nq ng b">self</code>从集合中访问<code class="fe no np nq ng b">delete_one</code>函数，以删除匹配指定过滤器的用户并处理错误。最后，我们返回了删除的用户信息。</li></ul><p id="6910" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">其次，我们需要通过创建一个处理程序来修改<code class="fe no np nq ng b">user_api.rs</code>，该处理程序使用来自<code class="fe no np nq ng b">repository</code>的<code class="fe no np nq ng b">delete_user</code>方法来删除用户。</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="af54" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="0ed6" class="mb mc in kb b kc kd kg kh kk md ko me ks mf kw mg mh mi mj bi translated">修改依赖关系以包括<code class="fe no np nq ng b">delete</code></li><li id="1a57" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">使用路由宏指定 HTTP 方法、相应的路由和路由参数</li><li id="6300" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">创建一个接受<code class="fe no np nq ng b">db</code>的<code class="fe no np nq ng b">delete_user</code>处理程序，作为参数的是<code class="fe no np nq ng b">MongoRepo</code>和<code class="fe no np nq ng b">path</code>的类型。在处理程序内部，我们创建了一个<code class="fe no np nq ng b">id</code>变量来获取用户的<strong class="kb io"> id </strong>和<strong class="kb io"> </strong>使用<code class="fe no np nq ng b">db.delete_user</code>方法通过传入<code class="fe no np nq ng b">id</code>从数据库中删除用户。最后，我们返回适当的响应或错误(如果有的话)。</li></ul><p id="6e3c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">最后，我们需要修改我们的应用程序入口点(<code class="fe no np nq ng b">main.rs</code>)，通过导入处理程序并为其添加一个新的<code class="fe no np nq ng b">service</code>来包含<code class="fe no np nq ng b">delete_user</code>处理程序。</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="d760" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">获取所有用户端点<br/> </strong>要获取用户列表，我们必须首先通过向实现块添加一个<code class="fe no np nq ng b">get_all_users</code>方法来修改<code class="fe no np nq ng b">mongodb_repo.rs</code>文件。</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="93c3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">上面的代码片段添加了一个<code class="fe no np nq ng b">get_all_users</code>方法，该方法接受一个<code class="fe no np nq ng b">self</code>作为参数，并返回用户列表或一个错误。在该方法中，我们使用引用<code class="fe no np nq ng b">MongoRepo</code>结构的<code class="fe no np nq ng b">self</code>来访问集合中的<code class="fe no np nq ng b">find</code>函数，而不使用任何过滤器，这样它可以匹配数据库中的所有文档，使用<code class="fe no np nq ng b">try_next()</code>方法循环遍历用户列表并处理错误，从而以最佳方式返回列表。</p><p id="9ad4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">其次，我们需要通过创建一个处理程序来修改<code class="fe no np nq ng b">user_api.rs</code>，该处理程序使用来自<code class="fe no np nq ng b">repository</code>的<code class="fe no np nq ng b">get_all_users</code>方法来获取用户列表。</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="4993" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">上面的代码片段执行了以下操作:</p><ul class=""><li id="bce8" class="mb mc in kb b kc kd kg kh kk md ko me ks mf kw mg mh mi mj bi translated">使用路由宏指定 HTTP 方法和相应的路由</li><li id="b6c4" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">创建一个使用<code class="fe no np nq ng b"> db.delete_user</code>方法获取用户列表的<code class="fe no np nq ng b">get_all_users</code>处理程序。然后，我们返回用户列表或错误(如果有的话)。</li></ul><p id="75f9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">最后，我们需要修改我们的应用程序入口点(<code class="fe no np nq ng b">main.rs</code>)，通过导入处理程序并为其添加新的<code class="fe no np nq ng b">service</code>来包含<code class="fe no np nq ng b">get_all_users</code>处理程序。</p><figure class="nb nc nd ne gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="8f65" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">完成后，我们可以通过在终端中运行下面的命令来测试我们的应用程序。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="06a6" class="mp kz in ng b gy nk nl l nm nn">cargo run</span></pre><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nv"><img src="../Images/0171591e1c24642c84512ceb1ebc197d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*r36F6b1PTNjBEC-8.png"/></div></div></figure><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nv"><img src="../Images/1a3b7f513009b67cd839e85540b75531.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wXqGnVVNSVCDem-T.png"/></div></div></figure><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nv"><img src="../Images/dbab4f449f9783e54a34afc04cda0915.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*m1CcFvw4Dm1M_u0H.png"/></div></div></figure><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nv"><img src="../Images/13ba69ddf73e4bac29d133c8d7925fae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*coULPe1dZnRQKjC0.png"/></div></div></figure><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nv"><img src="../Images/90fa6020219219f402bd4c1881a5e873.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*u9DF-lC4fYO6q5cQ.png"/></div></div></figure><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nz"><img src="../Images/6b9cc310bf5d307a60e01dccbacc0698.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AbkYqJoWy-p1aGQ3.png"/></div></div></figure><h1 id="8ff7" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="5b90" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">这篇文章讨论了如何模块化 Rust 应用程序，构建 REST API，并使用 MongoDB 持久化我们的数据。</p><p id="1c40" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">您可能会发现这些资源很有帮助:</p><ul class=""><li id="a546" class="mb mc in kb b kc kd kg kh kk md ko me ks mf kw mg mh mi mj bi translated"><a class="ae kx" href="https://actix.rs/" rel="noopener ugc nofollow" target="_blank"> Actix web </a></li><li id="55ca" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated"><a class="ae kx" href="https://github.com/mongodb/mongo-rust-driver" rel="noopener ugc nofollow" target="_blank"> MongoDB Rust 驱动</a></li><li id="02e4" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated"><a class="ae kx" href="https://serde.rs/" rel="noopener ugc nofollow" target="_blank"> Serde(序列化和反序列化库)</a></li><li id="b987" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated"><a class="ae kx" href="https://crates.io/crates/dotenv" rel="noopener ugc nofollow" target="_blank">铁锈环境装载机</a></li></ul></div></div>    
</body>
</html>