<html>
<head>
<title>Go — Various ways to use functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">go-使用函数的各种方法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/go-various-ways-to-use-functions-e89e073f7570?source=collection_archive---------6-----------------------#2022-10-27">https://blog.devgenius.io/go-various-ways-to-use-functions-e89e073f7570?source=collection_archive---------6-----------------------#2022-10-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/6474c98199151912036f1b2e5d2ce3c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rqeJOHAVfW8MUydYkD7FzA.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">琼·加梅尔在<a class="ae jz" href="https://unsplash.com/s/photos/functions?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="1476" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我最近开始涉猎 go 语言，我对该语言中函数的大量使用方式印象深刻！这个故事探讨了这个问题。我开始这一旅程的一些原因是为了更好地理解#kubernetes 源代码，不仅如此，我现在已经赶上了 GO，因为这种语言非常简单。</p><p id="618e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">go 中的函数可能有也可能没有返回类型。如果 go 中的函数没有返回类型，它将遵循以下模式:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="155c" class="lh li in ld b gy lj lk l ll lm">func theFuncName(param1 data-type, param2 data-type) {</span><span id="c74e" class="lh li in ld b gy ln lk l ll lm">    // ...</span><span id="49ed" class="lh li in ld b gy ln lk l ll lm">}</span></pre><p id="1768" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另一方面，如果有返回类型，它遵循下面的模式。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="f57d" class="lh li in ld b gy lj lk l ll lm">func theFuncName(param1 data-type, param2 data-type) return-data-type {</span><span id="a785" class="lh li in ld b gy ln lk l ll lm">    // ...</span><span id="df98" class="lh li in ld b gy ln lk l ll lm">}</span></pre><p id="e63d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以，现在让我们开始探索可以在 GO 中编写的各种类型的函数。我将简要地讨论一下我对使用函数的每一种方法的理解。</p><ol class=""><li id="1dad" class="lo lp in kc b kd ke kh ki kl lq kp lr kt ls kx lt lu lv lw bi translated"><strong class="kc io">一个简单的功能</strong></li></ol><p id="c98f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第一种类型是带有返回值的函数的最简单版本。这个函数称为 simpleFunc，它接受两个整数 x 和 y 作为参数，并返回这两个数字的和作为结果。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="d4b0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 2。命名函数</strong></p><p id="6d39" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这种类型中，返回值是预先命名的。除此之外，它类似于第一种方法</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="ec75" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 3。返回多个值</strong></p><p id="98fd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">GO 的一个有趣特性是能够从一个函数返回多个值。这个例子说明了。在这种情况下，3 个数字被传递给称为多值的函数，它们被平方，所有的结果立即返回！</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="6ab6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请注意，返回类型被指定为(int，int，int)是为了表明该函数一次返回 3 个值。</p><p id="6ed1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 4。返回多个值，名为</strong></p><p id="c255" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个方法类似于前面的方法，唯一的不同是返回值被命名为。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="00f9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 5。可变函数</strong></p><p id="f95b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你来自 C#世界，你已经熟悉这种类型的函数，它们被称为可变参数数量。不过，可变函数听起来更酷:-)</p><p id="4fe9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这种情况下，函数 variadicFunc 接受可变数量的整数，由<strong class="kc io"> nums …int </strong>表示。GO 中的“…”表示一个范围，在这种情况下是整数范围。因此，for 循环用于遍历并相加每个数字，以得出所有传递的数字的总数。注意 for 循环中的 _，n。第一个参数是索引，第二个参数是数字本身。在这种情况下，我不关心索引，所以我使用 _ 来丢弃它。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="c963" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 6。作用于结构的函数</strong></p><p id="bf86" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">作用于对象的函数也可以称为“方法”。如果你来自 C#世界，你一定很熟悉 POCO's 这个词，它是普通老式 C#对象的简称。在 GO 的例子中，结构被用来实现同样的功能。还要注意，C#也有结构。这个函数演示了如何定义一个函数来作用于一个结构的实例。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="6b88" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这个例子中，定义了一个名为<strong class="kc io"> SomeStruct </strong>的结构。现在，<strong class="kc io">using a point</strong>是一个旨在对<strong class="kc io"> SomeStruct </strong>的实例进行操作的函数。这种函数的格式是:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="ca2f" class="lh li in ld b gy lj lk l ll lm">func (var-name *struct-name) theFuncName(param1 data-type, ...) return-type {</span><span id="db2c" class="lh li in ld b gy ln lk l ll lm">   // ...</span><span id="6b45" class="lh li in ld b gy ln lk l ll lm">}</span></pre><p id="96be" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种方法的一种变体是定义一个不使用指向结构的指针的函数。在这种情况下，可以在不使用 new 的情况下创建结构的新实例，如下所示:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="c99c" class="lh li in ld b gy lj lk l ll lm">someStruct := SomeStruct{"John Doe"}</span></pre><p id="247b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是 C#和 GO 的横向比较。在这两种情况下，都有一个用户类/结构和一个对类/结构的属性进行操作的方法。我从另一个媒体帖子中获得了这个灵感，一旦我再次找到它，我会链接到它。</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lz"><img src="../Images/ad3e7331923cb477ed489143e4a70ae1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RvVrDtntBf1zuZTqxJmE3Q.png"/></div></div></figure><p id="b30d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 7。函数返回函数</strong></p><p id="1c6a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">GO 函数也可以返回类似于变量的函数。在 C#的世界里，你可以把这想象成返回一个<strong class="kc io">Action&lt;T&gt;T9】或者一个<strong class="kc io"> Func &lt; T，V&gt;T11】。</strong></strong></p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="b1f2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你注意到的话，函数定义的编写方式仍然适用。然而，在这种情况下会返回一个函数。即<strong class="kc io"> func(int，int) int </strong>。接受两个整数并返回一个整数的函数。请注意，返回的函数不包含名称。</p><p id="d4c7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 8。匿名函数</strong></p><p id="7fe2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">GO 还有匿名函数，可以同时定义和调用。在这种情况下，一个函数只需打印一条消息，然后一次性定义并调用它！</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="5ed7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> 9。延期功能</strong></p><p id="dc25" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对<strong class="kc io"> defer </strong>关键字的支持是我最喜欢的 GO 语言之一。defer 关键字可用于标识函数运行结束后必须运行的内容。多酷啊。！</p><p id="3ac6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">考虑这样一种情况，您正在打开一个文件进行读/写。假设这个程序永远不会终止。鉴于此，如果读/写该文件的函数必须关闭该文件。如果没有完成，其他试图读/写该文件的程序将会失败。发生这种情况的原因是，如果开发人员在函数快结束时忘记关闭文件。在 GO 中使用 defer 关键字可以很容易地避免这种情况。</p><p id="d84b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，考虑下面的函数:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="e04c" class="lh li in ld b gy lj lk l ll lm">package main</span><span id="5dae" class="lh li in ld b gy ln lk l ll lm">import "fmt"</span><span id="ac8d" class="lh li in ld b gy ln lk l ll lm">func main() {<br/> defer fmt.Println("I am done!")<br/> fmt.Println("This is the first line")<br/> fmt.Println("This is the second line")<br/> fmt.Println("This is the third line")<br/>}</span></pre><p id="5a9c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该函数的输出如下所示。注意我是如何完成这一行的！仅在<strong class="kc io">主</strong>功能中的所有内容执行完毕后打印。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="e70d" class="lh li in ld b gy lj lk l ll lm">This is the first line<br/>This is the second line<br/>This is the third line<br/>I am done!</span></pre><p id="c508" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面的例子还演示了关键字<strong class="kc io"> defer </strong>的行为。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="fb25" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">10。异步功能</p><p id="e01d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是我在 GO 语言中的另一个最爱。如果你来自 C#世界，你必须熟悉<strong class="kc io"> async/await </strong>模式来编写异步代码。在 GO 语言中使用<strong class="kc io">同步</strong>包也可以达到同样的效果。</p><p id="c28b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">考虑下面的例子。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="1b34" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在第 8 行有一个类型为<strong class="kc io"> sync 的变量。定义了 WaitGroup </strong>，称为<strong class="kc io"> wg </strong>。第 12 行使用 Add 函数表示 1 函数将异步启动，稍后将使用<strong class="kc io"> Wait </strong>方法等待该方法完成。<strong class="kc io"> go </strong>关键字用于指示函数<strong class="kc io"> asyncFunc </strong>必须异步执行，如第 14 行所示，<strong class="kc io"> Wait </strong>方法用于异步方法完成。</p><p id="9fcb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">还要注意 defer 关键字是如何使用由<strong class="kc io"> WaitGroup </strong>提供的<strong class="kc io"> Done </strong>方法来表示完成的。</p><p id="db0d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">11。传递一个函数指针</p><p id="b4ad" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这种类型中，对变量的引用通过使用&amp;来传递。我学到的一件有趣的事情是，与 C/C++不同的是，问题中变量的地址不是被发送，而是它的一个副本。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="7524" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">12。将切片传递给功能</p><p id="dee4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种类型处理两种不同类型的整数数组——一种大小不固定，另一种大小固定。在固定整数数组的情况下，值就地更新</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="5a83" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">13。参考通过</p><p id="51d3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Go 有个叫 maps 的东西，类似于 C#里的字典。要在 GO 中定义一个字符串和整数的字典，您可以执行以下操作。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="2d1f" class="lh li in ld b gy lj lk l ll lm">items := map[string]int{ "coins": 1, "pens": 2, "chairs": 4 }</span></pre><p id="b848" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">映射稍有不同，因为传递映射传递的是有问题的变量的地址，而不是类型 11 中提到的副本。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="bf71" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">14。将函数作为参数传递</p><p id="cf0e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是 GO 语言提供的另一个很酷的特性。就像函数如何返回函数一样，GO 中的函数也可以将函数作为参数。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="9e2f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这个特殊的例子中，<strong class="kc io"> squareFunc </strong>接受一个整数并通过平方输入返回一个整数，它作为参数传递给另一个也接受整数的函数。<strong class="kc io"> f func(int) int </strong>参数是被传递的函数，它可以像任何其他 GO 函数一样被调用</p><p id="b8cf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">15。关闭</p><p id="e3bb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">GO 中的闭包是匿名函数，也可以自动保存对定义在其主体之外的变量的引用</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="5f00" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，这里是包含所有功能的要点。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="7a3f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我是围棋界的新手，所以如果我有什么错误，请留言告诉我。感谢阅读！</p></div></div>    
</body>
</html>