# C++中的内存分配

> 原文：<https://blog.devgenius.io/memory-allocation-in-c-2520c266ad0b?source=collection_archive---------0----------------------->

*c++中的静态内存分配和动态内存分配。*

![](img/ecc625489a7ef0129826f6e7ecc9db88.png)

[安娜·季娅科娃](https://unsplash.com/@annadyakov1999?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

每个变量使用计算机内存空间来存储它的值。

当我们使用术语**分配**时，我们表示该变量已经在计算机内存上被给定了一个空间。

**Deallocations** 表示空间已经被计算机回收，现在无法访问该变量。

本文解释了在 C++编程语言中，如何将这些内存分配给变量。

记忆分为两部分。第一个叫做**堆栈内存**，另一个叫做**堆内存**。

> *堆栈内存*存储函数调用中声明的变量，通常比堆内存小。
> 
> *堆内存*用于动态内存分配，一般大于堆栈内存。

C++中的内存分配有两种方法。

其中之一是 ***静态内存分配*** ，也称为编译时分配。

另一种叫做 ***动态内存分配*** ，也就是运行时分配。

# 静态内存分配

> 在静态内存分配中，变量的大小和存储位置在编译时是固定的。

让我们使用下面的代码来看看静态内存分配是如何发生的。

上面的代码中有三个变量， **x** 是一个整数变量， **ch** 是一个字符变量， **a** 是一个整数数组。

在静态内存分配中，编译器会计算这些变量需要多少内存，并确定这些变量的存储位置。

想象一个如下的符号表，

> 答— -> 0
> 
> ch —-> 401
> 
> x — ->402

使用这样的表，变量的存储位置就被保存了。但是，实际的物理内存是**而不是**在编译时分配给变量的。

> 实际的物理内存只在运行时分配。

关于静态内存分配其他一些要点如下:

1.  静态内存分配**略快于动态内存分配**。
2.  这种类型的内存分配不太灵活。
3.  内存的分配和释放是由编译器自己完成的。

# 动态存储分配

> 动态内存分配允许您在程序执行期间定义内存需求。

动态内存分配使用特殊类型的内存，称为**堆内存。**不要把这和堆数据结构混淆。

在动态内存分配中， **new** 关键字用于**分配**内存， **delete** 关键字用于**释放**内存。

与静态内存分配不同，内存的分配和释放应该由程序员来完成。这意味着程序员需要编写代码来分配和释放内存。

***new*** 关键字返回已经分配给 ***堆内存*** 上的变量的地址。这发生在程序执行期间。

让我们看看如何在运行时使用下面的代码动态分配内存。

在上面的代码中，有一个变量 **n** 是整型变量 **arr** 是整型指针。这两个变量都存储在内存的静态部分。

但是在程序执行过程中，根据 *n* 的值，**new*new*new**关键字返回数组已经分配的内存在堆上的物理地址。

请仔细阅读上述声明，以了解该程序的工作。

> ***arr*** 指向数组存储的地址。这里所说的地址是由 ***new*** 关键字返回的地址。

关于动态内存分配，需要注意的其他一些要点如下:

1.  动态内存分配的好处在于 ***重用*** 的内存是可能的。
2.  内存泄漏是可能的。程序员在将内存重新分配给另一个变量时需要小心。
3.  编译器不帮助分配和释放。程序员需要分配和释放内存。

这是 C++中的内存分配。感谢你的阅读，我希望你有一个好的阅读。祝你愉快！