<html>
<head>
<title>Linked List Algorithm: Is it a palindrome for singly-linked list?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">链表算法:它是单链表的回文吗？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/linked-list-algorithm-is-it-a-palindrome-for-singly-linked-list-3137291f76c9?source=collection_archive---------2-----------------------#2020-08-31">https://blog.devgenius.io/linked-list-algorithm-is-it-a-palindrome-for-singly-linked-list-3137291f76c9?source=collection_archive---------2-----------------------#2020-08-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/5945a56e0573540f91e0f4cfcf5917be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v6S7BQibuojA8loZUu8wNw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><a class="ae jz" href="https://www.educative.io/edpresso/what-is-a-linked-list" rel="noopener ugc nofollow" target="_blank">https://www.educative.io/edpresso/what-is-a-linked-list</a></figcaption></figure><h1 id="0ee1" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">什么是链表？</h1><p id="15ca" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">链表是一种数据结构，由一系列通过链接连接的节点组成。每个节点都包含一个值，并有一个指向链中下一个节点的next指针。头指针指向第一个节点，最后一个元素指向null。</p><p id="09f6" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">有不同类型的链表:</p><ul class=""><li id="404e" class="mb mc in la b lb lw lf lx lj md ln me lr mf lv mg mh mi mj bi translated">单向链表(单向)</li><li id="88ce" class="mb mc in la b lb mk lf ml lj mm ln mn lr mo lv mg mh mi mj bi translated">双向链表(双向)</li><li id="23e3" class="mb mc in la b lb mk lf ml lj mm ln mn lr mo lv mg mh mi mj bi translated">循环链表</li></ul><p id="e9e5" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">链表有简单的基本操作，如插入、删除、搜索。与数组不同，元素中的指针可以很容易地被改变以插入或删除元素。</p><h1 id="94d7" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">什么是回文？</h1><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mp"><img src="../Images/c64a53f49e3ecf9b93ec68aa2e7742e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yKs3dOTwWNI8Zmn0nlquJg.png"/></div></div></figure><p id="de72" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">回文是一个单词、短语或序列，向后读和向前读是一样的。</p><h1 id="3fd1" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">链表是回文吗？</h1><p id="bcbd" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">现在我们知道了什么是链表和回文，我们如何确定给定的链表是否是回文。</p><p id="2dda" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">用一个数组或一个字符串，来判断这些数据集是否是一个回文可以有不同的简单解法。一个可能的解决方案是制作一个反向副本，并将其与原始副本进行比较，以查看反向副本是否与原始副本相同。另一个可能的解决方案是遍历数组或字符串，比较第一个元素和最后一个元素，并对每个向中心移动的元素继续这样做。</p><p id="4524" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">至于单链表，不像字符串或者数组那么直接。这是因为没有前一个指针或尾指针，我们不知道列表中的最后一个节点或前一个节点，也不能快速确定列表的长度。</p><p id="e753" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">有些解决方案会占用额外的内存空间。例如，将链表中的所有值存储到一个数组中，并判断该数组是否为回文。或者制作链表的副本，反转链表的副本并将每个值与原始值进行比较。</p><p id="1d51" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">让我们按照以下步骤来考虑不占用额外内存的解决方案:</p><ol class=""><li id="6059" class="mb mc in la b lb lw lf lx lj md ln me lr mf lv mu mh mi mj bi translated">确定给定链表的中点(使用两个指针)</li><li id="27af" class="mb mc in la b lb mk lf ml lj mm ln mn lr mo lv mu mh mi mj bi translated">反转链表的后半部分</li><li id="7b34" class="mb mc in la b lb mk lf ml lj mm ln mn lr mo lv mu mh mi mj bi translated">比较链接列表值</li></ol><p id="6aa5" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">让我们以这幅图为例:</p><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mv"><img src="../Images/09c9f42993c1363a7bbb13027531d301.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xBYG3YOWpojZg2T_wKQo-w.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">举例。这个单链表是回文吗？</figcaption></figure><h1 id="ed43" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">使用2个指针确定中点。</h1><ul class=""><li id="79af" class="mb mc in la b lb lc lf lg lj mw ln mx lr my lv mg mh mi mj bi translated">快速指针—最初设置为与头部指针相同，移动速度比慢速指针快两倍，直到到达终点</li><li id="4660" class="mb mc in la b lb mk lf ml lj mm ln mn lr mo lv mg mh mi mj bi translated">慢速指针—最初设置为与头指针相同，将随着快速指针一次移动一个节点。</li></ul><p id="6ea3" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">查看慢速指针和快速指针如何在链表中穿行。</p><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mz"><img src="../Images/892381dfba045efaa3b15628accfcc60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7xyBItdtDbZsQF1H9AXa1A.png"/></div></div></figure><pre class="mq mr ms mt gt na nb nc nd aw ne bi"><span id="e129" class="nf kb in nb b gy ng nh l ni nj">let slow = head;<br/>let fast = head;<br/>while (fast &amp;&amp; fast.next) {<br/>  slow = slow.next<br/>  fast = fast.next.next;<br/>}</span></pre><h1 id="1855" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak">反转链表的后半部分</strong></h1><p id="0594" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">一般情况下，我们如何反转一个链表？</p><p id="f3b7" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">当我们遍历链表时，我们希望第一个节点是最后一个，因此它的下一个指针应该指向null。有了prev，head和temp指针，我们可以让head的下一个指针指向prev节点，并在列表中移动时继续这样做。我们需要一个临时指针，这样头部就知道下一步该去哪个节点。</p><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/71b067bdb81635f8f1a144fb6511fbe0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Axy5tcWlruhunbenXQ6fgg.png"/></div></div></figure><pre class="mq mr ms mt gt na nb nc nd aw ne bi"><span id="9472" class="nf kb in nb b gy ng nh l ni nj">var reverse = function(head) {<br/>  let prev = null;<br/>  while (head) {<br/>    let temp = head.next;<br/>    head.next = prev;<br/>    prev = head;<br/>    head = temp;<br/>  }<br/>  return prev;<br/>}</span></pre><p id="b342" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">让我们回到我们的例子，看看后半部分(指针变慢)是什么样子。</p><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nl"><img src="../Images/a5b4d5b6e6f3b42626daa0732d8a6b7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-VyVdTInJzUMtXkubB5ZLA.png"/></div></div></figure><p id="9647" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">我们的头指针和慢指针以及所有后面的指针都指向末尾或空。我们现在可以…</p><h1 id="19af" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak">比较链表值</strong></h1><p id="4188" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">当我们在head或slow不等于null的情况下遍历时，我们可以在向终点(或null)移动时比较head的值和slow的值。</p><pre class="mq mr ms mt gt na nb nc nd aw ne bi"><span id="c38e" class="nf kb in nb b gy ng nh l ni nj">while (slow) {<br/>  if (head.val !== slow.val) {<br/>    return false;<br/>  }<br/>    head = head.next;<br/>    slow = slow.next<br/>}</span></pre><p id="b2fe" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">让我们把所有的碎片放在一起，为我们的最终解决方案。</p><pre class="mq mr ms mt gt na nb nc nd aw ne bi"><span id="0340" class="nf kb in nb b gy ng nh l ni nj">var isPalindrome = function(head) {<br/>    let slow = head;<br/>    let fast = head;<br/>    while (fast &amp;&amp; fast.next) {<br/>        slow = slow.next<br/>        fast = fast.next.next;<br/>    }<br/>    slow = reverse(slow);<br/>    while (slow) {<br/>        if (head.val !== slow.val) {<br/>            return false;<br/>        }<br/>        head = head.next;<br/>        slow = slow.next<br/>    }<br/>    return true;<br/>};</span><span id="63ed" class="nf kb in nb b gy nm nh l ni nj">var reverse = function(head) {<br/>    let prev = null;<br/>    while (head) {<br/>        let temp = head.next;<br/>        head.next = prev;<br/>        prev = head;<br/>        head = temp;<br/>    }<br/>    return prev;<br/>}</span></pre><p id="7327" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这就对了，当这些步骤被分解并组合在一起时，并不那么糟糕！</p></div><div class="ab cl nn no hr np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ig ih ii ij ik"><p id="e453" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">我想用一个简单的数据结构算法来保持本周的文章简洁明了。在本周的Hack Reactor中，我们做了一个react redux和thunk sprint，这是一个状态管理工具。我认为这在概念上是有意义的，并且检查代码的工作方式也是有意义的(有时，我必须仔细考虑)。我期待了解更多关于React hooks的知识，因为它是React自己的状态管理系统。在接下来的几周里，我们会写更多的东西！</p></div></div>    
</body>
</html>