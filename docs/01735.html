<html>
<head>
<title>A holistic perspective into exploring graphs using functional programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用函数式编程探索图形的整体视角</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/a-holistic-perspective-into-exploring-graphs-using-functional-programming-b021651e811b?source=collection_archive---------20-----------------------#2020-07-10">https://blog.devgenius.io/a-holistic-perspective-into-exploring-graphs-using-functional-programming-b021651e811b?source=collection_archive---------20-----------------------#2020-07-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="cafd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们开始之前，让我问你一个问题——当你遇到一个复杂的问题时，从基本的构建模块开始，然后逐步构建解决方案，这难道不是一种诱惑吗？嗯，可以说我不会怪你。</p><p id="2505" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于花了大量时间学习和使用命令式编程语言编程的人来说，这似乎是一种“自然”的策略。不幸的是，根据问题的复杂性，这可能不是最佳策略。如果你已经感到失落，想着我在唠叨些什么，请至少容忍我一会儿。让我们深入图表的世界，这是阐明我的观点的最佳选择。</p><p id="a38c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">图形无处不在。你很少会发现一个领域没有他们的存在。图由一组节点(顶点)和这些节点之间的边(G=(V，E))表示。这些边可以是有向的，也可以是无向的。我在下面展示了一个有向图的例子，我将用它来演示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cb8f0c7db6d488448fa072eb75c7c2cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6qEo2LBogD2XFjpNugK0Wg@2x.jpeg"/></div></div></figure><p id="ad4b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将使用一个名为<strong class="jm io"> edge </strong>的查询函数，它将告诉我们两个节点是否连接。</p><p id="acd0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">edge::Char-&gt; Char-&gt; Bool<br/>edge ' A ' ' B ' = True<br/>edge ' B ' ' C ' = True<br/>edge ' C ' ' A ' = True<br/>edge ' A ' ' D ' = True<br/>edge ' D ' ' E ' = True<br/>edge ' D ' ' F ' = True<br/>edge ' F ' ' E ' = True<br/>edge ' E ' ' B ' = True<br/>edge _ _ = False</p><p id="f8bc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">给定一个有向图，如果有一条路连接两个顶点，人们可以很容易地判断它们是否连接。现在，等一下。你一定在想“路径”是什么意思。</p><p id="e530" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">嗯，路径就是它的意思。两个顶点之间的路径是一系列相连的边，链中的每条边都通过边与其相邻边相连。例如，A 和 C 之间的路径是<em class="ku"> [(A，B)，(B，C)] </em>。请注意，连接两个顶点的路径可能不止一条。路径的长度是端点之间的中间边数或<em class="ku">中间顶点数+ 1。</em></p><p id="bc5d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">归纳起来，如果存在某个中间顶点 y，则称任意两个顶点 x 和 z 是连接的，使得在 x 和 y 之间存在长度为 k 的路径，并且存在连接 y 和 z 的直接边。这意味着存在连接 x 和 z 的长度为<em class="ku"> (k+1) </em>的路径</p><p id="1f8b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 Haskell 中，我们可以通过类型<strong class="jm io"> <em class="ku">路径</em> </strong>来定义这种抽象</p><p id="a39e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ku">类型路径= [Char] </em></p><p id="a055" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了发现路径，我们将使用函数<em class="ku"> extendPath。</em></p><p id="f71a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ku">extend Path::Path→[Path]<br/>extend Path[]=[[c]| c←[' A '..f ']]<br/>extend path p =[p++[c]| c←[' A '..F']，edge (last p) c] </em></p><p id="a757" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该函数将通过添加从终端顶点到另一个顶点的边(如果有边连接它们)来扩展长度为 k 到(k+1)的路径。</p><p id="111f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了将长度为 k 的所有路径扩展 1，我们可以定义一个名为<em class="ku"> extendAllPath — </em>的函数</p><p id="6d4b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ku">extendAllPath::[Path]→[Path]<br/>extendAllPath[]=[[c]| c←[' A '..f ']]<br/>extendAllPath l =</em><strong class="jm io"><em class="ku">concat map</em></strong><em class="ku"/><strong class="jm io"><em class="ku">extend path</em></strong><em class="ku">l</em></p><p id="2c22" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ku"> concatMap </em>函数将 map ( <em class="ku"> map :: (a → b) → a → b)) </em>和 concat ([c | p ← l，c ← p])组合在一起。</p><p id="45f6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，发现所有可能长度的所有路径怎么样？在像 Haskell 这样的函数式语言中，我们可以通过重复映射<strong class="jm io"> extendAllPath </strong>到一个空的列表列表来实现它。</p><p id="85af" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ku">迭代::(a → a) → a → a <br/>迭代 f x = &gt; [x，f x，f (f x)，f(f x))……]</em></p><p id="17ff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">all paths = iterate extendAllPath[[]]</strong></p><p id="9775" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">忽略长度为 0 和 1 的退化路径，我们可以利用 Haskell 提供的惰性评估，它可以有效地计算所有路径(包括带有循环的路径)。</p><p id="cf4c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">丢弃 2(取(n+1)条路径)</strong></p><p id="0fda" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">显而易见，我们可以清楚明确地定义图上的不同操作，而不用担心管理状态变量和与管理它们相关的额外工作。</p><p id="de1c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">总之，我认为真正的区别是当你开始用 Haskell 编写时，你会接触到一个全新的范例。我从 Python 开始，然后学习 C++。我对使用 Python 中的 list comprehensions、lambdas、map、reduce、filter 和 C++ STL 提供的一些功能性的东西感到非常兴奋。然而，Haskell 是完全不同的野兽。它彻底改变了你的想法。相比之下显得那么优雅。我注意到的主要区别是不可变的“变量”和它的数学感觉。我希望在任何编程语言之间都能找到其他更类似于语法差异的差异。<br/>是“更好”吗？我保留对此的判断，但我相信你会发现哈斯克尔在某些情况下有优势，如果不是很多的话。</p></div></div>    
</body>
</html>