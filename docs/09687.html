<html>
<head>
<title>SwiftUI Text Alignment</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI 文本对齐</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/swiftui-text-alignment-8bc9e4cb8afe?source=collection_archive---------9-----------------------#2022-09-05">https://blog.devgenius.io/swiftui-text-alignment-8bc9e4cb8afe?source=collection_archive---------9-----------------------#2022-09-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="d2cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">这里没有 CSS 对齐，没有 flexboxes！在本文中，我们将简单介绍如何在 SwiftUI 视图中对齐文本。</em></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/5553d5599939bc1f78750984d869ce44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*afIsj9ahuG3cxt0i"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@edznorton?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Edz Norton </a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h2 id="8e85" class="la lb in bd lc ld le dn lf lg lh dp li jv lj lk ll jz lm ln lo kd lp lq lr ls bi translated">让我们看看默认对齐方式…</h2><p id="d9ab" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">创建新视图时，默认的<code class="fe ly lz ma mb b">Text</code>视图占据尽可能少的空间，并保持在框架的中心。看一下下面的多行文本视图，它显示了文本如何只占用所需的空间。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mc"><img src="../Images/6e956f90d6956315468baf7b99ac36fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dsNTjA3JWGaTi3LrWZ8qZQ.png"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">文本视图只占用框架内所需的空间。</figcaption></figure></div><div class="ab cl md me hr mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ig ih ii ij ik"><h2 id="be41" class="la lb in bd lc ld le dn lf lg lh dp li jv lj lk ll jz lm ln lo kd lp lq lr ls bi translated">我们要继续讨论下一个校准方法吗？</h2><p id="4c39" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">如果你的目标是让你的文本与框架的起始或前沿对齐，那就不要玩文字游戏了。有几种不同的方法可以做到这一点，我个人倾向于将所有内容放入某种类型的堆栈中，无论是 VStack 还是 HStack，并使用它来相应地对齐我的内容。但是，我将向您展示这两种方法。<br/> <br/>当进行水平对齐并希望所有内容对齐时，如果使用的是 HStack 或 VStack，只需使用 VStack(alignment:。leading)或 HStack(alignment:。尾随)。这两个函数将在堆栈的开始或结束处水平对齐各自堆栈类型中的所有内容。</p><p id="790d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">或者，如果您只需要对齐单个文本对象或需要指定单个文本对象对齐方式，则可以通过应用。frame()修饰符并指定对齐方式。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mc"><img src="../Images/e39941291345a2af7764a536704afec4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kyaYP0U6rKPdkPANJJyZ7g.png"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">水平对齐的两个选项。</figcaption></figure></div><div class="ab cl md me hr mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ig ih ii ij ik"><h2 id="d53d" class="la lb in bd lc ld le dn lf lg lh dp li jv lj lk ll jz lm ln lo kd lp lq lr ls bi translated">你喜欢纸杯蛋糕的顶部还是底部？</h2><p id="43e3" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">我倾向于发现垂直对齐是棘手的，但这只是我的，因为它真的很简单。要将事物与垂直轴的顶部对齐，这与水平轴非常相似。然而，它并不像您所想的那样在堆栈中工作，我将在以后写一篇关于这方面的文章！</p><p id="c527" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">也就是说，您将使用<code class="fe ly lz ma mb b">.frame()</code>修改器并设置对齐，如下所示。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mc"><img src="../Images/c1fb2e32209a7d1921229a337317a988.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i5pO6edJpWQgyZQXDQY2tw.png"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">垂直对齐选项。</figcaption></figure></div><div class="ab cl md me hr mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ig ih ii ij ik"><h2 id="b682" class="la lb in bd lc ld le dn lf lg lh dp li jv lj lk ll jz lm ln lo kd lp lq lr ls bi translated">多方向的文本对齐是可能的！</h2><p id="f34f" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">虽然我们可以沿着一个轴的基础对齐，但我们也可以选择使用多方向对齐。这将允许我们通过使用以下方法之一沿两个轴对齐。</p><pre class="kk kl km kn gt mk mb ml mm aw mn bi"><span id="422e" class="la lb in mb b gy mo mp l mq mr">.topLeading<br/>.topTrailing<br/>.top<br/>.leading<br/>.center<br/>.trailing<br/>.bottomLeading<br/>.bottomTrailing</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mc"><img src="../Images/6d731d8f3d08c31d57739d3057e95eb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zc4rNfr2Klnnahgb1DskGw.png"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">使用多方向对齐允许我们沿两个轴对齐。</figcaption></figure></div><div class="ab cl md me hr mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ig ih ii ij ik"><h2 id="3da1" class="la lb in bd lc ld le dn lf lg lh dp li jv lj lk ll jz lm ln lo kd lp lq lr ls bi translated">多行文字对齐，当你需要具体的。</h2><p id="270b" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">如果你正在处理一个需要你特别对齐多行文本对象的设计，SwiftUI 使用<code class="fe ly lz ma mb b">.multilineTextAlignment()</code>让它变得非常简单，它允许我们传入上面显示的一个修饰符。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mc"><img src="../Images/c5acd74301bece4023484665cee179ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M5XZNhJzVKCOY-PgejPv3g.png"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">使用简单的修饰符可以实现多行文本对齐。</figcaption></figure></div><div class="ab cl md me hr mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ig ih ii ij ik"><p id="c557" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">总之，SwiftUI 通过使用修饰符使文本沿不同的轴对齐变得简单。我们也可以使用单个修饰符来对齐多行文本对象。</em></p><pre class="kk kl km kn gt mk mb ml mm aw mn bi"><span id="ed3e" class="la lb in mb b gy mo mp l mq mr"><strong class="mb io">Let's Connect!</strong></span><span id="e37e" class="la lb in mb b gy ms mp l mq mr">If you have any questions, or want to chat - reach out to me on Twitter <a class="ae kz" href="https://twitter.com/halluxdev" rel="noopener ugc nofollow" target="_blank">@halluxdev</a>!</span></pre></div></div>    
</body>
</html>