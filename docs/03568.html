<html>
<head>
<title>iOS Core Data with Sugar Syntax</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有 Sugar 语法的 iOS 核心数据</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/ios-core-data-with-sugar-syntax-ef53a0e06efe?source=collection_archive---------1-----------------------#2020-11-19">https://blog.devgenius.io/ios-core-data-with-sugar-syntax-ef53a0e06efe?source=collection_archive---------1-----------------------#2020-11-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/88f77ed7f3db28e3bef97ae41db1020a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Let7RsfLQHYbv64o"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">由<a class="ae jz" href="https://unsplash.com/@jankolar?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">扬·安东宁·科拉尔</a>在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="c984" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我几年前开始 iOS 编程时，我混淆了核心数据和数据库，但事实上核心数据不是数据库，即使核心数据实际上由 SQLite 数据库支持，但它们都是提供可搜索和持久存储的方式。简而言之，我们可以说 SQLite 本身就是一个数据库，核心数据是一个 ORM(对象关系模型),它在数据库和 UI 之间创建了一个层。</p><h1 id="4c9b" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">什么是核心数据？</h1><p id="52b1" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">核心数据是一个框架，用于管理应用程序中的模型层对象。它为与对象生命周期和对象图管理(包括持久性)相关的常见任务提供了通用和自动化的解决方案。它通常会减少您编写的代码量的百分之<strong class="kc io"> 50 </strong>到百分之<strong class="kc io"> 70 </strong>来支持模型层，为了更好地理解核心数据及其工作原理，我们需要理解<em class="mb">核心数据堆栈</em>。</p><h1 id="5b8a" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">什么是核心数据堆栈？</h1><p id="ef6a" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated"><em class="mb">核心数据堆栈</em>是框架对象的集合，这些对象作为核心数据初始化的一部分被访问，并在应用程序和外部数据存储中的对象之间传递。核心数据堆栈处理与外部数据存储的所有交互，以便您的应用程序可以专注于其业务逻辑。堆栈由四个主要的<strong class="kc io"><em class="mb"/></strong>对象组成:</p><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mc"><img src="../Images/935f8f82ebe1c85ee72494ca8f2807e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mJfF39Zz2IHl4BlZz9nPgQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><a class="ae jz" href="https://docs-assets.developer.apple.com/published/af070d78c7/73827830-1e19-4865-8757-c4d9f8ccacfb.png" rel="noopener ugc nofollow" target="_blank">https://docs-assets . developer . apple . com/published/af 070 d78c 7/73827830-1e 19-4865-8757-C4 d9 F8 CCA CFB . png</a></figcaption></figure><ul class=""><li id="afd5" class="mh mi in kc b kd ke kh ki kl mj kp mk kt ml kx mm mn mo mp bi translated"><code class="fe mq mr ms mt b"><a class="ae jz" href="https://developer.apple.com/documentation/coredata/nspersistentcontainer" rel="noopener ugc nofollow" target="_blank"><em class="mb">NSPersistentContainer</em></a></code>处理核心数据栈的创建，并提供对<code class="fe mq mr ms mt b">NSManagedObjectContext</code>以及许多便利方法的访问。</li><li id="68bf" class="mh mi in kc b kd mu kh mv kl mw kp mx kt my kx mm mn mo mp bi translated"><code class="fe mq mr ms mt b"><a class="ae jz" href="https://developer.apple.com/documentation/coredata/nsmanagedobjectmodel" rel="noopener ugc nofollow" target="_blank"><em class="mb">NSManagedObjectModel</em></a></code>描述核心数据堆栈将要访问的数据。在创建核心数据堆栈的过程中，堆栈创建的第一步是将<code class="fe mq mr ms mt b">NSManagedObjectModel</code>加载到内存中。在初始化<code class="fe mq mr ms mt b">NSManagedObjectModel</code>对象之后，构造<code class="fe mq mr ms mt b">NSPersistentStoreCoordinator</code>对象。</li><li id="d8ab" class="mh mi in kc b kd mu kh mv kl mw kp mx kt my kx mm mn mo mp bi translated"><code class="fe mq mr ms mt b"><a class="ae jz" href="https://developer.apple.com/documentation/coredata/nsmanagedobjectcontext" rel="noopener ugc nofollow" target="_blank"><em class="mb">NSManagedObjectContext</em></a></code>是你的应用程序交互最多的对象。可以把它想象成一个智能便笺本。当您从持久性存储中获取对象时，您将临时副本带到暂存区，在那里它们形成一个对象图。然后，您可以随意修改这些对象，如果您选择保存所做的更改，上下文将确保您的对象处于有效状态。如果是，更改将被写入持久性存储，为您创建的对象添加新记录，并为您删除的对象删除记录。</li><li id="ee91" class="mh mi in kc b kd mu kh mv kl mw kp mx kt my kx mm mn mo mp bi translated"><code class="fe mq mr ms mt b"><a class="ae jz" href="https://developer.apple.com/documentation/coredata/nspersistentstorecoordinator" rel="noopener ugc nofollow" target="_blank"><em class="mb">NSPersistentStoreCoordinator</em></a></code>位于核心数据堆栈的中间。它负责实现模型内部定义的实体的实例。它创建模型中实体的新实例，并从持久存储(<code class="fe mq mr ms mt b"><a class="ae jz" href="https://developer.apple.com/documentation/coredata/nspersistentstore" rel="noopener ugc nofollow" target="_blank">NSPersistentStore</a></code>)中检索现有实例，持久存储可以在磁盘上或内存中，这取决于应用程序的结构。</li></ul></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h1 id="c8a5" class="ky kz in bd la lb ng ld le lf nh lh li lj ni ll lm ln nj lp lq lr nk lt lu lv bi translated">1-初始化核心数据堆栈</h1><ul class=""><li id="853b" class="mh mi in kc b kd lw kh lx kl nl kp nm kt nn kx mm mn mo mp bi translated">堆栈的初始化为数据请求和数据创建准备核心数据。</li><li id="b051" class="mh mi in kc b kd mu kh mv kl mw kp mx kt my kx mm mn mo mp bi translated">从<em class="mb"> iOS 10 </em>开始，<code class="fe mq mr ms mt b">NSPersistentContainer</code>处理核心数据堆栈的创建，但在 iOS 10 之前，核心数据堆栈的创建更加复杂，并且<a class="ae jz" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreData/InitializingtheCoreDataStack.html#//apple_ref/doc/uid/TP40001075-CH4-SW1" rel="noopener ugc nofollow" target="_blank"> <em class="mb">您可以阅读更多</em> </a>。</li><li id="32da" class="mh mi in kc b kd mu kh mv kl mw kp mx kt my kx mm mn mo mp bi translated">下面是如何创建核心数据堆栈示例:</li></ul><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="no np l"/></div></figure><h1 id="c8d1" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">2-创建托管对象模型</h1><ul class=""><li id="6d1c" class="mh mi in kc b kd lw kh lx kl nl kp nm kt nn kx mm mn mo mp bi translated">大部分核心数据的功能依赖于您创建的<strong class="kc io"> <em class="mb">模式</em> </strong>来描述您的应用程序的实体、它们的属性以及它们之间的关系。核心数据使用一种称为<em class="mb">托管对象模型</em>的模式，即<code class="fe mq mr ms mt b"><a class="ae jz" href="https://developer.apple.com/documentation/coredata/nsmanagedobjectmodel" rel="noopener ugc nofollow" target="_blank">NSManagedObjectModel</a></code>的实例。</li><li id="4764" class="mh mi in kc b kd mu kh mv kl mw kp mx kt my kx mm mn mo mp bi translated">想象一下，我们有一个名为<code class="fe mq mr ms mt b">Person</code>的实体，它有<code class="fe mq mr ms mt b">first_name</code>和<code class="fe mq mr ms mt b">last_name</code>并拥有一个<code class="fe mq mr ms mt b">car</code>，那么<code class="fe mq mr ms mt b">Car</code>将是另一个具有<code class="fe mq mr ms mt b">name</code>和<code class="fe mq mr ms mt b">owner</code>属性的实体。</li><li id="a787" class="mh mi in kc b kd mu kh mv kl mw kp mx kt my kx mm mn mo mp bi translated"><em class="mb">所有者</em>可能有不止一辆<em class="mb">汽车</em>，那么我们将在所有者和汽车之间创建<em class="mb">一对多</em>关系。</li></ul><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nq"><img src="../Images/a82195204a512b6a0654ae6b90f37f90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E9K3mxz_flSeucDl83fqUw.png"/></div></div></figure><p id="1355" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">1-点击添加实体按钮，创建<strong class="kc io">人</strong>和<strong class="kc io">车</strong>实体。<br/> 2-为 Person 实体创建<strong class="kc io">名字</strong>和<strong class="kc io">姓氏</strong>属性。<br/> 3-建立车主与汽车之间的关系。<br/> 4-使关系<strong class="kc io">一对多</strong>。<br/> 5-对<strong class="kc io">车</strong>实体做同样的操作。</p><h1 id="265f" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">3-创建受管对象</h1><ul class=""><li id="f040" class="mh mi in kc b kd lw kh lx kl nl kp nm kt nn kx mm mn mo mp bi translated">定义了托管对象模型并初始化了应用程序中的核心数据堆栈后，就可以开始创建数据存储对象了。</li><li id="4bcb" class="mh mi in kc b kd mu kh mv kl mw kp mx kt my kx mm mn mo mp bi translated">我创建了一些 sugar 语法来创建实体并保存它们，您可以在文章末尾查看完整的源代码。</li></ul><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="no np l"/></div></figure><h1 id="a359" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">4-保存受管对象</h1><ul class=""><li id="2b35" class="mh mi in kc b kd lw kh lx kl nl kp nm kt nn kx mm mn mo mp bi translated">在创建了实体及其属性之后，我们所需要的就是调用<code class="fe mq mr ms mt b">save</code>或<code class="fe mq mr ms mt b">saveSync</code>来显式地保存该上下文，以便将这些更改持久化到您的持久存储中。</li></ul><h1 id="e6fc" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">5-获取对象</h1><ul class=""><li id="92f4" class="mh mi in kc b kd lw kh lx kl nl kp nm kt nn kx mm mn mo mp bi translated">既然数据存储在核心数据持久存储中，您将使用一个<code class="fe mq mr ms mt b"><a class="ae jz" href="https://developer.apple.com/documentation/coredata/nsfetchrequest" rel="noopener ugc nofollow" target="_blank">NSFetchRequest</a></code>来访问现有的数据。</li><li id="3819" class="mh mi in kc b kd mu kh mv kl mw kp mx kt my kx mm mn mo mp bi translated">首先构建一个描述想要返回的数据的<code class="fe mq mr ms mt b">NSFetchRequest</code>。</li><li id="d72e" class="mh mi in kc b kd mu kh mv kl mw kp mx kt my kx mm mn mo mp bi translated">然后在<code class="fe mq mr ms mt b"><a class="ae jz" href="https://developer.apple.com/documentation/coredata/nsmanagedobjectcontext" rel="noopener ugc nofollow" target="_blank">NSManagedObjectContext</a></code>上调用<code class="fe mq mr ms mt b"><a class="ae jz" href="https://developer.apple.com/documentation/coredata/nsmanagedobjectcontext/1506672-fetch" rel="noopener ugc nofollow" target="_blank">fetch(:</a>)</code>并传递请求。</li><li id="276c" class="mh mi in kc b kd mu kh mv kl mw kp mx kt my kx mm mn mo mp bi translated">我已经添加了一些糖语法，使我们的生活变得简单，只需要调用<code class="fe mq mr ms mt b">fetch</code>。</li></ul><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="no np l"/></div></figure><h1 id="ed65" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">6-从 CoreData 中删除实体</h1><ul class=""><li id="9062" class="mh mi in kc b kd lw kh lx kl nl kp nm kt nn kx mm mn mo mp bi translated">实际上，从核心数据中删除任何实体都非常简单。它只需要传递<code class="fe mq mr ms mt b">NSFetchRequest</code>实例，然后我们在您的托管对象上下文上执行批量删除请求。</li></ul><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="no np l"/></div></figure><h1 id="da5b" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">7-在后台使用核心数据</h1><ul class=""><li id="e44d" class="mh mi in kc b kd lw kh lx kl nl kp nm kt nn kx mm mn mo mp bi translated">核心数据被设计为在多线程环境中工作。</li><li id="cdc2" class="mh mi in kc b kd mu kh mv kl mw kp mx kt my kx mm mn mo mp bi translated">托管对象上下文在初始化时被绑定到与它们相关联的线程。</li><li id="b85b" class="mh mi in kc b kd mu kh mv kl mw kp mx kt my kx mm mn mo mp bi translated">从上下文中检索的托管对象被绑定到上下文所绑定到的同一队列。</li><li id="4188" class="mh mi in kc b kd mu kh mv kl mw kp mx kt my kx mm mn mo mp bi translated">管理对象上下文有两种类型:<strong class="kc io">主队列</strong>和<strong class="kc io">私有队列</strong>。</li><li id="b117" class="mh mi in kc b kd mu kh mv kl mw kp mx kt my kx mm mn mo mp bi translated">下面是一个我们如何使用私有队列来支持并发性的例子</li></ul><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="no np l"/></div></figure><ul class=""><li id="42a0" class="mh mi in kc b kd ke kh ki kl mj kp mk kt ml kx mm mn mo mp bi translated">我们创建了一个新的<code class="fe mq mr ms mt b">NSManagedObjectContext</code>,它被定义为私有队列，新的上下文被设置为运行应用程序的主队列上下文的子上下文，然后调用<code class="fe mq mr ms mt b">performBlock:</code>来执行实际的工作，在所有的数据都被使用之后，您可以调用私有上下文上的 save，它将所有的更改移动到主队列上下文中，而不会阻塞主队列。</li></ul><h1 id="393f" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">8-性能提示</h1><ul class=""><li id="bca6" class="mh mi in kc b kd lw kh lx kl nl kp nm kt nn kx mm mn mo mp bi translated">对持久性存储的每次往返都会产生开销，包括访问存储和将返回的对象合并到持久性堆栈中。如果可以将多个请求合并成一个返回所有所需对象的请求，请避免执行多个请求。</li><li id="f543" class="mh mi in kc b kd mu kh mv kl mw kp mx kt my kx mm mn mo mp bi translated">如果获取请求需要一个复合谓词，您可以通过确保最具限制性的谓词是第一个来提高获取效率，尤其是在谓词涉及文本匹配(<code class="fe mq mr ms mt b">contains</code>、<code class="fe mq mr ms mt b">endsWith</code>、<code class="fe mq mr ms mt b">like</code>和<code class="fe mq mr ms mt b">matches</code>)的情况下。</li><li id="c914" class="mh mi in kc b kd mu kh mv kl mw kp mx kt my kx mm mn mo mp bi translated">您可以设置一个获取将返回的对象数量的限制，以最小化内存中托管对象的工作集，从而提高应用程序的性能。</li><li id="cdea" class="mh mi in kc b kd mu kh mv kl mw kp mx kt my kx mm mn mo mp bi translated">使用预取，预取背后的想法是对未来需求的预期。当您获取一些对象时，有时您知道不久之后您还将需要相关的对象，这些对象可能由故障表示。</li><li id="bcbf" class="mh mi in kc b kd mu kh mv kl mw kp mx kt my kx mm mn mo mp bi translated">避免将核心数据用作大块二进制数据(如视频、图像或音频)的存储。</li><li id="c2cf" class="mh mi in kc b kd mu kh mv kl mw kp mx kt my kx mm mn mo mp bi translated">通过使用后台线程和切换到主队列来更新用户界面，避免阻塞应用程序的主线程。</li></ul></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><h2 id="31af" class="nr kz in bd la ns nt dn le nu nv dp li kl nw nx lm kp ny nz lq kt oa ob lu oc bi translated"><strong class="ak">这里是所有完整的糖语法</strong></h2><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="b5ef" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">希望你和我一样喜欢😃🎉如果是这样，请随意鼓掌，如果你喜欢更多，请随意鼓掌😃与朋友分享，与人分享总是令人愉快的，如果您也想查看，这里有所有源代码:</p><div class="od oe gp gr of og"><a href="https://github.com/deda9/CoreDataExample" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd io gy z fp ol fr fs om fu fw im bi translated">deda 9/coredata 示例</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">核心数据示例。在 GitHub 上创建一个帐户，为 deda9/CoreDataExample 开发做贡献。</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">github.com</p></div></div><div class="op l"><div class="oq l or os ot op ou jt og"/></div></div></a></div></div></div>    
</body>
</html>