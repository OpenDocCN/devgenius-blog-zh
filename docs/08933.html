<html>
<head>
<title>Docker Storage Solutions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker 储物解决方案</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/docker-storage-solutions-8fe71d7607f8?source=collection_archive---------7-----------------------#2022-07-19">https://blog.devgenius.io/docker-storage-solutions-8fe71d7607f8?source=collection_archive---------7-----------------------#2022-07-19</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><figure class="gm go jp jq jr js gi gj paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gi gj jo"><img src="../Images/92439345993dd055464e8692d89441f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bxcG3ejG1F9b-cXMHzIiXQ.png"/></div></div></figure><h1 id="9ef2" class="jz ka ir bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">介绍</h1><p id="e988" class="pw-post-body-paragraph kx ky ir kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ik bi translated">使用 Docker 时，有几种不同的方法来管理数据。该项目将涵盖两个基本选项。</p><p id="77c2" class="pw-post-body-paragraph kx ky ir kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ik bi translated">第一种方法是直接将本地目录挂载到容器。虽然这对于快速方便地访问容器中的数据非常有用，但是它的可移植性不是很好，这也是 Docker 容器背后的主要原因。第二种方法更加便携，可以被多个容器使用。但是，它没有为容器上的数据创建一个“直接”访问点。</p><p id="4e6e" class="pw-post-body-paragraph kx ky ir kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ik bi translated">我们将讨论这两种方法，我希望能展示每种方法的优缺点。</p><h1 id="d5f3" class="jz ka ir bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">设置</h1><p id="2173" class="pw-post-body-paragraph kx ky ir kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ik bi translated">现在，在我们开始之前，我们需要一些东西:</p><ul class=""><li id="9088" class="ma mb ir kz b la lv le lw li mc lm md lq me lu mf mg mh mi bi translated">EC2 实例或安装了 Docker 的其他工作空间</li><li id="217c" class="ma mb ir kz b la mj le mk li ml lm mm lq mn lu mf mg mh mi bi translated">终端访问</li><li id="29d2" class="ma mb ir kz b la mj le mk li ml lm mm lq mn lu mf mg mh mi bi translated">两杯面粉，3 汤匙…哦，对不起，食谱错了！</li></ul></div><div class="ab cl mo mp hv mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ik il im in io"><h1 id="4677" class="jz ka ir bd kb kc mv ke kf kg mw ki kj kk mx km kn ko my kq kr ks mz ku kv kw bi translated">让我们从挂载点开始！</h1><h2 id="0afa" class="na ka ir bd kb nb nc dn kf nd ne dp kj li nf ng kn lm nh ni kr lq nj nk kv nl bi translated">验证 Docker 安装</h2><p id="6077" class="pw-post-body-paragraph kx ky ir kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ik bi translated">首先，我们应该验证 Docker 已经安装并正在运行。这就像输入<code class="fe nm nn no np b">docker info</code>一样简单。</p><figure class="nr ns nt nu gu js gi gj paragraph-image"><div class="gi gj nq"><img src="../Images/fe1e2d466cbf50f4867b02d901777a65.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*7pXxsUPjiVwsK8ctwLnq5A.png"/></div></figure><p id="2bdb" class="pw-post-body-paragraph kx ky ir kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ik bi translated">如您所见，我准备好了，并准备进入下一步:</p><p id="31f2" class="pw-post-body-paragraph kx ky ir kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ik bi translated">为了进行测试，我们将创建一个新目录，并将几个文件放入其中</p><figure class="nr ns nt nu gu js gi gj paragraph-image"><div class="gi gj nv"><img src="../Images/e94a6a2887364c06cf69d855c0b9672c.png" data-original-src="https://miro.medium.com/v2/resize:fit:338/format:webp/1*_8YwgeLDBe0n8SwmHZkEMA.png"/></div></figure><p id="88d0" class="pw-post-body-paragraph kx ky ir kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ik bi translated">又快又简单！这只是我们验证我们已经正确安装了目录的一种方式。</p><h2 id="cf14" class="na ka ir bd kb nb nc dn kf nd ne dp kj li nf ng kn lm nh ni kr lq nj nk kv nl bi translated">启动几个容器…</h2><p id="800b" class="pw-post-body-paragraph kx ky ir kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ik bi translated">现在，我们将使用以下命令运行 Docker 容器:</p><p id="6686" class="pw-post-body-paragraph kx ky ir kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ik bi translated"><code class="fe nm nn no np b">docker run -itd --name unsc_pillarofautumn --network=slipspace -v $PWD/webfiles:/webfiles centos</code></p><p id="a7a1" class="pw-post-body-paragraph kx ky ir kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ik bi translated">让我们来分解一下:</p><ul class=""><li id="8aea" class="ma mb ir kz b la lv le lw li mc lm md lq me lu mf mg mh mi bi translated"><code class="fe nm nn no np b">docker run</code>这是我们基地启动集装箱的命令。</li><li id="a1de" class="ma mb ir kz b la mj le mk li ml lm mm lq mn lu mf mg mh mi bi translated"><code class="fe nm nn no np b">-itd</code>-I、-t 和-d 标志的组合，意味着我们希望将容器从主机上分离，并开始一个交互式会话。</li><li id="aeb3" class="ma mb ir kz b la mj le mk li ml lm mm lq mn lu mf mg mh mi bi translated"><code class="fe nm nn no np b">--name</code>这不是必须的，但有助于使事情变得简单。</li><li id="396b" class="ma mb ir kz b la mj le mk li ml lm mm lq mn lu mf mg mh mi bi translated"><code class="fe nm nn no np b">--network</code>这实际上创建/引用了一个新的网络，容器将在该网络上进行通信。</li><li id="749c" class="ma mb ir kz b la mj le mk li ml lm mm lq mn lu mf mg mh mi bi translated"><code class="fe nm nn no np b">-v</code>“音量”标志。(<em class="nw">即使它是一个“卷”，通过传递一个本地目录，而不是一个名称，这也被称为一个挂载点。)</em>我们将此标志<em class="nw"> </em>与以下选项一起使用:</li><li id="8539" class="ma mb ir kz b la mj le mk li ml lm mm lq mn lu mf mg mh mi bi translated">这是我们的本地主机目录。</li><li id="5613" class="ma mb ir kz b la mj le mk li ml lm mm lq mn lu mf mg mh mi bi translated"><code class="fe nm nn no np b">/webfiles</code>这是它在容器中的安装位置。如果不存在，就会被创建。</li><li id="9e87" class="ma mb ir kz b la mj le mk li ml lm mm lq mn lu mf mg mh mi bi translated"><code class="fe nm nn no np b">centos</code>这只是<code class="fe nm nn no np b">docker run</code>将用来构建容器的图像。</li></ul><figure class="nr ns nt nu gu js gi gj paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gi gj nx"><img src="../Images/ddf3755d2cf6a6e76ed7ab1a7de8c396.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vfV4Z0Lr7sSZMGgeCrow6g.png"/></div></div></figure><p id="660d" class="pw-post-body-paragraph kx ky ir kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ik bi translated">然后，我们将运行另一个具有相同选项的容器，只是名称不同。网络是由第一个命令创建的，但是当用于运行第二个容器时，它充当对已经建立的网络的引用。</p><h2 id="8ef3" class="na ka ir bd kb nb nc dn kf nd ne dp kj li nf ng kn lm nh ni kr lq nj nk kv nl bi translated">验证两个容器都可以访问数据</h2><p id="bc73" class="pw-post-body-paragraph kx ky ir kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ik bi translated">对于这一步，我们将使用<code class="fe nm nn no np b">docker exec</code>跳转到容器内部，查看我们已经挂载的文件。</p><figure class="nr ns nt nu gu js gi gj paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gi gj ny"><img src="../Images/025d37c0192753e541cfa9e2e7e45235.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-n6Ff5BINI5rtbemWtBJNQ.png"/></div></div><figcaption class="nz oa gk gi gj ob oc bd b be z dk translated">正如我们所看到的，两个容器都可以看到本地目录中的文件。</figcaption></figure><p id="7d53" class="pw-post-body-paragraph kx ky ir kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ik bi translated">成功！所以用这个方法，本地目录和容器里面的目录是链接的。任一端的任何变化都会传播到另一端。超级方便，但是不太便携。如果在任何其他环境中执行这个<code class="fe nm nn no np b">run</code>命令，它将会失败，因为目录不太可能是相同的。现在我们已经看到了如何使用挂载点，让我们实际创建一个命名卷，并展示如何使用它！</p><h1 id="da81" class="jz ka ir bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">码头命名卷</h1><p id="beab" class="pw-post-body-paragraph kx ky ir kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ik bi translated">对于这一部分，我们将创建一个命名卷。Docker 将命名卷视为外部硬盘驱动器，但是多个容器可以使用和访问该卷。</p><h2 id="5fc2" class="na ka ir bd kb nb nc dn kf nd ne dp kj li nf ng kn lm nh ni kr lq nj nk kv nl bi translated">创建卷</h2><p id="05b1" class="pw-post-body-paragraph kx ky ir kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ik bi translated">这很简单。可以使用该命令的可选标志和选项来创建非常特定类型的卷，但现在我们只运行普通卷:</p><p id="ba00" class="pw-post-body-paragraph kx ky ir kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ik bi translated"><code class="fe nm nn no np b">docker volume create webvolume</code>这里的“webvolume”只是我们为它选择的名称。</p><h2 id="834e" class="na ka ir bd kb nb nc dn kf nd ne dp kj li nf ng kn lm nh ni kr lq nj nk kv nl bi translated">加载一些数据</h2><p id="031a" class="pw-post-body-paragraph kx ky ir kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ik bi translated">现在，我们的卷是空的，所以让我们修复它！我们将继续旋转另一个容器，这一次显示您可以装载多个卷和装载点:</p><figure class="nr ns nt nu gu js gi gj paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gi gj od"><img src="../Images/af5d15a8ae172763622b51146ea6a3ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1VhsCmt6gP3ESDoWCSmrNg.png"/></div></div></figure><figure class="nr ns nt nu gu js gi gj paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gi gj oe"><img src="../Images/95ba402602aa452cc51dec694961a875.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GBKsOQEtVUyI9Z2SB5IrcA.png"/></div></div><figcaption class="nz oa gk gi gj ob oc bd b be z dk translated">跳到容器中，我们可以看到两个卷都已装载。一种是单独的卷，另一种是直接挂载到本地目录。</figcaption></figure><p id="b9d7" class="pw-post-body-paragraph kx ky ir kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ik bi translated">进入容器后，让我们将数据从本地驱动器(webexport)复制到卷(webvolume)中。</p><figure class="nr ns nt nu gu js gi gj paragraph-image"><div class="gi gj of"><img src="../Images/899a15e21f0670273fa2d37096a3b879.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*LgXjUsX6lovKH9p76HsA3Q.png"/></div></figure><h2 id="35fd" class="na ka ir bd kb nb nc dn kf nd ne dp kj li nf ng kn lm nh ni kr lq nj nk kv nl bi translated">用新容器验证…</h2><p id="355c" class="pw-post-body-paragraph kx ky ir kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ik bi translated">为了确认该卷是包含数据的卷，我们将把它附加到一个全新的容器:</p><p id="891b" class="pw-post-body-paragraph kx ky ir kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ik bi translated"><code class="fe nm nn no np b">docker run -itd --name unsc_forwarduntodawn --network=slipspace -v webvolume:/webvolume centos</code></p><p id="1174" class="pw-post-body-paragraph kx ky ir kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ik bi translated">登录进去，我们就有了！！</p><figure class="nr ns nt nu gu js gi gj paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gi gj og"><img src="../Images/7130cf49cdff653c23d6fcf5f79843ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*si3YuGBX34sK4eDZhIHucQ.png"/></div></div></figure><h1 id="01aa" class="jz ka ir bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">结论</h1><p id="3ab5" class="pw-post-body-paragraph kx ky ir kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ik bi translated">因此，今天我们通过两种不同的方式来使用 Docker 与数据进行交互。我希望这是有用的，并易于遵循！一如既往，我欢迎反馈，并希望下次见到你！</p></div></div>    
</body>
</html>