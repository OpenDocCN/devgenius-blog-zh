<html>
<head>
<title>A test drive of TestNG for Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java的TestNG测试驱动程序</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/a-test-drive-of-testng-for-java-5ab29cb4253a?source=collection_archive---------7-----------------------#2021-10-05">https://blog.devgenius.io/a-test-drive-of-testng-for-java-5ab29cb4253a?source=collection_archive---------7-----------------------#2021-10-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/587499bb655df71bda8b910eafb1fdd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DKBg_SdEcSQsxdkS"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@janbaborak?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">扬·巴布拉克</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="f496" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TestNG是最受推崇的Java单元测试框架之一。即使是所谓的“批评性评论”也会被视为好评。</p><p id="f974" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，除了知道TestNG是可用的之外，许多Java程序员并不太了解TestNG。也许那是你，那是最近的我。我看到TestNG是Apache NetBeans中的一个选项(它在NetBeans的Oracle时代也是一个选项)。</p><p id="b58a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JUnit似乎非常适合我所有的Java单元测试需求。JUnit是Java的标准单元测试框架，似乎也是其他编程语言(如C#)的单元测试框架的标准参考框架。</p><p id="7e7e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我从事Scala编程已经有几年了，但在某些方面我还是新手。也许我会到一个需要使用ScalaTest的时候。但我还没到那一步。我在所有的Scala项目中都使用JUnit(当然不是在REPL或Scastie上匆忙完成的小事情)。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/b5ed78ad89b904e49b923fbb93521f5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ExY5ztFa0oWYzstvFqFgxw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">曼德尔布罗集分形。</figcaption></figure><p id="eaa6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是今天，我想在一个Java项目上尝试TestNG。我将把我的Mandelbrot Julia Viewer程序从我的Toy Examples存储库中分出来，放入一个更集中的项目，一个分形查看程序。</p><p id="e4de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要绘制像著名的Mandelbrot集这样的分形，我们需要一个表示所谓“复数”的类。实际上，我们没有<em class="lg">来创建这样一个类。伯努瓦·曼德尔布罗自己可能没有。</em></p><p id="f37b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另外，我担心必须创建数千个<code class="fe lh li lj lk b">ComplexNumber</code>对象会导致程序非常慢。但事实证明并非如此，尽管在1975年可能是这样。</p><p id="6d2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，用对象来表示复数大大简化了放大和缩小功能。</p><h1 id="53ad" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">测试不可变的类</h1><p id="5efb" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">我用<code class="fe lh li lj lk b">ComplexNumber</code>类开始了TestNG的试驾。如果你想理解但不喜欢复数，你仍然可以理解分数、美元金额、玛雅数字，以及任何你可以应用四则运算的东西。</p><p id="d904" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于复数以及如何相加相乘的解释，<a class="ae kc" href="https://medium.com/i-math/complex-numbers-explained-fad9a6793019" rel="noopener">参见布雷特·贝里的文章</a>。</p><p id="6d80" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于这次试用，我将使用Apache NetBeans，因为我确信NetBeans附带了TestNG。我让您决定是为此创建一个新的NetBeans项目，还是在一个现有的项目中进行尝试，甚至是一个您已经在使用JUnit的项目。</p><p id="2397" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你选择跟随复数，这里有一个粗略的草稿，你可以复制粘贴:</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="861b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这可能会使我们对它进行的大多数测试失败。</p><p id="6497" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在NetBeans中，找到带有“<code class="fe lh li lj lk b">public class ComplexNumber</code>”的行，并将光标放在上面。这一行的左边应该会出现一个灯泡，像通常创建JUnit测试类一样单击它。而是选择“创建测试类[测试包中的TestNG”。</p><p id="b9ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就像JUnit一样，NetBeans将生成一个测试类，您可以也应该编辑它。您可能注意到的第一个区别是导入语句不同:<code class="fe lh li lj lk b">org.testng.annotations.Test</code>和<code class="fe lh li lj lk b">org.testng.Assert.*</code>(后者是静态导入)。</p><p id="9ed0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另请注意，TestNG 6.8.1被添加到项目概述窗格中的测试库中。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/655d3625bf95670b2bd39d285cce2031.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/1*7H1qug8V27zXiLFJ9flc9Q.png"/></div></figure><p id="dd04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">生成的测试似乎与为JUnit生成的测试完全相同。其中许多都有潜在的空指针警告和对<code class="fe lh li lj lk b">fail()</code>的默认调用。</p><p id="ee39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，请注意断言行是</p><pre class="lc ld le lf gt mr lk ms mt aw mu bi"><span id="d436" class="mv lm iq lk b gy mw mx l my mz">        assertEquals(result, expResult);</span></pre><p id="5707" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不</p><pre class="lc ld le lf gt mr lk ms mt aw mu bi"><span id="e5ce" class="mv lm iq lk b gy mw mx l my mz">        assertEquals(expResult, result);</span></pre><p id="bea9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我开始更喜欢“<code class="fe lh li lj lk b">expected</code>”而不是“<code class="fe lh li lj lk b">expResult</code>”；更喜欢“<code class="fe lh li lj lk b">actual</code>”而不是“<code class="fe lh li lj lk b">result</code>”所以我的断言行需要</p><pre class="lc ld le lf gt mr lk ms mt aw mu bi"><span id="8f33" class="mv lm iq lk b gy mw mx l my mz">        assertEquals(actual, expected);</span></pre><p id="e584" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不</p><pre class="lc ld le lf gt mr lk ms mt aw mu bi"><span id="7312" class="mv lm iq lk b gy mw mx l my mz">        assertEquals(expected, actual);</span></pre><p id="28b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就像我习惯和JUnit在一起一样。我检查了Javadoc以确保这一点。</p><p id="6fab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我将注释掉所有带有空指针警告的行，以及所有导致错误的行，直到我得到一个绿色指示器。</p><p id="56e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我重写了<code class="fe lh li lj lk b">testToString()</code>，因为<code class="fe lh li lj lk b">toString()</code>对于其他测试来说是至关重要的。测试得出一个非常接近0的伪随机复数，然后调用<code class="fe lh li lj lk b">toString()</code>。</p><p id="6f7b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，测试会失败，第一次也应该如此，因为<code class="fe lh li lj lk b">toString()</code>返回“尚未实现”，而不是类似于“0.3999688226275+0.395365866</p><p id="cda7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">继续运行测试。我从未能够在NetBeans中隔离JUnit测试，我认为TestNG测试也是如此，尽管TestNG。所以运行它们，让其他测试以“测试用例是原型”失败</p><blockquote class="na nb nc"><p id="fd89" class="kd ke lg kf b kg kh ki kj kk kl km kn nd kp kq kr ne kt ku kv nf kx ky kz la ij bi translated">应为[1.3325346606463198+1.09455474585856 I]，但找到了[NOTIMPLEMENTEDYET]</p></blockquote><p id="4c71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你知道如何通过<code class="fe lh li lj lk b">toString()</code>测试。进行更改并验证其测试通过。如果没有，检查<code class="fe lh li lj lk b">ComplexNumber</code>是否被重新编译。</p><p id="9106" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于大多数其他测试，我们需要覆盖<code class="fe lh li lj lk b">equals()</code>。这也意味着<code class="fe lh li lj lk b">hashCode()</code>。如果您愿意，可以让NetBeans为您编写这些覆盖。如果不是，放入覆盖存根(<code class="fe lh li lj lk b">equals()</code>总是假，<code class="fe lh li lj lk b">hashCode()</code>总是0)并相应地编写测试。</p><p id="e7a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当一个测试期望两个对象相等，但是断言失败时，来自TestNG的测试失败解释是有帮助的，就像您期望来自JUnit的解释一样。举个例子，</p><blockquote class="na nb nc"><p id="55f2" class="kd ke lg kf b kg kh ki kj kk kl km kn nd kp kq kr ne kt ku kv nf kx ky kz la ij bi translated">[verbosestng]Java . lang . assertion error:应为[0.5173287743137084+0.2005433523537954 I]，但找到了[0.5173287743137084+0.2005433523537954 I]</p></blockquote><p id="b426" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是当一个测试预计两个对象不相等，断言失败时，TestNG默认的失败解释就不是很有用了:</p><blockquote class="na nb nc"><p id="ec06" class="kd ke lg kf b kg kh ki kj kk kl km kn nd kp kq kr ne kt ku kv nf kx ky kz la ij bi translated">[verbosestng]Java . lang . assertion error:null</p></blockquote><p id="e96d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是针对我的不同虚部测试的，但也可能是针对在那次运行中失败的其他不等于测试的。啰嗦？不是很对<code class="fe lh li lj lk b">assertNotEquals()</code>。</p><p id="8cda" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是请记住，您总是可以添加定制的断言消息，就像在JUnit中一样，例如，</p><pre class="lc ld le lf gt mr lk ms mt aw mu bi"><span id="a7ae" class="mv lm iq lk b gy mw mx l my mz">    @Test<br/>    public void testNotEqualsDiffIm() {<br/>        double re = Math.random();<br/>        double im = Math.random();<br/>        ComplexNumber numberA = new ComplexNumber(re, im);<br/>        ComplexNumber numberB = new ComplexNumber(re, im * 2.5);<br/>        <strong class="lk ir">String msg = numberA.toString() + " shouldn't be equal to " <br/>                + numberB.toString();</strong><br/>        assertNotEquals(numberA, numberB, <strong class="lk ir">msg</strong>);<br/>    }</span></pre><p id="1f21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意断言消息在最后，不像Jupiter (5.0)之前的JUnit。我猜TestNG从1.0版本开始就这样了。</p><p id="d55e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过这种调整，不同的虚部测试应该给出更有帮助的故障解释，例如</p><blockquote class="na nb nc"><p id="c6c2" class="kd ke lg kf b kg kh ki kj kk kl km kn nd kp kq kr ne kt ku kv nf kx ky kz la ij bi translated">Java . lang . assertion error:0.9054998092512067+0.37128832 8766911 I不应等于0.9059999998 809 2512</p></blockquote><p id="9db0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦你让<code class="fe lh li lj lk b">equals()</code>正常工作，你就可以为算术运算、<code class="fe lh li lj lk b">plus()</code>、<code class="fe lh li lj lk b">minus()</code>、<code class="fe lh li lj lk b">times()</code>甚至<code class="fe lh li lj lk b">divides()</code>编写测试了。嗯，让我们稍微推迟一下<code class="fe lh li lj lk b">divides()</code>…</p><p id="564a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">复数加法的公式相当明显，减法的公式也是如此。乘法和除法的公式有点难记，但是，嘿，这就是我们有电脑的原因。在编写乘法测试时，一定要参考参考文献。</p><p id="77a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不管你是在学习复数还是更熟悉的东西，比如纯实数分数，我们仍然要处理除数为零的问题。</p><p id="57bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无论是对于复数还是纯实数分数，我认为被零除应该会导致异常。哪个例外？类比整数除法建议<code class="fe lh li lj lk b">ArithmeticException</code>。</p><p id="b05f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我对<code class="fe lh li lj lk b">ArithmeticException</code>的问题是，它表明更大的位宽或更高的机器精度可以提供正确的结果(例如，如果您从<code class="fe lh li lj lk b">Math.addExact()</code>获得<code class="fe lh li lj lk b">ArithmeticException</code>，您可以尝试使用<code class="fe lh li lj lk b">long</code>或<code class="fe lh li lj lk b">BigInteger</code>来代替)。</p><p id="4bfc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是被零除并不是一个可以在任何机器精度水平上精确表示的数字，也不能像无理数那样令人满意地近似。</p><p id="e25e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我觉得被零除应该导致<code class="fe lh li lj lk b">IllegalArgumentException</code>。但是在某些情况下，这可能需要捕捉一个<code class="fe lh li lj lk b">ArithmeticException</code>并将其包装成一个<code class="fe lh li lj lk b">IllegalArgumentException</code>。</p><p id="e23f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果被零除测试接受任一异常，但不接受可能处于相同继承级别的其他异常，这将是很好的，因为通过测试是有效的。在JUnit中，唯一有意义的方法是使用一个Try块和三个Catch块。</p><p id="4ef3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TestNG有一个类似JUnit 4的预期异常属性，但是我们可以指定两个或更多的预期异常。</p><pre class="lc ld le lf gt mr lk ms mt aw mu bi"><span id="bf19" class="mv lm iq lk b gy mw mx l my mz">    @Test(expectedExceptions = <strong class="lk ir">{ArithmeticException.class, <br/>                                IllegalArgumentException.class}</strong>)<br/>    public void testDivisionByZero() {<br/>        double re = -0.5 + Math.random();<br/>        double im = -0.5 + Math.random();<br/>        ComplexNumber someNumber = new ComplexNumber(re, im);<br/>        ComplexNumber zero = new ComplexNumber(0.0, 0.0);<br/>        ComplexNumber division = someNumber.divides(zero);<br/>        System.out.println(someNumber.toString() + " divided by " <br/>                + zero.toString() + " is said to be "<br/>                + division.toString());<br/>    }</span></pre><p id="b8f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe lh li lj lk b">divides()</code>抛出这两个异常中的任何一个，那么这个测试应该通过，如果抛出其他异常或者根本没有异常，那么这个测试就会失败。</p><p id="1e71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">测试不是文档。测试只是衡量一个程序是否在可接受的参数范围内工作。然而，我承认通过允许多个异常，TestNG允许多个可能的异常被更清楚地交流。</p><p id="6c5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您没有更改<code class="fe lh li lj lk b">divides()</code>存根，这个测试将失败，因为结果将是<code class="fe lh li lj lk b">someNumber</code>。但是如果你让<code class="fe lh li lj lk b">divides()</code>为非零除数工作，测试将失败，因为结果将是无意义的NaN + NaN <em class="lg"> i </em>，或者类似的东西。</p><p id="9549" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">针对TestNG的预期异常测试的NetBeans集成还有一些不足之处:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/74cc44a37b05b62c106421a7451179cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*qqSm_EpUiGv7GobqkQRmeg.png"/></div></figure><p id="5cf1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">什么？就这样吗？</p><blockquote class="na nb nc"><p id="ec07" class="kd ke lg kf b kg kh ki kj kk kl km kn nd kp kq kr ne kt ku kv nf kx ky kz la ij bi translated">[VerboseTestNG]调用:“命令行测试”-数字。complexnumberngtest . testdivisionbyzero()<br/>0.4118823922587276 0.46011452072966397 I除以0.0 + 0.0i据说是NaN + NaNi</p><p id="4365" class="kd ke lg kf b kg kh ki kj kk kl km kn nd kp kq kr ne kt ku kv nf kx ky kz la ij bi translated">[VerboseTestNG]失败:“命令行测试”numerics。complexnumberngtest . testdivisionbyzero()在0毫秒内完成<br/>[VerboseTestNG]org . TestNG . test exception:<br/>[VerboseTestNG]方法complexnumberngtest . testdivisionbyzero()[pri:0，instance:numerics。ComplexNumberNGTest@6d86b085]应该抛出java.lang.ArithmeticException类的异常</p></blockquote><p id="fd7f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我仔细检查以确保没有遗漏“或Java . lang . illegalargumentexception”类，但那就是不能被遗漏。</p><p id="db69" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，我向您保证，两个指定异常中的任何一个都将通过测试。</p><p id="2eb2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是TestNG发明者Cédric Beust事后不会加入的功能，因为它使预期的消息功能变得复杂，对他自己编程和我们使用它都是如此。</p><p id="b02c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">查看Javadoc中的<code class="fe lh li lj lk b">@Test</code>注释，我注意到它说它可以应用于一个测试过程(就像我们到目前为止所做的一样，也像我们在JUnit中所做的一样)，或者应用于整个测试类(这在JUnit中是一个错误)。</p><p id="7169" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，如果您的测试类完全由测试过程组成(与带有助手函数和嵌套类的测试过程相反)，您可以简单地将<code class="fe lh li lj lk b">@Test</code>注释放在靠近顶部的地方，然后您可能不必将它放在每个单独的测试过程上。</p><p id="e53e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我继续对<code class="fe lh li lj lk b">ComplexNumberNGTest</code>进行了修改，尽管被零除的测试需要注释，这样我就可以在它上面挂上预期的异常属性。</p><p id="8774" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我发现TestNG Javadoc有点缺乏细节。除了我已经提到的，我不知道在类级别使用<code class="fe lh li lj lk b">@Test</code>注释是否还有其他的注意事项或条件。</p><p id="90b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我还认为，如果您已经正确指定了测试设置和拆卸过程，您仍然可以将<code class="fe lh li lj lk b">@Test</code>注释放在类级别。那么TestNG测试运行者将正确地理解那些不是作为测试运行的测试过程，而是在测试之前或之后运行的。</p><h1 id="74c2" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">用状态测试类</h1><p id="b4b5" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">显然<code class="fe lh li lj lk b">ComplexNumberNGTest</code>并不是一个测试建立和拆除的好例子。我们需要一个有状态对象的类。</p><p id="5759" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个更好的例子是类似于<code class="fe lh li lj lk b">CheckingAccountNGTest</code>的东西，它从一个<code class="fe lh li lj lk b">CheckingAccount</code>实例开始，比如说，一开始就有1000美元的游戏币。然后，随着测试的进行，平衡会发生波动。</p><p id="9a1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于<code class="fe lh li lj lk b">CheckingAccount</code>与当前项目无关，我转而测试<code class="fe lh li lj lk b">ImageSelection</code>，这很像Java开发工具包(JDK)中的<code class="fe lh li lj lk b">StringSelection</code>，但是是针对图像的。</p><p id="eb55" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个能让我们把图像放到系统剪贴板上的类。如果这样的东西已经存在于JDK，我还没有能够找到它。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/9296e56507f92d0bdd9c89dbd9f11b45.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*hL-WDC8wi4-k9Z46r2YByQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">剪贴板测试的示例测试图像。</figcaption></figure><p id="6a8a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要一张测试图片放到剪贴板上。它不会是任何分形。它需要是简单的东西，可以在一个<code class="fe lh li lj lk b">Graphics2D</code>实例上用几个非迭代命令完成。</p><p id="9c3b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我想我们可以把它放在测试类的静态嵌套类中。但是我更喜欢在测试包下的<code class="fe lh li lj lk b">clipboardops</code>包中创建一个名为<code class="fe lh li lj lk b">TestImagePanel</code>的独立类(如果你不想创建自己的类，你可以使用我的<a class="ae kc" href="https://github.com/Alonso-del-Arte/algebraic-integer-calculator/blob/main/unit-testing/clipboardops/TestImagePanel.java" rel="noopener ugc nofollow" target="_blank">中的一个</a>)。</p><p id="8145" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我为<code class="fe lh li lj lk b">ImageSelection</code>写的非常粗略的草稿:</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="10fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该清单并没有反映出<code class="fe lh li lj lk b">plainTextFlavor</code>已被弃用(是的，这是术语，“数据风格”)。</p><p id="485f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让NetBeans生成<code class="fe lh li lj lk b">ImageSelectionNGTest</code>的框架，然后注释掉或删除所有带有潜在空指针警告的行。还要添加这些导入语句:</p><pre class="lc ld le lf gt mr lk ms mt aw mu bi"><span id="9b6c" class="mv lm iq lk b gy mw mx l my mz">import org.testng.annotations.AfterClass;<br/>import org.testng.annotations.AfterTest;<br/>import org.testng.annotations.BeforeClass;<br/>import org.testng.annotations.BeforeTest;</span></pre><p id="0518" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可能不会用到所有四个。我们总是可以在以后删除未使用的导入。还有一些其他的，但是这些是我相当确定有JUnit等价物的。</p><p id="5d57" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大概<code class="fe lh li lj lk b">BeforeClass</code>和<code class="fe lh li lj lk b">AfterClass</code>的工作方式与JUnit 4中的注释非常相似，JUnit 5中的<code class="fe lh li lj lk b">BeforeAll</code>和<code class="fe lh li lj lk b">AfterAll</code>也是如此。</p><p id="19a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而<code class="fe lh li lj lk b">BeforeTest</code>和<code class="fe lh li lj lk b">AfterTest</code>大概相当于JUnit 4中的<code class="fe lh li lj lk b">Before</code>和<code class="fe lh li lj lk b">After</code>以及JUnit 5中的<code class="fe lh li lj lk b">BeforeEach</code>和<code class="fe lh li lj lk b">AfterEach</code>。</p><p id="3a37" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我说可能是因为我可能做了一些不正确的假设。</p><p id="ef8c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我不想假设TestNG要求测试类的设置和拆卸是静态的，就像在JUnit中一样。</p><p id="fb3b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这对<code class="fe lh li lj lk b">ComplexNumberNGTest</code>来说无关紧要，因为每个测试过程都应该或多或少地创建<code class="fe lh li lj lk b">ComplexNumber</code>的随机实例，这些实例不会在接下来的测试中保留。</p><p id="f2c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是对于<code class="fe lh li lj lk b">ImageSelectionNGTest</code>，我们希望跟踪系统剪贴板上的内容。所以这个测试类需要获得一个指向系统剪贴板的指针，并保持它直到所有的测试都完成。</p><p id="326b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这指出了JUnit和TestNG之间的一个更重要的区别，这个区别对于用state测试类很重要:JUnit test runner为每个测试过程实例化测试类，而TestNG没有。</p><p id="4800" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着如果一个测试类有十个测试，JUnit测试运行器将实例化这个测试类十次。另一方面，TestNG测试运行程序将只实例化测试类一次，无论它只有一个测试、十个测试、一百个测试，无论有多少个。</p><p id="df8d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我明白了为什么我的JUnit版本的<code class="fe lh li lj lk b">ImageSelectionTest</code>会在一瞬间打开和关闭测试图像面板十几次。带<code class="fe lh li lj lk b">@BeforeClass</code>注释的过程打开测试图像面板和带<code class="fe lh li lj lk b">@AfterClass</code>注释的过程，这些过程为每个测试运行一次。</p><p id="77b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，在JUnit版本的<code class="fe lh li lj lk b">CheckingAccountTest</code>中，<code class="fe lh li lj lk b">@BeforeClass</code>注释的过程必须初始化一个静态的<code class="fe lh li lj lk b">CheckingAccount</code>实例。否则，每个测试将从测试类设置中初始化的相同天平开始。</p><p id="9b78" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在TestNG中，我们可以采用相同的方法，但我们不一定要这样做。我在<code class="fe lh li lj lk b">ImageSelectionTest</code>中的私有静态字段已经变成了我的<code class="fe lh li lj lk b">ImageSelectionNGTest</code>中的私有实例字段。</p><p id="3ec2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我仍然编写了一个报告剪贴板内容的私有helper过程，称为<code class="fe lh li lj lk b">reportClipboardContents()</code>。它从剪贴板包含什么样的“数据味道”开始。如果这些“风格”中有一种是<code class="fe lh li lj lk b">stringFlavor</code>，那么输出中将包含这些内容。</p><p id="eff2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">带注释的<code class="fe lh li lj lk b">@BeforeClass</code>获取系统剪贴板上的一个句柄，并设置一个图像和一个<code class="fe lh li lj lk b">ImageSelection</code>实例供测试使用，但是不把它放在剪贴板上，而是放置文本“这个消息是由setUpClass()放置的”或其他类似的文字。</p><p id="93b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我还写了一个<code class="fe lh li lj lk b">@AfterTest</code>注释的过程，除了调用<code class="fe lh li lj lk b">reportClipboardContents()</code>之外，它什么也不做。以及一个<code class="fe lh li lj lk b">@AfterClass</code>-带注释的过程，用于关闭测试图像面板。</p><p id="e2a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有的测试现在都应该失败了，如果没有其他原因，我们没有删除所有生成的对<code class="fe lh li lj lk b">fail()</code>的调用。</p><p id="443d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我添加了一个<code class="fe lh li lj lk b">@BeforeTest</code>-注释的过程，试图将一些文本放到剪贴板上时，我突然醒悟了:这导致了空指针异常，阻止了每个测试的运行。</p><p id="2634" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在查看了堆栈溢出的<a class="ae kc" href="https://stackoverflow.com/questions/39524664/testng-priority-of-beforeclass-and-beforetest" rel="noopener ugc nofollow" target="_blank">之后，我意识到我真正想要的是<code class="fe lh li lj lk b">@BeforeSuite</code>在所有事情之前运行，<code class="fe lh li lj lk b">@BeforeMethod</code>在每个<code class="fe lh li lj lk b">@Test</code>注释的测试过程之前运行，<code class="fe lh li lj lk b">@AfterMethod</code>在每个测试过程之后运行，<code class="fe lh li lj lk b">@AfterSuite</code>在所有事情之后运行。</a></p><p id="697d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解决了这个问题后，我就可以实际编写测试了，取代了NetBeans为我生成的许多内容。</p><p id="3efa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在混淆了之前和之后之后，我惊喜地发现TestNG没有<code class="fe lh li lj lk b">assertArrayEquals()</code>。在我看来，这是件好事。</p><pre class="lc ld le lf gt mr lk ms mt aw mu bi"><span id="57bd" class="mv lm iq lk b gy mw mx l my mz">    @Test<br/>    public void testGetTransferDataFlavors() {<br/>        System.out.println("getTransferDataFlavors");<br/>        DataFlavor[] expected = {DataFlavor.imageFlavor};<br/>        DataFlavor[] actual = this.imgSel.getTransferDataFlavors();<br/>        <strong class="lk ir">assertEquals(actual, expected);</strong><br/>    }</span></pre><p id="376e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它足够聪明，知道它应该逐个比较数组元素，并在发现不匹配时抛出一个<code class="fe lh li lj lk b">AssertionError</code>(大概是在检查数组长度相同之后)。</p><blockquote class="na nb nc"><p id="79b1" class="kd ke lg kf b kg kh ki kj kk kl km kn nd kp kq kr ne kt ku kv nf kx ky kz la ij bi translated">[verbosestng]Java . lang . assertion error:<strong class="kf ir">列表在元素[0] </strong>处不同:Java . awt . data transfer . data flavor[mime type = image/x-Java-image；representation class = Java . awt . image]！= Java . awt . data transfer . data flavor[mime type = text/plain；representation class = Java . io . inputstream；charset=unicode]</p></blockquote><p id="114d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们所要做的就是将<code class="fe lh li lj lk b">getTransferDataFlavors()</code>中被否决的<code class="fe lh li lj lk b">plainTextFlavor</code>替换为<code class="fe lh li lj lk b">imageFlavor</code>，测试就通过了。</p><p id="dddf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了测试布尔变量，比如对于<code class="fe lh li lj lk b">isDataFlavorSupported()</code>，TestNG和JUnit一样有<code class="fe lh li lj lk b">assertTrue()</code>和<code class="fe lh li lj lk b">assertFalse()</code>。但是即使在JUnit中，我现在也更喜欢使用Java的保留字<code class="fe lh li lj lk b">assert</code>来代替。</p><p id="235d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了实际的第一个和预期的第二个之外，<code class="fe lh li lj lk b">getTransferData()</code>的测试应该和相应的JUnit测试看起来完全一样。</p><h1 id="b216" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">重构</h1><p id="d561" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">我有一种挥之不去的感觉，也许<code class="fe lh li lj lk b">ImageSelection</code>不应该是<code class="fe lh li lj lk b">ClipboardOwner</code>(但是另一方面，<code class="fe lh li lj lk b">StringSelection</code>必须是<code class="fe lh li lj lk b">ClipboardOwner</code>，如果没有其他原因，仅仅是向后兼容)。</p><p id="13d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">似乎没有什么有意义的方法来测试<code class="fe lh li lj lk b">lostOwnership()</code>。在模型中，<code class="fe lh li lj lk b">StringSelection</code>，<code class="fe lh li lj lk b">lostOwnership()</code>是一个绝对不做任何事情的过程(至少在Java 8中是这样)。</p><p id="958c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">多亏了TestNG，我终于决定采取行动了。首先，我将<code class="fe lh li lj lk b">ClipboardOwner</code>从<code class="fe lh li lj lk b">ImageSelection</code>实现的接口列表中删除。然后我删除了<code class="fe lh li lj lk b">lostOwnership()</code>覆盖和<code class="fe lh li lj lk b">hasOwnership()</code>功能。最后，我删除了未使用的导入和剪贴板所有权标志。</p><p id="c516" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">点击保存。如果您没有在<code class="fe lh li lj lk b">ImageSelectionNGTest</code>中注释掉或删除对<code class="fe lh li lj lk b">lostOwnership()</code>或<code class="fe lh li lj lk b">hasOwnership()</code>的调用，NetBeans可能会进行后台扫描，并提醒您测试类中的错误。</p><p id="9126" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果测试类有错误，通过删除<code class="fe lh li lj lk b">lostOwnership()</code>和<code class="fe lh li lj lk b">hasOwnership()</code>的测试来纠正错误。实际上，无论如何都要去掉它们。</p><p id="7ab5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而且我决定把<code class="fe lh li lj lk b">ImageSelectionNGTest</code>做成<code class="fe lh li lj lk b">ClipboardOwner</code>。我相信您也可以在JUnit中做到这一点。那么当一个测试类实例失去剪贴板的所有权时，它会得到通知。</p><blockquote class="na nb nc"><p id="ebaf" class="kd ke lg kf b kg kh ki kj kk kl km kn nd kp kq kr ne kt ku kv nf kx ky kz la ij bi translated">剪贴板有以下数据风格:[Java . awt . data transfer . data flavor[mime type = image/x-Java-image；representation class = Java . awt . image]]<br/>测试类已失去sun . awt . data transfer . transferableproxy的系统所有权</p></blockquote><p id="99d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里的“系统”指的是系统剪贴板。我不确定什么是<code class="fe lh li lj lk b">TransferableProxy</code>，但是这比这篇文章所需要的更多地涉及到了<code class="fe lh li lj lk b">StringSelection</code>的细节。</p><h1 id="ca0e" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">测试Eclipse和IntelliJ IDEA</h1><p id="3c43" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">当然，TestNG不仅仅是针对NetBeans的。NetBeans也不是TestNG“开箱即用”的唯一集成开发环境(IDE)IntelliJ IDEA还附带了TestNG，以及一堆我以前从未听说过的其他测试框架。</p><p id="46a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在IntelliJ中不需要下载JAR或插件来进行测试。我这么说是肯定的，因为我为IntelliJ安装添加的唯一插件是Scala for IntelliJ插件。</p><p id="46c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，除了写这篇文章，我想在IntelliJ中使用TestNG的主要原因是用它来测试Scala类。同样的警告适用于TestNG for Scala，也适用于JUnit for Scala:如果您使用Code &gt; Generate… Test，生成的测试类将是Java的，而不是Scala的。</p><p id="ee7a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我仍然建议这样做，至少在特定的Scala项目中第一次这样做，这样IntelliJ就可以负责更新您的项目依赖关系以及其他需要处理的事情。</p><p id="e963" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">出于某种原因，IntelliJ将TestNG测试类命名为与JUnit测试类相同。例如，对于<code class="fe lh li lj lk b">SomeClass</code>，测试类将是<code class="fe lh li lj lk b">SomeClassTest</code>，而不是<code class="fe lh li lj lk b">SomeClassNGTest</code>。</p><p id="3f34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也许JetBrains的人认为极少数用户会希望使用不同的测试框架为同一个测试类创建两个或更多的测试类。这可能是一个很好的假设。</p><p id="fc03" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我尝试了一个在IntelliJ中使用TestNG的玩具示例，IntelliJ是一个名为<code class="fe lh li lj lk b">ArrayDemo</code>的静态类(在Scala中称为<code class="fe lh li lj lk b">object</code>)。我注意到TestNG Javadoc虽然很少，但似乎完全从IntelliJ中消失了。这使得IntelliJ的参数标签相当无用。例如，看看这个断言:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/6a6520b458e6c0811a72710ead5bc848.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*p1pl10kPWrgT4toV8sEmdQ.png"/></div></figure><p id="4e6f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">哪个应该是预期的，哪个应该是实际的？也许<code class="fe lh li lj lk b">i1</code>？如果你有阅读障碍，这种事情很重要。</p><p id="5e37" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">至于Eclipse，这绝对需要您自己下载TestNG JAR并编辑项目依赖项，或者您可以从Eclipse Marketplace安装Cédric Beust的TestNG for Eclipse。</p><p id="c79a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我想到可以将IntelliJ或NetBeans的TestNG JAR与Eclipse挂钩，但我并没有真正尝试过。但是最好让插件来做。</p><p id="046d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我不怎么使用Eclipse，所以我不在乎在Eclipse中实际尝试TestNG，哪怕只是一个玩具示例。</p><h1 id="8db1" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">摘要</h1><p id="8c2d" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">看起来你可以在TestNG中做你在JUnit中能做的一切，甚至更多。在这次试驾中，我只触及了TestNG的皮毛。</p><p id="ae71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有一些重要的区别需要注意，比如先实际后预期，以及测试类实例化的问题。</p><p id="3005" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">查看Javadoc总是一个好主意，尽管TestNG Javadoc似乎有点过于简洁，至少对于我在NetBeans中使用的版本来说是这样。</p><p id="1769" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">NetBeans集成中也有一些缺陷，包括编译中明显的偶然延迟。我不确定这是不是一个可复制的问题。</p><p id="0bd2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我已经试用过了，我决定我非常喜欢TestNG，可以在NetBeans中的新Java项目中使用它，也可以在IntelliJ中的新Scala项目中使用它。但不足以将我现有的任何项目从JUnit中切换出来。</p><p id="34ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你觉得绝对有必要的话，你可以在同一个项目中混合使用JUnit和TestNG，但是我强烈建议不要在同一个测试类中同时使用两者。</p><p id="8169" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看起来TestNG对得起所有的5星评价。</p></div></div>    
</body>
</html>