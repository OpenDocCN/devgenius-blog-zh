<html>
<head>
<title>Deploying Django Application on AWS with Terraform. GitLab CI/CD</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Terraform 在 AWS 上部署 Django 应用程序。GitLab CI/CD</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/deploying-django-application-on-aws-with-terraform-gitlab-ci-cd-fbc2bbc0d286?source=collection_archive---------8-----------------------#2022-08-02">https://blog.devgenius.io/deploying-django-application-on-aws-with-terraform-gitlab-ci-cd-fbc2bbc0d286?source=collection_archive---------8-----------------------#2022-08-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/df0060699ff075828d2a54e20217e636.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eg5m3XHCMRhJwuKCdHjNbA.png"/></div></div></figure><div class=""/><p id="c5b9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在前面的部分中，我们已经<a class="ae kt" href="https://medium.com/@eugen1j.bondar/deploying-django-application-on-aws-with-terraform-minimal-working-setup-d6075b3b8299" rel="noopener">将 Django web 应用程序部署到 ECS </a>并且<a class="ae kt" href="https://medium.com/@eugen1j.bondar/bcd9c29d6276" rel="noopener">将 PostgreSQL </a>连接到它。但是现在，我们必须手动部署应用程序更改。在这一部分中，我们将通过以下步骤自动完成这一过程:</p><ul class=""><li id="8b87" class="ku kv iy jx b jy jz kc kd kg kw kk kx ko ky ks kz la lb lc bi translated">为<a class="ae kt" href="https://gitlab.com/django-aws/django-aws-backend" rel="noopener ugc nofollow" target="_blank">后端</a>和<a class="ae kt" href="https://gitlab.com/django-aws/django-aws-infrastructure" rel="noopener ugc nofollow" target="_blank">基础设施</a>仓库创建一个 GitLab 组和项目。</li><li id="9c93" class="ku kv iy jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">添加<code class="fe li lj lk ll b">test</code> CI/CD 阶段以运行测试。</li><li id="be5d" class="ku kv iy jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">添加<code class="fe li lj lk ll b">build</code> CI/CD 阶段以构建 docker 映像并将其推送到 ECR。</li><li id="a5fc" class="ku kv iy jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">添加<code class="fe li lj lk ll b">deploy</code> CI/CD 阶段以更新 AWS 上的应用程序。</li></ul><h1 id="7178" class="lm ln iy bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">创建项目</h1><p id="1cd1" class="pw-post-body-paragraph jv jw iy jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">让我们从创建 GitLab 组和项目开始。去<a class="ae kt" href="https://gitlab.com/" rel="noopener ugc nofollow" target="_blank">gitlab.com</a>注册一个账户。</p><p id="672a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后<a class="ae kt" href="https://gitlab.com/groups/new#create-group-pane" rel="noopener ugc nofollow" target="_blank">创建</a>一个<a class="ae kt" href="https://docs.gitlab.com/ee/user/group/" rel="noopener ugc nofollow" target="_blank"> GitLab 组</a>。组就像是项目的文件夹。您可以为它们配置共享设置，如访问策略和 CI 变量。</p><p id="ebe0" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为该组中的<a class="ae kt" href="https://gitlab.com/django-aws/django-aws-backend" rel="noopener ugc nofollow" target="_blank"> Django </a>和<a class="ae kt" href="https://gitlab.com/django-aws/django-aws-infrastructure" rel="noopener ugc nofollow" target="_blank"> Terraform </a>创建项目。确保删除“使用自述文件初始化存储库”选项，以创建干净的存储库。</p><p id="6fdf" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另外，把你的 ssh 密钥添加到<a class="ae kt" href="https://gitlab.com/-/profile/keys" rel="noopener ugc nofollow" target="_blank"> SSH 密钥</a>部分。它允许你通过 Git 访问你的项目。</p><p id="0d92" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们将两个库都推送到 GitLab。</p><pre class="mp mq mr ms gt mt ll mu mv aw mw bi"><span id="b89b" class="mx ln iy ll b gy my mz l na nb"># Push backend<br/>cd ../django-aws-backend<br/>git remote add origin git@gitlab.com:django-aws/django-aws-backend<br/>git push --set-upstream origin main</span><span id="9001" class="mx ln iy ll b gy nc mz l na nb"># Push infrastructure<br/>cd ../django-aws-infrastructure<br/>git remote add origin git@gitlab.com:django-aws/django-aws-infrastructure<br/>git push --set-upstream origin main</span></pre><p id="b417" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在浏览器中检查您的 GitLab 项目，并验证推送是否成功。</p><h1 id="f46d" class="lm ln iy bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">阶段:测试</h1><p id="a074" class="pw-post-body-paragraph jv jw iy jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">现在让我们向 Django 项目添加单元测试检查。Django 的单元测试使用 Python 标准库模块<a class="ae kt" href="https://docs.python.org/3/library/unittest.html#module-unittest" rel="noopener ugc nofollow" target="_blank"> unittest </a>。点击查看更多关于测试 Django 应用程序<a class="ae kt" href="https://docs.djangoproject.com/en/3.2/topics/testing/overview/" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><p id="2a80" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">转到 Django 项目，激活<code class="fe li lj lk ll b">venv</code>并启动一个 PostgreSQL Docker 容器:</p><pre class="mp mq mr ms gt mt ll mu mv aw mw bi"><span id="9091" class="mx ln iy ll b gy my mz l na nb">$ cd ../django-aws-backend<br/>$ . ./venv/bin/activate<br/>$ docker-compose up -d</span></pre><p id="254c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们创建<code class="fe li lj lk ll b">django_aws/tests.py</code>并添加一个简单的测试来检查数据库连接:</p><figure class="mp mq mr ms gt ip"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="73ea" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本地运行<code class="fe li lj lk ll b">python manage.py test</code>:</p><pre class="mp mq mr ms gt mt ll mu mv aw mw bi"><span id="c678" class="mx ln iy ll b gy my mz l na nb">$ python manage.py test<br/>Creating test database for alias 'default'...<br/>System check identified no issues (0 silenced).<br/>.<br/>----------------------------------------------------------------------<br/>Ran 1 test in 0.010s</span><span id="c1e0" class="mx ln iy ll b gy nc mz l na nb">OK<br/>Destroying test database for alias 'default'...</span></pre><p id="3f93" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们在 GitLab 端添加这个检查。如果你不知道 GitLab CI 是什么，看看这里的<a class="ae kt" href="https://docs.gitlab.com/ee/ci/quick_start/" rel="noopener ugc nofollow" target="_blank"/>。一般来说，GitLab 会运行<a class="ae kt" href="https://docs.gitlab.com/ee/ci/yaml/" rel="noopener ugc nofollow" target="_blank">中指定的代码。存储库中的每次推送。</a></p><p id="b81d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建包含以下内容的<code class="fe li lj lk ll b">.gitlab-ci.yml</code>文件:</p><figure class="mp mq mr ms gt ip"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="5bb4" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">解释:</p><ul class=""><li id="fe0d" class="ku kv iy jx b jy jz kc kd kg kw kk kx ko ky ks kz la lb lc bi translated"><code class="fe li lj lk ll b">image: python:3.10</code>。默认情况下，GitLab 使用<a class="ae kt" href="https://docs.gitlab.com/runner/executors/docker.html" rel="noopener ugc nofollow" target="_blank"> docker 执行器</a>在 GitLab 托管的共享运行器上运行 CI/CD 管道。这里我们为执行者指定 docker 图像。</li><li id="a174" class="ku kv iy jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated"><code class="fe li lj lk ll b">stages:</code>。一个管道可以有几个阶段。现在我们只有<code class="fe li lj lk ll b">test</code>阶段。未来我们会有三个阶段:<code class="fe li lj lk ll b">test</code>、<code class="fe li lj lk ll b">build</code>、<code class="fe li lj lk ll b">deploy</code>。GitLab 将按照指定的顺序执行阶段。</li><li id="81ac" class="ku kv iy jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated"><code class="fe li lj lk ll b">services: postgres:14.2</code>。GitLab 将在<code class="fe li lj lk ll b">test</code>阶段在一个单独的容器中运行 PostgreSQL。因此，我们的 Django 应用程序将能够运行 DB 相关的测试。</li><li id="4e6b" class="ku kv iy jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated"><code class="fe li lj lk ll b">variables: POSTGRES_PASSWORD, POSTGRES_DB DATABASE_URL</code>-Django 和 PostgreSQL docker 容器的环境变量。</li><li id="f80e" class="ku kv iy jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated"><code class="fe li lj lk ll b">cache: key:</code>。这里我们缓存了<code class="fe li lj lk ll b">pip install</code>命令的结果，以加速流水线执行。如果键<code class="fe li lj lk ll b">files: requirements.txt</code>自上次运行以来没有改变，GitLab 将下载<code class="fe li lj lk ll b">venv</code>和<code class="fe li lj lk ll b">.cache/pip</code>目录的缓存。</li><li id="9f4f" class="ku kv iy jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated"><code class="fe li lj lk ll b">script: ...</code>是要执行的命令。GitLab 逐个执行命令。如果某个命令返回非零退出代码，GitLab 将中断管道执行，并将其标记为<em class="nf">失败</em>。如果所有命令都已成功执行，GitLab 将当前阶段标记为<em class="nf">成功</em>并进入下一阶段。</li></ul><p id="7dd7" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，推动更改并查看 GitLab Django 项目的<a class="ae kt" href="https://gitlab.com/django-aws/django-aws-backend/-/pipelines" rel="noopener ugc nofollow" target="_blank"> CI/CD </a>选项卡。</p><pre class="mp mq mr ms gt mt ll mu mv aw mw bi"><span id="4d32" class="mx ln iy ll b gy my mz l na nb">$ git add .<br/>$ git commit -m "add gitlab-ci; add test"<br/>$ git push</span></pre><figure class="mp mq mr ms gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi ng"><img src="../Images/6f03c812d81062e86ebfa8bf4c476914.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KsCUODONBAIn4_DF.png"/></div></div></figure><figure class="mp mq mr ms gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nh"><img src="../Images/b303f74030bf0c377c3fae02eb0c3e64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*e2d27rVUJE8FoKUz.png"/></div></div></figure><h1 id="b229" class="lm ln iy bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">阶段:构建</h1><p id="7c22" class="pw-post-body-paragraph jv jw iy jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">测试通过了，所以我们进入了<code class="fe li lj lk ll b">build</code>阶段。在这个阶段，我们需要将 GitLab 帐户与 AWS 帐户连接起来，以授予 GitLab 访问 ECR 存储库的权限。为此，我们将创建一个拥有有限权限的单独的 AWS 用户<code class="fe li lj lk ll b">gitlab</code>。让我们转到 AWS IAM 控制台，创建一个新用户<a class="ae kt" href="https://us-east-1.console.aws.amazon.com/iam/home#/users$new?step=details" rel="noopener ugc nofollow" target="_blank">。</a></p><blockquote class="ni nj nk"><p id="55d0" class="jv jw nf jx b jy jz ka kb kc kd ke kf nl kh ki kj nm kl km kn nn kp kq kr ks ig bi translated"><em class="iy">你可以在这里</em> 找到如何创建 AWS 用户 <a class="ae kt" href="https://medium.com/@eugen1j.bondar/deploying-django-application-on-aws-with-terraform-minimal-working-setup-d6075b3b8299#0f15" rel="noopener"> <em class="iy">的说明</em></a></p></blockquote><p id="fd3a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">向此用户添加<code class="fe li lj lk ll b">AmazonEC2ContainerRegistryPowerUser</code>策略，以启用对此帐户上任何 ECR 存储库的读写权限。进入用户创建的最后一步，保存<code class="fe li lj lk ll b">ACCESS_KEY_ID</code>和<code class="fe li lj lk ll b">SECRET_ACCESS_KEY</code>。</p><p id="b308" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在转到 GitLab 组设置，添加<code class="fe li lj lk ll b">AWS_ACCOUNT_ID</code>、<code class="fe li lj lk ll b">AWS_SECRET_ACCESS_KEY</code>、<code class="fe li lj lk ll b">AWS_ACCESS_KEY_ID</code>和<code class="fe li lj lk ll b">AWS_DEFAULT_REGION</code>变量。GitLab runner 将使用这些凭据进行 AWS CLI 调用。</p><figure class="mp mq mr ms gt ip"><div class="bz fp l di"><div class="no ne l"/></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated">添加 GitLab CI/CD 变量</figcaption></figure><p id="5925" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">确保屏蔽敏感变量<code class="fe li lj lk ll b">AWS_ACCOUNT_ID</code>、<code class="fe li lj lk ll b">AWS_SECRET_ACCESS_KEY</code>和<code class="fe li lj lk ll b">AWS_ACCESS_KEY_ID</code>以隐藏它们在 GitLab 日志中的值。查看<a class="ae kt" href="https://docs.gitlab.com/ee/ci/cloud_deployment/index.html#aws" rel="noopener ugc nofollow" target="_blank"> AWS 部署</a>文档页面以获取更多信息。</p><p id="c6d8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后添加到<code class="fe li lj lk ll b">.gitlab-ci.yml</code>构建模块:</p><figure class="mp mq mr ms gt ip"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="166d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">解释:</p><ul class=""><li id="ee0f" class="ku kv iy jx b jy jz kc kd kg kw kk kx ko ky ks kz la lb lc bi translated"><code class="fe li lj lk ll b">image: registry.gitlab.com/gitlab-org/cloud-deploy/aws-base:latest</code>。此映像允许在 CI/CD 期间使用 AWS CLI 命令。</li><li id="bc5a" class="ku kv iy jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated"><code class="fe li lj lk ll b">services: docker:20.10-dind</code>。我们使用<a class="ae kt" href="https://docs.gitlab.com/ee/ci/docker/using_docker_build.html#use-docker-in-docker" rel="noopener ugc nofollow" target="_blank"> docker-in-docker </a>在<a class="ae kt" href="https://docs.gitlab.com/runner/executors/docker.html" rel="noopener ugc nofollow" target="_blank"> docker 执行器</a>中构建 docker 映像。Docker 作为一个独立的服务启动，因此我们可以从 GitLab 作业中访问 docker 守护进程。</li><li id="4432" class="ku kv iy jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated"><code class="fe li lj lk ll b">variables: DOCKER_HOST, DOCKER_TLS_CERTDIR</code>。指定 docker-in-docker 守护程序的路径，并禁用 TLS 连接。</li><li id="3a83" class="ku kv iy jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated"><code class="fe li lj lk ll b">AWS_REGISTRY_URL</code>。从项目名称构建 ECR URL。确保 ECR repo 和 Gitlab 项目的名称相同。</li><li id="b547" class="ku kv iy jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated"><code class="fe li lj lk ll b">before_script: aws ecr get-login-password</code>。登录到 ECR。</li><li id="9dc0" class="ku kv iy jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated"><code class="fe li lj lk ll b">docker pull $AWS_REGISTRY_URL || true</code>。提取实际图像以将其用作缓存</li><li id="82c8" class="ku kv iy jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated"><code class="fe li lj lk ll b">docker push $AWS_REGISTRY_URL</code>。将图像上传到 ECR。</li><li id="bc4c" class="ku kv iy jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated"><code class="fe li lj lk ll b">only: main</code>。我们将只为<code class="fe li lj lk ll b">main</code>分支建立一个 docker 映像。</li></ul><p id="338e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">提交您的更改并检查 CI/CD 管道:</p><pre class="mp mq mr ms gt mt ll mu mv aw mw bi"><span id="03ca" class="mx ln iy ll b gy my mz l na nb">$ git add .<br/>$ git commit -m "add build stage"<br/>$ git push</span></pre><figure class="mp mq mr ms gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nt"><img src="../Images/9d448b1130d2d0fc53e3060fd8c62577.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*npezz-RBXZI5VOLd.png"/></div></div></figure><h1 id="204f" class="lm ln iy bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">阶段:部署</h1><p id="7911" class="pw-post-body-paragraph jv jw iy jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">构建阶段已过，现在我们将把容器从 ECR 部署到 ECS。</p><p id="578d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是让我们从运行迁移开始。我们希望将迁移作为单独的 ECS 任务来运行，以避免对 web 应用程序产生任何副作用。转到<code class="fe li lj lk ll b">infrastructure</code>项目，在<code class="fe li lj lk ll b">ecs.tf</code>中进行以下更改并应用更改:</p><figure class="mp mq mr ms gt ip"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c311" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们为<code class="fe li lj lk ll b">container_vars</code>中的<code class="fe li lj lk ll b">migration</code>和<code class="fe li lj lk ll b">web</code>容器移动了相同的变量。然后，我们为迁移容器创建了一个单独的任务定义和日志流。现在，我们可以使用指定的任务定义来启动任务，以便为每个版本应用迁移。</p><p id="2bc9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们创建一个部署脚本。返回 Django 项目并创建<code class="fe li lj lk ll b">scripts/deploy.sh</code>文件</p><pre class="mp mq mr ms gt mt ll mu mv aw mw bi"><span id="261f" class="mx ln iy ll b gy my mz l na nb">cd ../django-aws-backend<br/>mkdir scripts<br/>touch scripts/deploy.sh<br/>chmod 777 scripts/deploy.sh</span></pre><p id="43f5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">包含以下内容:</p><figure class="mp mq mr ms gt ip"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b394" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以查看<a class="ae kt" href="https://awscli.amazonaws.com/v2/documentation/api/latest/reference/ecs/run-task.html" rel="noopener ugc nofollow" target="_blank">运行-任务</a>、<a class="ae kt" href="https://awscli.amazonaws.com/v2/documentation/api/latest/reference/ecs/wait/tasks-stopped.html" rel="noopener ugc nofollow" target="_blank">等待任务-停止</a>和<a class="ae kt" href="https://awscli.amazonaws.com/v2/documentation/api/latest/reference/ecs/update-service.html" rel="noopener ugc nofollow" target="_blank">更新-服务</a>命令的文档。</p><p id="714e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本地运行该脚本进行检查:</p><pre class="mp mq mr ms gt mt ll mu mv aw mw bi"><span id="3efb" class="mx ln iy ll b gy my mz l na nb">$ ./scripts/deploy.sh<br/>Collecting data...<br/>Running migration task...<br/>Task arn:aws:ecs:us-east-2:947134793474:task/prod/dcc06d7ec1ac4bb69bba445565eddf8b running...<br/>Updating web...<br/>"prod-backend-web"<br/>Done!</span></pre><p id="21f6" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们已经由用户<code class="fe li lj lk ll b">admin</code>成功运行了这个脚本。GitLab CI/CD 将使用<code class="fe li lj lk ll b">gitlab</code>用户，因此我们需要授予所有需要的权限。</p><p id="d174" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们创建一个新策略<code class="fe li lj lk ll b">gitlab-deploy-ecs</code>，并将其添加到<code class="fe li lj lk ll b">gitlab</code>用户。转到<a class="ae kt" href="https://us-east-1.console.aws.amazon.com/iam/home" rel="noopener ugc nofollow" target="_blank"> IAM 控制台</a>，选择“用户”选项卡并点击<code class="fe li lj lk ll b">gitlab</code>用户。</p><figure class="mp mq mr ms gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nu"><img src="../Images/2f32539f88ae8e9d4c2f86b5069d4e00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3j8hkIFSjWK_PWGL.png"/></div></div></figure><p id="ad28" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，单击“Add inline policy”并添加 JSON 策略定义。你需要用你的<code class="fe li lj lk ll b">AWS_ACCOUNT_ID</code>而不是<code class="fe li lj lk ll b">947134793474</code>号。</p><figure class="mp mq mr ms gt ip"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="mp mq mr ms gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nv"><img src="../Images/eb20a60abcfec2b53194e050a339d365.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8zJloHL_CC_MWj48.png"/></div></div></figure><p id="7496" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">解释政策:</p><ul class=""><li id="51d6" class="ku kv iy jx b jy jz kc kd kg kw kk kx ko ky ks kz la lb lc bi translated"><code class="fe li lj lk ll b">ec2:DescribeSubnets</code>、<code class="fe li lj lk ll b">ec2:DescribeSecurityGroups</code>——用于“收集数据……”舞台。</li><li id="c00b" class="ku kv iy jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated"><code class="fe li lj lk ll b">ecs:RunTask</code>、<code class="fe li lj lk ll b">iam:PassRole</code> —用于运行迁移 ECS 任务。</li><li id="a184" class="ku kv iy jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated"><code class="fe li lj lk ll b">ecs:DescribeTasks</code> —用于等待迁移 ECS 任务结束。</li><li id="58bc" class="ku kv iy jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated"><code class="fe li lj lk ll b">ecs:UpdateService</code> —用于更新 ECS Django web 应用程序。</li></ul><p id="f7cf" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">点击“查看策略”，命名策略<code class="fe li lj lk ll b">gitlab-ecs-deploy</code>，点击“创建策略”。现在，<code class="fe li lj lk ll b">gitlab</code>用户将能够执行<code class="fe li lj lk ll b">deploy.sh</code>脚本。</p><p id="95be" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将部署阶段添加到<code class="fe li lj lk ll b">.gitlab-ci.yml</code></p><figure class="mp mq mr ms gt ip"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="89dc" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在部署阶段，我们只需运行<code class="fe li lj lk ll b">deploy.sh</code>脚本。我们使用<code class="fe li lj lk ll b">aws-base</code>映像来访问 AWS CLI 命令。</p><p id="aabc" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，让我们给 Django 添加一些更改，看看我们的应用程序会自动更新。让我们更改 Django 管理标题文本。将此行添加到<code class="fe li lj lk ll b">django_aws/urls.py</code>:</p><figure class="mp mq mr ms gt ip"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="28fa" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在提交您的更改，看看您的管道进展如何。</p><pre class="mp mq mr ms gt mt ll mu mv aw mw bi"><span id="07b8" class="mx ln iy ll b gy my mz l na nb">$ git add .<br/>$ git commit -m "add deploy stage"<br/>$ git push</span></pre><figure class="mp mq mr ms gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nw"><img src="../Images/4c0ec46aadadabf33e9f6c24e0d8b96d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*H5mLyXSK90CLZ_JX.png"/></div></div></figure><p id="b9f5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">检查您的管理页面<code class="fe li lj lk ll b">prod-57218461274.us-east-2.elb.amazonaws.com/admin</code>并查看新标题。更新 ECS 服务可能需要一些时间。</p><figure class="mp mq mr ms gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nx"><img src="../Images/4e8dfdd6abbca87b3fa4f868d0b870de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9INsADyFWPDaD9ie.png"/></div></div></figure><p id="bd40" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此外，不要忘记将基础设施代码推送到 GitLab。</p><p id="17ec" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">恭喜你！我们已经成功地用 GitLab 为我们的 web Django web 应用程序设置了 CI/CD。现在我们可以将代码提交到<code class="fe li lj lk ll b">main</code>分支，GitLab CI/CD 将自动测试、构建并在 AWS 上部署它。</p><p id="d58e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是<code class="fe li lj lk ll b">prod-57218461274.us-east-2.elb.amazonaws.com</code>域看起来不是用户友好的:)此外，我们需要用 SSL 证书保护用户和 Django 应用程序之间的连接。在下一部分中，我们将把 Namecheap 域连接到 AWS，并为它们设置一个 SSL 证书。</p><p id="07f1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以在这里和这里找到后端和基础设施项目的源代码<a class="ae kt" href="https://gitlab.com/django-aws/django-aws-backend" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="3253" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您的项目需要技术咨询，请查看我们的<a class="ae kt" href="https://daiquiri.team/services/technical-consulting?utm_medium=referral&amp;utm_source=medium_blog&amp;utm_campaign=django_aws_3" rel="noopener ugc nofollow" target="_blank">网站</a>或直接通过<a class="ae kt" href="https://www.linkedin.com/in/yevhen-bondar/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>与我联系。</p></div></div>    
</body>
</html>