<html>
<head>
<title>How to Use Mapstruct for Nested Protobuf and POJO to Reduce Boilerplate</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何对嵌套的 Protobuf 和 POJO 使用 Mapstruct 来减少样板文件</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-use-mapstruct-for-nested-protobuf-and-pojo-to-reduce-boilerplate-d3698e28c48b?source=collection_archive---------1-----------------------#2022-07-06">https://blog.devgenius.io/how-to-use-mapstruct-for-nested-protobuf-and-pojo-to-reduce-boilerplate-d3698e28c48b?source=collection_archive---------1-----------------------#2022-07-06</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="2b78" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">下面是如何在嵌套的 POJO 上使用 mapstruct，以及 POJO 到嵌套的 protobuf 消息，反之亦然</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj kg"><img src="../Images/36ed13b0e126fc12cfe2056e4fa93325.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7NNs5DHIEMyhL6JN.jpeg"/></div><figcaption class="ko kp gk gi gj kq kr bd b be z dk translated">照片由<a class="ae ks" href="https://www.pexels.com/@tima-miroshnichenko?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">马体·米罗什尼琴科</a>从<a class="ae ks" href="https://www.pexels.com/photo/woman-in-orange-long-sleeve-shirt-standing-beside-woman-in-black-long-sleeve-shirt-5439487/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">佩克斯</a>拍摄</figcaption></figure><p id="b23b" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">让我们看看嵌套映射的问题。以及如何使用<code class="fe lp lq lr ls b"><strong class="kv is"><em class="lt">mapstruct</em></strong></code>映射嵌套的数据对象。</p><p id="4344" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">假设你有下面的结构。根数据对象包含一个集合，每个集合项包含一个集合。</p><p id="50e3" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">你可以用<code class="fe lp lq lr ls b"><a class="ae ks" href="https://mapstruct.org/" rel="noopener ugc nofollow" target="_blank"><strong class="kv is"><em class="lt">mapstruct</em></strong></a></code>来做到这一点。即便如此，<a class="ae ks" href="https://stackoverflow.com/questions/39078941/nested-mapping-in-mapstruct" rel="noopener ugc nofollow" target="_blank">网上几乎没有关于如何做到这一点的指导。此外，在这个过程中，您会遇到一些奇怪的错误。让我们深入探讨如何实现这一点。</a></p></div><div class="ab cl lu lv hv lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ik il im in io"><p id="64e9" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><strong class="kv is"> <em class="lt">我们先从数据结构说起。</em>T15】</strong></p><p id="3ceb" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">下面是源数据对象。第一个是<code class="fe lp lq lr ls b">SourceDTO</code>，作为根级数据对象。接下来是<code class="fe lp lq lr ls b">SourceFirstLevelDTO</code>，在根级对象下的第一级。最后一个是<code class="fe lp lq lr ls b">SourceSecondLevelDTO</code>。</p><p id="630c" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">需要注意的是非根对象的集合。你不仅需要映射根对象，还需要映射它们下面的所有层次。T19】</p><p id="0211" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><code class="fe lp lq lr ls b"><a class="ae ks" href="http://twitter.com/NoArgsConstructor" rel="noopener ugc nofollow" target="_blank">@NoArgsConstructor</a></code>很重要，因为那是<a class="ae ks" href="https://mapstruct.org/" rel="noopener ugc nofollow" target="_blank"> mapstruct </a>所需要的。这样，生成的代码可以调用构造函数并映射所需的字段。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mb mc l"/></div></figure><p id="649c" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">目标数据对象在结构上是相似的。这是它们的样子。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mb mc l"/></div></figure><p id="1f12" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">让我们从根级别的映射器开始。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mb mc l"/></div></figure><p id="44f7" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">这是第一个错误。</p><pre class="kh ki kj kk gu md ls me mf aw mg bi"><span id="c4e1" class="mh mi ir ls b gz mj mk l ml mm">java: No target bean properties found: can’t map Collection element “SourceFirstLevelDTO source” to “FirstLevelDTO target”. Consider to declare/implement a mapping method: “FirstLevelDTO map(SourceFirstLevelDTO value)”.</span></pre><p id="42ea" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">让我们尝试在源映射器中声明该方法。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mb mc l"/></div></figure><p id="6d8c" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">您会得到下面的警告，但是构建会通过。这只是一个警告，但你不会得到预期的结果。二级列表不会被映射。</p><pre class="kh ki kj kk gu md ls me mf aw mg bi"><span id="8f6a" class="mh mi ir ls b gz mj mk l ml mm">java: Unmapped target property: “dataSecondLevel”. Mapping from Collection element “SourceSecondLevelDTO secondLevelDTOList” to “SecondLevelDTO secondLevelDTOList”.</span></pre><p id="9638" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">因此，如果没有第二种方法，您可以启动应用程序，但这是您在目标中得到的结果。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gi gj mn"><img src="../Images/7b7299747411a90996501d72522d743d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JoJepEKn_MygU7xmC2fHiw.png"/></div></div></figure><p id="ecb8" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">所以你可以添加这个方法，测试就会通过。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mb mc l"/></div></figure><p id="cd9b" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">让我感到奇怪的是，这种行为不是错误，而是警告。或许这是有原因的。</p></div><div class="ab cl lu lv hv lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ik il im in io"><p id="af47" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">围绕这个映射器，您还能改进什么？您可以将映射器分成单独的组件。如果您需要在映射器上有更好的粒度，这很好。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mb mc l"/></div></figure><p id="ead8" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">并且生成的映射器将引用所需的嵌套映射器。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mb mc l"/></div></figure></div><div class="ab cl lu lv hv lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ik il im in io"><p id="6d73" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">当你制作粒度图时，你还能改进什么？如果需要反向转换器呢？</p><p id="9203" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">让我们看看如何逆转这种转换。为此，您可以使用<code class="fe lp lq lr ls b"><a class="ae ks" href="https://mapstruct.org/documentation/stable/api/org/mapstruct/InheritInverseConfiguration.html" rel="noopener ugc nofollow" target="_blank">@InheritInverseConfiguration</a></code>。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mb mc l"/></div></figure><p id="c446" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">这是这些变化的结果。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gi gj ms"><img src="../Images/c7f4d8e2ba84d8d0982f185d7d4e1e9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-eEoR4Rt9B9a5OpcgrvsPg.png"/></div></div></figure></div><div class="ab cl lu lv hv lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ik il im in io"><h1 id="cd00" class="mt mi ir bd mu mv mw mx my mz na nb nc jx nd jy ne ka nf kb ng kd nh ke ni nj bi translated">如何映射嵌套的<code class="fe lp lq lr ls b">protobuf</code>消息</h1><p id="29be" class="pw-post-body-paragraph kt ku ir kv b kw nk js ky kz nl jv lb lc nm le lf lg nn li lj lk no lm ln lo ik bi translated"><em class="lt">如果需要将嵌套的 proto 文件映射到 POJO 怎么办？下面是从嵌套的</em> <code class="fe lp lq lr ls b"><em class="lt">protobuf</em></code> <em class="lt">结构映射到 POJO 需要做的事情。</em></p><p id="ab4d" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">下面是定义嵌套结构的原型文件。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mb mc l"/></div></figure><p id="6064" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">除了<code class="fe lp lq lr ls b">dtoList</code>参数之外，似乎与前面的例子相似。因此，如果消息源是 protobuf 消息，并且是一个重复的字段，就需要在字段名后面添加<code class="fe lp lq lr ls b">List</code>。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mb mc l"/></div></figure><p id="13c6" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">让我们来看看逆向转换。再次将为反向配置添加注释。即便如此，您还是会遇到以下问题。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gi gj np"><img src="../Images/4c73ae43c923c2cf376c28b11c4066f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vf_KIJuHMb_htRGvbiXFhQ.png"/></div></div></figure><p id="abae" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">您不能添加到不可修改的集合，因为默认生成会添加到不可修改的<code class="fe lp lq lr ls b">dtoList</code>。<em class="lt">如何解决这个问题？</em></p><p id="1332" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">您需要向映射器添加不同的生成策略。需要的策略是<code class="fe lp lq lr ls b">collectionMappingStrategy = CollectionMappingStrategy.ADDER_PREFERRED</code>。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mb mc l"/></div></figure><p id="cdb7" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">然后映射器将使用加法器而不是 getters。映射器将包含类似下面的代码。</p><pre class="kh ki kj kk gu md ls me mf aw mg bi"><span id="8a2a" class="mh mi ir ls b gz mj mk l ml mm">if ( dto.getSecondLevelDTOList() != null ) { <br/> for ( SecondLevelDTO secondLevelDTOList : dto.getSecondLevelDTOList() ) { <br/> firstLevelDto.addDto( secondLevelProtoMapper.map( secondLevelDTOList ) ); <br/> } <br/>}</span></pre></div><div class="ab cl lu lv hv lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ik il im in io"><p id="8b7a" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><strong class="kv is"> <em class="lt">这就是关于映射嵌套结构的全部内容。本指南展示了如何从源 POJO 映射到目标 POJO。还包括如何在<code class="fe lp lq lr ls b">protobuf</code>和 POJO 结构之间进行映射。</em></strong></p><p id="54aa" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><strong class="kv is"> <em class="lt"> Protobuf 映射有不同的配置，所以不要浏览细节。</em> </strong>本指南为您节省了一些使用<code class="fe lp lq lr ls b">mapstruct</code>映射嵌套结构的时间。</p></div></div>    
</body>
</html>