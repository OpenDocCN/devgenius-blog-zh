<html>
<head>
<title>KeyValueX: Eliminate boilerplate code and make Android projects no longer KV explosion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">KeyValueX:消除样板代码，让 Android 项目不再 KV 爆炸</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/keyvaluex-eliminate-boilerplate-code-and-make-android-projects-no-longer-kv-explosion-3f6fbca31692?source=collection_archive---------7-----------------------#2022-07-26">https://blog.devgenius.io/keyvaluex-eliminate-boilerplate-code-and-make-android-projects-no-longer-kv-explosion-3f6fbca31692?source=collection_archive---------7-----------------------#2022-07-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/a50f96e25b5d005b3b8cdd4b8d48ab55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y5HQeAVj-Y5wIyD7_U93mg@2x.png"/></div></div></figure><h1 id="930d" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">背景</h1><p id="6f70" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">摘自一段深夜独白:</p><p id="4bf3" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">定义几十或几百个键值是很常见的。有更简单的方法吗？</p><p id="ecde" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">这是项目中为数不多的不受控制的地方，呈指数级膨胀，很容易埋下一致性的隐患。</p><p id="04cd" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">每次添加一个新值，都需要考虑 key，get，put，init，5 个位置…</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="a8df" class="mf jw in mb b gy mg mh l mi mj">public class Configs {<br/>  <br/>  ...<br/>    <br/>  private static int TEST_ID;<br/>  <br/>  public final static String KEY_TEST_ID = "KEY_TEST_ID";<br/>  <br/>  public static void setTestId(int id) {<br/>    TEST_ID = id;<br/>    SPUtils.getInstance().put(KEY_TEST_ID, id);<br/>  }<br/>  <br/>  public static int getTestId() {<br/>    return TEST_ID;<br/>  }<br/>  <br/>  public static void initConfigs() {<br/>    TEST_ID = SPUtils.getInstance().getInt(KEY_TEST_ID, 0);<br/>  }<br/>}</span></pre><p id="a40a" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">事后陆续收到改进建议。有朋友提到“科特林房产代理”。</p><p id="3080" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">同时，受“属性代理”的启发，我想出了一个设计，减少了 Java 下的 key、value、get、put、init。</p><h1 id="d1b4" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">1.0 版用法</h1><p id="7054" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">第一步。如果读写 POJOs，您可能需要实现可序列化的接口</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="75f0" class="mf jw in mb b gy mg mh l mi mj">public class User implements Serializable {<br/>  public String title;<br/>  public String content;<br/>}</span></pre><p id="9b72" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">第二步。像往常一样，创建一个项目配置管理类，如 Configs</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="cce9" class="mf jw in mb b gy mg mh l mi mj">//Configs no longer define a bunch of KEY, VALUE constants and get, put, init static methods, Just a piece of KeyValue static variable:<br/>​<br/>public class Configs {<br/>  public final static KeyValueString accountId = new KeyValueString("accountId");<br/>  public final static KeyValueSerializable&lt;User&gt; user = new KeyValueSerializable&lt;&gt;("user");<br/>}</span></pre><p id="ea1a" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">第三步。通过页面上的 get( ) set()方法读写 KeyValue 等。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="9331" class="mf jw in mb b gy mg mh l mi mj">public class MainActivity extends AppCompatActivity {<br/>  ...<br/>          <br/>  //Test persistent write<br/>  Configs.user.set(u);<br/>​<br/>  //Test read<br/>  Log.d("---title", Configs.user.get().title);<br/>  Log.d("---content", Configs.user.get().content);<br/>}</span></pre><h1 id="ca89" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">1.0 版本回顾</h1><p id="ef42" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">KeyValueX v1.0 一出，迅速在群里引起热议。有人提到了多个模块的问题或者重复 KeyNames 的存在，有人提出通过“注释”来消除重复等问题。</p><p id="c958" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">同时我还发现，虽然 KeyValueX 已经消除了 key，value，get，put，init 样板代码，但是仍然存在两个一致性问题:</p><p id="8944" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">最终修饰符和关键字名称的一致性，</p><p id="d7e6" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">— — final 必须用 Java 编写，以免开发人员错误地直接给 KeyValue 赋值:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="1ee2" class="mf jw in mb b gy mg mh l mi mj">public class MainActivity extends AppCompatActivity {<br/>  ...<br/>      <br/>  //Normal use<br/>  Configs.user.set(u);<br/>  <br/>  //misuse<br/>  Configs.user = u;<br/>}</span></pre><p id="8c69" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">那么有的开发者可能会说，我每增加一个 KeyValue，通过 Ctrl/Command + D 复制一行就够了</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="fe9d" class="mf jw in mb b gy mg mh l mi mj">public class Configs {<br/>  public final static KeyValueString accountId = new KeyValueString("accountId");<br/>  public final static KeyValueBoolean isAdult = new KeyValueBoolean("accountId");<br/>}</span></pre><p id="3050" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">诚然这样可以解决最终的一致性问题，但同时也滋生了 KeyName 一致性问题，即记得改 KeyValue 变量名，忘了改 KeyName，而这种疏忽编译器是发现不了的，只有在线发生意外的时候。</p><p id="237e" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">因此，考虑到各种因素，v2.0 采用了标注设计:</p><h1 id="d74e" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">V2.0 使用</h1><p id="58e4" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">第一步。创建 KeyValueGroup 接口</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="9802" class="mf jw in mb b gy mg mh l mi mj">@KeyValueGroup<br/>public interface KeyValues {<br/>  <a class="ae mk" href="http://twitter.com/KeyValue" rel="noopener ugc nofollow" target="_blank">@KeyValue</a> KeyValueInteger days();<br/>  <a class="ae mk" href="http://twitter.com/KeyValue" rel="noopener ugc nofollow" target="_blank">@KeyValue</a> KeyValueString accountId();<br/>  @KeyValue KeyValueSerializable&lt;User&gt; user();<br/>}</span></pre><p id="102d" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">第二步。像往常一样，创建一个项目配置管理类，如 Configs</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="f478" class="mf jw in mb b gy mg mh l mi mj">//Configs do not need to define a bunch of KEY, VALUE constants and get, put, init static methods, Just one KeyValues static variable:<br/>​<br/>public class Configs {<br/>  public final static KeyValues keyValues = KeyValueCreator.create(KeyValues.class);<br/>}</span></pre><p id="2eb4" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">第三步。通过页面上的 get( ) set()方法读写 KeyValue 等。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="3e8b" class="mf jw in mb b gy mg mh l mi mj">public class MainActivity extends AppCompatActivity {<br/>  ...<br/>          <br/>  //Test persistent write<br/>  Configs.keyValues.user().set(u);<br/>​<br/>  //Test read<br/>  Log.d("---title", Configs.keyValues.user().get().title);<br/>  Log.d("---content", Configs.keyValues.user().get().content);<br/>}</span></pre><h1 id="189b" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">V2.0 回顾</h1><p id="406a" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">V2.0 通过接口+注释的设计，一举消除了 final 和 KeyName 的一致性问题，</p><p id="ffdd" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">并且 KeyValues 的实例化是通过无参数反射实现的，这样就不需要在编写代码的过程中专门构建 Impl 类，对于需要几分钟构建一次的庞大项目更加友好。</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ml"><img src="../Images/1bdecd068b2bd4bc05575b6a96046a4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BmteTJqbtl-sEnnW.jpg"/></div></div></figure><p id="c5c4" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">从上图可以看出，无参数反射加载类仅次于 new，所以我对 V2.0 的设计还是比较满意的。已经在 Java 项目中充分使用，欢迎测试反馈。</p><blockquote class="mm mn mo"><p id="49dd" class="kt ku mp kv b kw lr ky kz la ls lc ld mq lt lg lh mr lu lk ll ms lv lo lp lq ig bi translated"><a class="ae mk" href="https://github.com/KunMinX/KeyValueX" rel="noopener ugc nofollow" target="_blank"><em class="in">Github:key valuex</em>T3】</a></p></blockquote><h1 id="5993" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">键值-调度程序</h1><p id="3d88" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">期间有朋友提出可以用动态代理实现代替，即模仿改装，根据接口定义运行时动态生成方法。</p><p id="0e27" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">这消除了对声明性注释的需要，使接口定义更加简洁，如下所示:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="19ac" class="mf jw in mb b gy mg mh l mi mj">public interface KeyValues {<br/>  KeyValueInteger days();<br/>  KeyValueString accountId();<br/>  KeyValueSerializable&lt;User&gt; user();<br/>}</span></pre><p id="49c1" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">同时可以根据适配器模式实现一个转换器，比如转换成 UnPeek-LiveData，这样就可以顺便完成高频操作——更新配置后通知一些页面刷新 UI。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="c591" class="mf jw in mb b gy mg mh l mi mj">public interface KeyValues {<br/>  Result&lt;Integer&gt; days();<br/>  Result&lt;String&gt; accountId();<br/>  Result&lt;User&gt; user();<br/>}<br/>​<br/>Configs.keyValues.days().observer(this, result -&gt; {<br/>  ...<br/>});</span></pre><p id="36e0" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">但是动态代理有一个缺陷，就是类名和方法名不能混淆，否则运行时很难调整对应的方法。</p><p id="47cc" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">所以最后没有考虑动态代理的方法，但是我真的很喜欢转换器的设计。此外，受 Java 后端属性的启发，Dispatcher 设计诞生了</p><p id="f332" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">基于 MVI 调度器实现键值调度器。具体思路是通过 HashMap 来 cohere KeyValue，所以不考虑 Value，getter，setter，init 就声明 Key:</p><h1 id="ac72" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">KV-D 用法</h1><p id="679c" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">1.定义密钥列表</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="b997" class="mf jw in mb b gy mg mh l mi mj">public class Key {<br/>  public final static String TEST_STRING = "test_string";<br/>  public final static String TEST_BOOLEAN = "test_boolean";<br/>}</span></pre><p id="419e" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">2.阅读和写作</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="b244" class="mf jw in mb b gy mg mh l mi mj">//Reading<br/>boolean b = GlobalConfigs.getBoolean(Key.TEST_BOOLEAN);<br/>//Writing<br/>GlobalConfigs.put(Key.TEST_STRING, value);</span></pre><p id="8e99" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">3.可以通知 UI 刷新</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="f920" class="mf jw in mb b gy mg mh l mi mj">GlobalConfigs.output(this, keyValueEvent -&gt; {<br/>  switch (keyValueEvent.currentKey) {<br/>    case Key.TEST_STRING: ... break;<br/>    case Key.TEST_BOOLEAN: ... break;<br/>  }<br/>});</span></pre><p id="144e" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">依靠 MVI 调度程序消息聚合设计，由配置更改引起的任何 UI 刷新都将从这个唯一的出口做出响应。</p><p id="1622" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">目前已更新为<a class="ae mk" href="https://github.com/KunMinX/MVI-Dispatcher" rel="noopener ugc nofollow" target="_blank">MVI-调度员</a>项目。</p><h1 id="50da" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">KV-D 回顾</h1><p id="5aba" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">KV-D 旨在消除学习成本，允许开发人员像使用 SPUtils 一样使用它，同时自动实现快速内存读取，消除样板代码，并避免意外错误。</p><p id="7709" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">但是，KV-D 只适用于 Java 项目。要在 Kotlin 中实现属性代理，它需要基于像 KeyValueX 这样的设计。</p><p id="f860" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">所以 KeyValueX 再次升级:</p><ol class=""><li id="8e0b" class="mt mu in kv b kw lr la ls le mv li mw lm mx lq my mz na nb bi translated">简化注释:只需在接口处将其声明为 KeyValueX 接口，</li><li id="a98e" class="mt mu in kv b kw nc la nd le ne li nf lm ng lq my mz na nb bi translated">自动分组:路径 MD5 以 KeyValueX 接口为单位生成，KeyName 根据 MD5 自动分组。</li><li id="c217" class="mt mu in kv b kw nc la nd le ne li nf lm ng lq my mz na nb bi translated">全局内存快速读取:如 ViewModelProvider，并提供全局内存快速读取。</li></ol><h1 id="7398" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">3.0 版用法</h1><p id="12d8" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">1.创建 keyvaluegroup 接口，例如</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="2a7b" class="mf jw in mb b gy mg mh l mi mj">@KeyValueX<br/>public interface Configs {<br/>  KeyValueInteger days();<br/>  KeyValueString accountId();<br/>  KeyValueSerializable&lt;User&gt; user();<br/>}</span></pre><p id="e0d3" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">2.通过页面上的 get() set()方法读写 keyValue</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="b541" class="mf jw in mb b gy mg mh l mi mj">public class MainActivity extends AppCompatActivity {<br/>  private final Configs configs = KeyValueProvider.get(Configs.class);<br/>  <br/>  ...<br/>​<br/>  //Writing<br/>  configs.user().set(user);<br/>​<br/>  //Reading<br/>  configs.user().get().title;<br/>  configs.user().get().content;<br/>}</span></pre><p id="2e7c" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">代码已经更新到 KeyValueX 项目，请自便。</p><blockquote class="mm mn mo"><p id="1b4d" class="kt ku mp kv b kw lr ky kz la ls lc ld mq lt lg lh mr lu lk ll ms lv lo lp lq ig bi translated"><a class="ae mk" href="https://github.com/KunMinX/KeyValueX" rel="noopener ugc nofollow" target="_blank"> <em class="in"> Github:KeyValueX </em> </a></p></blockquote></div></div>    
</body>
</html>