<html>
<head>
<title>3 Things Working on Solo Projects Won’t Teach You</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">3个人项目中的事情不会教你</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/3-things-working-on-solo-projects-wont-teach-you-44d14f655fb0?source=collection_archive---------24-----------------------#2020-07-14">https://blog.devgenius.io/3-things-working-on-solo-projects-wont-teach-you-44d14f655fb0?source=collection_archive---------24-----------------------#2020-07-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a6de" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">版本控制、测试和Git</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/45eb44db6fbd448708baa95d8cac0e19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5UBwqKj0K3hAHnZS"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">制造者在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae kv" href="https://unsplash.com/@nesabymakers?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> NESA的照片</a></figcaption></figure><p id="f7af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然我从12岁就开始编程和开发应用程序，但本周标志着我在该行业作为软件工程师的第一年。回想我的第一年，我挑出几个我学到的概念。</p><h1 id="b0cc" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">版本控制</h1><p id="e981" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">多年来，我已经构建了几个应用程序(用于黑客马拉松、个人项目，或者只是尝试了解一些工具)。构建这些项目对我理解开发工作流帮助很大，并让我接触了无数的工具和库。然而，由于这些只是个人项目，他们中的大多数都没有投入生产。这样做的非常简单，不需要任何版本支持。</p><p id="ade0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如你们可能已经猜到的那样，软件工程工作并不是这样的。</p><p id="4b81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我了解了为什么版本控制软件是必不可少的，以及围绕它的一些最佳实践。在下一节中，我给出了为什么版本控制是必要的和一些常见策略的鸟瞰图。</p><p id="9d5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于本文，我们来谈谈版本控制软件是如何工作的。假设我们正在开发一个SAAS应用程序，该应用程序有一个客户端应用程序，它依赖于一个后端API。我们的团队负责维护后端API，客户端应用程序由另一个团队开发和维护。</p><blockquote class="mp"><p id="e5f7" class="mq mr iq bd ms mt mu mv mw mx my lr dk translated">因为客户端应用程序对后端应用程序有很强的依赖性，所以我们必须确保这两部分是兼容的。</p></blockquote><p id="c732" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">本质上，我们需要一种方法让客户端应用程序团队知道后端应用程序是否有重大的突破性变化或微小的变化，或者只是一些错误修复，因为这将改变客户端应用程序与后端API的交互方式。</p><blockquote class="ne nf ng"><p id="e40e" class="kw kx nh ky b kz la jr lb lc ld ju le ni lg lh li nj lk ll lm nk lo lp lq lr ij bi translated">这就是语义版本控制发挥作用的地方。</p></blockquote><p id="7b4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在语义版本控制中，版本号可能看起来像</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/74c285901cc651c5c68bdea981ea6f24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*1dJfygx9tHtE52mlpNBoiA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">语义版本格式</figcaption></figure><p id="19de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据语义版本规范:</p><ol class=""><li id="4f94" class="nm nn iq ky b kz la lc ld lf no lj np ln nq lr nr ns nt nu bi translated">当有重大变更时，我们更新主要版本(即，依赖于这个工件的软件也需要更新)</li><li id="5370" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated">当我们以向后兼容的方式添加功能时，我们就更新了次要版本(也就是说，依赖于这个工件的软件几乎不需要修改)。</li><li id="d456" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated">当我们进行向后兼容的错误修复时，我们会更新补丁版本(即，除了错误修复或重构之外，没有任何更改)。</li></ol><h2 id="64b9" class="oa lt iq bd lu ob oc dn ly od oe dp mc lf of og me lj oh oi mg ln oj ok mi ol bi translated">去哪里追踪这些数字？</h2><p id="ed1b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">跟踪这些数字的一种常见方法是使用git标签。每当我们提交时，如果我们想增加版本号，我们就用版本号标记回购协议。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/369eded0d018ca811fc6242544710811.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v8oTzXKrkxjDYQ-QQs3CkA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">标记存储库的命令</figcaption></figure><p id="349d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:许多第三方库会跟踪应用程序的版本，也会标记git repos。</p><p id="80c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你有兴趣了解更多，你可以在他们的网站上了解更多。</p><div class="on oo gp gr op oq"><a href="https://semver.org/" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd ir gy z fp ov fr fs ow fu fw ip bi translated">语义版本2.0.0</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">给定主要版本号。补丁，增加:主要版本当你做不兼容的API改变，次要…</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">semver.org</p></div></div></div></a></div><h1 id="e870" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">测试，测试，更多的测试</h1><p id="c622" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">你们中有多少人为自己的项目编写测试？没有吗？嗯，至少我是这么做的。我从来没有意识到为什么测试是至关重要的，直到我有机会看到一个相当大的代码库(&gt; 60，000 loc)。</p><blockquote class="mp"><p id="4bf1" class="mq mr iq bd ms mt mu mv mw mx my lr dk translated">如果你不喜欢对你的产品进行单元测试，很可能你的客户也不会喜欢测试它。</p></blockquote><p id="21cf" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">当我以前从事一个副业项目时，很容易发现是否有bug，因为这个项目很小，可能只有几个屏幕(如果它是一个web应用程序)，或者几个脚本。通常，当我看到一个bug时，我知道问题出在哪里。</p><p id="c7bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">想象一下，您刚刚接触了一个大型的代码库，但还没有掌握所有的知识来理解整个应用程序和不同的移动部分。如果你不得不添加一个功能或者对现有的方式进行改变，那么要花很长时间才能弄清楚这个功能是否破坏了应用程序的任何其他部分，或者在应用程序的不同部分产生了不必要的副作用。</p><p id="6273" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了一个写得很好的测试套件，一旦你做了所需要的改变，你需要做的就是运行测试，看看其他的一切是否都正常工作，这样可以节省你几个小时的时间。</p><h1 id="5a64" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">饭桶</h1><p id="b602" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">所以，这有点尴尬。当我开始工作的时候，我已经从事版本控制系统的工作有一段时间了，并且认为自己对它相当满意。</p><p id="e412" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我发现了关于<strong class="ky ir">改变基准</strong>及其注意事项。</p><p id="0780" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在开始后不久就遇到了rebasing，当我在学校被一些朋友认为是git-master时，我感到有些尴尬。虽然我听说过重置基础，但我从来没有使用过，因为我从来不觉得有必要。</p><h2 id="b506" class="oa lt iq bd lu ob oc dn ly od oe dp mc lf of og me lj oh oi mg ln oj ok mi ol bi translated">Git重置基础</h2><p id="b6d0" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">单独工作时，使用git rebase还是git merge并不重要。相反，当有许多开发人员<code class="fe oz pa pb pc b"><strong class="ky ir">committing</strong></code>和<code class="fe oz pa pb pc b"><strong class="ky ir">merging</strong></code>时，提交历史会变得混乱，让开发人员在单独的分支和<code class="fe oz pa pb pc b"><strong class="ky ir">rebasing</strong></code> <strong class="ky ir"> </strong>而不是<code class="fe oz pa pb pc b"><strong class="ky ir">committing</strong></code>上工作可能是一个更好的主意。</p><p id="f211" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">重置基础非常类似于合并(这是我一直使用的方法)。它们都将一个分支的变更集成到另一个分支中，例如，将一个特性分支的变更与主分支相结合。</p><blockquote class="mp"><p id="f55b" class="mq mr iq bd ms mt mu mv mw mx my lr dk translated">区别在于如何将更改添加到目标分支。</p></blockquote><p id="6858" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">为了理解其中的区别，让我们首先深入了解git merge是如何工作的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/1526c33134c97d4ecf55f194565dc349.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*0BR01DRjVRqdYNyihxg97g.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Git合并</figcaption></figure><p id="0590" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们将一个特性分支合并到一个基础分支上时，git会合并特性分支的提交并创建一个合并提交。然后，它将这个合并提交添加到基本分支。</p><p id="a919" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，重置基础将生成一个线性git提交历史。Git将把提交附加到基础分支，而不是创建一个合并提交。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/cc0089ce60325eaede9c0ed355745219.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*Xlo7Q18ojm6DgTqZ2yI1mg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Git Rebase</figcaption></figure><p id="27fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么git是怎么做到的呢？</p><p id="4425" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Git从特性分支获取提交，并复制它们；然后将它们应用于主分支机构的负责人。</p><blockquote class="mp"><p id="8faa" class="mq mr iq bd ms mt mu mv mw mx my lr dk translated">使用<code class="fe oz pa pb pc b">rebase</code>命令，您可以获取一个分支上提交的所有更改，并在另一个分支上重放它们。</p></blockquote><p id="af63" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">关于git重置有一些警告，在特定场景中可能不是最佳选择。本文深入解释了rebasing的工作原理、典型的开发人员工作流程以及一些注意事项。</p><div class="on oo gp gr op oq"><a href="https://www.atlassian.com/git/tutorials/merging-vs-rebasing#the-golden-rule-of-rebasing" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd ir gy z fp ov fr fs ow fu fw ip bi translated">合并与重置| Atlassian Git教程</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">git rebase命令以神奇的git巫术而闻名，初学者应该远离它，但是它可以…</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">www.atlassian.com</p></div></div></div></a></div></div><div class="ab cl pf pg hu ph" role="separator"><span class="pi bw bk pj pk pl"/><span class="pi bw bk pj pk pl"/><span class="pi bw bk pj pk"/></div><div class="ij ik il im in"><p id="7229" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些是一些不难学的东西；然而，在从事个人项目时，我从未感觉到深入研究上述任何工具的紧迫性。</p><p id="0549" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我很有兴趣听听其他开发人员是怎么说的，他们说你在参与一个更大团队的项目之前从未接触过这些东西。</p><p id="4405" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下次见。</p></div></div>    
</body>
</html>