<html>
<head>
<title>Design Pattern — Singleton</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计模式—单例</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/design-pattern-singleton-fa0f676a5d16?source=collection_archive---------3-----------------------#2021-01-01">https://blog.devgenius.io/design-pattern-singleton-fa0f676a5d16?source=collection_archive---------3-----------------------#2021-01-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="2dde" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最常见的设计模式——单一模式的详细讨论</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/39c4cda84e40dce93889957e5b5f4628.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kM2rwUplF6owBBUM"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@danist07?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">贝莉儿 DANIST</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a390" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">单体设计模式是最常用的设计模式。这可能是因为它非常容易理解，并且解决了软件工程中的一个重要问题。</p><h1 id="c19e" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">什么是单例设计模式？</h1><p id="6cc2" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">Singleton是四人帮(g of)设计模式之一。这是一个创造性的设计模式，意味着它处理对象的创建。</p><p id="5577" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在一个场景中，当你只需要一个类的对象时，你可以使用Singleton。Singleton将所述类的对象的创建限制为仅一个。</p><p id="edf8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个类的单例实例对于协调整个系统的操作或保证对资源的控制非常重要。Singleton类在应用程序中具有全局访问权限。</p><p id="d93b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在单例设计模式中，类负责创建自己并管理自己的生命周期。该类的唯一实例存储在该类的私有静态成员中。然而，这个实例可以通过一个公共getter在类外使用。</p><h1 id="f7f4" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">例子</h1><p id="8993" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">你可能见过或用过Singleton的例子—</p><ul class=""><li id="e57d" class="mc md in jm b jn jo jr js jv me jz mf kd mg kh mh mi mj mk bi translated">Java——Java中的Runtime &amp; SecurityManager是Java APIs中单例类的例子。以下是您如何访问它们的实例—</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ml mm l"/></div></figure><ul class=""><li id="dda6" class="mc md in jm b jn jo jr js jv me jz mf kd mg kh mh mi mj mk bi translated">数据库管理器、内存缓存或记录器通常是作为单例创建的。它们提供了共享资源的方法——分别是数据库、内存或日志缓冲区。</li><li id="a7e5" class="mc md in jm b jn mn jr mo jv mp jz mq kd mr kh mh mi mj mk bi translated">状态对象模式通常是单一的。</li></ul><h1 id="5a79" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">由Singleton解决的问题</h1><ul class=""><li id="a18d" class="mc md in jm b jn lx jr ly jv ms jz mt kd mu kh mh mi mj mk bi translated">它确保该类只有一个实例</li><li id="bafe" class="mc md in jm b jn mn jr mo jv mp jz mq kd mr kh mh mi mj mk bi translated">可以轻松访问该类的唯一实例</li><li id="bb31" class="mc md in jm b jn mn jr mo jv mp jz mq kd mr kh mh mi mj mk bi translated">单例类可以控制唯一实例的实例化</li><li id="0ed6" class="mc md in jm b jn mn jr mo jv mp jz mq kd mr kh mh mi mj mk bi translated">单例类也可以限制多个实例的创建</li><li id="40f6" class="mc md in jm b jn mn jr mo jv mp jz mq kd mr kh mh mi mj mk bi translated">单例类获得全局访问</li></ul><p id="2327" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这些问题可以通过私有构造函数、公共getter和共享静态实例来解决。详情请继续阅读。</p><h1 id="e821" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">用于单例的UML</h1><p id="a9fb" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">如果没有这个设计模式的UML图，这个讨论将是不完整的</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/e35e50ae66979a5cc618b86d9dbe4ec7.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*RHYaOI1Mpn7-_b2xiizETQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">单例的UML图</figcaption></figure><p id="ffdd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mw"> Client </em>是使用<em class="mw"> SingletonService </em>的类。<em class="mw"> SingletonService </em>有一个共享实例“<em class="mw">实例</em>”。它还有一个公共getter <em class="mw"> getInstance() </em>。它的构造函数是私有的。</p><h1 id="685c" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">创建单例类</h1><p id="428d" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">下面是如何创建一个简单的单例类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Java中的简单实现</figcaption></figure><p id="61f8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是创建单例类的一个非常简单的方法。我已经解释了下面的每一行。请注意，下面列表的编号对应于上面代码中的注释。</p><ul class=""><li id="aa49" class="mc md in jm b jn jo jr js jv me jz mf kd mg kh mh mi mj mk bi translated"><strong class="jm io"> #1 </strong> —这是包的名称。根据您的项目和您使用的包，它可能会有所不同。</li><li id="082e" class="mc md in jm b jn mn jr mo jv mp jz mq kd mr kh mh mi mj mk bi translated"><strong class="jm io"> #2 </strong> —我们在这里指定单例类的名称。在我的例子中，它是<em class="mw"> SingletonClass。</em></li><li id="da1f" class="mc md in jm b jn mn jr mo jv mp jz mq kd mr kh mh mi mj mk bi translated">这里我已经创建了SingletonClass类的一个实例。这个实例存储在一个<em class="mw">私有</em> &amp; <em class="mw">静态</em>成员<em class="mw">共享实例</em>中。成员的名称表明它是一个共享实例。根据具体情况，将共享实例命名为<em class="mw"> sharedInstance </em>或<em class="mw"> sharedLocationManager </em>是一种常见的做法。</li><li id="be86" class="mc md in jm b jn mn jr mo jv mp jz mq kd mr kh mh mi mj mk bi translated"><strong class="jm io"> #4 </strong> —为了确保只创建SingletonClass的一个实例，构造函数被标记为private。如果我们试图实例化这个类，它将抛出一个错误。请参见下面的错误消息。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/a90ab89f3fccd17f7f1b0068108fab6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jO87Am9NsRAVyoG87RQADA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">尝试实例化新对象时出错</figcaption></figure><ul class=""><li id="696b" class="mc md in jm b jn jo jr js jv me jz mf kd mg kh mh mi mj mk bi translated">最后，我们需要一个sharedInstance的公共getter。这是将用于提供单例类实例的方法。请看代码，我们如何使用这个getter来获取Singleton类的实例。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">将Singleton与getSharedInstance()一起使用</figcaption></figure><p id="59c7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面Singleton的实现有个小问题。即使我们不需要Singleton类，该类仍然被初始化。有一个更好的方法来处理这个问题。输入“延迟加载”。</p><h1 id="976e" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">惰性装载</h1><p id="6d7a" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">在注释#3中，我们看到共享的单例实例是在类被加载时创建的。因此，即使您不打算在代码中使用Singleton类，也可以创建共享对象。</p><p id="dc31" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">更好的方法是使用惰性加载，也就是说，直到需要时才创建单例类的实例。参考以下相同的代码-</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">延迟加载的单例实现</figcaption></figure><p id="e21f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您将这段代码与上面的代码进行比较，您会注意到我们没有实例化#3中的类。我们在#5的getSharedInstance()方法中有一个空检查。如果sharedInstance为null，我们实例化该类。这种方法被称为延迟加载，因为除非我们尝试使用它，否则对象不会被初始化。这种方法优于前一种方法。</p><h1 id="ade4" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">私有构造函数</h1><p id="656b" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">如果您看到上面的代码块，您会注意到默认构造函数被标记为private。这是为了确保该类不能从外部实例化。单例类负责自己的初始化。应该只有一个类的实例，该实例应该可以通过公共getter在应用程序中全局访问。私有构造函数阻止我们从外部创建Singleton类的另一个实例。</p><p id="5b01" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，即使使用私有构造函数，也可以使用反射创建单例类的实例。我们可以在以后的帖子中讨论这个问题。</p><h1 id="3f39" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">线程安全</h1><p id="f233" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">当我们的应用程序中只有一个线程时，上面提到的解决方案就足够了。当我们的单例类可以跨线程使用时，我们需要确保我们的类是线程安全的。为了达到这个目的，我们可以在实例化Singleton对象之前添加一个synchronized块。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">线程安全、延迟加载的单例实现</figcaption></figure><p id="7ca6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">getSharedInstance()方法现在被修改，如上所示。请注意，我们在#8处添加了同步块。第二个重要的变化是向静态成员添加了关键字<em class="mw"> volatile </em>。这是因为我们只想确保在访问singleton实例时不会有两个线程试图实例化它。</p><p id="4b1a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果已经创建了单例实例，就不需要再创建了，所有的线程都可以获得这个实例。在没有创建sharedInstance的情况下，一个线程试图创建该实例，我们不希望任何其他线程尝试做同样的事情。这就是为什么我们在检查null之后有一个同步块。</p><p id="50df" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这被称为双重检查单例，因为我们检查null两次，以确保它是线程安全的。这是创建单例类的最常见和被广泛接受的方法。</p><h1 id="93a0" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">什么时候使用Singleton？</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi my"><img src="../Images/61350bd15efb9d74ad5ee86bca274384.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hp2LBV393SuVVjML2wJkIw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">J Lee在Unsplash上的照片</figcaption></figure><p id="0596" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以在以下场景中使用Singleton</p><ul class=""><li id="54f7" class="mc md in jm b jn jo jr js jv me jz mf kd mg kh mh mi mj mk bi translated">与其他设计模式一起使用—单例设计模式与其他设计模式一起使用。例如，Facade是一个重要的设计模式，我们将在后面的文章中看到。它使用Singleton。这是因为通常只需要一个Facade对象。</li><li id="ec8f" class="mc md in jm b jn mn jr mo jv mp jz mq kd mr kh mh mi mj mk bi translated">访问硬件或公共资源——您可能正在访问项目中的特定硬件。通过一个公共类来处理在所述硬件/资源上执行的所有操作可能更有意义。在这些资源上进行初始化可能是一项耗时的任务。这里常见的例子有—数据库、内存缓存、机械臂等。</li><li id="de95" class="mc md in jm b jn mn jr mo jv mp jz mq kd mr kh mh mi mj mk bi translated">全局变量的替换— Singleton优于全局变量。</li><li id="6730" class="mc md in jm b jn mn jr mo jv mp jz mq kd mr kh mh mi mj mk bi translated">对实例的全局访问——有时项目需要存储一些重要的数据，并且可以跨应用程序访问这些数据。Singleton可以帮你做到。Singleton类的一个重要需求是提供对共享实例的全局访问。这通常是使用公共getter来完成的。</li></ul><h1 id="f336" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">单例的问题</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/38b9637ad4b2dc8f6bbcb76923228885.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tfb7zKMZHgMt76iw"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@mrthetrain?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Joshua Hoehne </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><ul class=""><li id="5367" class="mc md in jm b jn jo jr js jv me jz mf kd mg kh mh mi mj mk bi translated">过度使用——由于它的简单和强大，它被过度使用。你应该经常评估这个类是否真的需要是单例的。</li><li id="f4ce" class="mc md in jm b jn mn jr mo jv mp jz mq kd mr kh mh mi mj mk bi translated">缓慢——如果你让每件事都是单一的，它会减慢你的应用程序。</li><li id="c657" class="mc md in jm b jn mn jr mo jv mp jz mq kd mr kh mh mi mj mk bi translated">难以进行单元测试——单件有一个私有的构造函数，并且没有在接口上编程，它们难以进行单元测试。这可能看起来无关紧要，但却是一个大问题。</li><li id="97fa" class="mc md in jm b jn mn jr mo jv mp jz mq kd mr kh mh mi mj mk bi translated">线程安全——如果没有正确实现，单例类可能不是线程安全的。我们上面看到的双重检查实现是一个线程安全的实现。</li><li id="02c4" class="mc md in jm b jn mn jr mo jv mp jz mq kd mr kh mh mi mj mk bi translated">无参数-Singleton不能带参数，如果带参数，它就不是Singleton。它变成了工厂设计模式。在任何时候，你看到你的单例类接受参数，你应该重新思考和评估设计。</li><li id="d6d6" class="mc md in jm b jn mn jr mo jv mp jz mq kd mr kh mh mi mj mk bi translated">违反了单一责任原则——单例类一次做两件事，这违反了单一责任原则。</li><li id="9f4d" class="mc md in jm b jn mn jr mo jv mp jz mq kd mr kh mh mi mj mk bi translated">代码味道——Singleton可能掩盖了一些糟糕的设计。我们应该确定我们是否真的需要一个独生子女。退一步重新评估我们的设计会有所帮助。我们应该看看我们是否能在不使用Singleton的情况下解决同样的问题。</li></ul><h1 id="ae39" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">摘要</h1><ul class=""><li id="64ef" class="mc md in jm b jn lx jr ly jv ms jz mt kd mu kh mh mi mj mk bi translated">保证一个实例。这个单例实例存储在私有静态成员中，但是可以通过公共getter访问。</li><li id="914e" class="mc md in jm b jn mn jr mo jv mp jz mq kd mr kh mh mi mj mk bi translated">易于实施和使用。</li><li id="cfae" class="mc md in jm b jn mn jr mo jv mp jz mq kd mr kh mh mi mj mk bi translated">线程安全。</li><li id="f78c" class="mc md in jm b jn mn jr mo jv mp jz mq kd mr kh mh mi mj mk bi translated">解决一个重要的问题/明确的问题。</li><li id="9e2c" class="mc md in jm b jn mn jr mo jv mp jz mq kd mr kh mh mi mj mk bi translated">经常被滥用/过度使用。</li></ul><h1 id="e4cb" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">作为反模式的Singleton</h1><p id="33f9" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">一些软件工程的绝地认为单一设计模式是一种反模式。他们的论点是，它制造的问题比解决的问题还多。只有一个类对象的限制是不必要的，它使对象是全局的，可以从应用程序的任何地方访问。我们将把批评留到另一篇文章中。</p><h1 id="532f" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="d6a9" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">Singleton很牛逼。它非常强大，非常容易理解和实现。它解决了一个常见的设计问题。</p><p id="4509" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一方面，这是一种被过度使用的设计模式。学会这一点的工程师们会抓住每一个机会去应用它。单体类很难进行单元测试，单体类违反了单一责任原则。</p><p id="c7c1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用这种设计模式有利也有弊。当我们使用它时，我们需要留心。</p></div><div class="ab cl na nb hr nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ig ih ii ij ik"><p id="0f44" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mw">撰写&amp;编辑——维韦克·米塔尔</em></p><div class="nh ni gp gr nj nk"><a href="https://www.linkedin.com/in/vivekmittal06" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd io gy z fp np fr fs nq fu fw im bi translated">Vivek Mittal -首席软件工程师- Nuance Communications | LinkedIn</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">我是一名经验丰富的软件工程师，在软件工程方面有超过10年的经验。我有广泛的…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">www.linkedin.com</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny ks nk"/></div></div></a></div><h1 id="ef8d" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">附加阅读</h1><div class="nh ni gp gr nj nk"><a href="https://stellarsoftwarecompany.medium.com/software-design-patterns-1b41de14ab8b" rel="noopener follow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd io gy z fp np fr fs nq fu fw im bi translated">软件设计模式</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">软件设计模式概述</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">stellarsoftwarecompany.medium.com</p></div></div><div class="nt l"><div class="nz l nv nw nx nt ny ks nk"/></div></div></a></div></div></div>    
</body>
</html>