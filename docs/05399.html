<html>
<head>
<title>Data structures exercise: Array-backed set in Java, with TDD</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据结构练习:Java中的数组支持集，带TDD</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/data-structures-exercise-array-backed-set-in-java-with-tdd-9a54cc06e5e5?source=collection_archive---------0-----------------------#2021-08-03">https://blog.devgenius.io/data-structures-exercise-array-backed-set-in-java-with-tdd-9a54cc06e5e5?source=collection_archive---------0-----------------------#2021-08-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1c416e4c97401882537136b2bb06036e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nF_19ZZE0tJD-lLJ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">皮特·亚历克索普洛斯在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="3e2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">改造现有的数据结构是一个很好的计算机编程练习。今天，我们将使用测试驱动开发(TDD)方法，在Java中创建一个数组支持的可变集合。</p><p id="39e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望你遵循你最喜欢的Java集成开发环境(IDE ),不管是Eclipse、Apache NetBeans、IntelliJ IDEA还是其他什么。</p><p id="8931" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">集合就像一个列表，但是有两个重要的区别:一个集合不能包含重复项，顺序无关紧要。在内部，元素必须有一定的顺序，但是这个顺序对用户来说不重要(如果顺序很重要，他们应该使用不同的数据结构)。</p><p id="6a44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这使得移除集合中的元素比移除列表中的元素容易得多。假设我们想从一个数组支持的列表中移除一个元素。这可能需要向前推进几个要素。</p><p id="9a86" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于数组支持的集合，移动末尾的内容来占据要移除的元素空出的位置可能是一件简单的事情。</p><p id="f8e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数组支持的集合与数组支持的列表的共同之处在于，支持集合或列表的数组会在必要时自动扩展数组容量。我们很快就会谈到具体细节。</p><p id="3ec6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Java开发工具包(JDK)中最著名的set实现可能是<code class="fe lb lc ld le b">HashSet</code>。对于较大的集合，set实现比简单的数组支持的实现更有效，但它也比适合本练习的实现更复杂。</p><p id="06f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，如果您成功地完成了这个练习，那么您应该不会遇到使用散列表进行集合练习的问题。</p><p id="231b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了没有哈希表，我们的数组支持的集合将非常类似于<code class="fe lb lc ld le b">HashSet</code>，但是我们不允许在我们的数组支持的集合中有null元素。</p><h1 id="a07b" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">第一步</h1><p id="1922" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">以下是我们阵列支持的set实现的框架:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="15f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，主构造函数需要一个初始容量参数。如果您像我一样，您更喜欢使用填充默认初始容量的辅助构造函数。</p><p id="8f13" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是默认的初始容量应该是一个实现细节，一个不对外公开的值。出于这个原因，我们至少需要在一个测试中直接使用主构造函数。</p><p id="efec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，让您的IDE为<code class="fe lb lc ld le b">ArrayBackedSet</code>启动一个测试类，使用JUnit 4，如果您的系统上有JUnit 5，最好使用JUnit 5。</p><p id="3ac9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该使用什么元素类型<code class="fe lb lc ld le b">E</code>进行测试？最好是一个具有定义良好的<code class="fe lb lc ld le b">equals()</code>函数的不可变类(来自<code class="fe lb lc ld le b">Object</code>的<code class="fe lb lc ld le b">equals()</code>不算)。如果<code class="fe lb lc ld le b">E</code>实现<code class="fe lb lc ld le b">Comparable</code>就好了。</p><p id="8ac9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我建议用<code class="fe lb lc ld le b">java.time.LocalDateTime</code>。将它的导入添加到测试类<code class="fe lb lc ld le b">ArrayBackedSetTest</code>。</p><p id="ef7e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以使用<code class="fe lb lc ld le b">String</code>，它也有一个<code class="fe lb lc ld le b">equals()</code>超驰并且是<code class="fe lb lc ld le b">Comparable</code>。或者我们不必局限于单一类型，我们可以有一些使用一种类型的测试和其他使用其他类型的测试。</p><p id="bfba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我也开始喜欢在测试类中有一个私有的<code class="fe lb lc ld le b">java.util.Random</code>实例，但是如果你愿意的话，你可以一直使用<code class="fe lb lc ld le b">Math.random()</code>。</p><p id="7147" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">add()</code>函数的工作方式应该是，如果元素被成功添加到集合中，它返回true，如果它已经在集合中，则返回false(因此没有必要再次添加它)。</p><p id="e087" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是第一个测试。如果您使用的是JUnit 4，请务必添加“<code class="fe lb lc ld le b">public</code>”。</p><pre class="mi mj mk ml gt mo le mp mq aw mr bi"><span id="d1c4" class="ms lg iq le b gy mt mu l mv mw">    @Test<br/>    void testAdd() {<br/>        ArrayBackedSet&lt;LocalDateTime&gt; set = new ArrayBackedSet&lt;&gt;();<br/>        LocalDateTime dateTime = LocalDateTime.now();<br/>        String msg = "Should be able to add " + dateTime.toString()<br/>                + " to set of times";<br/>        assert set.add(dateTime) : msg;<br/>    }</span></pre><p id="63e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它应该会失败，因为现在<code class="fe lb lc ld le b">add()</code>除了返回false之外什么也不做。我们简单地通过让<code class="fe lb lc ld le b">add()</code>返回true来通过这个测试，而不需要对内部<code class="fe lb lc ld le b">elements</code>数组做任何事情。</p><pre class="mi mj mk ml gt mo le mp mq aw mr bi"><span id="7a53" class="ms lg iq le b gy mt mu l mv mw">    public boolean add(E element) {<br/>        return <strong class="le ir">true</strong>;<br/>    }</span></pre><p id="f69e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此时不需要重构。</p><p id="780b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我之前提到过，out set不允许null，不像<code class="fe lb lc ld le b">java.util</code>中的集合。但是尝试添加null应该抛出null指针异常还是应该简单地返回false？</p><p id="b4b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你决定并相应地编写测试。称这个测试为“添加拒绝空值”如果您简单地返回false，您可以通过这个小小的修改来通过测试:</p><pre class="mi mj mk ml gt mo le mp mq aw mr bi"><span id="fc0a" class="ms lg iq le b gy mt mu l mv mw">    public boolean add(E element) {<br/>        return <strong class="le ir">element != null</strong>;<br/>    }</span></pre><p id="effb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我知道这感觉很傻。在每一个TDD周期，我们试图只做通过测试所必需的最少的工作。这不是因为我们懒，而是因为我们想找到最简单、最优雅的解决方案。</p><p id="b4db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">趁我还没忘记，你应该写一份否定能力的测试。主构造函数应该通过抛出适当的异常来拒绝负容量。如果您使用的是JUnit 5，请使用<code class="fe lb lc ld le b">assertThrows()</code>。</p><h1 id="48e3" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">检查元素是否已经在集合中</h1><p id="0fd3" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">在这一点上，我们还不需要改变<code class="fe lb lc ld le b">add()</code>来实际添加任何东西到集合中，就像下一个测试不需要我们修改<code class="fe lb lc ld le b">contains()</code>来实际遍历后备数组寻找指定的元素。</p><p id="8bae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我要你写下一个测试。它应该实例化一个新的<code class="fe lb lc ld le b">ArrayBackedSet&lt;E&gt;</code>(您选择类型<code class="fe lb lc ld le b">E</code>)，添加一个元素，然后断言集合包含该元素。</p><p id="4de9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以通过改变布尔函数返回的内容来通过这个测试。</p><pre class="mi mj mk ml gt mo le mp mq aw mr bi"><span id="202f" class="ms lg iq le b gy mt mu l mv mw">    public boolean contains(E element) {<br/>        return <strong class="le ir">true</strong>;<br/>    }</span></pre><p id="4f86" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一个测试实际上需要我们重写<code class="fe lb lc ld le b">add()</code>来添加元素到集合中，重写<code class="fe lb lc ld le b">contains()</code>来检查指定的元素是否在集合中。</p><p id="acd0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该测试应该向集合中添加一些元素，然后断言该集合不包含从未添加的元素。我认为这个测试在断言任何东西之前向集合中添加多个元素是很重要的。</p><p id="9b8b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，使用<code class="fe lb lc ld le b">LocalDate</code>作为我们的<code class="fe lb lc ld le b">E</code>类型，这个不包含测试可以将过去日期的<code class="fe lb lc ld le b">LocalDate</code>对象添加到一个集合中，然后断言该集合不包含明天日期的<code class="fe lb lc ld le b">LocalDate</code>实例。</p><p id="fef0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在要做的事情似乎很清楚了。但是我们不要急于求成:因为我们还没有对重复元素的测试，<code class="fe lb lc ld le b">add()</code>不应该检查要添加的元素是否已经在集合中。</p><p id="24af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我建议我们添加一个私有整数字段，<code class="fe lb lc ld le b">nextUp</code>，它将指向<code class="fe lb lc ld le b">elements</code>中准备好新值的下一个数组槽。它当然会被初始化为0。我们这样重写<code class="fe lb lc ld le b">add()</code>:</p><pre class="mi mj mk ml gt mo le mp mq aw mr bi"><span id="d1be" class="ms lg iq le b gy mt mu l mv mw">    public boolean add(E element) {<br/>        <strong class="le ir">this.elements[this.nextUp] = element;<br/>        this.nextUp++;</strong><br/>        return true;<br/>    }</span></pre><p id="da33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而<code class="fe lb lc ld le b">contains()</code>这样:</p><pre class="mi mj mk ml gt mo le mp mq aw mr bi"><span id="40f4" class="ms lg iq le b gy mt mu l mv mw">    public boolean contains(E element) {<br/>        <strong class="le ir">boolean flag = false;<br/>        int index = 0;<br/>        while (!flag &amp;&amp; index &lt; this.nextUp) {<br/>            flag = element.equals(this.elements[index]);<br/>            index++;<br/>        }</strong><br/>        return <strong class="le ir">flag</strong>;<br/>    }</span></pre><p id="f836" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这应该通过不包含测试，以及先前的测试。这里至少有一个重构的机会:“<code class="fe lb lc ld le b">flag</code>”不是很有意义。也许应该是“<code class="fe lb lc ld le b">found</code>”…</p><p id="13d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">ArrayBackedSetTest</code>上可能有两个警告。一个可能是因为我们还没有使用来自<code class="fe lb lc ld le b">Assertions</code>的任何东西(或者<code class="fe lb lc ld le b">Assert</code>如果你正在使用JUnit 4)。或者你在消极能力测试中。</p><p id="5c1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个警告是因为我们在Add测试中的断言依赖于一个“不纯”的函数(<code class="fe lb lc ld le b">add()</code>现在改变了<code class="fe lb lc ld le b">elements</code>数组和<code class="fe lb lc ld le b">nextUp</code>字段)。</p><p id="8fcc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要消除该警告，只需将<code class="fe lb lc ld le b">set.add(dateTime)</code>提取到一个局部变量中，并对其进行断言。如果你想不出更好的名字，就叫它“T1”。</p><p id="831e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你们中的一些人可能想知道为什么我们的<code class="fe lb lc ld le b">contains()</code>函数有一个<code class="fe lb lc ld le b">E</code>类型的参数，而不是<code class="fe lb lc ld le b">Object</code>，就像我们在JDK的模型一样。</p><p id="d294" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那只是因为向后兼容。在Java 1.5中增加泛型之前，Java就有集合了。</p><p id="9bdb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于我们正在为这个练习重新编写<code class="fe lb lc ld le b">ArrayBackedSet&lt;E&gt;</code>，我们不会受到向后兼容Java 1.4或更早版本的限制。</p><p id="7c1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我想编写一个测试来尝试添加重复的元素。但是我认为，在我们编写测试之前，我们需要让<code class="fe lb lc ld le b">size()</code>正常工作。</p><p id="0011" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以首先编写一个测试，向集合中添加一些不同的元素，跟踪有多少，然后断言<code class="fe lb lc ld le b">set.size()</code>返回多少。</p><p id="8533" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了通过测试，我们只需将<code class="fe lb lc ld le b">size()</code>中的1改为<code class="fe lb lc ld le b">this.nextUp</code>。</p><pre class="mi mj mk ml gt mo le mp mq aw mr bi"><span id="89cf" class="ms lg iq le b gy mt mu l mv mw">    public int size() {<br/>        return <strong class="le ir">this.nextUp</strong>;<br/>    }</span></pre><p id="6308" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我认为现在我们已经拥有了编写重复元素测试所需的一切。如果一个元素已经在集合中，<code class="fe lb lc ld le b">add()</code>应该返回false，而<code class="fe lb lc ld le b">size()</code>应该返回与调用<code class="fe lb lc ld le b">add()</code>之前相同的数字。</p><pre class="mi mj mk ml gt mo le mp mq aw mr bi"><span id="8b57" class="ms lg iq le b gy mt mu l mv mw">    @Test<br/>    void testNoDuplicateElements() {<br/>        ArrayBackedSet&lt;String&gt; set = new ArrayBackedSet&lt;&gt;();<br/>        String msg = "Should not be able to add same element twice";<br/>        set.add(msg);<br/>        int expected = set.size();<br/>        boolean reAddFlag = set.add(msg);<br/>        assert !reAddFlag : msg;<br/>        int actual = set.size();<br/>        assertEquals(expected, actual);<br/>    }</span></pre><p id="03ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让这个测试通过的最简单的方法是通过If语句给<code class="fe lb lc ld le b">add()</code>添加一个<code class="fe lb lc ld le b">contains()</code>检查。</p><pre class="mi mj mk ml gt mo le mp mq aw mr bi"><span id="9fd4" class="ms lg iq le b gy mt mu l mv mw">    public boolean add(E element) {<br/>        <strong class="le ir">if (this.contains(element)) {<br/>            return false;<br/>        }</strong><br/>        this.elements[this.nextUp] = element;<br/>        this.nextUp++;<br/>        return true;<br/>    }</span></pre><p id="3768" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你们中的一些人可能更喜欢用If-Else，这很好。对于那些不记得重新格式化键盘快捷键的人来说，敲几次空格键来修复缩进并不太麻烦。</p><p id="6a87" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也许有一些聪明的方法可以在没有If语句的情况下通过这个测试。如果你知道这样做的方法，而且不是一个愚蠢的解决方法，请在评论中告诉我。</p><h1 id="e348" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">根据需要扩展容量</h1><p id="4536" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">假设后备数组有20个槽，都是满的，并且有一个调用来添加第21个元素。将数组大小加倍可能太多了。只添加一个阵列插槽可能太少了。</p><p id="0780" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这表明折衷为3/2，根据需要进行整数舍入。例如，如果后备阵列有16个插槽，而需要第17个，则将阵列容量增加到24个，而不是32个。</p><p id="9bc1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果以后需要，阵列容量将增加到36、54、81，然后是121或122，具体取决于243/2是向上取整还是向下取整，以此类推。</p><p id="5dea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于下一个测试，使用主构造函数来指定初始容量。那么测试应该添加足够的不同元素来填充初始容量。接下来是关键时刻:测试为这个集合增加了另一个元素。</p><p id="247b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为测试失败的<code class="fe lb lc ld le b">ArrayIndexOutOfBoundsException</code>编写一个Catch子句。或者，如果您使用JUnit 5或TestNG，请使用<code class="fe lb lc ld le b">assertDoesNotThrow()</code>。这个测试将会失败，因为<code class="fe lb lc ld le b">add()</code>将会导致一个异常被抛出。</p><p id="119c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果这是C++，IDE可能会警告我们，但是试图访问最后一个索引之外的数组的确切效果将是不可预测的。</p><p id="5614" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如你所知，在Java中，数组的大小在初始化后是固定的，不能扩展。但是，将一个数组的内容复制到另一个容量更大的数组，然后将原来的数组指针改为指向新的数组，这是完全有效的。</p><p id="876b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我建议我们在一个名为<code class="fe lb lc ld le b">expandCapacity()</code>的私人程序中进行。然后<code class="fe lb lc ld le b">add()</code>检查容量并在必要时调用<code class="fe lb lc ld le b">expandCapacity()</code>。</p><pre class="mi mj mk ml gt mo le mp mq aw mr bi"><span id="b6dc" class="ms lg iq le b gy mt mu l mv mw">    public boolean add(E element) {<br/>        if (this.contains(element)) {<br/>            return false;<br/>        }<br/>        <strong class="le ir">if (this.nextUp == this.elements.length) {<br/>            this.expandCapacity();<br/>        }</strong><br/>        this.elements[this.nextUp] = element;<br/>        this.nextUp++;<br/>        return true;<br/>    }</span></pre><p id="9f2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我把<code class="fe lb lc ld le b">expandCapacity()</code>的写作留给你。提示:IntelliJ IDEA可能会建议您使用<code class="fe lb lc ld le b">System.arraycopy()</code>。NetBeans可能会给你同样的提示。</p><p id="6bf5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦你让<code class="fe lb lc ld le b">expandCapactiy()</code>工作，我们所有的测试都应该通过，并且<code class="fe lb lc ld le b">ArrayBackedSetTest</code>应该显示所有的绿色。</p><p id="645c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是<code class="fe lb lc ld le b">ArrayBackedSet</code>可能会显示四个警告，如果你使用IntelliJ的话，因为我们还没有编写像<code class="fe lb lc ld le b">remove()</code>这样的函数(NetBeans不会警告你未使用的公共函数)。</p><h1 id="a093" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">从集合中移除元素</h1><p id="014e" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我继续编写了一个测试来删除集合中实际存在的元素。但后来我意识到我有点超前了。</p><p id="ad47" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你小心确保它正确地工作，而不是走得太远，删除功能实际上是相当复杂的。</p><p id="4c39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我希望您编写的下一个测试是实例化一个新集合，但不向该集合添加任何元素的测试。然后，测试试图删除适当类型的一些元素，这应该是不可能的，因为集合中根本没有元素，所以<code class="fe lb lc ld le b">remove()</code>返回false。</p><p id="c1a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个测试应该会失败，因为现在它返回true。让它通过只需要我们对<code class="fe lb lc ld le b">ArrayBackedSet</code>做一点小小的改变:</p><pre class="mi mj mk ml gt mo le mp mq aw mr bi"><span id="373f" class="ms lg iq le b gy mt mu l mv mw">    public boolean remove(E element) {<br/>        return <strong class="le ir">false</strong>;<br/>    }</span></pre><p id="c595" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们编写测试来删除集合中实际存在的元素。我也把这个留给你。只要确保第一次失败是因为正确的原因。</p><p id="aff2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我写的测试感觉有点长。这将是一个好主意，使一个单独的私有函数，使一个集合与元素被删除添加在一些伪随机位置。</p><p id="2f09" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更好的是，使用<code class="fe lb lc ld le b">Integer</code>作为<code class="fe lb lc ld le b">E</code>类型，包含从0到某个伪随机<em class="mx"> m </em>的整数。然后选择一个至少为0但不大于<em class="mx"> m </em>的伪随机<em class="mx"> n </em>，去掉<em class="mx"> n </em>。断言<code class="fe lb lc ld le b">remove(</code> <em class="mx"> n </em> <code class="fe lb lc ld le b">)</code>返回真，<code class="fe lb lc ld le b">contains(</code> <em class="mx"> n </em> <code class="fe lb lc ld le b">)</code>返回假，<code class="fe lb lc ld le b">size()</code>返回比之前少一。</p><p id="c451" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你不喜欢在一个测试中有三个断言，那就继续做三个独立的测试……实际上，我越想越觉得这个测试应该分成三个独立的测试:</p><ol class=""><li id="c9a0" class="my mz iq kf b kg kh kk kl ko na ks nb kw nc la nd ne nf ng bi translated">首先编写一个测试，当对集合中存在的元素调用时，断言<code class="fe lb lc ld le b">remove()</code>返回true。通过让<code class="fe lb lc ld le b">remove()</code>简单地返回<code class="fe lb lc ld le b">this.contains(element)</code>来通过这个测试。</li><li id="f8a5" class="my mz iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">接下来编写一个测试来断言，在对存在于集合中的元素调用<code class="fe lb lc ld le b">remove()</code>之后，该元素不再存在于集合中，因此<code class="fe lb lc ld le b">contains()</code>返回false。通过用null替换后备数组中的元素来通过这个测试(但是要注意:根据您编写<code class="fe lb lc ld le b">contains()</code>的方式，这可能会导致null指针异常)。</li><li id="97f1" class="my mz iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">最后，编写一个测试来断言成功移除一个元素会将集合的大小减少1。只需在适当的位置添加行“<code class="fe lb lc ld le b">this.nextUp--;</code>”即可通过该测试。</li></ol><p id="82fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我意识到了另一种超越自己的方法:不需要在后备数组中移动任何元素就可以通过上述三个测试。</p><p id="9a2d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这可能导致这样的问题，即删除一个元素会无意中导致另一个元素的意外删除。</p><p id="8067" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着我们需要编写一个测试，断言在删除一个元素之后，添加到集合中的所有其他元素到目前为止仍然在集合中。</p><p id="8cea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将该测试称为“仅删除目标元素”最简单的<code class="fe lb lc ld le b">E</code>类型也可能是<code class="fe lb lc ld le b">Integer</code>。</p><p id="15d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们没有超越自己，这个新的测试第一次应该会失败，如果我们按照我上面概述的三个步骤编写了<code class="fe lb lc ld le b">remove()</code>。</p><p id="d356" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过这个测试的一个方法是将被移除元素之后的所有元素在后备数组中向前移动一个槽。这对于数组支持的列表来说是合适的。</p><p id="7b68" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是请记住，顺序与集合中的调用方无关。调用者关心的是一个元素是否在集合中，而不是这个元素在后备数组中的位置。</p><p id="694d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，通过这个测试最直接的方法就是用后备数组中的最后一个元素覆盖要删除的元素的数组槽。</p><p id="911a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果要从{1，2，3，4，5}中删除3，可以将后备数组改为{1，2，5，4，null}，当然<code class="fe lb lc ld le b">this.nextUp</code>调整为指向4而不是null。</p><p id="110a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">实际上，后备数组可以改为{1，2，5，4，5}，并且仍然通过所有测试，只要<code class="fe lb lc ld le b">this.nextUp</code>被调整为指向4而不是第二个5。这是一个测试无法检查的实现细节，因为<code class="fe lb lc ld le b">this.elements</code>拥有私有访问权限。</p><p id="85fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我已经为<code class="fe lb lc ld le b">remove()</code>准备了大约四十行测试。如果我在一次测试中完成<code class="fe lb lc ld le b">remove()</code>的所有测试，可能会有30行代码。</p><p id="9fdc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，一般来说，我们应该更担心被测试的类中的长单元，而不是进行测试的类中的长单元。</p><p id="f49d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我的第一份<code class="fe lb lc ld le b">remove()</code>工作草案大概有二十行。</p><pre class="mi mj mk ml gt mo le mp mq aw mr bi"><span id="87d4" class="ms lg iq le b gy mt mu l mv mw">    public boolean remove(E element) {<br/>        <strong class="le ir">boolean found = false;<br/>        int index = 0;<br/>        while (!found &amp;&amp; index &lt; this.nextUp) {<br/>            found = element.equals(this.elements[index]);<br/>            index++;<br/>        }<br/>        if (found) {<br/>            index--;<br/>            int lastIndex = --this.nextUp;<br/>            if (index &lt; lastIndex) {<br/>                this.elements[index] = this.elements[lastIndex];<br/>            }<br/>            this.elements[lastIndex] = null;<br/>            return true;<br/>        } else {</strong><br/>            return false;<br/>        <strong class="le ir">}</strong><br/>    }</span></pre><p id="c0d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有的测试现在都应该通过了。这是做一些重构的最佳时机。重构的机会应该很明显。如果不明显，复习<code class="fe lb lc ld le b">contains()</code>。</p><p id="cfea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">contains()</code>和<code class="fe lb lc ld le b">remove()</code>都遍历<code class="fe lb lc ld le b">elements</code>数组，寻找特定的元素。这种重复并不完全是一字不差的，因为差异是非常表面的。</p><p id="c406" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该创建一个私有函数，称之为类似于<code class="fe lb lc ld le b">indexOf()</code>的东西，它的工作方式很像<code class="fe lb lc ld le b">String</code>的<code class="fe lb lc ld le b">indexOf()</code>函数。如果在后备数组中找到指定的元素，<code class="fe lb lc ld le b">indexOf()</code>返回索引。否则，它返回1。</p><p id="3a40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们重写<code class="fe lb lc ld le b">contains()</code>和<code class="fe lb lc ld le b">remove()</code>来使用<code class="fe lb lc ld le b">indexOf()</code>。重写后的<code class="fe lb lc ld le b">contains()</code>可以放在一行中，但是三行更清晰也更简洁。</p><p id="1c92" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用私有的<code class="fe lb lc ld le b">indexOf()</code>也会使<code class="fe lb lc ld le b">remove()</code>变得更短，但不会更短。</p><pre class="mi mj mk ml gt mo le mp mq aw mr bi"><span id="2853" class="ms lg iq le b gy mt mu l mv mw">    public boolean remove(E element) {<br/>        <strong class="le ir">int index = this.indexOf(element);<br/>        </strong>if <strong class="le ir">(index == -1)</strong> {<strong class="le ir"><br/>            </strong>return false;<strong class="le ir"><br/>        </strong>} else {<strong class="le ir"><br/>            </strong>int lastIndex = --this.nextUp;<br/>            if (index &lt; lastIndex) {<br/>                this.elements[index] = this.elements[lastIndex];<br/>            }<br/>            this.elements[lastIndex] = null;<br/>            return true;<strong class="le ir"><br/>        }</strong><br/>    }</span></pre><p id="c678" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">调用私有函数而不是内联可能会花费我们几分之一毫秒的时间。在我看来，清晰的收益和随后进行更改的便利是值得的。</p><p id="0e00" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然也许我们可以通过确保<code class="fe lb lc ld le b">indexOf()</code>只迭代到<code class="fe lb lc ld le b">nextUp - 1</code>，而不是<code class="fe lb lc ld le b">elements.length - 1</code>来重新获得那一毫秒的分数。</p><p id="524a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在运行所有测试，确保重构没有破坏任何东西。</p><h1 id="619e" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">检查集合是否为空</h1><p id="4ab2" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">数学家处理的大多是无限集合和空集。作为程序员，我们主要处理有限的集合，但是我们也处理空集，比如当搜索没有结果时。</p><p id="ea01" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">java.util.HashSet</code>有<code class="fe lb lc ld le b">isEmpty()</code>功能是有道理的，<code class="fe lb lc ld le b">ArrayBackedSet&lt;E&gt;</code>也是，只是我们的还不行。会的，在我们为它写了一个测试之后。</p><pre class="mi mj mk ml gt mo le mp mq aw mr bi"><span id="c11a" class="ms lg iq le b gy mt mu l mv mw">    @Test<br/>    void testIsEmpty() {<br/>        System.out.println("isEmpty");<br/>        ArrayBackedSet&lt;java.sql.Clob&gt; set = new ArrayBackedSet&lt;&gt;();<br/>        String msg = "Newly created set should be empty";<br/>        assert set.isEmpty() : msg;<br/>    }</span></pre><p id="fa2a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">元素类型<code class="fe lb lc ld le b">E</code>对于这个特定的测试并不重要，因为集合将从空开始并保持为空。所以我用了<code class="fe lb lc ld le b">Clob</code>。</p><p id="9f76" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个测试应该会失败。你知道让它通过的诀窍。写下一个测试的诀窍，不是空测试，我也留给你们。</p><p id="7db4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">选择<code class="fe lb lc ld le b">E</code>类型。添加一个<code class="fe lb lc ld le b">E</code>的实例就足以使集合不为空。如果你使用<code class="fe lb lc ld le b">assert</code>而不是JUnit的<code class="fe lb lc ld le b">assertFalse()</code>，确保在断言中否定<code class="fe lb lc ld le b">set.isEmpty()</code>。</p><p id="c6cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">测试失败了，你已经知道如何让它通过。如果没有，可以很快搞清楚。</p><h1 id="d6be" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">清理布景</h1><p id="897f" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">现在我们在<code class="fe lb lc ld le b">ArrayBackedSet</code>中应该只有一个警告，警告告诉我们不使用<code class="fe lb lc ld le b">clear()</code>(至少在IntelliJ IDEA中是这样)，只有一个做注释，也涉及<code class="fe lb lc ld le b">clear()</code>。</p><p id="348c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我把为<code class="fe lb lc ld le b">clear()</code>写测试的任务交给你了。基本思想是实例化一个集合，用一些元素填充它，断言它不为空，然后调用<code class="fe lb lc ld le b">clear()</code>并断言该集合现在为空，其大小为0。</p><p id="66f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到目前为止，我们编写的方法是，为了通过这个测试，将<code class="fe lb lc ld le b">nextUp</code>重置为0就足够了。</p><pre class="mi mj mk ml gt mo le mp mq aw mr bi"><span id="ec2a" class="ms lg iq le b gy mt mu l mv mw">    public void clear() {<br/>        <strong class="le ir">this.nextUp = 0;</strong><br/>    }</span></pre><p id="4060" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是这样做有一个潜在的严重问题:如果后备数组没有被新元素完全覆盖，我们的set实现可能会保留对对象的引用，否则垃圾收集器会丢弃这些对象，因为没有对这些对象的其他引用。</p><p id="4e24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">清除操作应该将后备数组中的每个非null元素设置为null，这样就可以安全地丢弃不再需要的对象，从而释放可能对程序的其余部分有用的内存。</p><p id="a742" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我仍然相信<code class="fe lb lc ld le b">elements</code>应该是<code class="fe lb lc ld le b">ArrayBackedSet</code>的私有物。尽管如此，还是有办法为<code class="fe lb lc ld le b">ArrayBackedSetTest</code>提供查询后备数组的方法，比如某种包私有函数，它可以揭示后备数组是否有任何非空值。</p><p id="d028" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我对它的感觉还不够强烈，不能真正写它，所以我要继续写下去，加入一些行来清除后备数组。</p><pre class="mi mj mk ml gt mo le mp mq aw mr bi"><span id="2187" class="ms lg iq le b gy mt mu l mv mw">    public void clear() {<br/>        <strong class="le ir">for (int i = 0; i &lt; this.nextUp; i++) {<br/>            this.elements[i] = null;<br/>        }</strong><br/>        this.nextUp = 0;<br/>    }</span></pre><p id="8457" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">清理后备阵刚好到<code class="fe lb lc ld le b">nextUp</code>就停下来就够好了。Java的一个优点是Java虚拟机会将对象数组初始化为空。</p><p id="a2c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，如果您决定编写包私有后备数组查询函数，它可能会遍历整个后备数组。无论容量是否扩大，所需的数量始终可用，如<code class="fe lb lc ld le b">elements.length</code>。</p><h1 id="4041" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">比较两组</h1><p id="8395" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">也许扩展阵列容量这件事一开始看起来令人生畏。但是现在，多亏了TDD，它变得非常简单，并不那么有趣。</p><p id="9e90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">至少在我看来，更有趣的是平等测试。但是也许有了TDD，这也会变得非常容易。</p><p id="7eee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果两个集合具有相同的元素，则这两个集合是相等的，而不管支持数组中元素的顺序如何，并且两个集合中的任何元素都不包含在另一个集合中。</p><p id="491c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，假设一组颜色由红色、绿色和蓝色组成，另一组颜色由蓝色、绿色和红色组成。支持数组肯定是不同的，但它们包含相同的元素。</p><p id="9aea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是Java，我们还必须处理这样的可能性，即<code class="fe lb lc ld le b">equals()</code>的<code class="fe lb lc ld le b">obj</code>参数可能是不同的类型，或者甚至可能是null。现在不要向我抱怨，向二十五年前的太阳微系统公司抱怨吧。</p><p id="51fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">至于引用等式优化(<code class="fe lb lc ld le b">this == obj</code>)，你可能觉得对于今天更快的计算机来说没有必要。即便如此，对它进行测试也无妨，即使您的实现并没有使用它。</p><p id="e753" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望您在<code class="fe lb lc ld le b">ArrayBackedSet</code>中放入一个总是返回false的<code class="fe lb lc ld le b">equals()</code>存根，以及一个总是为所有<code class="fe lb lc ld le b">ArrayBackedSet</code>实例返回0或其他常量的<code class="fe lb lc ld le b">hashCode()</code>覆盖。</p><p id="6393" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我希望你编写引用相等(<code class="fe lb lc ld le b">assert x.equals(x)</code>)、不等于null ( <code class="fe lb lc ld le b">assert x != null</code>)和不等于另一个类(<code class="fe lb lc ld le b">assert x != y</code>，其中<code class="fe lb lc ld le b">y</code>是任何其他类的实例)的测试。</p><p id="2a82" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我知道你的IDE可以生成<code class="fe lb lc ld le b">equals()</code>和<code class="fe lb lc ld le b">hashCode()</code>覆盖(至少如果它是主要的IDE之一的话)。</p><p id="971e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样一个生成的覆盖对于引用相等测试、不等于空测试和不等于另一个类测试来说应该很好。但是它可能需要被编辑以通过我们接下来要写的测试。</p><p id="9dda" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我重申，支持数组中的顺序对于集合相等比较来说并不重要。集合{1，3，5，7，9，2，4，6，8，10}与集合{1，2，3，4，5，6，7，8，9，10}相同。</p><p id="7415" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是如果一个集合比另一个集合多一个元素，这两个集合就不可能相等，因为一个集合至少有一个元素是另一个集合没有的。</p><p id="e7f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这表明在逐个比较元素之前，<code class="fe lb lc ld le b">equals()</code>应该检查集合大小。编写一个测试，创建两个集合，一个比另一个稍大，并断言两个集合不相等。</p><p id="93a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果ide生成的<code class="fe lb lc ld le b">equals()</code>覆盖比较了<code class="fe lb lc ld le b">this</code>和<code class="fe lb lc ld le b">obj</code>的<code class="fe lb lc ld le b">nextUp</code>字段，那么它应该通过不同大小集合测试。</p><p id="25af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它还可能通过一个测试，创建两个相同大小和相同类型的集合，但是具有不同的元素，并断言这两个集合不相等，尽管它们大小相同。</p><p id="68e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您没有使用IDE生成的覆盖，一定要进行相同大小但不同的元素测试。例如，你可以用一百个随机整数组成集合<em class="mx"> A </em>，用另外一百个整数组成集合<em class="mx"> B </em>。</p><p id="9165" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就像，可能在一个循环中，测试添加数字<em class="mx"> n </em>来设置<em class="mx"> A </em>和数字<em class="mx"> n </em>来设置<em class="mx"> B </em>，例如，第一次迭代可能会将508添加到<em class="mx"> A </em>，将508添加到<em class="mx"> B </em>。然后，当循环完成时，<em class="mx"> A </em>和<em class="mx"> B </em>具有相同的大小，但是它们应该具有不同的元素(当然，除了在伪随机数发生器只给出零的极不可能的情况下)。</p><p id="8ea6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使相同大小但不同元素通过测试的最简单方法可能是使用<code class="fe lb lc ld le b">java.util.Arrays</code>中的静态<code class="fe lb lc ld le b">equals()</code>。这可能就是IDE生成的覆盖所使用的。</p><p id="85ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">IDE生成的覆盖可能无法通过下一个测试，因为支持数组会有所不同:</p><pre class="mi mj mk ml gt mo le mp mq aw mr bi"><span id="db95" class="ms lg iq le b gy mt mu l mv mw">@Test<br/>    void testEquals() {<br/>        System.out.println("equals");<br/>        ArrayBackedSet&lt;Character&gt; alphabetSet <br/>                = new ArrayBackedSet&lt;&gt;();<br/>        ArrayBackedSet&lt;Character&gt; pangramSet <br/>                = new ArrayBackedSet&lt;&gt;();<br/>        char[] alphabet = "abcdefghijklmnopqrstuvwxyz"<br/>                .toCharArray();<br/>        for (char letter : alphabet) {<br/>            alphabetSet.add(letter);<br/>        }<br/>        char[] pangram <br/>                = "The quick brown fox jumps over the lazy dog"<br/>                .replace(<strong class="le ir">" "</strong>, <strong class="le ir">""</strong>).toLowerCase().toCharArray();<br/>        for (char gram : pangram) {<br/>            pangramSet.add(gram);<br/>        }<br/>        assertEquals(alphabetSet, pangramSet);<br/>    }</span></pre><p id="376d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">alphabetSet</code>的支持数组应该有ASCII (Unicode Latin-1)顺序的字母。但是<code class="fe lb lc ld le b">pangramSet</code>的支持数组应该有相同的字母，但是顺序不同:t，h，e，q，u，I，c，k，b，r，o，w，n，f，x，j，m，p，s，v，l，a，z，y，d，g。</p><p id="41a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在考虑了几种通过测试的不同方法后，我决定创建一个私有的后备数组匹配函数。该函数只是遍历一个数组，检查给定的元素是否包含在另一个后备数组中，一旦在另一个数组中找不到匹配的元素就停止。</p><p id="acfb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过将它标记为private，我们可以确保只有当两个集合的大小匹配时才调用它。这可能不是最优雅或最有效的解决方案。也许在重构过程中，或者在代码审查时，我会想到一个更好的主意。</p><p id="34d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">两个空集应该被认为相等吗？也许只有当一个的类型<code class="fe lb lc ld le b">E</code>与另一个的类型<code class="fe lb lc ld le b">E</code>匹配时。但是由于类型<code class="fe lb lc ld le b">E</code>在运行时不可用，似乎没有办法检查这一点。我想知道他们在Scala中是如何做到的？我得调查一下…</p><h1 id="7a60" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">其他集合操作</h1><p id="953e" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我决定在这个练习中省略三个重要的集合运算:并集、交集和补集，只是因为类型系统的问题。</p><p id="43e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">两个或多个集合的联合就是将集合合并成一个集合(当然，两个或多个集合中的元素在联合的集合中只出现一次)。例如{G，B-平坦，D}、{C，E，G，B-平坦}和{F，A，C}的并集是{A，B-平坦，C，D，E，F，G}。</p><p id="67ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">两个集合的交集是两个集合中出现的所有元素的集合。比如{G，B-平，D}和{C，E，G，B-平}的交集是{ B-平，G}。而{B-flat，G}和{F，A，C}的交集就是空集(因为这两个集合没有共同的元素)。</p><p id="3e8d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">交集是一种交换操作，这意味着无论在哪个set实例上调用它，结果都是相同的(或者，如果您选择将它实现为静态函数，则参数的给定顺序也是相同的)。</p><p id="11ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个集合和另一个集合的补集是另一个集合中不在第一个集合中的所有元素的集合。这是<em class="mx">而不是</em>一个交换运算。比如来自{G，B-flat，D}的{C，E，G，B-flat}的补码是{D}，来自{C，E，G，B-flat}的{G，B-flat，D}的补码是{C，E}(也可能是反过来，我对那种东西很困惑)。</p><p id="25d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为类型<code class="fe lb lc ld le b">E</code>在运行时不可用，所以我们可能不得不满足于union是<code class="fe lb lc ld le b">ArrayBackedSet&lt;Object&gt;</code>的实例而不是最窄的适用类型这样的操作结果。</p><p id="370e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以把这些集合操作看作是额外的奖励，不管你是否能找到一种方法使结果的<code class="fe lb lc ld le b">E</code>类型尽可能的窄。</p><h1 id="5a92" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论，现在</h1><p id="fc54" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">看起来我们就要结束了。如果你遇到任何问题，你可以查阅你的IDE中的<code class="fe lb lc ld le b">java.util.HashSet</code>源码，或者<a class="ae kc" href="https://github.com/Alonso-del-Arte/toy-examples" rel="noopener ugc nofollow" target="_blank">我的玩具实例GitHub库</a>中的<code class="fe lb lc ld le b">collections</code>包。</p><p id="2d10" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我们没有提供遍历集合的方法。这实际上是一个完全不同的练习，在我写完这篇文章后，我写了另一篇关于的文章<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/data-structures-exercise-making-a-collection-available-to-javas-for-each-loops-126e6cf8a877">。</a></p><p id="f4dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我要多做这些练习。也许我接下来应该做一个不可变的数据结构。我欢迎评论中的建议。</p></div></div>    
</body>
</html>