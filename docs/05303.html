<html>
<head>
<title>A mistake lots of React developers make almost everyday when using hooks.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">许多React开发人员在使用钩子时几乎每天都会犯的一个错误。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/a-mistake-lots-of-react-developers-make-almost-everyday-when-using-hooks-6b17779bbaa4?source=collection_archive---------1-----------------------#2021-07-16">https://blog.devgenius.io/a-mistake-lots-of-react-developers-make-almost-everyday-when-using-hooks-6b17779bbaa4?source=collection_archive---------1-----------------------#2021-07-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/6a0cdcd246d5b2e43edfd370f85fbbcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Kd4qlemJfaFXz-A-"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">贾斯汀·克里斯恩在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="3c92" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak">背景</strong></h1><p id="0ad0" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">当用现代的React(用钩子)编码时，UseEffect可以非常强大，因为它监视组件中特定的状态/属性变量，并且每当它的一个依赖项改变时触发。</p><p id="7a90" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">现在，这也可能是棘手和低效的，因为如果该效果改变了状态变量，则该效果所做的更改很可能会重新呈现组件。所以开发人员在使用这些钩子时需要小心，避免不必要的钩子使用。</p></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><h1 id="80e8" class="ka kb in bd kc kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx bi translated">问题</h1><p id="875d" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">如果我们有一个简单的计数器应用程序，除了count等于0的情况之外，每点击两次鼠标，count就增加1，我们希望在单击一次鼠标时增加1，我们决定使用一个在每次鼠标单击时触发的useEffect。</p></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><p id="5375" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">让我们来看看下面的使用效果</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="35a6" class="mw kb in ms b gy mx my l mz na">const [count, setCount] = useState(0);<br/>const [mouseClickCount, setMouseClickCount] = useState(0);</span><span id="c78a" class="mw kb in ms b gy nb my l mz na">useEffect(() =&gt; {</span><span id="9beb" class="mw kb in ms b gy nb my l mz na"> if(mouseClickCount === 2 &amp;&amp; count !== 0) {<br/>     setCount(count + 1 );<br/> } else if(mouseClickCount === 1 &amp;&amp; count === 0) {<br/>     setCount(count + 1 );<br/> }</span><span id="fed3" class="mw kb in ms b gy nb my l mz na">}, <strong class="ms io">[count, mouseClickCount]</strong>);</span><span id="8701" class="mw kb in ms b gy nb my l mz na"><br/>...</span></pre><p id="07ee" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">你看到这里的问题了吗？</p><p id="316e" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">你猜对了，每次这个useEffect改变count，它都会再次触发自己，因为count在它的dependancies数组中。这可能会导致性能问题，并且在某些情况下，如果mouseClickCount在挂钩完成之前没有重置为0，那么if语句中的条件可能会再次满足，并且它会增加计数的值，从而导致意外的结果。</p><p id="5ff6" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">此外，如果我们没有在这一点上发现问题，我们就会编写不必要的逻辑来避免在不应该调用setCount时调用它。</p><p id="1d52" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">对于这个非常具体的例子，我们在useEffect中有几行代码，但在其他用例中，我们可能有更多的代码。假设我们想将useEffect内部的逻辑(或部分逻辑)取出，放入useEffect调用的独立函数(或多个函数)中:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="975c" class="mw kb in ms b gy mx my l mz na">const [count, setCount] = useState(0);<br/>const [mouseClickCount, setMouseClickCount] = useState(0);</span><span id="9035" class="mw kb in ms b gy nb my l mz na">const checkCountAndMouseClicks = useCallback(() =&gt; {<br/>if(mouseClickCount === 2 &amp;&amp; count !== 0) {<br/>     setCount(count + 1);<br/> } else if(mouseClickCount === 1 &amp;&amp; count === 0) {<br/>     setCount(count + 1);<br/> }<br/>},[]);</span><span id="0984" class="mw kb in ms b gy nb my l mz na">useEffect(() =&gt; {<br/> checkCountAndMouseClicks();<br/>}, <strong class="ms io">[mouseClickCount]);</strong></span><span id="922b" class="mw kb in ms b gy nb my l mz na">...</span></pre><p id="7593" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">您在前面的代码片段中发现什么错误了吗？我们的计数将始终等于1！这是为什么呢？</p><p id="134e" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">好吧，useCallback对函数的包装进行了内存化，包括任何变量引用，所以当内存化计数等于0时，每次调用checkCountAndMouseClicks时，count都会是0，即使它的值可能不是0。</p></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><p id="29f6" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">我们如何解决这个问题？</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="40e7" class="mw kb in ms b gy mx my l mz na">const [count, setCount] = useState(0);<br/>const [mouseClickCount, setMouseClickCount] = useState(0);</span><span id="6439" class="mw kb in ms b gy nb my l mz na">const checkCountAndMouseClicks = useCallback(() =&gt; {<br/>if(mouseClickCount === 2 &amp;&amp; count !== 0) {<br/>     setCount(count + 1);<br/> } else if(mouseClickCount === 1 &amp;&amp; count === 0) {<br/>     setCount(count + 1);<br/> }<br/>},<strong class="ms io">[count]</strong>);</span><span id="69a2" class="mw kb in ms b gy nb my l mz na">useEffect(() =&gt; {<br/> checkCountAndMouseClicks();<br/>}, <strong class="ms io">[mouseClickCount]);</strong></span><span id="6375" class="mw kb in ms b gy nb my l mz na">...</span></pre><p id="f771" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">太神奇了！现在，每当我们单击时，将触发useEffect，当第二次单击时，它将使计数增加1，这将导致使用最新的计数引用对check count和MouseClicks进行新的函数记忆。</p></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><h1 id="2317" class="ka kb in bd kc kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx bi translated">但是我们还没有到那一步</h1><p id="a206" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">让我们仔细看看我们为解决上述两个问题做了什么，我注意到的一件事是，当我们可以用最少的实现获得这个功能时，我们坚持使用钩子。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="9a68" class="mw kb in ms b gy mx my l mz na">const [count, setCount] = useState(0);<br/>const [mouseClickCount, setMouseClickCount] = useState(0);</span><span id="f3db" class="mw kb in ms b gy nb my l mz na">const checkCountAndMouseClicks = useCallback(() =&gt; {<br/>if(mouseClickCount === 2 &amp;&amp; count !== 0) {<br/>     setCount(count + 1);<br/> } else if(mouseClickCount === 1 &amp;&amp; count === 0) {<br/>     setCount(count + 1);<br/> }<br/>},<strong class="ms io">[count]</strong>);</span><span id="9b61" class="mw kb in ms b gy nb my l mz na">const DomElementOnClick = (e) =&gt; {<br/> e.preventDefault();<br/> const updatedClickCount = mouseClickCount + 1;<br/> setMouseClickCount(updatedClickCount);<br/> checkCountAndMouseClicks();<br/>}<strong class="ms io">;</strong></span><span id="c9b7" class="mw kb in ms b gy nb my l mz na">...</span></pre><p id="43ea" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">通过这种设置，我们可以准确地实现我们所需要的，而不会让React向我们的应用捆绑包中添加一堆不必要的代码。</p></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><h1 id="44b4" class="ka kb in bd kc kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx bi translated"><strong class="ak">结论</strong></h1><p id="1d68" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">陷入这个问题是很常见的，因为开发人员往往会忘记钩子的用途。它们(在很大程度上)应该是捕捉事件发生时触发的逻辑，一旦你遵循这种思维定势，你就可以避免在不应该使用它们的时候使用它们。如果像onClick这样的事件侦听器正在做这项工作，我们不需要创建一个useEffect来包含属于事件处理程序的逻辑。</p></div></div>    
</body>
</html>