<html>
<head>
<title>“Matrix Diagonal Sum”: LeetCode Challenge</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">“矩阵对角和”:LeetCode 挑战</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/matrix-diagonal-sum-leetcode-challenge-a6b49f1a7390?source=collection_archive---------7-----------------------#2021-04-11">https://blog.devgenius.io/matrix-diagonal-sum-leetcode-challenge-a6b49f1a7390?source=collection_archive---------7-----------------------#2021-04-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/b09e7c7946ffb0d1c7509d854b65415d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*DENauUixUf2DS-VfgKCXlA.png"/></div></figure><figure class="js jt ju jv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gh gi jr"><img src="../Images/dd6eaa6397088ffd67cecaf42bdd1714.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*77Sh4GhJ29wveLh_eRviuw.png"/></div></div><figcaption class="ka kb gj gh gi kc kd bd b be z dk translated">描述</figcaption></figure><figure class="js jt ju jv gt jo gh gi paragraph-image"><div class="gh gi ke"><img src="../Images/cc59d487827c9501dc4e350934db3ab2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*nsy-TtFzNTtfGDMjSpncZA.png"/></div><figcaption class="ka kb gj gh gi kc kd bd b be z dk translated">示例 1</figcaption></figure><figure class="js jt ju jv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gh gi kf"><img src="../Images/dac160032c240c2b156f22b459cacef4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*h7UKVnAVa34_1jBWhHroJA.png"/></div></div><figcaption class="ka kb gj gh gi kc kd bd b be z dk translated">实施例 2 和 3</figcaption></figure><p id="22c3" class="pw-post-body-paragraph kg kh in ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ig bi translated">好吧，让我们来谈谈如何解决这个问题。给定一个大小为 N 乘 N 的数组，让我们从中切取一个 X，并将这些数字相加。</p><p id="8d66" class="pw-post-body-paragraph kg kh in ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ig bi translated">当解决这样的问题时，我喜欢在不同的例子中寻找相似之处，并找到一种模式，我们可以用同样的方式来解决它们。</p><p id="0a43" class="pw-post-body-paragraph kg kh in ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ig bi translated">我马上注意到的一件事是，如果数组的高度/长度是奇数，我们将只获取中间值(在本例中是值 5)一次，并将它添加到我们的总和中。然而，如果数组的长度是偶数，我们可以制作对角线切片，并将它们添加到总和<strong class="ki io"/><em class="le"/>中，而不用担心意外复制中间的项目。</p><p id="3015" class="pw-post-body-paragraph kg kh in ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ig bi translated">现在我们已经认识到了这一点，我们可以开始考虑如何从我们的输入数组中得到一个 X。我将通过向您展示我解决这个问题的第一种方法来开始这个解决方案，然后我们将开始寻找优化我们代码的速度/存储复杂性的方法。</p><p id="d3d4" class="pw-post-body-paragraph kg kh in ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ig bi translated">因此，由于我们的输入数组大小为 N 乘 N(甚至长度和高度)，我们可以创建四个指针变量，每个变量都从数组的外部角开始，并随着每次迭代逐渐向中间递增。</p><figure class="js jt ju jv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gh gi lf"><img src="../Images/d9a390ce159d8e0d28c521d874539cc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9XzVAvQvsPZwz6NzmJQ5cg.png"/></div></div><figcaption class="ka kb gj gh gi kc kd bd b be z dk translated">第一次迭代</figcaption></figure><p id="8c29" class="pw-post-body-paragraph kg kh in ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ig bi translated">这里我们有四个不同的变量。在代码中，我们实际上将使用 2 个变量来跟踪每个 指针的<strong class="ki io">行</strong>和<strong class="ki io">列</strong>的位置，因为它朝着中间移动。我们将继续简化，但是首先，我们将使用这些变量来跟踪我们的行和列。</p><figure class="js jt ju jv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gh gi lg"><img src="../Images/9f09e616194d93a930e1eaa92934e8f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fw7i8NDaJhjQJMsYJtO3Yg.png"/></div></div><figcaption class="ka kb gj gh gi kc kd bd b be z dk translated">第二次迭代</figcaption></figure><p id="172e" class="pw-post-body-paragraph kg kh in ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ig bi translated">在这个奇怪的数组示例中，随着变量向中间移动，它们最终会落在共享的中间值上，我们希望确保只将它添加到总和中一次，而不是 4 次。</p><figure class="js jt ju jv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gh gi lh"><img src="../Images/21713ec298d67cb6ed181d99aa7e4955.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mphRVDMIsjsGuYz-E9Ukcw.png"/></div></div><figcaption class="ka kb gj gh gi kc kd bd b be z dk translated">最终迭代(第三次)</figcaption></figure><h2 id="8141" class="li lj in bd lk ll lm dn ln lo lp dp lq kr lr ls lt kv lu lv lw kz lx ly lz ma bi translated"><strong class="ak">偶例</strong></h2><figure class="js jt ju jv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gh gi mb"><img src="../Images/71a3017045f521dc12f164e20841d72d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5BLT2O4WtOr2TsVAAgCrSQ.png"/></div></div><figcaption class="ka kb gj gh gi kc kd bd b be z dk translated">第一次迭代</figcaption></figure><figure class="js jt ju jv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gh gi mc"><img src="../Images/49137932a25249ae8e2885d03eb614ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H7ZJdbmiVjwMVjlOOGOfrA.png"/></div></div><figcaption class="ka kb gj gh gi kc kd bd b be z dk translated">最终迭代(第二次)</figcaption></figure><p id="b711" class="pw-post-body-paragraph kg kh in ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ig bi translated">在这个偶数的例子中，当它们到达中间时，它们有自己的值，并且可以毫无问题地将它们加到总和中。</p><h1 id="aaff" class="md lj in bd lk me mf mg ln mh mi mj lq mk ml mm lt mn mo mp lw mq mr ms lz mt bi translated">代码</h1><p id="f643" class="pw-post-body-paragraph kg kh in ki b kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz my lb lc ld ig bi translated">好吧，我们来谈谈代码。</p><p id="473a" class="pw-post-body-paragraph kg kh in ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ig bi translated">通过查看示例，我认为我们要做的第一件事是考虑给我们一个只有一项的数组的可能性(顶部的示例 3)。为了避免这个问题，让我们检查数组的长度是否为 1。如果是这样，我们就退货吧。</p><figure class="js jt ju jv gt jo gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/8bc7e8c6fe09fdfd05a0e8874ccb4501.png" data-original-src="https://miro.medium.com/v2/resize:fit:542/format:webp/1*5M-kCgTykbxq9v7i1DLS3g.png"/></div></figure><p id="f392" class="pw-post-body-paragraph kg kh in ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ig bi translated">否则，让我们做一些工作。</p><p id="3695" class="pw-post-body-paragraph kg kh in ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ig bi translated">所以我们将使用一些变量来跟踪一切。这些是我们的变量。</p><figure class="js jt ju jv gt jo gh gi paragraph-image"><div class="gh gi na"><img src="../Images/6e9c3f0eb9d7799be3025c751f773bac.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*wdMn-AuYixoWFmcN4AABaA.png"/></div></figure><h1 id="6606" class="md lj in bd lk me mf mg ln mh mi mj lq mk ml mm lt mn mo mp lw mq mr ms lz mt bi translated"><strong class="ak">循环</strong></h1><p id="49a5" class="pw-post-body-paragraph kg kh in ki b kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz my lb lc ld ig bi translated">因为我们每次迭代都将所有指针移向中间，所以我们只需要做一半长度的迭代就可以到达中间。我们的 for 循环条件将看起来像</p><blockquote class="nb nc nd"><p id="113f" class="kg kh le ki b kj kk kl km kn ko kp kq ne ks kt ku nf kw kx ky ng la lb lc ld ig bi translated"><strong class="ki io">if(I&lt;math . floor(mat . length/2))</strong></p></blockquote><p id="a4ec" class="pw-post-body-paragraph kg kh in ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ig bi translated">我们使用 Math.floor()的原因是因为我们只想要长度除以多少的地板(在奇数的情况下)。</p><p id="4f8c" class="pw-post-body-paragraph kg kh in ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ig bi translated">好吧，逻辑是这样的。</p><p id="f6ba" class="pw-post-body-paragraph kg kh in ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ig bi translated">查看每个变量，将该索引的值添加到总和中，并相应地增加变量的索引。</p><p id="5e07" class="pw-post-body-paragraph kg kh in ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ig bi translated">这是每个人的样子</p><figure class="js jt ju jv gt jo gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/00ef67a1cf9e947fd61091c77cfbca5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*3xMi2bDm8t0gZSctmcqU9Q.png"/></div></figure><p id="2ca4" class="pw-post-body-paragraph kg kh in ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ig bi translated">好的，如果我们在这一点返回 sum，我们将得到正确的长度为<em class="le">偶数</em>的数组的<strong class="ki io"> sum </strong>，但是我们只迭代到 Math.floor(length / 2 ),所以在最后，我们需要检查我们正在处理的数组是否是奇数。</p><p id="b800" class="pw-post-body-paragraph kg kh in ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ig bi translated">如果是，让我们取中间值并把它加到我们的和中。应该是这样的。</p><figure class="js jt ju jv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gh gi ni"><img src="../Images/982ffa77c047e3eb021730752ca4687f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LISBVAPIPqCMU5U91yaJmA.png"/></div></div><figcaption class="ka kb gj gh gi kc kd bd b be z dk translated">添加中间值</figcaption></figure><p id="9075" class="pw-post-body-paragraph kg kh in ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ig bi translated">太好了。因此，在这一点上，一切都正常运行。这个工作的速度很快，但是我们在这里占用了相当多的空间。这是我们可以开始创造性地使用变量的地方。</p><p id="7558" class="pw-post-body-paragraph kg kh in ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ig bi translated">原因是，如果我仔细观察，我会发现这些变量和其他变量的值是一样的。看一下代码，看看你是否注意到了它。这些值彼此以相同的速率增加或减少。</p><p id="a04d" class="pw-post-body-paragraph kg kh in ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ig bi translated">因此，我们可以将相似的组合在一起，从而节省大量空间。</p><p id="680c" class="pw-post-body-paragraph kg kh in ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ig bi translated">首先，我看到<strong class="ki io">第一行</strong>和<strong class="ki io">第一列</strong>从 0 开始，每次迭代递增 1。对于<strong class="ki io"> fourthColumn </strong>和<strong class="ki io"> fourthRow 也是如此:</strong>它们从 length-1 开始，每次迭代减 1。</p><p id="6c05" class="pw-post-body-paragraph kg kh in ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ig bi translated">因此，让我们创建一个名为<strong class="ki io"> inc </strong>和<strong class="ki io"> dec </strong>的变量来保存这些值。</p><figure class="js jt ju jv gt jo gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/0433d1a753086df141bca9ddddc2a4e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*SwgbxToUBKsl-rBAiasuMw.png"/></div><figcaption class="ka kb gj gh gi kc kd bd b be z dk translated">介绍 inc 和 dec</figcaption></figure><p id="07e1" class="pw-post-body-paragraph kg kh in ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ig bi translated">因此，我们所做的是用 inc 和 dec 替换这些变量。在循环中，我们+=求和的值，并在迭代的最后增加<strong class="ki io"> inc </strong>并减少<strong class="ki io"> dec </strong> <em class="le">。</em></p><p id="0483" class="pw-post-body-paragraph kg kh in ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ig bi translated">这个管用，而且更好。但是，我们仍然可以做得更好。</p><p id="dee9" class="pw-post-body-paragraph kg kh in ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ig bi translated">让我们用<strong class="ki io"> inc </strong>表示所有的增量值，用<strong class="ki io"> dec </strong>表示所有的减量值。只需<strong class="ki io"> <em class="le">确保</em> </strong>不要更改<strong class="ki io"> inc </strong>或<strong class="ki io"> dec </strong>的值，直到记录完这些值。</p><figure class="js jt ju jv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gh gi nk"><img src="../Images/86a37be2f81d5d19c460cf25abb586ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eTu97bkZxT9mnv8N-i3RaA.png"/></div></div><figcaption class="ka kb gj gh gi kc kd bd b be z dk translated">2 可变解决方案</figcaption></figure><p id="ae8a" class="pw-post-body-paragraph kg kh in ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ig bi translated">看看我们摆脱了多少代码！我必须说，我们以前的方法可读性更好，但这个解决方案节省了更多的空间，因为我们只使用两个变量来跟踪一切。</p><p id="d86f" class="pw-post-body-paragraph kg kh in ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ig bi translated">现在，只是为了好玩，让我们看看是否可以减少到只有一个变量。</p><h1 id="d77a" class="md lj in bd lk me mf mg ln mh mi mj lq mk ml mm lt mn mo mp lw mq mr ms lz mt bi translated">变量 inc 和 dec 有关系。</h1><p id="8a7b" class="pw-post-body-paragraph kg kh in ki b kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz my lb lc ld ig bi translated">它们都是彼此的反义词。为了得到相邻值的位置，我们只需要做一些数学运算。</p><p id="9023" class="pw-post-body-paragraph kg kh in ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ig bi translated">我们可以使用单个变量“距离”,并按照 inc 的工作方式将其递增 1。</p><p id="10b4" class="pw-post-body-paragraph kg kh in ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ig bi translated">为了得到相反的结果，我们只需要做</p><blockquote class="nb nc nd"><p id="facf" class="kg kh le ki b kj kk kl km kn ko kp kq ne ks kt ku nf kw kx ky ng la lb lc ld ig bi translated">[材料长度-距离-1]</p></blockquote><figure class="js jt ju jv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gh gi nl"><img src="../Images/7cb4cb0a4d1d3f09d46874d98cbeaba2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ISDFpNKEZqQAcUgI5cl0vQ.png"/></div></div><figcaption class="ka kb gj gh gi kc kd bd b be z dk translated">一元解</figcaption></figure><figure class="js jt ju jv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gh gi nm"><img src="../Images/98bc425c3b4417884354066ecfdaf26f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nna5puifY8Ala6ATEk69Og.png"/></div></div></figure><figure class="js jt ju jv gt jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/b09e7c7946ffb0d1c7509d854b65415d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*DENauUixUf2DS-VfgKCXlA.png"/></div></figure><p id="d766" class="pw-post-body-paragraph kg kh in ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ig bi translated">这是最终结果。</p><h1 id="8381" class="md lj in bd lk me mf mg ln mh mi mj lq mk ml mm lt mn mo mp lw mq mr ms lz mt bi translated">我们所做的。</h1><p id="d927" class="pw-post-body-paragraph kg kh in ki b kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz my lb lc ld ig bi translated">我们使用 4 个指针来跟踪我们在这个二维数组中的位置。</p><p id="9bf4" class="pw-post-body-paragraph kg kh in ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ig bi translated">然后我们通过用 inc 和 dec 替换我们的 4 个递增和递减变量来减少代码。</p><p id="a0a1" class="pw-post-body-paragraph kg kh in ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ig bi translated">最后，我们将其减少到一个变量，以最大化存储效率。这是一个有趣的挑战！敬请关注更多类似内容。</p></div></div>    
</body>
</html>