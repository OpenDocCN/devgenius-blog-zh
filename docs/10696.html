<html>
<head>
<title>DevOps in Go — Program Execution Order</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go 中的 DevOps 程序执行顺序</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/devops-in-go-program-execution-order-1329f4617aba?source=collection_archive---------2-----------------------#2022-11-23">https://blog.devgenius.io/devops-in-go-program-execution-order-1329f4617aba?source=collection_archive---------2-----------------------#2022-11-23</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="2736" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">Go bootcamp 系列中的 DevOps</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/37c2fb1e8e06683b4afe067412a85817.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8T2J5O3KT0U8uBsmPHgHQA.png"/></div></div></figure><p id="146b" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">通常在一个 Go 程序中有多个 Go 包，执行顺序在这些包之间切换。像 Python(和其他编程语言)一样，Go 也有自己的入口函数:<code class="fe lo lp lq lr b">main</code>函数。</p><p id="bcdd" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">在本文中，我们将通过<code class="fe lo lp lq lr b">main</code>函数并逐步展开，帮助您理解 go 程序的执行顺序。</p><h1 id="1a04" class="ls lt ir bd lu lv lw lx ly lz ma mb mc jx md jy me ka mf kb mg kd mh ke mi mj bi translated">主要功能</h1><p id="baad" class="pw-post-body-paragraph ks kt ir ku b kv mk js kx ky ml jv la lb mm ld le lf mn lh li lj mo ll lm ln ik bi translated">Go 语言中有一个特殊的函数:主包中的<code class="fe lo lp lq lr b">main</code>函数，它是用户级的入口函数。Go 程序的执行逻辑将在该函数中根据其调用顺序展开。</p><p id="4364" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">让我们看一个例子:</p><pre class="kh ki kj kk gu mp lr mq bn mr ms bi"><span id="75fe" class="mt lt ir lr b be mu mv l mw mx">package main<br/>​<br/>func main() {<br/>    // User logic<br/>    ... ...<br/>}</span></pre><p id="ebe6" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">可以看到函数原型非常简单，没有参数，没有返回值。而且 Go 语言<strong class="ku is">要求</strong>可执行程序的主包必须定义<code class="fe lo lp lq lr b">main</code>函数，否则 Go 编译器会报错。</p><p id="7630" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">另外值得一提的是，除了<code class="fe lo lp lq lr b">main</code>包，其他包也可以有自己的函数或方法，命名为<code class="fe lo lp lq lr b">main</code>。但是根据 Go 的可见性规则(以小写字母开头的标识符是非导出的标识符)，非 main 包中的自定义 main 函数仅限于在包中使用。以下代码片段来自非主包:</p><pre class="kh ki kj kk gu mp lr mq bn mr ms bi"><span id="877b" class="mt lt ir lr b be mu mv l mw mx">package pkga<br/>  <br/>import "fmt"<br/>​<br/>func Main() {<br/>    main()<br/>}<br/>​<br/>func main() {<br/>    fmt.Println("main func for pkga")<br/>}</span></pre><p id="4477" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">上述<code class="fe lo lp lq lr b">pkga</code>中定义的<code class="fe lo lp lq lr b">main()</code>只能在<code class="fe lo lp lq lr b">pkga</code>包中看到。</p><h1 id="3401" class="ls lt ir bd lu lv lw lx ly lz ma mb mc jx md jy me ka mf kb mg kd mh ke mi mj bi translated">初始化功能</h1><p id="c2cd" class="pw-post-body-paragraph ks kt ir ku b kv mk js kx ky ml jv la lb mm ld le lf mn lh li lj mo ll lm ln ik bi translated">尽管<code class="fe lo lp lq lr b">main</code>函数是用户级入口函数，但它不是第一个被执行的函数。Go 还有一个特殊功能叫做<code class="fe lo lp lq lr b">init</code>，在<code class="fe lo lp lq lr b">main</code>之前运行。例如:</p><pre class="kh ki kj kk gu mp lr mq bn mr ms bi"><span id="2c69" class="mt lt ir lr b be mu mv l mw mx">func init() {<br/>    // Package initialization<br/>    ....<br/>}</span></pre><p id="ad66" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">如果<code class="fe lo lp lq lr b">main</code>包所依赖的包中定义了<code class="fe lo lp lq lr b">init</code>函数，或者<code class="fe lo lp lq lr b">main</code>包本身定义了 init 函数，那么 Go 程序会在包初始化时自动调用<code class="fe lo lp lq lr b">init</code>函数。</p><p id="2f53" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">有一点要注意的是，<code class="fe lo lp lq lr b">main</code>函数会自动为你调用<code class="fe lo lp lq lr b">init</code>，而你实际上不能直接调用<code class="fe lo lp lq lr b">init</code>函数，否则会得到如下编译错误:</p><pre class="kh ki kj kk gu mp lr mq bn mr ms bi"><span id="5df4" class="mt lt ir lr b be mu mv l mw mx">./main.go:10:2: undefined: init</span></pre><p id="e046" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">事实上，一个 Go 包可以有不止一个<code class="fe lo lp lq lr b">init</code>函数。所以在初始化 Go 包的时候，Go 会按照一定的顺序逐个调用这个包的<code class="fe lo lp lq lr b">init</code>函数。一般来说，传递给 Go 编译器的源文件中的<code class="fe lo lp lq lr b">init</code>函数会先执行；并且同一个源文件中的多个<code class="fe lo lp lq lr b">init</code>函数会按照声明的顺序执行。</p><p id="5cce" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">例如，如果我们有以下项目结构:</p><pre class="kh ki kj kk gu mp lr mq bn mr ms bi"><span id="9051" class="mt lt ir lr b be mu mv l mw mx">../testinit<br/>├── go.mod<br/>├── main.go<br/>├── pkga<br/>│   └── a.go<br/>└── pkgb<br/>    └── b.go2 directories, 4 files</span></pre><p id="1af0" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">还有<code class="fe lo lp lq lr b">main.go</code>、<code class="fe lo lp lq lr b">a.go</code>、<code class="fe lo lp lq lr b">b.go</code>的样子:</p><pre class="kh ki kj kk gu mp lr mq bn mr ms bi"><span id="eb18" class="mt lt ir lr b be mu mv l mw mx">main.go<br/>============<br/>package main<br/><br/>import (<br/> "fmt"<br/>    _ "github.com/tonylixu/testinit/pkga"<br/>    _ "github.com/tonylixu/testinit/pkgb"<br/>)<br/><br/>func init() {<br/>    fmt.Println("main init")<br/>}<br/><br/>func main() {<br/>    fmt.Println("Running main func")<br/>}<br/><br/>a.go<br/>=========<br/>package pkgaimport "fmt"<br/><br/>func init() {<br/>    fmt.Println("In package a")<br/>}<br/><br/>func main() {<br/>}<br/><br/>b.go<br/>=========<br/>package pkgbimport "fmt"<br/><br/>func init() {<br/>    fmt.Println("In package b")<br/>}<br/><br/>func main() {<br/>}</span></pre><p id="006c" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">输出将是:</p><pre class="kh ki kj kk gu mp lr mq bn mr ms bi"><span id="63e4" class="mt lt ir lr b be mu mv l mw mx">$ go run main.go<br/>In package a<br/>In package b<br/>main init<br/>Running main func</span></pre><h2 id="882b" class="my lt ir bd lu mz na dn ly nb nc dp mc lb nd ne me lf nf ng mg lj nh ni mi nj bi translated">init —复杂的包级变量初始化</h2><p id="04b7" class="pw-post-body-paragraph ks kt ir ku b kv mk js kx ky ml jv la lb mm ld le lf mn lh li lj mo ll lm ln ik bi translated">一些包级变量需要更复杂的初始化过程。有时，使用其类型零值(每个 Go 类型都有一个零值定义)或简单的初始化表达式无法满足业务逻辑需求，而<code class="fe lo lp lq lr b">init</code>函数非常<strong class="ku is">适合</strong>这项工作，在标准库<code class="fe lo lp lq lr b">http</code>包中有这样一个典型的例子:</p><pre class="kh ki kj kk gu mp lr mq bn mr ms bi"><span id="32e5" class="mt lt ir lr b be mu mv l mw mx">var (<br/>    http2VerboseLogs    bool // Default false<br/>    http2logFrameWrites bool // Default false<br/>    http2logFrameReads  bool // Default false<br/>    http2inTests        bool // Default false<br/>)<br/><br/>func init() {<br/>    e := os.Getenv("GODEBUG")<br/>    if strings.Contains(e, "http2debug=1") {<br/>        http2VerboseLogs = true // Reset http2VerboseLogs<br/>    }<br/>    if strings.Contains(e, "http2debug=2") {<br/>        http2VerboseLogs = true // Reset http2VerboseLogs<br/>        http2logFrameWrites = true // Reset http2VerboseLogs<br/>        http2logFrameReads = true // Reset http2VerboseLogs<br/>    }<br/>}</span></pre><p id="4aed" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">我们可以看到标准库<code class="fe lo lp lq lr b">http</code>包定义了一系列布尔特性开关变量，默认关闭(即值为 false)，但是我们可以通过<strong class="ku is"> GODEBUG </strong>环境变量的值开启相关特性开关。</p><p id="6fca" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">所以在<code class="fe lo lp lq lr b">http</code>包的<code class="fe lo lp lq lr b">init</code>函数中，这些包级开关变量的复杂初始化是根据环境变量<strong class="ku is"> GODEBUG </strong>的值进行的。这保证了这些开关变量在 http 包初始化后可以处于合理的状态。</p><h2 id="f644" class="my lt ir bd lu mz na dn ly nb nc dp mc lb nd ne me lf nf ng mg lj nh ni mi nj bi translated">初始化—注册模式</h2><p id="36bf" class="pw-post-body-paragraph ks kt ir ku b kv mk js kx ky ml jv la lb mm ld le lf mn lh li lj mo ll lm ln ik bi translated">让我们看看下面的例子:</p><pre class="kh ki kj kk gu mp lr mq bn mr ms bi"><span id="e283" class="mt lt ir lr b be mu mv l mw mx">import (<br/>    "database/sql"<br/>    _ "github.com/lib/pq"<br/>)<br/><br/>func main() {<br/>    db, err := sql.Open("postgres", "user=pqgotest dbname=pqgotest sslmode=verify-full")<br/>    if err != nil {<br/>        log.Fatal(err)<br/>    }<br/>    <br/>    age := 21<br/>    rows, err := db.Query("SELECT name FROM users WHERE age = $1", age)<br/>    ...<br/>}</span></pre><p id="7ec4" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">事实上，这是一段“神奇”的代码。可以看到<code class="fe lo lp lq lr b">lib/pq</code>包作为空导入导入。main 函数不使用<code class="fe lo lp lq lr b">pq</code>包的任何变量、函数或方法，但它能够访问 PostgreSQL 数据库。而这一切的奥秘就在于<code class="fe lo lp lq lr b">pq</code>包的<code class="fe lo lp lq lr b">init</code>功能:</p><pre class="kh ki kj kk gu mp lr mq bn mr ms bi"><span id="f5d7" class="mt lt ir lr b be mu mv l mw mx">func init() {<br/>    sql.Register("postgres", &amp;Driver{})<br/>}</span></pre><p id="3ee9" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">即使<code class="fe lo lp lq lr b">lib/pq</code>是一个空导入，但它的<code class="fe lo lp lq lr b">init</code>功能仍然被执行。这种在<code class="fe lo lp lq lr b">init</code>函数中注册自己实现的模式，有效地减少了 Go 包的直接暴露，尤其是包级变量的暴露，从而避免了外部通过包级变量对包状态的改变。</p><h1 id="dd26" class="ls lt ir bd lu lv lw lx ly lz ma mb mc jx md jy me ka mf kb mg kd mh ke mi mj bi translated">转到包初始化顺序</h1><p id="d6a7" class="pw-post-body-paragraph ks kt ir ku b kv mk js kx ky ml jv la lb mm ld le lf mn lh li lj mo ll lm ln ik bi translated">下图显示了 Go 包的初始化顺序:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj nk"><img src="../Images/020bf7fd96a150530ba4b1a881d9056c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/0*19Ol2bzZ43RMnEap.png"/></div></figure><p id="048f" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">我们可以用以下三个要点来总结这一顺序:</p><ul class=""><li id="de9a" class="nl nm ir ku b kv kw ky kz lb nn lf no lj np ln nq nr ns nt bi translated">依赖包按照“深度优先”的顺序初始化；</li><li id="e336" class="nl nm ir ku b kv nu ky nv lb nw lf nx lj ny ln nq nr ns nt bi translated">每个包按照“常量-&gt;变量-&gt;初始化函数”的顺序初始化；</li><li id="a0b3" class="nl nm ir ku b kv nu ky nv lb nw lf nx lj ny ln nq nr ns nt bi translated">包中的多个 init 函数按照出现的顺序自动调用。</li></ul></div></div>    
</body>
</html>