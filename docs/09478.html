<html>
<head>
<title>Memory management in Rust -Part 2: Reference borrowing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust 中的内存管理-第 2 部分:引用借用</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/memory-management-in-rust-part-2-reference-borrowing-52f6654419e?source=collection_archive---------10-----------------------#2022-08-23">https://blog.devgenius.io/memory-management-in-rust-part-2-reference-borrowing-52f6654419e?source=collection_archive---------10-----------------------#2022-08-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a226a4a902d62e4250248ec17a49513d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1rTOPic633FnAB2aq-nyCA.jpeg"/></div></div></figure><p id="a5ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我之前的文章<a class="ae kw" href="https://anismousse.medium.com/ownership-and-moves-in-rust-4a9c6f02108d" rel="noopener">Rust 中的内存管理——第 1 部分:所有权和移动</a>中，我们轻松地理解了 Rust 中的内存管理方式。</p><p id="55ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们发现了<strong class="ka ir">所有权</strong>和<strong class="ka ir">移动</strong>的概念，可以用下面这句话来概括:</p><blockquote class="kx"><p id="0622" class="ky kz iq bd la lb lc ld le lf lg kv dk translated"><strong class="ak"> <em class="lh">每个值都有一个唯一的所有者，这个所有者决定了它的寿命。</em> </strong></p></blockquote><p id="83d8" class="pw-post-body-paragraph jy jz iq ka b kb li kd ke kf lj kh ki kj lk kl km kn ll kp kq kr lm kt ku kv ij bi translated">在这篇文章的第二部分，我们将介绍<strong class="ka ir">引用</strong>和<strong class="ka ir">引用借用</strong>的概念；我们就要到达终点了…所以请坚持住🦾.</p><h1 id="43d3" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">什么是参考？</h1><p id="cc88" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">引用是一个指针，<strong class="ka ir"> <em class="mq">不拥有它所指向的</em> </strong>值；它是一个内存地址，它所指向的值就是在这个地址上表示的。</p><p id="cb61" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<strong class="ka ir">与符号</strong> <code class="fe mr ms mt mu b"><strong class="ka ir">&amp;</strong></code>创建引用，使用<strong class="ka ir">星号(*) </strong>进行解引用(访问其引用的值)。</p><p id="9a15" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我们有<code class="fe mr ms mt mu b">let variable = 1;</code>，有<code class="fe mr ms mt mu b">let reference = &amp;variable;</code>，<code class="fe mr ms mt mu b">reference</code>是指向<code class="fe mr ms mt mu b">value</code>的引用，<code class="fe mr ms mt mu b">*reference</code>相当于<code class="fe mr ms mt mu b">1</code>是在<code class="fe mr ms mt mu b">variable</code>内排序的值。</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">Rust 中的引用</figcaption></figure><p id="ae56" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">引用不能比它所引用的值更长寿，这就引入了<strong class="ka ir">借用</strong>的概念。</p><p id="34c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">引用<strong class="ka ir">从它的所有者那里借用</strong>它们所指向的值，并最终将它返回。</p><p id="da55" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能已经意识到了<strong class="ka ir">引用借用</strong>概念给<strong class="ka ir">所有权</strong>和<strong class="ka ir">移动</strong>概念引入了一些灵活性(在这里复习那些概念<a class="ae kw" href="https://anismousse.medium.com/ownership-and-moves-in-rust-4a9c6f02108d" rel="noopener">)。</a></p><p id="0819" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下面的例子中，我们打印变量<code class="fe mr ms mt mu b">missy_favorite_humans,</code>中的所有值，然后打印它的大小。这是不可能的，因为<code class="fe mr ms mt mu b">missy_favorite_humans</code>将其值的所有权传递给了<code class="fe mr ms mt mu b">for</code>循环，因此当我们试图对变量<code class="fe mr ms mt mu b">missy_favorite_humans</code>调用<code class="fe mr ms mt mu b">len()</code>方法时，变量<code class="fe mr ms mt mu b">missy_favorite_humans</code>是未定义的。</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">Rust 编译器拒绝的示例</figcaption></figure><p id="824f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们在同一个示例中引入一个引用:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">参考借阅示例</figcaption></figure><p id="83a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个例子中，<code class="fe mr ms mt mu b">for</code>循环是在对<code class="fe mr ms mt mu b">missy_favorite_humans</code>的引用上完成的。<code class="fe mr ms mt mu b">for</code>循环可以通过<code class="fe mr ms mt mu b">&amp;missy_favorite_humans</code>访问借用值并打印出来。在循环的最后，<code class="fe mr ms mt mu b">&amp;missy_favorite_humans</code>正在脱离范围，而<code class="fe mr ms mt mu b">missy_favorite_humans</code>仍然拥有其项目的所有权。因此，可以处理第 10 行上的指令。</p><p id="9359" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是 Rust 是如何确保一个引用不能比它所引用的值更长寿的呢？救援来了:<strong class="ka ir"> <em class="mq">生生世世</em> </strong>。</p><h1 id="1245" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">一生</h1><p id="0086" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">正如在<a class="ae kw" href="https://doc.rust-lang.org/rust-by-example/scope/lifetime.html" rel="noopener ugc nofollow" target="_blank"> Rust by Examples </a>中提到的，一个<strong class="ka ir">生存期</strong>是编译器(借位检查器)用来确保所有借位有效的一个构造。换句话说，生命周期是代码的一部分，其中变量或引用可以安全地使用。</p><p id="cd7f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了满足<strong class="ka ir"> <em class="mq">引用不能比它所引用的</em> </strong>的值更长寿的规则，编译器检查引用<strong class="ka ir">的生存期是否必须包含在它所引用的变量的生存期内</strong>。(在这里暂停一下，再读一遍🧐).</p><p id="4ebe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面的代码示例<strong class="ka ir">被编译器拒绝</strong>，因为变量<code class="fe mr ms mt mu b">reference</code>(一个借用引用)的生存期不包含在<code class="fe mr ms mt mu b">variable</code>的生存期内；它引用的值。</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/d45ebac9ab1a4d42d743fd1087b03e07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*6yGLsQUHDquIW4B36kTe1A.png"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">不合规的参考文献借用示例</figcaption></figure><p id="edbb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看一个稍加修改的类似例子:</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/6dc87c8cf4241b0f417f6babaa85ac04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*EOYX5EZwVDWc0QMVLXpfMw.png"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">符合规范的参考文献借阅示例</figcaption></figure><p id="f2ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如你在这里看到的，引用借用是可能的，因为生命周期规则得到了尊重。</p><p id="9d4c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当在函数签名、结构、枚举、<code class="fe mr ms mt mu b">impl</code>块中使用引用时，我们需要精确它们的生存期。在某些情况下，Rust 编译器会自动推断生存期，并允许我们省略它(<a class="ae kw" href="https://doc.rust-lang.org/nomicon/lifetime-elision.html" rel="noopener ugc nofollow" target="_blank"> Lifetime Elision </a>)。</p><p id="80d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">寿命用撇号<code class="fe mr ms mt mu b">'</code>表示。按照惯例，小写字母用于命名。以下是一些例子:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">具有生存期的函数、结构和枚举的示例</figcaption></figure><p id="fbd3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mr ms mt mu b">'static</code>寿命注释是<strong class="ka ir">保留的</strong>寿命注释。这些<strong class="ka ir">参考对整个程序</strong>有效。它们保存在二进制文件的数据段中，引用的数据永远不会超出范围。</p><p id="9e57" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="mq">需要注意的是，Rust 没有空引用。</em> </strong></p><h1 id="e560" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">不同类型的参考</h1><p id="8193" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">引用有两种类型，<strong class="ka ir">共享引用</strong>和<strong class="ka ir">可变引用</strong>。让我们逐一探究。</p><h2 id="05b6" class="nh lo iq bd lp ni nj dn lt nk nl dp lx kj nm nn mb kn no np mf kr nq nr mj ns bi translated">共享参考</h2><p id="3f07" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">共享引用允许您读取它们所引用的值，但不允许您更改它们。您可以同时拥有对同一值的多个引用。</p><p id="b36b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当存在共享引用时，无论是它所引用的项目还是通过该项目的任何其他内容都不能被任何内容更改。<strong class="ka ir">所有权树</strong>中所有涉及共享引用的部分<strong class="ka ir">都是不可更改的。</strong></p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/6ebe9c5a6bfd0c5e08f3921ab52c15fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c8Q925HTmuw7uICYixZw3A.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">借用共享引用时的可访问性</figcaption></figure><h2 id="14f1" class="nh lo iq bd lp ni nj dn lt nk nl dp lx kj nm nn mb kn no np mf kr nq nr mj ns bi translated">可变引用</h2><p id="79c4" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">可变引用允许您读取和修改它所引用的值。关键字:<code class="fe mr ms mt mu b">&amp;mut</code>允许你创建一个可变的引用。</p><p id="5b77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">可变引用是<strong class="ka ir">排他的</strong>，这意味着当一个值上有一个可变引用时，除了现有可变引用上的可变引用之外，我们不能同时拥有该值上任何类型的任何其他引用。</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/ecd9cad7ff71c1dfca66e4d744d3eb5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cPO8ExFxR_V6qlJ5jZr22w.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">借用可变引用时的可访问性</figcaption></figure></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><p id="6137" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">共享引用和可变引用的区别可以用下面的规则来概括:<strong class="ka ir"> <em class="mq">一个值可以有多个读取者(共享引用)或者一个写入者(可变引用)</em> </strong>。</p><h2 id="0d45" class="nh lo iq bd lp ni nj dn lt nk nl dp lx kj nm nn mb kn no np mf kr nq nr mj ns bi translated">最后</h2><p id="46df" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">在对内存管理的概述中，我们看到为了实现其三连胜愿望的<strong class="ka ir">安全</strong>支柱，Rust 对<strong class="ka ir">所有权有一个限制性的规则</strong>。由于<strong class="ka ir">移动</strong>概念、<strong class="ka ir">引用</strong>、<strong class="ka ir">引用借用</strong>以及所有促进我们与记忆互动的规则，这个规则的一些灵活性是可能的。</p><blockquote class="oc od oe"><p id="e182" class="jy jz mq ka b kb kc kd ke kf kg kh ki of kk kl km og ko kp kq oh ks kt ku kv ij bi translated">Rust 的美妙之处在于那些在编译时强制执行的严格规则，这些规则迫使我们从一开始就拥有一个深思熟虑的、架构正确的、安全的程序。</p></blockquote><p id="8042" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在 Rust，所有的支票都是预先兑现的！！！</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oi"><img src="../Images/23707582c0d171d05c2d3a5ea3759df1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IpRVIw6zE31Tk79Yua0jWQ.jpeg"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">米西等着我销毁门上的可变引用</figcaption></figure><h1 id="8c64" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">资源</h1><p id="ddc7" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated"><a class="ae kw" href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html?highlight=ownership#what-is-ownership" rel="noopener ugc nofollow" target="_blank">所有权</a>章出自‘T<strong class="ka ir">何锈编程语言</strong>’。</p><p id="53a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://www.oreilly.com/library/view/programming-rust-2nd/9781492052586/" rel="noopener ugc nofollow" target="_blank">编程生锈，第二版</a></p><p id="418f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://doc.rust-lang.org/rust-by-example/index.html" rel="noopener ugc nofollow" target="_blank">锈由例</a></p></div></div>    
</body>
</html>