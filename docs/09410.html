<html>
<head>
<title>Primitive obsession anti-pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">原始执念反模式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/primitive-obsession-anti-pattern-83fb5dcd5cc2?source=collection_archive---------5-----------------------#2022-08-19">https://blog.devgenius.io/primitive-obsession-anti-pattern-83fb5dcd5cc2?source=collection_archive---------5-----------------------#2022-08-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5199" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过减少来自应用程序核心的代码味道来改进您的代码</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7050f3a208e0d863c37a61978e5a0298.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mS1a6_mx0mud11Ax"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">丹尼尔·伊德里在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="26ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">原始的痴迷是一种表明代码质量差的气味。我们认为<em class="ls"> boolean、string、int、</em>和<em class="ls"> float </em>是 PHP 中的原始类型。它们是不可避免的构建块，但是它们可以被安排到有意义的领域对象中。考虑以下对象:</p><h2 id="f9aa" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">购物者实体</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h2 id="48dc" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">订单实体</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="aabd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些不再是合适的对象，而仅仅是没有任何有意义的行为的值持有者。处理如此大量的属性很容易出错。想象以下业务操作:</p><ul class=""><li id="0883" class="mo mp iq ky b kz la lc ld lf mq lj mr ln ms lr mt mu mv mw bi translated">更改用户的家庭地址</li><li id="d215" class="mo mp iq ky b kz mx lc my lf mz lj na ln nb lr mt mu mv mw bi translated">更改用户的帐单地址</li><li id="25bb" class="mo mp iq ky b kz mx lc my lf mz lj na ln nb lr mt mu mv mw bi translated">分配订单的交货地址</li></ul><p id="fb23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个地址包含相同简单原始类型的五个独立属性，当从一个地方复制值到另一个地方时很容易出错，例如，您可以很容易地将<em class="ls"> addressLine2 </em>分配给<em class="ls"> addressLine1。</em>由于<strong class="ky ir">所有属性都是相互独立的</strong>，因此也有可能只有部分地址会改变，而其余部分会保持不变。</p><p id="1955" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您碰巧有一些关于地址的额外逻辑，您必须在每个实体之间复制这个逻辑，或者将这个逻辑移动到一个单独的服务。</p><p id="3926" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">购物者的名字也有同样的历史。目前有可能错误地只设置了名字，但是姓氏将会消失。</p><p id="98a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从长远来看，拥有有意义的值对象对你有帮助。不变性是你能在代码中引入的最好的东西。</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><p id="24c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们重构购物者和订单实体。很容易发现值对象的候选对象，它们通常共享名称的某个部分。</p><h2 id="71a2" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">重构后的购物者实体</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h2 id="4a7b" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">重构后的订单实体</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="dbe5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">前面提到的值对象现在可以引入一些有趣且易于测试的行为。它们被视为一个整体，因此不可能只改变一部分。如果你想改变值对象的任何一点，你应该创建一个新的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="a4df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一名购物者是女性，并且与另一名购物者结婚？当然，我想这是常有的事。这只是一个夸张的例子来证明不变性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="7c8d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有意义的对象而不是日期时间可能会引入方便的行为。传递当前日期允许简单的单元测试。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="be2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">给对象分配地址现在变得轻而易举:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="f977" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于值对象是不可变的，并且不暴露任何设置器，所以它们可以在整个应用程序中安全地共享。如果您出于某种原因需要在值对象中使用 setter，请确保实体 getter 返回值对象的克隆(以防止状态在实体外部被修改)。)</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="6b97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">货币对象是价值对象教程的典型场景:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="a923" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不可变货币对象允许安全的数学运算:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><p id="a17c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对值对象的持久性有很好的支持。</p><ul class=""><li id="8a9b" class="mo mp iq ky b kz la lc ld lf mq lj mr ln ms lr mt mu mv mw bi translated">对于教义，有<a class="ae kv" href="https://www.doctrine-project.org/projects/doctrine-orm/en/2.13/tutorials/embeddables.html" rel="noopener ugc nofollow" target="_blank">个可嵌入的</a></li><li id="77cd" class="mo mp iq ky b kz mx lc my lf mz lj na ln nb lr mt mu mv mw bi translated">对于拉勒维尔的雄辩有<a class="ae kv" href="https://laravel.com/docs/8.x/eloquent-mutators#value-object-casting" rel="noopener ugc nofollow" target="_blank">价值对象铸造</a></li></ul><p id="5574" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">值对象很棒，但不是每个应用程序都需要它们。如果是一个简单的没有任何逻辑的 CRUD app，很可能会过度工程化。对于富应用程序，它们被证明是最有用的，因为你可以免费获得优秀的验证。</p><p id="02b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也就是说，你应该先问问自己，处理这些额外课程的成本是否超过了它们带来的好处。</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><p id="01d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">像往常一样，我也想推荐我读过的关于干净代码的最好的书。任何人书架上的必备——著名马丁大叔的<a class="ae kv" href="https://amzn.to/3wAVePw" rel="noopener ugc nofollow" target="_blank">《干净的代码】 :</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/58f50909001aecb6a5142d43f682d845.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/0*DKeG3Ijnbjv66vfq.jpg"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">资料来源:Amazon.com</figcaption></figure><p id="c9bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有什么疑问吗？想法？请给我留下你的看法。让我们一起让我们的代码变得美丽。订阅我的出版物，获取更多类似的文章，成为更好的开发人员。</p><p id="94e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个故事对你有价值吗？请留言支持我的工作👏鼓掌表示感谢你知道你可以不止一次鼓掌吗？🥰 <em class="ls">谢谢你。</em></p></div></div>    
</body>
</html>