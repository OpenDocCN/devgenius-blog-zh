<html>
<head>
<title>Building smaller docker images — the right way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建更小的docker图像——正确的方法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/building-smaller-docker-images-the-right-way-1b6c12c112e1?source=collection_archive---------1-----------------------#2022-01-09">https://blog.devgenius.io/building-smaller-docker-images-the-right-way-1b6c12c112e1?source=collection_archive---------1-----------------------#2022-01-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="84fc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Docker图像很棒，它们很容易处理——但是如果你不注意正确构建它们，它们会被放大到很大的尺寸。</p><p id="c598" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">除了大小之外，这还会给生产Kubernetes集群带来严重的安全漏洞，因为您有一个从未使用过的包。</p><p id="c138" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你有一个大的python应用程序docker镜像，需要优化和缩小，那么第3部分是必读书。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f41ff4f476085117613a0507fbe71039.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cAx3fzADLYjc8ufALCoQew.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://images.pexels.com/photos/225769/pexels-photo-225769.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=2&amp;h=750&amp;w=1260" rel="noopener ugc nofollow" target="_blank">图片来源</a> : <em class="kz">马库斯·斯皮斯克</em></figcaption></figure><p id="626f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这篇文章将帮助你编写更小的docker映像，这将导致更有效和更安全的docker容器。</p><p id="5e89" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">扣好安全带！—我们将把docker图像的大小从536MB减少到263MB，最终减少到65.8 MB。</strong></p><p id="894a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们在这里编写的应用程序是一个简单的flask应用程序，它运行在python上，具有这些<a class="ae ky" href="https://github.com/sanjayBala/flask-docker-example/blob/master/requirements.txt" rel="noopener ugc nofollow" target="_blank">需求</a>。</p><h1 id="cb5d" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">0.做好准备</h1><p id="fdd3" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">假设您的计算机上安装了最新版本的docker，请执行以下操作</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="3084" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您还可以构建并运行docker容器来测试应用程序</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">构建并运行样品瓶应用程序</figcaption></figure><p id="2c5e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当容器运行时，您应该会看到如下所示的简单页面。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mf"><img src="../Images/9237600f3940374329558f76ae4cb56d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OG0r_1WYClfNX57BCAFd5w.png"/></div></div></figure><h1 id="71e4" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">1.码头工人——错误的方式</h1><p id="1cd9" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">我们将使用一种简单的方法——Debian映像。</p><p id="72c4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">甚至这个dockerfile也有好的一面，<strong class="jm io"> <em class="mg">只有一个RUN命令</em> </strong>，通过链接所有你想运行的shell命令只需一层。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">基于Debian的Dockerfile文件</figcaption></figure><p id="6d63" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个docker文件没有任何问题，我们的应用程序运行良好，并且易于理解。虽然这个图像的大小是500MB+，但当我们安装更多的pip包时，它肯定会呈指数级增长。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="48e3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了解决这个问题，我们可以选择一个替代的docker映像来构建，可能是一个基于alpine的映像，它具有最少的预安装包，因此使映像更小。</p><p id="7e90" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这让我们进入下一部分…</p><h1 id="d0ee" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">2.使用正确的图像</h1><p id="5ba9" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">选择python:3-alpine映像(python 3已经预装在这里，所以工作量更小)，让我们对does文件做一些小的修改，比如添加构建工具g++等，因为alpine映像没有附带这些工具，然后进行实际的pip安装。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">基于阿尔卑斯山的码头文件</figcaption></figure><p id="a2ab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将图像大小减少到263 MB，这很好，但是alpine图像一开始只有45 MB。所以我们添加了大约200MB的包。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="md me l"/></div></figure><h1 id="d954" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">3.利用多阶段构建</h1><p id="8346" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">更进一步，考虑一下我们的情况——我们需要的只是pip包，而不是gcc/g++构建依赖。</p><p id="9dbb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">幸运的是，有一种方法可以只使用我们需要的文件，并将它们放入另一个映像中——进入多阶段构建。</p><p id="ae02" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">多阶段构建是一种在容器中构建应用程序包的好方法，然后只将文件/工件/二进制文件复制到最终的容器中，而不需要依赖关系——这有助于我们使我们的映像大小小很多！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">基于阿尔卑斯山的多级码头文件</figcaption></figure><p id="777e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个docker文件实质上制造了两个“容器”，</p><p id="95c6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第一个容器(别名builder) <br/> </strong>第一个安装构建依赖项，但是这次我们将所有的pip需求安装到一个python虚拟环境目录<code class="fe mh mi mj mk b">/opt/venv</code>。</p><p id="c139" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第二个也是最后一个容器<br/> </strong>第二个容器来自alpine映像，它只复制了<code class="fe mh mi mj mk b">/opt/venv</code>目录，该目录包含我们的应用程序需要的所有pip包，没有任何其他构建时依赖项。</p><pre class="kj kk kl km gt ml mk mm mn aw mo bi"><span id="1901" class="mp lb in mk b gy mq mr l ms mt"># this copies the virt-env folder from the first container into the second<br/>COPY --from=builder /opt/venv /opt/venv ENV </span><span id="739f" class="mp lb in mk b gy mu mr l ms mt"># this directs the final container to use the /opt/venv packages<br/>PATH="/opt/venv/bin:${PATH}"</span></pre><blockquote class="mv mw mx"><p id="e0b0" class="jk jl mg jm b jn jo jp jq jr js jt ju my jw jx jy mz ka kb kc na ke kf kg kh ig bi translated">第二个容器是制作最终映像的容器，它被运送到Docker映像注册中心，没有二进制文件或构建工具——只有运行应用程序所需的最少内容。</p></blockquote><p id="460c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="mg">这种方法将图像大小缩减到惊人的65MB，当我们从500+ MB开始时，这看起来像是一个巨大的飞跃。</em>T11】</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">所有三个docker图像</figcaption></figure><h1 id="b0e6" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">总结</h1><p id="e43e" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">甚至在从源代码构建时也可以使用多阶段构建，并且不仅限于python虚拟环境。</p><p id="dcd8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">只需遵循一些简单的做法:</p><ul class=""><li id="5efc" class="nb nc in jm b jn jo jr js jv nd jz ne kd nf kh ng nh ni nj bi translated">选择正确的图像</li><li id="00b3" class="nb nc in jm b jn nk jr nl jv nm jz nn kd no kh ng nh ni nj bi translated">只安装应用程序绝对需要的包</li><li id="aadd" class="nb nc in jm b jn nk jr nl jv nm jz nn kd no kh ng nh ni nj bi translated">如果可能，使用多阶段构建</li><li id="a682" class="nb nc in jm b jn nk jr nl jv nm jz nn kd no kh ng nh ni nj bi translated">总是使用一个. dockerignore(这可以确保不需要的文件不会被复制到docker镜像中，就像zips例子一样)</li><li id="a5fc" class="nb nc in jm b jn nk jr nl jv nm jz nn kd no kh ng nh ni nj bi translated">总是尝试在docker文件中使用最少数量的RUN指令</li></ul><h1 id="8cde" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">资源</h1><p id="2b42" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">代码可以在这里查看:<a class="ae ky" href="https://github.com/sanjayBala/flask-docker-example" rel="noopener ugc nofollow" target="_blank"> Github代码链接</a></p></div></div>    
</body>
</html>