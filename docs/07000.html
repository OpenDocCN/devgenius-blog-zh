<html>
<head>
<title>MDC — Improve Logging for Debugging</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MDC —改进调试日志记录</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/mdc-improving-debugging-logging-bb421a62a195?source=collection_archive---------5-----------------------#2022-02-18">https://blog.devgenius.io/mdc-improving-debugging-logging-bb421a62a195?source=collection_archive---------5-----------------------#2022-02-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/56fbb1f3c3b0bfb7a31d4e79ed96fdda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hG1QyD_nylPOT3a0LAzMEw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">建筑商鲍勃同意！</figcaption></figure><p id="1aa8" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">将你的日志构建得和<a class="ae kx" href="http://www.bobthebuilder.com/en-us/" rel="noopener ugc nofollow" target="_blank">建造者鲍勃</a>一样好🤪</p><p id="0901" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">通常，在大多数后端应用程序中，线程池中的一个<em class="ky">独立线程处理一个客户端请求</em>。一旦请求完成，线程就被返回到线程池，并生成其典型的日志。</p><p id="c908" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们要解决什么？让我们以<strong class="kb io">为例</strong>。<br/>考虑这样一种情况:两个用户<em class="ky">已经登录并从数据库中检索数据。通过区分线程 ID，可以很容易地看出哪个日志语句属于哪个请求。这种基于线程的日志关联是从单个请求中识别所有日志的有用技术。然而，使用这种技术，我们无法区分哪个请求属于哪个用户。现在，当实现多线程时，事情变得更加混乱。</em></p><p id="aa28" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">部分解决方案</strong> : <br/>其中一种方法是在请求进入服务时生成一个惟一的编号，并在每个日志语句中打印出来，但是这又一次很难与用户相关联</p><p id="184a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">解决方案:</strong> <br/>另一个解决方案是为每个日志语句打印<em class="ky">用户 ID </em>和<em class="ky">请求 ID </em>。<em class="ky">请求 ID </em>将在客户端生成。对于用户的每个请求，请求 ID 都是唯一的。如果有来自多个用户的并发请求，这将有助于识别一个请求(因为我们也有<em class="ky">用户 ID </em>)。这些作为 HTTP 头与每个请求一起传递，并附加到每个日志行。</p><p id="0a96" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">方法</strong>:<br/><a class="ae kx" href="https://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/MDC.html" rel="noopener ugc nofollow" target="_blank">MDC</a>提供了一个简单的键/值(map)机制来捕获少量的定制诊断数据。因为它内置在日志框架中，所以从 MDC 向每个日志行添加值非常容易。log4j、log4j2 和 SL4J/logback 支持 MDC。</p><p id="7a26" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">MDC 允许我们在一个类似 map 的结构中填充一些信息，当日志消息被写入时，appender 可以访问这些信息。MDC 结构以与<em class="ky"> ThreadLocal </em>变量相同的方式在内部附加到执行线程。</p><p id="ac42" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">高层想法</strong>是:</p><ul class=""><li id="12cf" class="kz la in kb b kc kd kg kh kk lb ko lc ks ld kw le lf lg lh bi translated">在线程开始时，用日志附加器所需的信息填充 MDC</li><li id="4c83" class="kz la in kb b kc li kg lj kk lk ko ll ks lm kw le lf lg lh bi translated">记录消息</li></ul><p id="f0b9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">实现</strong> : <br/>应用栈:<a class="ae kx" href="https://www.java.com/en/download/" rel="noopener ugc nofollow" target="_blank">Java</a>—<a class="ae kx" href="http://dropwizard.io/en/stable/" rel="noopener ugc nofollow" target="_blank">drop wizard</a><br/>然而，这种实现背后的思想适用于任何框架。</p><p id="fe16" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">所有资源的方法拦截器:</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="9a81" class="lw lx in ls b gy ly lz l ma mb">/**<br/> * @author adesh.nalpet<br/> * created on 20th December 2019<br/> * A resource method interceptor for adding request context to MDC (Logger)<br/> */<br/>@Slf4j<br/>public class RequestContextModule extends AbstractModule {</span><span id="557f" class="lw lx in ls b gy mc lz l ma mb">    @Override<br/>    protected void configure() {<br/>        final RequestContextInterceptor requestContextInterceptor = new RequestContextInterceptor();<br/>        requestInjection(requestContextInterceptor);<br/>        bindInterceptor(Matchers.any(), Matchers.annotatedWith(Path.class), requestContextInterceptor);<br/>    }</span><span id="bb89" class="lw lx in ls b gy mc lz l ma mb">    @VisibleForTesting<br/>    public static class RequestContextInterceptor implements MethodInterceptor {</span><span id="16dc" class="lw lx in ls b gy mc lz l ma mb">        @Override<br/>        public Object invoke(MethodInvocation invocation) throws Throwable {</span><span id="3eaa" class="lw lx in ls b gy mc lz l ma mb">            /* Applicable for methods annotated with @Path (Resources) */<br/>            final Optional&lt;Annotation&gt; optionalAnnotation = Stream.of(invocation.getMethod().getDeclaredAnnotations())<br/>                    .filter(annotation -&gt; annotation instanceof Path)<br/>                    .findFirst();</span><span id="3041" class="lw lx in ls b gy mc lz l ma mb">            if (optionalAnnotation.isPresent()) {<br/>                final Annotation[][] parameterAnnotations = invocation.getMethod().getParameterAnnotations();</span><span id="04f7" class="lw lx in ls b gy mc lz l ma mb">                for (int index = 0; index &lt; parameterAnnotations.length; ++index) {<br/>                    for (final Annotation annotation : parameterAnnotations[index]) {<br/>                        /* Check for method arguments annotated with @Auth */<br/>                        if (annotation instanceof Auth) {<br/>                            try {<br/>                                final Auth auth = (Auth) invocation.getArguments()[index];<br/>                                /* Add request and user ID to MDC<br/>                                Note :<br/>                                * Any information in Auth can be logged.<br/>                                * Consider compliance restrictions before logging any sensitive information.<br/>                                */<br/>                                MDC.put(RequestContext.REQUEST_ID, auth.getRequestId());<br/>                                MDC.put(RequestContext.REQUEST_USER_ID, auth.getUserId());<br/>                            } catch (Exception e) {<br/>                                /* Deliberately catching all exceptions,<br/>                                to ensure application is not affected from logger<br/>                                TODO : Set-up alerts for the below log */<br/>                                log.error("[Auth to MDC] Error while fetching Auth");<br/>                            }<br/>                        }<br/>                    }<br/>                }<br/>            }<br/>            return invocation.proceed();<br/>        }<br/>    }<br/>}</span></pre><p id="e489" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">清除上下文的响应过滤器:</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="5680" class="lw lx in ls b gy ly lz l ma mb">/**<br/> * @author adesh.nalpet<br/> * created on 20th December 2019<br/> * A Servlet response filter to clear MDC.<br/> */<br/>public class ClearContextResponseFilter implements Filter {<br/>    @Override<br/>    public void init(FilterConfig filterConfig) throws ServletException {<br/>        /* deliberately nothing */<br/>    }</span><span id="757d" class="lw lx in ls b gy mc lz l ma mb">    @Override<br/>    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {<br/>        try {<br/>            chain.doFilter(request, response);<br/>        } finally {<br/>            RequestContext.clearContext();<br/>        }<br/>    }</span><span id="a902" class="lw lx in ls b gy mc lz l ma mb">    @Override<br/>    public void destroy() {<br/>        /* deliberately nothing */<br/>    }<br/>}</span></pre><p id="1ea7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">请求上下文:</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="1cdc" class="lw lx in ls b gy ly lz l ma mb">/**<br/> * @author adesh.nalpet<br/> * created on 20th December 2019<br/> * TODO : Validate storing RequestContext in thread local.<br/> */<br/>public class RequestContext {</span><span id="66d2" class="lw lx in ls b gy mc lz l ma mb">    public static final String REQUEST_ID = "request_id";<br/>    public static final String REQUEST_USER_ID = "user_id";</span><span id="14df" class="lw lx in ls b gy mc lz l ma mb">    public static void clearContext() {<br/>        MDC.remove(REQUEST_ID);<br/>        MDC.remove(REQUEST_USER_ID);<br/>    }<br/>}</span></pre><p id="9575" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">日志格式:</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="7329" class="lw lx in ls b gy ly lz l ma mb">logFormat: "%(%-5level) [%date] %X{request_id} %X{user_id} [%thread] [%logger{0}]: %message%n"</span></pre><p id="d9a3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">走向 MDC🚀</p></div></div>    
</body>
</html>