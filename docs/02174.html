<html>
<head>
<title>React.js // Discerning Between State and Props</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React.js //辨别状态和道具</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/react-js-discerning-between-state-and-props-5bebcb160053?source=collection_archive---------20-----------------------#2020-07-21">https://blog.devgenius.io/react-js-discerning-between-state-and-props-5bebcb160053?source=collection_archive---------20-----------------------#2020-07-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c6aeec7bae5e9cff1d6f050f66ef2acd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4BiwqNhxG0Sl5R1Mh0ZZtQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">“只要有可能，你就必须茁壮成长，哪怕只是为那些不可能的时候提供一个缓冲。”乔丹·沃克</figcaption></figure><p id="c6ee" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">广受欢迎的Javascript前端库React提供了结构化和简化的<a class="ae la" href="https://en.wikipedia.org/wiki/Coding_conventions" rel="noopener ugc nofollow" target="_blank">编程约定</a>，用于呈现特定项目后端所需的任何视图。为了有效地利用这个神奇的库，人们必须对<em class="lb">状态、</em>和<strong class="ke ir">的反应概念以及它们如何协同工作有一个良好的理解。</strong></p><p id="6455" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先，<em class="lb">状态</em>和<em class="lb">属性</em>的概念是通过哪个组件拥有数据来辨别的。<strong class="ke ir">状态</strong>是本地拥有的(对于一个组件)，并由组件本身更新。<strong class="ke ir">属性</strong>不属于本地组件，而是源自父组件，因此由只读数据组成。为了更新props，必须将回调函数传递给子组件，以提示上游的更改。</p><p id="43c2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">通过在代码中可视化这个过程，组件数据所有权的概念可以变得更加清晰。让我们从基础应用组件开始:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="cb3c" class="ll lm iq lh b gy ln lo l lp lq">import React, { Component } from 'react';<br/>import DogContainer from './DogContainer';</span><span id="47bf" class="ll lm iq lh b gy lr lo l lp lq">Class App extends Component {<br/>    const dogsData = [Fido, Bosco, Fluff]<br/>    constructor(){<br/>    super()<br/>    this.state = {<br/>      dogs: dogsData<br/>    }<br/>  }</span><span id="17da" class="ll lm iq lh b gy lr lo l lp lq">render() {<br/>    return (<br/>      &lt;div className="app"&gt;<br/>        &lt;DogContainer dogs={this.state.dogs}/&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>}</span><span id="83d2" class="ll lm iq lh b gy lr lo l lp lq">export default App;</span></pre><blockquote class="ls lt lu"><p id="4f42" class="kc kd lb ke b kf kg kh ki kj kk kl km lv ko kp kq lw ks kt ku lx kw kx ky kz ij bi translated">App类<strong class="ke ir">拥有</strong>数据。换句话说，App父类的状态等于“狗”的<strong class="ke ir">键</strong>和<strong class="ke ir"> ' </strong> dogsData(一个狗对象数组)的<strong class="ke ir">值</strong>。</p></blockquote><p id="53fe" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果我们要' console.log(this.state)，'将返回一个包含dogs的键的对象，该键包含dogs对象的数组:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ly"><img src="../Images/e1058250659617ffc49e8c759266e6bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3H_oHcHVCO-dluqaHOI4mA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">为了举例，狗的“对象”仅仅是字符串。</figcaption></figure><p id="2bcc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，注意第16行发生了什么:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="81e9" class="ll lm iq lh b gy ln lo l lp lq">        &lt;DogContainer dogs={this.state.dogs}/&gt;</span></pre><p id="40fa" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是将道具传递给子组件时必须遵循的约定，<em class="lb"> key={this.state} </em>。在这种情况下，子组件DogContainer正在接收一个对象作为道具；这个对象有一个指向父应用程序状态的“dogs”键(我们知道这是我们的dogs数据数组)。让我们看看这个DogContainer可能是什么样子:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="d0f0" class="ll lm iq lh b gy ln lo l lp lq">import React, { Component } from 'react';</span><span id="f01c" class="ll lm iq lh b gy lr lo l lp lq">Class DogContainer extends Component {<br/>  renderDogs = () =&gt; {<br/>    this.props.dogs.map(dogObj =&gt; {<br/>      return &lt;h1&gt;{dogObj.name}&lt;/h1&gt;<br/>    }<br/>  }<br/>  render() {<br/>    return (<br/>      &lt;div className="dogContainer"&gt;<br/>        {this.renderDogs}<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>}</span><span id="1023" class="ll lm iq lh b gy lr lo l lp lq">export default DogContainer;</span></pre><p id="eda5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这里，如果我们要' console.log(this.props)'我们将得到相同的返回对象，它包含一个指向包含我们所有数据的值的' dogs '键。这些<em class="lb">道具</em> <strong class="ke ir">属于</strong>App父类，但是DogContainer可以以只读方式访问。</p><p id="e310" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">React为处理前端信息提供了一个独特的结构，而<em class="lb">状态/属性</em>对于实现该结构至关重要。在防止错误和呈现独立组件时，适当的信息流是非常重要的。更多信息请参考React官方文件<a class="ae la" href="https://reactjs.org/docs/faq-state.html" rel="noopener ugc nofollow" target="_blank">这里</a>！</p></div></div>    
</body>
</html>