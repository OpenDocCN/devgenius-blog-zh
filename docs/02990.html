<html>
<head>
<title>Building Tic-Tac-Toe With React, CSS Grid, and Flexbox</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React、CSS网格和Flexbox构建井字游戏</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/building-tic-tac-toe-with-react-css-grid-and-flexbox-c2bb259b7ad5?source=collection_archive---------2-----------------------#2020-09-18">https://blog.devgenius.io/building-tic-tac-toe-with-react-css-grid-and-flexbox-c2bb259b7ad5?source=collection_archive---------2-----------------------#2020-09-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ac7b9dcc64678b0df21520329f9a7cdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E4DRr6RzdUgrd_P5TkItKA.jpeg"/></div></div></figure><p id="4930" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">自从我在熨斗学校开始构建web应用程序以来，我一直对创建游戏和需要逻辑的谜题感兴趣。作为一名开发初学者，我需要创建超级简单的游戏，然后开始考虑设计稍微复杂一点的游戏以及幕后的逻辑。井字游戏是有史以来最简单、最经典的双人游戏之一，几乎可以在任何地方玩。</p><p id="a2de" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以这就是我写这篇文章的原因，希望另一个初学者软件开发人员可以用React构建井字游戏，并将其作为未来理解更复杂的游戏/代码概念的垫脚石。</p><p id="159e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个演示中，我将使用React和CSS grid构建一个完整的井字游戏版本；我还将使用flexbox在页面上排列其他元素。</p><h1 id="bb8b" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">开始吧</h1><p id="4881" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">首先，我在我的终端中创建了一个名为“井字游戏”的React应用程序，命令如下:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="cd00" class="mf ku in mb b gy mg mh l mi mj">npx create-react-app tic-tac-toe-tyler</span></pre><p id="45e4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我的文本编辑器中打开它后，我清除了一些不必要的样板代码，这些代码是我们初始设置时附带的，这是我们在应用程序文件中留下的内容:</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mk"><img src="../Images/a89710aef5b6821f6c5772a61e29fe55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P5Se2Oy54Ez6uRAddWZ5fg.png"/></div></div></figure><p id="cd85" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在真正的乐趣开始了！在我的“src”目录中，我创建了两个新目录，一个用于组件，一个用于样式表，并相应地命名。因为我知道井字游戏需要一个由9个方块组成的游戏板，所以我将创建一个名为game、board和Square的组件，并将它们添加到我的新组件目录中。我还为游戏、棋盘和方块组件创建了相应的CSS文件，并将它们都放在新的样式表目录中。</p><p id="372b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是我们的文件树和应用程序组件在导入游戏组件后的样子:</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ml"><img src="../Images/8106f89478d0cbd44ddad3bbb6e50b2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7wnm3fnJIMHg1cp0g6HIWw.png"/></div></div></figure><p id="e3ae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们已经建立了一些游戏逻辑，并向组件中添加了一些元素，让我们从Square组件开始，然后返回到我们刚刚导入到App组件中的游戏组件。</p><h1 id="a2c2" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">方形部件</h1><p id="8e33" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">这个组件不需要保持任何状态，它只需要能够处理点击，这将使用X或o填充正方形。它还将通过调用通过props传递的函数来改变我们的游戏状态(这将在父组件中)以反映该玩家的回合，但我们将在稍后进行讨论。</p><p id="7ebe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是功能性方形组件的初始设置:</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mm"><img src="../Images/337272b7a481e34444efd56fa74423a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6ZoCNBrt1sl3aaxSlwHo4A.png"/></div></div></figure><p id="2681" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于每个方块在被点击时都需要做一些事情，我们将向我们的<div>添加一个onClick prop，当它被点击时，我们希望调用一个我们将定义为handleClick的函数。</div></p><p id="1733" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在handleClick中，我们将从稍后定义的props中调用一个函数，该函数根据轮到谁来改变方块内的文本，并改变游戏状态，以便我们可以检查赢家。它还检查以确保单击的方块尚未被选中:</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mm"><img src="../Images/5f21f8421ef5447bdfe7ffea7925f021.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8c6V_-44SVt6qVL7r7zKyg.png"/></div></div></figure><p id="ef3e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们来分解一下我们做的这个handleClick函数。</p><p id="22e3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您从未见过async/await语法，我在这里做的是使它成为一个异步函数。也就是说，当我们使用await关键字时，该函数不会继续执行，直到“await”之后的操作完成。在这种情况下，我们需要更新游戏状态，然后才能检查玩家是否赢了，因此我把它设为异步。</p><p id="5897" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，回到逻辑上来。第一个if语句将使用特定的索引检查一个名为checkBoard的道具，以查看该方块是否已被使用(如果空格返回null，则该空格尚未被使用)。</p><p id="abf1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果checkBoard返回false，我们将对一个名为isXTurn的属性进行检查，该属性将成为记录轮到谁的状态，X或o。</p><p id="3dc2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">根据isXTurn prop返回的内容，我们将从props中调用一个名为updateGame的函数，并向它传递两个参数，即被单击的盒子的索引和正方形将被填充的字母。</p><p id="9a8d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">updateGame函数将会更新游戏，这最终会改变我们的<div>中的文本。在我们使用下一个函数调用checkForWin之前，我们需要“等待”游戏状态被更新，check for win将检查玩家是否有获胜的组合。</div></p><h1 id="eaf5" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">电路板组件</h1><p id="777b" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">董事会将举行我们所有的广场，最终将使用CSS网格安排成3行3列。此外，这将是一个功能组件，我们将把所有的状态放在游戏组件，并将其传递给董事会。</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ml"><img src="../Images/e32fa8ef31f6ccd78b8fcc8a6d12439b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ziXRiQiYteTm_oRFWJhdbw.png"/></div></div></figure><p id="19ec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">打破我们的常数makeNineSquares，(再一次，大惊喜来了)它将使9个广场；当我们到达游戏组件时，我将把每个项目放入游戏状态。</p><p id="e810" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">indexCounter变量给每个方块一个唯一的索引。我从-1开始，因为我需要在返回每个方块之前递增它，并且我希望第一个方块的boxIndex为0。</p><p id="1a67" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">传递到每个方块的其他4个道具来自游戏容器，我们将在其中保存状态。通过回顾我在正方形组件中使用的所有道具，我知道我需要传递什么样的道具。</p><h1 id="a1a0" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">游戏组件</h1><p id="2d64" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">这个组件将是我们的有状态组件，我将保存我们所有的游戏信息；例如，玩家在他们的回合中选择了哪些盒子，轮到谁了，以及是否有人赢了。</p><p id="2a9f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我们知道需要导入Board组件，并向它传递我们在Board组件中要求的4个必要道具:</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ml"><img src="../Images/fb29c9b3bae7d63fd615cdfb5d12d3c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FfDk-CYtYxB-QMyn-rAl8Q.png"/></div></div></figure><p id="9d57" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">isXTurn和游戏道具将需要来自state，checkBoard和updateGame道具将是检查和修改游戏状态的辅助函数。所以让我们开始努力吧。我还将添加一个名为“胜利者”的状态，一旦有人获胜，我们可以用一个函数来改变它(我将把它添加到props中):</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mm"><img src="../Images/34aacce96b22ace3c07b6eb2a15e10fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2QdMQJFLzaGbnP_W8CSDTg.png"/></div></div></figure><p id="5dc5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们已经设置好了状态，并添加了checkForWin属性，这样我们就有3个函数要写了；<strong class="jx io"> checkBoard </strong>，<strong class="jx io"> updateGame </strong>，<strong class="jx io"> checkForWin </strong>。checkForWin将在每一轮之后查看是否创建了任何获胜模式，并更新获胜者状态(我们还将祝贺获胜者，并添加一个重置按钮)。</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mn"><img src="../Images/4298a2185973ae9a32623f0d98ec380f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N-_Nh4VXdSkbE9PDToYZQQ.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated"><strong class="bd kv">棋盘</strong>功能</figcaption></figure><p id="5bcb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">checkBoard函数将正方形的索引作为参数。在if语句中，索引用于检查游戏状态中特定方块的状态。如果状态没有返回X或O，那么checkBoard将返回一个布尔值false，这意味着方块可以玩了。但是，如果它返回null，checkBoard将返回true，这告诉handleClick函数不允许在游戏状态中更改该方块。</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/348f0a01f1e28aa797f802779d93d944.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*sM__HMMTbNRmED9mge6A3A.png"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated"><strong class="bd kv">更新游戏</strong>功能</figcaption></figure><p id="6776" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">updateGame函数接受一个数字(正方形的索引)和一个字符串(“X”或“O”)作为参数。在制作了游戏状态的副本，并更改了新的游戏状态以反映新的移动之后，我们更新了游戏状态，并且还将isXTurn状态翻转到相反的布尔值，以表示改变到其他玩家回合。</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mt"><img src="../Images/8465d5c6381b025a31b11b34b3724239.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ckA1Axz_t6MRn7RCwsrvnA.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated"><strong class="bd kv">检查</strong>功能</figcaption></figure><p id="fb8d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个checkForWin函数就是井字游戏的神奇之处。可变中奖组合是每一种可能的中奖组合。下面的图表有助于形象化:</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/d9cf1ea7caf496aa4c3b1ef6c0c6885f.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*LdKod8NMW9YcDz943IWlSw.png"/></div></figure><p id="c1c1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来是for循环，它遍历每一个获胜的组合。然后，我们还遍历组合中的每个数字，并创建一个数组(checkCombo ),包含在该组合的方块中找到的所有值。</p><p id="4702" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一旦checkCombo包含所有3个值，if语句就会检查checkCombo中的每个“条目”是X还是都是O。如果是这样，有人赢了，内部的If语句决定了赢的玩家是X还是O。</p><p id="e48b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这样，我们的游戏逻辑就完成了！</p><p id="4d65" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，不运行应用程序并进行测试/调试就完成所有这些是不现实的。所以一定要在你编码的时候运行你的应用程序，这样你就能看到什么有效，什么无效。我只是想把它放在这里，因为到目前为止我只展示了文本编辑器和图表。我使用React组件工具，并观察我的道具，以确保它们在我需要时也发生变化。</p><h1 id="c28a" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">是时候设计风格和添加功能了</h1><p id="2b52" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">为了让我们离开地面，我在Square组件中添加了一些CSS。我更改了颜色、大小和边框，然后将文本框中的文本居中，并放大了字体大小。我还为App组件的主体添加了灰色背景。这是我目前得到的信息:</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mv"><img src="../Images/49654dbe68bc038af58e414bcfeea263.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9jo86YY0MO4owrgqaFymTg.png"/></div></div></figure><p id="f203" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">也就是说:</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mw"><img src="../Images/14511569c319118a390288f6a3b68d2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0aCDrUSg9J8w2TMUpEg_RA.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">还不太像井字游戏</figcaption></figure><p id="ceda" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">显而易见的下一步是将这些方块放入网格中。我们可以用flexbox来做，但是我个人认为用CSS <strong class="jx io"> <em class="mx"> grid </em> </strong>来做一个网格是最有意义的。为了创建网格，我们需要处理位于Board组件中的容器元素:</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div class="gh gi my"><img src="../Images/8ec80f177e6f79949162ee656a07e084.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*9OEdOhvPhPBO1r7KpC4qXg.png"/></div></figure><p id="cf15" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于那些以前没有使用过网格的人来说，通过将display设置为grid，然后指定你想要的每一列和每一行的宽度，我们有效地在网格的每个区域放置了9个正方形。在这种情况下，我把它们做得比正方形本身稍大一点，以便把它们分开:</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mk"><img src="../Images/a946c780fc306af5c2a134e8bb9b32f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S3TKCLopRd4RgEvjY_8SCQ.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">这还差不多，差不多了</figcaption></figure><p id="5078" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，让我们通过在游戏组件内弯曲其父容器，将棋盘置于页面中央:</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/3a2a47d4a2f7d6aa9b7f47b239223f61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*1eYY9bPEAJDR1S_Poo2tIg.png"/></div></figure><p id="a56d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在顶部添加了20px的边距后，我们有了一个居中的、有效的井字游戏板:</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mw"><img src="../Images/15f10f5a915d4c7265aa5772cc7ea994.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lWB-A6Gp6Ifo0HH7ZoS9ZA.png"/></div></div></figure><p id="7c1f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这看起来不错，但是除了通过观察，目前没有办法知道轮到谁了，或者谁赢了，我们还需要一种方法来将游戏重置回初始状态。让我们添加一些最终功能，玩一些经典的井字游戏。</p><p id="3730" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我们应该添加一种方法来判断该轮到谁了。我将在左侧添加一个O，在右侧添加一个X，根据isXTurn状态，我将用边框突出显示这两个中的一个。</p><p id="5769" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我的游戏组件中的渲染方法现在看起来像这样:</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi na"><img src="../Images/91d4308c078c0b20cab4b3a506b93c67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JfZDp-Prdr81m2h3BmMfGg.png"/></div></div></figure><p id="9ec1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我在棋盘的上方和下方添加了一个<div>,并根据三元条件为每个棋盘指定了类名，以便根据轮到X还是O来来回回地切换样式。</div></p><p id="df6d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是我的意思(边框从X到O来回):</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mw"><img src="../Images/90a4b97021fef39bc6aa0a167cc7203b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uWqxU2cerj6CveFMZBCmGw.png"/></div></div></figure><p id="c70e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是我添加到游戏元素中的CSS，使它看起来像这样:</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mt"><img src="../Images/912537275be7c25ad33d26152f53d31a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KJDLptPUQ3DZBagOW8LlsQ.png"/></div></div></figure><p id="1167" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，让我们来提醒玩家，当有人做出一个胜利的组合。我们已经有了获胜者状态，所以当X或O获胜时，我们将在相应的一方下面放置一条消息。</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nb"><img src="../Images/23d557306cd32ef6ffbe68537953d16b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CWuxDWGCRrLrf7mek3umiA.png"/></div></div></figure><p id="0a5a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里，我在棋盘两边的每个<div>上添加了2个<span>元素。一个<span>保存X或O，另一个要么什么都不保存，要么保存一个表示“Wins”的字符串。我再次使用了三元条件，除了不是为了类名/样式的目的而使用它，而是用它来确定某些文本是否可见。</span></span></div></p><p id="02f1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是我想要的结果:</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mw"><img src="../Images/fc020955f57b0853edc32c1b72b930ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jJNZmwLFk84-r-e2YPTbYw.png"/></div></div></figure><p id="56a5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是我为游戏组件更改/添加的CSS，以获得上述结果:</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nc"><img src="../Images/9b98cb569ac6e5bcfd4c5bcd620247cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*OnKnOysq3AI8_fJ7Uh0vbA.png"/></div></div></figure><p id="916a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，我希望有一个按钮，重置游戏。我将把它添加到游戏组件中，并把它放在左上角:</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nd"><img src="../Images/a5f55c360ad453bc4cfebac5c964c1ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F0pS43mkzHueuPTCV_Y-NQ.png"/></div></div></figure><p id="73a8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以看到我在封装的<div>顶部添加了一个按钮，单击它会调用上面的一个函数，名为handleReset。handleReset所做的只是将每个状态恢复到初始设置，有效地重启游戏。</div></p><p id="1c55" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是(目前已经完成的)带有新安装的“重置游戏”按钮的应用程序:</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ne"><img src="../Images/3fafcacd34e6a8005e8c3aebd6614bfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QtQvScPaFe4HGeP-CiWf-A.png"/></div></div></figure><p id="8fab" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后我应用的最后一个CSS:</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/843713f6d0ee04289843c19c326a0181.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*e-tlb_kdkRhp1LUe5a9_IA.png"/></div></figure><p id="4268" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我不喜欢单击按钮后出现的紫色框，所以我将焦点的轮廓改为none，其余的属性我认为是不言自明的。</p><p id="4b46" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就结束了用React和CSS构建井字游戏的演示——结合了grid和flexbox。</p><p id="55d8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是实际游戏的GIF图:</p><figure class="lw lx ly lz gt jo"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">很有可能是O的第三招，我知道</figcaption></figure><p id="f004" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你不知何故做到了这一步，我希望我的写作风格足够容易让你跟上，我真诚地希望它能帮助你了解更多关于React、CSS grid或flexbox，或者构建简单游戏的知识。如果你感兴趣，我已经在这里链接了Github回购<a class="ae ni" href="https://github.com/tfunk2/tic-tac-toe-tyler" rel="noopener ugc nofollow" target="_blank">。感谢您的阅读，继续努力吧！</a></p></div></div>    
</body>
</html>