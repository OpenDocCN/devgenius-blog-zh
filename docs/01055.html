<html>
<head>
<title>Spring Boot Application Load Balancing with Nginx (and Docker)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Nginx(和 Docker)实现 Spring Boot 应用负载平衡</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/load-balancing-a-spring-boot-application-with-nginx-and-docker-e701f74c011d?source=collection_archive---------0-----------------------#2020-06-23">https://blog.devgenius.io/load-balancing-a-spring-boot-application-with-nginx-and-docker-e701f74c011d?source=collection_archive---------0-----------------------#2020-06-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/357d2e23d3c06f62492504352a7778a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*PvkRnEJGvll0kmGV95q9Ag.png"/></div></figure><p id="7538" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这篇文章中，我将尝试解释我们如何简单地部署一个 Nginx 服务器来在同一个 Spring Boot 应用程序的实例之间进行请求负载平衡。我们将在 Docker 环境中运行我们的配置。</p><h1 id="1367" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">应用程序</h1><p id="984a" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">我们的应用程序是一个非常简单的 Spring Boot Web 应用程序，使用的是 Kotlin，并不复杂。它仅由 RestController 构成。</p><p id="4632" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">它公开了两个方法，<em class="lv"> getResult() </em>返回控制器存储的数据；鉴于<em class="lv"> updateData() </em>使客户端能够更新数据。不用说，在 Spring Bean 中存储状态并不是一个好主意，但是为了简化这个例子，我们可以省略它。</p><p id="645d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">正如我提到的，逻辑不是超级有趣，但无论如何你可以在下面找到控制器代码。</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="e121" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您可以在端口 8080 上构建并运行应用程序。</p><h1 id="f857" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">DockerFile 文件</h1><p id="d482" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">下面您可以看到一个简单的 docker 文件，它将我们的应用程序部署到一个 docker 映像中。</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="f86f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">DockerFile 从构建目录中复制应用程序 JAR 并配置入口点。</p><h1 id="6511" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">负载平衡的配置</h1><p id="d93c" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated"><a class="ae mc" href="https://www.nginx.com/" rel="noopener ugc nofollow" target="_blank"> Nginx </a>是一款开源的 web 服务器，广泛用于负载均衡和反向代理服务器。在这个例子中，Nginx 将在我们应用程序的两个实例中充当负载平衡器。我们将首先为负载平衡配置 Nginx 然后将这个配置传递给 Docker 映像。</p><h1 id="e907" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">Nginx 配置</h1><p id="1d95" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">下面是一个非常简单的 Nginx 负载平衡配置:</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="ea84" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这个配置中，首先我们定义了两个上游服务器:一个用于端口 8080 上的服务 1，一个用于端口 8080 上的服务 2。(记住我们的 Spring Boot 应用程序运行在端口 8080 上)。</p><p id="402a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">此后，我们指示 Nginx 监听端口 9090，并将所有请求传递给我们的上游服务器。</p><h1 id="e671" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">Nginx Dockerfile 文件</h1><p id="fc3b" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">在下面的最小 docker 文件中，我们提取基本 nginx 映像，并用我们在上一节中创建的映像替换配置:</p><p id="ee34" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae mc" href="https://gist.github.com/itasyurt/42746090abb164948e8db9070cf29d98" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/itas yurt/42746090 abb 164948 E8 db 9070 cf 29d 98</a></p><h1 id="06d9" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">Docker 撰写</h1><p id="dff4" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">我们将使用 docker-compose.yml 组合我们的服务器实例和 Nginx，如下所示:</p><p id="8da6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae mc" href="https://gist.github.com/itasyurt/df4b77b8d013f82327f02b57ca7b8f2a" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/itas yurt/df 4b 77 b 8d 013 f 82327 f 02 b 57 ca 7 b 8 f2a</a></p><p id="828e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">以下是撰写文件中的一些亮点:</p><ul class=""><li id="15e8" class="md me iq jw b jx jy kb kc kf mf kj mg kn mh kr mi mj mk ml bi translated">我们在同一个端口上创建了公开端口 9090 的 Nginx 服务。Nginx 服务依赖于 service1 和 service2。注意，我们的 nginx 相关配置位于目录<em class="lv">中。/nginx </em>。</li><li id="3e6c" class="md me iq jw b jx mm kb mn kf mo kj mp kn mq kr mi mj mk ml bi translated">我们从同一个 docker 文件为我们的应用程序创建了两个服务。您可以注意到服务打开了端口 8181 和 8282。实际上，在后面运行这些服务器并不需要这样做，我们将使用这些端口来单独更改每台服务器的数据。</li><li id="51c1" class="md me iq jw b jx mm kb mn kf mo kj mp kn mq kr mi mj mk ml bi translated">服务名与 Nginx 配置中的相同。</li></ul><h1 id="8b5a" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">运行应用程序</h1><p id="058a" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">我们可以使用下面的命令构建并运行 docker 组合:</p><pre class="lw lx ly lz gt mr ms mt mu aw mv bi"><span id="f355" class="mw kt iq ms b gy mx my l mz na">docker-compose build</span><span id="aa24" class="mw kt iq ms b gy nb my l mz na">docker-compose up</span></pre><p id="72f6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">可以使用以下 Docker 命令验证容器的初始化:</p><pre class="lw lx ly lz gt mr ms mt mu aw mv bi"><span id="8379" class="mw kt iq ms b gy mx my l mz na">docker ps</span></pre><p id="e55c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">输出应该类似于:</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="d80d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我们可以通过 curl 访问我们的负载平衡应用程序并获取数据(最初是 10)。​</p><pre class="lw lx ly lz gt mr ms mt mu aw mv bi"><span id="7a53" class="mw kt iq ms b gy mx my l mz na">curl -XGET localhost:9090/api</span></pre><p id="d89e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">可以通过以下 curl 命令更新其中一台服务器上的数据:</p><pre class="lw lx ly lz gt mr ms mt mu aw mv bi"><span id="7106" class="mw kt iq ms b gy mx my l mz na">curl -XPUT localhost:8181/api?newData=19</span></pre><p id="b566" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请记住，我们已经公开了端口 8181，以便从外部访问服务器。请注意，我们也可以使用 9090，但这会修改随机服务器上的数据。</p><p id="2e48" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在我们更新了 service1 上的数据之后；根据 ngnix 选择的服务器，我们对 9090 的 GET 请求将开始返回 10 或 19 中的一个。因此，我们可以验证 Nginx 能够在不同的实例之间分发请求。</p><h1 id="ab4d" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">结论</h1><p id="fb25" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">简而言之，我们在本例中所做的是:</p><ol class=""><li id="3f1e" class="md me iq jw b jx jy kb kc kf mf kj mg kn mh kr nc mj mk ml bi translated">实现了一个简单的 Spring Boot 应用程序。</li><li id="ccba" class="md me iq jw b jx mm kb mn kf mo kj mp kn mq kr nc mj mk ml bi translated">配置一个 Nginx 负载平衡器，在应用程序的不同实例之间分配请求。</li><li id="ad39" class="md me iq jw b jx mm kb mn kf mo kj mp kn mq kr nc mj mk ml bi translated">组成 Docker 容器来创建环境。</li></ol><p id="d057" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">作为免责声明，请注意应用程序本身、nginx 配置和 docker 组合非常简单，仅用于演示目的。生产配置会更加复杂。</p><p id="c47c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">你可以在我的<a class="ae mc" href="https://github.com/itasyurt/lbsandbox/tree/lbexample" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到源代码。</p></div></div>    
</body>
</html>