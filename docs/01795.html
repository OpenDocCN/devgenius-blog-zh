<html>
<head>
<title>Building a Better Hybrid Data Access Solution in .NET with Entity Framework + RepoDb</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">中构建更好的混合数据访问解决方案。NET与实体框架+ RepoDb</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/building-a-better-hybrid-data-access-solution-in-net-with-entity-framework-repodb-d1039a648301?source=collection_archive---------2-----------------------#2020-07-12">https://blog.devgenius.io/building-a-better-hybrid-data-access-solution-in-net-with-entity-framework-repodb-d1039a648301?source=collection_archive---------2-----------------------#2020-07-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/e8afa8f60ff05c060226ac87b05694ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*o0A-KpGe_0bCr8mc.jpg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">上图是从这个<a class="ae jz" href="https://www.nappy.co/wp-content/uploads/2017/11/IMG_6291.jpg" rel="noopener ugc nofollow" target="_blank">环节</a>中截取的(由<a class="ae jz" href="https://www.instagram.com/__dahc/" rel="noopener ugc nofollow" target="_blank"> Dahc </a>拍摄)</figcaption></figure><p id="8ced" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">TL；DR:实体框架用起来是那么“好”，但是如果结合</strong> <a class="ae jz" href="https://repodb.net/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> RepoDb </strong> </a> <strong class="kc io">才是“最好”。请不要错过这颗宝石！💎</strong></p><p id="82be" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://github.com/dotnet/efcore" rel="noopener ugc nofollow" target="_blank">实体框架</a>，微软开发的ORM，是most最常用的ORM。NET开发人员。它与语言有足够的耦合，几乎所有的东西都以自己的方式实现。</p><p id="d160" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://repodb.net/" rel="noopener ugc nofollow" target="_blank"> RepoDb </a>是一个新的混合微表单库。NET，旨在满足微表单和宏表单(也称为完整表单)的缺失部分。当使用高级用例的高级特性时，它可以帮助开发人员简化软件开发。</p><blockquote class="ky kz la"><p id="4fb3" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">我是Mike，<a class="ae jz" href="https://repodb.net/" rel="noopener ugc nofollow" target="_blank"> RepoDb </a>的作者，开源贡献者，技术博主。我目前在Orsted A/S公司担任海上风能的高级应用架构师，or sted A/S是一家总部位于丹麦的可再生能源公司，被评为世界上最可持续发展的公司。我在RepoDb上花了很大力气来改善. NET中的数据访问空间。我个人请求你们对这个库的支持。我希望你分享，你博客和使用它。</p></blockquote><p id="d6c2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我写这篇文章是为了展示我们在使用实体框架为我们的企业设计和开发软件应用程序时收集到的现实问题，以及我们是如何解决这些问题的。本文涵盖的用例可以是“基础的”或“高级的”，但主要是那些大多数人“看不见”的。NET开发人员在软件开发过程中。虽然有些是在生产部署后实现的，但是由于时间限制、技术能力、有限的资源等原因，经常被忽略。</p><p id="8ada" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">免责声明:</strong>实体框架是我们组织中大量使用的ORM。但是主题可能会很大，涵盖所有内容，所以，我将这篇文章的内容仅限于我们的发现，以及我们如何用<a class="ae jz" href="https://repodb.net/" rel="noopener ugc nofollow" target="_blank"> RepoDb </a>解决这些问题。</p><h1 id="287c" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">基本问题经常被忽视💥</h1><p id="60bd" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">实体框架是一个具有庞大特性集的ORM。它在底层RDBMS之上实现了太多的抽象，导致开发的可控性降低，数据库功能/特性的可访问性受限。</p><p id="41ce" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是怎么回事？<strong class="kc io"> </strong>你作为开发者受限于实体框架能给你提供什么，而不是底层RDBMS能给你提供什么。</p><p id="2633" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是我所说的基本问题是什么呢？它与我们在开发过程中经常忽略的看不见的问题有关，因为我们编写的代码实现是按预期工作的。我的目标是展示与“以更稳健的方式写作”相比的“偏差”。</p><p id="81cf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看一些简单的真实场景和用例。</p><h2 id="7978" class="mi lg in bd lh mj mk dn ll ml mm dp lp kl mn mo lt kp mp mq lx kt mr ms mb mt bi translated">简单场景#1 —内联更新</h2><p id="bad3" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">假设您的目标是只更新包含15列的Customer表中的一列。你写了下面的代码。</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="0f24" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的代码看起来非常好，因为它的目的只是更新地址列。然而，在您不知情的情况下，Entity Framework会对Customer表的“所有”列进行更新。</p><p id="2eee" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">与并发冲突相关的风险是巨大的。在修改之前，手边的数据需要总是“最新的”，否则，脏的和过时的数据可能被提交到数据库。</p><p id="62a8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不推不发明；避免像下面的代码那样直接注入数据实体。通过这样做，其他列将被设置为null或空。</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="1c90" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另一方面，如果您的用例是动态的，那么通过创建一个单独的模型，只包含目标列并创建一个专用的DbSet <t>也是行不通的。</t></p><p id="542f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以最后一个办法是退回到原始SQL执行，迫使您放弃想要的代码流畅性。这是可行的，但你要慎重。</p><p id="b8e9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">RepoDb 以一种非常有效的方式解决了这个问题。我们更新行的方式是通过简单地只传递“键”和“目标列”来实现的。请看下面的代码。</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><h2 id="e0a2" class="mi lg in bd lh mj mk dn ll ml mm dp lp kl mn mo lt kp mp mq lx kt mr ms mb mt bi translated">简单场景#2 —删除</h2><p id="d61d" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">假设您想要删除一个现有记录。通过进行这样的活动，您首先需要对实际对象的引用，然后删除被引用的对象。简而言之，你需要从数据库做一个往返。</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="18b8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是理想的调用，但是实体框架中没有这样的方法。</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="9073" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是，如果您为“John Doe”投影primary/identity属性的值，您可以像下面的代码一样进行破解。</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="bf11" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://repodb.net/" rel="noopener ugc nofollow" target="_blank"> RepoDb </a>用下面的代码以更直接的方式解决了这个删除操作。两种方式都可以。</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><h2 id="787b" class="mi lg in bd lh mj mk dn ll ml mm dp lp kl mn mo lt kp mp mq lx kt mr ms mb mt bi translated">简单场景#3 —向上插入/合并</h2><p id="2bc9" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">假设您想要在数据库中插入一条新记录(如果尚不存在)或更新(如果已经存在)。这种用例在大多数情况下都非常重要。</p><p id="a707" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在实体框架的情况下，我们通常写下面的代码。</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="df2d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的代码从数据库进行了一次往返。首先检查数据是否存在，然后插入或更新数据。想象一下，如果这样的代码是应用程序中最繁忙的方法之一的一部分，它可能会比正常情况下使用两倍的服务器资源。</p><p id="0875" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://repodb.net/" rel="noopener ugc nofollow" target="_blank"> RepoDb </a>通过简单地调用“Merge”操作来解决这个upsert操作。数据库中没有往返，但它具有相同的功能。</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="f360" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">默认情况下，如果没有定义限定符，那么它使用表的主列。</p><blockquote class="ky kz la"><p id="340b" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">始终确保在限定符列上提供正确的索引，以进一步最大化RDBMS性能。</p></blockquote><h1 id="979b" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">“最佳”解决方案是使用Micro-ORM🙌</h1><p id="4db3" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">使用micro ORM，您“作为开发人员”控制开发流程。虽然一些基本操作是默认给出的，但主要是你负责大部分的实现。简而言之，你不局限于框架能给你提供什么。</p><p id="2ebe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://repodb.net/" rel="noopener ugc nofollow" target="_blank"> RepoDb </a>带给你的是介于微ORM和全ORM之间的解决方案。这些解决方案帮助您在开发过程中简化“事情”的实现(即:<a class="ae jz" href="https://repodb.net/feature/caching" rel="noopener ugc nofollow" target="_blank">第二层缓存</a>、<a class="ae jz" href="https://repodb.net/feature/tracing" rel="noopener ugc nofollow" target="_blank">追踪</a>、<a class="ae jz" href="https://repodb.net/feature/repositories" rel="noopener ugc nofollow" target="_blank">存储库</a>、<a class="ae jz" href="https://repodb.net/feature/batchoperations" rel="noopener ugc nofollow" target="_blank">批处理</a> / <a class="ae jz" href="https://repodb.net/feature/bulkoperations" rel="noopener ugc nofollow" target="_blank">批量操作</a>等)。</p><p id="2f39" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">试着看看像在数据库中插入数千甚至数百万行这样的事情。实体框架不能以非常快速和有效的方式处理这样的操作。用micro-ORM实现解决方案也是“非常繁琐”的。而在<a class="ae jz" href="https://repodb.net/" rel="noopener ugc nofollow" target="_blank"> RepoDb </a>中，它是一个开箱即用的特性。</p><p id="c067" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">毫无疑问，Entity Framework是一个非常好用的库，但是在某些情况下，它并不实用和/或不是最佳的。强烈建议将其与一个更健壮的框架结合使用，如<a class="ae jz" href="https://repodb.net/" rel="noopener ugc nofollow" target="_blank"> RepoDb </a>。我自己倾向于总是寻找和推荐一个“合适的”解决方案，而不是一个“合适的”解决方案。</p><p id="d183" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于实体框架的巨大特性，在使用实体框架时可能很少有隐藏的RDBMS可访问性限制。尽管如此，我们都需要“额外的”香料来炮制合适的解决方案。</p><h1 id="3636" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">边缘场景#1:批量操作超出了实体框架的范围，在RepoDb中是现成的🏃</h1><p id="aaee" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">众所周知，这些操作是一次性处理数千或数百万行的最快解决方案。虽然实体框架默认支持“批量”操作，但是这样的操作不足以满足巨大的数据量。</p><p id="e500" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">试着看一个吸引人的例子，下面是实际方法调用之间差异的一个非常基本的基准。(用100 K行7列Person表测试，批量操作:<a class="ae jz" href="https://repodb.net/operation/insertall" rel="noopener ugc nofollow" target="_blank"> RepoDb。InsertAll </a>，EF。AddRange，批量操作:<a class="ae jz" href="https://repodb.net/operation/bulkinsert" rel="noopener ugc nofollow" target="_blank"> RepoDb。批量插入</a>。</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi na"><img src="../Images/ac93c3efebe3e1b0d4ad7d16c58a41b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CnmrH6PtDBQZh2Y7GQ9f9A.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">以上项目可以在<a class="ae jz" href="https://github.com/mikependon/Tutorials/tree/master/Blogs/Medium/EntityFrameworkRepoDbCombination" rel="noopener ugc nofollow" target="_blank">这里</a>找到</figcaption></figure><p id="3701" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">想象一下，当使用真正的“批量”操作时，您的应用程序节省了多少“资源”和“时间”。它将18.96秒缩短到不到一秒。</p><p id="7dd4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">实现<a class="ae jz" href="https://repodb.net/feature/bulkoperations" rel="noopener ugc nofollow" target="_blank">批量</a>操作(即:<a class="ae jz" href="https://repodb.net/operation/bulkinsert" rel="noopener ugc nofollow" target="_blank">批量插入</a>、<a class="ae jz" href="https://repodb.net/operation/bulkupdate" rel="noopener ugc nofollow" target="_blank">批量合并</a>、<a class="ae jz" href="https://repodb.net/operation/bulkupdate" rel="noopener ugc nofollow" target="_blank">批量更新</a>和<a class="ae jz" href="https://repodb.net/operation/bulkdelete" rel="noopener ugc nofollow" target="_blank">批量删除</a>)需要开发人员花费太多的时间和精力来完成。它不仅繁琐，而且事后维护也很困难。在<a class="ae jz" href="https://repodb.net/" rel="noopener ugc nofollow" target="_blank"> RepoDb </a>中，它是SQL Server的一个现成特性。</p><p id="0eb6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了让你有一个高层次的概念，下图显示了<a class="ae jz" href="https://repodb.net/operation/bulkinsert" rel="noopener ugc nofollow" target="_blank">批量插入</a>操作的实际数据流。</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nb"><img src="../Images/c8d25bb235c64c8a2452770bf29eddb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8ZCfC6fsty6M1u8S.png"/></div></div></figure><p id="aebe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">只需点击下面的任何链接即可访问相应的图表。</p><ul class=""><li id="f92b" class="nc nd in kc b kd ke kh ki kl ne kp nf kt ng kx nh ni nj nk bi translated"><a class="ae jz" href="https://repodb.net/operation/bulkmerge" rel="noopener ugc nofollow" target="_blank">批量合并</a></li><li id="8138" class="nc nd in kc b kd nl kh nm kl nn kp no kt np kx nh ni nj nk bi translated"><a class="ae jz" href="https://repodb.net/operation/bulkupdate" rel="noopener ugc nofollow" target="_blank">批量更新</a></li><li id="9717" class="nc nd in kc b kd nl kh nm kl nn kp no kt np kx nh ni nj nk bi translated"><a class="ae jz" href="https://repodb.net/operation/bulkdelete" rel="noopener ugc nofollow" target="_blank">批量删除</a></li></ul><p id="eb46" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">也就是说，“批量”操作是值得拥有的特性。</p><h1 id="068e" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">边缘场景#2:目标操作的动态执行🚀</h1><p id="18bb" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">实体框架通过DbSet <t>与模型高度耦合，这样就限制了你进行有针对性的操作。在上面提到的基本问题(即:Inline-Update，Delete，Merge)中，我们“没有办法”用实体框架做最优的目标操作。</t></p><h2 id="30c9" class="mi lg in bd lh mj mk dn ll ml mm dp lp kl mn mo lt kp mp mq lx kt mr ms mb mt bi translated">目标操作</h2><p id="0448" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">这是一个原子和分钟的执行，只做事情的唯一目的。不多不少！</p><p id="0c72" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您在后端工作，从数据库中删除一行只需要编写如下SQL:</p><pre class="mu mv mw mx gt nq nr ns nt aw nu bi"><span id="67bd" class="mi lg in nr b gy nv nw l nx ny">&gt; DELETE FROM Table WHERE Id = @Id;</span></pre><p id="4bc6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是实体框架总是做下面的调用。</p><pre class="mu mv mw mx gt nq nr ns nt aw nu bi"><span id="3cd2" class="mi lg in nr b gy nv nw l nx ny">&gt; SELECT Id, ... FROM Table WHERE Id = @Id;<br/>&gt; DELETE FROM Table WHERE Id = @Id;</span></pre><p id="3670" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在删除对象之前，您总是需要获取对象的引用。这就是实现的方式，你别无选择，只能继承它。虽然编写定制的raw-SQL是一种选择，但它会影响代码流畅性的一致性。</p><blockquote class="ky kz la"><p id="b49b" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">“代码流畅性”有助于简化可读性和代码单元。对一些开发商来说，这是一种严格的“合规”。</p></blockquote><p id="e292" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如上所述，<a class="ae jz" href="https://repodb.net/" rel="noopener ugc nofollow" target="_blank"> RepoDb </a>用下面的代码解决这个问题(任何方法都可以)。</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><h2 id="8b4d" class="mi lg in bd lh mj mk dn ll ml mm dp lp kl mn mo lt kp mp mq lx kt mr ms mb mt bi translated">那么插入和更新特定的列怎么样呢？</h2><p id="f087" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">重要的是要注意，并不是表中的所有列都是“必需的”,这样才能将目标操作限制在它上面。</p><p id="0791" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在某些情况下，创建“初步记录”的场景是必要的。这个初步记录只需要表中的2到3列有初始值。虽然这项工作可以在实体框架中完成，但是没有办法针对特定的列，而且，你必须采用基于模型的方法进行操作。</p><p id="584a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">实体框架要求您填充模型，并将此模型(带有“所有”列)带回数据库。</p><p id="67ef" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另一方面，RepoDb 通过如下所示的“插入”调用解决了这个问题。动态对象可以在操作中传递，只针对所需的表和列。</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="4c37" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个用例也适用于“更新”操作。</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><h2 id="66a4" class="mi lg in bd lh mj mk dn ll ml mm dp lp kl mn mo lt kp mp mq lx kt mr ms mb mt bi translated">你喜欢重用一个模型来“投影”多个表吗？</h2><p id="d25d" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">这个场景在某些情况下非常重要。如果您提前计划了表的模式，并且您认为一些列可以共享，那么一个公共模型可以随时重用。实体框架不支持这一点，在<a class="ae jz" href="https://repodb.net/" rel="noopener ugc nofollow" target="_blank"> RepoDb </a>中，它是一个使用动态的现成特性。</p><p id="7c81" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">顺便说一句，dynamic有丰富的<a class="ae jz" href="https://repodb.net/" rel="noopener ugc nofollow" target="_blank"> RepoDb </a>，因此，你也可以“没有”模型地工作。</p><p id="b605" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">虽然一般来说，在C#中使用dynamic是很慢的。所以，无论你使用什么样的框架，都要这样做。请注意这一点。</p><h1 id="6507" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">边缘场景#3:你只是一个写原始SQL✍️️的专家</h1><p id="cac6" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">大多数开发人员倾向于编写SQL来应对ORM无法单独处理的用例。大多数情况下都是如此，因为大多数时候业务需求都是突发的。</p><p id="520e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，在敏捷的世界里，我们也需要一个快速变化的混合解决方案来解决这个问题。</p><p id="47e2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由社区请求触发，这就是“FromSqlRaw”和“FromSqlInterpolated”方法现在在实体框架中可用的原因。然而，实体框架不是为“动态”执行原始SQL语句而设计的。上面提到的方法是在它巨大的核心特性之上引入的。因此，实现是有限的，并且不如micro-ORM那样高效。</p><p id="0dd0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另一方面，Micro-ORM的核心实现是执行具有“高性能”和“高内存效率”的原始SQL，然后是利用这些核心实现的所需特性。</p><p id="2c9a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你把实体框架和微表单进行比较，就会发现在实现上有很大的不同。</p><h2 id="5d0c" class="mi lg in bd lh mj mk dn ll ml mm dp lp kl mn mo lt kp mp mq lx kt mr ms mb mt bi translated">FromSql*映射问题</h2><p id="f1a8" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">在实体框架中，上面提到的两种方法(即:FromRawSql，FromSqlInterpolated)都有映射问题，这也是一个健康辩论的候选。开发人员不能简单地动态执行raw-SQL，需要严格遵循一些要求(见下文)。</p><ul class=""><li id="6448" class="nc nd in kc b kd ke kh ki kl ne kp nf kt ng kx nh ni nj nk bi translated">模型必须是DbSet <t>的类型，仍然绑定到特定模型</t></li><li id="565d" class="nc nd in kc b kd nl kh nm kl nn kp no kt np kx nh ni nj nk bi translated">结果集属性必须始终存在于模型中</li></ul><p id="276b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您正在使用Person表(属于DbSet <person>)，那么您总是受限于该模型。raw-SQL的结果集必须与Person模型“always”相同。</person></p><p id="5bad" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面的代码将作为SQL <person>运行到DbSet <person>。</person></person></p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="f56a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是下面的代码作为SQL <customer>到DbSet <person>会失败。</person></customer></p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="c119" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面的异常被抛出。</p><pre class="mu mv mw mx gt nq nr ns nt aw nu bi"><span id="944a" class="mi lg in nr b gy nv nw l nx ny">System.InvalidOperationException: ‘The required column ‘XXX’ was not present in the results of a ‘FromSql’ operation.’</span></pre><p id="4998" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">执行仍然绑定到模型。另一个解决方案是在DbContext中创建一个新的DbSet <customer>属性。因此，这些要求限制了开发人员“动态地”执行查询。</customer></p><ul class=""><li id="13a9" class="nc nd in kc b kd ke kh ki kl ne kp nf kt ng kx nh ni nj nk bi translated">开发人员不能从SQL语句映射任何模型</li><li id="ba03" class="nc nd in kc b kd nl kh nm kl nn kp no kt np kx nh ni nj nk bi translated">SQL语句只能是DbSet <t>通用类型</t></li><li id="6b88" class="nc nd in kc b kd nl kh nm kl nn kp no kt np kx nh ni nj nk bi translated">无法添加额外的属性，尤其是对于执行存储过程返回的结果集</li></ul><p id="6853" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">RepoDb 被设计成动态ORM来满足这样的场景。想象一下，编写一个原始SQL，并以您喜欢的任何方式执行它。</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="3990" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">无论你的结果集有一个额外的列还是你的模型有一个额外的属性，一切都会被相应地处理。</p><p id="480d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">也就是说，实体框架和<a class="ae jz" href="https://repodb.net/" rel="noopener ugc nofollow" target="_blank"> RepoDb </a>可以带来一些好处。</p><h1 id="06ce" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">边缘场景#4:限制往返行程，只缓存它🐢 → 🐇</h1><p id="0819" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">实体框架默认不支持<a class="ae jz" href="https://repodb.net/feature/caching" rel="noopener ugc nofollow" target="_blank">二层缓存</a>。这是一个非常重要的特性，大多数解决方案都是需要的。这也是<a class="ae jz" href="https://repodb.net/" rel="noopener ugc nofollow" target="_blank"> RepoDb </a>存在至今的原因之一。</p><p id="2d13" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下图显示了第二层缓存的工作原理。</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nz"><img src="../Images/9c25e242bd79be99632c9ee5db8ceeb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eIpjPspSLjkG_8-5.png"/></div></div></figure><p id="7fe4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设你正在一个电子商务网站上工作，其中最繁忙的页面是“客户产品”页面。每个客户的产品列表不经常改变，或者在某些情况下，根本不改变。</p><p id="817a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您真的需要往返数据库来获取这些产品吗？解决方案就是简单地缓存它。由于Entity Framework在默认情况下不支持它，所以您必须创建一个定制的缓存机制，并在查询数据时注入它。</p><p id="7f7e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个特性是<a class="ae jz" href="https://repodb.net/" rel="noopener ugc nofollow" target="_blank"> RepoDb </a>的现成特性。只需简单地传递“cacheKey ”,一切都会像魔法一样工作。</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="cd90" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这些功能还解决了一些重要问题，如:</p><ul class=""><li id="788a" class="nc nd in kc b kd ke kh ki kl ne kp nf kt ng kx nh ni nj nk bi translated">查找表</li><li id="80d6" class="nc nd in kc b kd nl kh nm kl nn kp no kt np kx nh ni nj nk bi translated">连接多个表(客户端)</li></ul><blockquote class="ky kz la"><p id="38f1" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">通过跳过网上通信，效率和性能总是最好的。通过使用第二层缓存机制，可以节省95%到97%的执行时间。</p></blockquote><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oa"><img src="../Images/f33c4dec656c2bc9cf77a59b07c7fb73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ai0neF1MZzd5GwBTbJ7tsw.png"/></div></div></figure><h1 id="a4cf" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">边缘场景#5:简化多个RDBMS数据源的访问💥</h1><p id="16dd" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">在您的解决方案中，您可能使用SQL Server作为主要数据源。如果您的用例只是使用这样的RDBMS数据提供者，那就太好了。</p><p id="2074" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在一些用例中，数据存储在多个RDBMS数据源中。如果您的框架不够通用，那么将所有数据放入一个解决方案中是非常乏味的。尽管实体框架支持多个RDBMS数据提供者，但有时您会发现自己在使用它时遇到了困难。</p><p id="c7cd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，只要IDbConnection对象是打开的，micro-ORM就可以用于任何RDBMS数据源。</p><h2 id="5700" class="mi lg in bd lh mj mk dn ll ml mm dp lp kl mn mo lt kp mp mq lx kt mr ms mb mt bi translated">多数据源组合场景</h2><p id="cc1a" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">如果你有一个类似“体验API”的需求，并且想把所有东西捆绑在一个地方，那么在实体框架中实现它是相当困难的。</p><p id="bcb4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">想象一下，你在Azure SQL Server中有你的客户记录，在AWS PostgreSQL中有你的销售记录和订单记录，在Azure MySQL中有你的产品记录等等。对于实体框架来说，将数据整合到“体验API”中是相当困难的。</p><p id="ec64" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">只要您有一个到数据源的开放连接，RepoDb 就可以解决这种情况。请参见下面的示例代码。</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="1e38" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种实现可以以动态方式使用。您甚至可以将数据从一个RDBMS数据源带到另一个RDBMS数据源。</p><h2 id="faf9" class="mi lg in bd lh mj mk dn ll ml mm dp lp kl mn mo lt kp mp mq lx kt mr ms mb mt bi translated">多数据源集成场景</h2><p id="ac52" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">假设您想从SQL Server中生成一份报告，记录上个月驻留在PostgreSQL中的订单的所有客户记录。</p><p id="71dc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可以暂时从PostgreSQL的Sales表中复制数据，并将其大容量插入到SQL Server中。</p><p id="dcd1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在RepoDb中做这些事情既简单又直接。请参见下面的示例代码。</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="11ec" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果源端不支持fluent调用，那么可以将raw-SQL与目标端的fluent操作结合使用。</p><h1 id="400b" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">其他功能，未讨论🍕♻️</h1><p id="3985" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">实体框架中隐藏了许多东西，它们可能会影响应用程序的效率和性能。你只需要发现并找到一个更好的解决方案。</p><p id="9a77" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">RepoDb 是一个ORM，它最有可能给你解决方案，但是在编码方面有着类似EF的经验。</p><p id="8800" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是您可能会在实体框架上使用的特性。</p><ul class=""><li id="a082" class="nc nd in kc b kd ke kh ki kl ne kp nf kt ng kx nh ni nj nk bi translated"><a class="ae jz" href="https://repodb.net/feature/hints" rel="noopener ugc nofollow" target="_blank">提示/查询优化器</a></li><li id="ada3" class="nc nd in kc b kd nl kh nm kl nn kp no kt np kx nh ni nj nk bi translated"><a class="ae jz" href="https://repodb.net/feature/tracing" rel="noopener ugc nofollow" target="_blank">追踪</a></li><li id="b31d" class="nc nd in kc b kd nl kh nm kl nn kp no kt np kx nh ni nj nk bi translated"><a class="ae jz" href="https://repodb.net/feature/propertyhandlers" rel="noopener ugc nofollow" target="_blank">属性处理程序</a></li><li id="7610" class="nc nd in kc b kd nl kh nm kl nn kp no kt np kx nh ni nj nk bi translated"><a class="ae jz" href="https://repodb.net/feature/implicitmapping" rel="noopener ugc nofollow" target="_blank">隐式映射</a></li></ul><p id="0400" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面提到的未讨论的特性在我们的组织中被大量使用，以支持高级业务用例。大多数已经在生产环境中运行。</p><h1 id="9fe7" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">一条建议:不要做得太多，考虑使用其他库🐧</h1><p id="1e21" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">实体框架是一个用起来很酷的ORM。但是我试图解释实体框架“最好”和“不”使用的位置。不同的微表单存在于实体框架之上，以解决它不能做的事情。</p><p id="1520" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里是<a class="ae jz" href="https://repodb.net/" rel="noopener ugc nofollow" target="_blank"> RepoDb </a>的出处。引入这些特性是为了解决软件开发过程中遇到的不同问题(可能在不同的领域和行业中)。引入的解决方案得到了收集知识的人的验证和使用。</p><p id="dbcd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">OSS社区在那里帮助解决我们的问题。随着OSS库在市场上的出现，各种现实世界的问题很可能已经被收集、讨论和解决了。</p><p id="8978" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">说到底，使用什么取决于作为开发人员的您。要么创建一个定制的解决方案，要么利用已经公开提供的解决方案。时间就是金钱，努力就是知识！</p><h1 id="5ecc" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">总体结论👋</h1><p id="e3a8" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">以下是与本文相关的结论，我们希望您将它应用到自己的用例中。</p><ul class=""><li id="a0bc" class="nc nd in kc b kd ke kh ki kl ne kp nf kt ng kx nh ni nj nk bi translated">不要过度使用实体框架。毫无疑问，这是一个很酷的框架，但它有一些限制，本文将对此进行解释。如果你认为它在你的用例上不实用，那么把它和<a class="ae jz" href="https://repodb.net/feature/hints" rel="noopener ugc nofollow" target="_blank"> RepoDb </a>结合起来。</li><li id="c184" class="nc nd in kc b kd nl kh nm kl nn kp no kt np kx nh ni nj nk bi translated">总是花时间寻找正确的解决方案，OSS世界会帮助你。实体框架和<a class="ae jz" href="https://repodb.net/feature/hints" rel="noopener ugc nofollow" target="_blank"> RepoDb </a>无法提供其他解决方案。</li><li id="e851" class="nc nd in kc b kd nl kh nm kl nn kp no kt np kx nh ni nj nk bi translated"><a class="ae jz" href="https://repodb.net/feature/hints" rel="noopener ugc nofollow" target="_blank"> RepoDb </a>坦率直接；将为您提供您在软件开发中可能需要的混合解决方案。</li><li id="56dc" class="nc nd in kc b kd nl kh nm kl nn kp no kt np kx nh ni nj nk bi translated">在软件开发过程中，混合解决方案总是你能拥有的“最好”工具。</li></ul><p id="12b5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">~感谢您阅读本文！~ </strong>🙏🏻👍🕵</p></div></div>    
</body>
</html>