<html>
<head>
<title>Introduction to Regular Expression With Modern C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代C++正则表达式简介</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/introduction-to-regular-expression-with-modern-c-2d6e50e6d5a7?source=collection_archive---------10-----------------------#2020-08-09">https://blog.devgenius.io/introduction-to-regular-expression-with-modern-c-2d6e50e6d5a7?source=collection_archive---------10-----------------------#2020-08-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3865d50747ee3fd723ee1094c8f947d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ve2hl-T4y0lxpElxQxpbaQ.png"/></div></div></figure><p id="9fd1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到目前为止，正则表达式(或简称为regex)是现代C++中一个非常讨厌且被低估的话题。但与此同时，正确使用正则表达式可以省去您编写许多行代码的麻烦。如果你在这个行业呆了足够长的时间。如果不知道正则表达式，那么你将会失去20-30%的生产力。既然如此，我强烈推荐你学习regex，因为它是一次性投资(类似于<strong class="ka ir"> <em class="kw">学一次，随处写</em> </strong>的哲学)。</p><blockquote class="kx ky kz"><p id="4b12" class="jy jz kw ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><em class="iq"> /！\:本文已原创发表于我的</em> <a class="ae ld" href="http://www.vishalchovatiya.com/regex-c/" rel="noopener ugc nofollow" target="_blank"> <em class="iq">博客</em> </a> <em class="iq">。如果你有兴趣接收我的最新文章，</em> <a class="ae ld" href="http://eepurl.com/gDNybv" rel="noopener ugc nofollow" target="_blank"> <em class="iq">请报名参加我的简讯</em> </a> <em class="iq">。</em></p></blockquote><p id="b9ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最初，在本文中，我决定也包含regex-in-general。但是这没有意义，因为已经有人/教程在教regex方面比我做得更好。但是，我仍然留了一小部分来说明<a class="ae ld" href="http://www.vishalchovatiya.com/regex-c/#Motivation" rel="noopener ugc nofollow" target="_blank">动机</a> &amp; <a class="ae ld" href="http://www.vishalchovatiya.com/regex-c/#Learning_Regex" rel="noopener ugc nofollow" target="_blank">学习正则表达式</a>。在本文的其余部分，我将关注C++提供的使用regex的功能。如果你已经知道正则表达式，你可以用上面的思维导图作为复习。</p><p id="160f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">指针</em>:c++标准库提供了几种不同“风格”的正则表达式语法，但是默认风格(我在这里演示的是你应该一直使用的风格)是从<a class="ae ld" href="https://www.wikiwand.com/en/ECMAScript" rel="noopener ugc nofollow" target="_blank"> ECMAScript </a>的标准中大量借用的。</p><h1 id="cc99" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">动机</h1><ul class=""><li id="be7b" class="mc md iq ka b kb me kf mf kj mg kn mh kr mi kv mj mk ml mm bi translated">我知道它可怜又有些混乱的工具集。以下面的正则表达式模式为例，提取24小时格式的时间，即HH:MM。</li></ul><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="e949" class="mw lf iq ms b gy mx my l mz na">\b([01]?[0-9]|2[0-3]):([0-5]\d)\b</span></pre><ul class=""><li id="d240" class="mc md iq ka b kb kc kf kg kj nb kn nc kr nd kv mj mk ml mm bi translated">我是说！谁想用这个神秘的文本工作？T29】</li><li id="1df4" class="mc md iq ka b kb ne kf nf kj ng kn nh kr ni kv mj mk ml mm bi translated">无论你在想什么都是100%合理的。其实，<strong class="ka ir"> <em class="kw">我也因为同样的原因</em> </strong>耽误过两次学习正则表达式。但是，相信我，所有丑陋的东西都没有那么糟糕。</li><li id="a1d2" class="mc md iq ka b kb ne kf nf kj ng kn nh kr ni kv mj mk ml mm bi translated">我在这里描述的方法(<strong class="ka ir"> ↓ </strong>)不会花费超过2-3个小时来太直观地学习regex。学习之后，你会看到随着时间的推移，投资回报的复合效应。</li></ul><h1 id="bd06" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">学习正则表达式</h1><ul class=""><li id="6d0d" class="mc md iq ka b kb me kf mf kj mg kn mh kr mi kv mj mk ml mm bi translated">不要谷歌太多&amp;尝试分析哪个教程是最好的。其实不要浪费时间在这样的分析上。因为这样做没有意义。在这个时间点(嗯！如果你不知道正则表达式)真正重要的是“开始”，而不是“什么是最好的！”。</li><li id="2521" class="mc md iq ka b kb ne kf nf kj ng kn nh kr ni kv mj mk ml mm bi translated"><strong class="ka ir"> <em class="kw">直接去</em></strong><a class="ae ld" href="https://regexone.com/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="kw">【https://regexone.com】</em></strong></a><strong class="ka ir"><em class="kw">不用多想</em> </strong>。完成所有的课程。在这里相信我，我探索了很多文章，<a class="ae ld" href="https://www.udemy.com/course/regex-academy-an-introduction-to-text-parsing-sorcery/" rel="noopener ugc nofollow" target="_blank">课程</a>(&lt;=此篇免费，BTW) &amp;书籍。但是这是最好的不失去动力的开始。</li><li id="e36a" class="mc md iq ka b kb ne kf nf kj ng kn nh kr ni kv mj mk ml mm bi translated">在这之后，如果你还有胃口去解决更多的问题和练习。考虑以下链接:</li></ul><ol class=""><li id="7a77" class="mc md iq ka b kb kc kf kg kj nb kn nc kr nd kv nj mk ml mm bi translated"><a class="ae ld" href="http://regextutorials.com/" rel="noopener ugc nofollow" target="_blank">关于regextutorials.com的练习</a></li><li id="339f" class="mc md iq ka b kb ne kf nf kj ng kn nh kr ni kv nj mk ml mm bi translated"><a class="ae ld" href="https://www.hackerrank.com/domains/regex" rel="noopener ugc nofollow" target="_blank">hacker rank在regex上的练习题</a></li></ol><h1 id="3682" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><a class="ae ld" href="https://en.cppreference.com/w/cpp/regex/basic_regex" rel="noopener ugc nofollow" target="_blank">STD::regex</a>&amp;T24】STD::regex _ error举例</h1><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="bec1" class="mw lf iq ms b gy mx my l mz na">int main() {<br/>    try {<br/>        static const auto r = std::regex(R"(\)"); // Escape sequence error<br/>    } catch (const std::regex_error &amp;e) {<br/>        assert(strcmp(e.what(), "Unexpected end of regex when escaping.") == 0);<br/>        assert(e.code() == std::regex_constants::error_escape);<br/>    }<br/>    return EXIT_SUCCESS;<br/>}</span></pre><ul class=""><li id="0a3a" class="mc md iq ka b kb kc kf kg kj nb kn nc kr nd kv mj mk ml mm bi translated">你看！我使用的是<a class="ae ld" href="https://en.cppreference.com/w/cpp/language/string_literal" rel="noopener ugc nofollow" target="_blank">原始字符串文字</a>。您也可以使用普通字符串。但是，在这种情况下，您必须使用双反斜杠作为转义序列。</li><li id="e75c" class="mc md iq ka b kb ne kf nf kj ng kn nh kr ni kv mj mk ml mm bi translated">当前的<code class="fe nk nl nm ms b">std::regex</code>实现很慢(因为它需要在运行时创建正则表达式解释&amp;数据结构)，臃肿并且不可避免地需要堆分配(不支持分配器)。所以，<strong class="ka ir"> <em class="kw">如果你在一个循环中使用</em></strong><code class="fe nk nl nm ms b"><strong class="ka ir"><em class="kw">std::regex</em></strong></code><strong class="ka ir"><em class="kw"/></strong>就要当心了(参见<a class="ae ld" href="https://www.youtube.com/watch?v=7hfSyxNxFfo" rel="noopener ugc nofollow" target="_blank">c++ Weekly-Ep 74-STD::regex optimize by简森·特纳</a>)。另外，我认为只有一个成员函数可能有用，那就是<a class="ae ld" href="https://en.cppreference.com/w/cpp/regex/basic_regex/mark_count" rel="noopener ugc nofollow" target="_blank">STD::regex::mark _ count()</a>，它返回许多捕获组。</li><li id="5fee" class="mc md iq ka b kb ne kf nf kj ng kn nh kr ni kv mj mk ml mm bi translated">此外，如果您在运行时使用多个字符串来创建regex模式。然后你可能需要<a class="ae ld" href="http://www.vishalchovatiya.com/7-best-practices-for-exception-handling-in-cpp-with-example/" rel="noopener ugc nofollow" target="_blank">异常处理</a>即<code class="fe nk nl nm ms b">std::regex_error</code>来验证其正确性。</li></ul><h1 id="cb8b" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><a class="ae ld" href="https://en.cppreference.com/w/cpp/regex/regex_search" rel="noopener ugc nofollow" target="_blank"> std::regex_search </a>示例</h1><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="0b5c" class="mw lf iq ms b gy mx my l mz na">int main() {<br/>    const string input = "ABC:1-&gt;   PQR:2;;;   XYZ:3&lt;&lt;&lt;"s;<br/>    const regex r(R"((\w+):(\w+);)");<br/>    smatch m;</span><span id="57e8" class="mw lf iq ms b gy nn my l mz na">    if (regex_search(input, m, r)) {<br/>        assert(m.size() == 3);<br/>        assert(m[0].str() == "PQR:2;");                // Entire match<br/>        assert(m[1].str() == "PQR");                   // Substring that matches 1st group<br/>        assert(m[2].str() == "2");                     // Substring that matches 2nd group<br/>        assert(m.prefix().str() == "ABC:1-&gt;   ");      // All before 1st character match<br/>        assert(m.suffix().str() == ";;   XYZ:3&lt;&lt;&lt;");   // All after last character match</span><span id="39d4" class="mw lf iq ms b gy nn my l mz na">        // for (string &amp;&amp;str : m) { // Alternatively. You can also do<br/>        //     cout &lt;&lt; str &lt;&lt; endl;<br/>        // }<br/>    }<br/>    return EXIT_SUCCESS;<br/>}</span></pre><ul class=""><li id="1d6e" class="mc md iq ka b kb kc kf kg kj nb kn nc kr nd kv mj mk ml mm bi translated"><code class="fe nk nl nm ms b">smatch</code>是<a class="ae ld" href="https://en.cppreference.com/w/cpp/regex/match_results" rel="noopener ugc nofollow" target="_blank"> std::match_results </a>的专门化，它存储关于要检索的匹配的信息。</li></ul><h1 id="a070" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><a class="ae ld" href="https://en.cppreference.com/w/cpp/regex/regex_match" rel="noopener ugc nofollow" target="_blank">标准::正则表达式_匹配</a>示例</h1><ul class=""><li id="b5e5" class="mc md iq ka b kb me kf mf kj mg kn mh kr mi kv mj mk ml mm bi translated">你可能在每本regex书中总能找到的简短而有趣的例子是电子邮件验证。这就是我们的<code class="fe nk nl nm ms b">std::regex_match</code>功能完美契合的地方。</li></ul><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="7441" class="mw lf iq ms b gy mx my l mz na">bool is_valid_email_id(string_view str) {<br/>    static const regex r(R"(\w+@\w+\.(?:com|in))");<br/>    return regex_match(str.data(), r);<br/>}</span><span id="f999" class="mw lf iq ms b gy nn my l mz na">int main() {<br/>    assert(is_valid_email_id("vishalchovatiya@ymail.com") == true);<br/>    assert(is_valid_email_id("@abc.com") == false);<br/>    return EXIT_SUCCESS;<br/>}</span></pre><ul class=""><li id="ade2" class="mc md iq ka b kb kc kf kg kj nb kn nc kr nd kv mj mk ml mm bi translated">我知道这不是完全证明电子邮件验证正则表达式模式。但我的意图也不是那样。</li><li id="13bc" class="mc md iq ka b kb ne kf nf kj ng kn nh kr ni kv mj mk ml mm bi translated">你应该想知道为什么我用了<code class="fe nk nl nm ms b">std::regex_match</code>！不是<code class="fe nk nl nm ms b">std::regex_search</code>！基本原理很简单<code class="fe nk nl nm ms b"><strong class="ka ir"><em class="kw">std::regex_match</em></strong></code> <strong class="ka ir"> <em class="kw">匹配整个输入序列</em> </strong>。</li><li id="e69a" class="mc md iq ka b kb ne kf nf kj ng kn nh kr ni kv mj mk ml mm bi translated">另外，值得注意的是<strong class="ka ir"> <em class="kw">静态正则表达式对象避免了每次</em> </strong>函数进入时构造(“编译/解释”)一个新的正则表达式对象。</li><li id="d396" class="mc md iq ka b kb ne kf nf kj ng kn nh kr ni kv mj mk ml mm bi translated">上面小小的代码片段中的<strong class="ka ir"> <em class="kw">具有讽刺意味的是，它产生了大约30k行汇编</em> </strong>代码，这些代码也带有<code class="fe nk nl nm ms b">-O3</code>标志。这太荒谬了。但是不要担心，这已经被带到了ISO C++社区。不久我们可能会得到一些更新。与此同时，我们确实有其他选择(在本文末尾提到)。</li></ul><h1 id="cf21" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><a class="ae ld" href="https://en.cppreference.com/w/cpp/regex/regex_match" rel="noopener ugc nofollow" target="_blank">STD::regex _ match</a>&amp;<a class="ae ld" href="https://en.cppreference.com/w/cpp/regex/regex_search" rel="noopener ugc nofollow" target="_blank">STD::regex _ search</a>的区别？</h1><ul class=""><li id="e7f2" class="mc md iq ka b kb me kf mf kj mg kn mh kr mi kv mj mk ml mm bi translated">你可能想知道为什么我们有两个功能做几乎相同的工作？甚至我最初也有怀疑。但是，看了一遍又一遍cppreference提供的描述。我找到了答案。为了解释这个答案，我创建了这个例子(显然是在StackOverflow的帮助下):</li></ul><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="45e7" class="mw lf iq ms b gy mx my l mz na">int main() {<br/>    const string input = "ABC:1-&gt;   PQR:2;;;   XYZ:3&lt;&lt;&lt;"s;<br/>    const regex r(R"((\w+):(\w+);)");<br/>    smatch m;</span><span id="3e9e" class="mw lf iq ms b gy nn my l mz na">    assert(regex_match(input, m, r) == false);</span><span id="a589" class="mw lf iq ms b gy nn my l mz na">    assert(regex_search(input, m, r) == true &amp;&amp; m.ready() == true &amp;&amp; m[1] == "PQR");</span><span id="4a3d" class="mw lf iq ms b gy nn my l mz na">    return EXIT_SUCCESS;<br/>}</span></pre><ul class=""><li id="4487" class="mc md iq ka b kb kc kf kg kj nb kn nc kr nd kv mj mk ml mm bi translated"><code class="fe nk nl nm ms b"><strong class="ka ir"><em class="kw">std::regex_match</em></strong></code> <strong class="ka ir"> <em class="kw">只有当整个输入序列都匹配时才会返回</em> </strong> <code class="fe nk nl nm ms b"><strong class="ka ir"><em class="kw">true</em></strong></code> <strong class="ka ir"> <em class="kw">，而</em> </strong> <code class="fe nk nl nm ms b"><strong class="ka ir"><em class="kw">std::regex_search</em></strong></code> <strong class="ka ir"> <em class="kw">即使只有一个子序列匹配正则表达式也会成功。</em> </strong></li></ul><h1 id="d0f9" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><a class="ae ld" href="https://en.cppreference.com/w/cpp/regex/regex_iterator" rel="noopener ugc nofollow" target="_blank"> std::regex_iterator </a>示例</h1><ul class=""><li id="a8f8" class="mc md iq ka b kb me kf mf kj mg kn mh kr mi kv mj mk ml mm bi translated">当您需要关于匹配的&amp;子匹配的非常详细的信息时，<code class="fe nk nl nm ms b">std::regex_iterator</code>非常有用。</li></ul><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="2291" class="mw lf iq ms b gy mx my l mz na">#define C_ALL(X) cbegin(X), cend(X)</span><span id="23db" class="mw lf iq ms b gy nn my l mz na">int main() {<br/>    const string input = "ABC:1-&gt;   PQR:2;;;   XYZ:3&lt;&lt;&lt;"s;<br/>    const regex r(R"((\w+):(\d))");</span><span id="105f" class="mw lf iq ms b gy nn my l mz na">    const vector&lt;smatch&gt; matches{<br/>        sregex_iterator{C_ALL(input), r},<br/>        sregex_iterator{}<br/>    };</span><span id="643f" class="mw lf iq ms b gy nn my l mz na">    assert(matches[0].str(0) == "ABC:1" <br/>        &amp;&amp; matches[0].str(1) == "ABC" <br/>        &amp;&amp; matches[0].str(2) == "1");</span><span id="58af" class="mw lf iq ms b gy nn my l mz na">    assert(matches[1].str(0) == "PQR:2" <br/>        &amp;&amp; matches[1].str(1) == "PQR" <br/>        &amp;&amp; matches[1].str(2) == "2");</span><span id="b973" class="mw lf iq ms b gy nn my l mz na">    assert(matches[2].str(0) == "XYZ:3" <br/>        &amp;&amp; matches[2].str(1) == "XYZ" <br/>        &amp;&amp; matches[2].str(2) == "3");</span><span id="5089" class="mw lf iq ms b gy nn my l mz na">    return EXIT_SUCCESS;<br/>}</span></pre><ul class=""><li id="cb20" class="mc md iq ka b kb kc kf kg kj nb kn nc kr nd kv mj mk ml mm bi translated">早期(在C++11中)有一个限制，使用<code class="fe nk nl nm ms b">std::regex_interator</code>不允许被临时正则表达式对象调用。该错误已经用来自C++14的重载进行了纠正。</li></ul><h1 id="95cf" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><a class="ae ld" href="https://en.cppreference.com/w/cpp/regex/regex_token_iterator" rel="noopener ugc nofollow" target="_blank">STD::regex _ token _ iterator</a>示例</h1><ul class=""><li id="21aa" class="mc md iq ka b kb me kf mf kj mg kn mh kr mi kv mj mk ml mm bi translated"><code class="fe nk nl nm ms b">std::regex_token_iterator</code>是您将在80%的时间里使用的工具。与<code class="fe nk nl nm ms b">std::regex_iterator</code>相比略有不同。<strong class="ka ir"><em class="kw"/></strong><code class="fe nk nl nm ms b"><strong class="ka ir"><em class="kw">std::regex_iterator</em></strong></code><strong class="ka ir"><em class="kw"/></strong><code class="fe nk nl nm ms b"><strong class="ka ir"><em class="kw">std::regex_token_iterator</em></strong></code><strong class="ka ir"><em class="kw">的区别在于</em> </strong></li><li id="4be6" class="mc md iq ka b kb ne kf nf kj ng kn nh kr ni kv mj mk ml mm bi translated"><code class="fe nk nl nm ms b"><strong class="ka ir"><em class="kw">std::regex_iterator</em></strong></code> <strong class="ka ir"> <em class="kw">点匹配结果。</em> </strong></li><li id="3651" class="mc md iq ka b kb ne kf nf kj ng kn nh kr ni kv mj mk ml mm bi translated"><code class="fe nk nl nm ms b"><strong class="ka ir"><em class="kw">std::regex_token_iterator</em></strong></code> <strong class="ka ir"> <em class="kw">分次赛。</em>T47】</strong></li><li id="19cb" class="mc md iq ka b kb ne kf nf kj ng kn nh kr ni kv mj mk ml mm bi translated">在<code class="fe nk nl nm ms b">std::regex_token_iterator</code>中，每个迭代器只包含一个匹配的结果。</li></ul><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="1397" class="mw lf iq ms b gy mx my l mz na">#define C_ALL(X) cbegin(X), cend(X)</span><span id="ef40" class="mw lf iq ms b gy nn my l mz na">int main() {<br/>    const string input = "ABC:1-&gt;   PQR:2;;;   XYZ:3&lt;&lt;&lt;"s;<br/>    const regex r(R"((\w+):(\d))");</span><span id="e8dd" class="mw lf iq ms b gy nn my l mz na">    // Note: vector&lt;string&gt; here, unlike vector&lt;smatch&gt; as in std::regex_iterator<br/>    const vector&lt;string&gt; full_match{<br/>        sregex_token_iterator{C_ALL(input), r, 0}, // Mark `0` here i.e. whole regex match<br/>        sregex_token_iterator{}<br/>    };<br/>    assert((full_match == decltype(full_match){"ABC:1", "PQR:2", "XYZ:3"}));</span><span id="3d87" class="mw lf iq ms b gy nn my l mz na">    const vector&lt;string&gt; cptr_grp_1st{<br/>        sregex_token_iterator{C_ALL(input), r, 1}, // Mark `1` here i.e. 1st capture group<br/>        sregex_token_iterator{}<br/>    };<br/>    assert((cptr_grp_1st == decltype(cptr_grp_1st){"ABC", "PQR", "XYZ"}));</span><span id="0cf0" class="mw lf iq ms b gy nn my l mz na">    const vector&lt;string&gt; cptr_grp_2nd{<br/>        sregex_token_iterator{C_ALL(input), r, 2}, // Mark `2` here i.e. 2nd capture group<br/>        sregex_token_iterator{}<br/>    };<br/>    assert((cptr_grp_2nd == decltype(cptr_grp_2nd){"1", "2", "3"}));</span><span id="a902" class="mw lf iq ms b gy nn my l mz na">    return EXIT_SUCCESS;<br/>}</span></pre><h1 id="a15a" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">与<a class="ae ld" href="https://en.cppreference.com/w/cpp/regex/regex_token_iterator" rel="noopener ugc nofollow" target="_blank">STD::regex _ token _ iterator</a>反向匹配</h1><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="69ce" class="mw lf iq ms b gy mx my l mz na">#define C_ALL(X) cbegin(X), cend(X)</span><span id="b21c" class="mw lf iq ms b gy nn my l mz na">int main() {<br/>    const string input = "ABC:1-&gt;   PQR:2;;;   XYZ:3&lt;&lt;&lt;"s;<br/>    const regex r(R"((\w+):(\d))");</span><span id="d4eb" class="mw lf iq ms b gy nn my l mz na">    const vector&lt;string&gt; inverted{<br/>        sregex_token_iterator{C_ALL(input), r, -1}, // `-1` = parts that are not matched<br/>        sregex_token_iterator{}<br/>    };<br/>    assert((inverted == decltype(inverted){<br/>                            "",<br/>                            "-&gt;   ",<br/>                            ";;;   ",<br/>                            "&lt;&lt;&lt;",<br/>                        }));</span><span id="42c9" class="mw lf iq ms b gy nn my l mz na">    return EXIT_SUCCESS;<br/>}</span></pre><h1 id="406b" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><a class="ae ld" href="https://en.cppreference.com/w/cpp/regex/regex_replace" rel="noopener ugc nofollow" target="_blank"> std::regex_replace </a>示例</h1><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="0e6f" class="mw lf iq ms b gy mx my l mz na">string transform_pair(string_view text, regex_constants::match_flag_type f = {}) {<br/>    static const auto r = regex(R"((\w+):(\d))");<br/>    return regex_replace(text.data(), r, "$2", f);<br/>}</span><span id="b2ce" class="mw lf iq ms b gy nn my l mz na">int main() {<br/>    assert(transform_pair("ABC:1, PQR:2"s) == "1, 2"s);</span><span id="4c06" class="mw lf iq ms b gy nn my l mz na">    // Things that aren't matched are not copied<br/>    assert(transform_pair("ABC:1, PQR:2"s, regex_constants::format_no_copy) == "12"s);<br/>    return EXIT_SUCCESS;<br/>}</span></pre><ul class=""><li id="c931" class="mc md iq ka b kb kc kf kg kj nb kn nc kr nd kv mj mk ml mm bi translated">你看，在transform_pair的第二次调用中，我们传递了标志<code class="fe nk nl nm ms b">std::regex_constants::format_no_copy</code>,它建议不要复制不匹配的东西。在<a class="ae ld" href="https://en.cppreference.com/w/cpp/regex/match_flag_type" rel="noopener ugc nofollow" target="_blank"> std::regex_constant </a>下有很多这样有用的标志。</li><li id="0d7e" class="mc md iq ka b kb ne kf nf kj ng kn nh kr ni kv mj mk ml mm bi translated">此外，我们还构造了保存结果的新字符串。但是如果我们不想要一个新的字符串呢？而是希望将结果直接附加到某个地方(可能是容器或流或已经存在的字符串)。你猜怎么着！标准库也通过重载<code class="fe nk nl nm ms b">std::regex_replace</code>解决了这个问题，如下所示:</li></ul><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="c464" class="mw lf iq ms b gy mx my l mz na">int main() {<br/>    const string input = "ABC:1-&gt;   PQR:2;;;   XYZ:3&lt;&lt;&lt;"s;<br/>    const regex r(R"(-|&gt;|&lt;|;| )");</span><span id="21e5" class="mw lf iq ms b gy nn my l mz na">    // Prints "ABC:1     PQR:2      XYZ:3   "<br/>    regex_replace(ostreambuf_iterator&lt;char&gt;(cout), C_ALL(input), r, " ");</span><span id="356f" class="mw lf iq ms b gy nn my l mz na">    return EXIT_SUCCESS;<br/>}</span></pre><h1 id="bbef" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">用例</h1><h1 id="a673" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">用分隔符拆分字符串</h1><ul class=""><li id="8e21" class="mc md iq ka b kb me kf mf kj mg kn mh kr mi kv mj mk ml mm bi translated">虽然<code class="fe nk nl nm ms b">std::strtok</code>是最适合这样任务的&amp;最佳人选。但是为了演示如何使用regex:</li></ul><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="d6e0" class="mw lf iq ms b gy mx my l mz na">#define C_ALL(X) cbegin(X), cend(X)</span><span id="ec3b" class="mw lf iq ms b gy nn my l mz na">vector&lt;string&gt; split(const string&amp; str, string_view pattern) {<br/>    const auto r = regex(pattern.data());<br/>    return vector&lt;string&gt;{<br/>        sregex_token_iterator(C_ALL(str), r, -1),<br/>        sregex_token_iterator()<br/>    };<br/>}</span><span id="5e24" class="mw lf iq ms b gy nn my l mz na">int main() {<br/>    assert((split("/root/home/vishal", "/")<br/>                == vector&lt;string&gt;{"", "root", "home", "vishal"}));<br/>    return EXIT_SUCCESS;<br/>}</span></pre><h1 id="03a9" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">修剪字符串中的空白</h1><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="d7b5" class="mw lf iq ms b gy mx my l mz na">string trim(string_view text) {<br/>    static const auto r = regex(R"(\s+)");<br/>    return regex_replace(text.data(), r, "");<br/>}</span><span id="9ab1" class="mw lf iq ms b gy nn my l mz na">int main() {<br/>    assert(trim("12   3 4      5"s) == "12345"s);<br/>    return EXIT_SUCCESS;<br/>}</span></pre><h1 id="f8f0" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">从文件中查找包含或不包含某些单词的行</h1><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="272a" class="mw lf iq ms b gy mx my l mz na">string join(const vector&lt;string&gt;&amp; words, const string&amp; delimiter) {<br/>    return accumulate(next(begin(words)), end(words), words[0],<br/>            [&amp;delimiter](string&amp; p, const string&amp; word)<br/>            {<br/>                return p + delimiter + word;<br/>            });<br/>}</span><span id="2946" class="mw lf iq ms b gy nn my l mz na">vector&lt;string&gt; lines_containing(const string&amp; file, const vector&lt;string&gt;&amp; words) {<br/>    auto prefix = "^.*?\\b("s;<br/>    auto suffix = ")\\b.*$"s;</span><span id="2070" class="mw lf iq ms b gy nn my l mz na">    //  ^.*?\b(one|two|three)\b.*$<br/>    const auto pattern = move(prefix) + join(words, "|") + move(suffix);</span><span id="6a91" class="mw lf iq ms b gy nn my l mz na">    ifstream        infile(file);<br/>    vector&lt;string&gt;  result;</span><span id="078e" class="mw lf iq ms b gy nn my l mz na">    for (string line; getline(infile, line);) {<br/>        if(regex_match(line, regex(pattern))) {<br/>            result.emplace_back(move(line));<br/>        }<br/>    }</span><span id="7cd8" class="mw lf iq ms b gy nn my l mz na">    return result;<br/>}</span><span id="59fd" class="mw lf iq ms b gy nn my l mz na">int main() {<br/>   assert((lines_containing("test.txt", {"one","two"})<br/>                                        == vector&lt;string&gt;{"This is one",<br/>                                                          "This is two"}));<br/>    return EXIT_SUCCESS;<br/>}<br/>/* test.txt<br/>This is one<br/>This is two<br/>This is three<br/>This is four<br/>*/</span></pre><ul class=""><li id="4922" class="mc md iq ka b kb kc kf kg kj nb kn nc kr nd kv mj mk ml mm bi translated">这同样适用于查找不包含模式为<code class="fe nk nl nm ms b">^((?!(one|two|three)).)*$</code>的单词的行。</li></ul><h1 id="1f05" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">在目录中查找文件</h1><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="0f31" class="mw lf iq ms b gy mx my l mz na">namespace fs = std::filesystem;</span><span id="4c91" class="mw lf iq ms b gy nn my l mz na">vector&lt;fs::directory_entry&gt; find_files(const fs::path &amp;path, string_view rg) {<br/>    vector&lt;fs::directory_entry&gt; result;<br/>    regex r(rg.data());<br/>    copy_if(<br/>        fs::recursive_directory_iterator(path),<br/>        fs::recursive_directory_iterator(),<br/>        back_inserter(result),<br/>        [&amp;r](const fs::directory_entry &amp;entry) {<br/>            return fs::is_regular_file(entry.path()) &amp;&amp;<br/>                   regex_match(entry.path().filename().string(), r);<br/>        });<br/>    return result;<br/>}</span><span id="c935" class="mw lf iq ms b gy nn my l mz na">int main() {<br/>    const auto dir        = fs::temp_directory_path();<br/>    const auto pattern    = R"(\w+\.png)";<br/>    const auto result     = find_files(fs::current_path(), pattern);<br/>    for (const auto &amp;entry : result) {<br/>        cout &lt;&lt; entry.path().string() &lt;&lt; endl;<br/>    }<br/>    return EXIT_SUCCESS;<br/>}</span></pre><h1 id="5c3b" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用常规正则表达式的提示</h1><ul class=""><li id="e57e" class="mc md iq ka b kb me kf mf kj mg kn mh kr mi kv mj mk ml mm bi translated">使用原始字符串文字描述C++中的regex模式。</li><li id="5edd" class="mc md iq ka b kb ne kf nf kj ng kn nh kr ni kv mj mk ml mm bi translated">使用正则表达式验证工具，如<a class="ae ld" href="https://regex101.com" rel="noopener ugc nofollow" target="_blank">https://regex101.com</a>。我喜欢的是<a class="ae ld" href="https://regex101.com/" rel="noopener ugc nofollow" target="_blank"> regex101 </a>的代码生成&amp;耗时(在优化regex时会有帮助)特性。</li><li id="1563" class="mc md iq ka b kb ne kf nf kj ng kn nh kr ni kv mj mk ml mm bi translated">此外，尝试将验证工具生成的解释作为注释添加到代码中正则表达式模式的正上方。</li><li id="d3fa" class="mc md iq ka b kb ne kf nf kj ng kn nh kr ni kv mj mk ml mm bi translated">性能:</li><li id="3fc4" class="mc md iq ka b kb ne kf nf kj ng kn nh kr ni kv mj mk ml mm bi translated">如果你使用交替，试着像<code class="fe nk nl nm ms b">com|net|org</code>一样按照高概率顺序排列选项。</li><li id="bd4f" class="mc md iq ka b kb ne kf nf kj ng kn nh kr ni kv mj mk ml mm bi translated">如果可能的话，尽量使用惰性量词。</li><li id="5130" class="mc md iq ka b kb ne kf nf kj ng kn nh kr ni kv mj mk ml mm bi translated">尽可能使用非捕获组。</li><li id="66b3" class="mc md iq ka b kb ne kf nf kj ng kn nh kr ni kv mj mk ml mm bi translated">禁用回溯。</li><li id="d37f" class="mc md iq ka b kb ne kf nf kj ng kn nh kr ni kv mj mk ml mm bi translated">使用否定字符类比使用懒惰点更有效。</li></ul><h1 id="795e" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">离别赠言</h1><p id="84e3" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj no kl km kn np kp kq kr nq kt ku kv ij bi translated">不仅仅是你会把regex只和C++或者任何其他语言一起使用。我自己主要在IDE(在vscode中分析日志文件)和Linux终端上使用它。但是，请记住，过度使用正则表达式会给人一种聪明的感觉。而且，这是一个让你的同事(以及任何需要使用你的代码的人)对你非常生气的好方法。此外，对于您在日常工作中会遇到的大多数解析任务来说，regex是多余的。</p><p id="80bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正则表达式确实在复杂的任务中大放异彩，在这些任务中，手写的解析代码无论如何都会很慢；对于极其简单的任务，正则表达式的可读性和健壮性超过了它们的性能成本。</p><p id="29bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">更值得注意的是，标准库中当前的正则表达式实现(直到2020年6月19日)存在性能和代码膨胀问题。因此，明智地在Boost、CTRE和标准库版本之间进行选择。最有可能的是，你会继续哈娜·杜西科娃关于<a class="ae ld" href="https://github.com/hanickadot/compile-time-regular-expressions" rel="noopener ugc nofollow" target="_blank">编译时正则表达式</a>的工作。此外，她来自<a class="ae ld" href="https://www.youtube.com/watch?v=QM3W36COnE4&amp;list=WL&amp;index=9&amp;t=0s" rel="noopener ugc nofollow" target="_blank"> 2018 </a> &amp; 2019的CppCon演讲将会很有帮助，尤其是如果你计划在嵌入式系统中使用regex的话。</p></div></div>    
</body>
</html>