<html>
<head>
<title>Implementing Rate limiter using Redis cache in Spring Boot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Spring Boot 使用 Redis 缓存实现限速器</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/implementing-rate-limiter-using-redis-cache-in-spring-boot-1ddd0a9cf8da?source=collection_archive---------1-----------------------#2022-04-22">https://blog.devgenius.io/implementing-rate-limiter-using-redis-cache-in-spring-boot-1ddd0a9cf8da?source=collection_archive---------1-----------------------#2022-04-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="c8c0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 Bot 攻击的时代，几乎所有主要科技公司发布的 API 都实施了某种速率限制。在本文中，我将介绍在 Spring boot 中基于固定窗口计数器算法使用 Redis 缓存实现速率限制器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/755d04952edd35e032ef8faea0b2370b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PdJroSWNVKqrsLRX"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@photographybyharry?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">哈里·格劳特</a>拍摄</figcaption></figure><h1 id="7994" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">什么是速率限制？</h1><blockquote class="lx ly lz"><p id="70de" class="jk jl ma jm b jn jo jp jq jr js jt ju mb jw jx jy mc ka kb kc md ke kf kg kh ig bi translated">速率限制是一种限制网络流量的策略。它对某人在一定时间内重复一个动作的频率设置了上限。</p></blockquote><h1 id="f111" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">使用限速器有什么好处？</h1><ul class=""><li id="fa69" class="me mf in jm b jn mg jr mh jv mi jz mj kd mk kh ml mm mn mo bi translated"><strong class="jm io">防止拒绝服务(DoS)攻击引起的资源饥饿</strong>。</li><li id="be7a" class="me mf in jm b jn mp jr mq jv mr jz ms kd mt kh ml mm mn mo bi translated"><strong class="jm io">降低成本</strong>。限制过多的请求意味着减少服务器数量，将更多的资源分配给高优先级 API。</li><li id="e2b9" class="me mf in jm b jn mp jr mq jv mr jz ms kd mt kh ml mm mn mo bi translated"><strong class="jm io">防止服务器过载</strong>。</li></ul><h1 id="5382" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">设计和算法</h1><h2 id="8f31" class="mu la in bd lb mv mw dn lf mx my dp lj jv mz na ln jz nb nc lr kd nd ne lv nf bi translated">设计</h2><p id="acf5" class="pw-post-body-paragraph jk jl in jm b jn mg jp jq jr mh jt ju jv ng jx jy jz nh kb kc kd ni kf kg kh ig bi translated">有两种实现方式可供我们选择:</p><ol class=""><li id="df98" class="me mf in jm b jn jo jr js jv nj jz nk kd nl kh nm mm mn mo bi translated"><strong class="jm io">客户端</strong></li><li id="12ae" class="me mf in jm b jn mp jr mq jv mr jz ms kd mt kh nm mm mn mo bi translated"><strong class="jm io">服务器端</strong></li></ol><p id="48f7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">客户端有点不可靠，因为机器人可以很容易地找到一些伪造请求的方法，或者他们可以直接攻击服务 API 并伤害我们。</p><p id="d89d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文中，我们将从<strong class="jm io">服务器端实现</strong>开始。</p><p id="dd6b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">即使在<strong class="jm io">服务器端实现</strong>中，也有两种方法可供我们选择:</p><ol class=""><li id="725d" class="me mf in jm b jn jo jr js jv nj jz nk kd nl kh nm mm mn mo bi translated"><strong class="jm io">作为 API 网关内部的中间件</strong></li><li id="f16c" class="me mf in jm b jn mp jr mq jv mr jz ms kd mt kh nm mm mn mo bi translated"><strong class="jm io">在我们的控制器端点的应用程序内部</strong></li></ol><p id="bc5f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我看来，两者都很好。但是，如果您没有 API 网关或有第三方 API 网关(在这种情况下，您没有太多的自由)，您可以使用第二个选项，并可以自由定制速率限制器。</p><p id="7838" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文中，我们将采用第二种方法。</p><h2 id="8b81" class="mu la in bd lb mv mw dn lf mx my dp lj jv mz na ln jz nb nc lr kd nd ne lv nf bi translated">算法</h2><p id="67bb" class="pw-post-body-paragraph jk jl in jm b jn mg jp jq jr mh jt ju jv ng jx jy jz nh kb kc kd ni kf kg kh ig bi translated">有各种速率限制算法。</p><ol class=""><li id="362a" class="me mf in jm b jn jo jr js jv nj jz nk kd nl kh nm mm mn mo bi translated"><strong class="jm io">令牌桶</strong></li><li id="31ab" class="me mf in jm b jn mp jr mq jv mr jz ms kd mt kh nm mm mn mo bi translated"><strong class="jm io">漏桶</strong></li><li id="16f8" class="me mf in jm b jn mp jr mq jv mr jz ms kd mt kh nm mm mn mo bi translated"><strong class="jm io">固定窗口计数器</strong></li><li id="b027" class="me mf in jm b jn mp jr mq jv mr jz ms kd mt kh nm mm mn mo bi translated"><strong class="jm io">滑动窗口日志</strong></li><li id="b88b" class="me mf in jm b jn mp jr mq jv mr jz ms kd mt kh nm mm mn mo bi translated"><strong class="jm io">滑动窗口计数器</strong></li></ol><p id="d80f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文中，我们将使用<strong class="jm io">固定窗口计数器。</strong></p><p id="82a6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">先来了解一下<strong class="jm io">固定窗口计数器</strong>是如何工作的。</p><ul class=""><li id="4c71" class="me mf in jm b jn jo jr js jv nj jz nk kd nl kh ml mm mn mo bi translated">对于每个时间线，我们创建计数器并用零初始化它。</li><li id="5894" class="me mf in jm b jn mp jr mq jv mr jz ms kd mt kh ml mm mn mo bi translated">每次请求后，我们将计数器加 1。</li><li id="3528" class="me mf in jm b jn mp jr mq jv mr jz ms kd mt kh ml mm mn mo bi translated">一旦计数器达到预定义的阈值，我们就可以开始抛出异常，并向客户端发送 429 Http 状态代码。</li></ul><p id="96ff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用<strong class="jm io">固定窗口计数器的利弊:</strong></p><h2 id="8d5e" class="mu la in bd lb mv mw dn lf mx my dp lj jv mz na ln jz nb nc lr kd nd ne lv nf bi translated">赞成的意见</h2><ul class=""><li id="32eb" class="me mf in jm b jn mg jr mh jv mi jz mj kd mk kh ml mm mn mo bi translated"><strong class="jm io">内存高效</strong>。因为我们只是将计数存储为值，将用户 id 存储为键</li><li id="d6b5" class="me mf in jm b jn mp jr mq jv mr jz ms kd mt kh ml mm mn mo bi translated"><strong class="jm io">通俗易懂</strong>。</li><li id="ca95" class="me mf in jm b jn mp jr mq jv mr jz ms kd mt kh ml mm mn mo bi translated"><strong class="jm io">在间隔结束时重置可用配额</strong>符合特定用例。</li></ul><h2 id="ca72" class="mu la in bd lb mv mw dn lf mx my dp lj jv mz na ln jz nb nc lr kd nd ne lv nf bi translated">骗局</h2><ul class=""><li id="487e" class="me mf in jm b jn mg jr mh jv mi jz mj kd mk kh ml mm mn mo bi translated"><strong class="jm io">窗口边缘的流量峰值</strong>可能导致超过允许限制的更多请求通过。</li></ul><h1 id="c29a" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">履行</h1><p id="aab1" class="pw-post-body-paragraph jk jl in jm b jn mg jp jq jr mh jt ju jv ng jx jy jz nh kb kc kd ni kf kg kh ig bi translated">现在让我们深入研究一下实现。</p><p id="d5ba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以使用基于<strong class="jm io"> IP 地址</strong>的计数器或基于<strong class="jm io">用户</strong>的计数器。如果你的应用程序是安全的，那么我一定会推荐基于<strong class="jm io">用户</strong>的计数器。对机器人来说，不断改变 IP 地址比每次注册和创建新用户更容易。</p><p id="3b34" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我们将创建<strong class="jm io">服务</strong>来<strong class="jm io">获取并递增</strong>用户的<strong class="jm io"> API 命中计数。</strong></p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="e792" class="mu la in no b gy ns nt l nu nv">@Slf4j<br/>@Service<br/>public class RateLimiterService {</span><span id="9801" class="mu la in no b gy nw nt l nu nv">@Autowired<br/>    RedisTemplate&lt;String, Object&gt; template;</span><span id="e97d" class="mu la in no b gy nw nt l nu nv">    /**<br/>     * This method is to return the current number <br/>     * of api calls made by this user from cache<br/>     * @param userId - user id<br/>     * @return String - number of calls made by this user<br/>     */<br/>    @Cacheable(cacheNames = "apiHitCount", key ="{#userId}")<br/>    public String getApiHitCount(Integer userId) {<br/>        return "0";<br/>    }</span><span id="0653" class="mu la in no b gy nw nt l nu nv">     /**<br/>     * This method is to increment the number of api <br/>     * calls made by this user in cache<br/>     * @param userId - user id<br/>     * @return void<br/>     */<br/>    public void incrementApiHitCount(Integer userId) {<br/>        template.<br/>            opsForValue().<br/>            increment("apiHitCount" + "::" + userId);<br/>    }<br/>}</span></pre><p id="f733" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们将<strong class="jm io"> TTL(生存时间)</strong>设置为 1 小时，这将是我们的时间线。</p><p id="8da4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这可以在<strong class="jm io">缓存配置</strong>中进行配置。我将展示如何为一个特定的缓存键设置 TTL。</p><p id="f5b2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们必须为<strong class="jm io">重新分配另一个<strong class="jm io"> Bean </strong>。</strong></p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="8a24" class="mu la in no b gy ns nt l nu nv">@Bean<br/>public CacheManager cacheManager(<br/>    RedisConnectionFactory connectionFactory<br/>) {<br/>     RedisCacheConfiguration defaultCacheConfig =<br/>       RedisCacheConfiguration.defaultCacheConfig();<br/>     defaultCacheConfig.disableCachingNullValues();<br/>     Map&lt;String, RedisCacheConfiguration&gt; cacheConfigurations = <br/>       new HashMap&lt;&gt;();<br/> <br/>    // This is how, you can set the TTL for a particular cache key.<br/>    // Here as you can see, we have set it as 1 hour.<br/>    // After one hour it will be cleared from the cache.<br/>    cacheConfigurations.put(<br/>      "apiHitCount", defaultCacheConfig.<br/>      entryTtl(Duration.ofHours(1)).<br/>      serializeValuesWith(<br/>        SerializationPair.fromSerializer(RedisSerializer.string())<br/>      )<br/>    );<br/>    return RedisCacheManager.builder(connectionFactory).<br/>      cacheDefaults(defaultCacheConfig).<br/>      withInitialCacheConfigurations(cacheConfigurations).<br/>      build();<br/>}</span><span id="842b" class="mu la in no b gy nw nt l nu nv">@Bean<br/>public RedisTemplate&lt;String, Object&gt; redisTemplate() {<br/>   RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();<br/>   template.setConnectionFactory(lettuceConnectionFactory());<br/>   template.setDefaultSerializer(new StringRedisSerializer());<br/>   return template;<br/>}</span></pre><p id="94fd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们看看<strong class="jm io">控制器</strong>的逻辑。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="dfba" class="mu la in no b gy ns nt l nu nv">@Slf4j<br/>@RestController<br/>@RequestMapping("/api")<br/>public class DemoController {</span><span id="1c45" class="mu la in no b gy nw nt l nu nv">    @Autowired<br/>    RateLimiterService rateLimitedService;<br/> <br/>    @Autowired<br/>    DemoService demoService;<br/> <br/>    // We can get it from properties or, <br/>    // we can get it from config table (<br/>    // for this we will need to have a DAO call <br/>    // to get the limit)<br/>    @Value("${api.count.limit:100}")<br/>    private int apiCountLimit;<br/>    <br/>    /**<br/>     * GET endpoint to get bank balance of a particular user<br/>     * @param user - authenticated user<br/>     * @param request - http servlet request<br/>     * @return double - bank balance<br/>     */<br/>    @GetMapping("/get-details")<br/>    public double getDetails(<br/>      @AuthenticationPrincipal AvlUser user<br/>      HttpServletRequest request<br/>    ){</span><span id="46ec" class="mu la in no b gy nw nt l nu nv">    if (null != user &amp;&amp; null != user.getUsername())) {<br/>        // if the number of calls exceed the configured value, <br/>        // then we throw Too many calls exception.<br/>        if (<br/>           Integer.parseInt(<br/>           rateLimitedService.getApiHitCount(user.getUserId())) <br/>           &gt; apiCountLimit<br/>        ){<br/>          // we can log the user name<br/>          // such that later we can go through the logs<br/>          // and ban the malicious users<br/>          log.info(<br/>            "User {}, id {} has exceeded configured <br/>            per day api limit.", <br/>            user.getUsername(), <br/>            user.getUserId()<br/>          );<br/>          // we can catch this exception in exception handler to <br/>          // send 429 http status code<br/>          throw new TooManyCallsException();<br/>        }<br/>        // incrementing the count<br/>        rateLimitedService.incrementApiHitCount(<br/>          user.getUserId()<br/>        );<br/>        return demoService.getDetails(user);<br/>     } else {<br/>        throw new PermissionException();<br/>     }<br/>   }<br/>}</span></pre><ul class=""><li id="e0e2" class="me mf in jm b jn jo jr js jv nj jz nk kd nl kh ml mm mn mo bi translated">如果你想用基于<strong class="jm io"> IP 地址的</strong>计数器。可以使用<code class="fe nx ny nz no b">request.getRemoteAddr()</code>(其中请求为<code class="fe nx ny nz no b">HttpServletRequest</code>)。</li><li id="e2aa" class="me mf in jm b jn mp jr mq jv mr jz ms kd mt kh ml mm mn mo bi translated">你可以看看这篇文章，我解释了如何使用 <code class="fe nx ny nz no b"><strong class="jm io">@ControllerAdvice</strong></code>来<strong class="jm io">捕捉异常并发送任何你想要的 Http 状态代码。</strong></li></ul><p id="aa76" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于上面的例子。</p><ol class=""><li id="accd" class="me mf in jm b jn jo jr js jv nj jz nk kd nl kh nm mm mn mo bi translated">我们可以发送<strong class="jm io"> </strong> <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/429" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> Http 状态码 429 </strong> </a>为<code class="fe nx ny nz no b"><strong class="jm io">TooManyCallsException</strong></code>。</li><li id="320e" class="me mf in jm b jn mp jr mq jv mr jz ms kd mt kh nm mm mn mo bi translated">和<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/401" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> Http 状态码 401 </strong> </a>为<code class="fe nx ny nz no b"><strong class="jm io">PermissionException</strong></code>。</li></ol><h2 id="ebe8" class="mu la in bd lb mv mw dn lf mx my dp lj jv mz na ln jz nb nc lr kd nd ne lv nf bi translated">注意</h2><p id="f502" class="pw-post-body-paragraph jk jl in jm b jn mg jp jq jr mh jt ju jv ng jx jy jz nh kb kc kd ni kf kg kh ig bi translated">之前我使用了<code class="fe nx ny nz no b">@CachePut</code>来设置 API 命中数。在控制器中，我首先获取 API 命中数，然后加 1。但是正如@Vovabear 所指出的，当多个线程开始触及端点时，这可能会导致问题。</p><blockquote class="lx ly lz"><p id="b45d" class="jk jl ma jm b jn jo jp jq jr js jt ju mb jw jx jy mc ka kb kc md ke kf kg kh ig bi translated">让我们假设有两个线程 A 和 B，它们都有相同的 userId，当计数为 0 时，它们都同时到达了我们的端点。理想情况下，我们的计数应该是 2。但是由于两者都将计数读取为 0，所以它会尝试将其更新为 1，这是不正确的。</p></blockquote><p id="f5fb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我做的解决这个用的是<code class="fe nx ny nz no b">RedisTemplate</code> <code class="fe nx ny nz no b">opsForValue().increment</code>。现在 Redis 将处理并发线程，并且一次只允许一个线程更新值。</p><h1 id="f591" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="daa7" class="pw-post-body-paragraph jk jl in jm b jn mg jp jq jr mh jt ju jv ng jx jy jz nh kb kc kd ni kf kg kh ig bi translated">现在我们知道<strong class="jm io">什么是限速器</strong>、<strong class="jm io">为什么有利</strong>、<strong class="jm io">什么是所有的方法和算法都有</strong>。然后我们<strong class="jm io">通过选择将速率限制器<strong class="jm io">放在我们的应用程序</strong>中，然后使用<strong class="jm io">固定窗口计数器算法，实现了</strong>一个<strong class="jm io">服务器端速率限制器</strong>。</strong></p><p id="af77" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将取决于哪种方法更适合您的系统，然后您可以相应地实现。</p><p id="5cd8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，我们只是研究了事情的<strong class="jm io">速率限制方面</strong>。但是如果你也想做<strong class="jm io">僵尸管理</strong>，那么你必须<strong class="jm io">整体检测恶意活动</strong>，然后给他们<strong class="jm io">警告或者封锁账户</strong>。您可以利用<strong class="jm io">限速部件</strong>跟踪<strong class="jm io">异常活动</strong>。同样在上述实施中，如果您注意到我们正在记录即将达到限制的用户，这样我们就可以跟踪所有此类用户，如果我们看到特定用户的任何模式或一贯的异常活动，我们就可以开始阻止这些帐户。</p></div><div class="ab cl oa ob hr oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ig ih ii ij ik"><p id="5e6f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你想了解更多关于这个主题和其他系统设计概念，你应该浏览这本书。</p><ol class=""><li id="5758" class="me mf in jm b jn jo jr js jv nj jz nk kd nl kh nm mm mn mo bi translated"><a class="ae ky" href="https://www.amazon.com/System-Design-Interview-Insiders-Guide-ebook/dp/B08B3FWYBX" rel="noopener ugc nofollow" target="_blank">https://www . Amazon . com/System-Design-Interview-Insiders-Guide-ebook/DP/b 08 B3 fwybx</a></li></ol></div></div>    
</body>
</html>