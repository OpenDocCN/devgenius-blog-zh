<html>
<head>
<title>React Class &amp; Function Todo Lists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React 类和函数待办事项列表</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/react-class-function-todo-lists-6361ae06369b?source=collection_archive---------1-----------------------#2022-04-27">https://blog.devgenius.io/react-class-function-todo-lists-6361ae06369b?source=collection_archive---------1-----------------------#2022-04-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/8d7d697aa68f9cdd07de313d36b9d666.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XC0RR2rrFuCyW4J6fjVplA.png"/></div></div></figure><p id="39d3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">待办事项列表…可能是最基本的、独立的、概念验证的、几乎是最典型的应用程序实现。这个简单的应用程序想法亲切地将我们的注意力引向持久数据(至少在本地)和几种可能的条件渲染。在尝试新的库或前端框架时，这总是一个很好的“选择”。</p><p id="2f77" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我最近遇到了我对 React 类组件相当生疏的知识，主要是因为我在 99%的时间里选择了函数组件。然而，尴尬可以成为一个很好的动力。</p><p id="61b0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，本文将重温类组件，这是任何 React 开发人员都必须具备的技能，并且旨在制作一个利用类和函数组件的待办事项应用程序。</p><p id="a1a1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我们可以用<a class="ae kt" href="https://create-react-app.dev/docs/getting-started" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>创建我们的应用程序:</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="575e" class="ld le in kz b gy lf lg l lh li">npx create-react-app class-and-function-todos</span></pre><p id="2574" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们还将在最后安装<a class="ae kt" href="https://www.npmjs.com/package/classnames" rel="noopener ugc nofollow" target="_blank">类名</a>用于一些样式目的:</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="370d" class="ld le in kz b gy lf lg l lh li">npm install classnames</span></pre><p id="f9d1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后从根目录启动应用程序:</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="b1a8" class="ld le in kz b gy lf lg l lh li">cd class-and-function-todos<br/>npm start</span></pre><p id="22d9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是我们正在寻找的“待办事项”:</p><ul class=""><li id="844e" class="lj lk in jx b jy jz kc kd kg ll kk lm ko ln ks lo lp lq lr bi translated">创建两个 todo 列表组件，一个作为类，一个作为函数</li><li id="4fe5" class="lj lk in jx b jy ls kc lt kg lu kk lv ko lw ks lo lp lq lr bi translated">待办事项列表组件需要一个输入字段来创建新的待办事项</li><li id="b2ae" class="lj lk in jx b jy ls kc lt kg lu kk lv ko lw ks lo lp lq lr bi translated">新的 todo 不应是空字符串</li><li id="85bf" class="lj lk in jx b jy ls kc lt kg lu kk lv ko lw ks lo lp lq lr bi translated">输入字段需要一个按钮来添加新输入的 todo</li><li id="60fe" class="lj lk in jx b jy ls kc lt kg lu kk lv ko lw ks lo lp lq lr bi translated">并且每个 todo 都应该在被单击时切换其换行属性值</li></ul><p id="58f3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了保持有序，我们可以在 src 文件夹中添加一个“components”文件夹来存放我们的两个待办事项列表组件。我们将组件<em class="lx">称为 TodoListClass.jsx </em>和<em class="lx">称为 TodoListFunction.jsx </em>。</p><p id="52b2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了启动和运行，并确保我们正确地导入了每个组件，让我们快速地在 App.js 中呈现这两个组件。这是我的组件的开头看起来的样子:</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ly"><img src="../Images/a435f07e794b2a25369299d2c29a820f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yT_WvoWTpsP-Frnw7OCdLw.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">src/App.js</figcaption></figure><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi md"><img src="../Images/2dbc8bdfdbece071f471c081ffd40f84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8YwuQKGEDutjI9Hi0MQ_4Q.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">src/components/todolist class . jsx</figcaption></figure><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi me"><img src="../Images/f08a823d6afa05224521b056b98daff8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Puxk3dS-8owSaa_NNl1SPQ.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">src/components/todolistfunction . jsx</figcaption></figure><p id="702f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是我们拨入这些组件后 react 应用程序应该呈现的内容:</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mf"><img src="../Images/ffa6e9e8e7101be4f5ca488493c3dcca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gldeg5DovmI1gh-F1Dr_Qw.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">https://本地主机:3000</figcaption></figure></div><div class="ab cl mg mh hr mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ig ih ii ij ik"><p id="f05c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们已经有了工作的文件夹结构和组件呈现，我们将开始处理类组件待办事项列表:</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mn"><img src="../Images/3d270e40b5662a85b48d80367dd01890.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RQJP19C7vg_gLyZhS4VOOw.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">完成:src/components/todolistclass . jsx</figcaption></figure><p id="bb57" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">到目前为止，我们已经有了一个类组件，它带有一个构造函数、两个事件处理程序和一个 jsx 的呈现方法，还不算太坏！为了更好地与下一个函数组件版本进行比较，我们来看一下这个类的每个部分。</p><p id="0193" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第 5 行的构造函数方法用它的起始值初始化我们的本地状态，并将两个事件处理程序绑定到我们的类:handleSubmit &amp; handleTodoClick。</p><p id="a502" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在第 12 行，handleSubmit 将一个事件作为其参数，并执行 preventDefault 事件方法。这允许我们继续 handleSubmit 函数，而无需刷新浏览器，这是单击“Submit”类型的输入时的默认操作。</p><p id="1ece" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">继续 handleSubmit，初始化一个 newTodo(第 16 行)，但是如果 newTodo 的标签为空，我们将立即退出这个函数；防止我们意外添加空白的牛顿体。</p><p id="a92c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，我们使用类组件的 setState 方法将 newTodo 添加到我们的 Todo 列表中(第 24 行),然后清除输入字段(第 29 行),这样我们就可以重新开始，并使用输入字段添加额外的 todo。</p><p id="5b6d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">handleTodoClick 方法被传递给每个 todo，这样它就可以切换它们的“done”属性，并在我们的 render 方法中利用第 61 行的线穿过样式。</p><p id="f6e1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">进入 render 方法(第 42 行)，我们返回一个 react 片段，因为我们实际上有两个想要呈现的组件(div &amp; style)。style 标签是一种简单的方法，它包含了切换 todo 列表项的换行功能所需的样式，而主 div 是呈现 todo 列表的地方。</p><p id="fd3d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们在第 47–50 行为输入和 todo 列表中的按钮使用了一个不受控制的表单，然后映射 todos from 状态，将它们显示在输入字段下方。</p><p id="ccd6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">虽然这看起来很多，但是当一次分析一部分时，组件的每个部分都很简单和直接。</p><p id="acbb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，我们将在函数组件中构建完全相同的功能:</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mn"><img src="../Images/b0861b239e6c4fbfce10693862fde41c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Djs85qWVZOMEY6r7c0spmw.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">已完成:SCR/components/todolistfunction . jsx</figcaption></figure><p id="0bf1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个函数组件看起来非常类似于类组件，但是在语法上有一些不同。最明显的区别是使用钩子来管理状态(第 5–6 行)，用事件处理函数代替方法，用返回语句代替呈现方法。</p><p id="4d71" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我觉得这里要强调的最大区别是 useState 挂钩。并排查看这两个组件允许对状态管理执行进行比较和对比。即使是一个简单的待办事项应用程序也可以以一种有益的方式突出这些关键的实现差异:</p><ul class=""><li id="f42a" class="lj lk in jx b jy jz kc kd kg ll kk lm ko ln ks lo lp lq lr bi translated">构造函数与使用状态挂钩</li><li id="4a9c" class="lj lk in jx b jy ls kc lt kg lu kk lv ko lw ks lo lp lq lr bi translated">this.setState vs setTodos(来自 useState 钩子的 setter)</li></ul></div><div class="ab cl mg mh hr mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ig ih ii ij ik"><p id="c21b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此时，我们的应用程序应该看起来像这样:</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mo"><img src="../Images/dcbd799b51ab1413dc5490bab62d6854.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FAzqGpQnRrp5JcnjfKxBoA.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">已完成:https://localhost:3000</figcaption></figure><p id="90df" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您需要复习任何一种类型的组件，请尝试用两种不同的方法构建相同的功能。无论您更喜欢其中一个，或者您所在的团队同时使用这两个组件，快速深入地研究函数和类组件都是很好的实践！</p></div></div>    
</body>
</html>