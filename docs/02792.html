<html>
<head>
<title>JavaScript Unit Test Best Practices — UI Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript 单元测试最佳实践— UI 测试</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/javascript-unit-test-best-practices-ui-tests-99ee3e7fe467?source=collection_archive---------9-----------------------#2020-08-30">https://blog.devgenius.io/javascript-unit-test-best-practices-ui-tests-99ee3e7fe467?source=collection_archive---------9-----------------------#2020-08-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/396d16953d4eae4fd58d02972b3cf9da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VJfa9B3S5Ik23Kmy"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">戴维·坎泰利在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="4571" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">单元测试对于检查我们的应用程序如何工作非常有用。</p><p id="9a1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们以后会遇到各种各样的问题。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看在编写 JavaScript 单元测试时应该遵循的一些最佳实践。</p><h1 id="8cf9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">基于不太可能改变的属性查询 HTML 元素</h1><p id="6919" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该只检查属性不太可能改变的 HTML 元素。</p><p id="6646" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，当我们做一些小的改变时，我们不必更新我们的测试。</p><p id="73ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，这确保了外观和感觉的变化不会破坏我们的测试。</p><p id="535e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不要写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c6d9" class="mn lc iq mj b gy mo mp l mq mr">test("whenever no data is passed, number of messages shows zero", () =&gt; {<br/>  // ...<br/>  expect(wrapper.find("[className='mr-2']").text()).toBe("0");<br/>});</span></pre><p id="74f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要测试:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f17d" class="mn lc iq mj b gy mo mp l mq mr">&lt;span id="metric" className="mr-2"&gt;{value}&lt;/span&gt;</span></pre><p id="34a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们将自己的 ID 添加到想要测试的元素中，然后在测试中使用它。</p><p id="5ee2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9deb" class="mn lc iq mj b gy mo mp l mq mr">&lt;h3&gt;<br/>  &lt;Badge pill className="fixed_badge" variant="dark"&gt;<br/>    &lt;span data-testid="msgs-label"&gt;{value}&lt;/span&gt;<br/>  &lt;/Badge&gt;<br/>&lt;/h3&gt;</span></pre><p id="4c8e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用以下方法进行测试:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a6ae" class="mn lc iq mj b gy mo mp l mq mr">test("whenever no data is passed, number of messages shows zero", () =&gt; {<br/>  const metricValue = undefined;<br/>  const { getByTestId } = render(&lt;dashboardMetric value={undefined} /&gt;);<br/>  expect(getByTestId("msgs-label").text()).toBe("0");<br/>});</span></pre><p id="ff31" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不应该依赖于可以随时改变的 CSS 属性。</p><p id="f66e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们添加一个很少或从不改变的 ID。</p><h1 id="1f6b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用真实且完全渲染的组件进行测试</h1><p id="9cd7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该使用真实的、完全渲染的组件进行测试。</p><p id="852a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们可以相信我们的测试实际上是在测试组件中的东西。</p><p id="6c30" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们模仿或者进行部分或浅层渲染，我们可能会在测试中遗漏一些东西。</p><p id="7022" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果用真实的东西测试太慢，那么我们可以考虑模仿。</p><p id="a88d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，代替使用<code class="fe ms mt mu mj b">shallow</code>的浅层渲染:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="43e7" class="mn lc iq mj b gy mo mp l mq mr">test("when click to show filters, filters are displated", () =&gt; {<br/>  const wrapper = shallow(&lt;Calendar showFilters={false} title="Select Filter" /&gt;);<br/>  wrapper<br/>    .find("FiltersPanel")<br/>    .instance()<br/>    .showFilters();<br/><br/>  expect(wrapper.find("Filter").props()).toEqual({ title: "Select Filter" });<br/><br/>});</span></pre><p id="e528" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a4c5" class="mn lc iq mj b gy mo mp l mq mr">test("when click to show filters, filters are displated", () =&gt; {<br/>  const wrapper = mount(&lt;Calendar showFilters={false} title="Select Filter" /&gt;);<br/>  wrapper.find("button").simulate("click");<br/>  expect(wrapper.text().includes("Select Filter"));<br/>});</span></pre><p id="0d06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe ms mt mu mj b">mount</code>来完全安装<code class="fe ms mt mu mj b">Calendar</code>组件。</p><p id="e5fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们像真正的用户一样点击按钮。</p><p id="4005" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们检查应该出现的文本。</p><h1 id="94e5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用框架内置的异步事件支持</h1><p id="bfef" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该在运行测试时测试框架内置的异步事件。</p><p id="9d69" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们实际上是在运行某个东西之前等待我们想要的东西出现。</p><p id="b9f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在固定的时间睡觉是不可靠的，而且在做我们想做的事情之前等待项目出现也没有帮助。</p><p id="0019" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着我们的测试将是不可靠的。</p><p id="db0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有，固定时间睡觉要慢很多。</p><p id="36bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，用柏树，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4351" class="mn lc iq mj b gy mo mp l mq mr">cy.get("#show-orders").click();<br/>cy.wait("@orders");</span></pre><p id="8cb0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们点击 ID 为<code class="fe ms mt mu mj b">show-orders</code>的元素时，我们等待<code class="fe ms mt mu mj b">orders</code>出现。</p><p id="15be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不想让代码等待我们自己的逻辑和<code class="fe ms mt mu mj b">setInterval</code>:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="446c" class="mn lc iq mj b gy mo mp l mq mr">test("user name appears", async () =&gt; {<br/>  //...<br/>  const interval = setInterval(() =&gt; {<br/>    const found = getByText("james");<br/>    if (found) {<br/>      clearInterval(interval);<br/>      expect(getByText("james")).toBeInTheDocument();<br/>    }<br/>  }, 100);</span><span id="f199" class="mn lc iq mj b gy mv mp l mq mr">  const movie = await waitForElement(() =&gt; getByText("james"));<br/>});</span></pre><p id="a280" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这很复杂，而且我们没有利用测试框架的全部功能。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/8d5bbffe74173525a93f0a9bec71bf5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*n5NfCF0OlfCQGN9f"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">约翰·贝克在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="7e18" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="df78" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该用测试框架的等待功能来等待。</p><p id="ea9b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们应该用真实的组件进行测试。</p></div></div>    
</body>
</html>