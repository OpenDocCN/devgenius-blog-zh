<html>
<head>
<title>Experienced Java Developers Avoid These 5 Optional Practices for Fewer Issues</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有经验的 Java 开发人员避免这 5 个可选的实践，以减少问题</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/experienced-java-developers-avoid-these-5-optional-practices-for-fewer-issues-ce78ac10d9c?source=collection_archive---------7-----------------------#2022-10-23">https://blog.devgenius.io/experienced-java-developers-avoid-these-5-optional-practices-for-fewer-issues-ce78ac10d9c?source=collection_archive---------7-----------------------#2022-10-23</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="e157" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">要避免的 5 个习惯，并在未来以更干净的代码结束</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/d59ae5e4a95210ba5754e9fd185c808c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-LnEZIbywYJN4yuCgKjw2Q.png"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated">照片由<a class="ae kw" href="https://www.pexels.com/@tima-miroshnichenko?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">马体·米罗什尼琴科</a>从<a class="ae kw" href="https://www.pexels.com/photo/man-in-red-and-blue-plaid-button-up-shirt-using-silver-macbook-5702300/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">佩克斯</a>拍摄</figcaption></figure><p id="9f60" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">“我的同事不知道可选的存在。”——<a class="ae kw" href="https://www.reddit.com/r/java/comments/t1ev7h/comment/hyfmdt0/?utm_source=share&amp;utm_medium=web2x&amp;context=3" rel="noopener ugc nofollow" target="_blank">Reddit 上的一名 Java 开发者。</a></p><p id="580d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我们使用可选项已经 8 年了。尽管如此，人们对可选择的用法仍有争议。</p><p id="80e5" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我们应该用 of 还是<code class="fe lu lv lw lx b">ofNullable</code>搭配<code class="fe lu lv lw lx b">orElseThrow</code>？我们是不是用错了<code class="fe lu lv lw lx b">ofNullable</code>？<code class="fe lu lv lw lx b">Optional</code> <code class="fe lu lv lw lx b">flatMap</code>的用例是什么？</p><p id="8596" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">让我们深入了解你应该避免使用<code class="fe lu lv lw lx b">Optional</code>的 5 种做法。</p><h1 id="9894" class="ly lz ir bd ma mb mc md me mf mg mh mi jx mj jy mk ka ml kb mm kd mn ke mo mp bi translated">1.不要用可选的验证不变量</h1><p id="352f" class="pw-post-body-paragraph kx ky ir kz b la mq js lc ld mr jv lf lg ms li lj lk mt lm ln lo mu lq lr ls ik bi translated">验证不应该用<code class="fe lu lv lw lx b">Optional</code>来完成。</p><p id="feca" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">他们想要空的<code class="fe lu lv lw lx b">Optional</code>，而不是验证异常。这不是这个工具的用例。您应该事先进行验证并抛出异常。</p><p id="d409" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">将<code class="fe lu lv lw lx b">Optional</code>仅作为缺席指示器。</p><pre class="kh ki kj kk gu mv lx mw mx aw my bi"><span id="31c4" class="mz lz ir lx b gz na nb l nc nd">1 Optional&lt;Foo&gt; getMeFoo(String fooId) {<br/>2    var fooIdValid = validateFooId(fooId);<br/>3    if(!fooIdValid) { throw new FooIdInvalidException();}<br/>4    <br/>5    return fooService.getFooById(fooID);<br/>}</span></pre><p id="3ba6" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">验证部分不返回空的<code class="fe lu lv lw lx b">Optional</code>。只有当<code class="fe lu lv lw lx b">Optional</code>不在<code class="fe lu lv lw lx b">fooService</code>中时，才返回它。</p><p id="a6cc" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><strong class="kz is"> <em class="lt">如果你在第 2 行返回空的</em> </strong> <code class="fe lu lv lw lx b"><strong class="kz is"><em class="lt">Optional</em></strong></code> <strong class="kz is"> <em class="lt">，你会有歧义。</em> </strong></p><p id="f836" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">一个值显示两种情况。这肯定不是<code class="fe lu lv lw lx b">Optional</code>最初打算做的事情。</p><p id="cb6c" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">如果你不想在没有这个值的情况下继续，你可以抛出一个异常。这看起来是这样的:</p><pre class="kh ki kj kk gu mv lx mw mx aw my bi"><span id="a708" class="mz lz ir lx b gz na nb l nc nd">Foo getMeFoo(String fooId) throws IllegalStateException {<br/>    var fooIdValid = validateFooId(fooId);<br/>    if(!fooIdValid) { throw new FooIdInvalidException();}</span><span id="7371" class="mz lz ir lx b gz ne nb l nc nd">       return fooService.getFooById(fooID)<br/>       .orElseThrow(() -&gt;  new IllegalStateException());}<br/>}</span></pre></div><div class="ab cl nf ng hv nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ik il im in io"><p id="a8a8" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><strong class="kz is"> <em class="lt">另一个例子你可能看到的是</em> </strong> <code class="fe lu lv lw lx b"><strong class="kz is"><em class="lt">Optional</em></strong></code> <strong class="kz is"> <em class="lt">上的空异常。</em> </strong></p><p id="f468" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这不是很好的实践，因为您使用空的<code class="fe lu lv lw lx b">Optional</code>来<code class="fe lu lv lw lx b">swallow</code>错误。这段代码会产生无声的错误，将来可能会让您感到困惑。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nm nn l"/></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated"><a class="ae kw" href="https://stackoverflow.com/a/42993601/5999670" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure></div><div class="ab cl nf ng hv nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ik il im in io"><p id="32a0" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><strong class="kz is"> <em class="lt">空抓怎么办？</em> </strong>对于这个场景，<strong class="kz is"> <em class="lt">我们可以返回一个空的可选，因为它会正确地标记非问题。</em>T25】</strong></p><p id="3f6e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><code class="fe lu lv lw lx b">0</code>下面的场景可能意味着两件事——<strong class="kz is"><em class="lt">错误发生了或者零是有意义的。</em>T29】</strong></p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nm nn l"/></div></figure><p id="eef2" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">用一个空的<code class="fe lu lv lw lx b">Optional</code>我们得到了唯一的意义，那就是缺席值。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nm nn l"/></div></figure><h1 id="63c7" class="ly lz ir bd ma mb mc md me mf mg mh mi jx mj jy mk ka ml kb mm kd mn ke mo mp bi translated">2.<code class="fe lu lv lw lx b">flatMap</code>对嵌套<code class="fe lu lv lw lx b">Optional</code>帮助很大</h1><p id="a719" class="pw-post-body-paragraph kx ky ir kz b la mq js lc ld mr jv lf lg ms li lj lk mt lm ln lo mu lq lr ls ik bi translated">大多数开发人员使用地图，这在大多数情况下没问题。但是如果你需要将可选的映射到另一个可选的，你会有一个不必要的包装器。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nm nn l"/></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated"><a class="ae kw" href="https://www.tabnine.com/code/java/methods/java.util.Optional/flatMap?snippet=5ce70b3ee5946700042de71a" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="b4f7" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">什么是好的平面图候选？ </p><p id="3751" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">如果映射器函数的输入和输出都是<code class="fe lu lv lw lx b">Optional</code>。例如,<code class="fe lu lv lw lx b">Optional</code>通过地图绘制器并在途中变平。最后，我们得到一个单独的<code class="fe lu lv lw lx b">Optional</code>，没有包装器。</p></div><div class="ab cl nf ng hv nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ik il im in io"><p id="1f43" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><strong class="kz is"> <em class="lt">另一个用例是将多个操作排序在一起。</em> </strong></p><p id="8aa0" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">让我们有基于单个参数计算的多个操作。它们相互依赖，但结果是可选的。</p><pre class="kh ki kj kk gu mv lx mw mx aw my bi"><span id="526e" class="mz lz ir lx b gz na nb l nc nd">Optional&lt;Integer&gt; calcAs(int a) {return Optional.of(a+1);}</span><span id="f7d2" class="mz lz ir lx b gz ne nb l nc nd">jshell&gt; Optional.of(1).flatMap(a -&gt; calcAs(a).flatMap(b -&gt; calcAs(b)))<br/>$6 ==&gt; Optional[3]</span><span id="68b1" class="mz lz ir lx b gz ne nb l nc nd">jshell&gt; Optional.of(1).map(a -&gt; calcAs(a).map(b -&gt; calcAs(b)))<br/>$7 ==&gt; Optional[Optional[Optional[3]]]</span></pre><p id="6ce1" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这就是你会得到的差别。</p><h1 id="bc06" class="ly lz ir bd ma mb mc md me mf mg mh mi jx mj jy mk ka ml kb mm kd mn ke mo mp bi translated">3.不要混淆<code class="fe lu lv lw lx b">orElseThrow</code>和<code class="fe lu lv lw lx b">ofNullable</code></h1><p id="012c" class="pw-post-body-paragraph kx ky ir kz b la mq js lc ld mr jv lf lg ms li lj lk mt lm ln lo mu lq lr ls ik bi translated"><strong class="kz is"> <em class="lt">使用</em></strong><code class="fe lu lv lw lx b"><strong class="kz is"><em class="lt">ofNullable</em></strong></code><strong class="kz is"><em class="lt"/></strong><code class="fe lu lv lw lx b"><strong class="kz is"><em class="lt">orElseThrow</em></strong></code><strong class="kz is"><em class="lt">是毫无意义的。你可以做一个简单的空值检查。</em>T51】</strong></p><p id="0319" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">正如在前面的例子中所看到的，您可以使用<code class="fe lu lv lw lx b">orElseThrow</code>获得可选和解析。你不要把<code class="fe lu lv lw lx b">ofNullable</code>和<code class="fe lu lv lw lx b">orElseThrow</code>连起来。</p><p id="364b" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">出现此问题是因为开发人员将 optional 用作空检查。可选的如果值为空，将抛出 NPE。这并不意味着您应该使用它来代替空检查。</p></div><div class="ab cl nf ng hv nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ik il im in io"><p id="4b6a" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><strong class="kz is"> <em class="lt">如果你能避开</em> </strong> <code class="fe lu lv lw lx b"><strong class="kz is"><em class="lt">orElseThrow</em></strong></code> <strong class="kz is"> <em class="lt">那也是个不错的练习。</em>T12】</strong></p><p id="10d6" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">然后你会把期权仅仅看作是进一步映射的工具。并且避免<code class="fe lu lv lw lx b">value!=null</code>可选特质。更多的价值在于映射和功能特性的可选启用。</p><pre class="kh ki kj kk gu mv lx mw mx aw my bi"><span id="2df6" class="mz lz ir lx b gz na nb l nc nd">getMeFoo("123").map(Foo::getXProp).orElse(DEFAULT_VALUE)</span></pre><h1 id="c4cb" class="ly lz ir bd ma mb mc md me mf mg mh mi jx mj jy mk ka ml kb mm kd mn ke mo mp bi translated">4.不要对记录字段使用选项</h1><p id="2e7e" class="pw-post-body-paragraph kx ky ir kz b la mq js lc ld mr jv lf lg ms li lj lk mt lm ln lo mu lq lr ls ik bi translated"><strong class="kz is"> <em class="lt">可选意为返回值。而不是作为对象字段。</em> </strong></p><p id="4f28" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">Optional 不可序列化，因此在记录中使用没有意义。记录是数据载体，所以我们不应该添加不可序列化的选项。</p><p id="1053" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">有些人会将 optional 混淆为记录中的一个例外。但事实并非如此。</p><p id="50fd" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">即使在未来，可选将保持可选。Valhalla 不允许使用可选字段。未来可选将是一个基于价值的类，但仍然有可选的特质。</p><p id="e41e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">只有基本选项是可序列化的。但我们将等待瓦尔哈拉，看看这将如何工作。毕竟，他们需要满足“像类一样的代码(可选)，像 int 一样工作”的承诺 </p></div><div class="ab cl nf ng hv nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ik il im in io"><p id="ecc6" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><strong class="kz is"> <em class="lt">我们能不能把一个可选的序列化？</em>T24】</strong></p><p id="fe02" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">Nicolai 检查了可选的的<a class="ae kw" href="https://nipafx.dev/serialize-java-optional/" rel="noopener ugc nofollow" target="_blank">序列化代理。即便如此，我们需要编写自己的序列化，而不是 java 支持的现成东西。</a></p><p id="4bd3" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">你可以用芭乐可选的来代替。与 Java 的可选相比，这个可选是可序列化的。即便如此，番石榴乡亲们还是会再次<a class="ae kw" href="https://guava.dev/releases/19.0/api/docs/com/google/common/base/Optional.html#:~:text=However%2C%20we%20do%20gently%20recommend%20that%20you%20prefer%20the%20new%2C%20standard%20Java%20class%20whenever%20possible." rel="noopener ugc nofollow" target="_blank">把你指向官方 Java 的可选</a>。</p></div><div class="ab cl nf ng hv nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ik il im in io"><p id="9b9c" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">重点是避免记录中的<code class="fe lu lv lw lx b">Optional</code>字段。这与将 null 作为记录的字段是一样的。这不是<code class="fe lu lv lw lx b">Optional</code>用例。</p><h1 id="db0a" class="ly lz ir bd ma mb mc md me mf mg mh mi jx mj jy mk ka ml kb mm kd mn ke mo mp bi translated">5.在 orElseGet 中获取<code class="fe lu lv lw lx b">Optional</code>值</h1><p id="6754" class="pw-post-body-paragraph kx ky ir kz b la mq js lc ld mr jv lf lg ms li lj lk mt lm ln lo mu lq lr ls ik bi translated"><strong class="kz is"><em class="lt"/></strong><a class="ae kw" href="https://stackoverflow.com/questions/72535838/how-to-optain-an-optional-with-orelseget" rel="noopener ugc nofollow" target="_blank"><strong class="kz is"><em class="lt">如何将</em></strong></a><code class="fe lu lv lw lx b"><a class="ae kw" href="https://stackoverflow.com/questions/72535838/how-to-optain-an-optional-with-orelseget" rel="noopener ugc nofollow" target="_blank"><strong class="kz is"><em class="lt">Optional</em></strong></a></code><a class="ae kw" href="https://stackoverflow.com/questions/72535838/how-to-optain-an-optional-with-orelseget" rel="noopener ugc nofollow" target="_blank"><strong class="kz is"><em class="lt"/></strong></a><code class="fe lu lv lw lx b"><a class="ae kw" href="https://stackoverflow.com/questions/72535838/how-to-optain-an-optional-with-orelseget" rel="noopener ugc nofollow" target="_blank"><strong class="kz is"><em class="lt">orElseGet</em></strong></a></code><strong class="kz is"><em class="lt">？</em>T25】</strong></p><p id="0775" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">以下是不可能的:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nm nn l"/></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated"><a class="ae kw" href="https://stackoverflow.com/questions/72535838/how-to-optain-an-optional-with-orelseget" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="84dc" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">目前对于<code class="fe lu lv lw lx b">orElseGet</code>,我们可以添加一个返回值类型的供应商。所以不支持添加<code class="fe lu lv lw lx b">Optional</code>供应商。</p><p id="f714" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我们可以用<code class="fe lu lv lw lx b"><a class="ae kw" href="https://docs.oracle.com/en/java/javase/17/docs/api//java.base/java/util/Optional.html#or(java.util.function.Supplier" rel="noopener ugc nofollow" target="_blank">Optional#or</a></code>来代替。这个操作符使我们能够返回可选值，而不是某个值。尽管如此，这个操作符只适用于 Java 9 和更高版本。对于较低版本，您需要将该值映射到 Optional。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nm nn l"/></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated"><a class="ae kw" href="https://stackoverflow.com/a/72535896/5999670" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="4763" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><strong class="kz is"> <em class="lt">从之前的解决方案中我们可以看出什么？</em> </strong></p><p id="adc6" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">较新的 Java 版本解决了很多可选的问题。Java 9 &amp; 10 增加了很多可选的新方法，所以升级会解决很多问题。</p><p id="847d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">如果你需要的话，Guava Optional 为较低的 Java 版本提供了<code class="fe lu lv lw lx b"><a class="ae kw" href="https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Optional.html#or(com.google.common.base.Optional" rel="noopener ugc nofollow" target="_blank">or</a></code> <a class="ae kw" href="https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Optional.html#or(com.google.common.base.Optional" rel="noopener ugc nofollow" target="_blank">方法</a>。尽管如此，要注意的是，Guava Optional 和 Guava Optional 是不可互换的。如果没有番石榴可选，您需要以下产品:</p><pre class="kh ki kj kk gu mv lx mw mx aw my bi"><span id="6e78" class="mz lz ir lx b gz na nb l nc nd">thisOptional.isPresent() ? thisOptional : secondChoice</span></pre></div><div class="ab cl nf ng hv nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ik il im in io"><p id="96ea" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><strong class="kz is"> <em class="lt">你知道导致代码更简洁的可选做法吗？或者导致更少的问题？</em>T3】</strong></p><p id="e53f" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">请在评论中告诉我们。</p></div></div>    
</body>
</html>