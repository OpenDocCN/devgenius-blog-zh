<html>
<head>
<title>Kotlin sealed class with generic covariance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有一般协方差的 Kotlin 密封类</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/kotlin-sealed-class-with-generic-covariance-7e33875e7002?source=collection_archive---------1-----------------------#2020-10-16">https://blog.devgenius.io/kotlin-sealed-class-with-generic-covariance-7e33875e7002?source=collection_archive---------1-----------------------#2020-10-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="eef3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">协方差作为具有严格规则的契约，使得类类型是可预测的和安全的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/87e38150a7e5b9083cda9d6022ca84fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xrFR0giwI8oEYyUsSpzDFQ.png"/></div></div></figure><p id="f4df" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">协方差方法让我们缩小某些方法的类型，例如:<strong class="jm io"> Int </strong>类型是超类型<strong class="jm io"> Any </strong>的一部分。</p><p id="9c8a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> Kotlin 提供了“in”、“out”保留关键字，以增强我们使用协方差/逆变的工具。</strong></p><p id="6e4a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于“in”泛型，我们可以将超类型的类分配给子类型的类。但是对于“out”泛型，我们可以将子类型的类分配给超类型的类。</p><p id="ec90" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们的类使用泛型类型作为函数的输出，我们在协方差逻辑中使用'<code class="fe ku kv kw kx b">out</code>'。我们将 type 作为参数传递给接口，以便在我们使用的功能方面做到严格和简洁。<code class="fe ku kv kw kx b">Out</code>’表示 T 打算由这个类的方法产生。</p><p id="2a84" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">其实，<br/> 1。当超类型可以被指定为子类型时，使用中的<strong class="jm io">。<br/> 2。当子类型可以分配给超级类型时，使用<strong class="jm io"> out </strong>。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ky"><img src="../Images/f3c14221f535ab69356eaba8dff6878c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sVplq4REfcULJvlzuCTGTQ.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">由卡帕头提供。马尔钦·莫斯卡拉的《学院》</figcaption></figure><p id="af31" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">举例来说，在现实世界中，我们需要展示一组可能性:一个关于成功、失败或进行状态的类。当然，首先我们可以用<code class="fe ku kv kw kx b">enum</code>。但是<strong class="jm io">枚举</strong>有其局限性:每个子类型只能是一个常量，并且没有状态。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="db09" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">界面</strong></p><p id="1e8d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们从头开始调查。在最简单的情况下，我们可以使用常规方法— <strong class="jm io">接口</strong>作为可用方法的契约。我们在自定义类中覆盖预定义的方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="d8f4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们也可以用经典的<strong class="jm io">试试{}最后{}接住{}。它经常会把事情弄得一团糟:</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="8b0d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是这样的代码很难阅读。我们过度填充了一堆代码，有时不太容易发现特定方法的某些异常。</p><p id="205b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">科特林提供了自己的方法。</p><p id="c895" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">是密封类。</strong></p><p id="ea27" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们有不同类型的嵌套类，并保持状态。密封类允许我们表示层次结构。并且它防止继承，这个类是密封的，所以使用嵌套的子类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="69bb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">抽象类上的密封类:</p><p id="70b5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">默认情况下，密封类是抽象的，因此我们可以定义父密封类的嵌套子类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="d005" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当然，我们可以使用简单的普通密封类，但是它太无聊了。更有意思的是玩泛型，把类型当参数传。</p><p id="8951" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">泛型层次结构允许我们更加灵活，因为大多数结果类层次结构看起来非常相似:相同的名称和属性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="7309" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当子类型可以分配给超类型时，协方差提供关键字<strong class="jm io"> out </strong>。它激励我们使用这种类型并保持类型安全。</p><p id="9c6a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我的完整示例如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="5d16" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当关键字时<strong class="jm io">的额外奖励。</strong></p><p id="8646" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当表达式必须详尽时，添加必要的“加载”分支或 else 分支。它可以用于强制执行一个<code class="fe ku kv kw kx b">when</code>语句是穷举的。</p><p id="6242" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ku kv kw kx b">val &lt;T&gt; T.exhaustive: T<br/> get() = this</code></p><p id="f48c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个扩展属性帮助我们不从编辑器和编译器那里得到一个错误:“<em class="lf">‘when’表达式必须是穷举的，添加必要的‘is Error’分支或者‘else’分支来代替</em>”</p><p id="f599" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ku kv kw kx b">when(val result = getResult()) {<br/> is Result.Success -&gt; println(“succeeded”)<br/> is Result.Error -&gt; println(result.cause?.message)<br/> }.exhaustive</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lg"><img src="../Images/1cac06033f9a42f8623f10282f15fbcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*D5Tp-gW7QzsC5H7sWJujzg.jpeg"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">通过楼梯深入代码的海洋…</figcaption></figure><p id="3bb9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">结论</strong></p><p id="474f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用密封类来避免类型错误，并遵循预定义的方法。</p><p id="8b80" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">顺便说一下，ASP.NET C #也有同样功能的<code class="fe ku kv kw kx b">sealed </code>关键字。有时在架构逻辑中，继承应该以这种方式被限制。不同语言中的 OOP 方法非常相似。</p></div></div>    
</body>
</html>