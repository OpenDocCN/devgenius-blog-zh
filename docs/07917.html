<html>
<head>
<title>How to solve the singleton problem in Django ModelAdmin.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何解决 Django ModelAdmin 中的单体问题？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-solve-the-singleton-problem-in-django-modeladmin-4e31cc4f2690?source=collection_archive---------6-----------------------#2022-05-03">https://blog.devgenius.io/how-to-solve-the-singleton-problem-in-django-modeladmin-4e31cc4f2690?source=collection_archive---------6-----------------------#2022-05-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/a784c808982d91c7699a8b0b4be011be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cSFMXGJRf_6PyU5ouSk8sQ.jpeg"/></div></div></figure><p id="53ee" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">来自<em class="kx">django . contrib . admin . options</em>的<code class="fe kt ku kv kw b">ModelAdmin</code>类从一开始就有一个糟糕的设计:你的项目中每个注册的<code class="fe kt ku kv kw b">ModelAdmin</code>都是单例的。</p><p id="e9c9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个事实给每个在项目中使用 Django Admin 的开发人员制造了一个很大的障碍。这减慢了项目的速度，当同一个<code class="fe kt ku kv kw b">ModelAdmin</code>被几个用户使用时会产生问题，并鼓励程序员使用黑客手段来绕过这个(反)模式的限制。在这篇文章中，你可以用 5 行代码来学习如何解决这个问题。</p><p id="b99b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为什么 django.contrib.admin 的开发者继续依赖这个架构对我来说是个谜。</p><p id="824d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">幸运的是，从 Django 的第一个版本到当前版本(2022 年 4 月的 4.0.3 ),这个问题已经有了一个快速简单的解决方案。</p><h1 id="2b00" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">目录:</h1><ul class=""><li id="96b9" class="lw lx in jx b jy ly kc lz kg ma kk mb ko mc ks md me mf mg bi translated"><a class="ae mh" href="#91b7" rel="noopener ugc nofollow"> <strong class="jx io">问题</strong> </a> <strong class="jx io">。</strong>我会详细描述 ModelAdmin 使用 singleton 架构时遇到的问题。</li><li id="cf3b" class="lw lx in jx b jy mi kc mj kg mk kk ml ko mm ks md me mf mg bi translated"><a class="ae mh" href="#f433" rel="noopener ugc nofollow"> <strong class="jx io">解</strong> </a> <strong class="jx io">。</strong>我将带你完成修复，并解释它是如何工作的以及为什么工作。</li><li id="af70" class="lw lx in jx b jy mi kc mj kg mk kk ml ko mm ks md me mf mg bi translated"><a class="ae mh" href="#f141" rel="noopener ugc nofollow"> <strong class="jx io">姜戈 devs </strong> </a> <strong class="jx io">。我请求正在阅读这篇文章的 Django 开发者考虑改变 django.contrib.admin 的结构，让每个人的生活更轻松。</strong></li><li id="cf20" class="lw lx in jx b jy mi kc mj kg mk kk ml ko mm ks md me mf mg bi translated"><a class="ae mh" href="#e645" rel="noopener ugc nofollow"> <strong class="jx io">从 PyCon 2022 说起这个问题</strong> </a> <strong class="jx io">。除了这篇文章，我还有一个来自柏林 2022 年 PyCon DE 的视频。</strong></li></ul><h1 id="91b7" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">问题</h1><h2 id="494c" class="mn kz in bd la mo mp dn le mq mr dp li kg ms mt lm kk mu mv lq ko mw mx lu my bi translated">1.多个用户不能同时使用同一个<code class="fe kt ku kv kw b">ModelAdmin</code>正常工作。</h2><p id="8eee" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg mz ki kj kk na km kn ko nb kq kr ks ig bi translated">当多个用户同时运行管理面板时，singleton 设计模式允许一个用户修改另一个用户的数据。</p><p id="8e3d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我用我上一篇关于<a class="ae mh" rel="noopener ugc nofollow" target="_blank" href="/django-admin-dynamic-inline-positioning-7208596479ce"> Django admin 动态内联定位</a>的文章中的代码来演示一下。现在代码做什么并不重要。我们只是像这样修改管理面板中的功能:</p><figure class="nc nd ne nf gt jo"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">管理. py</figcaption></figure><p id="894d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们打开管理面板的两个选项卡来模拟两个用户。现在让我们打开第一个选项卡上 pk=1 的产品的变更表单(/admin/products/product/1/change)。过了这条线，我们被<code class="fe kt ku kv kw b">breakpoint</code>拦住了:</p><pre class="nc nd ne nf gt nm kw nn no aw np bi"><span id="89ba" class="mn kz in kw b gy nq nr l ns nt">10 self.hello = 'hello this is the first obj'</span></pre><p id="4757" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们检查<code class="fe kt ku kv kw b">self.hello</code>属性，我们会看到以下内容:</p><figure class="nc nd ne nf gt jo gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/2632ceb2212f8421ed3d34b1ee906fac.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/0*7lBqbZs-CtK0AiL_"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">调试器输出第一个线程</figcaption></figure><p id="032d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们在另一个选项卡('/admin/products/product/2/change ')中打开一个 pk=2 的产品的变更表单，看看会发生什么。我们马上从变更表单中得到响应，因为我们跳过了<code class="fe kt ku kv kw b">breakpoint</code>。但是让我们看看在第一个选项卡中为<code class="fe kt ku kv kw b">ModelAdmin</code>设置的<code class="fe kt ku kv kw b">hello</code>属性发生了什么。</p><figure class="nc nd ne nf gt jo gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/342d8419c6a9a6a4a180f6deb4be3677.png" data-original-src="https://miro.medium.com/v2/resize:fit:438/0*7zF2SKxsDaXGATya"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">第二个线程结束后，第一个线程中的调试器输出</figcaption></figure><p id="87d4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的 GET 请求 pk=1 的<code class="fe kt ku kv kw b">ModelAdmin.hello</code>属性已经更改为“这是第二个 obj”，尽管我们在第一个线程中什么也没做。</p><p id="da75" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们证明了<code class="fe kt ku kv kw b">ModelAdmin</code>是单例的，这意味着我们总是得到同一个<code class="fe kt ku kv kw b">ModelAdmin</code>实例。</p><p id="2461" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是一个简单的问题演示。因为在这个例子中没有真正的后果，一些人甚至认为它是微不足道的，但是这种行为对我们的项目的后果可能是危险的。</p><p id="2fee" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于这种行为，每个 ModelAdmin 都不能保证数据的完整性，因为不可能跟踪谁编辑了数据。这个当前线程编辑了我们的数据吗？另一个请求在我们不知情的情况下改变了什么吗？谁知道呢。</p><p id="8d35" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可能会认为这不是问题，因为请求必须同时发生，这个问题才会生效。然而，在一个多个人同时运行管理面板的项目中，问题不在于是否有人同时打开<code class="fe kt ku kv kw b">ModelAdmin</code>，而在于何时打开<strong class="jx io">。</strong></p><p id="b3a0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这导致了错误，如果没有对管理面板架构的深入理解，就没有明显的解释。</p><p id="7440" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以避免这个问题的最简单的方法就是不要使用<code class="fe kt ku kv kw b">ModelAdmin</code>实例作为容器。</p><blockquote class="nw nx ny"><p id="85fc" class="jv jw kx jx b jy jz ka kb kc kd ke kf nz kh ki kj oa kl km kn ob kp kq kr ks ig bi translated"><em class="in">但并不是每个开发者都意识到了这一点，</em> <code class="fe kt ku kv kw b"><em class="in">ModelAdmin</em></code> <em class="in">经常被没有经验的开发者用来存储数据。在这个</em> <a class="ae mh" href="https://stackoverflow.com/questions/727928/django-admin-how-to-access-the-request-object-in-admin-py-for-list-display-met/23574558#23574558?newreg=fca9027c603a4c18b9f6e584986b3f2a" rel="noopener ugc nofollow" target="_blank"> <em class="in">的例子中</em> </a> <em class="in">的最高投票答案正是如此。</em></p></blockquote><p id="9fa7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们不能使用<code class="fe kt ku kv kw b">ModelAdmin</code>，那么我们的数据可以存储在哪里？Django 默认没有给我们明确的答案。</p><h2 id="ed4c" class="mn kz in bd la mo mp dn le mq mr dp li kg ms mt lm kk mu mv lq ko mw mx lu my bi translated">2.劈</h2><p id="8750" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg mz ki kj kk na km kn ko nb kq kr ks ig bi translated">由于不能使用 ModelAdmin 的实例作为容器，开发人员正在寻找其他选择。</p><p id="700f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我发现的大多数解决方法<a class="ae mh" href="https://gist.github.com/vparitskiy/71bb97b4fd2c3fbd6d6db81546622346" rel="noopener ugc nofollow" target="_blank">是将信息存储在一个全局字典中，并将其映射到当前线程的本地。是的，那是可行的，但是难道不应该有比那更好的方法吗？</a></p><h2 id="d5b5" class="mn kz in bd la mo mp dn le mq mr dp li kg ms mt lm kk mu mv lq ko mw mx lu my bi translated">3.速度</h2><p id="2c14" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg mz ki kj kk na km kn ko nb kq kr ks ig bi translated">如果有可能使用<code class="fe kt ku kv kw b">ModelAdmin</code>作为数据的容器，Django 自己也能做到。目前 Django 在同一个请求中重复调用某些<code class="fe kt ku kv kw b">ModelAdmin</code>方法来获得相同的结果。所有这些结果都应该被缓存。如果<code class="fe kt ku kv kw b">ModelAdmin</code>表现得像 Django-GCBV 一样，我们可以节省宝贵的计算时间。</p><p id="4c91" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下表显示了每个请求调用以下<code class="fe kt ku kv kw b">ModelAdmin</code>方法几次的频率:</p><figure class="nc nd ne nf gt jo"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="9788" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对某些方法的调用次数取决于<code class="fe kt ku kv kw b">AdminForm</code>或<code class="fe kt ku kv kw b">ModelForm</code>字段的数量。</p><p id="06d2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们比较一下默认情况下“普通的”Django 管理面板和使用 ModelAdmin 的缓存方法的 Django 管理面板的响应时间。作为一个代码示例，我从我的<a class="ae mh" href="https://dev.to/danilovmy/django-admin-dynamic-inline-positioning-3cam" rel="noopener ugc nofollow" target="_blank">上一篇文章</a>中选取了这个项目:</p><p id="a31d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我创建了一个中间件，它输出请求和响应之间经过的时间:</p><figure class="nc nd ne nf gt jo"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">计时中间件</figcaption></figure><p id="0ef6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果中间件代码被执行，我们将得到结果:</p><figure class="nc nd ne nf gt jo"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">时间结果</figcaption></figure><p id="16e2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如您所见，即使在这个简单的项目中，由于缓存了计算函数的结果，速度也提高了近 20% ！</p><p id="08ff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">重构整个<code class="fe kt ku kv kw b">ModelAdmin</code>类可以大大提高这个速度，因为它目前是一段臃肿的 spagetty 代码。</p><h1 id="f433" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">解决方案</h1><p id="9ef7" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg mz ki kj kk na km kn ko nb kq kr ks ig bi translated">现在让我们来看看 Django 的单身族是从哪里来的，并尝试解决它。</p><p id="4b0f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当<code class="fe kt ku kv kw b">AdminSite</code>的实例从<em class="kx">django . contrib . admin . sites</em>注册时，就会创建<code class="fe kt ku kv kw b">ModelAdmin</code>的每个实例。</p><p id="6dec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<code class="fe kt ku kv kw b">AdminSite</code>类的 docstring 中，我们了解到<code class="fe kt ku kv kw b">get_urls</code>方法用于从 ModelAdmin 的每个注册实例中检索视图。感谢这个 docstring 的作者。</p><p id="50b1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<code class="fe kt ku kv kw b">AdminSite.get_urls</code>中，我们可以找到这段被截取的代码:</p><figure class="nc nd ne nf gt jo"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated"><code class="fe kt ku kv kw b">AdminSite.get_urls method</code></figcaption></figure><p id="15e1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们看到调用了<code class="fe kt ku kv kw b">ModelAdmin.urls</code>属性。该属性返回<code class="fe kt ku kv kw b">ModelAdmin.get_urls</code>方法的结果。所以，让我们探索一下这个方法<code class="fe kt ku kv kw b">get_urls</code>做了什么:</p><figure class="nc nd ne nf gt jo"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">模型管理员获取 _ urls</figcaption></figure><p id="4395" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">乍一看，这似乎是一大堆代码，但是让我们一段一段地解开它。让我们从底层开始探索这段代码。</p><p id="cb2c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">返回的列表是为 url 调度程序创建的。它包含来自<strong class="jx io"> url </strong>、要调用的<strong class="jx io">视图</strong>和视图的<strong class="jx io">名称</strong>的元组。</p><p id="339f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对我们来说重要的是，什么是作为<strong class="jx io">视图</strong>给出的。这是一个<strong class="jx io"> ModelAdmin 实例</strong>的包装<strong class="jx io">有界方法</strong>。那么，让我们来看看这个包装器<code class="fe kt ku kv kw b">wrap</code>是做什么的。</p><p id="296d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">幸运的是，这个包装器<code class="fe kt ku kv kw b">wrap</code>就在上面定义了。<code class="fe kt ku kv kw b">wrap</code>末尾的<code class="fe kt ku kv kw b">update_wrapper</code>并不重要，它只是让最终视图表现得像一个<strong class="jx io"> ModelAdmin 实例</strong>。</p><p id="60fe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kt ku kv kw b">wrapper</code>函数的主体对我们的任务至关重要。这里我们看到一个调用<code class="fe kt ku kv kw b">admin_site.admin_view</code>的调用，使用<strong class="jx io"> ModelAdmin 实例</strong>的<strong class="jx io">有界方法</strong>作为参数。<code class="fe kt ku kv kw b">admin_site</code>是<code class="fe kt ku kv kw b">AdminSite</code>的实例，在其上注册了<strong class="jx io"> ModelAdmin 实例</strong>。</p><p id="b518" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们需要覆盖这个方法来摆脱 Django ModelAdmin 对单例模式的诅咒。</p><p id="6886" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所有这些解释都是为了一个需要被覆盖的简单函数。是的，因为如果不知道整个系统是如何工作的，我们就不会明白如何正确地忽略这个函数来解决我们的问题而不破坏任何东西。</p><p id="3b64" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们创建一个<code class="fe kt ku kv kw b">AdminSite</code>的子类并覆盖<code class="fe kt ku kv kw b">admin_view</code>方法，如下所示:</p><figure class="nc nd ne nf gt jo"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">修复我们的单例问题</figcaption></figure><p id="33bb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们忽略所有的包装器，专注于这几行代码:</p><pre class="nc nd ne nf gt nm kw nn no aw np bi"><span id="4b1f" class="mn kz in kw b gy nq nr l ns nt">new_instance = type(instance)(instance.model, instance.admin_site) return func.__func__(new_instance, *args, **kwargs)</span></pre><p id="d8fe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kx"> func </em>是 ModelAdmin 的 singleton <em class="kx">实例</em>的一个有界方法，它对于每个查询总是相同的。</p><p id="cb72" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kx"> func </em>的<code class="fe kt ku kv kw b">__func__</code>属性是<code class="fe kt ku kv kw b">ModelAdmin</code>类的一个方法。它不再与<code class="fe kt ku kv kw b">ModelAdmin</code>的任何实例相关联。</p><blockquote class="nw nx ny"><p id="41b0" class="jv jw kx jx b jy jz ka kb kc kd ke kf nz kh ki kj oa kl km kn ob kp kq kr ks ig bi translated"><em class="in">这里我用的是 python 术语</em> <strong class="jx io"> <em class="in">绑定</em> </strong> <em class="in">和</em> <strong class="jx io"> <em class="in">未绑定</em> </strong> <em class="in">的方法。</em> <code class="fe kt ku kv kw b"><em class="in">func.__func__</em></code> <em class="in">没有绑定</em> <code class="fe kt ku kv kw b"><em class="in">func.__self__</em></code> <em class="in">的实例，但也不是静态函数，它是一个类方法。仍然需要与</em> <code class="fe kt ku kv kw b"><em class="in">func.__self__</em></code> <em class="in">同类的实例作为调用该方法的第一个参数。</em></p></blockquote><p id="30e2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了创建<code class="fe kt ku kv kw b">ModelAdmin</code>的<strong class="jx io">新实例</strong>，我们需要 model 和 admin_site 作为参数，这可以很容易地从旧的 singleton-instance 中获得。</p><p id="4304" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们可以返回'<strong class="jx io"> func </strong>'调用，使用<strong class="jx io">新实例</strong>作为自身，以及在调用时传递的参数*args 和**kwargs。</p><p id="11c8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在单例架构被成功绕过了。</p><p id="e117" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">这意味着每次向视图发送请求时，都会创建一个新的 ModelAdmin 实例，并调用其对应的视图函数</strong></p><p id="0781" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如前所述，从姜戈开始就有可能避免所有这些痛苦。</p><p id="b3a6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">剩下的工作就是将我们的子 AdminSite 作为项目中的默认设置。</p><p id="4bf2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以像这样创建一个<code class="fe kt ku kv kw b">AdminConfig</code>类的孩子:</p><figure class="nc nd ne nf gt jo"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="f152" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kt ku kv kw b">default_site</code>属性必须与你的<code class="fe kt ku kv kw b">AdminSite</code>类匹配。</p><p id="2064" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，在 INSTALLED_APPS 的 settings.py 中注册<code class="fe kt ku kv kw b">AdminConfig</code>完成修改。记得删除默认的管理面板。</p><figure class="nc nd ne nf gt jo"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="8512" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个新的管理面板目前的形式并不比旧的快。我们仍然需要缓存<code class="fe kt ku kv kw b">ModelAdmin</code>方法。为此，您可以为 ModelAdmin 创建一个 Mixin，并将上述方法包装如下:</p><figure class="nc nd ne nf gt jo"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="33c8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个缓存实现没有任何问题，但是如果你担心用不同的参数多次调用同一个方法，你可以用<a class="ae mh" href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="noopener ugc nofollow" target="_blank"> memoize 包装器</a>包装这些方法。这也会降低我们解决方案的速度提升。</p><h1 id="d1a6" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="0119" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg mz ki kj kk na km kn ko nb kq kr ks ig bi translated">我喜欢 Django 框架。这是帮助我创造伟大事物的强大工具。我可以用一小段代码在正确的地方修复这个框架的任何问题。但是找到那个地方并不容易。而 Django 的文档帮不上忙。缺少文件——这是 Django 最大的问题。</p><h1 id="f141" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Django devs</h1><p id="76e3" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg mz ki kj kk na km kn ko nb kq kr ks ig bi translated">我希望在我在这篇文章中提出的观点之后，你会同意 Django 在管理面板中实现单例架构存在严重的问题。这种模式使得管理面板变得麻烦和缓慢，需要做些事情来解决它。我在这里写下如何做到这一点。</p><p id="c29f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我提出的修复是改进 Django 管理面板的重要的第一步，但不幸的是，下一步工作要在实现之后才开始。ModelAdmin 类代码需要大大改进，我问了一下，例如，本期中的<a class="ae mh" href="https://code.djangoproject.com/ticket/33028" rel="noopener ugc nofollow" target="_blank">，但如果可以做到，我确信 Django 管理面板将是一个更好的工作工具。</a></p><h1 id="e645" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">PyCon 2022 上的单身问题讲座</h1><p id="840c" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg mz ki kj kk na km kn ko nb kq kr ks ig bi translated">我在许多场合都谈到过这个问题。你可以看到我 2022 年 4 月在柏林皮肯德的视频，我<a class="ae mh" href="https://medium.com/@danilovmy/the-python-and-django-conferences-you-dont-want-to-miss-in-2022-82c53257254" rel="noopener">在这里写了</a>我将在那次会议上发言。</p><figure class="nc nd ne nf gt jo"><div class="bz fp l di"><div class="oc nh l"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">在 PyCon 2022 上演讲</figcaption></figure></div></div>    
</body>
</html>