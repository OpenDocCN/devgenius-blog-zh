<html>
<head>
<title>4 Authentication Schemes Every Developer Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个开发人员都应该知道的 4 种身份验证方案</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/4-authentication-schemes-every-developer-should-know-c5961d584b81?source=collection_archive---------12-----------------------#2022-12-21">https://blog.devgenius.io/4-authentication-schemes-every-developer-should-know-c5961d584b81?source=collection_archive---------12-----------------------#2022-12-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="44f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">🚀<a class="ae kl" href="https://learnbackend.dev/books/build-layered-microservices" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">打造分层微服务</strong> </a>这本书出来了！现在就在<a class="ae kl" href="https://learnbackend.dev/books/build-layered-microservices" rel="noopener ugc nofollow" target="_blank"> learnbackend.dev </a>购买你自己的副本。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/54dcd97c776d82535ccb0a609edbcfc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dpKMAxAf4yCNFNG_jIuwnQ.jpeg"/></div></div></figure><p id="7352" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">身份验证是验证用户是否是他们所声称的人的行为，并且构成了任何安全过程中防止私人数据落入坏人之手的第一道防线。</p><p id="8ce2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它可以是单因素的，这意味着只进行一次验证以断言用户的身份，也可以是多因素的，这意味着将进行两次或更多次验证。</p><p id="468a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们将介绍每个开发人员都应该知道的 4 种最流行的身份验证方案。</p><h1 id="ccb2" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">基本访问认证</h1><p id="3f34" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated"><strong class="jp ir">基本访问认证</strong>是一种 HTTP 认证方案，客户端(如网络浏览器)在向服务器发出请求时提供用户名和密码。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mb"><img src="../Images/f796ac755fb7e2a6a8b0b3971e2ca37d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2fJO-qt0uOSqzmGEFC_1jA.jpeg"/></div></div></figure><p id="7864" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些凭证以<strong class="jp ir"> Base64 </strong>编码字符串的形式在 HTTP 请求的<code class="fe mc md me mf b">Authorization</code>头中指定:</p><pre class="kn ko kp kq gt mg mf mh bn mi mj bi"><span id="0c43" class="mk kz iq mf b be ml mm l mn mo">Authorization: Basic &lt;credentials&gt;</span></pre><p id="8e6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其中用户名和密码用一个冒号连接(例如<code class="fe mc md me mf b">username:password</code>)。</p><p id="9f52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">提醒一下，<strong class="jp ir">编码</strong>是将一段数据转换成另一种形式的过程，目的是使其更短或更秘密，但这可以使用相同的算法轻松逆转——其主要目标是确保数据的可用性。</p><p id="11f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如:</p><pre class="kn ko kp kq gt mg mf mh bn mi mj bi"><span id="c8ae" class="mk kz iq mf b be ml mm l mn mo">Authorization: Basic am9obmRvZUBtYWlsLmNvbTpoZWxsb3dvcmxk</span></pre><p id="f397" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，因为凭据是编码的而不是加密的，所以此方法实际上并不提供机密性保护，因此必须与 HTTPS 结合使用。</p><h1 id="3236" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">承载认证</h1><p id="a8b2" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated"><strong class="jp ir">承载认证</strong>是一种 HTTP 认证方案，涉及称为<strong class="jp ir">承载令牌</strong>的安全令牌。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mb"><img src="../Images/4df89377de8ed8fc7ed888f8a35bfb5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zbg2E0wQatcCQ8ZrmJD-Fw.jpeg"/></div></div></figure><p id="79ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">类似于<strong class="jp ir">基本访问认证</strong>，它涉及到放置在 HTTP 请求的<code class="fe mc md me mf b">Authorization</code>报头中的令牌的使用。但是，不同之处在于，这个令牌不是客户端生成的，而是服务器为响应登录请求而生成的。</p><pre class="kn ko kp kq gt mg mf mh bn mi mj bi"><span id="bba9" class="mk kz iq mf b be ml mm l mn mo">Authorization: Bearer &lt;token&gt;</span></pre><p id="572d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不过需要记住的一点是，这种类型的令牌通常有一个预定义的有效期，以秒为单位，在某个时间点会被系统视为过期。</p><p id="2adb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当这种情况发生时，客户端必须从服务器请求一个新的令牌，这可以通过邀请用户再次经历登录过程来完成，或者通过使用一个更透明的机制来完成，称为<strong class="jp ir">刷新令牌</strong>。</p><p id="140d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">刷新令牌是与访问令牌一起发送的特殊令牌，其具有更长的有效持续时间，并且用于在新的访问令牌到期时透明地请求新的访问令牌，而无需用户注意或执行任何动作。</p><p id="477b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不过，一个好的做法是，一旦这些刷新令牌被用来请求新的访问令牌，就使它们无效，以保护应用程序免受令牌泄露和重放攻击。</p><h1 id="ad61" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">OAuth</h1><p id="a2bc" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">代表<strong class="jp ir">开放授权</strong>的 OAuth 是一个专门设计用于 HTTP 的协议，它为资源所有者指定了一个允许可信授权服务器向第三方客户端发布这些资源的访问令牌的过程。</p><p id="9477" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">几年前，网络和移动应用程序开始大量交互，最终使用户能够使用另一个服务的帐户连接到一个服务，例如使用你的谷歌帐户登录你的健身或烹饪应用程序。</p><p id="6233" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了避免再次要求用户提供凭据，第三方应用程序通常会保留用户的密码而不进行加密，这除了安全问题之外，还意味着这些应用程序能够自由访问任何受保护的信息。</p><p id="1404" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了解决这些问题，OAuth 2.0 被创建来允许应用程序之间在最佳的安全上下文中进行交互。</p><p id="7778" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">OAuth 协议涉及 4 个参与者:</p><ul class=""><li id="653e" class="mp mq iq jp b jq jr ju jv jy mr kc ms kg mt kk mu mv mw mx bi translated">资源所有者。</li><li id="e6c8" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk mu mv mw mx bi translated">客户。</li><li id="c560" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk mu mv mw mx bi translated">授权服务器。</li><li id="a921" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk mu mv mw mx bi translated">资源服务器。</li></ul><p id="cd82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是 OAuth 协议工作原理的简单概述。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mb"><img src="../Images/de9eca1907dbd291c6b016a08a39c949.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DxJx7hvO-Y3aYBHWvsCNgg.jpeg"/></div></div></figure><ol class=""><li id="c86f" class="mp mq iq jp b jq jr ju jv jy mr kc ms kg mt kk nd mv mw mx bi translated">客户端(第三方应用程序或服务器)向资源所有者(用户)发送访问请求。</li><li id="74d5" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk nd mv mw mx bi translated">然后，客户端查询授权服务器，授权服务器用一个访问令牌进行响应。</li><li id="33b7" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk nd mv mw mx bi translated">一旦获得了令牌，客户机最终就能够通过查询资源服务器来检索受保护的资源。</li></ol><h1 id="63a6" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">API 键</h1><p id="5068" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">一个<strong class="jp ir"> API 密钥</strong>是一个唯一的标识符——通常是随机生成的——用于认证和授予调用程序对 API 的某些访问权限。</p><pre class="kn ko kp kq gt mg mf mh bn mi mj bi"><span id="c758" class="mk kz iq mf b be ml mm l mn mo">AidlASdkmudXbsdfgFLOmn4idsfsdhf</span></pre><p id="4865" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与授权令牌不同，API 密匙是专门为项目而不是用户设计的，因为它们并不安全，因为它们的值很容易在嵌入它们的源代码中检索到。</p><p id="b81f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了帮助识别进行 API 调用的项目之外，它们还用于跟踪和控制该接口的使用方式:</p><ul class=""><li id="275c" class="mp mq iq jp b jq jr ju jv jy mr kc ms kg mt kk mu mv mw mx bi translated">它们有助于限制 IP 范围和操作环境。</li><li id="a25f" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk mu mv mw mx bi translated">它们能够阻止匿名流量，而匿名流量可能是潜在恶意活动的指示器。</li><li id="6c8d" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk mu mv mw mx bi translated">它们通过控制和限制对 API 的调用次数来帮助使用 API。</li><li id="9de7" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk mu mv mw mx bi translated">最后，他们帮助分析和调试一个或多个客户可能遇到的问题。</li></ul><p id="e99c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">值得注意的是，与令牌相比，API 密钥很少过期，但可以很容易地停用，只需从数据库中删除它们。</p><h1 id="dc58" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">下一步是什么？</h1><p id="6e71" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">👉在<a class="ae kl" href="https://learnbackend.dev/" rel="noopener ugc nofollow" target="_blank"> https://learnbackend.dev </a>查看《如何使用 Express framework 构建生产就绪的分层认证微服务》一书<a class="ae kl" href="https://learnbackend.dev/books/build-layered-microservices" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">构建分层微服务</strong> </a>，该书从第一行代码到最后一行文档都符合开发实践和软件架构方面的行业标准。</p></div></div>    
</body>
</html>