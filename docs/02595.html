<html>
<head>
<title>About the *most important* tag above Graph Theory?!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于图论上面的*最重要*标签？！</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/about-the-most-important-tag-above-graph-theory-858c58654c06?source=collection_archive---------7-----------------------#2020-08-14">https://blog.devgenius.io/about-the-most-important-tag-above-graph-theory-858c58654c06?source=collection_archive---------7-----------------------#2020-08-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="b51d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们确实经常在几乎每个视频或文章的算法旁边看到最重要的标签，以及破解编码采访的图表。因此，在本文中，我们将对此进行简单的探讨。这更侧重于结构的应用和它的整体重要性，所以您可能想看另一篇关于实现或算法分析的文章。</p><p id="0bb4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">说到编码面试，一定要看看<a class="ae kj" href="https://vxhltech.hashnode.dev/about-the-most-important-tag-above-graph-theory-ckdbubgqz02dh66s185u1gufr?guid=none&amp;deviceId=7f5c5574-c372-42b5-8c96-4c2fea28f348" rel="noopener ugc nofollow" target="_blank">编码技巧的</a>博客关于<a class="ae kj" href="https://codinglanguages.hashnode.dev/how-to-ace-coding-interviews-the-ultimate-guide-ckcxekdxp00bqois16r59a9c1" rel="noopener ugc nofollow" target="_blank">如何在编码面试中胜出</a>。当我面试的时候，我可能会参考这个指南。</p><blockquote class="kk kl km"><p id="ccf6" class="jk jl ki jm b jn jo jp jq jr js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kh ig bi translated"><em class="in">图是一种数据结构。数据结构是一种有效组织数据的方式，在图中，数据以顶点/节点和边之间的网络的符号表示来组织。</em></p></blockquote><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi kq"><img src="../Images/44c768bf44138da9a474dfaf4276d857.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZiHRJvqw6AuKxuaw"/></div></div></figure><p id="839c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以把节点看作是数据块(T8 ),把边看作是这些数据块之间的关系(T10)。</p><p id="2894" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有向图指定特定顶点与其他顶点的访问度(从当前节点访问的节点数),无向图不指定访问度。其他包括加权图，其中每个边被赋予特定的数字权重。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi lc"><img src="../Images/3ebaa6c850c8d21a7475818f414f74f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/0*V2NQASkZykEjLqZl"/></div></figure><h1 id="08e4" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">实施情况简介:</h1><p id="ed87" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">有三种方法可以实现图形:</p><p id="a333" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="ki"> 1。邻接表:</em> </strong></p><p id="b173" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当图很稀疏时，也就是边的数量比可能的节点数量少得多时，经常使用这种方法。它的存储效率很高，并且很好地表示了稀疏图。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/fbbba9f0a2ba0256ca3016a86dd3e355.png" data-original-src="https://miro.medium.com/v2/resize:fit:642/0*Ew-FSc7ONsg578Iz"/></div></figure><p id="61d3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">节点作为对象存储，每个节点都有一个相邻节点的列表。这种数据结构允许以列表的形式在节点上存储附加数据。示例:</p><p id="e28d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，我们可以看到Alice Smith通过列表与每个人连接，连接的类型由字典键表示。</p><p id="71f8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">②<em class="ki">。邻近矩阵:</em> </strong></p><p id="012d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这在图形密集或连接速度需要超快的情况下使用。由于矩阵实现，确定节点A和节点B之间的连接需要O(1)的时间复杂度。主要缺点是存储需求为O(N&gt;2)，其中N是节点数。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/533d39908773a2688e8c7ae92efb8b5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:554/0*zERXT0gkvSwQku8v"/></div></figure><p id="c639" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2D列表，其中第一维索引表示源节点，第二维索引表示目的节点。听起来很简单是的。例如，在列表<code class="fe mi mj mk ml b">list[0][1]</code>中，<code class="fe mi mj mk ml b">0</code>表示第0个索引源节点，1表示第1个索引目的节点。如果两个节点之间的关系有特定的权重(quanititative value)，则<code class="fe mi mj mk ml b">list[0][1]=4</code>的值将是它的权重。节点的数据必须从邻接矩阵外部存储。</p><p id="834d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="ki"> 3。关联矩阵:</em> </strong></p><p id="3c49" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这在边缘非常重要的时候使用。如果我更关心关系而不是关系中的节点，这可能是有帮助的。</p><p id="a82e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2D列表，其中第一维表示节点，第二维表示边。例如，在列表<code class="fe mi mj mk ml b">list[0][1]</code>中，<code class="fe mi mj mk ml b">0</code>代表第0个索引源节点，1代表第1条边。当您想要进行复杂的矩阵运算或搜索关系时，例如给我所有具有“兄弟”关系的节点，这是非常有用的。</p><p id="3142" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要更详细地了解技术方面，你可以看看这篇文章。我更喜欢它们来满足我大部分的DSAlgo需求。</p><blockquote class="kk kl km"><p id="f24d" class="jk jl ki jm b jn jo jp jq jr js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kh ig bi translated"><em class="in">每一个非平凡程序都是一个图。函数调用、变量访问和作用域、对象，所有这些都是图论。</em></p></blockquote><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi mm"><img src="../Images/f534da2e4ffdd46b27d9bf71f2b28ecd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UpJz68oOOOSqomNA"/></div></div></figure><blockquote class="kk kl km"><p id="edd9" class="jk jl ki jm b jn jo jp jq jr js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kh ig bi translated"><em class="in">如果你想要更明确的东西，每</em> <a class="ae kj" href="https://en.wikipedia.org/wiki/Memory_management" rel="noopener ugc nofollow" target="_blank"> <em class="in">内存管理方法</em> </a> <em class="in">。最简单的</em> <a class="ae kj" href="https://en.wikipedia.org/wiki/Tracing_garbage_collection" rel="noopener ugc nofollow" target="_blank"> <em class="in">标记-清除</em> </a> <em class="in">涉及到创建一个有向图的</em> <a class="ae kj" href="https://en.wikipedia.org/wiki/Minimum_spanning_tree#:~:text=For%20directed%20graphs%2C%20the%20minimum,Chu%E2%80%93Liu%2FEdmonds%20algorithm.&amp;text=Such%20a%20tree%20can%20be,problem%20on%20the%20new%20graph." rel="noopener ugc nofollow" target="_blank"> <em class="in">生成树</em> </a> <em class="in">。有效地使用</em><a class="ae kj" href="https://en.wikipedia.org/wiki/Reference_counting" rel="noopener ugc nofollow" target="_blank"><em class="in"/></a><em class="in">引用计数需要了解</em> <a class="ae kj" href="https://en.wikipedia.org/wiki/Cyclic_graph" rel="noopener ugc nofollow" target="_blank"> <em class="in">循环</em> </a> <em class="in">和非循环图。</em></p></blockquote><p id="ea08" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">更具体地说，冒险游戏也是一个例子。位置是<strong class="jm io">顶点</strong>，它们之间的运动需要<strong class="jm io">边</strong>的遍历。自动帮助需要找到它们之间的路径。此外，谷歌地图涉及到寻找从源到目的地的最短路径，涉及到使用像Djikstra的算法。</p><p id="a1c7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为一个问题选择一种算法是一个偏好的问题。在以下情况下:</p><p id="d34b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">还有很多，一个延伸到另一个。不需要完全了解它们，但我们可以尝试一些很酷的个人项目，其中最受欢迎的项目包括使用Djikstra算法的寻路可视化工具，它可以保证到目的节点的最短路径，或者使用A*算法对其进行优化，以用于更实际的应用。</p><ul class=""><li id="fb48" class="mn mo in jm b jn jo jr js jv mp jz mq kd mr kh ms mt mu mv bi translated">看看这个<a class="ae kj" href="https://clementmihailescu.github.io/Pathfinding-Visualizer/" rel="noopener ugc nofollow" target="_blank">路径寻找可视化工具</a>，由Clement使用不同的图遍历算法。这真是太酷了。</li><li id="21aa" class="mn mo in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated">这里有一个<a class="ae kj" href="https://awesomeopensource.com/projects/pathfinding" rel="noopener ugc nofollow" target="_blank">寻路项目列表</a>供参考。</li></ul><h1 id="1003" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">1.网络系统及其安全性:</h1><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi nb"><img src="../Images/a6c455507c0df2bc0ce2e91f47ee04d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*T41dC_oAKhbkvSxg"/></div></div></figure><p id="6ab2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">推特社交图</em></p><p id="050d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在没有图数据模型的情况下，在这些类型的图中确定朋友的朋友和其他关系路径可能是痛苦的，并且在只有相对较少的记录的情况下变得非常低效。</p><p id="4350" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">图论广泛应用于网络系统的表示。网络中的图论可以观察到两类:<a class="ae kj" href="https://en.wikipedia.org/wiki/Topology" rel="noopener ugc nofollow" target="_blank">拓扑</a>和<a class="ae kj" href="https://en.wikipedia.org/wiki/Network_theory" rel="noopener ugc nofollow" target="_blank">网络理论</a>。拓扑是以各种格式表示网络结构的方式，有助于简化问题并获得更准确的结果。术语网络和图是相似的，因为两者都指顶点和边排列的拓扑(结构)。术语网络理论代表了使用拓扑分析图形和应用网络理论的不同方法。更简单地说，它对确定关系很有帮助。</p><blockquote class="kk kl km"><p id="3006" class="jk jl ki jm b jn jo jp jq jr js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kh ig bi translated"><em class="in">ESAT和法国海军病毒学和密码学实验室的计算机科学家团队最近使用了</em> <a class="ae kj" href="https://en.wikipedia.org/wiki/Vertex_cover" rel="noopener ugc nofollow" target="_blank"> <em class="in">顶点覆盖</em> </a> <em class="in">算法来设计实时保护网络免受病毒攻击的最佳策略。这是设计网络防御策略的最佳解决方案。网络活动用于解决大量的组合问题。</em></p></blockquote><h1 id="9475" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">2.网站设计:</h1><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi nc"><img src="../Images/49742be76144e1ec514cd91b6c5989d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jAtenipZH2Cql7qI"/></div></div></figure><p id="ae0b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">图论用于网站设计过程的建模，其中网页用顶点表示，网页之间的超链接用图中的边表示。这个概念被称为<a class="ae kj" href="https://en.wikipedia.org/wiki/Webgraph" rel="noopener ugc nofollow" target="_blank">网络图</a>。图形表示有助于找到所有连接的组件，使用有向图我们可以评估网站的效用和层次结构。</p><h1 id="12f2" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">3.数据科学问题:</h1><p id="9c2d" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">在数据科学中，有各种各样的实体，它们相互之间有不同的相关性，以获得最佳的洞察力。图表有助于使用不同的算法描述这些关系，例如:</p><ul class=""><li id="5077" class="mn mo in jm b jn jo jr js jv mp jz mq kd mr kh ms mt mu mv bi translated">最短路径算法</li><li id="dac7" class="mn mo in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated">最小生成树</li><li id="d589" class="mn mo in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated">PageRank算法</li></ul><p id="13db" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">更多的数据正被用于数据科学中不同的商业问题。要了解更多细节，请查看<a class="ae kj" href="https://towardsdatascience.com/data-scientists-the-five-graph-algorithms-that-you-should-know-30f454fa5513" rel="noopener" target="_blank">这篇</a>文章进行深入研究。</p><h1 id="50f1" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">4.操作系统:</h1><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi nd"><img src="../Images/46ec69962b7be604dd942a1af8d7a7f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*96aOOpNrAlp8p5xp"/></div></div></figure><p id="fd57" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">操作系统是一个程序，作为用户和计算机硬件之间的接口。操作系统的目的是提供一个环境，在这个环境中，用户可以以一种高效和方便的方式执行程序。图论在操作系统解决<a class="ae kj" href="https://en.wikipedia.org/wiki/Job_scheduler" rel="noopener ugc nofollow" target="_blank">作业调度</a>和<a class="ae kj" href="https://en.wikipedia.org/wiki/Resource_allocation" rel="noopener ugc nofollow" target="_blank">资源分配</a>问题中发挥着重要作用。<a class="ae kj" href="https://en.wikipedia.org/wiki/Graph_coloring" rel="noopener ugc nofollow" target="_blank">图着色</a>的概念应用于CPU的作业调度问题。假设作业是图的顶点，在两个不能同时执行的作业之间会有一条边。图表也用于磁盘调度算法。</p><p id="f797" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是本文的全部内容，希望它能对应用程序方面有所启发。这篇文章纯粹是出于好奇，而我正在学习所有关于图形数据结构和实现它，所以我花了我的时间。如果你觉得这很有帮助，请留下赞并分享。注销:)。</p></div><div class="ab cl ne nf hr ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ig ih ii ij ik"><p id="57c5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">原发布于</em><a class="ae kj" href="https://vxhltech.hashnode.dev/about-the-most-important-tag-above-graph-theory-ckdbubgqz02dh66s185u1gufr" rel="noopener ugc nofollow" target="_blank"><em class="ki">https://vxhltech . hash node . dev</em></a><em class="ki">。</em></p></div></div>    
</body>
</html>