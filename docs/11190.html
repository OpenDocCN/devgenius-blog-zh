<html>
<head>
<title>Elasticsearch — solution to searching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">弹性搜索——搜索的解决方案</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/elasticsearch-solution-to-searching-71116220c82f?source=collection_archive---------0-----------------------#2022-12-24">https://blog.devgenius.io/elasticsearch-solution-to-searching-71116220c82f?source=collection_archive---------0-----------------------#2022-12-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="e368" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">企业级搜索和分析引擎</p><p id="7ce9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Elasticsearch 是我们自己的数据的全文搜索引擎。它将我们的数据编入索引，并通过 HTTP 接口进行搜索。它是一个基于 Lucene 的分布式搜索引擎。它可以扩展到数 Pb 的数据。它支持多租户和高并发。它近乎实时地提供搜索结果。Elasticsearch 也是一套被称为 ELK Stack 的开源工具的一部分。</p><h2 id="b0a4" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">弹性搜索的使用案例</h2><ul class=""><li id="7fe9" class="lb lc in jm b jn ld jr le jv lf jz lg kd lh kh li lj lk ll bi translated">操作日志记录和日志分析(ELK)</li><li id="a1b7" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated">网站内容和媒体搜索</li><li id="89bd" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated">全文搜索</li><li id="2366" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated">事件数据和指标</li><li id="b83c" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated">用 Kibana 可视化数据</li></ul><h2 id="ac0d" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">串</h2><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi lr"><img src="../Images/5778ca320a7f1b1d1e9a0ce3c19d4eb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AaxjInoSw4tC5x_SmmhTMg.png"/></div></div></figure><p id="f515" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Elasticsearch 集群是一个分布式的节点集合，每个节点执行一个或多个集群操作。每个节点运行一个 ES 应用程序实例。集群是可水平扩展的。通过向群集中添加额外的节点，我们可以线性扩展群集容量，同时保持类似的性能。通过创建和使用注册令牌来添加节点。</p><p id="626b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">群集中的节点可以根据它们执行的特定操作类型来区分。在高可用性集群中，我们为不同的集群功能指定不同的节点集。要定义节点角色，我们可以这样设置配置— <code class="fe md me mf mg b">node.roles: [ master | data | ingest ]</code></p><h2 id="2cdf" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">主网点</h2><p id="0c69" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">每个集群在任一时间点都有一个主节点，其职责包括维护集群的健康和状态。主节点充当协调者，用于创建、删除、管理索引，以及将索引和底层碎片分配给集群中的适当节点。</p><h2 id="010a" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">主合格节点</h2><p id="9996" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">符合主节点条件的节点是成为主节点的候选节点。</p><h2 id="6864" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">数据节点</h2><p id="3c2b" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">数据节点保存实际的索引数据，并处理数据的搜索和聚合。</p><h2 id="cc17" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">仅协调器节点</h2><p id="ad93" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">这些节点向所有相关的碎片广播查询请求，并将它们的响应聚集成一个全局排序的集合，该集合被返回给客户端。这些节点充当负载平衡器。</p><h2 id="707d" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">摄取节点</h2><p id="9735" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">接收节点可以配置为在数据被接收之前对其进行预处理。由于某些处理器(如 grok 处理器)可能是资源密集型的，因此将单独的节点专用于接收管道是有益的，因为接收处理不会影响搜索操作。否则，数据节点将执行此任务。</p><p id="315d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在大型云集群中，我们将拥有专用的主节点、2 个或更多接收节点、2 个或更多协调节点和多个数据节点。</p><p id="ed01" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因为数据节点存储数据，所以它们应该连接磁盘。固态硬盘用于热数据，硬盘用于冷数据。我们还需要大内存(RAM)来存储数据节点，因为它们可以缓冲数据。</p><blockquote class="mk ml mm"><p id="45be" class="jk jl mn jm b jn jo jp jq jr js jt ju mo jw jx jy mp ka kb kc mq ke kf kg kh ig bi translated">Elasticsearch 用 Java 编写，在 JVM 中运行进程。它为不同的进程使用线程池。</p></blockquote><p id="bc91" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe md me mf mg b">GET /_cat/thread_pool/search?v&amp;h=host,name,active,rejected,completed</code></p><h2 id="7b09" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">索引</h2><p id="e83e" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">索引是相似类型文档的集合。这是一个逻辑统一体。物理上它被映射到碎片上。索引与设置、映射、别名和模板相关联。</p><h2 id="aa85" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">索引别名</h2><p id="4e76" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">别名是可以指向一个或多个索引的虚拟索引名。如果数据分布在多个索引中，这样就不需要跟踪查询哪个特定的索引。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi mr"><img src="../Images/0cb572e2bef8408796d30de338f218eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8DY99voRzqLkbgRGTjMdpQ.png"/></div></div></figure><pre class="ls lt lu lv gt ms mg mt bn mu mv bi"><span id="b58b" class="mw kj in mg b be mx my l mz na">GET _cat/aliases?v<br/>POST _aliases<br/>{<br/>  "actions": [<br/>    {<br/>      "add": {<br/>        "index": "index-1",<br/>        "alias": "alias1"<br/>      }<br/>    }<br/>  ]<br/>}</span></pre><p id="67fb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">索引别名还有助于在不停机的情况下进行索引迁移。</p><h2 id="6b3a" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">陶瓷或玻璃碎片</h2><p id="664c" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">指数被水平分割成称为<em class="mn">碎片</em>的小块。碎片是独立的 Lucene 索引。它们是索引的组成部分。</p><p id="b57f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Elasticsearch <a class="ae nb" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/size-your-shards.html#shard-size-recommendation" rel="noopener ugc nofollow" target="_blank">建议</a>每个碎片小于 65GB (AWS <a class="ae nb" href="https://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/sizing-domains.html" rel="noopener ugc nofollow" target="_blank">建议</a>小于 50GB)，因此我们可以创建基于时间的索引，其中每个索引包含 16-20GB 的数据，为数据增长提供一些缓冲。</p><blockquote class="mk ml mm"><p id="2e3f" class="jk jl mn jm b jn jo jp jq jr js jt ju mo jw jx jy mp ka kb kc mq ke kf kg kh ig bi translated">主碎片和复制碎片</p></blockquote><p id="ef3d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">获取索引碎片<code class="fe md me mf mg b">GET _cat/shards/index</code></p><p id="11df" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">碎片的生命周期:初始化→开始→重新定位→未分配</p><pre class="ls lt lu lv gt ms mg mt bn mu mv bi"><span id="0d4c" class="mw kj in mg b be mx my l mz na">{<br/>    "settings" : {<br/>        "index" : {<br/>            "number_of_shards" : 8,<br/>            "number_of_replicas" : 2<br/>        }<br/>    }<br/>}</span></pre><h2 id="b7ff" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">传输日志/存储缓冲器</h2><p id="f531" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">Lucene 提交的开销太大，无法对每个单独的更改都执行，因此每个分片副本还会将操作写入其事务日志，称为 translog。每个碎片都有一个事务日志。translog 中的数据只能通过 Lucene 提交保存到磁盘上。在失败的情况下，这将被重放以提交未保存的更改。在提交期间，内存中的所有段都被合并成一个段并保存到磁盘。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi nc"><img src="../Images/1682380b914f88ff66d61558d024a5e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mB9Uqv2ECmj-_Rxuw_Mgww.png"/></div></div></figure><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi nd"><img src="../Images/bc52e19e229ec8e5ef6c857d84cffb32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1lOqsxQsZHDC7lZVlrKCXQ.jpeg"/></div></div></figure><blockquote class="mk ml mm"><p id="0fb3" class="jk jl mn jm b jn jo jp jq jr js jt ju mo jw jx jy mp ka kb kc mq ke kf kg kh ig bi translated">刷新—将内存缓冲区内容复制到内存中新创建的段，并清除 translog。每秒钟都会发生。</p><p id="a751" class="jk jl mn jm b jn jo jp jq jr js jt ju mo jw jx jy mp ka kb kc mq ke kf kg kh ig bi translated">刷新—内存中的段被写入磁盘。较小的段被合并成较大的段。</p></blockquote><h2 id="9d24" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">片段</h2><p id="263b" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">Lucene 索引被分成称为段的更小的文件。段是倒排索引。段是不可变的。Lucene 按顺序在所有段中搜索。所以有很多段会影响性能。Elasticsearch 通过删除已删除的文档来合并片段以创建新的片段。合并还有助于将较小的片段组合成较大的片段，因为较小的片段具有较差的搜索性能。</p><h2 id="7aa4" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">文档</h2><p id="7fd5" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">文档是传递给 Elasticsearch 进行存储的信息单元。文档是存储在 Elasticsearch 索引中的 JSON 文件，被视为基本存储单元。文档是不可变的。在更新的情况下，旧文件被新文件替换。doc 响应中的 _version 字段是过去的事情，现在已经没有意义了。</p><h2 id="c523" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">菲尔德斯</h2><p id="e396" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated"><em class="mn">数据类型，如二进制、布尔、关键字、数字、日期、文本、地理形状、搜索类型</em></p><h2 id="503f" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">元字段</h2><blockquote class="mk ml mm"><p id="601d" class="jk jl mn jm b jn jo jp jq jr js jt ju mo jw jx jy mp ka kb kc mq ke kf kg kh ig bi translated"><strong class="jm io"> _index — </strong>索引名称<br/> <strong class="jm io"> _type <br/> _id — </strong>文档的唯一 id<br/><strong class="jm io">_ source—</strong>应用任何分析器/转换之前的原始 JSON 文档。<br/> <strong class="jm io"> _all </strong> —包含文档中的所有其他字段</p></blockquote><p id="9753" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">ES 对象与数据库的指示性映射:</p><blockquote class="mk ml mm"><p id="7328" class="jk jl mn jm b jn jo jp jq jr js jt ju mo jw jx jy mp ka kb kc mq ke kf kg kh ig bi translated">MySQL = &gt; Databases = &gt; Tables = &gt; Row = &gt; Column = &gt; Index<br/>elastic search =&gt;indexes =&gt;Types =&gt;Documents =&gt;Properties =&gt;Mapping</p></blockquote><h2 id="9276" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">专家系统使用的内部数据结构</h2><blockquote class="mk ml mm"><p id="0c68" class="jk jl mn jm b jn jo jp jq jr js jt ju mo jw jx jy mp ka kb kc mq ke kf kg kh ig bi translated">倒排索引—针对文本数据<br/> BKD 树—数字、日期、地理空间数据<br/> doc_values —排序&amp;聚合</p></blockquote><h2 id="a909" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">分析器</h2><p id="8776" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">Elasticsearch 提供了<strong class="jm io">分析器</strong>来定义文本应该如何被索引和搜索。分析器在索引过程中用于将短语和表达式解析成它们的组成术语。在索引中定义的分析器由单个记号赋予器和任意数量的记号过滤器组成。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi ne"><img src="../Images/cb8dc3aabac8ca1b9c91ef92d50cfc6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SnqaGShH5OBSsEO5.png"/></div></div></figure><p id="cd68" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">分析仪有三个组件:</p><ul class=""><li id="a9c9" class="lb lc in jm b jn jo jr js jv nf jz ng kd nh kh li lj lk ll bi translated">字符过滤器<code class="fe md me mf mg b">(html_strip)</code></li><li id="27fb" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated">记号赋予器<code class="fe md me mf mg b">(standard)</code></li><li id="2894" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated">令牌过滤器<code class="fe md me mf mg b">(lowercase)</code></li></ul><p id="81e6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Elasticsearch 有很多内置的分析器、令牌化器和令牌过滤器。</p><pre class="ls lt lu lv gt ms mg mt bn mu mv bi"><span id="47d5" class="mw kj in mg b be mx my l mz na">POST /_analyze<br/>{<br/>  "text": "This text will be analyzed   with STANDARD analyzer"<br/>  "analyzer": "standard"<br/>}<br/><br/>POST /_analyze<br/>{<br/>  "text": "This text will be analyzed   with STANDARD analyzer"<br/>  "char_filter": [],<br/>  "tokenizer": "standard",<br/>  "filter": [ "lowercase" ]<br/>}</span></pre><h2 id="1cce" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">索引模板</h2><p id="d65d" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">索引模板是用来创建新索引的框架。</p><h2 id="26a5" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">索引生命周期管理</h2><p id="f212" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">每个索引经历不同的阶段(热→暖→冷→删除)。基于预定义的配置，ILM 将从一个阶段到另一个阶段的模式索引。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi ni"><img src="../Images/3d9b1f50c765e77688c6e06ee841ad97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FgDfGKdxVISVW9NiKlpl-g.png"/></div></div></figure><h2 id="c0d2" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">摄取管道</h2><p id="ec3c" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">摄取管道允许我们在索引文档之前应用转换，如<em class="mn">字段删除</em>、<em class="mn">信息提取、</em>甚至<em class="mn">数据丰富</em>。一个流水线由几个被称为<a class="ae nb" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/processors.html" rel="noopener ugc nofollow" target="_blank">处理器</a>的可配置任务组成。Elasticsearch 将管道存储为集群状态下的内部数据结构。</p><pre class="ls lt lu lv gt ms mg mt bn mu mv bi"><span id="a18b" class="mw kj in mg b be mx my l mz na">GET _nodes/ingest?filter_path=nodes.*.ingest.processors<br/>PUT _ingest/pipeline/blog-demo-pipeline<br/>{<br/>  "version": 1,<br/>  "description": "Demo pipeline for medium blog",<br/>  "processors": [<br/>    {<br/>      "set": {<br/>        "description": "Set default value of Tag",<br/>        "field": "StoryTag",<br/>        "value": "Data Engineering"<br/>      }<br/>    },<br/>    {<br/>      "lowercase": {<br/>        "field": "author"<br/>      }<br/>    },<br/>    {<br/>      "remove": {<br/>        "field": "external_reads"<br/>      }<br/>    }<br/>  ]<br/>}<br/><br/>POST _ingest/pipeline/blog-demo-pipeline/_simulate<br/>{<br/>  "docs": [<br/>    {...}<br/>  ]<br/>}<br/>POST users/_doc?pipeline=blog-demo-pipeline<br/>{...}<br/><br/>POST _reindex<br/>{<br/>  "source": {<br/>    "index": "existing index name"<br/>  },<br/>  "dest": {<br/>    "index": "new index name",<br/>    "op_type": "create",<br/>    "pipeline": "blog-demo-pipeline"<br/>  }<br/>}</span></pre><h2 id="5a43" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">数据复制</h2><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi nj"><img src="../Images/90f5e6f4ae8a2816d8b8115b4eae0d20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w9HDPdg_hG8pRO1H1HEYgw.png"/></div></div></figure><p id="c829" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Elasticsearch 有<strong class="jm io">主分片</strong>和<strong class="jm io">副本分片</strong>的概念。</p><p id="edb3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将数据从主碎片复制到副本碎片的过程称为<strong class="jm io">数据复制</strong>。数据复制的核心考虑因素是副本和主副本的延迟(<strong class="jm io"> Lag </strong>)。如果 Lag 始终为 0，则它是可靠性最高的实时复制。Elasticsearch 借助<strong class="jm io">文档复制</strong>和<strong class="jm io">段复制</strong>实现数据复制。</p><h2 id="90b0" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">文件索引</h2><p id="133f" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">Elasticsearch 的输入数据在存储之前会进行分析和标记。Lucene 库通常只存储经过分析的令牌。Elasticsearch 还将收到的原始文档存储在一个名为 _source 的特殊字段中。虽然会占用额外的存储空间，但 _source 字段在提供文档更新功能方面至关重要，也是重新索引操作所必需的。</p><h2 id="21c0" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">文档路由</h2><p id="994e" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">Elasticsearch 使用路由算法在索引时将我们的文档分发到底层碎片。每个文档将在一个且只有一个主碎片中被索引。文档均匀分布，因此不会有任何碎片过载。</p><p id="716d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">路由算法是一个简单的公式，其中 Elasticsearch 在索引或搜索期间推导出文档的碎片:</p><pre class="ls lt lu lv gt ms mg mt bn mu mv bi"><span id="234c" class="mw kj in mg b be mx my l mz na">shard = hash(id) % number_of_shards</span></pre><p id="69af" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">哈希函数需要一个惟一的 id，通常是一个文档 ID，甚至是一个由用户提供的自定义 ID。</p><p id="41e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mn">注意:文档不是从主碎片中检索的，但是 ES 利用自适应副本选择(ARS)从复制组中挑选一个碎片。</em></p><h2 id="5a9b" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">专家系统中的索引请求流程</h2><ol class=""><li id="9b26" class="lb lc in jm b jn ld jr le jv lf jz lg kd lh kh nk lj lk ll bi translated">该请求由协调节点接收。</li><li id="c25b" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh nk lj lk ll bi translated">该节点将文档路由到它们的索引和碎片。</li><li id="f05b" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh nk lj lk ll bi translated">主碎片和副本碎片将文档写入(并行)translog。</li><li id="484f" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh nk lj lk ll bi translated">文档被规范化(映射和分析)并存储在内存缓冲区中。</li><li id="049b" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh nk lj lk ll bi translated">索引被刷新，以便可以搜索。</li><li id="57b6" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh nk lj lk ll bi translated">Lucene 在磁盘上提交新的段。</li></ol><h2 id="531f" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">文档搜索</h2><blockquote class="mk ml mm"><p id="3066" class="jk jl mn jm b jn jo jp jq jr js jt ju mo jw jx jy mp ka kb kc mq ke kf kg kh ig bi translated"><strong class="jm io">查询阶段</strong> —协调节点将请求路由到索引中的所有碎片。这些碎片独立地执行搜索，并创建按相关性分数排序的结果的优先级队列。所有碎片都将匹配文档的文档 id 和相关分数返回给协调节点。协调节点创建一个新的优先级队列，并对结果进行全局排序。协调节点创建一个优先级队列，对所有碎片的结果进行排序，并返回前 10 个命中结果。<br/> <strong class="jm io">获取阶段</strong> —协调节点然后从碎片中请求原始文档。碎片丰富了文档，并将它们返回到协调节点。<br/> <strong class="jm io">文档评分</strong> —词频(TF)、逆词频(IDF)、常模。<code class="fe md me mf mg b">relevance_score = TF * IDF</code>。我们可以在查询对象的同一层附加一个<code class="fe md me mf mg b">indices_boost </code>对象。这将提高提升指数的优先级。现在 ES 用 Okapi BM25 算法计算相关度。</p></blockquote><p id="fe46" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有多种类型的搜索查询谓词:</p><blockquote class="mk ml mm"><p id="e656" class="jk jl mn jm b jn jo jp jq jr js jt ju mo jw jx jy mp ka kb kc mq ke kf kg kh ig bi translated">Term，Terms <br/> ids <br/>存在<br/>范围<br/>通配符<br/>前缀<br/> regexp <br/> match_phrasse，multi_match，match_all <br/>模糊<br/>同义词</p></blockquote><h2 id="84cf" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">过滤器与查询上下文</h2><p id="d545" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated"><strong class="jm io">过滤上下文</strong>针对所提供的查询提供是/否的答案。默认情况下，过滤器被缓存，它们不会影响文档的相关性分数。<strong class="jm io">查询上下文，</strong>显示每个文档与查询的匹配程度。它利用分析器来做出决定。结果包括相关性分数。</p><p id="ba8b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">除非是全文搜索或相关性分数类型的搜索过滤器，否则建议使用上下文搜索。过滤器通常比查询更快。</p><h2 id="b30f" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">分页方法</h2><ul class=""><li id="1151" class="lb lc in jm b jn ld jr le jv lf jz lg kd lh kh li lj lk ll bi translated"><strong class="jm io">from/size</strong>—<code class="fe md me mf mg b">from</code>参数定义了我们想要从开始跳过的项目数。<code class="fe md me mf mg b">size</code>参数是返回的最大命中数。</li><li id="7414" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated"><strong class="jm io"> _scroll API </strong> —用于检索大量结果。它类似于 SQL 数据库中的游标。不建议用户请求使用。它应该在批处理模式下使用。</li><li id="0bc4" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated"><strong class="jm io">搜索 _ 之后</strong></li><li id="56ec" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated"><strong class="jm io">时间点(PIT) </strong></li></ul><h2 id="0ae2" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">聚合</h2><blockquote class="mk ml mm"><p id="b0ea" class="jk jl mn jm b jn jo jp jq jr js jt ju mo jw jx jy mp ka kb kc mq ke kf kg kh ig bi translated">指标聚合—总和、最小值、最大值、平均值<br/>数字/非数字指标聚合<br/>存储桶聚合—对组中的查询结果进行排序<br/>管道聚合—从一个阶段到另一个阶段的管道聚合</p></blockquote><h2 id="2581" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">数据流</h2><p id="f3e0" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">数据流简化了时序数据的处理。它处理翻转索引别名和索引，并为后备索引定义公共映射和设置。它利用索引语句管理(ISM)策略。</p><h2 id="d5df" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">配置</h2><blockquote class="mk ml mm"><p id="47cc" class="jk jl mn jm b jn jo jp jq jr js jt ju mo jw jx jy mp ka kb kc mq ke kf kg kh ig bi translated">flush _ threshold _ size<br/>index _ buffer _ size<br/>refresh _ interval<br/>threadpool . bulk . queue _ size</p></blockquote><h2 id="ecdb" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">K8s 上的安装</h2><pre class="ls lt lu lv gt ms mg mt bn mu mv bi"><span id="198a" class="mw kj in mg b be mx my l mz na">helm repo add bitnami https://charts.bitnami.com/bitnami<br/># helm repo add elastic https://helm.elastic.co<br/>helm install elasticsearch --set master.replicas=3,coordinating.service.type=LoadBalancer bitnami/elasticsearch<br/>kubectl port-forward svc/elasticsearch-master 9200<br/>curl localhost:9200</span></pre><p id="d701" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mn">注:ES 使用 9200 进行 API &amp;搜索，9300 进行节间通信。</em></p><h2 id="bc5b" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">K8s 运算符</h2><pre class="ls lt lu lv gt ms mg mt bn mu mv bi"><span id="bb7c" class="mw kj in mg b be mx my l mz na"># Elastic<br/>kubectl create -f https://download.elastic.co/downloads/eck/2.5.0/crds.yaml<br/>kubectl apply -f https://download.elastic.co/downloads/eck/2.5.0/operator.yaml<br/><br/># opensearch<br/>helm repo add opensearch-operator https://opster.github.io/opensearch-k8s-operator/<br/>helm install opensearch-operator opensearch-operator/opensearch-operator</span></pre><h2 id="be72" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">使用 python</h2><pre class="ls lt lu lv gt ms mg mt bn mu mv bi"><span id="b2b3" class="mw kj in mg b be mx my l mz na"># pip install elasticsearch<br/># pip install opensearch-py <br/><br/>from elasticsearch import Elasticsearch <br/>from elasticsearch import helpers<br/>import pandas as pd<br/><br/>df = (<br/>    pd.read_csv("wiki_movie_plots_deduped.csv")<br/>    .dropna()<br/>    .sample(5000, random_state=42)<br/>    .reset_index()<br/>)<br/> <br/>url = 'http://root:root@localhost:9200'  <br/>es = Elasticsearch(url)  <br/># es = Elasticsearch([{'host': 'localhost', 'port': 9200}])<br/><br/>mappings = {<br/>        "properties": {<br/>            "title": {"type": "text", "analyzer": "english"},<br/>            "ethnicity": {"type": "text", "analyzer": "standard"},<br/>            "director": {"type": "text", "analyzer": "standard"},<br/>            "cast": {"type": "text", "analyzer": "standard"},<br/>            "genre": {"type": "text", "analyzer": "standard"},<br/>            "plot": {"type": "text", "analyzer": "english"},<br/>            "year": {"type": "integer"},<br/>            "wiki_page": {"type": "keyword"}<br/>    }<br/>}<br/><br/>index_name = "movies"<br/><br/><br/>index_exists = es.indices.exists(index = index_name)<br/><br/>if not index_exists:  <br/>  es.indices.create(index = index_name, mappings = mapping, ignore=400)<br/><br/># curl -XGET [http://localhost:9200/retail_store]<br/>docs = []<br/>for i, row in df.iterrows():<br/>    doc = {<br/>        "title": row["Title"],<br/>        "ethnicity": row["Origin/Ethnicity"],<br/>        "director": row["Director"],<br/>        "cast": row["Cast"],<br/>        "genre": row["Genre"],<br/>        "plot": row["Plot"],<br/>        "year": row["Release Year"],<br/>        "wiki_page": row["Wiki Page"]<br/>    }<br/>    docs.append(doc)<br/>            <br/>helpers.bulk(es, docs, index=index_name, doc_type='_doc')<br/><br/>query = {  <br/>  "query" : {  <br/>    "bool" : {  <br/>      "must" : {  <br/>         "match_phrase" : {  <br/>            "cast" : "jack nicholson",<br/>         }  <br/>      },<br/>      "filter": {"bool": {"must_not": {"match_phrase": {"director": "roman polanski"}}}},  <br/>    }  <br/>  }  <br/>}<br/><br/>results = es.search(index=index_name, body=query, size = 20)<br/><br/># get all hits<br/># helpers.scan(client=es, query=query, index=index_name) <br/><br/>es.delete(index = index_name, id = doc_id)<br/># es.delete_by_query(index = index_name, query = query)<br/><br/>es.indices.put_settings(index=index_name, body={"key": "value"})<br/><br/>es.indices.delete(index='movies')<br/></span></pre><p id="afea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">设置</strong>包括特定于索引的属性，如碎片数量、分析器等。<strong class="jm io">映射</strong>用于定义文档及其字段应该如何存储和索引。我们为每个字段定义数据类型，或者对未知字段使用动态映射。</p><p id="0c48" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mn">注意:对于批量 API，在使用 cURL 时使用</em> <code class="fe md me mf mg b"><em class="mn">Content-Type: application/x-ndjson</em></code></p><h2 id="9672" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">分层索引</h2><p id="9a4f" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">Elasticsearch 允许我们为数据节点设置不同的层和不同的硬件配置文件。我们通过在<code class="fe md me mf mg b">elasticsearch.yml</code>配置文件中设置<code class="fe md me mf mg b">node.role</code>属性来做到这一点。</p><blockquote class="mk ml mm"><p id="9ca5" class="jk jl mn jm b jn jo jp jq jr js jt ju mo jw jx jy mp ka kb kc mq ke kf kg kh ig bi translated">hot—data _ hot<br/>Warm—data _ Warm<br/>Cold—data _ Cold<br/>Frozen—data _ Frozen</p></blockquote><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi nd"><img src="../Images/d86ae12dd83015f31f545be5e938b4df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c3BS-jxq52x5_Rttpkb5eQ.png"/></div></div></figure><h2 id="4a6c" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">基本 API</h2><pre class="ls lt lu lv gt ms mg mt bn mu mv bi"><span id="eb44" class="mw kj in mg b be mx my l mz na">POST &lt;index-name&gt;/_search?explain=true<br/>GET &lt;index1&gt;,&lt;index2&gt;,&lt;index3&gt;/_search <br/>GET /_cluster/health<br/>GET /_cat/indices?h=index<br/>GET index/_settings<br/>GET index/_mapping<br/>DELETE /document-index/_doc/id<br/>POST document-index/_delete_by_query?conflicts=proceed<br/>{<br/> "query": {<br/> "match_all": {}<br/> }<br/>}<br/>GET /_analyze<br/>{<br/>  "analyzer" : "standard",<br/>  "text" : "Hello, from Elastic Search."<br/>}</span></pre><h2 id="a255" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">与火花互动</h2><pre class="ls lt lu lv gt ms mg mt bn mu mv bi"><span id="8a10" class="mw kj in mg b be mx my l mz na"># via package<br/>--packages org.elasticsearch:elasticsearch-hadoop:7.10.1<br/># or via pip<br/>!pip install elasticsearch-hadoop<br/><br/>df = spark.read<br/>    .format("org.elasticsearch.spark.sql")<br/>    .option("es.nodes","http://host:9200")<br/>    .option("es.read.metadata", "true")<br/>    .option("es.read.field.include", "text,user")<br/>    .load("index/type")<br/><br/>df.write<br/>    .format("org.elasticsearch.spark.sql")<br/>    .option("es.nodes","http://localhost:9200")<br/>    .option("es.write.operation", "upsert")<br/>    .save("index/type")</span></pre><h2 id="c3b2" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">弹性搜索管理工具</h2><p id="7594" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated"><a class="ae nb" href="https://github.com/lmenezes/cerebro" rel="noopener ugc nofollow" target="_blank">脑波强化器</a></p><h2 id="5fd8" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">使用插件定制弹性搜索</h2><p id="c0d5" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">Elasticsearch 有一个基于界面的插件架构，允许扩展和定制 ES 功能。插件通常是保存在特定位置的打包工件(jar、zip、rpm)文件。我们可以使用<code class="fe md me mf mg b">elasticsearch-plugin</code>命令行工具来安装、列出和删除插件。一些常见的插件类别有:</p><blockquote class="mk ml mm"><p id="70b2" class="jk jl mn jm b jn jo jp jq jr js jt ju mo jw jx jy mp ka kb kc mq ke kf kg kh ig bi translated">API 扩展插件<br/>快照插件<br/>发现插件<br/>映射器插件<br/>集成插件</p></blockquote><pre class="ls lt lu lv gt ms mg mt bn mu mv bi"><span id="9668" class="mw kj in mg b be mx my l mz na">GET _cat/plugins</span></pre><h2 id="36e1" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">使用 Elasticsearch 的公司</h2><blockquote class="mk ml mm"><p id="e0aa" class="jk jl mn jm b jn jo jp jq jr js jt ju mo jw jx jy mp ka kb kc mq ke kf kg kh ig bi translated">Swiggy，Quora，AutoDesk，Adobe，沃尔玛，Grab，Tinder，优步，Visa，Compass，Pearson，Pinterest，Wikimedia，网飞</p></blockquote><h2 id="e268" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">瓶颈</h2><ul class=""><li id="3b59" class="lb lc in jm b jn ld jr le jv lf jz lg kd lh kh li lj lk ll bi translated"><strong class="jm io">集群管理器</strong> —当节点数量超过 300 时，系统变慢，集群重启变慢</li><li id="7292" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated"><strong class="jm io">分片分配器</strong></li><li id="7372" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated">没有针对不良查询的<strong class="jm io">准入控制器</strong> —没有对不良查询的主动预防</li><li id="2d3c" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated"><strong class="jm io">数据保留时间越长，存储成本</strong>越高</li><li id="5b47" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated">插件和核心之间直接<strong class="jm io">耦合</strong>，无资源分割</li><li id="b0fc" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated">Elasticsearch 不允许多数据中心安装。</li></ul><h2 id="f739" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">AWS 中的云产品</h2><p id="8971" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">AWS 提供 OpenSearch 服务，这是 Elasticsearch 的一个分支。该服务提供两种产品:托管和无服务器。AWS 产品具有以下优势:</p><blockquote class="mk ml mm"><p id="b9db" class="jk jl mn jm b jn jo jp jq jr js jt ju mo jw jx jy mp ka kb kc mq ke kf kg kh ig bi translated">增强的安全性<br/>警报<br/>性能分析器<br/> SQL 查询支持<br/>索引管理<br/> k 近邻搜索</p></blockquote><h2 id="99a7" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">OpenSearch 的未来工作正在进行中</h2><ul class=""><li id="1876" class="lb lc in jm b jn ld jr le jv lf jz lg kd lh kh li lj lk ll bi translated">远程存储</li><li id="1813" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated">智能缓存</li><li id="5fb9" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated">跨集群和完整集群复制</li></ul><h2 id="f7e9" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">摘要</h2><p id="c405" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">简而言之，专家系统索引可以总结为以下步骤</p><ul class=""><li id="0237" class="lb lc in jm b jn jo jr js jv nf jz ng kd nh kh li lj lk ll bi translated">向 API 发送数据</li><li id="b031" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated">数据被路由到索引、节点和碎片</li><li id="695a" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated">映射、标准化和分析</li><li id="87e4" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated">磁盘持久性</li><li id="1e02" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated">可供搜索的数据</li></ul><p id="9e58" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢阅读！！</p></div></div>    
</body>
</html>