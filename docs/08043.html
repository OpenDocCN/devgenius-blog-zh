<html>
<head>
<title>Inside the JavaScript Runtime Environment</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 JavaScript 运行时环境中</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/inside-the-javascript-runtime-environment-457c02100827?source=collection_archive---------1-----------------------#2022-05-13">https://blog.devgenius.io/inside-the-javascript-runtime-environment-457c02100827?source=collection_archive---------1-----------------------#2022-05-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="cef7" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">JavaScript 运行时环境的简要说明</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/c471334c7ca9069481ee75e1ebb2f43c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Shk_5yhp2D-cWi40_4X4ow.jpeg"/></div></div></figure><p id="dc4f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">几天前，我们开始了一个系列，旨在更深入地挖掘 JavaScript 及其实际工作方式:我们认为，通过了解 JavaScript 的构建块以及它们如何协同工作，您将能够编写更好的代码和应用程序。</p><p id="ff01" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae lk" rel="noopener ugc nofollow" target="_blank" href="/how-javascript-works-behind-the-scenes-88c546173f32">本系列的第一篇文章</a>重点介绍了引擎、运行时和调用栈。本系列的第二篇文章关注 JavaScript 引擎内部的简要解释。</p><p id="74bf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在本文中，我们将讨论 JavaScript 运行时环境是如何工作的。</p><h1 id="04cb" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">JavaScript 运行时</h1><p id="dbc2" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">JavaScript 运行时就像一个盒子或容器，包含了我们使用 JavaScript 需要的所有东西。任何 JavaScript 运行时的核心都是 JavaScript 引擎。这正是我们在上一篇文章中谈到的。没有引擎就没有运行时，也就没有 JavaScript。</p><p id="31de" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在浏览器环境中，这由以下元素组成:</p><ol class=""><li id="7bf7" class="mi mj in kq b kr ks ku kv kx mk lb ml lf mm lj mn mo mp mq bi translated">JavaScript 引擎</li><li id="9526" class="mi mj in kq b kr mr ku ms kx mt lb mu lf mv lj mn mo mp mq bi translated">Web APIs</li><li id="3c15" class="mi mj in kq b kr mr ku ms kx mt lb mu lf mv lj mn mo mp mq bi translated">回调队列</li><li id="12d3" class="mi mj in kq b kr mr ku ms kx mt lb mu lf mv lj mn mo mp mq bi translated">事件循环</li></ol><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/e0ff59ea535b388c661cea29eaf438e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-QcXDhD9TnN7CcnYAV8Lxw.png"/></div></figure><h1 id="a662" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">JavaScript 引擎</h1><p id="efca" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">在上一篇文章<a class="ae lk" rel="noopener ugc nofollow" target="_blank" href="/inside-the-javascript-engine-bb7b9f26e84b"><strong class="kq io">JavaScript 引擎</strong> </a>里面我们已经深入的谈过 JavaScript 引擎了。但是总的来说，JavaScript 引擎只是一个执行 JavaScript 代码的计算机程序。今天，JavaScript 引擎内置在所有现代浏览器中。当 JavaScript 文件加载到浏览器中时，JavaScript 引擎将从上到下执行文件的每一行(为了简化解释我们在 JS 中避免提升)。JavaScript 引擎会逐行解析代码，转换成机器码然后执行。</p><p id="ffe6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">每个浏览器都有自己的 JavaScript 引擎，但最著名的引擎是谷歌的 V8。V8 引擎支持 Google Chrome，也支持 Node.js，后者是 JavaScript 运行时。</p><p id="3750" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">引擎由两个主要组件组成:<br/> <em class="mx"> *内存堆—这是内存分配发生的地方<br/> *调用堆栈—这是代码执行时堆栈帧所在的地方</em></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi my"><img src="../Images/1c0d5703059e85f9a1cf56342d77723e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AMSdZcDQ5GkKfM4fUF_4gA.png"/></div></div></figure><h2 id="7546" class="mz lm in bd ln na nb dn lr nc nd dp lv kx ne nf lx lb ng nh lz lf ni nj mb nk bi translated">垃圾堆</h2><p id="13ec" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">环境中的第一个容器，也是 V8 JS 引擎的一部分，被称为“内存堆”当 V8 JS 引擎在代码中遇到变量和函数声明时，它将它们存储在<strong class="kq io">堆</strong>中。</p><h2 id="3769" class="mz lm in bd ln na nb dn lr nc nd dp lv kx ne nf lx lb ng nh lz lf ni nj mb nk bi translated">堆栈</h2><p id="716e" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">环境中的第二个容器称为“调用堆栈”它也是 V8 JS 引擎的一部分。当 JS 引擎遇到一个可操作的项目时，比如一个函数调用，它会将它添加到<strong class="kq io">堆栈</strong>中。</p><p id="ce96" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">一旦一个函数被添加到堆栈中，JS 引擎就立即开始解析它的代码，向堆中添加变量，向堆栈顶部添加新的函数调用，或者将自己发送到 Web API 调用所在的第三个容器。</p><p id="671a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当一个函数返回值，或者被发送到<strong class="kq io"> Web API 容器</strong>时，它被弹出堆栈，并移动到堆栈中的下一个函数。如果 JS 引擎到达函数的末尾，并且没有显式写入返回值，JS 引擎将返回 undefined，并从堆栈中弹出函数。当他们说 JavaScript 同步运行<strong class="kq io"/>时，这个解析函数并将其弹出堆栈的过程就是他们的意思。它在单线程上一次只做一件事。</p><p id="a512" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">注意—堆栈是一种运行后进先出的数据结构。除了栈顶的那个函数，其他函数都不会被聚焦，引擎也不会移动到下一个函数，除非它上面的那个函数被弹出。</p><h1 id="587f" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">Web API 容器</h1><p id="823c" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">Web APIs 不是 JavaScript 引擎的一部分，但它们是浏览器提供的运行时环境的一部分。现代浏览器中有大量可用的 API，允许我们做各种各样的事情。一些最常见的浏览器 API 类别让我们:</p><ul class=""><li id="fb19" class="mi mj in kq b kr ks ku kv kx mk lb ml lf mm lj nl mo mp mq bi translated"><strong class="kq io">操作文档</strong>:最常用的 Web APIs 之一是<a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model" rel="noopener ugc nofollow" target="_blank">DOM API</a>，它允许开发人员操作 HTML 和 CSS，让我们创建、更改甚至删除 HTML，并动态地将样式应用到我们的 Web 页面。</li><li id="9bc4" class="mi mj in kq b kr mr ku ms kx mt lb mu lf mv lj nl mo mp mq bi translated"><strong class="kq io">绘制和操作图形:</strong>在浏览器中得到广泛支持，<a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API" rel="noopener ugc nofollow" target="_blank">Canvas API</a>和<a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API" rel="noopener ugc nofollow" target="_blank">Web 图形库 API </a>让我们以编程方式更新包含在<code class="fe nm nn no np b">&lt;canvas&gt;</code>元素中的像素数据。</li><li id="70f9" class="mi mj in kq b kr mr ku ms kx mt lb mu lf mv lj nl mo mp mq bi translated"><strong class="kq io">从服务器获取数据:</strong> <a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="noopener ugc nofollow" target="_blank">获取 API </a>通过使用<code class="fe nm nn no np b">Request</code>和<code class="fe nm nn no np b">Response</code>对象的通用定义，提供了通过网络获取资源的接口。</li></ul><p id="f56b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">事件侦听器、计时函数和 AJAX 请求等特性都位于 Web APIs 容器中，直到某个动作被触发。一个请求完成接收它的数据，一个定时器到达它的设定时间或者一个点击发生，这触发一个回调函数被发送到回调队列。</p><h1 id="09e0" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">回调队列</h1><p id="6791" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">回调队列按照添加顺序存储从 Web APIs 发送的回调函数。这个队列是一个运行<a class="ae lk" href="https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)" rel="noopener ugc nofollow" target="_blank">先进先出</a>的数据结构。队列使用<a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push" rel="noopener ugc nofollow" target="_blank">数组推送方法</a>向队列末尾添加一个新的回调函数，使用<a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/shift" rel="noopener ugc nofollow" target="_blank">数组移位方法</a>移除队列中的第一项。</p><p id="08d0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">回调函数将在队列中等待，直到调用堆栈为空，然后由事件循环将它们移入堆栈。然后，当堆栈为空时，回调函数被传递到堆栈，以便可以执行。这是通过一个叫做<strong class="kq io">事件循环</strong>的东西来实现的(我们将在另一篇文章中讨论<em class="mx">)。</em></p><h1 id="cb97" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">事件循环</h1><p id="eb9d" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">所以基本上，事件循环从回调队列中获取回调函数，并将它们放入调用堆栈中。这样它们就可以被执行。此外，事件循环对于非阻塞并发模型也是必不可少的。现在我们将在另一篇关于事件循环的文章中讨论为什么这会使 JavaScript 成为非阻塞的。因为这确实是 JavaScript 开发的一个基本部分，每个开发人员都需要深入理解。</p><p id="bbff" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">好了，我们看了 JavaScript 运行时，以及它是如何在幕后相当详细地工作的。我希望上面的文章能帮助你理解 JavaScript 运行时环境。现在，让我们在这里结束它。会有一篇关于事件循环的新文章。要获得我的新故事的更新，请关注我的<strong class="kq io">M</strong><a class="ae lk" href="https://adityayaduvanshi.medium.com/" rel="noopener"><strong class="kq io">edium</strong></a>和<strong class="kq io">T</strong><a class="ae lk" href="https://twitter.com/fixslyr" rel="noopener ugc nofollow" target="_blank"><strong class="kq io">witter</strong></a><strong class="kq io">。</strong></p><p id="05a6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如有疑问，可直接联系我<a class="ae lk" href="https://www.linkedin.com/in/theaditya-yaduvanshi-/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io">Linkedin</strong></a><strong class="kq io">。</strong></p></div><div class="ab cl nq nr hr ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ig ih ii ij ik"><p id="4943" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">还有，你可以看看这些文章，让你的 JavaScript 更强大。</p><div class="nx ny gp gr nz oa"><a rel="noopener  ugc nofollow" target="_blank" href="/how-javascript-works-behind-the-scenes-88c546173f32"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd io gy z fp of fr fs og fu fw im bi translated">JavaScript 如何在幕后工作？</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">JavaScript 代码执行中涉及的所有核心组件的概述。</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">blog.devgenius.io</p></div></div><div class="oj l"><div class="ok l ol om on oj oo km oa"/></div></div></a></div><div class="nx ny gp gr nz oa"><a rel="noopener  ugc nofollow" target="_blank" href="/inside-the-javascript-engine-bb7b9f26e84b"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd io gy z fp of fr fs og fu fw im bi translated">在 JavaScript 引擎内部</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">JavaScript 引擎的简要说明</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">blog.devgenius.io</p></div></div><div class="oj l"><div class="op l ol om on oj oo km oa"/></div></div></a></div></div><div class="ab cl nq nr hr ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ig ih ii ij ik"><p id="6918" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果你喜欢这篇文章，请广而告之。要获得我的新故事的更新，请在 M  <a class="ae lk" href="https://adityayaduvanshi.medium.com/" rel="noopener"> <strong class="kq io"> edium </strong> </a> <strong class="kq io">和</strong><a class="ae lk" href="https://twitter.com/fixslyr" rel="noopener ugc nofollow" target="_blank"><strong class="kq io">Twitter</strong></a><strong class="kq io">上关注我。</strong></p></div></div>    
</body>
</html>