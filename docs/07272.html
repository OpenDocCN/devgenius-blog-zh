<html>
<head>
<title>Promises in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript 中的承诺</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/promises-in-javascript-606ce34e2cf1?source=collection_archive---------15-----------------------#2022-03-10">https://blog.devgenius.io/promises-in-javascript-606ce34e2cf1?source=collection_archive---------15-----------------------#2022-03-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/7bc70516ab9dcd94bdadb86de2dc821d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ocwLyPOzYdG3nkOR5dZSIQ.jpeg"/></div></div></figure><p id="b5f4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">承诺是 javascript 的一个重要方面。任何时候你进行异步调用，不管是来自你的客户端应用程序还是服务器，我保证“promise”会让事情对你来说容易得多，但是承诺很难理解，至少对我来说是这样。一旦我们爬上理解承诺之山，景色将是壮丽的。那我们就开始吧，好吗？</p><h1 id="cc14" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">承诺</h1><p id="4df0" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">承诺就像它们的名字一样。javascript 中的 Promise 是一个向您承诺异步操作结果的对象。假设您想从 api 获取所有订单的数据，这显然不会是一个即时的过程，需要一些时间来获取数据，持续时间可能取决于数量，但会有延迟，因此您返回的不是错误或部分数据，而是一个承诺，您可以使用它来获取结果或相应的错误。让我们用一个例子来理解上面的案例。<br/>当我们发出获取数据的请求时，我使用流行的<a class="ae lw" href="https://jsonplaceholder.typicode.com/" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/</a>来获取一些数据并分析我们得到的响应。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lx"><img src="../Images/1c4b8525bc9db40445432531722107ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4T1j5nqYVrNAkM-ruCvp0g.png"/></div></div></figure><p id="f9aa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">嗯，我们这里有什么！一个对象和一个承诺，这个术语看起来有点熟悉。我们看到另一件有趣的事，“已满”表示应许的状态。我们可以有三种承诺状态。<br/> 1。待定<br/> 2。履行了<br/> 3。Reject <br/>正如你可能从名字中推断的那样，Pending 状态发生了，当承诺仍然在幕后工作时，我们请求的任何动作都还没有完成来提供给我们结果。在上面的例子中，我们只向 API 查询一个商品，所以在我们打印出“something”对象之前，承诺就已经实现了。我们将在本文后面模拟这种情况。敬请期待！<br/>进入“已完成”状态，这意味着我们的异步操作成功了，但是结果在哪里呢？在等式“then()”中引入另一个元素，当 promise 返回结果或错误时，就会调用这个函数。then()函数被提供了承诺的结果和错误，然后它调用内部定义的具有该值的函数。很复杂对吧！让我们来看一个例子，以便更好地了解情况。带着我们已经实现的承诺向前努力，让我们试着看看它的结果。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mc"><img src="../Images/fc3fd5101fd60b014b00d2194a345c94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9mbZdOz2mJeqKNkEdGWarw.png"/></div></div></figure><p id="4688" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">好的，我们在我们的承诺上附加了一个 then()函数，它收到了一个成功的结果，我们正在打印这个结果。如果这是一个错误，那么带有错误参数的()函数就会被执行。等待，但我们看到的是，结果是另一个“承诺”。我们现在要干嘛？。别担心，promises 给了我们链接多个异步调用的功能。因此，promise 的结果是另一个异步调用，我们可以在函数中执行异步元素，相应的结果将在下一个 then 调用中收到。再次，变得有点乱！让我们再次回到我们的例子。</p><pre class="ly lz ma mb gt md me mf mg aw mh bi"><span id="535d" class="mi ku in me b gy mj mk l ml mm">something.then(result=&gt;result.json()).then(result=&gt;console.log(result));<br/>{userId: 1, id: 1, title: ‘delectus aut autem’, completed: false}</span></pre><p id="3f60" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将另一个 then 函数链接到我们之前的函数，我们将从第一个 promise 获得的正文流转换为 json，这是一个异步调用，当该调用完成时，我们的下一个 then 函数被调用，结果是，瞧，我们最终得到了结果。这基本上总结了我们对状态以及如何处理它们的讨论。我们将进一步探究拒绝状态。</p></div><div class="ab cl mn mo hr mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ig ih ii ij ik"><p id="d7cf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">到目前为止，我们已经处理了如何处理承诺，它的各个阶段。但是我们如何自己创造一个承诺，因为有时我们需要创造一个承诺。让我们在下一节探讨这个问题。</p><h1 id="cf89" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">创造承诺</h1><pre class="ly lz ma mb gt md me mf mg aw mh bi"><span id="f947" class="mi ku in me b gy mj mk l ml mm">let promise = new Promise(function(resolve, reject){<br/>///asynchronous operation</span><span id="6a61" class="mi ku in me b gy mu mk l ml mm">})</span></pre><p id="833d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面的语法是一个承诺的原型。我们来分解一下。每当我们创建一个承诺，我们传递一个函数给它，一旦承诺被创建，这个函数就被调用。这个函数，为了方便起见，我们称它为“可执行函数”，接收两个回调，resolve 和 reject，我们一会儿再回到这些函数。让我们回滚到我们的可执行函数，因此它包含了我们需要执行的任何操作，一旦完成，如果操作成功，它就调用 resolve，如果操作失败，就调用 reject。让我们试着模拟一个例子。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mv"><img src="../Images/e0b5b974b48c0eaa514241433e459eb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gWwWPRcdNxOw1L6mTAsN5g.png"/></div></div></figure><p id="247a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在可执行函数中，我设置了一个 1 分钟的超时，当超时结束时，我们调用 resolve 函数，结果是一个字符串。<br/>我们在这个例子中遇到了两件事，我们还没有看到承诺的待定状态，所以这个例子展示了这一点。一旦我们创建了一个承诺，我们就会看到它处于挂起状态，因为可执行函数内部的代码仍未完成，并被称为 resolve 函数。当 resolved 被调用时，我们得到返回值。<br/>让我们看看可执行函数内部的操作何时失败。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mw"><img src="../Images/8470f8faf2187b4690c6b7911708b449.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IUcm6T5hf8i6-ipzOzGspA.png"/></div></div></figure><p id="513c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如您在上面看到的，在我们的超时函数中，完成后我们用错误值调用 reject，这意味着承诺将收到一个错误。</p><p id="865b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">希望这对你有帮助。如有任何疑问，请随时联系我们，不要忘记鼓掌。:D</p></div></div>    
</body>
</html>