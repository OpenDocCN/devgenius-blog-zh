<html>
<head>
<title>The main idea of implementing a binary tree with Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Golang 实现二叉树的主要思想</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/the-main-idea-of-implementing-a-binary-tree-with-golang-556fac53ced4?source=collection_archive---------4-----------------------#2022-03-03">https://blog.devgenius.io/the-main-idea-of-implementing-a-binary-tree-with-golang-556fac53ced4?source=collection_archive---------4-----------------------#2022-03-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="4887" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">手动实现二叉树</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f79319d8534fef49fc65db1ef7bc2298.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*v1Lgwb-nBFnLpI0O"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@ka_idris?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Kam Idris </a>拍摄的照片</figcaption></figure><p id="6e61" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一般的算法操作，无非就是写、查、删三个主要操作。此外，可能还有一些操作，例如获取关于相应数据结构的信息。比如二叉树可能需要获得树的度，栈和队列需要获得长度。</p><p id="4d37" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">根据这个想法，我们需要理解这些对于二叉树的操作:</p><ol class=""><li id="7791" class="kz la in jm b jn jo jr js jv lb jz lc kd ld kh le lf lg lh bi translated">二叉树结构的定义</li><li id="66b2" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">二叉树的创建</li><li id="bd4b" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">向二叉树中添加数据</li><li id="951f" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">计算二叉树中节点的数量</li><li id="f5f8" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">计算二叉树的深度</li><li id="eedb" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">二叉树遍历:四种遍历方法</li></ol><ul class=""><li id="3017" class="kz la in jm b jn jo jr js jv lb jz lc kd ld kh ln lf lg lh bi translated">前序遍历:先访问根节点，再访问左子树，最后访问右子树；这种情况反复出现直到结束。</li><li id="861c" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh ln lf lg lh bi translated">后序遍历:先访问左侧子树，再访问右侧子树，最后访问根节点；这种情况反复出现直到结束。</li><li id="8df3" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh ln lf lg lh bi translated">有序遍历:先访问左边的子树，再访问根节点，最后访问右边的子树；这种情况反复出现直到结束。</li><li id="943a" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh ln lf lg lh bi translated">分层遍历:每一层从左到右访问每个节点。</li></ul><p id="c30b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">二叉树的结构。</strong></p><p id="afef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">设计二叉树的结构。利用单向链表的特点和二叉树的相似性来设计。</p><ul class=""><li id="4836" class="kz la in jm b jn jo jr js jv lb jz lc kd ld kh ln lf lg lh bi translated">该树是一种递归形式，在每个节点之间进行链接和存储</li><li id="1be8" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh ln lf lg lh bi translated">二叉树只有左右两个子树</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="7f36" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">二叉树的创建。</strong></p><p id="054e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">主要思想是利用单向链表的特点创建一棵二叉树(其实这里不能叫单向链表，因为应该是单向链表；一个根节点指向两个子节点)，所以二叉树的节点就是链表的节点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="2d6c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">向二叉树添加数据。</strong></p><p id="2411" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">主要思想是只从一个根节点开始，然后根据需要，或者在左子树方向，或者在右子树方向，然后直接链接到新节点，等等。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="941f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">结果的示意图如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lq"><img src="../Images/c3447409d5eda4f282b5f731a361dc10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z-NRPDI1qrk8Dl8xjMmtPQ.png"/></div></div></figure><p id="d147" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">统计一棵二叉树的节点数。</strong></p><p id="f949" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们用上面的例子来测试。由于二叉树是递归结构，我们可以使用递归来遍历计算。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="7410" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">计算二叉树的深度。</strong></p><p id="9435" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">树的深度也是树的最大级别。</p><p id="bdfd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">根节点是第一级，只要有一个左子树或者有一个右子树，这个级别就需要加一，一直计算到最后。</p><p id="90ad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以这可以通过递归来实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="63ee" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">遍历四种二叉树。</strong></p><p id="51f0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">前三种简单，用递归的方法，第四种方法比较麻烦。</p><ol class=""><li id="0265" class="kz la in jm b jn jo jr js jv lb jz lc kd ld kh le lf lg lh bi translated">前序遍历</li></ol><p id="e909" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了在前序中遍历二叉树，执行以下操作:</p><ul class=""><li id="bef8" class="kz la in jm b jn jo jr js jv lb jz lc kd ld kh ln lf lg lh bi translated">访根。</li><li id="993a" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh ln lf lg lh bi translated">遍历根的左子树。</li><li id="b8e7" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh ln lf lg lh bi translated">遍历根的右边子树。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="d529" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于上面的例子，结果应该输出<code class="fe lr ls lt lu b">1 2 6 4 3 5 7</code>。</p><p id="c646" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.后序遍历</p><p id="a00d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了在后序遍历中遍历二叉树，执行以下操作:</p><ul class=""><li id="0c3a" class="kz la in jm b jn jo jr js jv lb jz lc kd ld kh ln lf lg lh bi translated">遍历根的左子树。</li><li id="72db" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh ln lf lg lh bi translated">遍历根的右边子树。</li><li id="fa54" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh ln lf lg lh bi translated">访根。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="15bd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于上面的例子，结果应该输出<code class="fe lr ls lt lu b">6 4 2 5 7 3 1</code>。</p><p id="0f19" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.有序遍历</p><p id="ad69" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了在有序遍历中遍历二叉树，执行以下操作:</p><ul class=""><li id="da84" class="kz la in jm b jn jo jr js jv lb jz lc kd ld kh ln lf lg lh bi translated">遍历最左边的子树。</li><li id="de98" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh ln lf lg lh bi translated">访根。</li><li id="f9e0" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh ln lf lg lh bi translated">遍历最右边的子树。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="790c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于上面的例子，结果应该输出<code class="fe lr ls lt lu b">6 2 4 1 5 3 7</code>。</p><p id="9336" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">4.等级顺序遍历。</p><p id="2875" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">主旨。</p><p id="ab66" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因为是树形结构并且想逐层输出结果，输出左节点值后，下一个需要输出本层的右节点值。</p><p id="d20d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">前面的三种方法都是按照模型“一棵小三节点树”的方式输出的，所以这三种方法都无法立即找到正确的下一个节点。</p><p id="1e86" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以可以考虑创建一个队列缓存(先进先出特性)，遍历数据，按照输出的顺序放入队列。</p><p id="4e44" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以解决方案是实现每个层从左到右访问每个节点。</p><p id="2c8e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，把树的根节点放入队列，你需要定义一个链表队列。</p><p id="88b1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从队列中移除节点，首先打印节点值，如果节点有左子树节点，左子树上栈，如果节点有右子树节点，右子树上栈。</p><p id="c786" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">重复此操作，直到队列中没有元素。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="4238" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">二叉树的层次顺序遍历的完整代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="fcd0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢您阅读本文，如果您认为文章写得很好，请关注我。</p><p id="7cdb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果发现本文有错误，欢迎留言讨论。</p><p id="1be6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">祝你愉快。</p></div></div>    
</body>
</html>