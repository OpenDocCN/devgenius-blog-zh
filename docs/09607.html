<html>
<head>
<title>Rust for Dummies, Idiots, Beginners and Everyone Else! — Part 2: Variables, Data &amp; Compound Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">生锈的傻瓜，白痴，初学者和其他人！—第 2 部分:变量、数据和复合类型</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/rust-for-dummies-idiots-beginners-and-everyone-else-part-2-variables-data-compound-types-446c48f90053?source=collection_archive---------10-----------------------#2022-08-31">https://blog.devgenius.io/rust-for-dummies-idiots-beginners-and-everyone-else-part-2-variables-data-compound-types-446c48f90053?source=collection_archive---------10-----------------------#2022-08-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="ddfe" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">介绍</h1><p id="869d" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">嘿，伙计们！今天，我们将探讨一些以某种形式延伸到其他编程语言的常见概念。这些是你肯定会发现自己会回来的基本原则。让我们从变量和数据类型开始吧！</p><h1 id="9eaf" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">作为通用编程概念系列的一部分</h1><h1 id="4d0c" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">变量</h1><h2 id="5669" class="lg jl in bd jm lh li dn jq lj lk dp ju kt ll lm jy kx ln lo kc lb lp lq kg lr bi translated">变量—简介</h2><p id="ab2e" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">最简单的概念是，变量是一种通过使用指定的名称以易于引用的方式存储数据的方法。</p><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="lx ly l"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">字符串类型的名为 Guess 的可变变量声明。</figcaption></figure><p id="55c9" class="pw-post-body-paragraph ki kj in kk b kl md kn ko kp me kr ks kt mf kv kw kx mg kz la lb mh ld le lf ig bi translated">让我们来分析一下这里发生了什么。对于那些上过数学或计算机课的人来说，当你的老师说"考虑下面的问题，让…"时，你会想到 let 关键字。这是一个告诉 Rust 我们要声明一个变量的关键字。</p><p id="79ec" class="pw-post-body-paragraph ki kj in kk b kl md kn ko kp me kr ks kt mf kv kw kx mg kz la lb mh ld le lf ig bi translated">在 let 之后，我们声明变量是可变的。如果我们没有使用这个关键字，默认情况下，声明的变量将是不可变的，因此我们将不能在程序运行时改变它。通过使用关键字<em class="mi"> mut </em>,我们可以在以后改变这个值。换句话说，一旦我们给一个变量名赋值，我们就不能再给同一个变量名赋值了。自然地，可变变量很快将对我们至关重要，值得注意的是，使某些变量可变是必须的，</p><p id="ae0f" class="pw-post-body-paragraph ki kj in kk b kl md kn ko kp me kr ks kt mf kv kw kx mg kz la lb mh ld le lf ig bi translated">我们然后指定名字<em class="mi">猜测</em>。这是我们稍后在程序中用来引用赋值的单词。最后，我们声明这个名为 guess 的新可变变量等于一个新字符串。字符串是各种编程语言中常见的数据类型，通常用于表示单词和句子。</p></div><div class="ab cl mj mk hr ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ig ih ii ij ik"><h2 id="b3ab" class="lg jl in bd jm lh li dn jq lj lk dp ju kt ll lm jy kx ln lo kc lb lp lq kg lr bi translated">常数</h2><p id="a2b4" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">作为旁注，还有一个常数。一个常量无论如何都不能改变，通常在程序的最开始就在全局范围内声明(后面会详细介绍)。常量和不可变变量的根本区别是什么？</p><p id="cb8f" class="pw-post-body-paragraph ki kj in kk b kl md kn ko kp me kr ks kt mf kv kw kx mg kz la lb mh ld le lf ig bi translated">不可变变量和常量都不能在运行时改变。然而，如果不可变变量没有先前的值，则它可以在运行之前或期间被赋予初始值。常数就不是这样了——常数必须在运行前定义，不能更改，也不能在运行时创建。</p><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="lx ly l"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">声明一个常数</figcaption></figure><p id="a596" class="pw-post-body-paragraph ki kj in kk b kl md kn ko kp me kr ks kt mf kv kw kx mg kz la lb mh ld le lf ig bi translated">上面我们看到了如何在 Rust 中声明一个常数。</p><ol class=""><li id="7130" class="mq mr in kk b kl md kp me kt ms kx mt lb mu lf mv mw mx my bi translated">我们使用适当的关键字。</li><li id="b8ff" class="mq mr in kk b kl mz kp na kt nb kx nc lb nd lf mv mw mx my bi translated">后跟一个全大写的变量。</li><li id="2445" class="mq mr in kk b kl mz kp na kt nb kx nc lb nd lf mv mw mx my bi translated">然后我们必须声明它的数据类型，在这个例子中是一个 32 位的无符号整数。</li><li id="3ff3" class="mq mr in kk b kl mz kp na kt nb kx nc lb nd lf mv mw mx my bi translated">最后，我们把这等同于我们选择的价值。</li></ol></div><div class="ab cl mj mk hr ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ig ih ii ij ik"><h2 id="328c" class="lg jl in bd jm lh li dn jq lj lk dp ju kt ll lm jy kx ln lo kc lb lp lq kg lr bi translated">遮蔽</h2><p id="41c1" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">作为初始部分的最后一项，我们将讨论阴影及其与可变性的相似性。隐藏是用与已存在的变量相同的来声明变量。</p><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="lx ly l"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">隐藏:声明两个同名的变量</figcaption></figure><p id="3fb9" class="pw-post-body-paragraph ki kj in kk b kl md kn ko kp me kr ks kt mf kv kw kx mg kz la lb mh ld le lf ig bi translated">乍一看，这段代码似乎试图打破不变性的规则——但事实并非如此！赋值为 5 的变量的初始声明对我们来说并不新鲜。然而，第二行是事情变得有趣的地方——因为我们再次使用了<em class="mi"> let </em>关键字以及相同的变量名，我们并没有试图改变 x 的值，而是声明了一个恰好具有相同名称的新变量。</p></div><div class="ab cl mj mk hr ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ig ih ii ij ik"><h1 id="8b58" class="jk jl in bd jm jn ne jp jq jr nf jt ju jv ng jx jy jz nh kb kc kd ni kf kg kh bi translated">数据类型</h1><p id="dee1" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">让我们从常量声明中再次讨论这个例子。</p><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="lx ly l"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">用 u32 数据类型声明常数。</figcaption></figure><p id="3d84" class="pw-post-body-paragraph ki kj in kk b kl md kn ko kp me kr ks kt mf kv kw kx mg kz la lb mh ld le lf ig bi translated">那个<em class="mi"> u32 </em>就是所谓的数据类型。当我们声明数据类型时，我们告诉 Rust 我们打算存储的数据的性质和大小。这在所有静态类型的语言中都是必要的。这与 Python 等动态类型化的语言形成了对比——也就是说，我们不必声明数据类型，Python 会为我们解决这个问题。</p><p id="47d7" class="pw-post-body-paragraph ki kj in kk b kl md kn ko kp me kr ks kt mf kv kw kx mg kz la lb mh ld le lf ig bi translated">让我们讨论 Rust 中的一些不同的数据类型:</p><p id="279e" class="pw-post-body-paragraph ki kj in kk b kl md kn ko kp me kr ks kt mf kv kw kx mg kz la lb mh ld le lf ig bi translated">标量:包含单个值的数据类型。整数、浮点数、布尔值和字符。</p><h2 id="6f08" class="lg jl in bd jm lh li dn jq lj lk dp ju kt ll lm jy kx ln lo kc lb lp lq kg lr bi translated">整数</h2><p id="779d" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><a class="ae nj" href="https://medium.com/@marcinbaraniecki/on-integer-types-in-rust-b3dc1b0a23d3" rel="noopener">整数</a>是非小数——整数，根据你的内存需求，你可以声明一个整数为 8、16、32、64 或 128 位——有符号或无符号。有符号或无符号仅仅意味着值是正的，还是也可能是负的。</p><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="lx ly l"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">在 Rust 中声明不同大小的整数</figcaption></figure><p id="835d" class="pw-post-body-paragraph ki kj in kk b kl md kn ko kp me kr ks kt mf kv kw kx mg kz la lb mh ld le lf ig bi translated">整数也可以用各种格式表示，<a class="ae nj" href="https://www.rapidtables.com/convert/number/hex-dec-bin-converter.html" rel="noopener ugc nofollow" target="_blank">十进制、十六进制、八进制、二进制或字节</a>。</p><h2 id="b901" class="lg jl in bd jm lh li dn jq lj lk dp ju kt ll lm jy kx ln lo kc lb lp lq kg lr bi translated">浮点字符</h2><p id="5494" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">浮点字符通过允许小数值而与整数形成对比——这些数字基本上包括小数点和其后的任何数字。</p><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="lx ly l"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">在 Rust 中声明浮点数</figcaption></figure><p id="c41c" class="pw-post-body-paragraph ki kj in kk b kl md kn ko kp me kr ks kt mf kv kw kx mg kz la lb mh ld le lf ig bi translated">值得注意的是，我们可以声明 64 位或 32 位的浮点数。通常，默认值为 64 位，这是 f64 运算比现代 CPU 上的 f32 运算更快的原因，但是 f64 允许更高的精度。</p><h2 id="8e36" class="lg jl in bd jm lh li dn jq lj lk dp ju kt ll lm jy kx ln lo kc lb lp lq kg lr bi translated">布尔运算</h2><p id="7993" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">Rust 中的布尔类型与其他编程语言没有什么不同。值得注意的是，布尔值的大小是一个字节，最好通过示例来解释:</p><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="lx ly l"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">Rust 中的布尔声明</figcaption></figure><h2 id="12c8" class="lg jl in bd jm lh li dn jq lj lk dp ju kt ll lm jy kx ln lo kc lb lp lq kg lr bi translated">字符类型</h2><p id="4ff8" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">字符类型是最原始的字母类型。值得注意的是，字符文字应该用单引号指定。</p><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="lx ly l"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">在 Rust 中声明字符数据类型</figcaption></figure><p id="7754" class="pw-post-body-paragraph ki kj in kk b kl md kn ko kp me kr ks kt mf kv kw kx mg kz la lb mh ld le lf ig bi translated">字符大小为 4 个字节，代表 unicode 标量值，这意味着它可以代表 ASCII 字符、重音字母、中文、日文字母、表情符号等</p><h1 id="0478" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">复合类型</h1><p id="01c7" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">复合类型包括元组和数组。(还有更多但是一步一个脚印)。</p><p id="fa45" class="pw-post-body-paragraph ki kj in kk b kl md kn ko kp me kr ks kt mf kv kw kx mg kz la lb mh ld le lf ig bi translated">Tuple 是将许多不同类型的值组合成一个复合类型的通用方法。元组具有预定的固定长度，即，一旦被声明，元组的大小就不能增长或收缩。</p><p id="cc63" class="pw-post-body-paragraph ki kj in kk b kl md kn ko kp me kr ks kt mf kv kw kx mg kz la lb mh ld le lf ig bi translated">相反，数组是一种将相同数据类型的值集合存储在一起的方法。Rust 中的数组与 C 类似，大小是固定的。</p><p id="38e3" class="pw-post-body-paragraph ki kj in kk b kl md kn ko kp me kr ks kt mf kv kw kx mg kz la lb mh ld le lf ig bi translated">元组通过在一组括号内写一个逗号分隔的列表来声明。元组中的每个位置都被分配了一种数据类型。</p><p id="4730" class="pw-post-body-paragraph ki kj in kk b kl md kn ko kp me kr ks kt mf kv kw kx mg kz la lb mh ld le lf ig bi translated">数组由方括号内的逗号分隔列表声明。值得注意的是，元组和数组之间的一个区别是元组数据存储在堆中，而数组数据存储在堆栈中。</p><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="lx ly l"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">Rust 中的元组运算</figcaption></figure><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="lx ly l"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">Rust 中的数组操作</figcaption></figure></div><div class="ab cl mj mk hr ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ig ih ii ij ik"><h1 id="22e0" class="jk jl in bd jm jn ne jp jq jr nf jt ju jv ng jx jy jz nh kb kc kd ni kf kg kh bi translated">结论</h1><p id="5879" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">这就是这篇文章的全部内容！我们讨论了变量、数据类型和复合数据类型。我希望这篇文章是信息丰富的，如果你有任何问题，请随时在评论中提出！</p><p id="5be0" class="pw-post-body-paragraph ki kj in kk b kl md kn ko kp me kr ks kt mf kv kw kx mg kz la lb mh ld le lf ig bi translated">下一次我们将看看声明函数和控制流。</p><h1 id="5fc0" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">关于作者</h1><p id="34ed" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">我是<a class="ae nj" href="https://www.linkedin.com/in/lukeabela5698/" rel="noopener ugc nofollow" target="_blank"> Luke </a>，我在马耳他大学攻读电子电气工程学士学位，在那里我学习嵌入式系统。接下来，我在伦敦大学玛丽皇后学院攻读了人工智能科学硕士学位。从那以后，我一直从事人工智能和物联网工程师的工作。</p></div></div>    
</body>
</html>