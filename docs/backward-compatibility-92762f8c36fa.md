# 向后兼容性

> 原文：<https://blog.devgenius.io/backward-compatibility-92762f8c36fa?source=collection_archive---------6----------------------->

如今，在这个行业中，我们用来开发解决方案的库、框架和外部 API 的数量如此之多，以至于我们基本上依赖于我们无法控制的东西。如果我们是任何公共事物的创造者，我们应该尊重我们的客户，向后兼容应该永远是一个要求。

![](img/abdcf3dff6025175654a9821dad5991d.png)

[Pixabay](https://pixabay.com/photos/people-man-jumping-flying-sky-2589340/)

开源是软件公司的基石之一。如果没有开源运动和共享代码的想法，编写代码将会非常昂贵，以至于今天的大多数公司都不会这么做。

但是在软件中，我们不理解我们创造的任何东西都是在两个部分——客户和生产者——之间创造一个契约。即使软件是免费的，连续违反合同也是完全不负责任的。

一个库或者一个框架的 API 代表了这个库的客户将会拥有的体验，所以我们应该尽可能的保留这个 API。突破性的改变不仅对客户有巨大的影响，而且对图书馆的使用也有巨大的影响。所以突破性的改变应该是我们最后的选择，我们应该尽可能的避免它们。如果我们决定冒这个险，我们需要把影响降到最低。维护中间代码以适应从旧版本到新版本，以及创建日落过程以给客户时间进行迁移都是例子。

使用这么多库和框架的团队的反应应该是保护他们的业务免受这些外部行为所要求的变更。这是使用[清洁建筑](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)的主要原因之一。
如果你的代码(你的业务)中最相关的部分没有被大量的库感染，那么任何突破性的改变对你的工作都只会产生有限的影响。
像在船上一样，我们可以通过第三方库将问题的影响降至最低:

> 在船上，舱壁是密封时将船分成单独的水密舱室的隔板。随着舱口的关闭，隔板阻止水从一个部分流到另一个部分。这样，一次穿透船体不会不可挽回地使船沉没。隔板执行了一个控制损害的原则。
> [释放它！迈克尔·t·尼加德的第二版](https://learning.oreilly.com/library/view/release-it-2nd/9781680504552/)

## 内部服务变更

在这个疯狂的微服务世界(我称之为[分布式单片](/distributed-monolith-1d2d9f86a68f?sk=7b489fa66af30f9946142485df6784d6)世界)中，向其他服务公开 API 的服务经常破坏它们的 API。

这种系统非常脆弱，如果一个服务破坏了 API，所有上游服务都会失败。在 monoliths 中，这个问题并没有那么糟糕，因为你的测试或者你的语言会警告你这个问题。这个问题在 monolith 应用程序中更容易解决，因为你有更密切的客户和生产者，你的测试或你的语言会警告你生产者中引入的变化。

但在分布式应用中，这个问题并不容易解决，为了避免这个问题，公司引入了大型 E2E 测试、合同测试或手动检查来验证更改是否安全。有时我们使用分支来隔离那些变更，并创建环境来手动检查它们，创建[大批量的变更](/batching-1e23cc939710?sk=e4244dcaaa7cdd2ea676f07c6f0314d3)。

脆弱的架构难以被自动测试所带来的复杂性暴露在为解决那些工程问题而创建的过程和[环境](/long-lived-environments-93f097786aa6?sk=84eba6ba390918a6a9a89fff6454e3b4)中。

这些解决方案与这种在创建产品(功能)时试图增加质量的糟糕想法有关，通常是浪费时间，没有什么好处。

> C 减轻对检验的依赖以实现质量。通过将质量放在产品的第一位，消除大量检测的需要。
> [Demmings](https://michelbaudin.com/2012/09/12/demings-point-3-of-14-cease-dependence-on-inspection-to-achieve-quality/)

但是软件充满了权衡，有时你更喜欢定义内部 API 来减少代码的重复，减少团队的认知负荷。但是做出有意识的决定不同于低估引入内部 API 的成本，以服务或内部库的形式。我们将关注服务 API，如果你想了解更多关于库和它们的问题，看看这篇[博文](/the-hidden-cost-of-libraries-8a0772770654?sk=162d71e2fef124db052852d0a81130aa)。

如果你更喜欢引入内部 API，一个好的决定是改变质量，减少引入公共内部 API 带来的问题，也就是考虑向后兼容性。

在多个服务中进行重大更改并一次性部署所有这些服务，只会带来巨大的风险。如果你必须回滚，你需要回滚所有的服务，按什么顺序？。所有这些变化的副作用是什么？。我们需要回滚保存的数据吗？。

一个风险小得多的选择是使用[“扩展和收缩技术”](https://www.martinfowler.com/bliki/ParallelChange.html)。您没有进行破坏性的更改，而是引入了保持向后兼容性的新更改，并允许您在不更改客户端的情况下部署“服务器”服务。
例如，如果你需要改变你的一个资源的主体，你可以用新的主体创建一个新的控制器，但是保持旧的主体。您可以逐个迁移调用新端点的每个客户端，但未迁移的客户端仍将使用旧端点。
迁移完所有客户端后，旧的端点就可以移除了。

练习[黑暗发射](https://martinfowler.com/bliki/DarkLaunching.html)将有助于我们通过多次部署降低部署复杂性。更重要的是，我们可以在不影响用户的情况下检查新解决方案的性能，我们可以调用新的和旧的端点，并监控新的和旧的端点的行为。我们还可以丢弃新端点的答案，因此这有助于我们简化如何使用来自生产的信息来优化我们的系统，但对客户端的影响更小。这种方法有助于我们持续地部署小的变更，减少引入错误的风险和这些错误的后果。

## 架构决策

但是如果我们知道很难自动测试服务之间的连接点，为什么不减少这些连接点作为遵循的规则呢？为什么不把这个想法作为我们架构的杂务呢？。这是一种权衡，有时表里不一(在代码中，在数据库中)比过多的合作、过多的耦合要好。

创建团队负责的业务的垂直自治部分，并尽可能减少这些服务(那些团队)之间的通信，将有助于我们创建更简单的架构。更易于监控、更易于扩展等。

对于任何事情，向后兼容都是我们需要记住的原则，它将帮助我们在生活中减少压力。