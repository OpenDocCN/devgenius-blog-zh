<html>
<head>
<title>Golang: Using Regex Pattern Matching with net/http</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang:通过 net/http 使用正则表达式模式匹配</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/golang-using-regex-pattern-matching-with-net-http-d80c3261680a?source=collection_archive---------2-----------------------#2022-01-31">https://blog.devgenius.io/golang-using-regex-pattern-matching-with-net-http-d80c3261680a?source=collection_archive---------2-----------------------#2022-01-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="4ab4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">众所周知，net/http 包功能强大且易于使用。很容易启动来服务 http urls。然而，URL 模式识别是基本的，因此程序员通常会求助于第三方包，例如<a class="ae ki" href="https://github.com/gorilla/mux" rel="noopener ugc nofollow" target="_blank"> Gorilla Mux </a>来满足他们的路由需求。</p><p id="ec3a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是，如果你在一个受约束的环境中，使用第三方依赖会受到限制，或者你只是想让你的代码简单。你能做的就是把它和正则表达式包(即 regex)和 net/http 包混在一起。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/fb5ecbbd954179d301893e5fb1ba188f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8oGJ0aWZisc6SLgg"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">照片由<a class="ae ki" href="https://unsplash.com/@remotarjobs?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Remotar 乔布斯</a>在<a class="ae ki" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><h2 id="58a6" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">技术</h2><p id="3c98" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">想法是创建自己的定期 expresssion 网址匹配器。您将确保匹配器(这是一个结构)实现了<a class="ae ki" href="https://pkg.go.dev/net/http#Handler" rel="noopener ugc nofollow" target="_blank">处理程序接口</a>。然后，这个结构将被用来提供与我们所熟悉的 net/http 设施相匹配的 URL。请继续阅读，了解更多信息。</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="fc18" class="kz la in ly b gy mc md l me mf">package regexURL</span><span id="8ef4" class="kz la in ly b gy mg md l me mf">import (<br/>        "fmt"<br/>        "net/http"<br/>        "regexp"<br/>)</span><span id="a5af" class="kz la in ly b gy mg md l me mf">type RegexURLMatcher struct {<br/>        Patterns map[string]*regexp.Regexp //1<br/>        Handlers map[string]http.HandlerFunc //2<br/>}</span><span id="ee08" class="kz la in ly b gy mg md l me mf">func NewRegexURLMatcher() *RegexURLMatcher { //3<br/>        return &amp;RegexURLMatcher{<br/>                Patterns: make(map[string]*regexp.Regexp),<br/>                Handlers: make(map[string]http.HandlerFunc),<br/>        }<br/>}</span><span id="c0e7" class="kz la in ly b gy mg md l me mf">func (r *RegexURLMatcher) Add(regex string, handler   <br/>        http.HandlerFunc) error { //4</span><span id="6984" class="kz la in ly b gy mg md l me mf">        compiled, err := regexp.Compile(regex) <br/>        if err != nil {<br/>                return fmt.Errorf("Regex string cannot compile with err: %w", compiled)<br/>        }</span><span id="1706" class="kz la in ly b gy mg md l me mf">        r.Handlers[regex] = handler<br/>        r.Patterns[regex] = compiled</span><span id="012f" class="kz la in ly b gy mg md l me mf">        return nil<br/>}</span><span id="8093" class="kz la in ly b gy mg md l me mf">func (r *RegexURLMatcher) ServeHTTP(res http.ResponseWriter, req *http.Request) { //5<br/>        toMatchPattern := req.Method + " " + req.URL.Path<br/>        for regexString, handlerFunc := range r.Handlers { //6<br/>                if  <br/>                r.Patterns[regexString].MatchString(toMatchPattern) <br/>                == true {<br/>                        handlerFunc(res, req)<br/>                        return<br/>                }<br/>        }</span><span id="00a1" class="kz la in ly b gy mg md l me mf">        http.NotFound(res, req)</span><span id="0890" class="kz la in ly b gy mg md l me mf">}</span></pre><h2 id="ec84" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">代码解释</h2><p id="0727" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">RegexurlMatcher 结构有两个字符串映射——一个保存处理函数(//1 ),另一个(//2)存储编译后的正则表达式 URL 模式。NewRegexURLMatcher 函数(//3)将创建一个新的空 RegexURLMatcher 结构。</p><p id="0b08" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它有一个 Add 函数(//4)，允许您将一个 regex 字符串模式关联到一个特定的<a class="ae ki" href="https://pkg.go.dev/net/http#HandlerFunc" rel="noopener ugc nofollow" target="_blank"> http。HandlerFunc </a>函数(记住 Golang 中的函数是一等公民)。将首先编译 regex 字符串模式，如果 regex 字符串无效，将引发一个错误。否则，如果一切顺利，编译后的模式和处理函数将被添加到 RegexURLMatcher 结构中的两个映射中。</p><p id="b628" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如前所述，RegexURLMatcher struct 实现了 handler 接口，因此它必须具有 ServeHTTP 函数(//5)。在实现中，我们采用请求方法和 URL 路径来形成要测试的字符串。用什么测试？我们将枚举处理程序的映射来获取 regex 字符串(即键)和处理程序函数(//6)。每个正则表达式字符串将用于从模式映射中获取模式。将测试这个编译后的正则表达式模式，以匹配从请求中获得的字符串。如果匹配，将使用处理函数来处理请求。</p><h2 id="7318" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">怎么用？</h2><p id="85c1" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">让我们以 main.go 为例来看看如何使用我们新的 RegexURLMatcher 结构。</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="06e1" class="kz la in ly b gy mc md l me mf">package main</span><span id="1692" class="kz la in ly b gy mg md l me mf">import (<br/>        "fmt"<br/>        "net/http"<br/>        "regexURL"<br/>        "strings"<br/>)</span><span id="972e" class="kz la in ly b gy mg md l me mf">func main() {</span><span id="db94" class="kz la in ly b gy mg md l me mf">r := regexURL.NewRegexURLMatcher()<br/>        r.Add("(GET) /greeting(/?[A-Za-z0-9]*)?", greeter)<br/>        http.ListenAndServe(":8080", r) //7</span><span id="bf75" class="kz la in ly b gy mg md l me mf">}</span><span id="3ef3" class="kz la in ly b gy mg md l me mf">func greeter(res http.ResponseWriter, req *http.Request) {//8</span><span id="ce8e" class="kz la in ly b gy mg md l me mf">        defer req.Body.Close()</span><span id="3e63" class="kz la in ly b gy mg md l me mf">        path := req.URL.Path<br/>        segments := strings.Split(path, "/")</span><span id="3b9a" class="kz la in ly b gy mg md l me mf">        name := ""</span><span id="970d" class="kz la in ly b gy mg md l me mf">        if len(segments) &gt; 2 {<br/>                name = segments[2]<br/>        }</span><span id="9ee2" class="kz la in ly b gy mg md l me mf">        if name == "" {<br/>                name = "user"<br/>        }</span><span id="e68e" class="kz la in ly b gy mg md l me mf">        payload := fmt.Sprintf("Hello %s\n", name)<br/>        res.Write([]byte(payload))</span><span id="a07f" class="kz la in ly b gy mg md l me mf">}</span></pre><p id="8114" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在主程序中，我们创建了新的 spanning new matcher struct (/)并添加了我们想要匹配的 URL 正则表达式以及相关的处理函数，在本例中是我们的自定义欢迎函数(/)8。欢迎函数将尝试提取 URL 的第三段，例如<a class="ae ki" href="http://localhost:8080/greeting/ArnoldGovernor" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/greeting/Arnold governor</a>，并向其问好。</p><p id="62c1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我将把这个技巧留给你。记住 Golang 简洁有力。编码快乐！</p></div></div>    
</body>
</html>