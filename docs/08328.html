<html>
<head>
<title>Python Up Your Code: Identity vs Equality</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python Up 您的代码:身份与平等</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/python-up-your-code-identity-vs-equality-ab2205a6fec8?source=collection_archive---------15-----------------------#2022-06-05">https://blog.devgenius.io/python-up-your-code-identity-vs-equality-ab2205a6fec8?source=collection_archive---------15-----------------------#2022-06-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d29b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Python 中“==”和“is”运算符的区别</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/569e9fd8b44013a7098d9bec2027b602.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8pBvC9V2Sw6DhQqWSqPd-w.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@maximalfocus?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">最大焦点</a>在<a class="ae kv" href="https://unsplash.com/s/photos/digital-abstract?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">不飞溅</a>上拍摄</figcaption></figure><p id="13ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这应该是一篇很短的文章，主题是我认为我们迟早都会遇到的(最好是越早越好)。尽管这个话题可能很简单，但深入探究它会让你大开眼界。所以，让我们开始吧！</p><p id="244a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在 Python 中(和其他一些语言一样，但我们在这里主要关注 Python)，在像<code class="fe ls lt lu lv b">==</code>或<code class="fe ls lt lu lv b">!=</code>这样的<strong class="ky ir">等式</strong>操作符和像<code class="fe ls lt lu lv b">is</code>和<code class="fe ls lt lu lv b">is not</code>这样的<strong class="ky ir">等式</strong>操作符之间有一些不同。区别决定了这两个类别的不同用例。但是不知何故困惑开始了。因为在一个非常特殊但又非常普遍的例子中，这些运算符实际上表现相同。</p><p id="2e41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是让我们举例说明，以便更好地理解正在发生的事情。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="f27d" class="ma mb iq lv b gy mc md l me mf"><em class="mg"># 2 equal integers</em><br/>a = 2<br/>b = 2</span><span id="db3f" class="ma mb iq lv b gy mh md l me mf"><em class="mg"># test for equality</em><strong class="lv ir"><br/>print</strong>(a == b)</span><span id="546a" class="ma mb iq lv b gy mh md l me mf"><em class="mg"># test for identity</em><strong class="lv ir"><br/>print</strong>(a <strong class="lv ir">is</strong> b)</span><span id="e796" class="ma mb iq lv b gy mh md l me mf">Output:<br/>True<br/>True</span></pre><p id="4d48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">至少可以说，很有趣。现在考虑下一个例子:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="0abf" class="ma mb iq lv b gy mc md l me mf"><em class="mg"># 2 equal lists</em><br/>l1 = [1, 2, 3]<br/>l2 = [1, 2, 3]</span><span id="795e" class="ma mb iq lv b gy mh md l me mf"><em class="mg"># test for equality<br/></em><strong class="lv ir">print</strong>(l1 == l2)</span><span id="8c0c" class="ma mb iq lv b gy mh md l me mf"><em class="mg"># test for identity</em><strong class="lv ir"><br/>print</strong>(l1 is l2)</span><span id="8b72" class="ma mb iq lv b gy mh md l me mf">Output:<br/>True<br/>False</span></pre><p id="1b2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这一次，我们可以确定列表是相等的，但是<code class="fe ls lt lu lv b">is</code>操作符返回了<code class="fe ls lt lu lv b">False</code>。</p><p id="fa0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们再看一下第一个例子，但这一次，让我们更彻底一点:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="dd1d" class="ma mb iq lv b gy mc md l me mf"><em class="mg"># 2 equal integers</em><br/>a = 2<br/>b = 2</span><span id="7647" class="ma mb iq lv b gy mh md l me mf"><em class="mg"># test for equality</em><strong class="lv ir"><br/>print</strong>(a == b)</span><span id="363a" class="ma mb iq lv b gy mh md l me mf"><em class="mg"># test for identity</em><strong class="lv ir"><br/>print</strong>(a <strong class="lv ir">is</strong> b)</span><span id="f208" class="ma mb iq lv b gy mh md l me mf"><em class="mg"># print out the object ids<br/></em><strong class="lv ir">print</strong>(<strong class="lv ir">id</strong>(a))<br/><strong class="lv ir">print</strong>(<strong class="lv ir">id</strong>(b))</span><span id="0416" class="ma mb iq lv b gy mh md l me mf">Output:<br/>True<br/>True<br/>140495050653968<br/>140495050653968</span></pre><p id="45f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个例子中的<code class="fe ls lt lu lv b">==</code>和<code class="fe ls lt lu lv b">is</code>操作符都返回<code class="fe ls lt lu lv b">True</code>。返回<code class="fe ls lt lu lv b">True</code>的等式运算符应该不会让任何人感到惊讶，真的。但是有趣的是<code class="fe ls lt lu lv b">is</code>操作符也返回<code class="fe ls lt lu lv b">True</code>。注意<code class="fe ls lt lu lv b">id()</code>函数调用是如何返回相同的对象 id 的？好了，现在我们可以清楚地了解情况了。</p><p id="147c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">原来，<code class="fe ls lt lu lv b">is</code>操作符是在测试这两个变量是否指向 Python 内存中的同一个对象。</p><ul class=""><li id="d0d7" class="mi mj iq ky b kz la lc ld lf mk lj ml ln mm lr mn mo mp mq bi translated">在第一行之后，在<code class="fe ls lt lu lv b">a = 2</code>处，Python 创建了一个整数值为 2 的对象，并将其赋给我们的变量<code class="fe ls lt lu lv b">a</code>；</li><li id="f28e" class="mi mj iq ky b kz mr lc ms lf mt lj mu ln mv lr mn mo mp mq bi translated">在第二行，我们有了<code class="fe ls lt lu lv b">b = 2</code>。所以，这里发生的是，Python 也将变量<code class="fe ls lt lu lv b">b</code>赋给了<code class="fe ls lt lu lv b">a</code>正在引用的同一个对象，因为整数<strong class="ky ir">是不可变的</strong>，所以<strong class="ky ir">有机会</strong>，取决于你的 Python <strong class="ky ir">实现</strong>，将使用同一个整数对象(你可以在这里阅读关于这个微妙主题的更多内容<a class="ae kv" href="https://docs.python.org/3/reference/datamodel.html#objects-values-and-types" rel="noopener ugc nofollow" target="_blank">)；我们现在看到的叫做<strong class="ky ir">共享引用</strong>，你可以在</a><a class="ae kv" href="https://www.geeksforgeeks.org/shared-reference-in-python/" rel="noopener ugc nofollow" target="_blank">这里</a>读到更多；</li></ul><p id="d521" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">底线是，这两个变量，在这个特殊的例子中(我使用的是<code class="fe ls lt lu lv b">CPython</code>实现)，最终引用了同一个 integer 对象。这就是<code class="fe ls lt lu lv b">a is b</code>回归<code class="fe ls lt lu lv b">True</code>的原因。我们也可以把<code class="fe ls lt lu lv b">a is b</code>线看作<code class="fe ls lt lu lv b">id(a) == id(b)</code>的简写。</p><p id="f704" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">而且，虽然我们已经谈到了 Python 实现主题，但您可能对获得 Python 实现有点好奇。方法如下:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="7ad9" class="ma mb iq lv b gy mc md l me mf"><strong class="lv ir">import</strong> platform<br/>platform.<strong class="lv ir">python_implementation</strong>()</span></pre><p id="a84a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，回到手头的任务，让我们对两个列表进行同样的尝试:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="98a2" class="ma mb iq lv b gy mc md l me mf"><em class="mg"># 2 equal lists</em><br/>l1 = [1, 2, 3]<br/>l2 = [1, 2, 3]</span><span id="e955" class="ma mb iq lv b gy mh md l me mf"><em class="mg"># test for equality<br/></em><strong class="lv ir">print</strong>(l1 == l2)</span><span id="a3b6" class="ma mb iq lv b gy mh md l me mf"><em class="mg"># test for identity</em><strong class="lv ir"><br/>print</strong>(l1 is l2)</span><span id="e1f8" class="ma mb iq lv b gy mh md l me mf"><em class="mg"># print out the object ids<br/></em><strong class="lv ir">print</strong>(<strong class="lv ir">id</strong>(l1))<br/><strong class="lv ir">print</strong>(<strong class="lv ir">id</strong>(l2))</span><span id="f5ae" class="ma mb iq lv b gy mh md l me mf">Output:<br/>True<br/>False<br/>139711984251904<br/>139711982769344</span></pre><p id="7310" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">列表是可变的，所以即使我们创建了两个值相等的列表，Python 也创建了两个独立的、不同的对象。<code class="fe ls lt lu lv b">is</code>操作符将检查两个列表的 id 是否相等，并将自然返回<code class="fe ls lt lu lv b">False</code>。</p><p id="a01c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不得不说，这同样适用于<code class="fe ls lt lu lv b">!=</code>对<code class="fe ls lt lu lv b">is not</code>的情况。它将产生非常相似的结果。</p><p id="25d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">官方 Python <a class="ae kv" href="https://peps.python.org/pep-0008/#programming-recommendations" rel="noopener ugc nofollow" target="_blank"> PEP 8 风格指南</a>对这个主题有一些建议。它们提出了非常好的观点，绝对不仅值得一读，而且值得实际应用，因为它们可以防止严重错误的发生:</p><blockquote class="mw mx my"><p id="9673" class="kw kx mg ky b kz la jr lb lc ld ju le mz lg lh li na lk ll lm nb lo lp lq lr ij bi translated">应该总是使用<code class="fe ls lt lu lv b">is</code>或<code class="fe ls lt lu lv b">is not</code>来比较 singletons，比如 None，而不是等式运算符。</p><p id="7261" class="kw kx mg ky b kz la jr lb lc ld ju le mz lg lh li na lk ll lm nb lo lp lq lr ij bi translated">此外，当你真正想要的是<code class="fe ls lt lu lv b">if x is not None</code>时，注意不要写<code class="fe ls lt lu lv b">if x</code>——例如，当测试一个缺省值为 None 的变量或参数是否被设置为其他值时。另一个值的类型(比如容器)在布尔上下文中可能为 false！</p><p id="5642" class="kw kx mg ky b kz la jr lb lc ld ju le mz lg lh li na lk ll lm nb lo lp lq lr ij bi translated">使用<code class="fe ls lt lu lv b">is not</code>操作符而不是<code class="fe ls lt lu lv b">not ... is</code>。虽然这两种表达式在功能上完全相同，但前者更具可读性，也更受青睐:</p><p id="f27b" class="kw kx mg ky b kz la jr lb lc ld ju le mz lg lh li na lk ll lm nb lo lp lq lr ij bi translated">#正确:如果 foo 不是 None: <br/> #错误:如果不是 foo 就是 None:</p></blockquote><p id="1a4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一点强调，我们应该总是用<code class="fe ls lt lu lv b">is</code>来比较一个变量到<code class="fe ls lt lu lv b">None</code>而不是<code class="fe ls lt lu lv b">==</code>。为什么？嗯，我能想到几个原因:</p><ul class=""><li id="e45f" class="mi mj iq ky b kz la lc ld lf mk lj ml ln mm lr mn mo mp mq bi translated"><code class="fe ls lt lu lv b">None</code>是独生子。只能有一个<code class="fe ls lt lu lv b">None</code>实例。将变量的值与<code class="fe ls lt lu lv b">None</code>对象的值进行比较是没有意义的，因为我们真正想做的是测试变量<code class="fe ls lt lu lv b">is</code><code class="fe ls lt lu lv b">None</code>；</li><li id="06e4" class="mi mj iq ky b kz mr lc ms lf mt lj mu ln mv lr mn mo mp mq bi translated">通过简单地覆盖<code class="fe ls lt lu lv b">__eq__()</code>方法，可以在一些定制类中覆盖<code class="fe ls lt lu lv b">==</code>操作符，并且<code class="fe ls lt lu lv b">my_var == None</code>可能不会返回我们期望的结果。另一方面，<code class="fe ls lt lu lv b">is</code>操作符不能(这么容易)被覆盖；</li><li id="7409" class="mi mj iq ky b kz mr lc ms lf mt lj mu ln mv lr mn mo mp mq bi translated"><code class="fe ls lt lu lv b">is</code>通常比<code class="fe ls lt lu lv b">==</code>快。它只是检查有问题的操作数的<code class="fe ls lt lu lv b">id()</code>返回值。</li></ul><p id="6a0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二个建议是我们编写类似于<code class="fe ls lt lu lv b">if variable</code>的东西，并期望它像<code class="fe ls lt lu lv b">if variable is not None</code>一样工作。编写更短的代码行可能会使它看起来更整洁一些，但这肯定是不正确的。这样来看:如果我们的变量是<code class="fe ls lt lu lv b">0</code>会怎么样？看到问题了吗？在布尔上下文中，<code class="fe ls lt lu lv b">None</code>并不是唯一计算结果为<code class="fe ls lt lu lv b">False</code>的东西。还有<code class="fe ls lt lu lv b">False</code>、<code class="fe ls lt lu lv b">0</code>，一个空字符串等等。这些都能算到<code class="fe ls lt lu lv b">False</code>而<code class="fe ls lt lu lv b">if variable</code>会算到<code class="fe ls lt lu lv b">False</code>，尽管都不是<code class="fe ls lt lu lv b">None</code>。</p><p id="ae7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第三个建议非常重视可读性，当然，当你看两行代码时，你会选择哪一行？</p><p id="dfbc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该结束了。我希望我设法解释了为什么了解您的操作员可以将您从无休止的寻找奇怪的错误中解救出来。我们都应该努力变得比昨天的自己更好。我们以后会感谢自己的。为此，我们在下一次的<a class="ae kv" href="https://medium.com/@deck451/python-up-your-code-files-fac7e07cd34f" rel="noopener">再见！在此之前，保持安全和快乐的编码！干杯！</a></p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><p id="51d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mg"> Deck 是软件工程师、导师、作家，有时甚至是老师。他拥有 12 年以上的软件工程经验，现在是 Python 编程语言的真正倡导者，同时他的热情是帮助人们提高他们的 Python(以及一般的编程)技能。你可以在</em> <a class="ae kv" href="https://www.linkedin.com/in/deck451/" rel="noopener ugc nofollow" target="_blank"> <em class="mg">【领英】</em></a><em class="mg"/><a class="ae kv" href="https://www.facebook.com/deck451/" rel="noopener ugc nofollow" target="_blank"><em class="mg">【脸书】</em></a><em class="mg"/><a class="ae kv" href="https://twitter.com/Deck45100" rel="noopener ugc nofollow" target="_blank"><em class="mg">推特</em></a><em class="mg"/><a class="ae kv" href="https://discord.com" rel="noopener ugc nofollow" target="_blank"><em class="mg">不和</em> </a> <em class="mg"> : Deck451#6188，以及跟随他写在这里的</em> <a class="ae kv" href="https://medium.com/@deck451" rel="noopener"> <em class="mg">中</em> </a></p></div></div>    
</body>
</html>