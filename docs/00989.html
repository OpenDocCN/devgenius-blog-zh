<html>
<head>
<title>Smarter caching with service workers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">服务人员更智能的缓存</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/smarter-caching-with-service-workers-76672bd24000?source=collection_archive---------21-----------------------#2020-06-21">https://blog.devgenius.io/smarter-caching-with-service-workers-76672bd24000?source=collection_archive---------21-----------------------#2020-06-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="94ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你曾经开发过一个web应用程序，你一定面临过让它离线工作的挑战。在这篇教程中，我分享了我最近如何让Codr离线工作的经验。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/226dad33f62e9ccc22da6c80ae5bce11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rw2-vN88grv_BeaHgwNLdw.png"/></div></div></figure><p id="2812" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Codr是一个针对<a class="ae kx" href="https://nevolin.be/codr/" rel="noopener ugc nofollow" target="_blank">编码谜题和挑战</a>的web app，但是你不需要写任何代码就能成功。初学者学习代码的好工具，专家的放松疗法。</p><p id="5098" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的栈是NodeJS，后端是Express，前端是html/js/jquery。要让一个webapp离线工作，你需要使用一个服务工作者(又名web worker)。它是浏览器中一个独立的线程，专门用于某个网站。如果你以前从未使用过服务人员，先去谷歌/Youtube上学习一些初学者教程。</p><p id="ca96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个网站通常有两种类型的内容，静态和动态。静态内容是图片、css、html、javascript等文件。另一方面，动态内容是从web服务器加载的，例如实时统计数据、博客评论等。离线用户应该能够访问所有静态内容，并在适当的时候显示一些离线状态消息:“要访问此页面，请联机”。</p><p id="546e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Codr，我们有不需要在线连接的练习挑战/谜题。练习题的数量是有限的，每个练习题都存储在一个单独的文件中，因此很容易被缓存。但对于排名模式，我们坚持在线，因为这些是动态生成的，并保持奖励系统公平合理。</p><p id="97a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意:有几个不错的现成解决方案，比如Google的Workbox，可以满足您的离线缓存需求。但是我需要一个定制的解决方案来满足我的特定需求。</p><p id="0aaf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的服务器列出了需要缓存的所有文件，并将其插入到服务工作者脚本的顶部:</p><pre class="km kn ko kp gt ky kz la lb aw lc bi"><span id="8b8c" class="ld le iq kz b gy lf lg l lh li">const assetsToCache = &lt;%- assetsToCache %&gt;<br/>// note I am using EJS templates</span></pre><p id="7d56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有基本的服务工作者教程都向您展示了如何缓存文件，但是很少有人解释如何强制缓存更新。一种解决方案是稍微更改您的服务工作者文件，这样浏览器将触发更新并对文件进行完整的重新缓存。但是，如果100个文件中只有1个发生了变化，那该怎么办呢？重新下载其他99个文件也有点傻，对吧。</p><p id="36ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的后端，我为每个缓存文件生成一个哈希/校验和(使用bcrypt)。我的资产结构是这样的:</p><pre class="km kn ko kp gt ky kz la lb aw lc bi"><span id="84c2" class="ld le iq kz b gy lf lg l lh li">const assetsToCache = [<br/>  {file: '/codr/views/home.html', checksum: 'XYZ123'},<br/>  ...<br/>]</span></pre><p id="368a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这样的结构，我可以使用IndexedDB存储(客户端)来跟踪所有缓存的文件及其校验和。因此，每当服务工作者触发更新时，它将只重新缓存已更改的文件(其中校验和不同)。以下是我的服务人员的(几乎)完整代码:</p><pre class="km kn ko kp gt ky kz la lb aw lc bi"><span id="b331" class="ld le iq kz b gy lf lg l lh li">importScripts('./js/localforage.min.js');<br/>// I am using localforage for IndexedDB access</span><span id="c3b4" class="ld le iq kz b gy lj lg l lh li">self.addEventListener("install", function(event) {<br/>    console.log("installing");<br/>    self.skipWaiting();<br/>    event.waitUntil(procDB());<br/>});</span><span id="1149" class="ld le iq kz b gy lj lg l lh li">async function procDB() {<br/>    const cache = await caches.open(CACHE_NAME);<br/>    for (const entry of assetsToCache) {<br/>        const value = await localforage.getItem(entry.file)<br/>        if (!value || value !== entry.checksum) {<br/>            console.log('caching: ' + entry.file)<br/>            await cache.add(entry.file)<br/>            await localforage.setItem(entry.file, entry.checksum)<br/>        } else {<br/>            // console.log('skip re-cache: ' + entry.file)<br/>        }<br/>    }<br/>}</span></pre><p id="eef6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编码快乐！:)</p></div></div>    
</body>
</html>