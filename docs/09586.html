<html>
<head>
<title>Terraform — Module Introduction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Terraform —模块介绍</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/terraform-module-introduction-3647c7511d0c?source=collection_archive---------4-----------------------#2022-08-30">https://blog.devgenius.io/terraform-module-introduction-3647c7511d0c?source=collection_archive---------4-----------------------#2022-08-30</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="bf70" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">什么是 Terraform 模块？</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/716e6844067384a8475a8343f356e37e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*OkuiaYyoXf0BZDdXqmRF4A.png"/></div></div></figure><p id="cc24" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">在 Terraform 中，一个“模块”是一个包含一组 Terraform 代码的文件夹，我们在我之前的 Terraform 文章中写的代码实际上就在一个模块中。</p><p id="04fc" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">Terraform 模块封装了专用于一项任务的资源组，减少了您为类似的基础架构组件开发的代码量。</p><p id="2b97" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">Terraform 模块对于编写高质量的 Terraform 代码和提高代码可重用性非常重要。<strong class="ku is">可以说，一个成熟的生产环境应该是由几个可信的、成熟的模块组装而成</strong>。</p><h1 id="fad4" class="lo lp ir bd lq lr ls lt lu lv lw lx ly jx lz jy ma ka mb kb mc kd md ke me mf bi translated">为什么是模块？</h1><p id="60d9" class="pw-post-body-paragraph ks kt ir ku b kv mg js kx ky mh jv la lb mi ld le lf mj lh li lj mk ll lm ln ik bi translated">Terraform 模块允许你在一些资源集的顶层创建逻辑抽象。换句话说，一个模块允许你将资源组合在一起，并在以后重用这个组，也可以在团队之间甚至在社区中共享模块。</p><p id="22cd" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">假设您有一个托管在 AWS 中的 EC2 服务器，这个 EC2 服务器正在使用哪些 AWS 资源？</p><ul class=""><li id="28ce" class="ml mm ir ku b kv kw ky kz lb mn lf mo lj mp ln mq mr ms mt bi translated">EC2 实例本身</li><li id="9b3a" class="ml mm ir ku b kv mu ky mv lb mw lf mx lj my ln mq mr ms mt bi translated">用于存储应用程序数据 EBS 卷</li><li id="c4c4" class="ml mm ir ku b kv mu ky mv lb mw lf mx lj my ln mq mr ms mt bi translated">面向公众访问的弹性 IP</li><li id="f6fa" class="ml mm ir ku b kv mu ky mv lb mw lf mx lj my ln mq mr ms mt bi translated">入口和出口流量的安全组</li><li id="1f45" class="ml mm ir ku b kv mu ky mv lb mw lf mx lj my ln mq mr ms mt bi translated">一个 VPC</li><li id="7147" class="ml mm ir ku b kv mu ky mv lb mw lf mx lj my ln mq mr ms mt bi translated">子网</li><li id="44fa" class="ml mm ir ku b kv mu ky mv lb mw lf mx lj my ln mq mr ms mt bi translated">..等等</li></ul><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj mz"><img src="../Images/2c1634c0e6d2d60aa323446be9e9d3e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c0FIM2mmHCc8pFdoE8ZGmw.png"/></div></div></figure><p id="ec78" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">现在让我们假设您需要用一组资源创建这个服务器 3 次。这就是模块真正有用的地方:你绝对不想一遍又一遍地重复相同的配置代码。相反，你需要做的是调用 3 次“app_server”模块。</p><pre class="kh ki kj kk gu na nb nc nd aw ne bi"><span id="92a6" class="nf lp ir nb b gz ng nh l ni nj">module "server" {<br/>  count         = 3<br/>  source        = "./module_app_server"<br/>  some_variable = some_value<br/>}</span></pre><h1 id="ddb9" class="lo lp ir bd lq lr ls lt lu lv lw lx ly jx lz jy ma ka mb kb mc kd md ke me mf bi translated">创建一个模块</h1><p id="7a6f" class="pw-post-body-paragraph ks kt ir ku b kv mg js kx ky mh jv la lb mi ld le lf mj lh li lj mk ll lm ln ik bi translated">几乎任何包含 Terraform 代码文件的文件夹都是一个 Terraform 模块。如果我们直接在一个文件夹中执行<code class="fe nk nl nm nb b">terraform apply</code>或<code class="fe nk nl nm nb b">terraform plan</code>命令，那么当前文件夹就叫做<strong class="ku is">根</strong>模块。</p><p id="8d2f" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">在执行 Terraform 命令时，我们还可以通过命令行参数指定根模块的路径。</p><h2 id="d4f7" class="nf lp ir bd lq nn no dn lu np nq dp ly lb nr ns ma lf nt nu mc lj nv nw me nx bi translated">模块结构</h2><p id="c66a" class="pw-post-body-paragraph ks kt ir ku b kv mg js kx ky mh jv la lb mi ld le lf mj lh li lj mk ll lm ln ik bi translated">旨在重用的模块使用与我们编写的根模块相同的 Terraform 代码和代码风格指南。一般来说，一个完整的模块应该是这样的:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj ny"><img src="../Images/53fc40858860bdaaa2d3dfac16def65d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5H1ZahqUmYyjj4vgu_IFlg.png"/></div></div></figure><p id="943c" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">让我们逐一探索这些项目:</p><ul class=""><li id="bc4c" class="ml mm ir ku b kv kw ky kz lb mn lf mo lj mp ln mq mr ms mt bi translated"><code class="fe nk nl nm nb b">README.md</code>:描述模块的用途。应该用 Markdown 语法写。不需要描述模块的输入和输出，因为工具会自动收集相关信息。如果在<code class="fe nk nl nm nb b">README</code>中引用了外部文件或图像，请务必使用带有特定版本号的绝对 URL 路径，以防止将来指向错误的版本。</li><li id="3339" class="ml mm ir ku b kv mu ky mv lb mw lf mx lj my ln mq mr ms mt bi translated"><code class="fe nk nl nm nb b">LICENSE</code>:描述模块的使用。如果你想公开发布一个模块，最好考虑包含一个明确的许可协议文件，许多组织不会使用没有明确许可协议的模块。</li><li id="70a4" class="ml mm ir ku b kv mu ky mv lb mw lf mx lj my ln mq mr ms mt bi translated"><code class="fe nk nl nm nb b">examples</code>:顾名思义，文件夹包含示例。这是可选的。</li><li id="6c27" class="ml mm ir ku b kv mu ky mv lb mw lf mx lj my ln mq mr ms mt bi translated"><code class="fe nk nl nm nb b">variables.tf</code>:包含模块的所有输入变量。输入变量应该有对其用途的清晰描述。</li><li id="6efb" class="ml mm ir ku b kv mu ky mv lb mw lf mx lj my ln mq mr ms mt bi translated"><code class="fe nk nl nm nb b">outputs.tf</code>:包含模块的所有输出值。输出值应该有明确的目的描述。</li><li id="64db" class="ml mm ir ku b kv mu ky mv lb mw lf mx lj my ln mq mr ms mt bi translated"><code class="fe nk nl nm nb b">modules</code>:嵌入式模块文件夹，为了封装复杂度或者重用代码，我们可以在 modules 子目录下创建一些嵌入式模块。外部用户可以使用包含自述文件的所有嵌入式模块；没有<code class="fe nk nl nm nb b">README</code>文件的模块被认为只在当前模块中使用(可选)。</li><li id="4296" class="ml mm ir ku b kv mu ky mv lb mw lf mx lj my ln mq mr ms mt bi translated"><code class="fe nk nl nm nb b">main.tf</code>:模块的主入口点。对于一个简单的模块，所有的资源都可以在其中定义；如果是比较复杂的模块，我们可以将创建的资源分布到不同的代码文件中，但是引用嵌入式模块的代码还是要保存在<code class="fe nk nl nm nb b">main.tf</code>中。</li></ul><p id="2b15" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">如果一个模块包含多个嵌入模块，它们应该避免相互引用，根模块负责组合它们。</p><p id="1439" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">除了完整的模块结构之外，有时为了方便起见，可以有一个如下所示的最小模块:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj nz"><img src="../Images/19670e4fc7e18329e14281f2b688b6c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*IIOo4AJFFrca36Qy5wCROg.png"/></div></figure><h1 id="0f07" class="lo lp ir bd lq lr ls lt lu lv lw lx ly jx lz jy ma ka mb kb mc kd md ke me mf bi translated">根模块与子模块</h1><p id="e03a" class="pw-post-body-paragraph ks kt ir ku b kv mg js kx ky mh jv la lb mi ld le lf mj lh li lj mk ll lm ln ik bi translated">每个 Terraform 配置至少有一个模块，称为其<em class="oa">根模块</em>，由主工作目录中的<code class="fe nk nl nm nb b">.tf</code>文件中定义的资源组成。</p><p id="183a" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">Terraform 模块(通常是配置的根模块)可以<em class="oa">调用</em>其他模块，将它们的资源包含到配置中。被另一个模块调用的模块通常被称为<em class="oa">子模块。</em></p><p id="8daa" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">如下图所示:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj ob"><img src="../Images/bce9bcf823646f34e5a282bab9350190.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Np7lfQsbng8B47_qnB3xfw.png"/></div></div></figure><p id="93af" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">子模块可以来自许多地方:</p><ul class=""><li id="bbe2" class="ml mm ir ku b kv kw ky kz lb mn lf mo lj mp ln mq mr ms mt bi translated">本地路径</li><li id="9913" class="ml mm ir ku b kv mu ky mv lb mw lf mx lj my ln mq mr ms mt bi translated">官方的 Terraform 注册表</li><li id="c8fd" class="ml mm ir ku b kv mu ky mv lb mw lf mx lj my ln mq mr ms mt bi translated">一个 Git 存储库(一个定制的或者 GitHub/BitBucket)</li><li id="8ef9" class="ml mm ir ku b kv mu ky mv lb mw lf mx lj my ln mq mr ms mt bi translated">带有模块的. zip 档案的 HTTP URL</li></ul><h1 id="1d33" class="lo lp ir bd lq lr ls lt lu lv lw lx ly jx lz jy ma ka mb kb mc kd md ke me mf bi translated">避免深度模块结构</h1><p id="58c8" class="pw-post-body-paragraph ks kt ir ku b kv mg js kx ky mh jv la lb mi ld le lf mj lh li lj mk ll lm ln ik bi translated">我们刚刚提到，可以在子目录下创建嵌入式模块(<code class="fe nk nl nm nb b">modules/</code>文件夹)。Terraform 提倡“扁平化”的模块结构，只需维护一层嵌入式模块，防止在嵌入式模块内继续创建嵌入式模块。</p><p id="7418" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">嵌入式模块应该被设计成容易组合的结构，这样在根模块中，通过组合独立的嵌入式模块可以创建复杂的基础设施。</p><h1 id="9c8e" class="lo lp ir bd lq lr ls lt lu lv lw lx ly jx lz jy ma ka mb kb mc kd md ke me mf bi translated">结论</h1><p id="f599" class="pw-post-body-paragraph ks kt ir ku b kv mg js kx ky mh jv la lb mi ld le lf mj lh li lj mk ll lm ln ik bi translated">现在你应该对什么是 Terraform 模块和子模块有了基本的了解。在我的下一篇文章中，我将通过一些例子详细介绍如何使用 Terraform 模块。</p></div></div>    
</body>
</html>