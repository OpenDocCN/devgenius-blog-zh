<html>
<head>
<title>Node.js Best Practices — Security and Config</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js最佳实践—安全性和配置</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/node-js-best-practices-security-and-config-c212c3e2cea8?source=collection_archive---------6-----------------------#2020-08-20">https://blog.devgenius.io/node-js-best-practices-security-and-config-c212c3e2cea8?source=collection_archive---------6-----------------------#2020-08-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e28a31ad5150cf79d29957bf656b6afa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cytGG9PrQ3jtObPI"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">弗洛里安·伯杰在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="0d1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，JavaScript应用程序也必须写得很好。</p><p id="9a1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们以后会遇到各种各样的问题。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看在编写节点应用程序时应该遵循的一些最佳实践。</p><h1 id="2d79" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">阻止跨站点请求伪造</h1><p id="aa15" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该阻止跨站点请求伪造。</p><p id="a9fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个攻击者，攻击者可以试图通过自己的站点将数据放入应用程序。</p><p id="ddee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">攻击者创建一个带有表单或其他输入的请求，这些表单或输入创建针对应用程序的请求。</p><p id="beac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了减少跨站点请求伪造，我们可以使用csurf包。</p><p id="b4d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="693f" class="mn lc iq mj b gy mo mp l mq mr">const express = require(‘express’);  <br/>const csrf = require('csurf');</span><span id="bf33" class="mn lc iq mj b gy ms mp l mq mr">const app = express();</span><span id="1d95" class="mn lc iq mj b gy ms mp l mq mr">app.use(csrf());</span><span id="6a38" class="mn lc iq mj b gy ms mp l mq mr">app.use(function(req, res, next){ <br/> res.locals.csrftoken = req.csrfToken(); <br/> next();<br/>});</span></pre><p id="1379" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<code class="fe mt mu mv mj b">csrf</code>中间件，所以我们可以用<code class="fe mt mu mv mj b">csrfToken</code>方法获得CSRF令牌。</p><p id="c147" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以在模板中使用它:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6f3f" class="mn lc iq mj b gy mo mp l mq mr">&lt;input type="hidden" name="&lt;i&gt;csrf" value={{csrftoken}} /&gt;</span></pre><h1 id="50c1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不要使用邪恶的正则表达式</h1><p id="6814" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">邪恶的正则表达式包括分区分组、重复和重叠交替。</p><p id="9e16" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当应用于某些不匹配的输入时，这些模式可能需要指数级的时间来计算。</p><p id="302f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些模式的例子包括:</p><ul class=""><li id="e179" class="mw mx iq kf b kg kh kk kl ko my ks mz kw na la nb nc nd ne bi translated"><code class="fe mt mu mv mj b">(a+)+</code></li><li id="3099" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated"><code class="fe mt mu mv mj b">([a-zA-Z]+)*</code></li><li id="d2f6" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated"><code class="fe mt mu mv mj b">(a|aa)+</code></li></ul><p id="847c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果检查像<code class="fe mt mu mv mj b">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</code>这样的输入，那么我们将挂起我们的应用程序。</p><p id="8494" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完成模式检查可能需要几秒或几分钟。</p><p id="9e87" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用以下方法审计邪恶的正则表达式:</p><ul class=""><li id="4dbc" class="mw mx iq kf b kg kh kk kl ko my ks mz kw na la nb nc nd ne bi translated"><a class="ae kc" href="http://www.cs.bham.ac.uk/~hxt/research/rxxr.shtml" rel="noopener ugc nofollow" target="_blank"> RXRR </a></li><li id="027d" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated"><a class="ae kc" href="https://www.microsoft.com/en-us/download/details.aspx?id=20095" rel="noopener ugc nofollow" target="_blank"> SDL RegEx Fuzzer </a></li></ul><h1 id="b1d7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">添加速率限制</h1><p id="8a21" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">速率限制将保护我们免受DOS攻击。</p><p id="2bdb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不希望攻击者用大量请求轰炸我们的应用程序，让它们全部通过。</p><p id="0c93" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了限制从一个IP地址对我们的应用程序的请求数量，我们可以使用express-limiter包。</p><p id="0ea9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="022d" class="mn lc iq mj b gy mo mp l mq mr">const express = require('express');<br/>const redisClient = require('redis').createClient();</span><span id="93a0" class="mn lc iq mj b gy ms mp l mq mr">const app = express();</span><span id="1063" class="mn lc iq mj b gy ms mp l mq mr">const limiter = require('express-limiter')(app, redisClient);</span><span id="aacd" class="mn lc iq mj b gy ms mp l mq mr">limiter({<br/>  lookup: ['connection.remoteAddress'],<br/>  total: 100,<br/>  expire: 1000 * 60 * 60<br/>})</span></pre><p id="cc05" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<code class="fe mt mu mv mj b">limiter</code>中间件来限制每个IP地址每小时最多100个请求。</p><p id="ad6e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">total</code>是请求数。</p><p id="9568" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">expire</code>是重新设定限值的时间。</p><h1 id="0577" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Docker撰写</h1><p id="338c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以创建Docker compose配置，将Nginx与我们的应用程序一起安装。</p><p id="1e6b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3326" class="mn lc iq mj b gy mo mp l mq mr">web:<br/>  build: ./app<br/>  volumes:<br/>    - "./app:/src/app"<br/>  ports:<br/>    - "3030:3000"<br/>  command: pm2-docker app/server.js<br/>  nginx:<br/>    restart: always<br/>    build: ./nginx/<br/>  ports:<br/>    - "80:80"<br/>  volumes:<br/>    - /www/public<br/>  volumes_from:<br/>    - web<br/>  links:<br/>    - web:web</span></pre><p id="954e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用Docker compose文件一次性安装Nginx和我们的应用程序。</p><h1 id="eaef" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在业务逻辑和API路径之间保持清晰的分离</h1><p id="d8c1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该在业务逻辑和API路径之间保持清晰的分离。</p><p id="e141" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们绝对不应该在我们的API路由中包含我们的逻辑，因为路由可以做很多事情。</p><p id="6236" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要一个包含所有业务逻辑的服务层，这样我们就可以分别使用和测试它们。</p><p id="bdb2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以更容易地使用一切。</p><h1 id="7c46" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对配置文件使用config文件夹</h1><p id="a937" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">配置文件应该在一个<code class="fe mt mu mv mj b">config</code>文件夹中，这样我们可以将所有的配置添加到一个地方。</p><p id="b462" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样很容易发现和改变。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/99f0dae11206e2fcdbc55a758abdaee5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zwuNxgfAfjbqYskp"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@flowforfrank?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">费伦茨·阿尔马西</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><h1 id="8cc8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="9100" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当我们创建节点应用程序时，应该考虑到邪恶的正则表达式和文件夹结构。</p></div></div>    
</body>
</html>