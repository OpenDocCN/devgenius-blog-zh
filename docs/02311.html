<html>
<head>
<title>How to convert between JSON and XML in IBM Integration Bus</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">IBM集成总线中JSON和XML之间如何转换</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-convert-between-json-and-xml-in-ibm-integration-bus-2754a837aec9?source=collection_archive---------1-----------------------#2020-07-28">https://blog.devgenius.io/how-to-convert-between-json-and-xml-in-ibm-integration-bus-2754a837aec9?source=collection_archive---------1-----------------------#2020-07-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/9f9b44b06927b7c9daf67a6fb24cf3bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ApmqG_QK3RX_eZgG_lHMgQ.jpeg"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">沙哈达特·拉赫曼在<a class="ae ja" href="https://unsplash.com/s/photos/xml?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><div class=""/><p id="d316" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">消息格式之间的转换是集成软件的主要特性之一。之所以需要这样做，是因为应用程序使用不同的格式。一些应用程序被公开为基于XML的SOAP API，而另一些被公开为基于JSON格式的REST API。因此，在本教程中，我将解释如何在IIB使用IIB的母语ESQl(也称为扩展SQl语言)完成JSON和XML之间的转换。</p><h2 id="9af8" class="ky kz jd bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">要求:</h2><p id="acbb" class="pw-post-body-paragraph ka kb jd kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">在本教程中，我们将使用postman向我们的应用程序发送请求，IBM App Connect创建REST API，根据我们收到的输入在XML和JSON之间进行转换。</p><h2 id="a3d7" class="ky kz jd bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">第一步:</h2><p id="784f" class="pw-post-body-paragraph ka kb jd kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">在您的App Connect工具包中，首先创建一个REST API。</p><figure class="lx ly lz ma gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lw"><img src="../Images/65448828f04a6a7caaab38022e36a494.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8rDvVMVyLbydYt-g47Szcg.png"/></div></div></figure><h2 id="d128" class="ky kz jd bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">第二步:</h2><p id="b3f9" class="pw-post-body-paragraph ka kb jd kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">打开REST描述符，通过单击resources旁边的(+)添加新资源。将其命名为/converter，并选择post operation。单击应用，然后单击确定</p><figure class="lx ly lz ma gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mb"><img src="../Images/4d01e34ab8847c1181a5892e989e8327.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fqml8QzhlbYLW1tijwMOOw.png"/></div></div></figure><h2 id="46b2" class="ky kz jd bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">第三步:</h2><p id="6f54" class="pw-post-body-paragraph ka kb jd kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">如图所示，通过单击“创建子流程”图标来创建子流程。</p><figure class="lx ly lz ma gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mc"><img src="../Images/1b055b66fe314ff5ef790199796da7f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5go70EU2v9TQj8p4kHRL5w.png"/></div></div></figure><h2 id="487e" class="ky kz jd bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">第四步:</h2><p id="d34e" class="pw-post-body-paragraph ka kb jd kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">一旦我们准备好了子流程，我们就可以开始开发了。添加以下节点，并如图所示进行连接。双击该节点，这样它将生成ESQL文件，以避免任何错误。</p><figure class="lx ly lz ma gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi md"><img src="../Images/54ebe0e7690778ddb9017b8cfcd0a573.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iMM8sxqTek6DGtKWiUlykA.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">我们的REST API的消息流</figcaption></figure><blockquote class="me"><p id="f8db" class="mf mg jd bd mh mi mj mk ml mm mn kx dk translated"><strong class="ak">IIB的REST API默认解析JSON格式的数据</strong></p></blockquote><p id="d1b7" class="pw-post-body-paragraph ka kb jd kc b kd mo kf kg kh mp kj kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated">设计这样一个消息流的原因是IIB的<strong class="kc je"> REST API默认解析JSON格式的数据</strong>。在我们的教程中，我们需要在XML和JSON之间进行转换，反之亦然。因此，我们还需要配置我们的流来接受XML格式。为此，我们使用了请求头中的头参数，并根据它的值路由我们的流。</p><figure class="lx ly lz ma gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mt"><img src="../Images/21bb2609c4ff6b3d718c918ecff1748e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pbqMpEFWQKnDKreSrclcmA.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">路由节点的属性</figcaption></figure><p id="e71a" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在匹配输出的情况下，它将路由到“重置内容描述符”节点，并将消息域设为XMLNSC以便解析。在JSON输出的情况下，流将转到compute节点进行转换。在流程中的任何一点，如果解析失败(JSON或XML ),它将从错误计算节点发送一个错误。</p><figure class="lx ly lz ma gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mu"><img src="../Images/606e8a700218f3bbe2260b611d9fb567.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rxVqS_KaKmpj6UPlxd4fmg.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">重置内容描述符节点的属性</figcaption></figure><h2 id="e081" class="ky kz jd bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">第五步:实际代码</h2><p id="22ff" class="pw-post-body-paragraph ka kb jd kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">到这一步，我们已经设置好了所有的配置和消息流。现在是实际查看编码部分的时候了。下图显示了ESQL代码如何区分XML和JSON格式，并最终进行实际转换。</p><figure class="lx ly lz ma gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi ca"><img src="../Images/20cefb7819efa5d0f6b5cc0df7e3bdea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jWvvgdbxigiEoU6gxAgL7w.png"/></div></div></figure><p id="65f0" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">完整的项目上传到我的github库，链接如下:</p><div class="im in gp gr io mv"><a href="https://github.com/ahmedkhan1991/xmlJsonConverterESQL" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd je gy z fp na fr fs nb fu fw jc bi translated">Ahmed Khan 1991/xmlJsonConverterESQL</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">github.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj iu mv"/></div></div></a></div><h2 id="b089" class="ky kz jd bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">步骤6:用邮递员测试</h2><p id="26c1" class="pw-post-body-paragraph ka kb jd kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">对于所有还没用过postman的人来说，Postman是一个用来测试REST APIs的软件。现在我们的REST API已经准备好了，我们已经将它部署到我们的集成服务器中，并将使用postman测试这个API。</p><ol class=""><li id="d94a" class="nk nl jd kc b kd ke kh ki kl nm kp nn kt no kx np nq nr ns bi translated"><strong class="kc je">测试JSON到XML </strong></li></ol><figure class="lx ly lz ma gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nt"><img src="../Images/ecd11b541de117141de0d5e40c0fb9bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tlLzt-_0dsYlMJywwR1tUw.png"/></div></div></figure><p id="9d86" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在postman中，转到标题选项卡，创建内容类型为“应用程序/json”。</p><p id="6fdd" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后打开body标记，输入任何想要转换成XML的JSON对象，应用程序将返回带有根元素“root”的XML，如下所示。</p><figure class="lx ly lz ma gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nu"><img src="../Images/6061ec84992a935079a66da8a4cfafd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0EF_BQLAfm82KDrkFo64Dw.png"/></div></div></figure><p id="be49" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2.<strong class="kc je">测试XML到JSON </strong></p><figure class="lx ly lz ma gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nv"><img src="../Images/1c7ba13ceb3218ab9829b8301220ebc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cd-PZ_myk74Fp50LtOq1nQ.png"/></div></div></figure><p id="07cd" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在postman中，转到header选项卡，将Content-Type更改为“application/xml”。</p><p id="6db7" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后打开body标记，输入任何想要转换成JSON的有效XML文本，应用程序将返回相应的JSON，如下所示。</p><figure class="lx ly lz ma gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nw"><img src="../Images/86804601e6eb4ce0ae90b17cd0e36848.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WisLx2eJy6hG6ulRKLgGfg.png"/></div></div></figure><h2 id="1e44" class="ky kz jd bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">结论:</h2><p id="a873" class="pw-post-body-paragraph ka kb jd kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">在本文中，我们比理论上解释JSON和XML格式更进了一步。我们使用App Connect Toolkit和ESQL创建了一个REST API，用于在业界广泛使用的两种消息格式之间进行转换。</p><p id="529b" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc je">阅读更多:</strong></p><div class="im in gp gr io mv"><a href="https://medium.com/dev-genius/how-to-convert-xml-list-to-json-array-in-iib-app-connect-enterprise-toolkit-using-esql-b495673fe838" rel="noopener follow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd je gy z fp na fr fs nb fu fw jc bi translated">如何使用ESQL在IIB(App Connect Enterprise toolkit)将XML列表转换为JSON数组</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">以前我写过一篇关于如何在SOAP XML和REST JSON对象之间进行转换的文章，反之亦然。简而言之，这是…</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">medium.com</p></div></div><div class="ne l"><div class="nx l ng nh ni ne nj iu mv"/></div></div></a></div><p id="9b21" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc je">快乐学习。</strong></p></div></div>    
</body>
</html>