<html>
<head>
<title>How to perform debouncing in Reactjs?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在 Reactjs 中执行去抖？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-perform-debouncing-in-reactjs-b5efc3ab8c6a?source=collection_archive---------18-----------------------#2022-03-03">https://blog.devgenius.io/how-to-perform-debouncing-in-reactjs-b5efc3ab8c6a?source=collection_archive---------18-----------------------#2022-03-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/a9400ec7d4edc66784c220ff2d03fa3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PIeTcwHHDH8t3zJIkwQhsQ.jpeg"/></div></div></figure><p id="a829" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Javascript 中的去抖是提高浏览器性能的有效方法。这是耗时的计算，因此它们可能会频繁调用或降级。基于去抖的编程实践去抖是维护耗时任务的合适选择。通常，该过程是一个方便的选项，用于限制进程中调用函数的速率。</p><h1 id="8173" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">什么是去抖功能？</h1><p id="6aa1" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">Reactjs 中的 Debounce 或 debounce()函数主要是强制函数在运行时暂停。函数的作用是限制或减少它们被调用的次数。</p><p id="de21" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最佳<a class="ae lw" href="https://bosctechlabs.com/hire-react-developer/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> react js 开发服务</strong> </a>的可用性将是有效改善稳定结果的合适选择。这也是限制函数调用次数的合适选项。</p><h1 id="b090" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">Reactjs 中的去抖如何发挥作用？</h1><p id="1bc3" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">Reactjs 中的去抖是一个非常有用的过程，主要是确保为您提供超越的实际好处。例如，当有自动完成或预输入时，它需要和下拉选项一起显示。</p><p id="55a4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些主要是在为每次击键触发 API 时启用的。通常，去抖功能是快速触发 API 的实用选项之一，并且它还允许整个时间延迟属性。这些是在键入时快速添加用户的合适选项。</p><p id="b66d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当您给出 300 毫秒的延迟时，用户需要一些时间或更长时间来键入下一个单词或字母。对于触发 API 来说，这是一个非常实用的选择，这个过程主要减少了 API 调用的数量，并使其变得非常重要。</p><h2 id="7762" class="lx ku in bd kv ly lz dn kz ma mb dp ld kg mc md lh kk me mf ll ko mg mh lp mi bi translated">创建 React 应用程序并安装模块:</h2><p id="655d" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">步骤 1:使用以下命令创建一个 React 应用程序:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="8158" class="lx ku in mo b gy ms mt l mu mv">npx create-react-app react-debouncing</span></pre><p id="2e47" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">步骤 2:创建项目文件夹后，即 react-de bounding，使用以下命令移动到该文件夹:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="6d0e" class="lx ku in mo b gy ms mt l mu mv">cd react-debouncing</span></pre><p id="903b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">步骤 3:创建 ReactJS 应用程序后，使用以下命令安装所需的模块:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="f1a7" class="lx ku in mo b gy ms mt l mu mv">npm install lodash</span></pre><h2 id="c978" class="lx ku in bd kv ly lz dn kz ma mb dp ld kg mc md lh kk me mf ll ko mg mh lp mi bi translated">无去抖的回拨:</h2><p id="2bc2" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">该流程主要增加了被称为<filterlist>受理的重要环节。主要原因是他们有一个包含 200 条记录的完整名单。</filterlist></p><p id="34ef" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它特别具有组件和输入，用户可以在其中键入他们需要的查询和名称，这样他们就可以在查询中被自动过滤。<filterlist>组件列表如下:</filterlist></p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="cdd5" class="lx ku in mo b gy ms mt l mu mv">import React, { useState, useCallback } from "react";<br/>import debounce from "lodash.debounce";<br/>export function FilterList({ names }) {<br/> const [query, setQuery] = useState("");<br/> let filteredNames = names;<br/> if (query !== "") {<br/>   filteredNames = names.filter((name) =&gt; {<br/>     return name.toLowerCase().includes(query.toLowerCase());<br/>   });<br/> }<br/> const changeHandler = (event) =&gt; {<br/>   setQuery(event.target.value);<br/> };<br/> const debouncedChangeHandler = useCallback(debounce(changeHandler, 300), []);<br/> return (<br/>   &lt;div&gt;<br/>     &lt;input<br/>       onChange={debouncedChangeHandler}<br/>       type="text"<br/>       placeholder="Type a query..."<br/>     /&gt;<br/>     {filteredNames.map((name) =&gt; (<br/>       &lt;div key={name}&gt;{name}&lt;/div&gt;<br/>     ))}<br/>     &lt;div&gt;{filteredNames.length === 0 &amp;&amp; query !== "" &amp;&amp; "No matches..."}&lt;/div&gt;<br/>   &lt;/div&gt;<br/> );<br/>}</span></pre><h1 id="e3c2" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">什么是去抖应用？</h1><p id="3886" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">主要实现了去抖动，其中搜索与用户一起工作。这些主要是在搜索框中键入的，以便获得正确的结果。它主要来自服务器，所以单击服务器 API 会在最大程度上停止。</p><p id="979e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些主要是由于频繁的服务器 API 更改而导致的，因此它们会降低服务器性能。基于去抖动的各种应用是可用的，例如内容加载网页，如 Face、Twitter 等等。这些应用程序主要允许用户保留内容并持续向下滚动。</p><p id="9221" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通常，当滚动事件被频繁点击时，会产生影响。主要原因是它们包含更多的图像和视频。滚动事件利用去抖动。例如，当您在寻找去抖 handleOnChange 时</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="eea6" class="lx ku in mo b gy ms mt l mu mv">function debounce(fn, delay) {<br/>  var timer = null;<br/>  return function() {<br/>    var context = this,<br/>      args = arguments;   <br/>clearTimeout(timer);<br/>    timer = setTimeout(function() {     <br/>fn.apply(context, args);<br/>    }, delay);<br/>  };<br/>}<br/>var SearchBox = React.createClass({<br/>  render: function() {<br/>    return &lt;input type="search" name="p" onChange={this.handleOnChange} /&gt;;<br/>  }, <br/>handleOnChange: function(event) {<br/>    // make ajax call<br/>  }<br/>});</span></pre><h1 id="94ba" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">去抖动回拨的代码:</h1><p id="6468" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">为了在 Reactjs 中反跳 changeHandler 函数，使用 lodash 很方便。去抖封装。这些主要是通过各种允许去抖动作的库来实现的。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="60ca" class="lx ku in mo b gy ms mt l mu mv">import debounce from 'lodash.debounce';<br/>const debouncedCallback = debounce(callback, waitTime);</span></pre><p id="eb02" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在该过程中，debounce()函数将接受回调参数函数。这些是为其功能返回去抖版本的合适选项。主要调用去反跳函数，因为去反跳回调会被自动调用多次。</p><p id="e47a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些都是突发的，并保证在不同的等待时间调用回调。在分析过程中，这是一个非常重要的方式去抖动拟合完美。这些都是适合在<filterlist>中过滤的方法:让我们去抖 changeHandler。该过程将主要导致 300 毫秒的等待时间。</filterlist></p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="f197" class="lx ku in mo b gy ms mt l mu mv">import { useState, useCallback } from 'react';<br/>import debounce from 'lodash.debounce';<br/>export function FilterList({ names }) {<br/>  const [query, setQuery] = useState("");<br/>  let filteredNames = names;<br/>  if (query !== "") {   <br/>filteredNames = names.filter((name) =&gt; {     <br/>return name.toLowerCase().includes(query.toLowerCase());<br/>    });<br/>  }<br/>  const changeHandler = event =&gt; {   <br/>setQuery(event.target.value);<br/>  };<br/>  const debouncedChangeHandler = useCallback( <br/>debounce(changeHandler, 300)<br/>  , []);<br/>  return (   <br/>&lt;div&gt;     <br/>&lt;input       <br/>onChange={debouncedChangeHandler}       <br/>type="text"       <br/>placeholder="Type a query..."     <br/>/&gt;     <br/>{filteredNames.map(name =&gt; &lt;div key={name}&gt;{name}&lt;/div&gt;)}   <br/>&lt;/div&gt;<br/>  );<br/>}</span></pre><h1 id="fea3" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">使用后端代码创建项目:</h1><p id="9624" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">使用击键时的安全 API 构建自动完成项目是很有帮助的。这些主要是增加了自定义的去抖功能，这是一个非常方便的选择使用内置的去抖功能，保证了更好的使用。</p><p id="fefe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用 node 创建简短的后端程序可以保证得到更好的字符串。获得最适合在 Reactjs 中执行去抖的 react js 开发服务，节省更多时间。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="6d10" class="lx ku in mo b gy ms mt l mu mv">const express =require('express');<br/>const mongoose = require('mongoose');<br/>const bodyParser = require('body-parser');<br/>const app = express();<br/>app.use(bodyParser.json());<br/>app.use((req,res,next) =&gt; {<br/>res.header('Access-Control-Allow-Origin', '*');<br/>res.header('Access-Control-Allow-Headers', '*');<br/>next(); <br/>});<br/>const Words = mongoose.model("words", new mongoose.Schema({ <br/>words: [String] <br/>}));<br/>app.get("/api/words", async (req , res) =&gt; {<br/>let qw = req.query.queryWord; <br/>let queryWord = qw.replace(/^"|"$/g, '');<br/>const words = await Words.find({})<br/>let wordsArray = words[0].words;<br/>let filteredArray = wordsArray.filter(val =&gt; {<br/>return val.indexOf(queryWord.toLowerCase()) &gt; -1<br/>});<br/>res.send(filteredArray);<br/>});<br/>app.post("/api/words", async (req , res) =&gt; {<br/>const newWordArray = new Words(req.body);<br/>const savedArray = await newWordArray.save();<br/>res.send(savedArray);<br/>});<br/> const PORT = process.env.port || 5000;<br/>mongoose.connect("mongodb://localhost/word-list-db", {useNewUrlParser: true, useUnifiedTopology: true})<br/>  .then(() =&gt; {<br/>  app.listen(PORT, () =&gt; console.log(`Server running on port ${PORT}`));<br/>})<br/>.catch((err) =&gt; console.log(err));<br/>mongoose.set('useFindAndModify', false);</span></pre><h2 id="50c4" class="lx ku in bd kv ly lz dn kz ma mb dp ld kg mc md lh kk me mf ll ko mg mh lp mi bi translated">反应代码:</h2><p id="65fb" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">去抖函数有两个不同的参数。这些主要是在延迟时启用主要的调用函数，比如 getDropDown 函数。这些包括呼叫的延迟量，并确保获得快速功能。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="64c0" class="lx ku in mo b gy ms mt l mu mv">import React , {useCallback, useState} from 'react'; <br/>import './App.css';<br/>import axios from 'axios';<br/>function App() {<br/> const [options, showOptions] = useState(false);<br/> const [searchString, setSearchString] = useState("");<br/> const [dropDownOptions, setDropdownOptions] = useState([]);<br/> const onInputClickHandler = () =&gt; {<br/>   showOptions(true);<br/> } <br/> const getDropDown = (val) =&gt; {<br/>   axios.get("http://localhost:5000/api/words?queryWord=" + val).then(res =&gt; {<br/>     setDropdownOptions(res.data);<br/>   });<br/> }<br/> const onInputChangeHandler = (e) =&gt; {<br/>   const nextValue = e.target.value<br/>   setSearchString(nextValue);<br/>   getDropDown(nextValue);<br/> }<br/> const setOptionsAsInputHandler = (val) =&gt; {<br/>   showOptions(false);<br/>   setSearchString(val);<br/> }<br/> return (<br/>   &lt;div className="App"&gt;<br/>     &lt;header className="App-header"&gt;<br/>       &lt;h1&gt;Debounce In React&lt;/h1&gt;<br/>       &lt;div className="Autocomplete"&gt;<br/>         &lt;input className="Input" placeholder="Type Something..." onClick={onInputClickHandler} onChange={onInputChangeHandler} value={searchString}/&gt;<br/>         &lt;div className="Options"&gt;<br/>           {options ?<br/>             dropDownOptions.map(value =&gt; {<br/>               return &lt;div key={value} onClick={() =&gt; setOptionsAsInputHandler(value)}&gt;{value}&lt;/div&gt;<br/>             })<br/>           : null}<br/>         &lt;/div&gt;         <br/>       &lt;/div&gt;<br/>     &lt;/header&gt;<br/>   &lt;/div&gt;<br/> );<br/>} <br/>export default App;</span></pre><h2 id="1fd4" class="lx ku in bd kv ly lz dn kz ma mb dp ld kg mc md lh kk me mf ll ko mg mh lp mi bi translated">结论:</h2><p id="84e5" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">创建去抖动函数的最好方法是使用 useMemo()钩子。这些也是处理所有正在发生的事件的合适选项。正确的设置保证了去抖关闭的完全刷新。当去抖事件处理程序访问时，必须使用 useMemo(…，dependencies)设置依赖关系参数。</p><p id="360c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">感谢您从头到尾阅读我们的文章。希望你喜欢阅读，并从我们的文章中获得一些价值。还有，让我们知道你的想法。我们不断改进我们的内容，并始终努力为您提供最好的。</p><p id="fe67" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你的企业缺乏专业人士，聘请一家<a class="ae lw" href="https://bosctechlabs.com/services/mobile-app-development/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">手机 app 开发公司</strong> </a> <strong class="jx io"> </strong>为 app 开发解决方案，攻克技术上的东西。</p><p id="ee50" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">继续学习！！！继续分享！！！</p></div></div>    
</body>
</html>