<html>
<head>
<title>Create a forEach Method for a Linked List in Swift — The “Easy” Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Swift 中为链表创建 forEach 方法——这是一种“简单”的方法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/create-a-foreach-method-for-a-linked-list-in-swift-the-easy-way-596262078287?source=collection_archive---------6-----------------------#2021-05-12">https://blog.devgenius.io/create-a-foreach-method-for-a-linked-list-in-swift-the-easy-way-596262078287?source=collection_archive---------6-----------------------#2021-05-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="b254" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">理解扩展和闭包</h2><div class=""/><div class=""><h2 id="7200" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">让我们用 forEach 方法扩展一个链表</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/ec8eb72b26a395f5ab81e155cb2119d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OTVzgUpw07DCl8HU_UD8UQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">名单，名单，到处都是名单</figcaption></figure><h1 id="f3b2" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">目标</h1><p id="cfc9" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">在链表中创建一个方法，我们可以用它来迭代链表，并传入代码来对每个位置做一些事情。</p><h1 id="f2a5" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">链接列表—简介</h1><p id="045d" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">根据<a class="ae ms" href="https://www.geeksforgeeks.org/data-structures/linked-list/" rel="noopener ugc nofollow" target="_blank">geeksforgeeks.com</a>:</p><blockquote class="mt mu mv"><p id="674a" class="lw lx mw ly b lz mx ka mb mc my kd me mz na mh mi nb nc ml mm nd ne mp mq mr ij bi translated">链表是一种线性数据结构，其中的元素不是存储在连续的内存位置。链表中的元素使用指针链接…</p></blockquote><p id="b313" class="pw-post-body-paragraph lw lx iq ly b lz mx ka mb mc my kd me mf na mh mi mj nc ml mm mn ne mp mq mr ij bi translated">换句话说，一个链表就像一个数组，但是它是使用随机存取(指针)存储的，而不是使用固定的内存块(连续的内存位置)。在集合的大小变化很大的情况下，链表非常有用，因为它不像数组那样需要连续的内存块来存储所有数据。</p><p id="a3fe" class="pw-post-body-paragraph lw lx iq ly b lz mx ka mb mc my kd me mf na mh mi mj nc ml mm mn ne mp mq mr ij bi translated">当数组的大小发生变化时，内存空间往往也会发生变化，这有时可能需要您的应用程序花一些时间来重新配置，以便数组适合某个位置。当一个链表改变时，指向下一个节点的指针也随之改变，这个节点可以存储在内存中的任何地方。</p><p id="c16a" class="pw-post-body-paragraph lw lx iq ly b lz mx ka mb mc my kd me mf na mh mi mj nc ml mm mn ne mp mq mr ij bi translated">在 LinkedList 中的每个节点，我们获得一个保存该节点值的<code class="fe nf ng nh ni b">value</code>属性和一个查看列表中下一个节点的<code class="fe nf ng nh ni b">next</code>属性。有时我们还会得到一个<code class="fe nf ng nh ni b">prev</code>属性来查看当前节点之前的节点。下一个属性是可选的，因为您可能位于列表的末尾。这是链表中的一个节点。稍后我们将扩展它来迭代整个<code class="fe nf ng nh ni b">LinkedList</code>:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nj nk l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nl"><img src="../Images/fe91710e0da067d4aee7125a6273ac4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oTZL3LFiApU71QmD.png"/></div></div></figure><p id="16cd" class="pw-post-body-paragraph lw lx iq ly b lz mx ka mb mc my kd me mf na mh mi mj nc ml mm mn ne mp mq mr ij bi translated">假设我们不能、不应该或不想修改原始类，我们可以扩展它以包含功能。所以让我们用一个叫做<code class="fe nf ng nh ni b">forEach</code>的方法来创建一个 LinkedList 的扩展。我们的方法还不需要接受任何参数——记住，我们关心的是从我们正在处理的任何节点到链表的末尾。</p><p id="11d7" class="pw-post-body-paragraph lw lx iq ly b lz mx ka mb mc my kd me mf na mh mi mj nc ml mm mn ne mp mq mr ij bi translated">从任何节点确定我们何时在列表的末尾比您想象的要简单。一开始理解起来可能有点困难，但是我们需要做的是查看当前节点的 next 属性，看看是否知道我们是否在列表的末尾。</p><p id="748a" class="pw-post-body-paragraph lw lx iq ly b lz mx ka mb mc my kd me mf na mh mi mj nc ml mm mn ne mp mq mr ij bi translated">为了实现这一点，我们将创建一个初始化为<code class="fe nf ng nh ni b">current</code>节点的变量。然后我们将创建一个 while 循环，这个循环一直持续到变量为<code class="fe nf ng nh ni b">nil</code>。在循环内部，我们将简单地打印出<code class="fe nf ng nh ni b">current</code>节点的值，并将<code class="fe nf ng nh ni b">current</code>节点设置为<code class="fe nf ng nh ni b">next</code>节点。当我们在最后一个节点时，这将使<code class="fe nf ng nh ni b">current</code>为零，这将停止我们的循环。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nj nk l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nl"><img src="../Images/fe91710e0da067d4aee7125a6273ac4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oTZL3LFiApU71QmD.png"/></div></div></figure><h2 id="4fa6" class="nm lf iq bd lg nn no dn lk np nq dp lo mf nr ns lq mj nt nu ls mn nv nw lu iw bi translated">就是这样！… 🤫</h2><p id="a7ec" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi">…</p><p id="11b7" class="pw-post-body-paragraph lw lx iq ly b lz mx ka mb mc my kd me mf na mh mi mj nc ml mm mn ne mp mq mr ij bi translated">好吧，我答应过我们可以运行一些代码，不是吗？</p><h1 id="ca01" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">使用闭包来运行我们的代码</h1><p id="34b9" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">我们可以给我们的方法传递一个闭包。这个闭包将在每个节点上运行我们的代码。当我们调用这个方法时，我们使用尾随闭包语法和<code class="fe nf ng nh ni b">someVariable in</code>,其中<code class="fe nf ng nh ni b">someVariable</code>是您想要命名每个位置的节点的名称。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="0174" class="pw-post-body-paragraph lw lx iq ly b lz mx ka mb mc my kd me mf na mh mi mj nc ml mm mn ne mp mq mr ij bi translated">现在，您可以简单地在任何节点上调用 forEach，并对该节点和列表中的每个剩余节点执行一些操作。如果您从头开始，那么您已经遍历了整个<code class="fe nf ng nh ni b">LinkedList</code>。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="6a43" class="pw-post-body-paragraph lw lx iq ly b lz mx ka mb mc my kd me mf na mh mi mj nc ml mm mn ne mp mq mr ij bi translated">我希望这篇文章教会你一些关于链表、闭包或扩展的知识。我很想在评论中听到你的意见！⏬</p></div></div>    
</body>
</html>