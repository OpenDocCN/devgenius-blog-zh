<html>
<head>
<title>Slack Clone with React | Semantic UI | GraphQL | PostgresSQL (PART 4)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有 React |语义 UI | GraphQL | PostgresSQL 的松弛克隆(第 4 部分)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/slack-clone-with-react-semantic-ui-graphql-postgressql-part-4-71bc8b99d060?source=collection_archive---------11-----------------------#2020-09-17">https://blog.devgenius.io/slack-clone-with-react-semantic-ui-graphql-postgressql-part-4-71bc8b99d060?source=collection_archive---------11-----------------------#2020-09-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="a28c" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">之前，我们启动了数据库。你可以在这里找到那篇<a class="ae kc" href="https://medium.com/dev-genius/slack-clone-with-react-semantic-ui-graphql-postgressql-part-3-f42515446c80" rel="noopener">文章。</a></h2></div><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi kd"><img src="../Images/20839c740b90ba944468979690f01820.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uD7SOi9GlEXE8_Nk"/></div></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk translated">沃洛季米尔·赫里先科在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="966d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">今天，我们将简要讨论 Graphql 查询和变异。</p><h1 id="9a8a" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">简单介绍一下 GraphQL API</h1><h1 id="51f6" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">类型:查询、突变、自定义</h1><p id="09ba" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">类型定义了你的端点是什么，并描述了它们应该返回什么。</p><p id="c3f0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">查询如下所示= &gt;</p><pre class="ke kf kg kh gt mn mo mp mq aw mr bi"><span id="3aa7" class="ms lq in mo b gy mt mu l mv mw">type Query {<br/>    getColors: [String]!<br/>    getNames: [String]<br/>    sayName: String!<br/>  }</span></pre><p id="78cd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">(例如:<code class="fe mx my mz mo b">getColors</code>需要返回一个字符串数组，这些字符串将是颜色名称)。感叹号表示项目不能为空。类型查询类别将是您的 GET 端点。</p><p id="2ec6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">突变是这样的= &gt;</p><pre class="ke kf kg kh gt mn mo mp mq aw mr bi"><span id="2db9" class="ms lq in mo b gy mt mu l mv mw">type Mutation {<br/>    sayHello(message: String!): String!<br/>  }</span></pre><p id="3a60" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">同样的规则也适用于突变。唯一的区别是，类型突变类别将是您的 POST、PUT、DELETE 端点。</p><p id="79a0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">自定义类型如下所示= &gt;</p><pre class="ke kf kg kh gt mn mo mp mq aw mr bi"><span id="98ea" class="ms lq in mo b gy mt mu l mv mw">type User {<br/>  name: String!<br/>  age: Int!<br/>  bio: String!<br/>}</span></pre><p id="7e73" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是一个常规的自定义对象，有 3 个属性描述它(<code class="fe mx my mz mo b">name, age, bio</code>)，您可以像 so = &gt;一样使用它</p><pre class="ke kf kg kh gt mn mo mp mq aw mr bi"><span id="2db3" class="ms lq in mo b gy mt mu l mv mw">type Query{<br/>/** returns array of users */<br/>  getUsers: [User!]<br/>  getUser: User!<br/>}</span><span id="bdd5" class="ms lq in mo b gy na mu l mv mw">type Mutation {<br/>/** creates a user, returns that user */<br/>  createUser: (name: String!, age: Int!, bio:String!): User<br/>}</span></pre><h1 id="3c28" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">解析器:查询和突变</h1><p id="48a4" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated"><em class="mm">解析器返回您在类型中描述的实际数据。您的查询和突变名称需要与您在</em> <code class="fe mx my mz mo b"><em class="mm">type query</em></code> <em class="mm">类别</em>中描述的名称相匹配</p><p id="d848" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">解析器中的查询如下所示= &gt;</p><pre class="ke kf kg kh gt mn mo mp mq aw mr bi"><span id="8879" class="ms lq in mo b gy mt mu l mv mw">Query: {<br/>  getColors: () =&gt; ["blue", "yellow", "green"],<br/>  sayName: () =&gt; "Ajea!"<br/>}</span></pre><p id="fc8a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">解析器中的突变看起来像这样= &gt;</p><pre class="ke kf kg kh gt mn mo mp mq aw mr bi"><span id="4632" class="ms lq in mo b gy mt mu l mv mw">/**args is whatever data you passed in (as an object), when you call this type. There are more params by default but we don't need them, thats way we use ```_,```*/ <br/>Mutation: {<br/>   sayHello: (_, args) =&gt; {<br/>      return `hello ${args.message}`<br/>   },<br/>   createUser: async (_, args) =&gt; {<br/>      try{<br/>        /** async code happens **/<br/>       /** create user with args data into DB, and then return  user*/<br/>      }catch(err){<br/>       console.log(err)<br/>      }<br/>  }<br/>}</span></pre><p id="999c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果所有这些仍然模糊不清，请不要担心，一旦我们在下一篇文章中创建了真正的查询和变化，就开始变得有意义了。在下一篇文章中，我们将创建它们，并在 Graphql 服务器中进行实际测试。我只是想回顾一下 GraphQL API 的概述。</p><p id="4dfc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">希望有所帮助，如果不放心让我知道: )</p></div></div>    
</body>
</html>