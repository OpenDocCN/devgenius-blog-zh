<html>
<head>
<title>Graph Modeling in PySpark using GraphFrames: Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 GraphFrames 在 PySpark 中进行图形建模:第 2 部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/graph-modeling-in-pyspark-using-graphframes-part-2-26645ccd4ae7?source=collection_archive---------4-----------------------#2022-09-17">https://blog.devgenius.io/graph-modeling-in-pyspark-using-graphframes-part-2-26645ccd4ae7?source=collection_archive---------4-----------------------#2022-09-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="cccd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是多部分教程的第 2 部分，我将演示如何在 GraphFrames 中找到主题。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/5085670b3098048d462e7559fe3fc8b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*RApkAbZGS4mq_8zB.png"/></div></figure><p id="485b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您还没有阅读本教程的第 1 部分，我强烈建议您在跳到这里之前先阅读第 1 部分。如果您对 graphframes 有所了解，可以跳过第 1 部分</p><p id="5ed6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae kq" href="https://sharmashorya1996.medium.com/graph-modeling-in-pyspark-using-graphframes-part-1-e7cb42099182" rel="noopener">https://sharmashorya 1996 . medium . com/graph-modeling-in-py spark-using-graph frames-part-1-e7cb 42099182</a></p><h2 id="6ab3" class="kr ks in bd kt ku kv dn kw kx ky dp kz jv la lb lc jz ld le lf kd lg lh li lj bi translated">什么是图案？</h2><p id="a785" class="pw-post-body-paragraph jk jl in jm b jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd lo kf kg kh ig bi translated">图形主题是具有明确结构的<strong class="jm io">小的连通子图</strong>。这些函数在图中搜索各种主题。在网络中多次出现的连通图称为网络的主题。</p><p id="f1f5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">简而言之，网络<strong class="jm io">主题</strong>是网络中反复出现的重要互联模式。这里，模式意味着它是一个小的诱导子图。</p><h2 id="2aa9" class="kr ks in bd kt ku kv dn kw kx ky dp kz jv la lb lc jz ld le lf kd lg lh li lj bi translated">在图形框架中寻找简单的主题</h2><p id="5850" class="pw-post-body-paragraph jk jl in jm b jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd lo kf kg kh ig bi translated">在本教程中，我们将模拟一个朋友的社交网络。因此，我们将在 6 个不同的个体之间定义不同类型的关系。</p><h2 id="798a" class="kr ks in bd kt ku kv dn kw kx ky dp kz jv la lb lc jz ld le lf kd lg lh li lj bi translated">让我们编码，</h2><pre class="kj kk kl km gt lp lq lr ls aw lt bi"><span id="8ada" class="kr ks in lq b gy lu lv l lw lx">import os<br/>import sys<br/>import glob<br/>from os.path import abspath<br/>os.environ['SPARK_HOME'] = 'C:\spark-3.1.2-bin-hadoop3.2'<br/>os.environ['JAVA_HOME'] = 'C:\Program Files\Java\jdk1.8.0_201'<br/>os.environ['HADOOP_HOME'] = 'C:\spark-3.1.2-bin-hadoop3.2'<br/>spark_python = os.path.join(os.environ.get('SPARK_HOME',None),'python')<br/>py4j = glob.glob(os.path.join(spark_python,'lib','py4j-*.zip'))[0]<br/>graphf = glob.glob(os.path.join(spark_python,'graphframes.zip'))[0]<br/>sys.path[:0]=[spark_python,py4j]<br/>sys.path[:0]=[spark_python,graphf]<br/>os.environ['PYTHONPATH']=py4j+os.pathsep+graphf<br/>import findspark<br/>findspark.init()<br/>findspark.find()<br/>from pyspark.sql import SparkSession<br/>spark = SparkSession.builder.appName("Spark Examples").enableHiveSupport().getOrCreate()<br/>from graphframes import *<br/>import networkx as nx<br/>import matplotlib.pyplot as plt</span></pre><p id="d664" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在顶点中，我们有关于这些个体的信息。</p><pre class="kj kk kl km gt lp lq lr ls aw lt bi"><span id="7bbd" class="kr ks in lq b gy lu lv l lw lx">vertices = spark.createDataFrame([("James", "Software Engineer"),<br/>                                 ("Mary", "Software Engineer"),<br/>                                 ("Roy", "Product Developer"),<br/>                                 ("Ryan", "HR"),<br/>                                 ("John", "Security"),<br/>                                 ("Robert", "Testing Engineer")], ["id", "Designation"])<br/>vertices.show()</span></pre><p id="57b5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来我们将定义连接顶点的边。</p><pre class="kj kk kl km gt lp lq lr ls aw lt bi"><span id="b0bd" class="kr ks in lq b gy lu lv l lw lx">edges = spark.createDataFrame([("James", "Mary", "colleagues"),<br/>                              ("Mary", "James", "colleagues"),<br/>                              ("Roy", "James", "friends"),<br/>                              ("James", "Roy", "friends"),<br/>                              ("Mary", "Roy", "neighbours"),<br/>                              ("Roy", "Mary", "neighbours"),<br/>                              ("Roy", "Ryan", "friends"),<br/>                              ("Ryan", "Roy", "friends"),<br/>                              ("James", "Ryan", "friends"),<br/>                              ("Ryan", "James", "friends"),<br/>                              ("John", "Roy", "friends"),<br/>                              ("Roy", "John", "friends"),<br/>                              ("Ryan", "John", "reportsto"),<br/>                              ("Robert", "John", "reportsto")],<br/>                             ["src", "dst", "type"])<br/>edges.show()</span></pre><p id="7644" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里我们假设所有的人都为同一家公司工作，他们之间的关系可以从纯粹的同事到朋友到邻居。但是，如果您注意到所有关系都是双向的，除了员工-经理关系(reportsto)。</p><p id="0bf5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们定义图形，并使用我们在以前的教程中使用的相同的函数来绘制有向图。</p><pre class="kj kk kl km gt lp lq lr ls aw lt bi"><span id="04dc" class="kr ks in lq b gy lu lv l lw lx">g = GraphFrame(vertices, edges)<br/># the function will plot the source and destination nodes and connect them by meand of undirected line<br/>def plot_directed_graph(edge_list):<br/>    plt.figure(figsize=(9,9))<br/>    gplot=nx.DiGraph()<br/>    edge_labels = {}<br/>    for row in edge_list.select("src", "dst", "type").take(1000):<br/>        gplot.add_edge(row["src"], row["dst"])<br/>        edge_labels[(row["src"], row["dst"])] = row["type"]<br/>    pos = nx.spring_layout(gplot)<br/>    nx.draw(gplot, pos, with_labels=True, font_weight="bold", node_size=3500)<br/>    nx.draw_networkx_edge_labels(gplot, pos, edge_labels=edge_labels, font_color="green", font_size=11, font_weight="bold")</span><span id="28fc" class="kr ks in lq b gy ly lv l lw lx">plot_directed_graph(g.edges)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/5da5111622ef4c9303871bd3c69309c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*KYdrhHASdkUmWT-LuZ7H7Q.png"/></div></figure><p id="edcd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">既然我们的图表已经设置好了，是时候让我们看看图表中的关系模式了。</p><p id="67e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">简单的图案，</p><pre class="kj kk kl km gt lp lq lr ls aw lt bi"><span id="0767" class="kr ks in lq b gy lu lv l lw lx">simple_motifs = g.find("(start_vertex)-[edge]-&gt;(end_vertex)")<br/>simple_motifs.show(truncate=False)<br/>simple_motifs.count()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/86b44e5e11da7576323dafd63fa82e62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*q7HwMVfTQ2x8lPGfu-bZhg.png"/></div></figure><p id="8fd8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在。我们可以访问节点的各个字段，也可以访问边。</p><pre class="kj kk kl km gt lp lq lr ls aw lt bi"><span id="44d0" class="kr ks in lq b gy lu lv l lw lx">filtered_motifs = g.find("(start_vertex)-[edge]-&gt;(end_vertex)").filter("edge.type='friends'")<br/>filtered_motifs.show(truncate=False)<br/>filtered_motifs.count()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/e04b548dbe36167c21e8c16169a06a34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*6DgBgz-ieFvLLqF3WbqHgQ.png"/></div></figure><p id="31b6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">复杂模式，</p><pre class="kj kk kl km gt lp lq lr ls aw lt bi"><span id="623a" class="kr ks in lq b gy lu lv l lw lx">filtered_motifs = g.find("(start_vertex)-[edge]-&gt;(end_vertex)")\<br/>                    .filter("start_vertex.id='Roy' AND edge.type='friends'")<br/>filtered_motifs.show(truncate=False)<br/>filtered_motifs.count()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/f29c0d9f8653f1a3894babf38170da7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*AIPOgXBeIzyBS8P8BUpKxQ.png"/></div></figure><p id="b073" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了得到更压缩的结果，</p><pre class="kj kk kl km gt lp lq lr ls aw lt bi"><span id="cc78" class="kr ks in lq b gy lu lv l lw lx">filtered_motifs.select("start_vertex.id", "edge.type", "end_vertex.id").show(truncate=False)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi md"><img src="../Images/105e25833b13bda795b76b6b0c641e0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:342/format:webp/1*iMG2lMnnEy-VuoRL5rrLVw.png"/></div></figure></div><div class="ab cl me mf hr mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ig ih ii ij ik"><p id="5768" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就把我们带到了第 2 部分的结尾，第 2 部分的代码可以在:</p><p id="8e19" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae kq" href="https://github.com/shorya1996/PySpark/blob/main/GettingStartedWithGraphFramesPart2.ipynb" rel="noopener ugc nofollow" target="_blank"><strong class="jm io">https://github . com/shorya 1996/PySpark/blob/main/gettingstartedwithgraphframespart 2 . ipynb</strong></a></p><p id="b382" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">在 Linkedin 上关注我</strong></p><p id="c5ab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">领英:</strong><a class="ae kq" href="https://www.linkedin.com/in/shorya-sharma-b94161121/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io">https://www.linkedin.com/in/shorya-sharma-b94161121/</strong></a></p></div></div>    
</body>
</html>