<html>
<head>
<title>Build a lighter and secure nodeJs docker image</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建一个更简单、更安全的节点 docker 映像</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/build-a-lighter-and-secure-nodejs-docker-image-3345f449e754?source=collection_archive---------3-----------------------#2022-04-10">https://blog.devgenius.io/build-a-lighter-and-secure-nodejs-docker-image-3345f449e754?source=collection_archive---------3-----------------------#2022-04-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="4468" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一个企业应用程序将是云原生的，并被数百万用户使用，我想构建一个更轻、更安全的 nodeJs docker 容器。</p><p id="39c0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">先决条件</strong></p><ol class=""><li id="531a" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated">关于 nodeJS 的一点知识</li></ol><p id="d35e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.一些码头工人的知识</p><p id="a54e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.机器中的 Docker 运行时间(如果是本地机器，则为 docker 桌面)</p><p id="4c49" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">4.NodeJS 已安装(使用 NVM 进行更好的控制【https://github.com/nvm-sh/nvm<a class="ae kr" href="https://github.com/nvm-sh/nvm" rel="noopener ugc nofollow" target="_blank"/></p><p id="e889" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">5.邮递员或同等的 rest 客户端</p><p id="2996" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">初始图像</strong></p><p id="dc1b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我在这个例子中使用的应用程序是一个简单的微服务 nodeJS 应用程序，但同样适用于任何 nodeJS 应用程序(NextJS 也是)</p><p id="39d3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最初我使用节点高山图像。在这个例子中，我使用的是 alpine(docker pull node:16 . 13 . 2-alpine 3.15)，但同样适用于任何版本的 nodeJS</p><ol class=""><li id="c175" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated">首先在 express JS 中创建一个简单的 nodeJS 服务器。在这个练习中，我创建了一个简单的 express 服务器，将一个待办事项添加到我的待办事项列表中。</li></ol><p id="b7fa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从下面的链接下载/克隆示例应用程序</p><p id="3728" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae kr" href="https://github.com/codedaemon12/nodejs-distroless.git" rel="noopener ugc nofollow" target="_blank">https://github.com/codedaemon12/nodejs-distroless.git</a></p><p id="5f1e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.创建完成后，添加一个 docker 文件作为 docker file 并放在线下</p><blockquote class="ks kt ku"><p id="b60b" class="jk jl kv jm b jn jo jp jq jr js jt ju kw jw jx jy kx ka kb kc ky ke kf kg kh ig bi translated"><em class="in">从节点:16.13.2-alpine3.15 作为基础</em></p><p id="ceff" class="jk jl kv jm b jn jo jp jq jr js jt ju kw jw jx jy kx ka kb kc ky ke kf kg kh ig bi translated"><em class="in">工作方向/基本方向</em></p><p id="5126" class="jk jl kv jm b jn jo jp jq jr js jt ju kw jw jx jy kx ka kb kc ky ke kf kg kh ig bi translated"><em class="in">复制 package.json。/ </em></p><p id="9c59" class="jk jl kv jm b jn jo jp jq jr js jt ju kw jw jx jy kx ka kb kc ky ke kf kg kh ig bi translated"><em class="in">运行 npm 安装</em></p><p id="d52b" class="jk jl kv jm b jn jo jp jq jr js jt ju kw jw jx jy kx ka kb kc ky ke kf kg kh ig bi translated"><em class="in">复制 src。/src </em></p><p id="4412" class="jk jl kv jm b jn jo jp jq jr js jt ju kw jw jx jy kx ka kb kc ky ke kf kg kh ig bi translated"><em class="in">曝光 8000 </em></p><p id="1a3b" class="jk jl kv jm b jn jo jp jq jr js jt ju kw jw jx jy kx ka kb kc ky ke kf kg kh ig bi translated"><em class="in"> CMD ["npm "，" start"] </em></p></blockquote><p id="96d6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.建立 docker 形象</p><blockquote class="ks kt ku"><p id="bd6a" class="jk jl kv jm b jn jo jp jq jr js jt ju kw jw jx jy kx ka kb kc ky ke kf kg kh ig bi translated">语法:docker build -t <image name="" with="" tag=""> <docker file="" path=""/></image></p><p id="39bb" class="jk jl kv jm b jn jo jp jq jr js jt ju kw jw jx jy kx ka kb kc ky ke kf kg kh ig bi translated">" docker build -t todoapp:v1 . "</p></blockquote><p id="2cf4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里 docker 文件路径是工作目录，所以在末尾点</p><p id="1abd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">4.这样，node JS 应用程序将使用来自 docker hub 的 alpine 映像进行构建</p><p id="d34d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">5.运行上面的 docker 映像构建。这里，我们在构建时将应用程序端口映射到 8000，在运行期间，我将端口连接到 3000</p><blockquote class="ks kt ku"><p id="467e" class="jk jl kv jm b jn jo jp jq jr js jt ju kw jw jx jy kx ka kb kc ky ke kf kg kh ig bi translated">docker run-d-p 3000:8000 todo app:v1</p></blockquote><p id="24a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">6.检查容器是否正在运行</p><blockquote class="ks kt ku"><p id="5bb8" class="jk jl kv jm b jn jo jp jq jr js jt ju kw jw jx jy kx ka kb kc ky ke kf kg kh ig bi translated">docker ps</p></blockquote><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi kz"><img src="../Images/6869f9089557d3ad386c2bc0e41dd2ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2QNJ7czo7r2a3w81zG8_qA.png"/></div></div></figure><p id="bf51" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">7.现在打开 postman 或任何 rest 工具，首先执行 get</p><p id="9713" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae kr" href="http://0.0.0.0:3000/getToDo" rel="noopener ugc nofollow" target="_blank">http://0 . 0 . 0 . 0:3000/getToDo</a></p><p id="9489" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它将返回一个空列表</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi ll"><img src="../Images/fd5b1dd1f5f4cbc5fae40330ccbb4d11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y5CY16IoTO0nTNEDDnT9dQ.png"/></div></div></figure><p id="e7a4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在在 postman 中打开另一个标签，选择 post。将待办事项添加到列表中</p><p id="2ec8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae kr" href="http://0.0.0.0:3000/addToDo" rel="noopener ugc nofollow" target="_blank">http://0 . 0 . 0 . 0:3000/add todo</a></p><blockquote class="ks kt ku"><p id="876f" class="jk jl kv jm b jn jo jp jq jr js jt ju kw jw jx jy kx ka kb kc ky ke kf kg kh ig bi">{</p><p id="d955" class="jk jl kv jm b jn jo jp jq jr js jt ju kw jw jx jy kx ka kb kc ky ke kf kg kh ig bi translated">" todo ":"买咖啡"</p><p id="73ca" class="jk jl kv jm b jn jo jp jq jr js jt ju kw jw jx jy kx ka kb kc ky ke kf kg kh ig bi">}</p></blockquote><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi lm"><img src="../Images/b5cf0f2c98e971ea5d6dcd0447350a25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k-AFEO2SdhVFyCwMX3ejTg.png"/></div></div></figure><p id="cdf8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Todo 将被添加并在响应中返回。</p><p id="51d3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">恭喜您，您的节点应用程序正在 docker 容器中运行。</p><p id="69ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以上步骤有助于创建 docker 映像，我们也可以将相同的映像应用于生产环境。</p><p id="c769" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们进入 docker 容器</p><p id="aa4e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为此，首先获取 docker 容器名</p><blockquote class="ks kt ku"><p id="ba37" class="jk jl kv jm b jn jo jp jq jr js jt ju kw jw jx jy kx ka kb kc ky ke kf kg kh ig bi translated">docker ps</p></blockquote><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi ln"><img src="../Images/fc49e5bc68498f477bfcf5d740ef9e01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zVdwi2WbTC25OUfqe15eGA.png"/></div></div></figure><p id="cebc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以使用 docker exec 命令对正在运行的容器运行任何命令。在我们的例子中，我们想进入容器内部，所以</p><p id="81ef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">语法:docker exec -it <container name=""> /bin/sh</container></p><blockquote class="ks kt ku"><p id="08d5" class="jk jl kv jm b jn jo jp jq jr js jt ju kw jw jx jy kx ka kb kc ky ke kf kg kh ig bi translated">docker exec-it heuristic _ hugle/bin/sh</p></blockquote><p id="cb30" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">或者列出工作目录中的文件</p><blockquote class="ks kt ku"><p id="6524" class="jk jl kv jm b jn jo jp jq jr js jt ju kw jw jx jy kx ka kb kc ky ke kf kg kh ig bi translated">docker exec-it heuristic _ hugle ls-la</p></blockquote><p id="40c3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们在集装箱里面。您可以运行命令 ls -la，它将列出我们在上面构建的应用程序</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi lo"><img src="../Images/8146830a0b2869d8ccbf8a5ba0b88bc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vyw_yXvrMZWSYngyJ3NzWA.png"/></div></div></figure><p id="ec9f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，有了这个，我们就可以进入正在运行的容器，进行任何操作。对于生产中的应用来说，这可能不是一个好主意。这是图片的发行版。</p><p id="bbaa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae kr" href="https://github.com/GoogleContainerTools/distroless" rel="noopener ugc nofollow" target="_blank">https://github.com/GoogleContainerTools/distroless</a></p><blockquote class="ks kt ku"><p id="0323" class="jk jl kv jm b jn jo jp jq jr js jt ju kw jw jx jy kx ka kb kc ky ke kf kg kh ig bi translated">“发行版”映像只包含您的应用程序及其运行时依赖项。它们不包含包管理器、shells 或任何其他您期望在标准 Linux 发行版中找到的程序。</p></blockquote><p id="97c2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">基本上，我们将改变我们的形象，以 distroless 版本，这将更加安全。</p><p id="e031" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将修改我们的 docker 文件如下。因为我们是在 docker 容器中构建我们的应用程序，所以我们需要安装一些依赖项。我们不能没有 shell，所以我们必须将 docker 构建步骤转换成两个阶段。</p><blockquote class="ks kt ku"><p id="463e" class="jk jl kv jm b jn jo jp jq jr js jt ju kw jw jx jy kx ka kb kc ky ke kf kg kh ig bi translated">#第一阶段</p><p id="47a9" class="jk jl kv jm b jn jo jp jq jr js jt ju kw jw jx jy kx ka kb kc ky ke kf kg kh ig bi translated">从节点:16.13.2-alpine3.15 作为基础</p><p id="a3c9" class="jk jl kv jm b jn jo jp jq jr js jt ju kw jw jx jy kx ka kb kc ky ke kf kg kh ig bi translated">工作目录/基本</p><p id="18fe" class="jk jl kv jm b jn jo jp jq jr js jt ju kw jw jx jy kx ka kb kc ky ke kf kg kh ig bi translated">复制 package.json。/</p><p id="40d0" class="jk jl kv jm b jn jo jp jq jr js jt ju kw jw jx jy kx ka kb kc ky ke kf kg kh ig bi translated">运行 npm 安装</p><p id="8f50" class="jk jl kv jm b jn jo jp jq jr js jt ju kw jw jx jy kx ka kb kc ky ke kf kg kh ig bi translated">#第二阶段</p><p id="5748" class="jk jl kv jm b jn jo jp jq jr js jt ju kw jw jx jy kx ka kb kc ky ke kf kg kh ig bi translated">来自 gcr.io/distroless/nodejs:16</p><p id="79ce" class="jk jl kv jm b jn jo jp jq jr js jt ju kw jw jx jy kx ka kb kc ky ke kf kg kh ig bi translated">工作目录/应用程序</p><p id="d790" class="jk jl kv jm b jn jo jp jq jr js jt ju kw jw jx jy kx ka kb kc ky ke kf kg kh ig bi translated">复制 src。/src</p><p id="16d2" class="jk jl kv jm b jn jo jp jq jr js jt ju kw jw jx jy kx ka kb kc ky ke kf kg kh ig bi translated">COPY-from = base/base/node _ modules。/节点 _ 模块</p><p id="3b98" class="jk jl kv jm b jn jo jp jq jr js jt ju kw jw jx jy kx ka kb kc ky ke kf kg kh ig bi translated">暴露 8000</p><p id="9d83" class="jk jl kv jm b jn jo jp jq jr js jt ju kw jw jx jy kx ka kb kc ky ke kf kg kh ig bi translated">CMD ["src/server.js"]</p></blockquote><p id="ddf0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们重新建造。让我们添加一个新标签作为 v2</p><blockquote class="ks kt ku"><p id="41ff" class="jk jl kv jm b jn jo jp jq jr js jt ju kw jw jx jy kx ka kb kc ky ke kf kg kh ig bi translated">" docker build -t todoapp:v2 . "</p></blockquote><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi lp"><img src="../Images/0447866656a926c881e5b1b263f251ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wU8mCXwcPzBs3XuVFCr7fg.png"/></div></div></figure><p id="a879" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，在不同的端口运行映像</p><blockquote class="ks kt ku"><p id="4b9c" class="jk jl kv jm b jn jo jp jq jr js jt ju kw jw jx jy kx ka kb kc ky ke kf kg kh ig bi translated">docker run-p 3001:8000-d todo app:v2</p></blockquote><p id="e120" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们在这个容器中再次运行我们的 exec 命令</p><p id="6559" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先获取容器名</p><blockquote class="ks kt ku"><p id="eb8e" class="jk jl kv jm b jn jo jp jq jr js jt ju kw jw jx jy kx ka kb kc ky ke kf kg kh ig bi translated">docker ps</p></blockquote><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi lq"><img src="../Images/087c8757d33861ec61e6ebf78de4a8de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZAPPZSId5OQ6eQIQ_UPQrw.png"/></div></div></figure><p id="87dd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在运行 exec 命令</p><blockquote class="ks kt ku"><p id="ab03" class="jk jl kv jm b jn jo jp jq jr js jt ju kw jw jx jy kx ka kb kc ky ke kf kg kh ig bi translated">docker exec-it quickical _ wes coff/bin/sh</p></blockquote><p id="64b1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它将返回如下错误</p><blockquote class="ks kt ku"><p id="b0fc" class="jk jl kv jm b jn jo jp jq jr js jt ju kw jw jx jy kx ka kb kc ky ke kf kg kh ig bi translated"><em class="in">“OCI 运行时 exec 失败:exec 失败:container_linux.go:380:启动容器进程导致:exec: "/bin/sh": stat /bin/sh:没有这样的文件或目录:未知”</em></p></blockquote><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi lr"><img src="../Images/21eb793645b1140448841e2b209438de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-eb1fvrQEu9tE_tQ1PBEOQ.png"/></div></div></figure><p id="abb9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以尝试其他类似命令</p><blockquote class="ks kt ku"><p id="33cd" class="jk jl kv jm b jn jo jp jq jr js jt ju kw jw jx jy kx ka kb kc ky ke kf kg kh ig bi translated">docker exec-it quickical _ wes coff ls-la</p></blockquote><p id="6897" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是我们会得到同样的错误。该命令在之前的图像中运行良好。</p><p id="20c2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以通过使用 distroless 镜像，我们去掉了外壳，从而增加了容器的安全性。Distroless 图像有更多的好处和细节可以在上面分享的链接中查看。</p><p id="a5ce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">分布式图像被广泛使用。我正在运行多个 java 和 go 应用程序，它们使用相同的发行版映像进行最终构建。</p><p id="2e3f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">多阶段构建技术还减少了图像大小，因为我们可以构建应用程序并只复制所需的文件。这在我们缩小/压缩文件时更有帮助。</p></div></div>    
</body>
</html>