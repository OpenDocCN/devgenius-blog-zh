<html>
<head>
<title>Go (Golang): Unit of Work and Generics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go (Golang):工作单位和仿制药</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/go-golang-unit-of-work-and-generics-5e9fb00ec996?source=collection_archive---------0-----------------------#2022-06-06">https://blog.devgenius.io/go-golang-unit-of-work-and-generics-5e9fb00ec996?source=collection_archive---------0-----------------------#2022-06-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/b47c70dacdb3f808ab4b6ed4da8bff32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*I1B-VwlhYb5sJMpS"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated"><a class="ae ja" href="https://unsplash.com/@max_duz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Max Duzij </a>在<a class="ae ja" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><div class=""/><p id="f06f" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是我之前关于跨多个存储库的事务的故事的延续，所以一定要查看它，以便阅读更多关于这个主题的内容:<a class="ae ja" rel="noopener ugc nofollow" target="_blank" href="/go-golang-clean-architecture-repositories-vs-transactions-9b3b7c953463"> Go (Golang):干净的架构&amp;存储库对比事务</a></p><p id="e3c9" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这也是 GitHub 回购的源代码:<a class="ae ja" href="https://github.com/rafael-piovesan/go-rocket-ride" rel="noopener ugc nofollow" target="_blank">https://github.com/rafael-piovesan/go-rocket-ride</a></p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="b4c7" class="lf lg jd bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">介绍</h1><p id="defa" class="pw-post-body-paragraph ka kb jd kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated"><a class="ae ja" rel="noopener ugc nofollow" target="_blank" href="/go-golang-clean-architecture-repositories-vs-transactions-9b3b7c953463">之前</a>中，我讨论了处理必须由多个存储库共享的数据库事务的不同方法。熟悉工作单元模式的人通常都知道这个问题，根据 Martin Fowler 的说法<a class="ae ja" href="https://martinfowler.com/eaaCatalog/unitOfWork.html" rel="noopener ugc nofollow" target="_blank"/>:</p><blockquote class="mi mj mk"><p id="20c1" class="ka kb ml kc b kd ke kf kg kh ki kj kk mm km kn ko mn kq kr ks mo ku kv kw kx ig bi translated">维护受业务事务影响的对象列表，并协调更改的写出和并发问题的解决。</p></blockquote><p id="00c3" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此外，这是一个非常普遍的模式。NET 和 Java+Hibernate 社区。所以，我在这里的重点不是引入任何新概念，而是提出一个如何在 Go (Golang)中实现它的实用方法。对于好奇的读者来说，关于它背后的理论有很好的来源(查看最后的参考资料)。话虽如此，我不会试图详细解释它，也不会宣扬它的优点和/或缺点，同时试图将其应用于现实世界的应用中。</p><p id="3571" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后一条信息，对于下面的代码示例，我正在使用<a class="ae ja" href="https://bun.uptrace.dev/" rel="noopener ugc nofollow" target="_blank"> Bun(一种 Golang ORM) </a>。确保检查它的文档，以防不太清楚。</p><h1 id="030a" class="lf lg jd bd lh li mp lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly mt ma mb mc bi translated">给我看看密码</h1><p id="3924" class="pw-post-body-paragraph ka kb jd kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">这是自我上一篇文章以来的第一个变化，术语(类型和变量被重命名，以直接引用工作单元模式)。这是我的队友们的一些很好的反馈和有价值的贡献后的结果(你会在这里看到的部分代码是他们的想法)。</p><figure class="mu mv mw mx gt ip"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="cafe" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里的要点是方法<code class="fe na nb nc nd b">Do(context.Context, UnitOfWorkBlock) error</code>如何创建一个新事务，将它传递给<code class="fe na nb nc nd b">UnitOfWorkStore</code>实例中的新存储库，最后，调用调用者代码提供的回调函数。</p><p id="d186" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe na nb nc nd b">UnitOfWorkStore</code>仅保存对存储库的引用，如下所示:</p><figure class="mu mv mw mx gt ip"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="f426" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，将模式付诸实践(<em class="ml">明白了吗？因为它是一个工作单元…是的，很蹩脚，对此表示抱歉</em>):</p><figure class="mu mv mw mx gt ip"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="ec7a" class="lf lg jd bd lh li mp lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly mt ma mb mc bi translated">太好了，但是它有什么新的吗？</h1><p id="352b" class="pw-post-body-paragraph ka kb jd kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">细心的读者可能已经意识到，除了重命名一些内容和简化部分代码之外，这个实现与我以前的文章基本相同。这是真的。自从 Go 1.18 发布以来，随着泛型的引入，主要的变化发生在存储库实现上(阅读更多:<a class="ae ja" href="https://go.dev/doc/tutorial/generics" rel="noopener ugc nofollow" target="_blank">https://go.dev/doc/tutorial/generics</a>)。这里有一个“之前与之后”的对比:</p><figure class="mu mv mw mx gt ip"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="6161" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好了，不同之处在于，<code class="fe na nb nc nd b">AuditRecord</code>接口现在是另一个接口<code class="fe na nb nc nd b">data.ICRUDStore</code>的组合，除此之外，后者是一个通用接口，而不是实现在数据库上持久化实体的实际过程。因此，当我们调用<code class="fe na nb nc nd b">NewAuditRecord(...)</code>时，我们得到的是<code class="fe na nb nc nd b">AuditRecord</code>的一个实例，而这个实例又是一个<code class="fe na nb nc nd b">data.ICRUDStore[entity.AuditRecord]</code>。</p><p id="d837" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不错！但是这能做什么呢？让我们来看看我们与由<code class="fe na nb nc nd b">data.New[T](...)</code>返回的类型相关联的实际实现:</p><figure class="mu mv mw mx gt ip"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="f082" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它的最大好处是简化了前面的代码，通过为所有的库提供一个单一的实现，并且仍然保持编译器检查我们传递给它们的方法的所有参数类型的安全性(当我们有一个接受类型<code class="fe na nb nc nd b">interface{}</code>的参数的函数时，这是主要的问题)。</p><p id="618a" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">回到前面的例子，只是为了强调所有东西是如何组合在一起的:</p><figure class="mu mv mw mx gt ip"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="9a5e" class="lf lg jd bd lh li mp lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly mt ma mb mc bi translated">结论</h1><p id="e55e" class="pw-post-body-paragraph ka kb jd kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">将我的代码的第一个版本与最新版本进行比较，我不认为这些变化是一个巨大的突破，但它们确实提高了可读性和简单性，这反过来有助于可维护性。尽管如此，玩泛型还是很有意思的，希望能启发人们寻找更多关于如何以及在哪里使用它们的例子。</p><h1 id="1053" class="lf lg jd bd lh li mp lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly mt ma mb mc bi translated">参考</h1><ol class=""><li id="d4c8" class="ne nf jd kc b kd md kh me kl ng kp nh kt ni kx nj nk nl nm bi translated"><a class="ae ja" href="https://github.com/rafael-piovesan/go-rocket-ride" rel="noopener ugc nofollow" target="_blank">本文 GitHub 资源库</a></li><li id="ac62" class="ne nf jd kc b kd nn kh no kl np kp nq kt nr kx nj nk nl nm bi translated"><a class="ae ja" href="https://www.martinfowler.com/eaaCatalog/" rel="noopener ugc nofollow" target="_blank">企业应用架构的模式</a></li><li id="8425" class="ne nf jd kc b kd nn kh no kl np kp nq kt nr kx nj nk nl nm bi translated"><a class="ae ja" href="https://docs.microsoft.com/en-us/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application" rel="noopener ugc nofollow" target="_blank">在 ASP.NET MVC 应用程序中实现存储库和工作单元模式</a></li><li id="9ab6" class="ne nf jd kc b kd nn kh no kl np kp nq kt nr kx nj nk nl nm bi translated"><a class="ae ja" href="https://go.dev/doc/tutorial/generics" rel="noopener ugc nofollow" target="_blank">教程:泛型入门</a></li></ol></div></div>    
</body>
</html>