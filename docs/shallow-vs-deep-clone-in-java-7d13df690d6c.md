# Java 中的浅层克隆与深层克隆

> 原文：<https://blog.devgenius.io/shallow-vs-deep-clone-in-java-7d13df690d6c?source=collection_archive---------5----------------------->

## Java 没有提供复制构造函数。那么有什么方法可以创建一个对象的副本呢？

对象应该以这样的方式复制，即新创建的复制对象和原始对象具有相同的数据成员和成员函数。这就是我们求助于 ***克隆()*** 的方法。

要克隆一个对象，任何类(这里是双胞胎)，让那个类实现可克隆的[标记接口。](https://www.baeldung.com/java-marker-interfaces)我们可以看到，在类演示中，类双胞胎的对象兄弟是从原始对象姐妹克隆而来的。并且对象兄弟具有与对象姐妹相同的成员函数。此外，对象兄弟已经复制了对象姐妹的所有数据成员，以及那些数据成员的值。

> **浅克隆**

当一个原始对象被克隆，并且该原始对象有一个 ***引用一个用户定义的类*** 。那么**引用将与克隆对象共享。**

这里对象 ***法国**类国家*** 被克隆成对象 ***德国*** 。对象 ***法国*** 保存变量 ***happinesIndexRank，povertyIndexRank*** 和， ***引用自定义类 UnitedNations 作为变量 un*** 。而对象法国和对象德国持有变量 happinesIndexRank 和 povertyIndexRank 的单独且排他的副本。这两个对象共享它们之间的参考 un。法国. un 和德国. un 指向联合国的同一个对象，因此法国. un 和德国. un 的 hashcode 是相同的。这意味着更改 france.un 对象的数据将反映在 germany.un 对象中，反之亦然。这被称为浅层克隆，在 Java 中这是默认发生的。

> **深度克隆**

浅层克隆可以通过对克隆方法进行少量更改来克服。深度克隆比浅层克隆略贵。

从对象法国克隆对象德国时，在克隆方法本身的变量 germany.un 中将类 UnitedNations 的新对象分配给对象德国。这就导致了深度克隆。原始对象法国和克隆对象德国看不同的对象类联合国。法国. un 和法国.德国的 hashcode 是不一样的。在任一个中所做的更改都不会反映在另一个中。