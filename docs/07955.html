<html>
<head>
<title>Why “this” gets undefined inside a function</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么“this”在函数中没有定义</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/why-this-gets-undefined-inside-a-function-d70a39b40d3b?source=collection_archive---------2-----------------------#2022-05-06">https://blog.devgenius.io/why-this-gets-undefined-inside-a-function-d70a39b40d3b?source=collection_archive---------2-----------------------#2022-05-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="0b5a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在进入“这个”关键词之前，我们先来了解一下“未定义”。</p><p id="9d57" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">简单来说，如果我们试图去理解，“<strong class="jm io"> undefined </strong>”就是一个值的缺席。它是原始数据类型之一。</p><p id="0d84" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">根据<a class="ae ki" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined" rel="noopener ugc nofollow" target="_blank"> MDN </a>的定义，</p><p id="773e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kj kk kl km b"><strong class="jm io">undefined</strong></code>是<em class="kn">全局对象</em>的属性。也就是说，它是全局范围内的变量。</p><p id="ce30" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">尚未赋值的变量属于类型<code class="fe kj kk kl km b">undefined</code>。如果被求值的变量没有赋值，方法或语句也会返回<code class="fe kj kk kl km b">undefined</code>。如果没有返回值，函数将返回<code class="fe kj kk kl km b">undefined</code>。</p><p id="c12c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们试着通过一个简单的例子来理解。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/08f9150390f36f8ff6df06569f320f8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6f8sNsNmuNWeHtiGdw3mhg.png"/></div></div></figure><p id="8218" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上述程序的输出如下。</p><blockquote class="la lb lc"><p id="dbb1" class="jk jl kn jm b jn jo jp jq jr js jt ju ld jw jx jy le ka kb kc lf ke kf kg kh ig bi translated">undefined 有朋友列表，那些<br/> undefined 有朋友列表，这些<br/> undefined 有朋友列表，那些<br/> undefined 有朋友列表，他们</p></blockquote><p id="f6c0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们试着一步一步地理解代码。</p><p id="f7cb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你看到,“unleashThis”是一个对象文字，它有两个属性和一个函数。</p><p id="e458" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看看 JS 引擎将如何执行上面的代码。</p><p id="d236" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">代码的第一行是在此时声明但没有赋值的变量。</p><p id="1ff7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意:请不要和“这个”混淆。我们还没有到达终点。</p><p id="c904" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">继续前进…</p><p id="2da4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在调用堆栈上，在全局执行上下文中，声明了“unleashThis”。</p><p id="f281" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">记住一点，如果你试图把函数赋给一个变量，它会把整个函数放到调用栈上。</p><p id="095e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意:当变量被放入调用栈时，它是未定义的，但是如果整个函数被放入调用栈。如果函数没有返回值，则返回 undefined。</p><p id="a684" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第 11 行将被放在调用堆栈中，在那里我们将调用 loopItNow。</p><p id="8a80" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，转折来了。</p><blockquote class="la lb lc"><p id="eca3" class="jk jl kn jm b jn jo jp jq jr js jt ju ld jw jx jy le ka kb kc lf ke kf kg kh ig bi translated"><strong class="jm io">记住，每当有函数调用时，就会创建一个新的执行上下文。</strong></p><p id="9108" class="jk jl kn jm b jn jo jp jq jr js jt ju ld jw jx jy le ka kb kc lf ke kf kg kh ig bi translated"><strong class="jm io">当调用一个函数时，创建一个激活记录，也称为执行上下文。该记录包含关于从哪里调用函数(调用栈)、如何调用函数、传递了什么参数等信息。</strong></p></blockquote><p id="1211" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当执行引擎到达第 5 行时,“this”值应该是什么？🤔</p><p id="0934" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">目前，已经创建了一个新的执行上下文，其中范围是对象的本地范围。原因是您必须看到从哪里调用了“this”关键字。</p><p id="f96e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">“this.friends”属于 unleashThis 对象的局部范围。所以，friends 数组的值将被放入其中。</p><p id="c748" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，执行的下一行将是第 6 行，我们试图将该值打印到控制台。</p><p id="9253" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">记住，当 JS 引擎看到“()”时，它会兴奋地创建一个新的执行上下文。</p><p id="a775" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您尝试可视化 JS 引擎执行代码。我们来看下图。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi lg"><img src="../Images/63aabb6a235726e645b21ffa7bc0401c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VN-6vr7t5FHK0WGNC1M5oQ.png"/></div></div></figure><p id="8da5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以，在第 6 行，当“this”试图在窗口范围内查找“name”时，没有找到，返回 undefined。</p><p id="ac6e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，下一个问题是，上述问题的可能解决方案是什么。</p><blockquote class="la lb lc"><p id="3614" class="jk jl kn jm b jn jo jp jq jr js jt ju ld jw jx jy le ka kb kc lf ke kf kg kh ig bi translated"><strong class="jm io">解决方案 1:在 loopItNow 函数内部使用 var self = this】</strong></p><p id="2293" class="jk jl kn jm b jn jo jp jq jr js jt ju ld jw jx jy le ka kb kc lf ke kf kg kh ig bi translated"><strong class="jm io">解决方案二:使用箭头= &gt;功能</strong></p><p id="8985" class="jk jl kn jm b jn jo jp jq jr js jt ju ld jw jx jy le ka kb kc lf ke kf kg kh ig bi translated"><strong class="jm io">解决方案 3:使用绑定方法</strong></p><p id="7500" class="jk jl kn jm b jn jo jp jq jr js jt ju ld jw jx jy le ka kb kc lf ke kf kg kh ig bi translated"><strong class="jm io">解决方案 4:将“this”关键字显式附加到匿名函数</strong></p></blockquote><p id="fede" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们试着一个一个去理解每一个解。</p><blockquote class="la lb lc"><p id="42c7" class="jk jl kn jm b jn jo jp jq jr js jt ju ld jw jx jy le ka kb kc lf ke kf kg kh ig bi translated"><strong class="jm io">方案一:使用 var self = this</strong></p></blockquote><p id="bedc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本"<strong class="jm io">var self =本；</strong>"是即使在大型企业应用程序中处理" this "上下文问题最常用的语句之一。</p><p id="8fa0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你认为这个声明在做什么？</p><p id="4632" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">实际上，当第 6 行开始执行时，loopItNow 上的一个“闭包”被创建来保存“self”对象，理解这一点会很有趣。“自我”对象现在拥有与“释放”对象相同的属性和功能。但是，唯一被创建的是被封闭的新的<strong class="jm io"> <em class="kn">词法环境</em> </strong> <em class="kn">。</em></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi lh"><img src="../Images/ab67db566529f4756a4572e0a6410aac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RsexuHJVTzUnX2LluFEPeQ.png"/></div></div><figcaption class="li lj gj gh gi lk ll bd b be z dk translated">使用 var self = this</figcaption></figure><p id="7b83" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您仔细观察代码，当开始执行循环时，它将外部变量和词法环境一起封装起来，这只不过是一个“闭包”。这可能有点难以理解，但它会得到超时。</p><blockquote class="la lb lc"><p id="313b" class="jk jl kn jm b jn jo jp jq jr js jt ju ld jw jx jy le ka kb kc lf ke kf kg kh ig bi translated"><strong class="jm io">解决方案 2:使用箭头功能</strong></p></blockquote><p id="c865" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如你所知，arrow(= &gt;)函数没有自己的“this”绑定。因此，当使用 arrow 函数时，不会有到“this”的新绑定，它将仍然使用来自 loopItNow 函数的绑定，该函数具有“unleashThis”对象的本地范围。</p><blockquote class="la lb lc"><p id="8a6f" class="jk jl kn jm b jn jo jp jq jr js jt ju ld jw jx jy le ka kb kc lf ke kf kg kh ig bi translated"><strong class="jm io"> Arrow 函数放弃了这个绑定的所有常规规则，取而代之的是它们的直接词法封闭范围的值。</strong></p><p id="6813" class="jk jl kn jm b jn jo jp jq jr js jt ju ld jw jx jy le ka kb kc lf ke kf kg kh ig bi translated"><strong class="jm io">箭头函数只是匿名的，没有命名。</strong></p></blockquote><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi lm"><img src="../Images/3bd06758668ee8d7aee7f78040a5a6a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kqokshv6VSBW7GH9T8jJew.png"/></div></div><figcaption class="li lj gj gh gi lk ll bd b be z dk translated">使用箭头= &gt;功能</figcaption></figure><blockquote class="la lb lc"><p id="4b7b" class="jk jl kn jm b jn jo jp jq jr js jt ju ld jw jx jy le ka kb kc lf ke kf kg kh ig bi translated"><strong class="jm io">解决方案 3:使用绑定功能</strong></p></blockquote><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ln"><img src="../Images/f92b8128ca352f032ebdd1e26980e63d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LrqWHKuqBrPO1kvhT-QqsA.png"/></div></div><figcaption class="li lj gj gh gi lk ll bd b be z dk translated">使用绑定方法</figcaption></figure><blockquote class="la lb lc"><p id="a4ae" class="jk jl kn jm b jn jo jp jq jr js jt ju ld jw jx jy le ka kb kc lf ke kf kg kh ig bi translated">注意:bind 方法返回一个函数。使用“绑定”方法</p></blockquote><p id="0b28" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当绑定函数被调用时，作为<code class="fe kj kk kl km b">this</code>参数传递给目标函数<code class="fe kj kk kl km b">func</code>的值。如果使用<strong class="jm io">新</strong>操作符构建绑定函数，则忽略该值。</p><p id="6409" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当使用<code class="fe kj kk kl km b">bind</code>在<code class="fe kj kk kl km b">setTimeout</code>中创建一个函数(作为回调函数提供)时，任何作为<code class="fe kj kk kl km b">this</code>传递的原始值都被转换成一个对象。如果没有参数提供给<code class="fe kj kk kl km b">bind</code>，或者如果<code class="fe kj kk kl km b">this</code>是<code class="fe kj kk kl km b">null</code>或<code class="fe kj kk kl km b">undefined</code>，则执行范围的<code class="fe kj kk kl km b">this</code>被视为新函数的<code class="fe kj kk kl km b">this</code>。</p><blockquote class="la lb lc"><p id="67d2" class="jk jl kn jm b jn jo jp jq jr js jt ju ld jw jx jy le ka kb kc lf ke kf kg kh ig bi translated"><strong class="jm io">解决方案 4:将“this”关键字显式附加到匿名函数上</strong></p></blockquote><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi lo"><img src="../Images/e6a77a4456602c7c68272f88fd95b716.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2cjGo5zTPUmHXD3vx9E3Sg.png"/></div></div><figcaption class="li lj gj gh gi lk ll bd b be z dk translated">使用回调作为参数“this”。</figcaption></figure><p id="512b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果看到上面的解决方案，for-each 方法将“this”作为回调，将“this”作为参数。</p><p id="5ed2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">“This”包含了从局部对象释放 this。</p><p id="bec2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">“this”关键字的几个关键属性。</strong></p><blockquote class="la lb lc"><p id="7695" class="jk jl kn jm b jn jo jp jq jr js jt ju ld jw jx jy le ka kb kc lf ke kf kg kh ig bi translated"><strong class="jm io">记住，这绝不是指函数的词法范围。确实，在内部，作用域有点像一个对象，每个可用的标识符都有属性。</strong></p><p id="225d" class="jk jl kn jm b jn jo jp jq jr js jt ju ld jw jx jy le ka kb kc lf ke kf kg kh ig bi translated"><strong class="jm io">这既不是对函数本身的引用，也不是对函数词法范围的引用。</strong></p><p id="7939" class="jk jl kn jm b jn jo jp jq jr js jt ju ld jw jx jy le ka kb kc lf ke kf kg kh ig bi translated"><strong class="jm io">这实际上是一个函数被调用时进行的绑定，它引用的内容完全由调用该函数的调用点决定。</strong></p></blockquote><p id="25fa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我希望，以上所有的解决方案可能会给你使用“这个”的想法。</p><p id="4534" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">快乐编码。不断学习。继续探索。😊</p></div></div>    
</body>
</html>