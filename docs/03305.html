<html>
<head>
<title>Best of Modern JavaScript — Modules in Browsers and Import/Export Relationship</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最佳现代 JavaScript——浏览器中的模块和导入/导出关系</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/best-of-modern-javascript-modules-in-browsers-and-import-export-relationship-d69ba6d7c96d?source=collection_archive---------4-----------------------#2020-10-21">https://blog.devgenius.io/best-of-modern-javascript-modules-in-browsers-and-import-export-relationship-d69ba6d7c96d?source=collection_archive---------4-----------------------#2020-10-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/74e05876258e3706374f7dd955dfbbec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1L-9QSA366RH4914"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@kaleidico?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">万花筒</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="3a96" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自 2015 年以来，JavaScript 有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解如何在浏览器中使用 JavaScript 模块，以及导出和导入之间的关系。</p><h1 id="71e6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">浏览器中的 ES6 模块</h1><p id="98a1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以在大多数现代浏览器中使用 ES6 模块。</p><p id="a7fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要使用它们，我们只需添加一个脚本标签，将<code class="fe me mf mg mh b">type</code>属性设置为<code class="fe me mf mg mh b">module</code>。</p><p id="d28c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">文件扩展名仍然是像楷书文件一样的<code class="fe me mf mg mh b">js</code>。</p><p id="40ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript 文件的内容通过 web 服务器传送。</p><p id="c89c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">浏览器中的 ES6 模块通过将语法 os 同步加载与底层异步加载相结合，方便地结合在一起。</p><p id="c20c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们没有 ES6 模块灵活。</p><p id="e1e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们只能在顶层加载，所以不能有条件。</p><p id="f51f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种限制让我们可以静态地分析模块，看看在执行之前其他模块导入了什么模块。</p><p id="370a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">常规脚本不能成为模块，因为它们是同步的。</p><p id="452b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不能以声明的方式导入模块，因为它们是一个接一个加载的，</p><p id="da91" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，添加了一种新类型的脚本，以便我们可以异步加载模块。</p><p id="8b6b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要在浏览器中导入模块，我们可以编写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2b01" class="mq lc iq mh b gy mr ms l mt mu">&lt;script type="module"&gt;<br/>  import _ from "https://unpkg.com/lodash-es";</span><span id="20e3" class="mq lc iq mh b gy mv ms l mt mu">  console.log(_.uniq([1, 2, 2, 3]));<br/>&lt;/script&gt;</span></pre><p id="5c91" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们导入了 Lodash 的 ES6 模块版本并使用了它的方法。</p><p id="73fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">type</code>属性被设置为<code class="fe me mf mg mh b">module</code>，这样我们就可以在脚本中导入模块。</p><p id="f7ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript 文件是模块还是脚本取决于代码的编写位置。</p><p id="8261" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们没有任何导出或导入，并且使用带有脚本标签的文件，而没有将<code class="fe me mf mg mh b">type</code>属性设置为<code class="fe me mf mg mh b">module</code>，那么它就是一个脚本。</p><p id="30d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则就是一个模块。</p><h1 id="3acf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">进口与出口的关系</h1><p id="b330" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">模块系统之间的导入与导出的关系不同。</p><p id="0a59" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 CommonJS 中，导入是导出值的副本。</p><p id="5428" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 ES6 模块中，导入是导出的只读视图，随着导出值的更新而更新。</p><p id="6191" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><p id="1a79" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">baz.js</code></p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8bb7" class="mq lc iq mh b gy mr ms l mt mu">module.exports = {<br/>  add(x, y) {<br/>    return x + y;<br/>  },<br/>  subtract(x, y) {<br/>    return x - y;<br/>  }<br/>};</span></pre><p id="2060" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过编写以下内容来导入它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="cfe1" class="mq lc iq mh b gy mr ms l mt mu">const { add, subtract } = require("./baz");</span><span id="7f71" class="mq lc iq mh b gy mv ms l mt mu">const sum = add(1, 2);<br/>const difference = subtract(1, 2);</span></pre><p id="71f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们需要一个 CommonJS 模块时，我们会制作一个模块的副本。</p><p id="948e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们将整个模块作为一个对象导入时，这也适用。</p><p id="2dfc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e26e" class="mq lc iq mh b gy mr ms l mt mu">const baz = require("./baz");</span><span id="2d26" class="mq lc iq mh b gy mv ms l mt mu">const sum = baz.add(1, 2);<br/>const difference = baz.subtract(1, 2);</span></pre><p id="5640" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe me mf mg mh b">baz</code>就是<code class="fe me mf mg mh b">baz.js</code>模块的副本。</p><p id="3c88" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，ES6 模块导入并对导出的值进行只读查看。</p><p id="d126" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">导入实时连接到导出的数据。</p><p id="669c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们导入整个模块，那么整个导入的模块就像一个冻结的对象。</p><p id="1cd9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><p id="9a44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">baz.js</code></p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5c6b" class="mq lc iq mh b gy mr ms l mt mu">export const add = (x, y) =&gt; {<br/>  return x + y;<br/>};</span><span id="44cc" class="mq lc iq mh b gy mv ms l mt mu">export const subtract = (x, y) =&gt; {<br/>  return x - y;<br/>};</span></pre><p id="3033" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">foo.js</code></p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7a89" class="mq lc iq mh b gy mr ms l mt mu">import { add, subtract } from "./baz";</span><span id="82b0" class="mq lc iq mh b gy mv ms l mt mu">const sum = add(1, 2);<br/>const difference = subtract(1, 2);</span></pre><p id="af41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">add</code>和<code class="fe me mf mg mh b">subtract</code>是只读的。</p><p id="41b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们试图将一个导入的成员重新分配给某个东西，我们会得到一个错误。</p><p id="2bec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果导入整个模块，我们会得到相同的结果:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="673a" class="mq lc iq mh b gy mr ms l mt mu">import * as baz from "./baz";</span><span id="d93c" class="mq lc iq mh b gy mv ms l mt mu">const sum = baz.add(1, 2);<br/>const difference = baz.subtract(1, 2);</span></pre><p id="e506" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不能给<code class="fe me mf mg mh b">baz</code>赋值。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/a1a36eb8cf6929a339fd7eefb7140a2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IdQFrzgNOLLwId1n"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">塞尔吉奥·阿尔维斯·桑托斯在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="71c0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="0b00" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">ES6 模块导入是导出的只读视图。</p><p id="bb50" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以在浏览器中使用模块。</p></div></div>    
</body>
</html>