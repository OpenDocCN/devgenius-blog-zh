<html>
<head>
<title>How to Solve the Multi-Armed Bandit Problem: Epsilon-Greedy Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何解决多臂强盗问题:ε-贪婪算法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-solve-the-multi-armed-bandit-problem-epsilon-greedy-approach-ebe286390578?source=collection_archive---------0-----------------------#2022-06-17">https://blog.devgenius.io/how-to-solve-the-multi-armed-bandit-problem-epsilon-greedy-approach-ebe286390578?source=collection_archive---------0-----------------------#2022-06-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="5d5b" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">包括代码解释和模拟结果！</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/7596ec871411813459e7b73850b3c0d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MryRvyie1vUB0rNb"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">卡尔·劳在<a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="7ccf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi lp translated">让我们从离开的地方继续。我在之前的帖子中已经解释了<em class="ly">探索-利用困境</em>和<em class="ly">多臂强盗问题</em>。本文就是建立在这个基础上的，所以，考虑先浏览一下(如果你不熟悉这些术语的话)。</p><div class="lz ma gp gr mb mc"><a rel="noopener  ugc nofollow" target="_blank" href="/understanding-the-explore-exploit-dilemma-a-visual-approach-839f437c1cff"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd io gy z fp mh fr fs mi fu fw im bi translated">探索-利用困境:一种视觉方法！</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">强化学习和贝叶斯统计交叉的经典问题</h3></div><div class="mk l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">blog.devgenius.io</p></div></div><div class="ml l"><div class="mm l mn mo mp ml mq km mc"/></div></div></a></div><p id="c830" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这一篇中，我将解释ε-贪婪算法以及它如何帮助解决探索-利用困境。</p><p id="fb75" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我将通过分解我下面提供的模拟代码来进行解释。我们将根据组件的用途和最终结果对其进行检查。</p><p id="5453" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以，让我们深入研究一下。</p></div><div class="ab cl mr ms hr mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ig ih ii ij ik"><h1 id="057b" class="my mz in bd na nb nc nd ne nf ng nh ni jt nj ju nk jw nl jx nm jz nn ka no np bi translated">ε-贪婪实现代码</h1><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nq nr l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">ε贪婪实现代码</figcaption></figure><h2 id="3712" class="ns mz in bd na nt nu dn ne nv nw dp ni lc nx ny nk lg nz oa nm lk ob oc no od bi translated">模拟的结果</h2><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oe"><img src="../Images/4c1c5956f2f5fff886a05260479fe56c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_I741rrVPsUhybZ8j0advA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">结果快照 1</figcaption></figure><p id="9264" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">绿色和橙色线条分别代表考虑中的盗匪的个人胜率，<em class="ly"> 50% </em> &amp; <em class="ly"> 25% </em>。</p><p id="842b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">模拟期间的总体胜率用蓝线表示。</p><p id="6db1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">请注意，在最初的波动之后，整体赢率开始向给定强盗池的最高可能赢率靠拢。也就是达到了获得最大回报的目的。</p><p id="e717" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最初的波动是由于模型的观察值越多，它在估计整体胜率时就越有信心。正如你从下面的一些其他结果中看到的，最初的波动对所有人来说都是常见的。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oe"><img src="../Images/8c9b3767aeab95ed8783b41ad108ff8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t8XbSzFfrbohcUDNUOzd5Q.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">结果快照 2</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oe"><img src="../Images/e47ee0210f06780b8f36dc6cfabd8112.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VTnFopWiX94fpeu_J6xmxw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">结果快照 3</figcaption></figure><blockquote class="of og oh"><p id="2403" class="kt ku ly kv b kw kx jo ky kz la jr lb oi ld le lf oj lh li lj ok ll lm ln lo ig bi translated">请注意，尽管 Epsilon-Greedy 是一种很好的方法，但它不是 100%安全的。在某些情况下，当模拟中的试运行次数很少时，模型可能会收敛到次优胜率，但一旦您运行模拟足够长的时间，这些情况将可以忽略不计。</p><p id="4a2d" class="kt ku ly kv b kw kx jo ky kz la jr lb oi ld le lf oj lh li lj ok ll lm ln lo ig bi translated">此外，如果你想让总体回报尽可能接近最高值(在上述场景中为 50%)，在这种情况下可以使用衰减ε。</p><p id="700a" class="kt ku ly kv b kw kx jo ky kz la jr lb oi ld le lf oj lh li lj ok ll lm ln lo ig bi translated"><strong class="kv io">衰减的ε与迭代的时间或次数成反比。实际意义在于，模型的探索因子随着模拟的每次迭代而不断减小，从而更经常地选择最佳 bandit。</strong></p></blockquote></div><div class="ab cl mr ms hr mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ig ih ii ij ik"><h1 id="abcb" class="my mz in bd na nb nc nd ne nf ng nh ni jt nj ju nk jw nl jx nm jz nn ka no np bi translated">模拟代码的分解</h1><p id="2e73" class="pw-post-body-paragraph kt ku in kv b kw ol jo ky kz om jr lb lc on le lf lg oo li lj lk op lm ln lo ig bi translated">从导入所需的库和初始化模拟的超参数开始。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="c2ce" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">即:</p><ul class=""><li id="6737" class="oq or in kv b kw kx kz la lc os lg ot lk ou lo ov ow ox oy bi translated"><code class="fe oz pa pb pc b">NUM_TRIALS</code>模拟将执行的试验次数</li><li id="6673" class="oq or in kv b kw pd kz pe lc pf lg pg lk ph lo ov ow ox oy bi translated"><code class="fe oz pa pb pc b">EPS</code>探索因子(模型探索了多少而不是探索了多少)。一个<strong class="kv io">0.1</strong>ε值意味着模型将探索 10%的时间而不是利用。常用的数值是 5%到 10%。</li><li id="4c4a" class="oq or in kv b kw pd kz pe lc pf lg pg lk ph lo ov ow ox oy bi translated"><code class="fe oz pa pb pc b">BANDIT_PROBS</code>盗匪的实际胜率(模型未知)</li></ul><p id="b260" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">举个更实际的例子:</p><ul class=""><li id="3317" class="oq or in kv b kw kx kz la lc os lg ot lk ou lo ov ow ox oy bi translated">游戏者有两台老虎机，实际赢率分别为 25%和 50%。</li><li id="5fdf" class="oq or in kv b kw pd kz pe lc pf lg pg lk ph lo ov ow ox oy bi translated">探索因素表示，如果游戏者玩 100 次，则 10%的次数，他们将探索其他吃角子老虎机，而不是简单地玩直到该时间点的最高估计胜率的一个。</li></ul></div><div class="ab cl mr ms hr mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ig ih ii ij ik"><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="6c47" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后声明模拟函数，并且在该函数中，模拟之前投币机的初始胜率估计值被设置为 0，因为模拟还没有开始。</p><p id="df0c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">此外，还声明了一些变量来记录模型决策和模拟过程中获得的奖励。</p><p id="4a38" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">还记录了最佳 bandit，以检查模型在模拟过程中选择该 bandit 的次数。记住，最终目标是最大化模型选择最优的次数。</p></div><div class="ab cl mr ms hr mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ig ih ii ij ik"><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="af23" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后我们就有了决定模型是否要进行探索的组件。</p><p id="9ac7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">通过将ε值与<code class="fe oz pa pb pc b">np.random.random</code>函数进行比较来做出决定，该函数从均匀分布的范围[0.0，1.0]中返回一个浮点整数。</p><blockquote class="of og oh"><p id="8f48" class="kt ku ly kv b kw kx jo ky kz la jr lb oi ld le lf oj lh li lj ok ll lm ln lo ig bi translated">为了简化理解，我们假设<code class="fe oz pa pb pc b">np.random.random</code>从<strong class="kv io">均匀分布的范围【1100】</strong>中返回一个整数。也就是说，该范围内的每个整数被选中的概率相等。</p><p id="27c2" class="kt ku ly kv b kw kx jo ky kz la jr lb oi ld le lf oj lh li lj ok ll lm ln lo ig bi translated">现在，如果探索因子是 0.1 (10%)，那么如果<code class="fe oz pa pb pc b">np.random.random</code>返回[1，10]之间的值，模型将进行探索，因为发生这种情况的概率是 10%</p></blockquote><p id="9499" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果是，则记录除了具有最高胜率估计值的盗匪之外的那些盗匪的指数，并通过<code class="fe oz pa pb pc b">np.random.choice</code>功能随机选择其中一个进行探索。</p></div><div class="ab cl mr ms hr mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ig ih ii ij ik"><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="5687" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">接下来，是利用场景组件，它只选择到那时为止胜率估计最高的强盗。</p><p id="cf84" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">注意<code class="fe oz pa pb pc b">np.random.choice</code>功能用于有两个胜率最高的强盗的情况。在这种情况下，我们只是从两个中随机选择一个。然而，如果只有一个胜率最高的强盗，那么<code class="fe oz pa pb pc b">np.random.choice</code>函数将返回那个强盗。</p></div><div class="ab cl mr ms hr mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ig ih ii ij ik"><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="6e1b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后，一旦一个强盗被选中，就要检查它是否是最佳的。此步骤仅用于记录模拟结果。</p><p id="7b8f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后拉匪臂看我们拿不拿奖励。注意，这里使用了<code class="fe oz pa pb pc b">np.random.random </code>功能，并且应用了与之前相同的逻辑。唯一不同的是，这里我们检查的是玩家是否从选择的强盗那里得到了奖励，而不是探索因素。</p><p id="66e6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">之后，根据上一步获得的奖励计算新的平均胜率估计值。</p><p id="58a3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">用于计算平均胜率估计值的方法如下:</p><p id="f412" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">假设你有四个整数<strong class="kv io"> 2，4，1，7 </strong>。平均值将达到 3.5 T4。<br/>现在，我们假设您向该组添加了另一个整数<strong class="kv io"> 6 </strong>。你可以相加得到新的平均值<strong class="kv io"> 4。</strong></p><p id="f2a2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">或者你可以得到新的数字<strong class="kv io"> (6) </strong>和以前的平均值<strong class="kv io"> (3.5) </strong>之差，即<strong class="kv io">(6–3.5 =</strong><strong class="kv io">2.5)</strong>，然后将其平均分配到整个组中，即<strong class="kv io"> (2.5/5 = 0.5) </strong>，平均值加起来就是<strong class="kv io"> (3.5+0.5 = 4) </strong></p><blockquote class="of og oh"><p id="9fb3" class="kt ku ly kv b kw kx jo ky kz la jr lb oi ld le lf oj lh li lj ok ll lm ln lo ig bi translated">为什么选择第二种方法？<strong class="kv io">这使我们能够计算恒定时间和空间中的平均值</strong>，因为我们没有像第一种方法那样存储数字，而只是存储以前的平均值。</p></blockquote><p id="b5ae" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">除此之外，其余组件用于绘制结果，并且仅用于可视化目的。所以，它们是自明的。</p></div><div class="ab cl mr ms hr mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ig ih ii ij ik"><h1 id="af5e" class="my mz in bd na nb nc nd ne nf ng nh ni jt nj ju nk jw nl jx nm jz nn ka no np bi translated">感谢阅读！</h1><p id="eca0" class="pw-post-body-paragraph kt ku in kv b kw ol jo ky kz om jr lb lc on le lf lg oo li lj lk op lm ln lo ig bi translated">这给了我很大的鼓励！😃<em class="ly">如果你觉得这个帖子很有意思，想要更多，可以考虑</em> <a class="ae ks" href="https://medium.com/subscribe/@pratik.pandav" rel="noopener"> <strong class="kv io"> <em class="ly">关注我</em></strong></a><strong class="kv io"><em class="ly"/></strong>🥁<em class="ly">。我每周发布与机器学习、统计和数据分析相关的主题。我喜欢通过可视化来学习，因此，我的帖子包含了大量的图表、模拟和代码示例。</em></p><p id="fa03" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">简要说明一下，我尽力把错误降到最低，但它们是我们学习的一部分，所以，如果你发现什么，请指出来。最后，请随意提出你希望我写的主题。</p></div></div>    
</body>
</html>