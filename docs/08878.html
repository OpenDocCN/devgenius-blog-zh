<html>
<head>
<title>Best practices for Microservices / Web Application Developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务/ Web 应用程序开发人员的最佳实践</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/best-practices-for-microservices-web-application-developers-f17bf56a1a5a?source=collection_archive---------5-----------------------#2022-07-16">https://blog.devgenius.io/best-practices-for-microservices-web-application-developers-f17bf56a1a5a?source=collection_archive---------5-----------------------#2022-07-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/5f6ed0ee37ffb3e9f74025d98f2d06db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oYvKk9q1Hv78PoHLP9Jn0Q.png"/></div></div></figure><p id="7ab9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们深入了解一些最佳实践。这些最佳实践将指导您创建一个易于操作的安全系统。</p><h1 id="2bcf" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">设计</h1><ul class=""><li id="43e8" class="lr ls in jx b jy lt kc lu kg lv kk lw ko lx ks ly lz ma mb bi translated">设计应该是领域驱动的。</li><li id="bbab" class="lr ls in jx b jy mc kc md kg me kk mf ko mg ks ly lz ma mb bi translated">尽可能去做一个新的设计。如果你的服务中有一些与你的服务无关的东西，那就全部去掉。因此，在这种情况下，我们不需要重新设计一切，但我们可以隔离，然后使我们的服务独立。</li></ul><h1 id="d7c4" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">硬编码值</h1><ul class=""><li id="8dba" class="lr ls in jx b jy lt kc lu kg lv kk lw ko lx ks ly lz ma mb bi translated">让我们假设两个服务 A 和 B。现在 A 正在调用 B。因此 A 有服务 B 的地址。在这种情况下，大多数开发人员对此进行硬编码。(可能是服务上的主机名/IP 地址)。现在服务 a 知道服务 B 在哪里。</li><li id="6a92" class="lr ls in jx b jy mc kc md kg me kk mf ko mg ks ly lz ma mb bi translated">问题出现在…</li></ul><blockquote class="mh mi mj"><p id="80f1" class="jv jw mk jx b jy jz ka kb kc kd ke kf ml kh ki kj mm kl km kn mn kp kq kr ks ig bi translated">如果网络团队决定改变主机或他们决定改变网络地址。因为我们必须发送其他部署/需要改变代码，并在部署过程中做同样的事情。许多艰苦的工作..</p></blockquote><ul class=""><li id="46a2" class="lr ls in jx b jy jz kc kd kg mo kk mp ko mq ks ly lz ma mb bi translated">为了避免这种情况，我们可以使用服务发现机制来发现第二个服务。(服务 B)</li></ul><h1 id="faad" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">记录</h1><ul class=""><li id="37a7" class="lr ls in jx b jy lt kc lu kg lv kk lw ko lx ks ly lz ma mb bi translated">由于没有在第一时间恢复问题，可能会出现相同错误记录两次的情况。最佳实践是，如果出现故障，立即返回，但不要记录日志。</li><li id="dd5e" class="lr ls in jx b jy mc kc md kg me kk mf ko mg ks ly lz ma mb bi translated">我们必须记录堆栈跟踪以了解问题的部分。(地点详情)</li></ul><p id="a7b2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们想一个场景。假设你收到一个分配 X 辆车给 Y 个客户的请求，那么在你把这个请求发送给你的服务层之前，你可以生成一个 ID。假设是 001。(为了更好地理解流程，它将被标记为服务启动)。为此，我们可以使用日志附加器。</p><ul class=""><li id="fff7" class="lr ls in jx b jy jz kc kd kg mo kk mp ko mq ks ly lz ma mb bi translated">请确保将调试警告错误信息记录在单独的类别和级别中，这样才有意义。(单独类别中的 log-debug-warn-error-info)。因此，当问题出现时，我们可以很容易地检查每个部分。</li></ul><h1 id="0de4" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">版本控制</h1><ul class=""><li id="9ae1" class="lr ls in jx b jy lt kc lu kg lv kk lw ko lx ks ly lz ma mb bi translated"><strong class="jx io">语义版本化</strong>:是根据变更的严重程度分配版本号的实践。比如 v1。与 v1 相比，0.1 将只有很小的补丁。0.0 ;v1。</li><li id="b562" class="lr ls in jx b jy mc kc md kg me kk mf ko mg ks ly lz ma mb bi translated"><strong class="jx io">强制升级</strong>:让我们用一个场景来明确这个概念。以两个服务 A 和 B 为例。A 将调用服务 B。因此我们必须更新服务 B。因此在更新期间，我们必须更改数据库结构，以便服务结构会有所不同。所以当我们推这个新版本的服务 B 的时候，服务 A 就坏了。</li></ul><p id="3292" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">解决方案</strong>:增加一个主版本号，并将其部署为一个单独的服务。现在你有一个 B 服务版本 1.00 和 B 服务版本 2.00。因此我们的流量仍然采取 1.00 版本。所以我们需要通知消费者，通知功能必须更新到此功能。因此，所有消费者都将迁移到 2.00 版本。</p><h1 id="2a80" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">授权和认证机制</h1><ul class=""><li id="c818" class="lr ls in jx b jy lt kc lu kg lv kk lw ko lx ks ly lz ma mb bi translated">如果您的每个服务都试图验证用户，那么它会增加更多的延迟。</li></ul><p id="e73b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">解决方案:创建一个</strong>独立的身份验证服务，当请求到达服务层时，它可以指向这个身份服务，如果成功，它可以指向相关的路径。在这里，我们已经强行转发到了特定的服务。在这种情况下，我们可以避免一些延迟，当然，在任何给定的时间，您都可以根据我们的要求更改验证过程或认证授权过程。</p><h1 id="0aba" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">属国</h1><ul class=""><li id="2126" class="lr ls in jx b jy lt kc lu kg lv kk lw ko lx ks ly lz ma mb bi translated">我们应该避免对我们服务的任何依赖。假设有 3 个服务 A、B、C，我们应该能够分别部署 A 或 B 或 C，而不用担心破坏其他服务。</li></ul><h1 id="4d59" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">容错</h1><ul class=""><li id="d491" class="lr ls in jx b jy lt kc lu kg lv kk lw ko lx ks ly lz ma mb bi translated">由于存在多种服务，因此可能存在多种故障可能性。因此，在这种情况下，强烈建议拥有一个强大的容错机制，以避免排队并缩短故障时刻的响应时间。</li></ul><h1 id="ade7" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">证明文件</h1><ul class=""><li id="e09c" class="lr ls in jx b jy lt kc lu kg lv kk lw ko lx ks ly lz ma mb bi translated">有必要用一种技术性的方式来写文档，并以更好的理解来吸引文档。因此，消费者可以查看这些文档并尝试一些服务。</li></ul><p id="ad0d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">参考:</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure></div></div>    
</body>
</html>