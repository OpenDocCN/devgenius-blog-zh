<html>
<head>
<title>Persistent Connections in HTTP/1.1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">HTTP/1.1中的持久连接</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/persistent-connections-in-http-1-1-45c3bc1c7c87?source=collection_archive---------1-----------------------#2020-04-01">https://blog.devgenius.io/persistent-connections-in-http-1-1-45c3bc1c7c87?source=collection_archive---------1-----------------------#2020-04-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/aca56da540e9f316e3f2bb889e11c8a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fcheigPTDbRFDoYuftwnbQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">连接头</figcaption></figure><p id="006b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">HTTP(超文本传输协议)是建立在传输层协议TCP(传输控制协议)之上的应用层协议。简而言之，HTTP是在TCP之上完成的通信。</p><p id="b991" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在HTTP的第一个版本HTTP 1.0中，客户端打开一个TCP连接向服务器发出HTTP请求。一旦请求通过用于关闭TCP连接的服务器。但是有一个问题…对于每个HTTP连接，服务器必须启动一个新的TCP连接。HTTP 1.0服务器可以避免这种情况的一种方法是使用<strong class="kb io">保持活动连接</strong>。</p><h1 id="f78e" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">保持活动连接</h1><p id="b0ed" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">  <strong class="kb io"> <em class="ma">站点位置</em> </strong>的<em class="ma"> </em> <strong class="kb io"> <em class="ma">属性声明<em class="ma">向服务器发起HTTP请求的应用程序很可能在将来发出更多请求</em>。因此，如果服务器收到请求，很可能会向它发出进一步的请求。所以理想情况下，它应该准备好接受更多的请求。但是，在HTTP 1.0中，必须非常频繁地为每个请求重新建立连接，这是低效的。</em></strong></p><p id="37a3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">事实证明，打开和关闭TCP连接的过程开销很大。为了克服这个问题，HTTP/1.0试图通过在HTTP请求中引入<em class="ma">连接</em>头来重用连接。如果请求中的<em class="ma">连接</em>头的值被设置为<em class="ma"> Keep-Alive </em>，则服务器不会在HTTP请求完成后立即关闭连接，而是会在同一TCP连接上等待客户端的下一个请求一段时间。它还将通过在<strong class="kb io"> <em class="ma">响应</em> </strong> <strong class="kb io"> <em class="ma">报头</em> </strong>中用<em class="ma">连接</em>值作为<em class="ma">保持活动</em>来通知客户端它对进一步的请求开放。因此，客户机和服务器可以节省为连续的http请求创建新的TCP连接的时间。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/5edc65886300a517cc72f606c98c7f6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*pUbpaVZN52hrEwZweq5Rtw.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">连接头</figcaption></figure><p id="a716" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">另一方面，如果服务器碰巧不支持保活连接，它会关闭TCP连接，并且不会在响应中的<em class="ma">连接</em>报头中返回。响应头中没有<em class="ma">连接</em>表示客户端关闭连接，并且不期望服务器对之前的连接做出任何响应。</p><p id="ea9c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这对于服务器到客户端的直接通信来说很好。但是当通信通过代理服务器路由时，情况就不同了。</p><h1 id="d60d" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">盲中继代理</h1><p id="ca94" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated"><em class="ma">连接</em>头似乎已经解决了连续请求的问题，直到请求通过盲中继代理服务器被中继。顾名思义，盲中继代理服务器将整个请求从客户端中继到服务器，包括<em class="ma">连接</em>头。服务器在接收到将<em class="ma">连接</em>报头设置为<em class="ma">保持活动的请求时，</em>在响应中以<em class="ma">连接:保持活动</em>报头进行响应，并保持其自身与代理之间的TCP连接打开，以期待来自代理的更多请求。</p><p id="8464" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">代理再次盲目地将来自服务器的响应转发到客户端，客户端在接收到具有<em class="ma">连接:保持活动</em>报头的响应时，保持与代理的连接打开，并在同一时间向代理发送更多请求。由于代理不支持<em class="ma">保持活动状态</em>，因此在检测到HTTP请求结束时，它会终止与客户端和服务器的连接。结果，来自客户端的进一步请求被丢弃，而服务器保持其资源等待来自代理的请求。</p><h1 id="c555" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">HTTP/1.1中盲中继代理的解决方案</h1><p id="8a39" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">与盲中继代理不同，现代代理被编程为在转发请求之前逐跳丢弃<em class="ma">报头，例如<em class="ma">连接</em>报头。这导致消除了由盲中继代理引起的连接挂起问题。另一方面，这阻止了连接的重用，因此我们又回到了起点，我们必须为每个请求创建TCP连接。</em></p><p id="8eca" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">作为一个变通办法，Netspace的开发人员引入了一个新的头部，<em class="ma">代理连接。</em>代理如果能够保持连接活动，它将从客户端丢弃<em class="ma">代理连接</em>，并在将其转发到服务器之前添加新的<em class="ma">连接</em>报头。如果代理恰好是一个盲中继，它会将<em class="ma">代理连接</em>报头转发给服务器，服务器会很高兴地忽略这个报头，从而避免了连接挂起的问题。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/1f9f0ee763ff65c1eb18d4566073349f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*rkfBHfIUPTPPC32YTuliOg.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">代理连接标头变通办法控制盲中继代理中的挂起问题</figcaption></figure><p id="8e6d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">然而，如果在网络空间代理和服务器之间碰巧有一个盲中继代理，这个模型就会失败。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mh"><img src="../Images/61c4efb5edc61086d5691141bb301055.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*epb8O47VMqZEkZKcHgvYpQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">如果盲目中继代理恰好在网络空间代理之后，代理连接标头会失败</figcaption></figure><h1 id="9d98" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">持续连接— HTTP/1.1</h1><p id="ea1a" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">持续连接是指在事务完成后不会立即终止的连接。默认情况下，HTTP/1.0连接不是持久。<em class="ma">连接:Keep-Alive </em>一直在尝试使用HTTP/1.0中的持久连接。代理服务器的引入被证明是这种方法的一个障碍。</p><p id="c08b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为了解决这个问题，较新的HTTP/1.1协议被设计为持久的，除非指定。与HTTP/1.0类似，HTTP/1.1也采用了<em class="ma">连接</em>头。但是，在这里，如果客户机不需要服务器在事务完成后保持连接打开，那么连接被设置为关闭。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/afcbbe8f31810ec6872de93bc13e5cf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*S2e7Iw159RpJR2i1oy9LXQ.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">HTTP/1.1请求中的连接头</figcaption></figure></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><p id="a09f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">参考:</p><div class="mp mq gp gr mr ms"><a href="https://www.oreilly.com/library/view/http-the-definitive/1565925092/ch04s05.html" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd io gy z fp mx fr fs my fu fw im bi translated">HTTP:权威指南</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">Web客户端经常打开到同一站点的连接。例如，网页中的大多数嵌入图像通常来自…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">www.oreilly.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng jt ms"/></div></div></a></div><div class="mp mq gp gr mr ms"><a href="https://tools.ietf.org/html/rfc7230#appendix-A.1.2" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd io gy z fp mx fr fs my fu fw im bi translated">RFC 7230 -超文本传输协议(HTTP/1.1):消息语法和路由</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">互联网工程任务组。征求意见:7230 Adobe过时产品:2145，2616 J…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">tools.ietf.org</p></div></div></div></a></div><div class="mp mq gp gr mr ms"><a href="https://tools.ietf.org/html/rfc2068#section-19.7.1" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd io gy z fp mx fr fs my fu fw im bi translated">RFC 2068 -超文本传输协议- HTTP/1.1</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">网络工作组R. Fielding征求意见:2068 UC Irvine类别:标准跟踪J. Gettys J. Mogul DEC…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">tools.ietf.org</p></div></div></div></a></div><div class="mp mq gp gr mr ms"><a href="https://jdebp.eu/FGA/web-proxy-connection-header.html" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd io gy z fp mx fr fs my fu fw im bi translated">jdebp.eu</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">此域名可能出售！</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">jdebp.eu</p></div></div></div></a></div></div></div>    
</body>
</html>