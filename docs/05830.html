<html>
<head>
<title>Review Unit Testing from Building a Connected Undirected Graph</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从构建连通无向图看单元测试</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/review-unit-testing-from-building-a-connected-undirected-graph-a827c1851c09?source=collection_archive---------4-----------------------#2021-11-05">https://blog.devgenius.io/review-unit-testing-from-building-a-connected-undirected-graph-a827c1851c09?source=collection_archive---------4-----------------------#2021-11-05</a></blockquote><div><div class="fc ic id ie if ig"/><div class="ih ii ij ik il"><div class=""/><figure class="gm go jl jm jn jo"><div class="bz fq l di"><div class="jp jq l"/></div></figure><h1 id="a0ae" class="jr js io bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">文章的出处</h1><p id="c6f7" class="pw-post-body-paragraph kp kq io kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ih bi translated">这些天来，我试图解决关于<a class="ae ln" href="https://leetcode.com/" rel="noopener ugc nofollow" target="_blank"> LeetCode </a>的问题，每当我提交解决方案以通过验证时，我都会想到一个问题。</p><p id="c12a" class="pw-post-body-paragraph kp kq io kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ih bi translated"><strong class="kr ip"> <em class="lt">如何验证自己提交的东西是否符合要求的问题？</em> </strong></p><p id="6802" class="pw-post-body-paragraph kp kq io kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ih bi translated">好吧，大多数开发人员会不断提交改进的解决方案，直到他们通过网站上的整个测试用例，检查时间/空间复杂度是否达到问题的标准，并继续上述循环。</p><p id="a9f7" class="pw-post-body-paragraph kp kq io kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ih bi translated">然而，在真实的编程场景中，没有任何验证系统可以用来检查您的解决方案是否满足市场需求。你应该负责设计你自己的测试用例，以确保你所提交的能适应真实市场中的场景。为了实现这一点，当评估开发人员的质量交付能力时，测试的技巧很重要。</p></div><div class="ab cl lu lv hs lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ih ii ij ik il"><h1 id="ab47" class="jr js io bd jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk mf km kn ko bi translated"><strong class="ak">选择一个容易上手的测试框架</strong></h1><p id="351d" class="pw-post-body-paragraph kp kq io kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ih bi translated">嗯，这取决于你熟悉哪种编程语言。例如，我熟悉Java/C++，所以<a class="ae ln" href="https://junit.org/junit5/" rel="noopener ugc nofollow" target="_blank"> JUnit 5 </a> / <a class="ae ln" href="https://sourceforge.net/projects/cppunit/" rel="noopener ugc nofollow" target="_blank"> CppUnit </a>将是开始单元测试任务的第一选择。再说一次，无论您应用什么测试框架都没有关系；重要的是你开始习惯于在你的任务中随时进行测试。</p><p id="2a82" class="pw-post-body-paragraph kp kq io kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ih bi translated">对于编程语言，<a class="ae ln" href="https://en.wikipedia.org/wiki/List_of_unit_testing_frameworks" rel="noopener ugc nofollow" target="_blank"> wiki </a>页面提供了基于您选择的语言的各种测试框架。我们应该做的是发现问题来练习技巧。</p><h1 id="2257" class="jr js io bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">如何在IDE上使用JUnit？</h1><p id="fd58" class="pw-post-body-paragraph kp kq io kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ih bi translated">幸运的是，大多数ide如<a class="ae ln" href="https://code.visualstudio.com/docs/java/java-testing" rel="noopener ugc nofollow" target="_blank"> VSCode </a>或<a class="ae ln" href="https://www.eclipse.org/community/eclipse_newsletter/2017/october/article5.php" rel="noopener ugc nofollow" target="_blank"> Eclipse </a>都支持默认测试框架，所以我们只需要知道如何在我们的工作中应用它们。在我的例子中，我将展示如何在Eclipse上应用JUnit来完成一个基本图形问题的单元测试任务——构建一个连通的无向图。来源如下图所示:</p><figure class="mg mh mi mj gu jo"><div class="bz fq l di"><div class="mk jq l"/></div></figure><p id="03e1" class="pw-post-body-paragraph kp kq io kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ih bi translated">为了概括图形问题，我定义了一个模板形式的数据类，它包含2个构造函数和4个公共成员函数来操作图形构造任务。到目前为止，我们还不知道定义的成员是否可以照常工作。所以我们需要在每个成员函数上应用测试任务。在eclipse中，我们可以通过以下方式生成基本的单元测试用例</p><ul class=""><li id="19f3" class="ml mm io kr b ks lo kw lp la mn le mo li mp lm mq mr ms mt bi translated"><strong class="kr ip">右键单击源新JUnit测试案例</strong>。</li></ul><figure class="mg mh mi mj gu jo gi gj paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gi gj mu"><img src="../Images/f6314aa68ea328b2e567c09f79119095.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ms_zx9y2qwk6YUmLrTRqKQ.png"/></div></div></figure><ul class=""><li id="2891" class="ml mm io kr b ks lo kw lp la mn le mo li mp lm mq mr ms mt bi translated"><strong class="kr ip">选择包装设置文件名勾选存根方法接下来</strong></li></ul><figure class="mg mh mi mj gu jo gi gj paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gi gj nb"><img src="../Images/d9770c9cef19ed63fd564205b8b73ccd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YHAf1PeXTZUIV4KV3E-fyg.png"/></div></div></figure><ul class=""><li id="9e6b" class="ml mm io kr b ks lo kw lp la mn le mo li mp lm mq mr ms mt bi translated"><strong class="kr ip">选择要测试的方法完成</strong></li></ul><p id="0941" class="pw-post-body-paragraph kp kq io kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ih bi translated">由您来决定您想要为哪个方法创建任务，或者在生成测试运行程序之后编辑您自己的任务。</p><figure class="mg mh mi mj gu jo gi gj paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gi gj nc"><img src="../Images/49d9e231a6370970f9626a4f3e50b868.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e2A5W_FffYmIQ-AauQMZYw.png"/></div></div></figure><ul class=""><li id="d21b" class="ml mm io kr b ks lo kw lp la mn le mo li mp lm mq mr ms mt bi translated">最终生成的脚本如下。最初，它只包含我们在之前的配置面板中勾选的方法。事实上，您可以通过在自定义任务<strong class="kr ip"> </strong>上添加注释<strong class="kr ip"> @Test </strong>来定义您的测试，以区别于默认生成的任务。</li></ul><figure class="mg mh mi mj gu jo"><div class="bz fq l di"><div class="mk jq l"/></div></figure><p id="abff" class="pw-post-body-paragraph kp kq io kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ih bi translated">注意，用@Test注释的每个方法都是一个要执行的函数范围的任务。例如，当要测试任何方法时，测试运行程序将按顺序运行方法:</p><pre class="mg mh mi mj gu nd ne nf ng aw nh bi"><span id="4c52" class="ni js io ne b gz nj nk l nl nm">setUpBeforeClass()-&gt;<br/>...<br/>setUp()-&gt;{tested method 1}-&gt;tearDown()<br/>setUp()-&gt;{tested method 2}-&gt;tearDown()<br/>setUp()-&gt;{tested method 3}-&gt;tearDown()<br/>...<br/>tearDownAfterClass()</span></pre><p id="aa12" class="pw-post-body-paragraph kp kq io kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ih bi translated">如果您要预先准备相关联的资源，请在setUpBeforeClass()/tearDown after class()或setUp()/tearDown()中分配/取消分配它们。这四种方法的区别如下:</p><ul class=""><li id="db85" class="ml mm io kr b ks lo kw lp la mn le mo li mp lm mq mr ms mt bi translated">setUpBeforeClass():应该在这里配置所有测试周期所需的资源。</li><li id="1363" class="ml mm io kr b ks nn kw no la np le nq li nr lm mq mr ms mt bi translated">tearDownAfterClass():所有测试完成后，它释放资源。</li><li id="f19e" class="ml mm io kr b ks nn kw no la np le nq li nr lm mq mr ms mt bi translated">setUp():仅在测试中需要的资源应该在这里定义。</li><li id="0c43" class="ml mm io kr b ks nn kw no la np le nq li nr lm mq mr ms mt bi translated">tearDown():测试完成后，它释放资源。</li></ul><p id="7d1e" class="pw-post-body-paragraph kp kq io kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ih bi translated">因此，请记住，每个存根方法都有自己的函数范围，不要错误地应用它。</p><h1 id="0a4b" class="jr js io bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">执行测试运行程序</h1><p id="8e9b" class="pw-post-body-paragraph kp kq io kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ih bi translated">提供的源代码是我用来验证单个功能的JUnit测试用例。<br/><strong class="kr ip">{此处添加GraphNodeTest.java }<br/></strong>为了验证测试用例的正确性，就</p><ul class=""><li id="9f2c" class="ml mm io kr b ks lo kw lp la mn le mo li mp lm mq mr ms mt bi translated">右键单击测试源作为JUnit测试案例运行</li></ul><figure class="mg mh mi mj gu jo gi gj paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gi gj ns"><img src="../Images/1c9aaf34c1a918515409852f5868a54b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CGTAKVHLuXpxU3bHzMHwRg.png"/></div></div></figure><p id="1c80" class="pw-post-body-paragraph kp kq io kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ih bi translated">测试运行人员将显示最终测试用例的状态。恭喜你！</p><figure class="mg mh mi mj gu jo gi gj paragraph-image"><div class="gi gj nt"><img src="../Images/4d194e1a20edcea0df8e2658e92c2f54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*uGeq21c86Q-mVZItHT1yJg.png"/></div></figure><h1 id="954a" class="jr js io bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">其他隐藏的测试问题</h1><p id="eac9" class="pw-post-body-paragraph kp kq io kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ih bi translated">如果你仅仅按照上面提到的步骤来完成你的模块的简单验证，这是不足以涵盖相关的测试主题的。事实上，当谈到软件的质量保证时，有许多值得讨论的话题。我在这里列出了一些，供你深入研究。</p><ul class=""><li id="cbb0" class="ml mm io kr b ks lo kw lp la mn le mo li mp lm mq mr ms mt bi translated"><strong class="kr ip">代码覆盖率</strong></li></ul><p id="561c" class="pw-post-body-paragraph kp kq io kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ih bi translated">源可能包含条件规则以适应特定的条件。为了在一个函数中完全覆盖所有情况，我们可能需要设计各种场景案例来进行验证。因此，在一些公司中，代码覆盖率是证明他们的软件在极端场景发生时是否能正常运行的重要标准。</p><ul class=""><li id="691b" class="ml mm io kr b ks lo kw lp la mn le mo li mp lm mq mr ms mt bi translated"><strong class="kr ip">测试命名惯例</strong></li></ul><p id="4df1" class="pw-post-body-paragraph kp kq io kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ih bi translated">在我的例子中，我直接应用了由JUnit生成并编码的测试用例。尽管如此，会有比我上面测试的更多的案例。因此，如何为每个场景命名是一个重要的问题，因为那些接管资源的人会调查给定测试用例的领域知识，以了解它反映了什么样的场景。</p><ul class=""><li id="7ea5" class="ml mm io kr b ks lo kw lp la mn le mo li mp lm mq mr ms mt bi translated"><strong class="kr ip">检测表格类别</strong></li></ul><p id="5ebd" class="pw-post-body-paragraph kp kq io kr b ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ls lk ll lm ih bi translated">单元测试只是这个领域的测试类别之一。当您的系统规模扩大时，应该考虑更多的测试方法来验证稳定性、可修改性和可理解性。例如，集成测试、回归测试、白盒/黑盒测试等。</p></div><div class="ab cl lu lv hs lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ih ii ij ik il"><h1 id="8569" class="jr js io bd jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk mf km kn ko bi translated">蔻驰的低语</h1><p id="11d9" class="pw-post-body-paragraph kp kq io kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ih bi translated">不幸的是，在台湾，大多数公司不关心他们是否测试他们的软件，而是关心最后期限是否能得到满足，这总是让工程师对环境感到沮丧。然而，测试的基本技能决定了您的产品是否能存活足够长的时间，并迅速适应动态的市场。有许多人认为质量保证是一个没有价值的职位，因为通常它的工资较低，不需要加入开发工作。嗯，这在台湾是事实，但是这个想法应该被纠正。最好的方法之一是自己做，现在就开始测试你的源代码。</p></div></div>    
</body>
</html>