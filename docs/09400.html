<html>
<head>
<title>Graph Database and Query Language 101: Speed &amp; Simplicity (Part-II)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图形数据库和查询语言 101:速度和简单性(下)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/graph-database-and-query-language-101-speed-simplicity-part-ii-ada397fea6e?source=collection_archive---------18-----------------------#2022-08-18">https://blog.devgenius.io/graph-database-and-query-language-101-speed-simplicity-part-ii-ada397fea6e?source=collection_archive---------18-----------------------#2022-08-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="b1ac" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">第二部分</h1><p id="8c6e" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">我们已经在本系列文章的第一部分<a class="ae lg" href="https://medium.com/@RickySun/graph-database-and-query-language-101-speed-simplicity-f8ca7e600ec7" rel="noopener">中介绍了速度和性能部分。是时候谈谈图形数据库的一个独特特性了，它应该是普遍可用的——网络(链接实体)分析期间的递归操作。</a></p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi lh"><img src="../Images/eb10be59a228673015a9f2404412a7fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hbv3sewifIl_gKyf"/></div></div></figure><p id="8390" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">以 UBO(最终受益人所有人)识别为例，世界各地的监管机构都在试图识别可能隐藏在层层中间空壳公司背后的最终企业所有人。另一方面，大型企业或个人倾向于通过投资于其他公司使其业务经营多样化，这些公司反过来进一步投资于下游，并最终与数百万公司和自然人(作为所有者、股东、高级管理人员或法律代表的个人)建立起一个巨大的工商图网络(也可以称之为知识图的一种特殊形式)。</p><p id="4d3b" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">在图 9 中，我们说明了 SQL 和 GQL 是如何分别处理 UBO 标识的。正如您所看到的，SQL 处理递归查询是非常笨拙的，它从一个主题公司开始，向上游追溯(渗透)到利益相关者，多达五层。你要写很多行 SQL 代码，这是反直觉的！而且，在一个只有 10，000 行(投资关系)的小表上，SQL 需要几十秒钟才能产生结果，这意味着它将永远花费在数百万到数十亿行的大表上。</p><p id="f0fd" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">另一方面，编写 GQL 可能出乎意料地简单。在 Graph-10 中，从 Ultipa Manager(Ultipa Graph 数据库管理的集成 Web-GUI)启动了一个易于理解的一行程序，为躲在离主题公司 5 跳远的投资者查询一个包含数百万个实体的大型数据集。链接实体格式的结果会实时返回，并清楚地标识主题公司、中间公司和最终投资者。</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi ly"><img src="../Images/6b737519a04968f5c357d2d2aa2a7611.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*olfIHRlnTToi8uSU"/></div></div></figure><p id="19d8" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">在图 9 和图 10 中，我们简要说明了进行网络/链接分析时 SQL 和 GQL 之间的能力差异。分析性地扩展这个主题是值得的，让我们重温一下第一部分中的查询:</p><p id="3624" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">找到 200 对用户(从年龄=22 的用户开始，到年龄=33 的用户结束),他们彼此相距 X 跳。假设 X =[1–20]</p><p id="47d7" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">从查询语言设计的角度来看，您将如何定义和表达问题并相应地获取答案？</p><p id="8888" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">关键部分是使查询叙述化，这意味着自然地类似于人类语言，因此容易理解，同时使它递归和简洁，以便您不必以复杂的(即 SQL)方式编写您的逻辑。</p><p id="d2f8" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">n({年龄==22})。e()[10]。n({age==39})作为路径返回路径限制 200</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi lz"><img src="../Images/284684a6215164cff20fd7013e9ba3fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*D4Lr5Mia-jkduBC9"/></div></div></figure><p id="b623" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">上面用 Ultipa GQL 编写的一个 liner 很容易解释，但是如果您对它的要点感到震惊，递归部分在于 e()[10]，它指定搜索深度正好是 10 跳，当然您可以将其修改为 e()[5:11]，它代表从 5 到 11 跳的遍历深度，或者 e()[:10]，它意味着最多 10 跳，或者 e()[*:10]，其中*代表最短路径(BFS)搜索</p><p id="c0de" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">当然，查询可以以多种方式扩展，比如根据边上的属性进行过滤，或者进行数学和统计计算。例如，通过仅识别 relationship="Invest "沿路径搜索，结果在图 12 中被捕获，具有以下更新的查询:</p><p id="ee8d" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">n({年龄==22})。e({name=="Invest"})[3:5]。n({age==39})作为 p 返回 p 限制 200</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi ma"><img src="../Images/1dff6c206139de4bd8f9cf93c3e176df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tCv5s_Ch5aRrWJEf"/></div></div></figure><p id="f7ad" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">有了强大的递归查询，很多事情都可以非常简单地完成。在余下的部分，我们将对 Neo4j、TigerGraph 和 Ultipa 进行比较。中国有句俗话:比较出真理。接下来就来揭晓真相吧。</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi lh"><img src="../Images/c173414f32c8f6a41eb8679a92ccbce1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FncFdS0j4PlmT3p_"/></div></div></figure><p id="2c68" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">在图 13 中，我们比较了 Cypher、Gremlin、UQL 和 GSQL，同时让它们描述一个典型的关联数据三元组，其中一个标记的实体(Person)有一个作为厨师(job)的工作(relation)功能。如您所见，下面列出了一些要点供您参考:</p><p id="b997" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">GSQL 非常复杂，对于这样一个简单的三元组，需要编写 10 多行代码，对于一个真正复杂的场景，你无法想象你的编码和维护经验。</p><p id="7ebf" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">Gremlin 的语言设计很奇怪，看起来既冗长又混乱，一些功能显然可以合并到更少的链接组件中。</p><p id="2412" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">Cypher 和 UQL 的主要区别在于，Cypher 仍然像 SQL 一样使用 WHERE 子子句，但 UQL 允许这部分在内联中自然完成。</p><p id="e390" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">最后，UQL 支持模式化和无模式，前者允许模式化(强类型)匹配，而后者更灵活地支持尚未模式化的数据集。在 UQL，这被称为半模式，它在处理不同类型的数据时提供了很大的灵活性。</p><p id="0d2c" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">当今大多数实现智能推荐的系统都涉及某种社交推荐，这就是所谓的协同过滤。核心概念其实很简单——本质上是“图形”:</p><p id="d8bf" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">要向客户推荐某样东西，某些产品，我们通常会先浏览客户朋友的购物行为，并根据发现进行推荐…</p><p id="39b0" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">让我们看看这三个图系统是如何应对协同过滤挑战的。</p><p id="19bb" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">Neo4j 使用 Cypher 编写以下逻辑:</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi mb"><img src="../Images/e28e6abb758cbc089ce7eb50f0602070.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Sqialkt9m2yHQ05V"/></div></div></figure><p id="e13e" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">密码逻辑是这样的:</p><p id="5674" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">1.寻找里奇的朋友和朋友的朋友(第一部分)</p><p id="3e36" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">2.收集不同的(独特的)朋友</p><p id="e348" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">3.找出这些朋友买了什么产品(第二部分)</p><p id="0db0" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">4.返回前 5 个购买的产品</p><p id="001d" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">Neo4j 逻辑对数据集有一个先决条件，它假设朋友类型的关系是可用的。这是大多数电子商务网站很难满足的一个主要假设，即使是在世界上最大的淘宝或 T-mall 网站上——他们不会跟踪用户的社交网络信息！</p><p id="01ff" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">Neo4j &amp; Cypher 的另一个明显的限制是，它不允许在图上进行深度遍历，在搜索 1 到 2 跳深度并构建中间数据集(friends)后，您必须暂停，然后继续搜索的第二部分。在像 UBO(最终企业所有者)查找这样的场景中，这种症状可能会加剧，在这种情况下，您需要进行深度遍历，有时需要 10 甚至 20 跳。Neo4j 不能简单快速地处理这种情况。</p><p id="d3e9" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">TigerGraph 使用 GSQL(GraphSQL 的缩写)来进行“协作过滤”，下面来自 Tigergraph 在线文档的代码块说明了如何做到这一点。首先，提供一组用户(input_user)，然后，找到所有喜欢输入用户的目标用户，再次，从这些目标用户出发，继续搜索他们喜欢的用户，并聚集(ACCUM)并以有序的方式返回。</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi mc"><img src="../Images/8ee46ff11275b045079e9e7bf101fcdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nxCx83WmemcEy7wd"/></div></div></figure><p id="2c22" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">首先，这个例子本质上是一个带有数据聚合的基于 2 跳模板的路径搜索。此外，上面的 GSQL 过于复杂、笨拙和冗长。SQL 的一个主要缺点是它消耗了大量的人类认知能力——一个超过 10 行的 SQL 存储过程变得难以解释。而这一簇 GSQL 代码给了我们所有关于 SQL 的不好的记忆。</p><p id="3b34" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">仅仅为了简单的比较和展示，如果 UQL 要完成同样的任务，你只需要写下:</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div class="gh gi md"><img src="../Images/ec0b182a53d29e37e2199bd21f471eb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/0*iI7T9a-DXzPYvbPg"/></div></figure><p id="b032" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">很简单明了，不是吗？</p><p id="8f55" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">首先，开始一个模板搜索(t())，从一组节点 n()开始；</p><p id="266f" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">第二，遍历名为“Liked By”(或任何其他属性)的边；</p><p id="746c" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">第三，继续遍历键入“Liked”的边，到达别名为 c 的节点；</p><p id="d785" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">第四，返回 distinct c 并按 b 分组。</p><p id="5a2e" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">让我们回到我们最初关于协同过滤的问题，在电子商务图表数据集上，它由客户、产品和连接用户和产品的购物或浏览行为组成。用非常形象的方式思考，你基本上需要完成以下步骤:</p><p id="15e1" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">1.从用户开始，查找所有产品(已查看、已添加或已购买)</p><p id="dfaf" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">2.找到所有对这些产品有过特定操作(即购买)的用户</p><p id="8316" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">3.查找用户在步骤 2 中采取措施的所有其他产品。</p><p id="f259" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">4.返回一些产品(即排名靠前的)并推荐给用户。</p><p id="d573" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">结果如下图所示:</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi me"><img src="../Images/5f80f9cefdceea4f49c8a43ed18a1963.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Fw8QFqy3QPE2_SOQ"/></div></div></figure><p id="fbd4" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">用于实现这一点的 UQL 是一个基于模板的路径查询，如下所示，它描述了上面定义的路径过滤标准。最终被推荐的产品可以以更复杂的方式被进一步过滤、排名或处理，但是查询语言本身表面上是不言自明的并且容易理解:</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/fe8bd42100c1b95bd3d39af30177eea6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/0*tbKfd0Cp86In6UxR"/></div></figure><p id="b6b4" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">在这一系列文章中，我们讨论了图形数据库的两个关键特性:</p><p id="34d5" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">速度:如果速度和性能不重要，还有什么能更重要？图形数据库的整个承诺植根于前所未有的数据渗透能力，这直接转化为速度！</p><p id="e171" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">简单性:图数据是高维的，SQL 远没有能力处理图查询。如果我们要设计 GQL，我们希望查询易于理解，当然也易于编码，这样基于图形数据库的二次开发就可以提供更快的价值实现和上市时间。</p><p id="81f4" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">数据查询语言的美妙之处不在于它的复杂，而在于它的简单。它应该容易理解，因此需要最小的认知负荷，并且应该快如闪电！所有繁琐和令人生畏的复杂性都应该被基础系统屏蔽掉，因此对人类用户是透明的。这就像古希腊的泰坦阿特拉斯把地球扛在肩上，而不是给生活在地球上的用户增加负担(=查询语言和数据库的用户)。</p><p id="b673" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">写几十行甚至几百行 SQL 代码，加重了认知负荷。我们信奉的理念是:</p><p id="3265" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">任何懂业务的人都能掌握一门图数据库查询语言，不一定是数据科学家。</p><p id="4596" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">查询语言应该非常容易使用，所有的复杂性都嵌入在底层数据库中，并且对用户透明。</p><p id="7b9c" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">最后，图形数据库具有取代大部分 SQL 工作负载的巨大潜力，Gartner 在 2021 年的一份报告中预测，到 2025 年，80%的商业智能创新将由图形分析推动，图形的增长轨迹是指数级的！</p><p id="5930" class="pw-post-body-paragraph ki kj in kk b kl lt kn ko kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ig bi translated">有些人声称 RDBMS &amp; SQL 永远不会被取代，我们发现这很难相信，RDBMS 在 70 年代就已经取代了导航数据库，并在近 50 年里相当成功，但如果历史教会了我们什么，那就是对任何东西的痴迷都不会永远持续下去，这在互联网和信息技术的世界中尤其如此。</p><blockquote class="mg mh mi"><p id="baf3" class="ki kj mj kk b kl lt kn ko kp lu kr ks mk lv kv kw ml lw kz la mm lx ld le lf ig bi translated"><em class="in">“珍惜的，灭亡的”</em></p><p id="3678" class="ki kj mj kk b kl lt kn ko kp lu kr ks mk lv kv kw ml lw kz la mm lx ld le lf ig bi translated"><em class="in">《你抗拒什么，就坚持什么》</em></p><p id="24b7" class="ki kj mj kk b kl lt kn ko kp lu kr ks mk lv kv kw ml lw kz la mm lx ld le lf ig bi translated"><em class="in">如果人脑是终极数据库，</em></p><p id="9a0d" class="ki kj mj kk b kl lt kn ko kp lu kr ks mk lv kv kw ml lw kz la mm lx ld le lf ig bi translated"><em class="in">图形数据库是到达那里的最短路径。</em></p></blockquote></div></div>    
</body>
</html>