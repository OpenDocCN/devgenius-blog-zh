<html>
<head>
<title>The Reason Why Order in Hooks Matters</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">钩子中的顺序很重要的原因</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/the-reason-why-order-in-hooks-matters-2acd702526b3?source=collection_archive---------13-----------------------#2022-06-15">https://blog.devgenius.io/the-reason-why-order-in-hooks-matters-2acd702526b3?source=collection_archive---------13-----------------------#2022-06-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/144184eec512046093b5754e7737fce5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1CFkhYo-thhnEHh3"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">由<a class="ae jz" href="https://unsplash.com/@lautaroandreani?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">劳塔罗·安德烈亚尼</a>在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="d23d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">React 钩子是 React 16.8 中的新特性。它们允许您在不编写类的情况下使用状态和其他 React 特性。它们是编写有状态组件的强大方法，也是编写功能组件的好方法。</p><p id="4207" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，所有这些力量都是有代价的。它们有一些你应该遵守的约束，以使它们很好地工作，否则，你最终会有很多 bug。</p><p id="701c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">今天我想谈谈一个具体的规则:</p><blockquote class="ky kz la"><p id="7e40" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><em class="in">不要在循环、条件或嵌套函数中调用钩子。</em></p></blockquote><p id="20d2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以，简单地说，我们不能这样做:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="2e73" class="lo lp in lk b gy lq lr l ls lt">import * as React from "react";<br/><br/>const Iron = ({ isMelted = false }) =&gt; {<br/>  if (isMelted) {<br/>    const [temperature, setTemperature] = React.useState(null);<br/>  }<br/><br/>  return &lt;div&gt;{...}&lt;/div&gt;;<br/>};</span></pre><p id="7045" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">或者更糟的是:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="2b8b" class="lo lp in lk b gy lq lr l ls lt">&lt;button onClick={() =&gt; useRequest({ id: 12 })}&gt;<br/>  {n + 1}<br/>&lt;/button&gt;</span></pre><p id="3418" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有时候，阅读这条规则的人会应用它，而不会问太多为什么和如何应用的问题，如果你也是其中之一，那没关系，遵循文档而不深入并不可耻，但命运希望你在这里就是因为这个原因，所以我问你:你能告诉我为什么它如此重要吗？</p><p id="3647" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在做任何解释之前，我希望你打开你的问题解决工具——大脑，我会给你五分钟时间想出一个解决方案，然后你可以浏览这篇文章来寻求启发！</p><p id="dba8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你解决问题的过程如何？希望你找到了很酷的东西！让我们深入了解一下，实现我们自己的<strong class="kc io">使用状态</strong>。</p><p id="7f08" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首发应用会是这个，你猜怎么着？另一个计数器…但是将自定义解决方案与真实解决方案进行比较会很有用。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="15b6" class="lo lp in lk b gy lq lr l ls lt">import ReactDOM from "react-dom";<br/>import { useState } from "react";<br/><br/>// The actual Component<br/>export default function App() {<br/>  const [counter, setCounter] = useState(10);<br/>  const increment = () =&gt; setCounter(counter + 1);<br/><br/>  return (<br/>    &lt;div&gt;<br/>      &lt;button onClick={increment}&gt;{counter}&lt;/button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}<br/><br/>ReactDOM.render(&lt;App /&gt;, document.getElementById("root"));</span></pre><blockquote class="ky kz la"><p id="d264" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><em class="in">我们将使用 React 17，因为 18 版本中的新渲染逻辑不能很好地与“自制”解决方案一起工作，但你知道，这只是一个实验😇</em></p></blockquote><h1 id="f814" class="lu lp in bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">我们的自定义使用状态</h1><p id="f25f" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">我们的目标是调用自定义的 useState，而不是真实的 useState，让我们揭开这个钩子的行为的神秘面纱:</p><ul class=""><li id="d012" class="mw mx in kc b kd ke kh ki kl my kp mz kt na kx nb nc nd ne bi translated">可以接受带有状态初始值的参数。</li><li id="931e" class="mw mx in kc b kd nf kh ng kl nh kp ni kt nj kx nb nc nd ne bi translated">它返回一个具有实际值的元组和一个更新该值的函数。</li><li id="8223" class="mw mx in kc b kd nf kh ng kl nh kp ni kt nj kx nb nc nd ne bi translated">一旦状态被更新，它触发组件的重新呈现，保持更新的值。</li></ul><p id="5040" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以我们要做的第一件事是用一些基本的占位符来声明我们的函数，并注释真正的函数💅</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="191f" class="lo lp in lk b gy lq lr l ls lt">// import { useState } from "react";<br/><br/>function useState(initialValue) {<br/>  const setValue = (newValue) =&gt; {};<br/>  const tuple = [initialValue, setValue];<br/>  return tuple;<br/>}</span></pre><p id="a683" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">太好了，现在没有东西崩溃了，但它也不起作用…我们的 setValue 函数什么也不做。我们需要给她实际的功能，但是你可能会注意到这里的一个问题:状态是如何存储在函数中的？</p><p id="c145" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我的意思是，每个人都知道 React 组件只是函数，对吗？React 本身调用这些触发组件渲染的函数，但是对于每一次对<code class="fe nk nl nm lk b">App</code>组件的新调用，我们都会初始化一个全新的 useState 函数。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="57b1" class="lo lp in lk b gy lq lr l ls lt">App(); // A new useState is invoked<br/>App(); // A new useState is invoked<br/>App(); // A new useState is invoked</span></pre><p id="37ea" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，为了解决这个问题，我们需要一个外部变量来存储我们的钩子声明！姑且称之为<strong class="kc io">状态</strong>。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="1bc0" class="lo lp in lk b gy lq lr l ls lt">// This variable will be persistent between renders!<br/>let state = [];<br/><br/>function useState(initialValue) {<br/>  const setValue = (newValue) =&gt; {};<br/>  const tuple = [initialValue, setValue];<br/>  return tuple;<br/>}</span></pre><p id="97c3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在是时候实现钩子的核心逻辑了，初始版本可能是这样的:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="4834" class="lo lp in lk b gy lq lr l ls lt">let state = null;<br/><br/>function useState(initialValue) {<br/>  if (state &amp;&amp; state[0]) {<br/>    return state;<br/>  }<br/><br/>  const setValue = (newValue) =&gt; {<br/>    state[0] = newValue;<br/>    customRender(); // Who am I?<br/>  };<br/><br/>  state = [initialValue, setValue];<br/><br/>  return state;<br/>}</span></pre><p id="e686" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们来分解一下行为:在初始调用时，useState 将检查在 States 数组的特定索引处是否已经有了什么，如果是，它将返回它，否则它用元组填充 state 变量并返回它。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="a7f5" class="lo lp in lk b gy lq lr l ls lt">// First Render: Initialize with the Tuple<br/>// Second Render: State is not null, so returns it.<br/>// Third Render: State is not null. so returns it.<br/>// Continue Infinitely...</span></pre><blockquote class="ky kz la"><p id="b856" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><em class="in">但是 the 雷纳托，我迫不及待地尝试了这段代码，但什么都没用。你在开玩笑吗？！？</em></p></blockquote><p id="57d6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">仔细看前面的代码片段，看到<code class="fe nk nl nm lk b">customRender</code>函数调用了吗？这是我们在 react 中模拟重新渲染的奇怪技巧。简单地说，我们创建一个包装了<code class="fe nk nl nm lk b">ReactDOM.render()</code>调用的函数，并在设置新值时调用它。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="2c57" class="lo lp in lk b gy lq lr l ls lt">// Wrap the render function into a function.<br/>function customRender() {<br/>  ReactDOM.render(&lt;App /&gt;, document.getElementById("root"));<br/>}<br/><br/>// Don't forget to call it immediately, we need our initial render :)<br/>customRender();</span></pre><p id="5263" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你尝试这段代码，你会发现它实际上和真实的一样，我会把沙箱留在这里。</p><figure class="lf lg lh li gt jo"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="2d17" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">酷，现在是时候让一切爆炸了！</p><p id="ed56" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">看看我放在这里的这个新沙箱:</p><figure class="lf lg lh li gt jo"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="7eb9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你能发现这个漏洞吗？这并不酷…每个按钮都有相同的状态值🥲，也许是时候更好的实现了！</p><h1 id="1990" class="lu lp in bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">是时候更好地实现了！</h1><p id="5a16" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">第一个明显的问题是，我们的<strong class="kc io"> state </strong>变量接受单个值，所以它需要成为一个数组，此外，我们需要一种方法来跟踪我们的<code class="fe nk nl nm lk b">useState</code>调用的索引，因为，对于每个状态，将有不同的值！</p><p id="37e0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这里，你可以找到两个不同的按钮，最终享受自己的价值工作版本！</p><figure class="lf lg lh li gt jo"><div class="bz fp l di"><div class="nn no l"/></div></figure><h1 id="0889" class="lu lp in bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">我们问题的答案</h1><p id="3b08" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">到目前为止，我们问自己为什么钩子的顺序很重要，我希望现在你自己已经找到了答案。</p><p id="4f8c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">原因很简单，就是这个变量:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="27b6" class="lo lp in lk b gy lq lr l ls lt">const states = []; // I'm a bad Guy 😙</span></pre><p id="40c4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">尽管这是一个非常幼稚的实现，但 internally react 的工作方式与此类似。每个钩子定义都存储有一个特定的索引，因此 React 依赖它来返回正确的值。</p><p id="6c3f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如我们在第一个例子中看到的，这就是这样做不正确的原因:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="ebc9" class="lo lp in lk b gy lq lr l ls lt">import * as React from "react";<br/><br/>const Iron = ({ isMelted = false }) =&gt; {<br/>  // Sometimes the index can be zero, sometimes not?<br/>  // There is no consistency between renders!<br/>  if (isMelted) {<br/>    const [temperature, setTemperature] = React.useState(null);<br/>  }<br/><br/>  return &lt;div&gt;&lt;/div&gt;;<br/>};</span></pre><p id="5a28" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可能还会发现 React 常见问题解答中的这个答案很有用:</p><blockquote class="ky kz la"><p id="b5db" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><strong class="kc io"><em class="in">React 如何将钩子调用与组件关联起来？</em>T12】</strong></p><p id="c960" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><em class="in">每个组件都有一个内部“存储单元”列表。它们只是 JavaScript 对象，我们可以在其中放置一些数据。当你调用一个类似 useState()，</em> <strong class="kc io"> <em class="in">的钩子时，它读取当前单元格(或者在第一次渲染时初始化它)，然后将指针移动到下一个</em> </strong> <em class="in">。这就是多个 useState()调用各自获得独立的本地状态的方式。</em></p></blockquote><p id="deed" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="lb">最初发布于</em><a class="ae jz" href="https://renatopozzi.me/articles/the-reason-why-order-in-react-hooks-matters" rel="noopener ugc nofollow" target="_blank"><em class="lb">https://renatopozzi . me</em></a><em class="lb">。</em></p><div class="np nq gp gr nr ns"><a href="https://www.linkedin.com/in/itsrennyman/" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd io gy z fp nx fr fs ny fu fw im bi translated">雷纳托·波齐|职业简介| LinkedIn</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">把善良和知识带给其他人。我是一名软件开发人员，目前在意大利米兰，🇮🇹，我曾经…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">www.linkedin.com</p></div></div><div class="ob l"><div class="oc l od oe of ob og jt ns"/></div></div></a></div></div></div>    
</body>
</html>