<html>
<head>
<title>How to build Kafka Spring Boot message driven service</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何构建卡夫卡 Spring Boot 消息驱动服务</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-build-kafka-spring-boot-message-driven-service-e85921249685?source=collection_archive---------1-----------------------#2022-12-30">https://blog.devgenius.io/how-to-build-kafka-spring-boot-message-driven-service-e85921249685?source=collection_archive---------1-----------------------#2022-12-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="cff8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们准备好这一广受欢迎的编程技能</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/80ad2780136779bf7ab6d2a1b07bd274.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LWd6rvsQ8G5U79KtNy5QJw.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/es/@yingzge?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">鹦哥</a>在<a class="ae kv" href="https://unsplash.com/photos/D6AYkHWLR9o?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="926b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">消息代理的使用非常广泛，已经成为大多数企业系统的关键基础设施组件之一。特别是，它为金融系统处理大量货币交易提供了动力。</p><p id="5061" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">近年来，由于 Kafka 的高吞吐量和对数据流的支持，许多企业都在采用它。有趣的是，卡夫卡的知识和经验一直是一项抢手的技能，也是软件工程师招聘广告中最热门的关键词之一。</p><p id="8a65" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了帮助任何有兴趣学习 Kafka 知识的人，我将分享 Kafka 的基本知识，以及如何构建一个与其集成的 Java Spring Boot 服务。</p><h2 id="fd32" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">什么是消息代理？</h2><p id="8167" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">Message broker 通常像邮局一样连接各种系统，并将消息从源系统路由到目标系统。这种架构不仅使系统解耦，还保证了消息的传递。</p><p id="69c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下图说明了 RabbitMQ(一个流行的开源消息代理)的消息流，消息生产者将消息发送到 RabbitMQ 上的一个交换，交换根据路由规则将消息传输到指定的队列，然后消费者从队列中提取消息。</p><p id="7d4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">显然，这样的设计允许以异步方式处理消息。即使消费者不在，生产者仍然可以发送消息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/29ae90d1fc63ef7b96f04f2ffb32ab11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/0*LBuGwXGbmpxk4saI"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">RabbitMQ 概述</figcaption></figure><h2 id="e386" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">《果壳中的卡夫卡》</h2><p id="87ba" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">传统的消息代理将消息保存在队列中，一旦消息被消费和确认就删除消息，而 Kafka 将消息流保存在主题中，并且消息在消费时不会被删除。相反，维护一个偏移量来跟踪要使用的最新消息。</p><p id="f247" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这张图向你展示了卡夫卡的高层信息流。生产者向主题发送消息。消费者定期就该话题进行投票，并收到新消息。处理消息时，使用者提交偏移量增量，以便使用下一个偏移量的消息。</p><p id="d166" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">多个消费者群体可以用不同的偏移值对同一主题进行投票。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/974229c03a72d3ade98a112617c049fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/0*S7F-L5UFQyab2P0Y"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">卡夫卡</figcaption></figure><p id="eca4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了并行处理的好处，分区是 Kafka 的一个很棒的特性。在卡夫卡内部，主题是分区的。消息根据消息键被分发到分区。分区可以在不同的节点中维护，并由多个使用者处理。下图显示了一个主题，该主题有 3 个分区，由一个消费者组中的一个消费者使用。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ms"><img src="../Images/8aad0c75272c914f2ec4252fff98948a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*voJZ8Jojaijp_Cc4"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">卡夫卡——隔墙</figcaption></figure></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="9ed6" class="na lt iq bd lu nb nc nd lx ne nf ng ma jw nh jx md jz ni ka mg kc nj kd mj nk bi translated">为发展而启动卡夫卡</h1><p id="2894" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">首先，让我们在本地机器上创建一个 Kafka。启动 Kafka 实例最简单的方法是运行 docker 映像。是一个一体化的 docker 映像，它不仅包括 Kafka 实例，还包括模式注册表、连接器和 web UI。您将找到 Kafka 应用程序开发所需的一切。</p><p id="58b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行以下命令启动并运行 docker 容器:</p><pre class="kg kh ki kj gt np no nq bn nr ns bi"><span id="114a" class="nt lt iq no b be nu nv l nw nx">docker run -e ADV_HOST=127.0.0.1 -e SAMPLEDATA=0 -e RUNTESTS=0 \<br/>-p 3030:3030 -p 9092:9092 --rm landoop/fast-data-dev:latest</span></pre><p id="03e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">转到<a class="ae kv" href="http://localhost:3030" rel="noopener ugc nofollow" target="_blank"> http://localhost:3030 </a>，您将看到一个 web UI，它链接到 schema registry UI、topic UI 以及 Kafka connect UI，提供了一种在开发期间检查消息的便捷方式。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/d04c9f57070f1fa5a2402a7d190f08e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xGFBpyJowryTe_vJ"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Kafka 开发环境— Web 用户界面</figcaption></figure></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="823b" class="na lt iq bd lu nb nc nd lx ne nf ng ma jw nh jx md jz ni ka mg kc nj kd mj nk bi translated">快速演示</h1><p id="8cff" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">为了快速演示 Kafka 消息的提交和使用，这里有一个简单的保险索赔处理器的示例应用程序。新的保险索赔请求被提交到 Kafka 主题“claim-submitted ”,供处理器进行评估，然后将结果发送到另一个主题“claim-updated”进行进一步处理。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/9e76d575fed48d838b3a3d89fc319316.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/0*K6R5zS0bfvYdKPFo"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">示例应用程序—保险索赔处理程序</figcaption></figure><p id="78e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从 GitHub<a class="ae kv" href="https://github.com/gavinklfong/spring-kafka-demo" rel="noopener ugc nofollow" target="_blank">https://github.com/gavinklfong/spring-kafka-demo</a>获得示例应用程序</p><p id="6f33" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Kafka docker 容器启动并运行后，运行以下命令来编译并启动应用程序:</p><pre class="kg kh ki kj gt np no nq bn nr ns bi"><span id="6277" class="nt lt iq no b be nu nv l nw nx">mvn spring-boot:run</span></pre><p id="7c45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请看<strong class="ky ir"> ClaimsRequestController </strong>的源代码，它向您展示了如何分别使用 Kafka 客户端库和 Spring <strong class="ky ir"> KafkaTemplate </strong>生成 Kafka 消息:</p><p id="0fe1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行以下命令，使用 kafka 客户端库生成新的保险索赔请求:</p><pre class="kg kh ki kj gt np no nq bn nr ns bi"><span id="3d03" class="nt lt iq no b be nu nv l nw nx">curl --request POST 'http://localhost:8080/claim-1'</span></pre><p id="d280" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个命令使用 Spring <strong class="ky ir"> KafkaTemplate </strong>生成一个新的实例声明请求:</p><pre class="kg kh ki kj gt np no nq bn nr ns bi"><span id="0438" class="nt lt iq no b be nu nv l nw nx">curl --request POST 'http://localhost:8080/claim-2'</span></pre><p id="acf7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，您应该有两个提交给 Kafka 主题“claim-submitted”的索赔请求。查看 web UI(<a class="ae kv" href="http://localhost:3030/kafka-topics-ui/#/" rel="noopener ugc nofollow" target="_blank">http://localhost:3030/Kafka-topics-UI/#/</a>)，您将能够看到主题“claim-submitted”上生成的请求以及主题“claim-updated”上的审核结果</p><p id="144f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">主题为“已提交索赔”的已提交请求</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/2303761c4ea4dcb257304d0e049931a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZJQhxFj-KbmQK3pl"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Kafka 主题中的消息“已提交索赔”</figcaption></figure><p id="54a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">主题“索赔-已更新”的索赔审查结果</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/844d615ec0aea287fd9ae507e671c451.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9BkNMCrssp_2GVfr"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">卡夫卡主题“索赔-更新”中的消息</figcaption></figure><p id="15e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此命令用于检索“索赔-更新”主题的最新索赔审查结果:</p><pre class="kg kh ki kj gt np no nq bn nr ns bi"><span id="15de" class="nt lt iq no b be nu nv l nw nx">curl --request GET 'http://localhost:8080/claim-results'</span></pre></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="5043" class="na lt iq bd lu nb nc nd lx ne nf ng ma jw nh jx md jz ni ka mg kc nj kd mj nk bi translated">库依赖性</h1><p id="1bac" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">Java 编程与 Kafka 无缝集成。使用<a class="ae kv" href="https://start.spring.io" rel="noopener ugc nofollow" target="_blank"> Spring Boot 初始化生成 Maven pom.xml。在依赖项部分选择“Apache Kafka 的 Spring ”:</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/53e18574575e71c056da28ecde3e228b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Py0BSJ_Me_QQ6WZA"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">来源:https://start.spring.io</figcaption></figure><p id="ded5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将 spring boot 作为父项，将生成以下依赖关系:</p><pre class="kg kh ki kj gt np no nq bn nr ns bi"><span id="117d" class="nt lt iq no b be nu nv l nw nx"><br/>   &lt;dependency&gt;<br/>     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>     &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;<br/>   &lt;/dependency&gt;<br/>   &lt;dependency&gt;<br/>     &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;<br/>     &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;<br/>   &lt;/dependency&gt;<br/><br/><br/>   &lt;dependency&gt;<br/>     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>     &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;<br/>     &lt;scope&gt;test&lt;/scope&gt;<br/>   &lt;/dependency&gt;<br/>   &lt;dependency&gt;<br/>     &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;<br/>     &lt;artifactId&gt;spring-kafka-test&lt;/artifactId&gt;<br/>     &lt;scope&gt;test&lt;/scope&gt;<br/>   &lt;/dependency&gt;</span></pre><p id="cc2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然 Spring Kafka 组件为与 Kafka 的集成提供了丰富的功能，但它依赖 Kafka 客户端库来与 Kafka 进行任何交互。下面的 Maven 依赖树显示了 Spring Kafka 的传递依赖:</p><pre class="kg kh ki kj gt np no nq bn nr ns bi"><span id="bfaa" class="nt lt iq no b be nu nv l nw nx">org.springframework.kafka:spring-kafka:jar:3.0.1:compile<br/>  +- ...<br/>  +- ...<br/>  +- org.apache.kafka:kafka-clients:jar:3.3.1:compile<br/>  |  ...<br/>  |  ...</span></pre></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="db8a" class="na lt iq bd lu nb nc nd lx ne nf ng ma jw nh jx md jz ni ka mg kc nj kd mj nk bi translated">发送卡夫卡信息</h1><h2 id="2384" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">使用 Kafka 客户端库生成消息</h2><p id="168a" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">让我们看看如何在不使用 Spring 框架的情况下，直接使用 Kafka 客户端库生成消息。</p><p id="03e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下图概述了消息生成器的工作方式:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/e13ce62688de50f2620467b48d96947b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fA-bkUIZ-t4fw3UP"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">卡夫卡制片人</figcaption></figure><p id="47cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了发送消息，<strong class="ky ir"> KafkaProducer </strong>首先用一组属性实例化。<strong class="ky ir"> KafkaProducer </strong>是线程安全的，因此可以创建一个实例并在线程间共享。Kafka 上的消息由字节数组格式的键和值组成。至少需要以下属性:</p><ul class=""><li id="de22" class="oe of iq ky b kz la lc ld lf og lj oh ln oi lr oj ok ol om bi translated"><strong class="ky ir">引导服务器</strong> — Kafka 消息代理地址。docker 容器的 Kafka 消息代理是<strong class="ky ir"> localhost:9092 </strong></li><li id="3f1d" class="oe of iq ky b kz on lc oo lf op lj oq ln or lr oj ok ol om bi translated"><strong class="ky ir">密钥串行化器</strong> —将消息密钥转换成字节数组的串行化器</li><li id="b53b" class="oe of iq ky b kz on lc oo lf op lj oq ln or lr oj ok ol om bi translated"><strong class="ky ir">值串行化器</strong> —将消息值转换为字节数组的串行化器</li></ul><p id="93f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">全套生产者配置可在<a class="ae kv" href="https://kafka.apache.org/documentation/#producerconfigs" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="68b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的示例代码构建了一个医疗索赔请求，并发送到 Kafka 主题“claim-submitted ”,以客户 id 作为消息键。消息值是 JSON 字符串中的 POJO。因为消息键和值是字符串格式的，所以我们在属性中配置字符串序列化程序，以便 Kafka Producer 能够将消息键和值转换为字节数组以供提交。</p><p id="d3d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了支持高性能，<strong class="ky ir"> KafkaProducer </strong>的<strong class="ky ir"> send() </strong>方法调用是异步的。这意味着方法调用会立即返回，而不会等待提交完成。出于演示的目的，示例代码通过调用<strong class="ky ir"> get() </strong>方法等待提交完成。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="0891" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行上面的示例代码两次，并在 web UI 上查看这个主题(<a class="ae kv" href="http://localhost:3030" rel="noopener ugc nofollow" target="_blank"> http://localhost:3030 </a>)。两条记录将出现在主题“已提交索赔”上，偏移量从零开始。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/71d5cb1ec413a494f370949667278d98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ByqTXIkL-ehkdq2d"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">“已提交索赔”主题中的消息</figcaption></figure><h2 id="fdad" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">Spring Boot 的消息制作者</h2><p id="1618" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">Spring Boot 让它对开发者更加友好。Kafka Producer 属性在<strong class="ky ir"> application.properties </strong>中配置，带有构造<strong class="ky ir"> KafkaTemplate </strong>和<strong class="ky ir"> KafkaProducer </strong>的自动配置。KafkaTemplate 为消息提交提供了更高层次的方法调用。</p><p id="735f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，该框架为 JSON 字符串转换提供了 JSON 序列化程序。很高兴不再需要 JSON 字符串转换的样板代码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/6414455433d84469f444f173f448636b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tAaI65jnMScC87HH"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">卡夫卡模板</figcaption></figure><p id="7891" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">application.yaml 中<strong class="ky ir"> KafkaProducer </strong>的属性。要启用 Kafka 自动配置，请确保您在其中一个配置类中有<strong class="ky ir"> @EnableKafka </strong>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="dd20" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过自动配置构建的<strong class="ky ir"> KafkaTemplate </strong>，代码行数减少，程序代码看起来更加整洁。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os ot l"/></div></figure></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="866c" class="na lt iq bd lu nb nc nd lx ne nf ng ma jw nh jx md jz ni ka mg kc nj kd mj nk bi translated">消费卡夫卡的信息</h1><h2 id="652e" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">使用 Kafka 客户端库消费消息</h2><p id="5bfd" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">下图向你展示了卡夫卡信息消费的高级序列。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/e8a18ec3b90e98031b7e919ed3669ba5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*knBYD5SKw3P8hhet"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">卡夫卡消费者</figcaption></figure><p id="c0df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，设置一个至少具有以下属性的 Kafka 消费者:</p><ul class=""><li id="2b40" class="oe of iq ky b kz la lc ld lf og lj oh ln oi lr oj ok ol om bi translated"><strong class="ky ir">引导服务器</strong> — Kafka 消息代理地址。docker 容器的 Kafka 消息代理是<strong class="ky ir"> localhost:9092 </strong></li><li id="7017" class="oe of iq ky b kz on lc oo lf op lj oq ln or lr oj ok ol om bi translated"><strong class="ky ir">密钥反串行化器</strong> —将消息密钥的字节数组转换为目标数据类型</li><li id="f698" class="oe of iq ky b kz on lc oo lf op lj oq ln or lr oj ok ol om bi translated"><strong class="ky ir">值反序列化器</strong> —将消息值的字节数组转换为目标数据类型</li><li id="8383" class="oe of iq ky b kz on lc oo lf op lj oq ln or lr oj ok ol om bi translated"><strong class="ky ir">组 Id </strong> — Kafka 跟踪每个消费者组的偏移量。如果提供的组 id 已经存在，消费者将加入该组。否则就会产生新的消费群体。</li><li id="8d97" class="oe of iq ky b kz on lc oo lf op lj oq ln or lr oj ok ol om bi translated"><strong class="ky ir">自动偏移复位</strong> —它决定如果没有找到偏移会发生什么。可能是因为新的消费者群体设置。默认值为“latest ”,即获取最新的偏移量。“最早”意味着从一开始就获得所有消息。</li></ul><p id="cbf8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一整套消费者配置可在<a class="ae kv" href="https://kafka.apache.org/documentation/#consumerconfigs" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="cb3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦消费者准备好了，订阅主题(可能不止一个主题)并对消息进行投票。收到的消息是字节数组，然后根据配置的反序列化器转换成目标数据类型。每个消费者记录由主题、分区、偏移量、消息键和消息值组成。</p><p id="4bdb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，将 offset 提交给 Kafka。基本上，它更新了 Kafka 上的偏移量，以便消费者群体消费下一个偏移量的消息。或者，可以为使用者配置自动提交时间间隔，以便定期自动提交所使用的消息。</p><p id="74a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该示例代码订阅主题“提交索赔”，并使用 Kafka 提交的医疗索赔。使用<strong class="ky ir"> StringDeserializer </strong>将接收到的字节数组转换成字符串。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os ot l"/></div></figure><h2 id="e2cc" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">Spring Boot 的消息消费者</h2><p id="8f97" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">Spring Boot 在 Kafka 客户端库的基础上添加了一个层。与生产者类似，Kafka 消费者的属性可以在 application.yaml 中配置。</p><p id="2181" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更重要的是，Spring Boot 上的反序列化利用了 Spring 的消息传递框架，而不是 Kafka 反序列化器。我们喜欢 Spring 的消息传递组件所提供的特性和灵活性。因此，Kafka 消费者上的反序列化器总是字节数组反序列化器，它什么也不做，只是让字节数组通过。<strong class="ky ir">Spring 消息层的 ByteArrayJsonMessageConverter</strong>负责从字节数组转换成 POJO。</p><p id="450f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，使用<strong class="ky ir"> @KafkaListener </strong>的方法为目标主题触发新的传入消息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/ee28d3967fbef794f995f0fd7d339a63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_vmWPfo7nTJmg7sJ"/></div></div></figure><p id="4fb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的 application.yaml 具有所有消费者属性:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="cc94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在 KafkaConfig.java 定义<strong class="ky ir">ByteArrayJsonMessageConverter</strong>，这样 Spring 框架将使用它将字节数组中的 JSON 值转换为 POJO。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="cb1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，注释<strong class="ky ir"> @KafkaListener </strong>将参数<strong class="ky ir"> id </strong>作为消费群 id，订阅参数<strong class="ky ir"> topics </strong>中定义的主题。处理程序被触发来处理新的医疗索赔。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os ot l"/></div></figure></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="bc79" class="na lt iq bd lu nb nc nd lx ne nf ng ma jw nh jx md jz ni ka mg kc nj kd mj nk bi translated">最后的想法</h1><p id="f014" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">随着越来越多的公司采用 Kafka，对具有 Kafka 集成编码技能的软件工程师提出了更高的要求。与传统消息代理中的消息队列概念不同，Kafka 中的消息像一个记录流，用户通过偏移量读取消息，并且可以访问历史记录。Apache Kafka 为应用程序提供了有用的客户端库，以便与 Kafka 无缝交互。Spring 框架改善了开发人员的体验，因为自动配置完成了大部分设置，并大大减少了样板代码。</p><p id="58c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不要忘了查看 GitHub repos(<a class="ae kv" href="https://github.com/gavinklfong/spring-kafka-demo" rel="noopener ugc nofollow" target="_blank">https://github.com/gavinklfong/spring-kafka-demo</a>)获取示例消息生产者和消费者的完整源代码。</p><p id="dc5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于高吞吐量，Kafka 在应用程序实现 ETL(提取-转换-加载)流的高性能数据流中起着关键作用。如果您有兴趣了解更多，请不要错过我的下一篇文章，关于如何提高 Kafka 消息驱动服务的性能。</p></div></div>    
</body>
</html>