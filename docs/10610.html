<html>
<head>
<title>Performing Bulk Insert Using pgx and CopyFrom</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 pgx 和 CopyFrom 执行大容量插入</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/performing-bulk-insert-using-pgx-and-copyfrom-ce34c8b12bac?source=collection_archive---------1-----------------------#2022-11-16">https://blog.devgenius.io/performing-bulk-insert-using-pgx-and-copyfrom-ce34c8b12bac?source=collection_archive---------1-----------------------#2022-11-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/7c92b8bd44ab2687efe8e33dc42e48b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*u5hvFF3qAVB-KTY2"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">照片由<a class="ae jz" href="https://unsplash.com/@casparrubin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卡斯帕·卡米尔·鲁宾</a>在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="d11c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">PostgreSQL 和 Go，多好的组合啊。让这两者协同工作的方法之一是使用 pgx 库。pgx 是一个纯 Go 数据库驱动程序和 PostgreSQL 工具包。</p><blockquote class="ky kz la"><p id="cd03" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">pgx 驱动程序是一个低级、高性能的接口，它公开了 PostgreSQL 特有的特性，如<code class="fe lf lg lh li b">LISTEN</code> / <code class="fe lf lg lh li b">NOTIFY</code>和<code class="fe lf lg lh li b">COPY</code>。它还包括一个标准<code class="fe lf lg lh li b">database/sql</code>接口的适配器。</p></blockquote><h2 id="d2f3" class="lj lk in bd ll lm ln dn lo lp lq dp lr kl ls lt lu kp lv lw lx kt ly lz ma mb bi translated">介绍</h2><p id="3490" class="pw-post-body-paragraph ka kb in kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx ig bi translated">在开发应用程序的过程中，无论是在启动过程中，还是在实体之间存在多对多关系的情况下，您最终肯定会需要在数据库中执行批量输入。</p><p id="4e6f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本教程中，考虑的例子将是学生在特定的学期中学习特定的学习领域/科目。</p><h2 id="7fef" class="lj lk in bd ll lm ln dn lo lp lq dp lr kl ls lt lu kp lv lw lx kt ly lz ma mb bi translated">场景分解</h2><p id="1b2d" class="pw-post-body-paragraph ka kb in kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx ig bi translated">出于演示的目的，有三个表，一个包含学生数据，第二个包含可用的科目，第三个用于存储学生选择的学习领域。学生和科目表中的种子数据如下所示。</p><figure class="mh mi mj mk gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="e5e7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">主题选择表的结构同样是简化的，如下所示。它包含来自两个主要实体的主键以及选择主题的学年和学期。</p><figure class="mh mi mj mk gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mn"><img src="../Images/6005a82ab1248bcb7de96522724de5db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fPcwqpjDEG-3oZK8T3f1og.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">数据透视表结构</figcaption></figure><p id="5cd9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">数据处理完毕后，让我们开始编码吧。</p><h2 id="d048" class="lj lk in bd ll lm ln dn lo lp lq dp lr kl ls lt lu kp lv lw lx kt ly lz ma mb bi translated">复制自功能</h2><p id="1583" class="pw-post-body-paragraph ka kb in kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx ig bi translated"><code class="fe lf lg lh li b">CopyFrom</code>函数可用于 pgx 连接，它利用 PostgreSQL 的本机<code class="fe lf lg lh li b">copy</code>功能。</p><blockquote class="ky kz la"><p id="fcf7" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">CopyFrom 使用 PostgreSQL 复制协议来执行批量数据插入。它返回复制的行数和一个错误。</p></blockquote><p id="e211" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">PostgreSQL 的本机<code class="fe lf lg lh li b">copy</code>功能允许将数据从一个表复制到一个外部文件或一个命令，反之亦然，允许将数据从一个命令或外部文件复制到数据库中的一个现有表中。</p><p id="b422" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">CopyFrom 函数签名如下</p><p id="9bfb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe lf lg lh li b">func (c *Conn) CopyFrom (ctx context.Context, tableName Identifier, columnNames []string, rowSrc CopyFromSource) (int, error)</code></p><p id="a154" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如上所示，它接受四个参数，第一个是上下文。接下来是执行大容量插入的表的名称。名称必须是<code class="fe lf lg lh li b">Identifier</code>类型，因此必须进行一些转换或转换。第三个参数是按照输入数据的组织顺序排列的表列名。第四个也是最后一个参数是输入数据本身，它将被转换成<code class="fe lf lg lh li b">CopyFromSource</code>类型。</p><h2 id="1874" class="lj lk in bd ll lm ln dn lo lp lq dp lr kl ls lt lu kp lv lw lx kt ly lz ma mb bi translated">使用 CopyFromSource</h2><figure class="mh mi mj mk gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="5b97" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">端点从客户机接收数据(JSON 有效载荷),并将其解包到<code class="fe lf lg lh li b">studentSubjects</code>结构中。值得注意的一个特殊变量是<code class="fe lf lg lh li b">linkedSubejcts</code>变量，它是切片的切片<code class="fe lf lg lh li b">[][]interface{}</code>。</p><p id="703f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">内部切片的类型是<code class="fe lf lg lh li b">interface{}</code>，这意味着它可以接受任何类型的值。<code class="fe lf lg lh li b">[][]interface{}</code>是<code class="fe lf lg lh li b">CopyFromRows()</code>函数期望的类型，它返回一个可由<code class="fe lf lg lh li b">CopyFrom()</code>函数使用的接口。<code class="fe lf lg lh li b">CopyFromRows()</code>签名如下:</p><p id="f64c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe lf lg lh li b">func CopyFromRows(rows [][]interface{}) CopyFromSource</code></p><blockquote class="ky kz la"><p id="b2c6" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">CopyFromRows 在提供的行切片上返回一个 CopyFromSource 接口，使其可由*Conn.CopyFrom 使用。</p></blockquote><p id="07c9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从第 24 行到第 27 行，代码遍历特定学生选择的主题 id，并将主题 id 的实例与学生 id、学年和学期组合成类型为<code class="fe lf lg lh li b">interface{}</code>的单个片段。然后切片被附加到<code class="fe lf lg lh li b">linkedSubjects</code>变量。</p><p id="667a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从第 29 行到第 34 行可以看到 CopyFrom 的用法，使用的参数在上面的小节中有描述。<code class="fe lf lg lh li b">context.Background()</code>用作函数的上下文。表格名称被转换为<code class="fe lf lg lh li b">identifier</code>类型。表的列名只是字符串类型的一个普通的老片段。</p><p id="f2aa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">CopyFrom 相对容易使用，它返回两个参数，复制的行数和一个错误。</p><p id="e70f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">提交给服务器的 JSON 有效负载如下所示。</p><figure class="mh mi mj mk gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="a98d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用 postman，我们可以模拟这个过程，一旦端点被调用，student_subject 表就会有 4 个新行:</p><figure class="mh mi mj mk gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h2 id="4ad0" class="lj lk in bd ll lm ln dn lo lp lq dp lr kl ls lt lu kp lv lw lx kt ly lz ma mb bi translated">更进一步</h2><p id="af7a" class="pw-post-body-paragraph ka kb in kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx ig bi translated">虽然将数据转换成<code class="fe lf lg lh li b">[][]interface{}</code>并使用<code class="fe lf lg lh li b">CopyFromRows()</code>将其包装在<code class="fe lf lg lh li b">CopyFromSource</code>接口中工作良好，但我们可以更进一步，利用<code class="fe lf lg lh li b">CopyFromSlice()</code>来替换循环中的逻辑。</p><figure class="mh mi mj mk gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><blockquote class="ky kz la"><p id="f7a3" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">CopyFromSlice 通过动态函数返回一个 CopyFromSource 接口，使其可由*Conn.CopyFrom 使用。</p></blockquote><p id="41f6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe lf lg lh li b">func CopyFromSlice(length int, next func (int) ([]interface{}, error)) CopyFromSource</code></p><p id="d9b4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如上所示的<code class="fe lf lg lh li b">length</code>参数是我们正在执行批量插入的项目/行数。该函数的第二个参数是一个迭代器函数，它返回一个接口，如上面显示的要点的第 30 行所示。</p><p id="427c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这将产生与第一段代码相同的结果。</p><h2 id="9d06" class="lj lk in bd ll lm ln dn lo lp lq dp lr kl ls lt lu kp lv lw lx kt ly lz ma mb bi translated">结论</h2><p id="82ed" class="pw-post-body-paragraph ka kb in kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx ig bi translated">就这样，您开始在 PostgreSQL 中运行批量插入操作，并使用 pgx。因为 CopyFrom 依赖于本机复制协议，所以它非常强大。</p><blockquote class="ky kz la"><p id="39bb" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">CopyFrom 比只有 5 行的 insert 要快。</p></blockquote><p id="3b6d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要了解更多关于 pgx 的<code class="fe lf lg lh li b">CopyFrom</code>功能和它能提供的所有东西，请在这里通读 pgx 的文档<a class="ae jz" href="https://pkg.go.dev/github.com/jackc/pgx/v4" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="1fa7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您同样可以直接访问与<a class="ae jz" href="https://pkg.go.dev/github.com/jackc/pgx/v4#Conn.CopyFrom" rel="noopener ugc nofollow" target="_blank"> CopyFrom </a>、<a class="ae jz" href="https://pkg.go.dev/github.com/jackc/pgx/v4#CopyFromRows" rel="noopener ugc nofollow" target="_blank"> CopyFromRows </a>和<a class="ae jz" href="https://pkg.go.dev/github.com/jackc/pgx/v4#CopyFromSlice" rel="noopener ugc nofollow" target="_blank"> CopyFromSlice </a>相关的文档。</p></div></div>    
</body>
</html>