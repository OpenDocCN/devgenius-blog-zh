<html>
<head>
<title>Define custom command-line flag types in Go 1.19</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Go 1.19 中定义自定义命令行标志类型</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/define-custom-command-line-flag-types-in-go-1-19-e9a9c8838c5f?source=collection_archive---------3-----------------------#2022-08-04">https://blog.devgenius.io/define-custom-command-line-flag-types-in-go-1-19-e9a9c8838c5f?source=collection_archive---------3-----------------------#2022-08-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="b156" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">命令标志提供了一种设置程序选项的方法。Go 对处理标志有很大的支持。随着 Go 1.19 的发布，Go 标志包中又增加了一个新的内容。标志包现在可以处理自定义结构类型。这意味着程序员可以停止编写代码来后处理命令标志，以实例化自定义结构类型。在这篇文章中，我将详细介绍我实现<code class="fe ki kj kk kl b">encoding.TextUnmarshaler</code>和<code class="fe ki kj kk kl b">encoding.TextMarshaler</code>接口的方法。</p><h1 id="9255" class="km kn in bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">基础知识</h1><p id="f01b" class="pw-post-body-paragraph jk jl in jm b jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd lo kf kg kh ig bi translated">首先，我将定义一个名为 Person 的结构类型。该结构将有 2 个字段，这些字段将被命名为<code class="fe ki kj kk kl b">FirstName</code>和<code class="fe ki kj kk kl b">LastName</code>。我选择了 2 个字段来演示一个字符串如何填充 2 个 struct 字段。下面是结构定义:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/82342727ce0b22b1e351aea957d6a298.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*HASV-AR7YLr49BIwPj2-ug.png"/></div></figure><p id="e501" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下一步我将添加两个方法来输入 Person。这是为了同时满足<code class="fe ki kj kk kl b">encoding.TextMarshaler</code>和<code class="fe ki kj kk kl b">encoding.TextUnmarshaler</code>接口。这将是指定字符串如何成为您的自定义类型，以及您的类型如何成为字符串的区域。以下是我的实现:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/84228636ce79619243e60e94f85b1f77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*UPIrtw_IDnM1PmCVI4oBUw.png"/></div></figure><p id="8380" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在定义<code class="fe ki kj kk kl b">UnmarshalText</code>时，重要的是返回并寻找错误。在这种情况下，在分割字符串之后，我验证数组长度。如果提供了一个名称，则长度将为 1，导致错误提示两个名称。如果你注意到，p 被称为指针，这是为了确保字段数据被设置持久。既然接口令人满意，那么是时候测试实现了。</p><h1 id="2887" class="km kn in bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">履行</h1><p id="e54f" class="pw-post-body-paragraph jk jl in jm b jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd lo kf kg kh ig bi translated">用自定义类型定义和访问标志非常简单。首先，您需要定义一个期望类型的变量。解析后，该变量还将保存标志数据。下一步是调用<code class="fe ki kj kk kl b">flag.TextVar</code>。TextVar 函数将定义一个带有自定义数据类型的标志。下面是将标志<code class="fe ki kj kk kl b">person</code>处理为类型 Person 的实现:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ly"><img src="../Images/0d3f08217ece67f99a8888ef8a59e4d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_gF-aDYj1RXK9QghtFxZOQ.png"/></div></div></figure><p id="e2f0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是终端上的代码:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi md"><img src="../Images/59a044ee9e7fbe4831d2eb29073fc8cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*xcRWonEtrpCHC3kR0QiIjA.gif"/></div></figure><p id="9722" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这张 gif 中，我展示了可能的用例。我故意犯了一个错误来显示我之前写的错误消息，并用 flag -h 调用程序来显示生成的文档。</p><h1 id="9a24" class="km kn in bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">结论</h1><p id="33bb" class="pw-post-body-paragraph jk jl in jm b jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd lo kf kg kh ig bi translated">标志包是提取用户定义的程序选项的好方法。这也是在编写代码的同时生成命令行文档的好方法。从技术上来说，这一新增功能增加了命令行标志的静态类型。它还使程序员能够定义吸引用户的字符串输入格式。</p><h1 id="a171" class="km kn in bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">来源</h1><div class="me mf gp gr mg mh"><a href="https://github.com/cheikhshift/medium_examples/tree/main/flagtypes" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd io gy z fp mm fr fs mn fu fw im bi translated">medium _ examples/flag types at main cheikh shift/medium _ examples</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">中型文章的代码示例。在 GitHub 上创建一个帐户，为 cheikhshift/medium_examples 开发做贡献。</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">github.com</p></div></div></div></a></div></div></div>    
</body>
</html>