<html>
<head>
<title>Factory patternS to hide instantiation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">隐藏实例化的工厂模式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/factory-patterns-to-hide-instantiation-kotlin-d5f01cf01921?source=collection_archive---------8-----------------------#2022-03-14">https://blog.devgenius.io/factory-patterns-to-hide-instantiation-kotlin-d5f01cf01921?source=collection_archive---------8-----------------------#2022-03-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="c9dc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi ki translated"><span class="l kj kk kl bm km kn ko kp kq di"> Y </span> o，欢迎回到我开始传播快乐的设计模式系列！不要吝啬你的时间，看看我以前的帖子，以获得最大的收获:</p><ul class=""><li id="fe74" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">策略模式:<a class="ae la" href="https://medium.com/towardsdev/strategy-pattern-for-independent-algorithms-kotlin-70ed24c7bd8b" rel="noopener">https://medium . com/toward sdev/strategy-pattern-for-independent-algorithms-kot Lin-70 ed 24 c 7 BD 8 b</a></li><li id="aef3" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">观察者模式:<a class="ae la" href="https://medium.com/towardsdev/observer-pattern-for-loose-coupling-kotlin-f5ab804609bb" rel="noopener">https://medium . com/toward sdev/observer-pattern-for-loose-coupling-kot Lin-f5ab 804609 bb</a></li><li id="8dba" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">装饰模式:<a class="ae la" href="https://medium.com/towardsdev/decorator-decorator-pattern-for-object-composition-kotlin-7cec92cbaf7b" rel="noopener">https://medium . com/toward sdev/decorator-decorator-pattern-for-object-composition-kot Lin-7 CEC 92 cbaf 7b</a></li></ul><p id="f231" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另外，通过购买“设计模式”来支持<a class="lg lh ep" href="https://medium.com/u/fbfa235a954c?source=post_page-----d5f01cf01921--------------------------------" rel="noopener" target="_blank">奥赖利媒体</a>:<a class="ae la" href="https://www.oreilly.com/library/view/head-first-design/9781492077992/" rel="noopener ugc nofollow" target="_blank">https://www . oreilly . com/library/view/head-first-Design/9781492077992/</a></p><p id="d42c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">结构:</p><ul class=""><li id="15d2" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">介绍</li><li id="d405" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">问题(在本文中将有 2 个部分)</li><li id="9b98" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">要遵循的设计原则</li><li id="b33e" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">最终解决方案代码(在本文中将有 2 个部分)</li><li id="d04c" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">额外部分</li><li id="b9bc" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">图画</li></ul><p id="1ef1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一点序言:这个模式很长。实际上，它包含了 3 个变量，我将尝试分解它们👹但是要获得最大的收获，请查阅提到的那本书👀</p><p id="260c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，我将在本文中不止一次地提到各种事情，因为这有助于更好地吸收信息，并从不同的角度看待它</p></div><div class="ab cl li lj hr lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ig ih ii ij ik"><h1 id="ec57" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">工厂模式</h1><h2 id="718e" class="mn lq in bd lr mo mp dn lv mq mr dp lz jv ms mt md jz mu mv mh kd mw mx ml my bi translated">介绍</h2><p id="d835" class="pw-post-body-paragraph jk jl in jm b jn mz jp jq jr na jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ig bi translated">在之前的文章中，我已经多次提到:以一种灵活的方式设计你的软件。也就是说，我们不需要改变现有的代码或者分散一堆<code class="fe ne nf ng nh b">if/else</code>语句，这些语句会使代码变得脆弱，容易被修改。</p><p id="225d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了避免这种情况<strong class="jm io">编程到一个接口</strong>而不是具体的父接口，并通过多态来利用方法。我们也不局限于这些类的具体实现。</p><p id="2a89" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看看糟糕的设计:</p><figure class="ni nj nk nl gt nm"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="d07e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">乍一看，我们编程到一个超类型，可以利用多态性。<strong class="jm io">唉</strong>，如果<code class="fe ne nf ng nh b">ParentClass</code>的实现会改变怎么办？🧐加号，那些上面提到的<code class="fe ne nf ng nh b">if/else</code>在这里找到他们的路= &gt;坏！</p><blockquote class="np nq nr"><p id="f732" class="jk jl ns jm b jn jo jp jq jr js jt ju nt jw jx jy nu ka kb kc nv ke kf kg kh ig bi translated">找到不同的东西并封装它们</p></blockquote><p id="473c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如何重构？让我们一步一步来:</p><ol class=""><li id="9350" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh nw kx ky kz bi translated">有什么变化？<em class="ns">创建对象</em></li><li id="2162" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nw kx ky kz bi translated">什么保持不变？应用于对象的方法，因为它们是相同的超类型</li></ol><p id="e1bf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Solution❓ <strong class="jm io">封装</strong>变化的内容(对象创建)并保留方法调用。另外，添加接口/抽象类。</p><blockquote class="np nq nr"><p id="5825" class="jk jl ns jm b jn jo jp jq jr js jt ju nt jw jx jy nu ka kb kc nv ke kf kg kh ig bi translated">对象创建的部分违反了实体的<strong class="jm io">开闭原则</strong>,因为我们需要重新打开代码来放置更改</p></blockquote><p id="f248" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">遇到所谓的<strong class="jm io">简易工厂</strong>哪来的救援！您可以在下面的 repo 中找到源代码:</p><div class="nx ny gp gr nz oa"><a href="https://github.com/SleeplessChallenger/KotlinDesignPatterns/tree/main/src/main/kotlin/4_FactoryPattern/SimpleFactory" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd io gy z fp of fr fs og fu fw im bi translated">KotlinDesignPatterns/src/main/kotlin/4 _ factory pattern/simple factory at main…</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">O'Reilly 设计模式在 Kotlin 的实现。为 sleep less challenger/KotlinDesignPatterns 开发做出贡献…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">github.com</p></div></div><div class="oj l"><div class="ok l ol om on oj oo op oa"/></div></div></a></div><p id="bb85" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，让我们仔细阅读它来修改上面粘贴的设计。</p><ol class=""><li id="f604" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh nw kx ky kz bi translated"><code class="fe ne nf ng nh b">PizzaStore.kt</code>是我们的主文件，类似于<code class="fe ne nf ng nh b">main()</code>函数。我们用<code class="fe ne nf ng nh b">type</code>呼叫<code class="fe ne nf ng nh b">orderPizza()</code>，开始我们的创作。但是这里我们把变化的逻辑移到另一个叫做<code class="fe ne nf ng nh b">SimplePizzaFactory</code>的类中，在那里可以找到变化的部分。</li><li id="b28e" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nw kx ky kz bi translated"><code class="fe ne nf ng nh b">Pizza.kt</code>是我们的<code class="fe ne nf ng nh b">abstract class</code>，它是其他披萨类型的父代:<code class="fe ne nf ng nh b">Cheese</code> &amp; <code class="fe ne nf ng nh b">Pepperoni</code></li><li id="6d02" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nw kx ky kz bi translated">在我们创建了想要的比萨饼之后，我们回到我们的<code class="fe ne nf ng nh b">PizzaStore</code>，在这里利用了超类型的方法(又名<code class="fe ne nf ng nh b">Pizza</code>)。由于我们的 concrete pizza 是子类型，所以我们不关心返回的是哪一个。因此，我们简单地对它应用方法。</li></ol><p id="eaad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们有一个地方，<code class="fe ne nf ng nh b">SimplePizzaFactory</code>所有可能的变化都集中在这里，因此我们不需要重新打开我们的<code class="fe ne nf ng nh b">Store</code>来实现它们🔝</p><p id="ddd1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是…</p><p id="0c86" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">简单工厂本身并不是一种模式。然而，许多开发者认为这是一个 thing‼️</p><p id="0afe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，在这个沉重的介绍之后，让我们进入有趣的部分，探索真实的 patterns🕵🏼‍♂️</p><h2 id="0298" class="mn lq in bd lr mo mp dn lv mq mr dp lz jv ms mt md jz mu mv mh kd mw mx ml my bi translated">问题:第一部分</h2><p id="7755" class="pw-post-body-paragraph jk jl in jm b jn mz jp jq jr na jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ig bi translated">正如你在介绍中看到的，我们需要<strong class="jm io">封装</strong>不同的东西。实际上，我们设法以某种方式做到了这一点，还能走得更远吗？</p><p id="ea4b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你看，在我们的<code class="fe ne nf ng nh b">SimpleFactory</code>中，我们的对象<strong class="jm io">工厂</strong>创造了所有种类的产品。但是如果我们想要有更多的变化呢？</p><p id="70f8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，我们有<code class="fe ne nf ng nh b">abstract creator</code>也就是<strong class="jm io">客户端</strong>和许多<code class="fe ne nf ng nh b">concrete creators</code>也就是<strong class="jm io">子客户端</strong>。在<strong class="jm io">客户端</strong>中，我们有<em class="ns">抽象工厂方法</em>，然后在<strong class="jm io">子客户端中实现。</strong></p><p id="ffb4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，我们有<em class="ns">许多子客户</em>，这些客户希望拥有自己的产品<strong class="jm io">继承<em class="ns">抽象产品</em>的</strong>。当父 creator 的子类可以处理<strong class="jm io">工厂方法</strong>中的所有实例化，从而只返回产品时，我们该如何做呢？然后产品将由抽象创建者处理并返回</p><p id="9a19" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">哇…🤯我知道这看起来很模糊，所以让我们一步一步来。</p><ol class=""><li id="8138" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh nw kx ky kz bi translated">我们在子客户中制造工厂方法。这个工厂方法在抽象创建器中实现了<code class="fe ne nf ng nh b">abstract</code>工厂方法</li><li id="9e39" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nw kx ky kz bi translated">这些子客户端处理实例化</li><li id="e58d" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nw kx ky kz bi translated">它们返回 object(是抽象对象的子类)</li><li id="0f45" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nw kx ky kz bi translated">我们的<em class="ns">抽象客户端</em>对其进行进一步处理，并将处理后的对象返回给我们的具体子客户端，具体子客户端再将其呈现给我们(实际上，该方法是从<strong class="jm io">子客户端</strong>调用的，因此该方法将对象返回给我们)</li></ol><pre class="ni nj nk nl gt oq nh or os aw ot bi"><span id="83d6" class="mn lq in nh b gy ou ov l ow ox">              abstract creator<br/>               /           \<br/>           sub-creator1    sub-creator2<br/>           /   |    \        /   |   \<br/>                                            <br/>concrete product1 ..2     another concrete product1 ..2</span><span id="e92a" class="mn lq in nh b gy oy ov l ow ox">Those products inherit from abstract product</span></pre><p id="a3da" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">看看我们<strong class="jm io">如何将</strong>抽象类创建者<em class="ns">与子客户端中的<em class="ns">具体产品</em>分离。</em></p><blockquote class="np nq nr"><p id="9910" class="jk jl ns jm b jn jo jp jq jr js jt ju nt jw jx jy nu ka kb kc nv ke kf kg kh ig bi translated">别担心，我们会一步一步来的</p></blockquote><p id="e0fe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，在所有这些模式中，<code class="fe ne nf ng nh b">abstract creator</code>是我们的客户端。我们<strong class="jm io">封装</strong>子客户端中的变更，并隔离其中的所有内容。所以，我们的客户不需要知道太多，只要有那个产品要处理(客户只知道这个产品将是<code class="fe ne nf ng nh b">abstract product)</code>的子类型)</p><h2 id="3c78" class="mn lq in bd lr mo mp dn lv mq mr dp lz jv ms mt md jz mu mv mh kd mw mx ml my bi translated">最终解决方案代码:第一部分</h2><div class="nx ny gp gr nz oa"><a href="https://github.com/SleeplessChallenger/KotlinDesignPatterns/tree/main/src/main/kotlin/4_FactoryPattern/Factory" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd io gy z fp of fr fs og fu fw im bi translated">KotlinDesignPatterns/src/main/kotlin/4 _ Factory pattern/Factory at main…</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">O'Reilly 设计模式在 Kotlin 的实现。为 sleep less challenger/KotlinDesignPatterns 开发做出贡献…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">github.com</p></div></div><div class="oj l"><div class="oz l ol om on oj oo op oa"/></div></div></a></div><p id="acb7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看看具体的例子来澄清所有的骚动🙌</p><ol class=""><li id="8144" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh nw kx ky kz bi translated">我们有<code class="fe ne nf ng nh b">abstractCreator.kt</code>，它有抽象方法<code class="fe ne nf ng nh b">createObject()</code>。<em class="ns">但是我们不直接用这个方法。</em></li><li id="d995" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nw kx ky kz bi translated">我们有子类(子客户端):<code class="fe ne nf ng nh b">concreteCreator</code> &amp; <code class="fe ne nf ng nh b">anotherConcreteCreator</code>，这个<code class="fe ne nf ng nh b">abstractCreator</code>，是我们本地的创作者。那些创建者<strong class="jm io">覆盖/实现了</strong>来自父类的抽象方法，而父类实际上是我们的<strong class="jm io">工厂</strong>。所以，那些子客户端是我们的<code class="fe ne nf ng nh b">abstractCreator</code>的子客户端可以访问父客户端的方法。我们从<strong class="jm io">客户端</strong>(父客户端)调用方法，在我的例子中，是<code class="fe ne nf ng nh b">giveType</code>触发了特定子客户端的<code class="fe ne nf ng nh b">createObject</code>。</li><li id="505f" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nw kx ky kz bi translated">那个<code class="fe ne nf ng nh b">createObject</code>也是我们的<strong class="jm io">工厂</strong>本身，它处理对象实例化。它将具体产品返回给我们的<code class="fe ne nf ng nh b">abstractClient</code> <code class="fe ne nf ng nh b">giveType</code>方法，具体产品是我们抽象产品的子产品。</li><li id="880c" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nw kx ky kz bi translated">在这个父方法中，我们被限制在<strong class="jm io">产品</strong>的<code class="fe ne nf ng nh b">abstract class</code>(父)，这允许我们应用来自<strong class="jm io">抽象产品</strong>的方法(回忆多态及其用法)</li><li id="bd4f" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nw kx ky kz bi translated">子产品因客户而异。即<code class="fe ne nf ng nh b">concreteCreator</code>有 2 个<code class="fe ne nf ng nh b">concreteProducts</code>(来自抽象产品)<code class="fe ne nf ng nh b">anotherConcreteCreator</code>还有 2 个<code class="fe ne nf ng nh b">anotherConcreteProducts</code>(又是<strong class="jm io">从抽象产品继承</strong>)。</li><li id="6ccf" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nw kx ky kz bi translated">那些产品，作为子类，被返回到<code class="fe ne nf ng nh b">abstractCreator</code>中的<code class="fe ne nf ng nh b">giveType</code>方法，在那里来自<code class="fe ne nf ng nh b">abstractProduct</code>的方法被应用。</li><li id="66f6" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nw kx ky kz bi translated">然后，处理后的对象返回给我们，我们可以进一步处理它。(我在上面解释了为什么我们可以利用父方法，并且这个方法直接给我们结果)</li><li id="e0a8" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nw kx ky kz bi translated">我们在<code class="fe ne nf ng nh b">abstractCreator</code>中的<code class="fe ne nf ng nh b">giveType()</code>是从特定类型的产品中分离出来的<strong class="jm io"/>。只要这个产品是抽象产品的一个<strong class="jm io">子类，我们不关心哪个客户实际上把产品返回给我们。</strong></li></ol><p id="c57d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">呃……😲很艰难。我希望你得到了这种分离工厂的主要优点。</p><p id="d971" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">同样，好处是我们可以尽可能多地参数化/调整我们的创建(也就是子代中的<strong class="jm io">工厂方法</strong>),只要它返回期望的对象。</p><blockquote class="np nq nr"><p id="203a" class="jk jl ns jm b jn jo jp jq jr js jt ju nt jw jx jy nu ka kb kc nv ke kf kg kh ig bi translated">通过使用<strong class="jm io">工厂模式</strong>我们:</p><p id="946a" class="jk jl ns jm b jn jo jp jq jr js jt ju nt jw jx jy nu ka kb kc nv ke kf kg kh ig bi translated">-封装类/方法中不同的部分</p><p id="0fad" class="jk jl ns jm b jn jo jp jq jr js jt ju nt jw jx jy nu ka kb kc nv ke kf kg kh ig bi translated">-编程到一个接口，而不是一个特定的实现。也就是说，我们知道工厂返回<code class="fe ne nf ng nh b">abstractProduct</code>的子类型</p></blockquote><h2 id="ad77" class="mn lq in bd lr mo mp dn lv mq mr dp lz jv ms mt md jz mu mv mh kd mw mx ml my bi translated">要遵循的设计原则</h2><p id="3cb5" class="pw-post-body-paragraph jk jl in jm b jn mz jp jq jr na jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ig bi translated">固体的另一个原理😈</p><ol class=""><li id="b24c" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh nw kx ky kz bi translated">依赖倒置原则:我们依赖抽象，而不是具体的类</li></ol><p id="ab40" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可能会问自己:这听起来类似于上面提到的<em class="ns">“编程到一个接口而不是特定的实现”</em>。但是这个原则规定了这样一个事实:我们的高级组件&amp;低级组件不应该相互依赖，它们<strong class="jm io">必须依赖于相似的抽象。</strong></p><p id="be73" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以下是对原则的违反:</p><pre class="ni nj nk nl gt oq nh or os aw ot bi"><span id="9d4b" class="mn lq in nh b gy ou ov l ow ox">                   abstractCreator<br/>                     /   |     \<br/>       concreteProduct1        concreteProduct3<br/>                   concreteProduct2</span></pre><p id="3889" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们本着这个原则来做:</p><pre class="ni nj nk nl gt oq nh or os aw ot bi"><span id="6b23" class="mn lq in nh b gy ou ov l ow ox">                      abstractCreator<br/>                           |<br/>                       abstractProduct<br/>                     /      |       \<br/>         concreteProduct1        concreteProduct3<br/>                   concreteProduct2</span></pre><p id="c8f2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">看看<strong class="jm io">高层组件</strong> (abstractCreator) &amp; <strong class="jm io">低层组件</strong> (concreteProducts)如何依赖一个抽象。回忆代码演练中的<code class="fe ne nf ng nh b">giveType</code>。这取决于<em class="ns">抽象产品类型</em>。在子客户端中创建的产品也依赖于<strong class="jm io">相同的</strong> <em class="ns">抽象产品类型</em>。</p><h2 id="67c3" class="mn lq in bd lr mo mp dn lv mq mr dp lz jv ms mt md jz mu mv mh kd mw mx ml my bi translated">问题:第二部分</h2><p id="e82c" class="pw-post-body-paragraph jk jl in jm b jn mz jp jq jr na jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ig bi translated">但是，如果我们不想简单地创建最终产品，而是用产品系列对其进行微调，该怎么办呢？也就是说，想象我们不是简单地创建具有硬编码值的<code class="fe ne nf ng nh b">concreteProduct</code>，而是在它里面有工厂，子产品有它们自己的<code class="fe ne nf ng nh b">interface</code>等等？</p><p id="defc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另外，如果我们有相同的<code class="fe ne nf ng nh b">concreteProduct</code>，只是子产品的类型不同，那会怎么样？即<code class="fe ne nf ng nh b">Colour</code>是一个抽象类，它有两个相似的孩子:<code class="fe ne nf ng nh b">Red</code> &amp; <code class="fe ne nf ng nh b">Blue</code>。在这种情况下，我们不需要像<strong class="jm io">工厂模式</strong>中那样有重复的代码。</p><p id="2651" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">换句话说，我们已经设法创造了一个所谓的成分家族，来填充我们相同的产品。</p><blockquote class="np nq nr"><p id="0b44" class="jk jl ns jm b jn jo jp jq jr js jt ju nt jw jx jy nu ka kb kc nv ke kf kg kh ig bi translated">在我的代码中，产品系列是面团、奶酪、浇头</p></blockquote><p id="9572" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请阅读以下段落，直到它铭刻在你的脑海中:</p><p id="827a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi ki translated"><span class="l kj kk kl bm km kn ko kp kq di">一个</span> <strong class="jm io">抽象工厂</strong>允许我们通过为子工厂(不是<strong class="jm io">子客户/子创建者</strong>)提供接口来创建产品系列。结果，我们的代码是<strong class="jm io">与<em class="ns">混凝土工厂</em>分离</strong>，使得<em class="ns">混凝土产品</em>充满所谓的配料。因此，我们可以有<em class="ns">多家工厂</em>生产<strong class="jm io">相同的</strong>产品，而<em class="ns">的含量</em>不同。说到被<strong class="jm io">解耦</strong>，可以追溯到产品与其他代码的<strong class="jm io">松耦合</strong>，即<strong class="jm io">子客户端/客户端</strong>代码(在我们这里是<strong class="jm io">具体创建者/抽象</strong>)保持不变。因此，<strong class="jm io">每个工厂都创造了自己的产品系列</strong>。</p><p id="ee09" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi">I’m serious, もう一度読んでください！👺</p><h2 id="1d08" class="mn lq in bd lr mo mp dn lv mq mr dp lz jv ms mt md jz mu mv mh kd mw mx ml my bi translated">最终解决方案代码:第二部分</h2><p id="f1af" class="pw-post-body-paragraph jk jl in jm b jn mz jp jq jr na jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ig bi translated">现在让我们仔细阅读<strong class="jm io">抽象工厂</strong>的代码</p><div class="nx ny gp gr nz oa"><a href="https://github.com/SleeplessChallenger/KotlinDesignPatterns/tree/main/src/main/kotlin/4_FactoryPattern/AbstractFactory" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd io gy z fp of fr fs og fu fw im bi translated">KotlinDesignPatterns/src/main/kotlin/4 _ factory pattern/abstract factory at main…</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">O'Reilly 设计模式在 Kotlin 的实现。为 sleep less challenger/KotlinDesignPatterns 开发做出贡献…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">github.com</p></div></div><div class="oj l"><div class="pa l ol om on oj oo op oa"/></div></div></a></div><ol class=""><li id="ae51" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh nw kx ky kz bi translated">是我们心爱的工厂。它定义了所有其他工厂要实现的方法。</li><li id="ded7" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nw kx ky kz bi translated"><code class="fe ne nf ng nh b">TokyoIngredientFactory.kt</code>是实现所有方法的具体工厂。回想一下上面写的东西:这些方法本身就是小厂。</li><li id="ee98" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nw kx ky kz bi translated"><code class="fe ne nf ng nh b">AbstractPizzaStore.kt</code>是我们的抽象创建者/客户，它定义了<strong class="jm io">抽象工厂方法</strong>，以及一个我们将用来获得产品的方法(<code class="fe ne nf ng nh b">createPizza()</code>-我们的工厂方法)</li><li id="252d" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nw kx ky kz bi translated"><code class="fe ne nf ng nh b">TokyoPizzaStore.kt</code>是拥有混凝土工厂的子客户/创建者。这个子客户把工厂放在混凝土产品里面。</li><li id="b9a5" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nw kx ky kz bi translated"><code class="fe ne nf ng nh b">Pepperoni.kt</code>等披萨都是<code class="fe ne nf ng nh b">AbstractPizza</code>的子产品。这里回忆一下<strong class="jm io">反转</strong>的依赖关系。</li><li id="f30b" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nw kx ky kz bi translated"><code class="fe ne nf ng nh b">Cheese</code>、<code class="fe ne nf ng nh b">Dough</code>为混凝土配料接口。</li></ol><p id="87b5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么，一切是如何运作的呢？</p><p id="606f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<code class="fe ne nf ng nh b">main.kt</code>中，我们实例化<strong class="jm io">子客户端</strong>并使用来自<strong class="jm io">抽象客户端</strong>的方法。Steps☝️:</p><ol class=""><li id="b74a" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh nw kx ky kz bi translated">从<strong class="jm io">子客户端</strong>中，我们调用<strong class="jm io">父客户端</strong>(带有披萨类型)方法(在我的例子中是<code class="fe ne nf ng nh b">orderPizza()</code>)，该方法触发子客户端中实现的工厂方法。</li><li id="19bf" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nw kx ky kz bi translated"><strong class="jm io">工厂方法</strong></li><li id="ec84" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nw kx ky kz bi translated">这个<strong class="jm io">工厂</strong>实现了<strong class="jm io">抽象工厂</strong>。</li><li id="cd87" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nw kx ky kz bi translated">然后，从开始的父中的那个方法，<code class="fe ne nf ng nh b">orderPizza()</code>，使用抽象的比萨方法，<code class="fe ne nf ng nh b">prepare()</code>，在具体的比萨中实现。那种方法使用放在混凝土比萨饼里面的工厂<strong class="jm io"/>。</li><li id="7dfc" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nw kx ky kz bi translated">然后在父方法<code class="fe ne nf ng nh b">orderPizza()</code>中，它进一步处理 pizza。最后，我们收到了比萨饼。</li><li id="d397" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh nw kx ky kz bi translated">因此，正如在开始时提到的，如果内部材料相同，我们不需要相同比萨饼的类别数。只要把工厂放在里面，这将解耦代码。</li></ol><p id="3010" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">呃…我知道，很多信息，很难跑题。</p><blockquote class="np nq nr"><p id="2cb5" class="jk jl ns jm b jn jo jp jq jr js jt ju nt jw jx jy nu ka kb kc nv ke kf kg kh ig bi translated">如果你没有得到任何东西，不要羞于再读一遍并提问</p></blockquote><h2 id="4a41" class="mn lq in bd lr mo mp dn lv mq mr dp lz jv ms mt md jz mu mv mh kd mw mx ml my bi translated">额外部分</h2><ul class=""><li id="9874" class="kr ks in jm b jn mz jr na jv pb jz pc kd pd kh kw kx ky kz bi translated">在抽象工厂模式代码中，我们的<strong class="jm io">存储</strong>是<strong class="jm io">客户端</strong>，工厂方法为<code class="fe ne nf ng nh b">createPizza()</code>。然后，在<code class="fe ne nf ng nh b">Pepperoni/MeatPizza</code>我们依次有小工厂。</li><li id="f1b9" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated"><code class="fe ne nf ng nh b">Pizza</code>与<strong class="jm io">和</strong>从地区差异中分离出来，看起来像是一个充满了工厂的模式，这些工厂有他们自己的一套配料。例如，<code class="fe ne nf ng nh b">Pepperoni</code>可以填充各种利用不同成分的工厂。只要这些工厂坚持特定的<code class="fe ne nf ng nh b">interface</code>成分，即他们创造子成分(像<code class="fe ne nf ng nh b">ThickCrust</code>工具<code class="fe ne nf ng nh b">Dough</code>等)，一切都在运转。</li><li id="b286" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">看，<strong class="jm io">抽象工厂</strong>中的每个方法本身就是一个小工厂。为什么？- &gt;那些方法在它们内部进行对象实例化。另外，<em class="ns">具体工厂</em>覆盖<em class="ns">抽象工厂</em>的<em class="ns">抽象方法</em>。这有点类似于<strong class="jm io">工厂模式</strong>中的方法覆盖，但是我们只覆盖了一个方法。</li><li id="f4dd" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">在<code class="fe ne nf ng nh b">Abstract Factory</code>的源代码中你可以找到文件夹:<code class="fe ne nf ng nh b">Modified Version</code>。它是由我工作时的高级开发人员修改的。坦率地说，我喜欢他的补充👐如果你想让我做一个代码演练——写在评论里！</li></ul><h2 id="463c" class="mn lq in bd lr mo mp dn lv mq mr dp lz jv ms mt md jz mu mv mh kd mw mx ml my bi translated">图画🎨</h2><p id="98e1" class="pw-post-body-paragraph jk jl in jm b jn mz jp jq jr na jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ig bi translated"><strong class="jm io">简单工厂&amp;工厂模式</strong></p><p id="eef6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">工厂模式</strong></p><figure class="ni nj nk nl gt nm gh gi paragraph-image"><div role="button" tabindex="0" class="pf pg di ph bf pi"><div class="gh gi pe"><img src="../Images/267a6d4ac91563441ec16afbb5c27116.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8is_eL_7URUJV5CpeNmY-g.jpeg"/></div></div></figure><p id="9d60" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">抽象工厂模式</strong></p><figure class="ni nj nk nl gt nm gh gi paragraph-image"><div role="button" tabindex="0" class="pf pg di ph bf pi"><div class="gh gi pe"><img src="../Images/c234887f2e562f1130a0146857411797.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LJPuaok-kdLXLnVH-4XNZQ.jpeg"/></div></div></figure><p id="e136" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我的画能让我理清所有事物的运作方式。我知道我的涂鸦可能看起来很可怕😵，但如果你发现他们至少有一点点洞察力，那么我是 elated✌️</p><h2 id="1d57" class="mn lq in bd lr mo mp dn lv mq mr dp lz jv ms mt md jz mu mv mh kd mw mx ml my bi translated">结尾部分👣</h2><p id="ee14" class="pw-post-body-paragraph jk jl in jm b jn mz jp jq jr na jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ig bi translated">在最后一部分，让我们观察一下抽象工厂模式的<strong class="jm io">工厂</strong> &amp; <strong class="jm io">的学术定义</strong></p><blockquote class="np nq nr"><p id="362f" class="jk jl ns jm b jn jo jp jq jr js jt ju nt jw jx jy nu ka kb kc nv ke kf kg kh ig bi translated"><strong class="jm io">工厂模式</strong>:为对象创建定义一个接口，但是强制子类实现它。这种模式允许主类将对象实例化推迟到子类</p><p id="aa43" class="jk jl ns jm b jn jo jp jq jr js jt ju nt jw jx jy nu ka kb kc nv ke kf kg kh ig bi translated"><strong class="jm io">抽象工厂模式</strong>:定义相关产品族创建的接口，不指定产品的具体类别</p></blockquote><p id="a210" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种模式肯定是漫长的。需要多少遍就仔细读多少遍。并且可以自由提问！👍希望你明白这两种模式的区别，但是如果不明白，你知道该怎么做，该去哪里问😇</p><p id="1240" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以找到我:</p><ul class=""><li id="abe2" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">领英:<a class="ae la" href="http://www.linkedin.com/in/sleeplesschallenger" rel="noopener ugc nofollow" target="_blank">www.linkedin.com/in/sleeplesschallenger</a></li><li id="c21c" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">GitHub:<a class="ae la" href="https://github.com/SleeplessChallenger" rel="noopener ugc nofollow" target="_blank">https://github.com/SleeplessChallenger</a></li><li id="fb93" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">leet code:<a class="ae la" href="https://leetcode.com/SleeplessChallenger/" rel="noopener ugc nofollow" target="_blank">https://leetcode.com/SleeplessChallenger/</a></li><li id="9a2c" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">电报:@无眠挑战者</li></ul></div></div>    
</body>
</html>