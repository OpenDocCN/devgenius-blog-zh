# Selenium 用例:提取 IMDb 用户评级

> 原文：<https://blog.devgenius.io/a-selenium-use-case-extract-imdb-user-rating-ff827ec9c6d8?source=collection_archive---------10----------------------->

![](img/918e325283a01e139727f4635a4bf846.png)

几个月前，我在 Kaggle 上发现了三个数据集，其中包含了关于在[网飞](https://www.kaggle.com/datasets/shivamb/netflix-shows)、[亚马逊 Prime Video](https://www.kaggle.com/datasets/shivamb/amazon-prime-movies-and-tv-shows) 和[迪士尼+](https://www.kaggle.com/datasets/shivamb/disney-movies-and-tv-shows) 上可获得的标题的信息。作为一个电影和电视节目的超级粉丝，我认为看看这些流媒体平台根据用户提供的内容质量会很有趣。由于没有包含这些信息的栏目，我不得不自己想办法填写。

为了实现这一点，我创建了一个函数，在 IMDb 上搜索特定的标题，选择正确的结果，并提取其评级，将其插入到数据集中。在这篇文章中，我将解释我是如何从从 IMDb 网站上抓取评分的最初步骤开始构建这个功能的。

如果你想看到整个过程，你可以查看我开发这个项目的笔记本。该文件被命名为 **data_enriching** 。

在这个项目中，我将使用 Selenium 和 Pandas 中的以下模块:

![](img/0b2c8a47335891bcdded169649e688f1.png)

## 初始化 web 驱动程序并打开 IMDb

在使用 Selenium 抓取网站之前，我需要初始化一个 WebDriver，在这里是 Google Chrome，然后转到我想要的 url:

```
os.environ['WDM_LOG_LEVEL'] = '0'
browser = webdriver.Chrome(ChromeDriverManager().install())
wait = **WebDriverWait**(browser, 10)
browser.maximize_window()
browser.**get**("[https://www.imdb.com/](https://www.imdb.com/)")
```

有些网站加载时间较长，我无法直接与它们的元素(按钮、标签、链接……)交互，如果我尝试的话，会收到一条**元素不可交互**的消息。为了避免这种情况，我创建了一个名为 **wait** 的变量，其中我使用了 **WebDriverWait** 类来设置在执行任何操作之前的 10 秒限制。

如果一切正常，我应该会看到下面的页面:

![](img/055b10331b4b118e9741c0d42c7fd510.png)

## 搜索特定标题

现在，我将进入搜索选项卡，键入我想要的任何名称，如“星际”。在正常情况下，我会使用鼠标和键盘来完成这项工作，但是我可以使用 Selenium 来自动完成这个过程。

首先，我将使用我之前创建的 wait 变量和 Selenium 的 **expected conditions (ec)** 模块的组合，将标识搜索选项卡的 web 元素存储在一个变量中，这将允许我确保在满足某个条件之前不执行任何操作，在本例中，直到 web 元素可点击，然后我将使用 **send_keys()** 方法键入名称“Interstellar”。

![](img/844b234488b876c9c32e49ea437873a1.png)

姓名发送到搜索选项卡后，我可以单击搜索按钮来查看结果列表。这个过程和以前一样，但是因为浏览器现在已经完全加载，我可以简单地使用 **find_element( By。ID)** 方法来识别搜索按钮，我将使用 **click()** 来代替 send_keys()。

![](img/c32b83acc216bf55d58a18350a1abfdc.png)

在执行完这些行之后，我应该会看到下面的页面:

![](img/90a6e7d47a00753cc9b35d9696fc1901.png)

## 访问第一结果并提取其用户评级

可以看到，一个标题可以返回许多结果，这意味着我需要找到一种方法来确保我选择的是与我的数据集上的条目相匹配的一个。稍后我将解释我是如何解决这个问题的，但是现在，让我们使用 XPath 提取第一行的评级:

![](img/87e033fc54fda3bbbef97fd8f4f67134.png)

执行后，我应该会看到下面的页面:

![](img/7dd5c6ecbd32fc67d561ac8590c2ead6.png)

在所有可用的元素中，我想提取分子上的数字，我在红框中突出显示了这个数字。为此，我将使用它的 **class_name** 来查找它，然后提取它的 **text** 值，返回“8.6”。

![](img/d7ba1bb33c8a0fc18d994bd8d83ce14a.png)

现在步骤已经很清楚了，我可以创建一个函数来提取数据集上每个条目的 IMDB 评级。

# 创建一个使用熊猫 DF 的函数

在我开始构建我的函数之前，有一个问题需要首先解决。正如我在**搜索特定标题**一节中提到的，一个标题可以返回许多结果，因此我需要找到一种方法来确保我提取的那个标题的评级与我的数据集上的条目完全匹配。

数据集的两列是**导演**和**演员表**，它们包含演员表中不同成员的名字。在 IMDb 查看任何特定结果时，也可以获得此信息。

![](img/ebbeb099609be59ab1bfabe27391c3b0.png)

因此，我决定创建一个名为 **full_cast** 的额外列，它将包含来自 director 和 cast 列的所有值。此外，我可以使用 Selenium 提取列表中所有演职人员的姓名，所以剩下要做的就是提取匹配结果的等级。

这个函数有点长，有很多步骤，所以我将把它分成三个部分来解释:

1.  初始设置

2.单独访问每个搜索结果并提取演职人员姓名

3.将 IMDb 上的姓名与我的数据集中的姓名进行比较，找到匹配时提取评分

## 初始设置

我的函数要做的第一件事是将 full_cast 列中的所有名称和结果列表的长度分别存储在两个变量中。

![](img/fce726488cf83d3cbf376ab02ec28a6b.png)

为了创建 full_cast 列表，我将使用 **item()** 后跟 **split()** 函数，使用逗号(，)作为分隔符来分隔值。

接下来，该功能将初始化网络驱动程序，进入 IMDb 主页，并搜索相应的标题，如前一节所述，一旦到达搜索结果页面，乐趣就开始了。

## 选择正确的标题并提取其等级

一旦搜索完成，我会看到一个表格，其中包含所有符合星际名称的条目，我可以通过点击它们进入它们的主页。

为此，我需要采取两个步骤:

1.  将带有搜索结果的表的 web 元素存储在一个变量中
2.  用构成表格的行(web 元素)创建一个列表

![](img/9baaa7166c55a79b885ad180d5198d7b.png)

我首先使用 class_name 搜索表，并使用 tag_name ( **tr** )提取它的所有行，这意味着**表行。**结果列表如下所示:

![](img/a5b54cff59175990cc7ff996874eff5c.png)

如果你不明白这些线是什么意思，不必惊慌。重要的是要知道搜索返回的结果总数。

因为我想将每个条目的转换信息与我的数据集上可用的转换信息进行比较，所以我需要单独访问每个条目，这可以通过使用它们的 XPath 来实现，第一个元素如下所示:

```
/html/body/div[3]/div/div[2]/div[3]/div[1]/div/div[2]/table/tbody/**tr[1]**/td[2]/a
```

这是一条显示通向我正在寻找的元素的步骤的路线，在本例中是第一行。在斜线之间的元素中，我感兴趣的是前面提到的表示**表格行**的 **tr[]，**。括号内的数字标识了该路径发出信号的行数，这是我需要操作来访问表上的每个结果的内容。

首先，我将使用一个 **FOR 循环**遍历一个范围，从 0 开始，到我用所有搜索结果( **search_result** )创建的列表的长度为止。

在循环内部，我将使用字符串格式用我刚刚创建的范围的值来更改 XPATH 的 **tr[]** 元素的编号，这样我就可以访问所有结果。

![](img/7d41791001ac00a1f77051f543496a86.png)

需要指出的是，Python 中的索引是从 0 开始的，而 HTML 中的索引是从 1 开始的，所以我必须使用 **(rg + 1)** 来更改这个值。

访问第一个结果页面后，我将使用以下代码行提取可用的演员姓名:

![](img/3cec1dbe5eff7459f6e6b43fa96f1054.png)

按照与搜索结果相同的过程，我将在一个列表( **members_imdb_list)** 中存储与演职人员一起构成表格的所有元素，但提取其中的文本元素，这是我正在寻找的名称，就像我检索评级一样。

## **寻找列表之间的匹配并提取用户评级**

现在，我将使用第二个 FOR 循环来遍历我在开始时创建的列表( **full_cast** )，其中包含我的数据集中存储的名称，以检查是否有任何与包含 IMDb 值的列表( **members_imdb_list** )匹配的内容

在进入这个循环之前，我创建了一个名为 **count** 的变量，它将在每次检查一个新成员时增加 1 个单位。如果变量等于 **full_cast** 列表的长度，它将中断循环。

![](img/ef6d9a828247ce3febb8736e93136b90.png)

如果存在匹配，该函数将在网页中查找存储评级的元素，以返回其文本值，如前所述，并通过**关闭 WebDriver。关闭()**方法。

如果没有匹配的名字，我必须返回到搜索页面，以便第一个循环可以转到下一个结果。如果我不这样做，我将收到一个错误，因为我将试图访问 WebDriver 当前所在的页面中的一个元素。这可以通过 **back()** 方法来完成，该方法执行与单击指向左边的箭头相同的动作。

## 将函数应用于数据集的标题列

在包括一些错误处理以确保即使没有某个标题的结果或者在 tha 数据集和 IMDb 之间没有匹配，该函数也能继续工作之后，该函数是完整的，我们可以将它应用于我的数据集:

![](img/3d41453b42b24ff141054a5f7eeb04fa.png)

我设置了我的 new_column 的名称( **imdb_rating** )，我将在其中存储评级值，然后使用 **map()** 函数将我的函数应用到 **title** 列。我使用 list 以便它返回实际值而不是迭代器。

一旦这一行被执行，整个过程将开始，我会看到所有被搜索的标题出现标签。浏览所有数据集条目需要一段时间，所以我建议将其分成更小的部分。一旦执行完成， **imdb_rating** 列将出现在我的数据集中，大部分评级应该会出现。我说大多数，是因为有些头衔在 IMDb 可能不存在，或者因为被比较的名字有细微的差别，不允许找到匹配。

![](img/5b1018ff74e8adcd42019caacba0c3aa.png)