<html>
<head>
<title>Different ways to sort an array in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 中数组排序的不同方法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/different-ways-to-sort-an-array-in-java-3f3d201c48a4?source=collection_archive---------6-----------------------#2020-09-14">https://blog.devgenius.io/different-ways-to-sort-an-array-in-java-3f3d201c48a4?source=collection_archive---------6-----------------------#2020-09-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d996cccc0f091ce48a4c081f89d8bb54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eA9dSht5cvDaKrvQ"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><a class="ae jz" href="https://unsplash.com/@sweetpagesco?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">莎拉·布朗</a>在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="67d0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在 java 中，主要有两种方法对数组进行排序。</p><p id="8def" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可以让 java 类实现 comparable，并实际实现 compareTo 方法。这样，Arrays.sort 将确切地知道它将依靠什么算法来对数组进行排序。</p><p id="291c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">或者您可以实现一个比较器类，通过名称或 id 来比较对象。然后，在您的客户端代码中，您可以使用比较器作为第二个参数来执行 Arrays.sort。</p><p id="155e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们深入可比和比较器之前，让我们先来讨论一下这两者是如何工作的。</p><p id="d6d9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">可比较的</p><p id="c340" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Comparable 是一个可以由任何 java 类实现的接口。它为一个对象提供了与另一个对象进行比较的兼容性，以便进行排序。</p><p id="c947" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此外，实现 comparable 接口的类可以通过实现 compareTo 方法自定义排序方式。</p><p id="7692" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">事实上，实现 comparable 接口的类必须实现 compareTo 方法。</p><p id="e487" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看看下面这个实现 comparable 的类:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="b36d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如你已经注意到的，当一个类实现 comparable 时，你也必须指定泛型。这个泛型将是可比较的对象/类的类型。</p><p id="fb1f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在文件内部，您还需要实现一个 compareTo 方法。这是你决定你想要你的类对象如何排序的地方。在上面的场景中，我们希望所有对按照 endTime 升序排序，就像 compareTo 方法中规定的那样。</p><p id="9bcd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果结束时间是一样的呢？我们还可以执行以下操作:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="f07f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这里，如果配对的结束时间相同，那么我们可以按开始时间升序对配对进行排序。</p><p id="5aeb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">到目前为止，我们已经展示了实现 comparable 的类是怎样的。当客户机实际上有一个 pair 数组并对它们进行排序时，看起来是什么样的？</p><p id="3cda" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们来看看:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="10a3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">虽然使一个类实现具有可比性确实给了它对象类以我们想要的方式排序的能力，但当有一个数组时，它也将一个特定的排序行为耦合到每个 pair 实例上。如果我们想按 endTime 升序对某些对进行排序，而按 end time 降序对其他对进行排序呢？使用实现 comparable 的 pair 类无法做到这一点。</p><p id="ca07" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">输入比较器。</p><p id="a6cf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Comparator 是一个允许类对用户定义的类的对象进行排序的接口。我们没有将排序功能与类本身紧密结合，而是将排序逻辑留给一个比较器，该比较器专门处理比较两个对象的逻辑:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="2d5b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这里，PairComparatorByEndTime 实现了比较器接口，并且需要实现 compare 方法。类似于 compareTo，排序的逻辑在这里决定。</p><p id="a245" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在客户端代码中，有另一个重载的 arrays.sort 方法，它接受两个参数而不是一个，第二个参数是一个比较器实例。</p><p id="dfb0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有了比较器，pair 类不再需要实现 comparable，而是由比较器进行排序:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="7c58" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果需要，您还可以包含一个不同的比较器来按开始时间排序。</p><p id="a244" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每种方法的优缺点是什么？</p><p id="15ae" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用 comparable，您可以简单地将排序逻辑浓缩到对象类中。您不需要在外部维护不同的比较器类来担心如何对对象的数组/集合进行排序。</p><p id="4bae" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，这只会限制对象以一种方式排序，并且您不能真正不同地排序两个对象的数组/集合。如果您在扩展代码时将它用于生产代码，这可能是一个问题。</p><p id="12ab" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用 comparator，您可以给客户端代码几个选项来对类实例的数组进行排序。这避免了使用 comparable 的缺陷，并为用户提供了更多的灵活性，可以根据需要对集合进行不同的排序。</p><p id="77b3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，由于不同的比较器类有额外的逻辑，因此需要维护更多的代码。想象一下，您维护的所有类都有几个比较器。这意味着需要在代码库中维护更多的测试和逻辑。</p><p id="d15f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">作为一名开发人员，您可以根据问题的范围来决定使用哪种解决方案。</p><p id="6c20" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就是这样！编码快乐！</p><p id="f4a3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果有问题/顾虑，欢迎在本文中发表评论。</p></div></div>    
</body>
</html>