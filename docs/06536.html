<html>
<head>
<title>MVVM Pattern in SwiftUI: A Practical Example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI 中的 MVVM 模式:一个实例</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/mvvm-pattern-in-swiftui-a-practical-example-c79c5cc44f74?source=collection_archive---------2-----------------------#2022-01-15">https://blog.devgenius.io/mvvm-pattern-in-swiftui-a-practical-example-c79c5cc44f74?source=collection_archive---------2-----------------------#2022-01-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9061" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">学习使用 MVVM 模式在 SwiftUI 中构建一个简单的应用程序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f2466122ba3943cfbd12f9164b383b5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7IatRIAgdnVwbhsHl3dvIQ.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由来自<a class="ae kv" href="https://www.pexels.com/it-it/foto/foto-del-primo-piano-della-persona-che-scrive-sul-computer-portatile-1181675/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">佩克斯</a>的<a class="ae kv" href="https://www.pexels.com/it-it/@divinetechygirl?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">克里斯蒂娜·莫里洛</a>拍摄</figcaption></figure><p id="8bd1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在今天的文章中，我将向您展示如何在 SwiftUI 框架上使用著名的模型-视图-视图模型模式，构建一个非常简单的应用程序。我将指导您完成该模式中使用的所有步骤和术语。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="ec83" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">介绍</h1><p id="7ecd" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在命令式 UIKit 的古代时代，苹果围绕模型视图控制器或 MVC 模式构建了所有的应用程序。随着时间的推移，应用程序变得越来越大，开发人员开始使用控制器作为各种代码的巨大容器。UI 逻辑进入控制器内部，业务逻辑进入控制器内部，其他控制器的表示进入控制器内部……控制器很快变成了巨大的怪物。MVC 的首字母缩略词很快成为著名的大规模视图控制器。为了避免这个问题，开发人员开始应用不同的模式。其中之一是模型-视图-视图模型或 MVVM。<br/>当苹果决定从头开始为用户界面创建一个新的声明式框架 SwiftUI 时，它选择了 MVVM 作为其技术的主要模式，并采用了一些非常简洁的解决方案，让人们可以轻松地使用它。</p><p id="9324" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们来看看 app 本身。我们将建立一个能够在 iTunes 商店搜索音乐的应用程序。用户将输入艺术家或乐队的名字，点击搜索按钮并获取一些数据。数据将被解码，并以列表的形式显示在屏幕上，包括歌曲名称、专辑图片和商品价格。</p><p id="763a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了简单起见，我设计了一个超级简单的 UI。没有加载视图，没有错误弹出窗口，没有哨声和铃声…</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/fc3cc8fd110dcc7fe138c6eb63f9cb82.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/1*30pIrpYlJkxumSZdjDA_Qw.gif"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="1150" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">MVVM——一些理论</h1><p id="79c3" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">什么是 MVVM 模式？如果你正在阅读这篇文章，你可能已经有一个模糊的想法，但请允许我解释一下。让我们从维基百科的定义开始:</p><blockquote class="mx my mz"><p id="0be3" class="kw kx na ky b kz la jr lb lc ld ju le nb lg lh li nc lk ll lm nd lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="iq">模型:</em> </strong> <em class="iq">模型</em>或者指<a class="ae kv" href="https://en.wikipedia.org/wiki/Domain_model" rel="noopener ugc nofollow" target="_blank">域模型</a>，表示真实状态内容(一种面向对象的方法)，或者指<a class="ae kv" href="https://en.wikipedia.org/wiki/Data_access_layer" rel="noopener ugc nofollow" target="_blank">数据访问层</a>，表示内容(一种以数据为中心的方法)。</p><p id="7f09" class="kw kx na ky b kz la jr lb lc ld ju le nb lg lh li nc lk ll lm nd lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="iq">视图</em> </strong>:在<a class="ae kv" href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller" rel="noopener ugc nofollow" target="_blank">模型-视图-控制器</a> (MVC)和<a class="ae kv" href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter" rel="noopener ugc nofollow" target="_blank">模型-视图-演示者</a> (MVP)模式中，<em class="iq">视图</em>是用户在屏幕上看到的结构、布局和外观。它显示模型的表示，并接收用户与视图的交互(鼠标点击、键盘输入、屏幕点击手势等)。)，并通过<a class="ae kv" href="https://en.wikipedia.org/wiki/Data_binding" rel="noopener ugc nofollow" target="_blank">数据绑定</a>(属性、事件回调等)将这些处理转发给视图模型。)被定义为链接视图和视图模型。</p><p id="7c9f" class="kw kx na ky b kz la jr lb lc ld ju le nb lg lh li nc lk ll lm nd lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="iq">视图模型:</em></strong><em class="iq">视图模型</em>是公开公共属性和命令的视图的抽象。代替 MVC 模式的控制器，或者 MVP 模式的呈现者，MVVM 有一个<em class="iq">绑定器</em>，它自动化了视图和它在视图模型中的绑定属性之间的通信。视图模型被描述为模型中的数据状态。在 MVP 模式中，视图模型和表示者之间的主要区别在于，表示者有对视图的引用，而视图模型没有。相反，视图直接绑定到视图模型的属性来发送和接收更新。为了高效运行，这需要一种绑定技术或者生成<a class="ae kv" href="https://en.wikipedia.org/wiki/Boilerplate_code" rel="noopener ugc nofollow" target="_blank">样板代码</a>来进行绑定。</p><p id="989b" class="kw kx na ky b kz la jr lb lc ld ju le nb lg lh li nc lk ll lm nd lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="iq">绑定器</em> </strong>:声明性数据和命令绑定隐含在 MVVM 模式中。在微软<a class="ae kv" href="https://en.wikipedia.org/wiki/Solution_stack" rel="noopener ugc nofollow" target="_blank">解决方案栈</a>中，绑定器是一种叫做<a class="ae kv" href="https://en.wikipedia.org/wiki/XAML" rel="noopener ugc nofollow" target="_blank"> XAML </a>的<a class="ae kv" href="https://en.wikipedia.org/wiki/Markup_language" rel="noopener ugc nofollow" target="_blank">标记语言</a>。绑定器使开发人员不必编写锅炉板逻辑来同步视图模型和视图。当在微软堆栈之外实现时，声明性数据绑定技术的出现使这种模式成为可能，如果没有绑定器，人们通常会使用 MVP 或 MVC，并且必须编写更多的样板文件(或者用其他工具生成它)。</p></blockquote><p id="c1fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，这个定义相当冗长，所以也许一张图片和一些简单的单词会有所帮助:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/c01a4ba325d41535937536e4b06049c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rgKSkqHUlGwOFmDJ3Htpjg.jpeg"/></div></div></figure><p id="03cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们解释一下。我们有三个主要组成部分。视图将负责创建所有用户界面小部件，并在屏幕上显示。模型将保存所有要在屏幕上显示的原始数据，视图模型将负责所有的业务逻辑，并处理模型中的数据，以便根据需要在屏幕上显示它们。</p><p id="ab88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个组件<em class="na">可以与其他一个或两个</em>通信，如下所示:</p><ul class=""><li id="9c1f" class="nf ng iq ky b kz la lc ld lf nh lj ni ln nj lr nk nl nm nn bi translated">视图将只与视图模型对话。</li><li id="d253" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">视图模型将直接与模型对话，并间接地与视图对话，以某种方式通知它(我们将在后面看到)其状态的变化。</li><li id="4be2" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">模型将与视图模型间接对话，通知其状态的变化。</li></ul><p id="4587" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个组件<em class="na">都知道</em>遵循这些规则的其他组件:</p><ul class=""><li id="ce52" class="nf ng iq ky b kz la lc ld lf nh lj ni ln nj lr nk nl nm nn bi translated">视图确切地知道谁是它的视图模型。视图对模型一无所知。</li><li id="703b" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">视图模型确切地知道谁是它的模型。视图模型与某些视图对话，但它并不确切知道它是谁。</li><li id="b5a7" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">该模型与一些视图模型对话，但它并不确切知道它是谁。模型对视图一无所知。</li></ul><p id="e381" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">模型将与视图模型对话，视图模型将使用活页夹与视图对话。我们可以用委托、闭包、联合来创建一个绑定器……但是 SwiftUI 和联合联系紧密，很难知道一个何时结束，另一个何时开始。</p><h1 id="c832" class="lz ma iq bd mb mc nt me mf mg nu mi mj jw nv jx ml jz nw ka mn kc nx kd mp mq bi translated">编写代码</h1><p id="189b" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">为了对我将要处理的数据有一个概念，我从唯一需要的 REST 服务开始，从 iTunes 的<a class="ae kv" href="https://developer.apple.com/library/archive/documentation/AudioVideo/Conceptual/iTuneSearchAPI/index.html#//apple_ref/doc/uid/TP40017632-CH3-SW1" rel="noopener ugc nofollow" target="_blank">搜索 API</a>开始，并且分析了响应以便为模型创建一个结构。</p><h2 id="b452" class="ny ma iq bd mb nz oa dn mf ob oc dp mj lf od oe ml lj of og mn ln oh oi mp oj bi translated"><strong class="ak">型号</strong></h2><p id="2dac" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">这是一个 JSON 响应的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="2878" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，响应有一个根对象，该根对象具有两个属性:<strong class="ky ir">结果计数</strong>和一个<strong class="ky ir">结果数组</strong>。结果对象有很多属性，但是对于我们的例子，我们只需要其中的几个。</p><p id="2117" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用 JSON 作为参考，我为响应编写了模型:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="a79a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这很容易解释，但是看看第 18 行发生了什么。我已经创建了一个带有静态计算 var 的扩展，我将在我的项目中使用它来准备一个<strong class="ky ir">示例</strong>。这一点非常有用，尤其是在 SwiftUI 中，您需要现成的模型在<strong class="ky ir">画布预览</strong>中为您的 UI 制作原型。如果您将实施<strong class="ky ir">单元测试</strong>，为每个模型创建一个例子以便做好准备也是一件好事。<br/>有时您不希望您的示例在生产版本中被发送到 AppStore，所以只需添加<strong class="ky ir">活动编译条件</strong>以在需要时排除这部分代码。</p><h2 id="2b77" class="ny ma iq bd mb nz oa dn mf ob oc dp mj lf od oe ml lj of og mn ln oh oi mp oj bi translated">视角</h2><p id="de68" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们的模型完成后，下一步将是为我们的应用程序创建一个简单的 UI。一个搜索字段、一个动态图标、一个列表和一个搜索按钮就足够了。</p><p id="02d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将是我们应用程序的主要视图。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><ul class=""><li id="c0e4" class="nf ng iq ky b kz la lc ld lf nh lj ni ln nj lr nk nl nm nn bi translated">第 3 行:我为我们的视图模型<strong class="ky ir">创建了一个<code class="fe om on oo op b">@StateObject</code>。属性包装器允许您在您的一个视图中创建一个引用类型，并确保它保持活动状态，以便在该视图以及您与之共享的其他视图中使用。它将负责使用 ViewModel 的<code class="fe om on oo op b">@Published</code>包装器刷新视图的<code class="fe om on oo op b">body</code>属性，执行绑定器的角色……我们稍后会看到。</strong></li><li id="ffc5" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">第 11、13、37 行:我将视图的不同部分和行为绑定到 ViewModel 持有的属性。视图本身将根据这些变量的实际状态来创建。</li><li id="87d5" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">第 31 行:<code class="fe om on oo op b">Button</code>在 ViewModel 中触发一个函数，该函数将从我们的后端获取数据……我们稍后会看到。</li><li id="8b40" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">第 23 到 25 行:创建了一行的视图。我们将很快看到这个结构的实现，但是请注意它的 init。如前所述，一个视图无法知道一个<strong class="ky ir">模型</strong>的存在，它只能与一个包装视图并相应地显示其数据的视图模型对话。为了遵守 MVVM 模式，创建了一个视图模型，并在其初始化器中将其赋予新创建的行视图。</li></ul><p id="d6e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如第 25 行所述，我们使用第二个视图在屏幕上呈现结果。让我们看看我是如何编码的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><ul class=""><li id="f01d" class="nf ng iq ky b kz la lc ld lf nh lj ni ln nj lr nk nl nm nn bi translated">第 8 行:我使用了 iOS15 中引入的新的惊人的<code class="fe om on oo op b">AsyncImage</code>视图。它让异步加载变得异常简单。正如您所看到的，图像 URL 是由另一个包装了结果模型的 viewModel 给出的。视图不能与模型对话。</li><li id="c2d5" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">第 16 行和第 26 行:这里使用了相同的方法。这些属性来自视图模型。我们稍后将看到，全价转换了原始模型中的数据。</li><li id="fcf6" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">第 33 行:如前所述，我已经使用之前编写的示例模型创建了画布预览。超级得心应手！</li></ul><p id="cbe6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意视图如何确切地知道谁是它们的视图模型。</p><h2 id="f206" class="ny ma iq bd mb nz oa dn mf ob oc dp mj lf od oe ml lj of og mn ln oh oi mp oj bi translated">视图模型</h2><p id="baaf" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">是时候编写我们的小应用程序的引擎了，主视图模型。为了在视图和视图模型之间创建所需的<strong class="ky ir">绑定</strong>，在 Swift 中我们需要创建一个符合<code class="fe om on oo op b">ObservableObject</code>协议的对象。然后我们必须用 SwiftUI 属性包装器<code class="fe om on oo op b">@Published</code>声明绑定变量，以便允许我们在绑定视图中重新计算<code class="fe om on oo op b">body</code>属性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><ul class=""><li id="d218" class="nf ng iq ky b kz la lc ld lf nh lj ni ln nj lr nk nl nm nn bi translated">第 3–7 行:这里声明了所有的<code class="fe om on oo op b">@Published</code>属性。视图需要所有这些东西来根据实际状态创建 UI 本身。</li><li id="89f6" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">第 5 行:一旦属性改变了它的值，就会触发一个属性观察器。该函数更新另一个属性的值，该属性又向相关视图发送消息以更新自身。</li><li id="7dab" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">第 19 行:对于 web 服务，我使用了新的<code class="fe om on oo op b">Await Async</code> api。</li><li id="f025" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">第 25 行:与第 5 行类似，results 属性被更新，if 触发相关视图的刷新。</li></ul><p id="c272" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您所看到的，代码非常简洁，易于理解。请注意，如前所述，<strong class="ky ir">视图模型对绑定视图</strong>一无所知，它只是向某人发送消息，并不关心谁在监听。这使得这些对象之间的耦合度极低。</p><p id="2d3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们看一下第二个较小的 ViewModel，它包装了结果模型并用于创建列表行。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><ul class=""><li id="2c01" class="nf ng iq ky b kz la lc ld lf nh lj ni ln nj lr nk nl nm nn bi translated">第 3 行:ViewModel 用一个模型初始化。</li><li id="2270" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">第 5、9、13 行:三个计算变量被暴露给相关视图。请注意这些值是如何被相应地操作的，一些属性被修改、组合，一些被转换成提供默认值的非可选变量。</li></ul><p id="8626" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，即使这个 ViewModel 也对相关视图一无所知。</p><h1 id="d34c" class="lz ma iq bd mb mc nt me mf mg nu mi mj jw nv jx ml jz nw ka mn kc nx kd mp mq bi translated">最后的话</h1><p id="ca19" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">如您所见，SwiftUI 实际上是由 MVVM 模式组成的。苹果做了很多构造，以便很容易地实现这种模式，有时很难注意到它，所以如果你喜欢它，就开始在你的项目中使用它。你甚至可以在应用程序的一小部分中使用 MVVM 来增强信心。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="e083" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你是不是对那些<code class="fe om on oo op b">@Published</code>、<code class="fe om on oo op b">ObservableObject</code>、<code class="fe om on oo op b">@StateObject</code>都很迷茫？看看这本很棒的互动书籍:</p><div class="oq or gp gr os ot"><a href="https://www.bigmountainstudio.com/data/jz1m0" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">在 SwiftUI 中使用数据</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">在 SwiftUI 中处理数据令人困惑！我听到了！这就是为什么我做了一个指南给你指明正确的道路。</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">www.bigmountainstudio.com</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph kp ot"/></div></div></a></div></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="876c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本教程的视频版本也可在此处获得:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pi ol l"/></div></figure><p id="8096" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请订阅我的 YouTube 频道😉</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="34f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你喜欢这篇文章，如果你喜欢，请鼓掌。<br/>如果这篇文章对你有用，请随意<a class="ae kv" href="https://www.buymeacoffee.com/dy59tqxn794" rel="noopener ugc nofollow" target="_blank">给我一杯咖啡</a>并允许我创造更多酷的内容和文章。</p><p id="d267" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">享受你的编码！</p></div></div>    
</body>
</html>