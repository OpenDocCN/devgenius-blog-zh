<html>
<head>
<title>Best Features of ES2018 — Object Rest and Spread</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ES2018的最佳功能—对象静止和扩散</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/best-features-of-es2018-object-rest-and-spread-161798d60afa?source=collection_archive---------11-----------------------#2020-09-28">https://blog.devgenius.io/best-features-of-es2018-object-rest-and-spread-161798d60afa?source=collection_archive---------11-----------------------#2020-09-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9ea265de3add7efe6fb1a5d8043b0aba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3QiVzpTBxvJhQJKJ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">安吉丽娜·基丘科娃在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="98fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自2015年以来，JavaScript有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解ES2018的最佳特性。</p><h1 id="8c31" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对象上的Rest运算符</h1><p id="14a1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以在对象中使用rest操作符进行析构。</p><p id="5192" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a61b" class="mn lc iq mj b gy mo mp l mq mr">const obj = {<br/>  a: 1,<br/>  b: 2,<br/>  c: 3<br/>};<br/>const {<br/>  a,<br/>  ...rest<br/>} = obj;</span></pre><p id="0a26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe ms mt mu mj b">a</code>是1而<code class="fe ms mt mu mj b">rest</code>是:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6661" class="mn lc iq mj b gy mo mp l mq mr">{<br/>  "b": 2,<br/>  "c": 3<br/>}</span></pre><p id="7963" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们使用对象析构来处理命名参数，rest操作符让我们收集所有剩余的参数。</p><p id="0d58" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以如果我们写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a0c6" class="mn lc iq mj b gy mo mp l mq mr">function foo({<br/>  a,<br/>  b,<br/>  ...rest<br/>}) {<br/>  console.log(<br/>    a,<br/>    b,<br/>    rest<br/>  );<br/>  return a + b;<br/>}</span><span id="bc75" class="mn lc iq mj b gy mv mp l mq mr">foo({<br/>  a: 1,<br/>  b: 2,<br/>  c: 3<br/>})</span></pre><p id="cbb3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe ms mt mu mj b">a</code>就是1，<code class="fe ms mt mu mj b">b</code>就是2，<code class="fe ms mt mu mj b">rest</code>就是<code class="fe ms mt mu mj b">{c: 3}</code>。</p><p id="bd3a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们最多可以使用rest操作符进行一次析构，并且只能在最后使用。</p><p id="378f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是有意义的，因为这是JavaScript引擎知道什么还没有通过析构赋给变量的唯一方式。</p><p id="79ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们不能写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="18a1" class="mn lc iq mj b gy mo mp l mq mr">const {...rest, a} = obj;</span></pre><p id="ac0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e356" class="mn lc iq mj b gy mo mp l mq mr">const {foo, ...a, ...b} = obj;</span></pre><p id="6a3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们都会给我们带来语法错误。</p><p id="7f61" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以嵌套rest操作符。</p><p id="4c61" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="589d" class="mn lc iq mj b gy mo mp l mq mr">const obj = {<br/>  qux: {<br/>    a: 1,<br/>    b: 2,<br/>    c: 3,<br/>  },<br/>  foo: 4,<br/>  baz: 5,<br/>  bar: 6,<br/>};<br/>const {<br/>  qux: {<br/>    a,<br/>    ...rest1<br/>  },<br/>  ...rest2<br/>} = obj;</span></pre><p id="e4d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe ms mt mu mj b">a</code>就是1，<code class="fe ms mt mu mj b">rest1</code>就是<code class="fe ms mt mu mj b">{b: 2, c: 3}</code>。</p><p id="9972" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而<code class="fe ms mt mu mj b">rest2</code>就是<code class="fe ms mt mu mj b">{foo: 4, baz: 5, bar: 6}</code>。</p><h1 id="5250" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对象文字中的扩展运算符</h1><p id="d125" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">对象文字中的扩展运算符是ES2018的新增功能。</p><p id="0afa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以这样使用它:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5890" class="mn lc iq mj b gy mo mp l mq mr">const obj = {<br/>  a: 1,<br/>  b: 2<br/>};</span><span id="9966" class="mn lc iq mj b gy mv mp l mq mr">const obj2 = {<br/>  ...obj,<br/>  baz: 3<br/>}</span></pre><p id="533d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用spread操作符将<code class="fe ms mt mu mj b">obj</code>的属性复制到一个新对象中，并将其分配给<code class="fe ms mt mu mj b">obj2</code>。</p><p id="fac8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以<code class="fe ms mt mu mj b">obj2</code>就是<code class="fe ms mt mu mj b">{a: 1, b: 2, baz: 3}</code>。</p><p id="7c60" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">顺序很重要，因为它们将按照传播的顺序进行填充。</p><p id="4f52" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ffa8" class="mn lc iq mj b gy mo mp l mq mr">const obj = {<br/>  a: 1,<br/>  b: 2<br/>};</span><span id="ea0a" class="mn lc iq mj b gy mv mp l mq mr">const obj2 = {<br/>  baz: 3,<br/>  ...obj<br/>}</span></pre><p id="4e97" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe ms mt mu mj b">obj2</code>就是<code class="fe ms mt mu mj b">{baz: 3, a: 1, b: 2}</code>。</p><p id="0eec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这两个键冲突，后一个键会覆盖前一个键。</p><p id="a260" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c253" class="mn lc iq mj b gy mo mp l mq mr">const obj = {<br/>  a: 1,<br/>  baz: 2<br/>};</span><span id="cd08" class="mn lc iq mj b gy mv mp l mq mr">const obj2 = {<br/>  baz: 3,<br/>  ...obj<br/>}</span></pre><p id="83c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9aab" class="mn lc iq mj b gy mo mp l mq mr">{baz: 2, a: 1}</span></pre><p id="f976" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为<code class="fe ms mt mu mj b">obj2</code>的值。</p><h1 id="1018" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对象扩展运算符的使用</h1><p id="356f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">对象扩展操作符有几个用例。</p><p id="3e16" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中之一就是克隆一个物体。</p><p id="4ab4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="335a" class="mn lc iq mj b gy mo mp l mq mr">const obj = {<br/>  a: 1,<br/>  b: 2<br/>};</span><span id="e88e" class="mn lc iq mj b gy mv mp l mq mr">const clone = {<br/>  ...obj<br/>};</span></pre><p id="09f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后用spread运算符对<code class="fe ms mt mu mj b">obj</code>进行浅层复制，因此<code class="fe ms mt mu mj b">clone</code>为:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="63b4" class="mn lc iq mj b gy mo mp l mq mr">{<br/>  a: 1,<br/>  b: 2<br/>}</span></pre><p id="da6c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这与使用<code class="fe ms mt mu mj b">Object.assign</code>进行克隆是一样的；</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3638" class="mn lc iq mj b gy mo mp l mq mr">const obj = {<br/>  a: 1,<br/>  b: 2<br/>};</span><span id="b4ad" class="mn lc iq mj b gy mv mp l mq mr">const clone = Object.assign({}, obj);</span></pre><p id="ca8b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">传播更短，更干净。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/2cce783df388bdd4588447cd77251225.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*m0NDv4CiUdTg6lzv"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@drewcoffman?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">德鲁·科夫曼</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="8226" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="7b21" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">“对象静止”和“展开”操作符是ES2018中发布的全新操作符。</p><p id="5bea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既干净又方便。</p></div></div>    
</body>
</html>