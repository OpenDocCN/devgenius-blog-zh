<html>
<head>
<title>Creating anonymous chat rooms with Socket.io and Express.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Socket.io 和 Express.js 创建匿名聊天室</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/creating-anonymous-chat-rooms-with-socket-io-and-express-js-f565897b5c?source=collection_archive---------13-----------------------#2022-04-18">https://blog.devgenius.io/creating-anonymous-chat-rooms-with-socket-io-and-express-js-f565897b5c?source=collection_archive---------13-----------------------#2022-04-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="010f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文中，我们将创建一个聊天应用程序，它将人们两两一组地匿名连接到不同的房间。聊天应用程序将使用<a class="ae ki" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express.js </a>作为服务器端代码，使用<a class="ae ki" href="https://socket.io/" rel="noopener ugc nofollow" target="_blank"> Socket.io </a>监听 web socket 通信，客户端将使用普通 JavaScript 开发。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi kj"><img src="../Images/8e08491b9522a0491343d39e69aabc5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*Kdmnqa4P7yW7TTqQmkEo7g.png"/></div></figure><h1 id="30ab" class="kr ks in bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">设置我们的项目</h1><ul class=""><li id="435b" class="lp lq in jm b jn lr jr ls jv lt jz lu kd lv kh lw lx ly lz bi translated">我们将创建一个名为<code class="fe ma mb mc md b">chat-app</code>的目录，并使用命令将该目录更改为目录。</li></ul><pre class="kk kl km kn gt me md mf mg aw mh bi"><span id="1d4c" class="mi ks in md b gy mj mk l ml mm">$ mkdir chat-app &amp;&amp; cd chat-app</span></pre><ul class=""><li id="c3a0" class="lp lq in jm b jn jo jr js jv mn jz mo kd mp kh lw lx ly lz bi translated">通过运行命令初始化我们的节点应用程序。</li></ul><pre class="kk kl km kn gt me md mf mg aw mh bi"><span id="dab1" class="mi ks in md b gy mj mk l ml mm">$ yarn init -y</span></pre><ul class=""><li id="1f54" class="lp lq in jm b jn jo jr js jv mn jz mo kd mp kh lw lx ly lz bi translated">通过运行命令，使用 yarn 在我们的项目中安装 express。</li></ul><pre class="kk kl km kn gt me md mf mg aw mh bi"><span id="5183" class="mi ks in md b gy mj mk l ml mm">$ yarn add express</span></pre><ul class=""><li id="324f" class="lp lq in jm b jn jo jr js jv mn jz mo kd mp kh lw lx ly lz bi translated">我们将创建一个名为<code class="fe ma mb mc md b">app.js</code>的 JavaScript 文件，并创建一个简单的节点 HTTP 服务器。</li><li id="d667" class="lp lq in jm b jn mq jr mr jv ms jz mt kd mu kh lw lx ly lz bi translated">接下来，我们将把 express 导入到我们的应用程序中，创建一个 express 应用程序并启动服务器来监听端口<code class="fe ma mb mc md b">8001</code>上的请求。</li></ul><pre class="kk kl km kn gt me md mf mg aw mh bi"><span id="61d1" class="mi ks in md b gy mj mk l ml mm">// app.js<br/>const http = require("http")<br/>const express = require("express")</span><span id="d3ef" class="mi ks in md b gy mv mk l ml mm">const app = express()</span><span id="1996" class="mi ks in md b gy mv mk l ml mm">app.get("/index", (req, res) =&gt; {<br/>    res.send("Welcome home")<br/>})</span><span id="4c3c" class="mi ks in md b gy mv mk l ml mm">const server = http.createServer(app)</span><span id="f7f6" class="mi ks in md b gy mv mk l ml mm">server.on("error", (err) =&gt; {<br/>    console.log("Error opening server")<br/>})</span><span id="2071" class="mi ks in md b gy mv mk l ml mm">server.listen(8001, () =&gt; {<br/>    console.log("Server working on port 8001")<br/>})</span></pre><ul class=""><li id="fb35" class="lp lq in jm b jn jo jr js jv mn jz mo kd mp kh lw lx ly lz bi translated">现在，我们可以通过运行命令来启动应用程序。</li></ul><pre class="kk kl km kn gt me md mf mg aw mh bi"><span id="24c8" class="mi ks in md b gy mj mk l ml mm">$ node app.js</span></pre><p id="6ced" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以在浏览器上访问<code class="fe ma mb mc md b">[http://localhost:8001/index](http://localhost:8001/index)</code>来测试应用程序是否工作。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/84c343fab1a3719210c2c8851a4af012.png" data-original-src="https://miro.medium.com/v2/resize:fit:1054/format:webp/1*AcNs8ks9IlmYP3vspMto5w.png"/></div></figure><h1 id="3b26" class="kr ks in bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">在服务器端初始化<a class="ae ki" href="http://socket.io/" rel="noopener ugc nofollow" target="_blank"> socket.io </a></h1><p id="0b34" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv mx jx jy jz my kb kc kd mz kf kg kh ig bi translated">要在服务器端初始化套接字，请遵循以下步骤。</p><ul class=""><li id="305a" class="lp lq in jm b jn jo jr js jv mn jz mo kd mp kh lw lx ly lz bi translated">通过运行命令，将<a class="ae ki" href="http://socket.io/" rel="noopener ugc nofollow" target="_blank"> socket.io </a>依赖项安装到我们的应用程序中。</li></ul><pre class="kk kl km kn gt me md mf mg aw mh bi"><span id="e44e" class="mi ks in md b gy mj mk l ml mm">$ <!-- -->yarn add socket.io</span></pre><ul class=""><li id="6ba8" class="lp lq in jm b jn jo jr js jv mn jz mo kd mp kh lw lx ly lz bi translated">将<a class="ae ki" href="http://socket.io/" rel="noopener ugc nofollow" target="_blank"> socket.io </a>导入到我们的代码中，创建一个新的套接字服务器，然后向套接字添加一个事件监听器，以监听是否建立了连接。</li></ul><pre class="kk kl km kn gt me md mf mg aw mh bi"><span id="7124" class="mi ks in md b gy mj mk l ml mm"><em class="na">// app.js</em></span><span id="6258" class="mi ks in md b gy mv mk l ml mm">const http = require("http");</span><span id="3dfe" class="mi ks in md b gy mv mk l ml mm">const { Server } = require("socket.io");</span><span id="a93f" class="mi ks in md b gy mv mk l ml mm">const express = require("express");</span><span id="0706" class="mi ks in md b gy mv mk l ml mm">const app = express();<br/></span><span id="216b" class="mi ks in md b gy mv mk l ml mm">app.get("/index", (req, res) =&gt; {</span><span id="14f9" class="mi ks in md b gy mv mk l ml mm">  res.send("Welcome home");</span><span id="b12d" class="mi ks in md b gy mv mk l ml mm">});<br/></span><span id="c448" class="mi ks in md b gy mv mk l ml mm">const server = http.createServer(app);</span><span id="0335" class="mi ks in md b gy mv mk l ml mm">const io = new Server(server);</span><span id="b41a" class="mi ks in md b gy mv mk l ml mm">io.on("connection", (socket) =&gt; {</span><span id="f6be" class="mi ks in md b gy mv mk l ml mm">  console.log("connected");</span><span id="b5fc" class="mi ks in md b gy mv mk l ml mm">});<br/></span><span id="7f10" class="mi ks in md b gy mv mk l ml mm">server.on("error", (err) =&gt; {</span><span id="6d15" class="mi ks in md b gy mv mk l ml mm">  console.log("Error opening server");</span><span id="87c4" class="mi ks in md b gy mv mk l ml mm">});<br/></span><span id="73cf" class="mi ks in md b gy mv mk l ml mm">server.listen(8001, () =&gt; {</span><span id="bb23" class="mi ks in md b gy mv mk l ml mm">  console.log("Server working on port 3000");</span><span id="ef2e" class="mi ks in md b gy mv mk l ml mm">});</span></pre><h1 id="487a" class="kr ks in bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">在客户端初始化<a class="ae ki" href="http://socket.io/" rel="noopener ugc nofollow" target="_blank"> socket.io </a></h1><p id="0ea8" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv mx jx jy jz my kb kc kd mz kf kg kh ig bi translated">我们将使用普通的 JavaScript 创建一个简单的 UI，并将网页作为 express 应用程序中的静态文件。</p><p id="8cad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将创建一个包含文件的公共目录来构建我们的 UI，使我们的项目结构看起来像这样。</p><pre class="kk kl km kn gt me md mf mg aw mh bi"><span id="920d" class="mi ks in md b gy mj mk l ml mm">chat-app/<br/>     |- node_modules/<br/>     |- public/<br/>            |- index.html<br/>            |- main.js<br/>            |- app.js<br/>            |- package.json<br/>            |- yarn.lock</span></pre><blockquote class="nb nc nd"><p id="0186" class="jk jl na jm b jn jo jp jq jr js jt ju ne jw jx jy nf ka kb kc ng ke kf kg kh ig bi translated">我们将利用<a class="ae ki" href="https://tailwindcss.com/" rel="noopener ugc nofollow" target="_blank"> Tailwind CSS </a>来设计客户端 UI 的样式，以减少我们将要编写的自定义 CSS 的数量。</p></blockquote><p id="252f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<code class="fe ma mb mc md b">index.html</code>中，为我们的聊天窗口创建一个模板。</p><pre class="kk kl km kn gt me md mf mg aw mh bi"><span id="3339" class="mi ks in md b gy mj mk l ml mm">&lt;!-- index.html --&gt;<br/>&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>&lt;head&gt;<br/>    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;<br/>    &lt;script src="https://cdn.tailwindcss.com"&gt;&lt;/script&gt;<br/>    &lt;title&gt;Anon Chat App&lt;/title&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>    &lt;div class="flex-1 p:2 sm:p-6 justify-between flex flex-col h-screen"&gt;<br/>        &lt;div id="messages" class="flex flex-col space-y-4 p-3 overflow-y-auto scrollbar-thumb-blue scrollbar-thumb-rounded scrollbar-track-blue-lighter scrollbar-w-2 scrolling-touch"&gt;<br/>        &lt;/div&gt;<br/>        &lt;div class="border-t-2 border-gray-200 px-4 pt-4 mb-2 sm:mb-0"&gt;<br/>           &lt;div class="relative flex"&gt;<br/>              &lt;input type="text" placeholder="Write your message!" class="w-full focus:outline-none focus:placeholder-gray-400 text-gray-600 placeholder-gray-600 pl-12 bg-gray-200 rounded-md py-3"&gt;<br/>              &lt;div class="absolute right-0 items-center inset-y-0 hidden sm:flex"&gt;<br/>                 &lt;button type="button" class="inline-flex items-center justify-center rounded-lg px-4 py-3 transition duration-500 ease-in-out text-white bg-blue-500 hover:bg-blue-400 focus:outline-none"&gt;<br/>                    &lt;span class="font-bold"&gt;Send&lt;/span&gt;<br/>                    &lt;svg  viewBox="0 0 20 20" fill="currentColor" class="h-6 w-6 ml-2 transform rotate-90"&gt;<br/>                       &lt;path d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 15.571V11a1 1 0 112 0v4.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z"&gt;&lt;/path&gt;<br/>                    &lt;/svg&gt;<br/>                 &lt;/button&gt;<br/>              &lt;/div&gt;<br/>           &lt;/div&gt;<br/>        &lt;/div&gt;<br/>     &lt;/div&gt;<br/>         &lt;script src="/socket.io/socket.io.js"&gt;&lt;/script&gt;<br/>     &lt;script src="./main.js"&gt;&lt;/script&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="e8b3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的 HTML 文件中，我们包含了两个 JavaScript 文件，第一个用于在客户端初始化<a class="ae ki" href="http://socket.io/" rel="noopener ugc nofollow" target="_blank"> socket.io </a>，另一个<code class="fe ma mb mc md b">main.js</code>用于编写我们的定制 JavaScript 代码。</p><p id="07f1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后在<code class="fe ma mb mc md b">main.js</code>文件中，我们将创建一个能够向聊天框添加消息的函数。函数<code class="fe ma mb mc md b">createMessage</code>需要两个参数。第一个参数是消息字符串，第二个参数是布尔值，用于确定消息是来自用户还是来自另一个外部用户。</p><pre class="kk kl km kn gt me md mf mg aw mh bi"><span id="ca4d" class="mi ks in md b gy mj mk l ml mm">// main.js<br/>const messageBox = document.querySelector("#messages");</span><span id="33d3" class="mi ks in md b gy mv mk l ml mm">function createMessage(text, ownMessage = false) {<br/>  const messageElement = document.createElement("div");<br/>  messageElement.className = "chat-message";<br/>  const subMesssageElement = document.createElement("div");<br/>  subMesssageElement.className =<br/>    "px-4 py-4 rounded-lg inline-block rounded-bl-none bg-gray-300 text-gray-600";<br/>  if (ownMessage) {<br/>    subMesssageElement.className += " float-right bg-blue-800 text-white";<br/>  }<br/>  subMesssageElement.innerText = text;<br/>  messageElement.appendChild(subMesssageElement);</span><span id="55e3" class="mi ks in md b gy mv mk l ml mm">  messageBox.appendChild(messageElement);<br/>}</span><span id="a10f" class="mi ks in md b gy mv mk l ml mm">createMessage("Welcome to vahalla");<br/>createMessage("Who are you to talk to me", true);</span></pre><p id="f66c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">更改服务器应用程序<code class="fe ma mb mc md b">app.js</code>中的代码，并使用静态文件来呈现客户端 UI。</p><pre class="kk kl km kn gt me md mf mg aw mh bi"><span id="a51a" class="mi ks in md b gy mj mk l ml mm">// app.js<br/>const http = require("http");<br/>const { Server } = require("socket.io");<br/>const express = require("express");<br/>const path = require("path");</span><span id="7122" class="mi ks in md b gy mv mk l ml mm">const app = express();</span><span id="9899" class="mi ks in md b gy mv mk l ml mm">app.use(express.static(path.join(__dirname, "public")));</span><span id="16ae" class="mi ks in md b gy mv mk l ml mm">const server = http.createServer(app);</span><span id="8a8e" class="mi ks in md b gy mv mk l ml mm">const io = new Server(server);</span><span id="7972" class="mi ks in md b gy mv mk l ml mm">io.on("connection", (socket) =&gt; {<br/>  console.log("connected");<br/>});</span><span id="e3ea" class="mi ks in md b gy mv mk l ml mm">server.on("error", (err) =&gt; {<br/>  console.log("Error opening server");<br/>});</span><span id="d428" class="mi ks in md b gy mv mk l ml mm">server.listen(8001, () =&gt; {<br/>  console.log("Server working on port 8001");<br/>});</span></pre><blockquote class="nb nc nd"><p id="8ef1" class="jk jl na jm b jn jo jp jq jr js jt ju ne jw jx jy nf ka kb kc ng ke kf kg kh ig bi translated">注意:要查看我们的应用程序中所做的更改，我们必须停止正在运行的服务器应用程序，然后重新运行它，以使新的更改生效。所以我们正在利用<code class="fe ma mb mc md b">nodemon</code>来为我们自动化这个过程。</p></blockquote><p id="e0d8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过运行以下命令安装 nodemon。</p><pre class="kk kl km kn gt me md mf mg aw mh bi"><span id="f9fa" class="mi ks in md b gy mj mk l ml mm">$ npm install -g nodemon</span></pre><p id="dc88" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后使用 nodemon 运行节点应用程序。</p><pre class="kk kl km kn gt me md mf mg aw mh bi"><span id="5064" class="mi ks in md b gy mj mk l ml mm">$ nodemon ./app.js</span></pre><p id="98d4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在你的浏览器上打开<code class="fe ma mb mc md b">[http://localhost:8001](http://localhost:3000)</code>,看看这个聊天应用会是什么样子。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nh"><img src="../Images/f68ccb7cfcffa60863c7a5fc3e9e1ff8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WwFXn5Asw6LQfhdIyt0Zqg.png"/></div></div></figure><h1 id="8dbe" class="kr ks in bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">为 Web 套接字通信创建不同的房间</h1><p id="a928" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv mx jx jy jz my kb kc kd mz kf kg kh ig bi translated">为了跟踪创建的房间和连接到每个房间的用户数量，我们将创建一个<code class="fe ma mb mc md b">Room</code>类来管理这些数据。</p><p id="846b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将在项目的根目录下创建一个名为<code class="fe ma mb mc md b">room.js</code>的新文件。然后我们创建<code class="fe ma mb mc md b">Room</code>类，并让构造函数初始化一个属性来保存我们房间的状态。</p><pre class="kk kl km kn gt me md mf mg aw mh bi"><span id="d1f3" class="mi ks in md b gy mj mk l ml mm">// room.js</span><span id="e6fd" class="mi ks in md b gy mv mk l ml mm">// the maximum number of people allowed in each room<br/>const ROOM_MAX_CAPACITY = 2;</span><span id="78e0" class="mi ks in md b gy mv mk l ml mm">class Room {<br/>  constructor() {<br/>    this.roomsState = [];<br/>  }<br/>}</span><span id="4429" class="mi ks in md b gy mv mk l ml mm">module.exports = Room;</span></pre><p id="ce51" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ma mb mc md b">roomsState</code>是一个对象数组，保存关于创建的每个房间 ID 和该房间中用户数量的信息。所以一个典型的<code class="fe ma mb mc md b">roomsState</code>应该是这样的。</p><pre class="kk kl km kn gt me md mf mg aw mh bi"><span id="0645" class="mi ks in md b gy mj mk l ml mm">// rooms state<br/>[<br/>    {<br/>        roomID: "some id",<br/>        users: 1<br/>    },<br/>    {<br/>        roomID: "a different id",<br/>        users: 2<br/>    }<br/>]</span></pre><p id="5a67" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，添加加入房间的方法。该方法将在房间中循环，以检查是否有任何房间的用户数量少于每个房间中允许的最大参与者数量。如果列表中的所有房间都被占用，它将创建一个新房间，并将该房间中的用户数量初始化为 1。</p><p id="2de2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了生成一个惟一的 id，我们将在应用程序中使用一个名为<a class="ae ki" href="https://www.npmjs.com/package/uuid" rel="noopener ugc nofollow" target="_blank"> uuid </a>的包。</p><p id="e3fa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过在我们的终端中运行这个命令来安装 uuid。</p><pre class="kk kl km kn gt me md mf mg aw mh bi"><span id="3222" class="mi ks in md b gy mj mk l ml mm">$ yarn add uuid</span></pre><p id="5278" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后通过如下运行将包导入到我们的应用程序中。</p><pre class="kk kl km kn gt me md mf mg aw mh bi"><span id="a22c" class="mi ks in md b gy mj mk l ml mm">// room.js<br/>const { v4: uuidv4 } = require("uuid");</span><span id="d65d" class="mi ks in md b gy mv mk l ml mm">class Room {<br/>  constructor() {<br/>    /**/<br/>  }</span><span id="b83a" class="mi ks in md b gy mv mk l ml mm">  joinRoom() {<br/>    return new Promise((resolve) =&gt; {<br/>      for (let i = 0; i &lt; this.roomsState.length; i++) {<br/>        if (this.roomsState[i].users &lt; ROOM_MAX_CAPACITY) {<br/>          this.roomsState[i].users++;<br/>          return resolve(this.roomsState[i].id);<br/>        }<br/>      }</span><span id="3701" class="mi ks in md b gy mv mk l ml mm">      // else generate a new room id<br/>      const newID = uuidv4();<br/>      this.roomsState.push({<br/>        id: newID,<br/>        users: 1,<br/>      });<br/>      return resolve(newID);<br/>    });<br/>  }<br/>}</span><span id="e1fc" class="mi ks in md b gy mv mk l ml mm">module.exports = Room;</span></pre><blockquote class="nb nc nd"><p id="8816" class="jk jl na jm b jn jo jp jq jr js jt ju ne jw jx jy nf ka kb kc ng ke kf kg kh ig bi translated">注意:利用数组来管理房间的状态显然不是最好的方法。想象一下，在您的应用程序中有数千个房间，您必须为每个连接请求遍历每个房间。它将在 O(n)处执行。出于本教程的目的，我们将坚持这种方法。</p></blockquote><p id="ba11" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将向<code class="fe ma mb mc md b">Room</code>类添加另一个方法<code class="fe ma mb mc md b">leaveRoom()</code>，以减少特定房间中的用户数量。</p><pre class="kk kl km kn gt me md mf mg aw mh bi"><span id="a666" class="mi ks in md b gy mj mk l ml mm">// room.js<br/>class Room {<br/>  constructor() {<br/>    /**/<br/>  }</span><span id="db04" class="mi ks in md b gy mv mk l ml mm">  joinRoom() {}</span><span id="cc2b" class="mi ks in md b gy mv mk l ml mm">  leaveRoom(id) {<br/>    this.roomsState = this.roomsState.filter((room) =&gt; {<br/>      if (room.id === id) {<br/>        if (room.users === 1) {<br/>          return false;<br/>        } else {<br/>          room.users--;<br/>        }<br/>      }<br/>      return true;<br/>    });<br/>  }<br/>}</span><span id="d375" class="mi ks in md b gy mv mk l ml mm">module.exports = Room;</span></pre><p id="e3a3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ma mb mc md b">leaveRoom()</code>方法获取一个房间 ID，并在房间数组中循环查找是否有房间匹配参数中提供的 ID。</p><p id="72d8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果它找到匹配的房间，它检查房间中的用户是否是其中之一，以便删除该特定的房间状态。如果房间中的用户数大于 1，<code class="fe ma mb mc md b">leaveRoom()</code>方法只是将该房间中的用户数减 1。</p><p id="41e0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，我们的<code class="fe ma mb mc md b">room.js</code>代码应该与此类似。</p><pre class="kk kl km kn gt me md mf mg aw mh bi"><span id="ae46" class="mi ks in md b gy mj mk l ml mm">// room.js<br/>const { v4: uuidv4 } = require("uuid");</span><span id="13a6" class="mi ks in md b gy mv mk l ml mm">// the maximum number of people allowed in a room<br/>const ROOM_MAX_CAPACITY = 2;</span><span id="ff33" class="mi ks in md b gy mv mk l ml mm">class Room {<br/>  constructor() {<br/>    this.roomsState = [];<br/>  }</span><span id="c249" class="mi ks in md b gy mv mk l ml mm">  joinRoom() {<br/>    return new Promise((resolve) =&gt; {<br/>      for (let i = 0; i &lt; this.roomsState.length; i++) {<br/>        if (this.roomsState[i].users &lt; ROOM_MAX_CAPACITY) {<br/>          this.roomsState[i].users++;<br/>          return resolve(this.roomsState[i].id);<br/>        }<br/>      }</span><span id="a50a" class="mi ks in md b gy mv mk l ml mm">      const newID = uuidv4();<br/>      this.roomsState.push({<br/>        id: newID,<br/>        users: 1,<br/>      });<br/>      return resolve(newID);<br/>    });<br/>  }</span><span id="16fa" class="mi ks in md b gy mv mk l ml mm">  leaveRoom(id) {<br/>    this.roomsState = this.roomsState.filter((room) =&gt; {<br/>      if (room.id === id) {<br/>        if (room.users === 1) {<br/>          return false;<br/>        } else {<br/>          room.users--;<br/>        }<br/>      }<br/>      return true;<br/>    });<br/>  }<br/>}</span><span id="24f8" class="mi ks in md b gy mv mk l ml mm">module.exports = Room;</span></pre><h1 id="d798" class="kr ks in bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">进出房间。</h1><p id="92f3" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv mx jx jy jz my kb kc kd mz kf kg kh ig bi translated">为了在我们的聊天应用程序中为用户创建不同的频道，我们将为他们创建房间。</p><p id="f54e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ki" href="http://socket.io/" rel="noopener ugc nofollow" target="_blank"> socket.io </a>允许我们创建套接字可以加入和离开的任意通道。它可用于向客户端子集广播事件。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/f2c1c415a5ba67b5d2f937acbaf7b3d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*IagxqLJDYmOgWhEVrLF67w.png"/></div><figcaption class="nn no gj gh gi np nq bd b be z dk translated"><em class="nr">来源:</em><a class="ae ki" href="https://socket.io/docs/v3/rooms/" rel="noopener ugc nofollow" target="_blank"/><em class="nr">)</em></figcaption></figure><p id="f732" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要加入一个房间，我们需要加入一个具有唯一房间 ID 的房间。</p><pre class="kk kl km kn gt me md mf mg aw mh bi"><span id="be70" class="mi ks in md b gy mj mk l ml mm">io.on("connection", socket =&gt; {<br/>    // join a room<br/>  socket.join("some room id");</span><span id="cd83" class="mi ks in md b gy mv mk l ml mm">  socket.to("some room id").emit("some event");<br/>});</span></pre><p id="3ffc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们的服务器应用程序中，一旦新用户加入连接，<code class="fe ma mb mc md b">Room.joinRoom()</code>就会返回一个惟一的 ID，这是我们惟一的房间 ID。因此，我们可以加入和离开我们的房间如下。</p><pre class="kk kl km kn gt me md mf mg aw mh bi"><span id="b5d2" class="mi ks in md b gy mj mk l ml mm">// app.js<br/>io.on("connection", async (socket) =&gt; {<br/>  const roomID = await room.joinRoom();<br/>  // join room<br/>  socket.join(roomID);</span><span id="27b5" class="mi ks in md b gy mv mk l ml mm">  socket.on("disconnect", () =&gt; {<br/>    // leave room<br/>    room.leaveRoom(roomID);<br/>  });<br/>});</span></pre><h1 id="d139" class="kr ks in bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">发送和接收消息</h1><p id="2991" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv mx jx jy jz my kb kc kd mz kf kg kh ig bi translated">现在，我们将回到客户端代码，为从客户端发送的消息发出事件。还可以监听来自服务器的消息事件，并将消息写入我们的聊天框。</p><pre class="kk kl km kn gt me md mf mg aw mh bi"><span id="7f08" class="mi ks in md b gy mj mk l ml mm">// main.js<br/>socket.on("receive-message", (message) =&gt; {<br/>  createMessage(message);<br/>});</span><span id="9c11" class="mi ks in md b gy mv mk l ml mm">sendButton.addEventListener("click", () =&gt; {<br/>  if (textBox.value != "") {<br/>    socket.emit("send-message", textBox.value);<br/>    createMessage(textBox.value, true);<br/>    textBox.value = "";<br/>  }<br/>});</span></pre><blockquote class="nb nc nd"><p id="3303" class="jk jl na jm b jn jo jp jq jr js jt ju ne jw jx jy nf ka kb kc ng ke kf kg kh ig bi translated">注意:在我们的聊天应用程序中，我们直接将来自用户的消息添加到聊天框中，而不确认消息是否被 socket 服务器接收到。通常情况不是这样。</p></blockquote><p id="e890" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后在我们的快递申请表上。</p><pre class="kk kl km kn gt me md mf mg aw mh bi"><span id="6d54" class="mi ks in md b gy mj mk l ml mm">// app.js<br/>io.on("connection", async (socket) =&gt; {<br/>  const roomID = await room.joinRoom();<br/>  // join room<br/>  socket.join(roomID);</span><span id="c5a2" class="mi ks in md b gy mv mk l ml mm">  socket.on("send-message", (message) =&gt; {<br/>    socket.to(roomID).emit("receive-message", message);<br/>  });</span><span id="8dbf" class="mi ks in md b gy mv mk l ml mm">  socket.on("disconnect", () =&gt; {<br/>    // leave room<br/>    room.leaveRoom(roomID);<br/>  });<br/>});</span></pre><p id="d5a7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最终使我们的 express 应用程序代码看起来像这样。</p><pre class="kk kl km kn gt me md mf mg aw mh bi"><span id="3732" class="mi ks in md b gy mj mk l ml mm">// app.js<br/>const http = require("http");<br/>const { Server } = require("socket.io");<br/>const express = require("express");<br/>const path = require("path");<br/>const Room = require("./room");</span><span id="a218" class="mi ks in md b gy mv mk l ml mm">const app = express();</span><span id="b4a1" class="mi ks in md b gy mv mk l ml mm">app.use(express.static(path.join(__dirname, "public")));</span><span id="4190" class="mi ks in md b gy mv mk l ml mm">const server = http.createServer(app);</span><span id="27dc" class="mi ks in md b gy mv mk l ml mm">const io = new Server(server);</span><span id="11d2" class="mi ks in md b gy mv mk l ml mm">const room = new Room();</span><span id="b3a4" class="mi ks in md b gy mv mk l ml mm">io.on("connection", async (socket) =&gt; {<br/>  const roomID = await room.joinRoom();<br/>  // join room<br/>  socket.join(roomID);</span><span id="c9ed" class="mi ks in md b gy mv mk l ml mm">  socket.on("send-message", (message) =&gt; {<br/>    socket.to(roomID).emit("receive-message", message);<br/>  });</span><span id="e12c" class="mi ks in md b gy mv mk l ml mm">  socket.on("disconnect", () =&gt; {<br/>    // leave room<br/>    room.leaveRoom(roomID);<br/>  });<br/>});</span><span id="496a" class="mi ks in md b gy mv mk l ml mm">server.on("error", (err) =&gt; {<br/>  console.log("Error opening server");<br/>});</span><span id="47f8" class="mi ks in md b gy mv mk l ml mm">server.listen(8001, () =&gt; {<br/>  console.log("Server working on port 8001");<br/>});</span></pre><p id="411e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的客户端 JavaScript 是这样的。</p><pre class="kk kl km kn gt me md mf mg aw mh bi"><span id="9894" class="mi ks in md b gy mj mk l ml mm">// main.js<br/>const messageBox = document.querySelector("#messages");<br/>const textBox = document.querySelector("input");<br/>const sendButton = document.querySelector("button");</span><span id="4a28" class="mi ks in md b gy mv mk l ml mm">function createMessage(text, ownMessage = false) {<br/>  const messageElement = document.createElement("div");<br/>  messageElement.className = "chat-message";<br/>  const subMesssageElement = document.createElement("div");<br/>  subMesssageElement.className =<br/>    "px-4 py-4 rounded-lg inline-block rounded-bl-none bg-gray-300 text-gray-600";<br/>  if (ownMessage) {<br/>    subMesssageElement.className += " float-right bg-blue-800 text-white";<br/>  }<br/>  subMesssageElement.innerText = text;<br/>  messageElement.appendChild(subMesssageElement);</span><span id="e3af" class="mi ks in md b gy mv mk l ml mm">  messageBox.appendChild(messageElement);<br/>}</span><span id="9075" class="mi ks in md b gy mv mk l ml mm">const socket = io();</span><span id="5a04" class="mi ks in md b gy mv mk l ml mm">socket.on("connection", (socket) =&gt; {<br/>  console.log(socket.id);<br/>});</span><span id="36e7" class="mi ks in md b gy mv mk l ml mm">socket.on("receive-message", (message) =&gt; {<br/>  createMessage(message);<br/>});</span><span id="772e" class="mi ks in md b gy mv mk l ml mm">sendButton.addEventListener("click", () =&gt; {<br/>  if (textBox.value != "") {<br/>    socket.emit("send-message", textBox.value);<br/>    createMessage(textBox.value, true);<br/>    textBox.value = "";<br/>  }<br/>});</span></pre><h1 id="c558" class="kr ks in bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">测试我们的聊天应用</h1><p id="588d" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv mx jx jy jz my kb kc kd mz kf kg kh ig bi translated">为了向我们的聊天应用发送文本，我们将打开四个不同的浏览器来确认两个房间已创建。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/2702d29031563b6082c3a981dae415eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*HYBzzktAbAlMqyjcCQ89Qg.gif"/></div></figure><h1 id="975e" class="kr ks in bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">结论</h1><p id="5dfd" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv mx jx jy jz my kb kc kd mz kf kg kh ig bi translated">如果你看到这个，这意味着我们到目前为止已经阅读了，并且可能已经在我们的机器上运行了聊天应用程序。</p><p id="c645" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以在这个<a class="ae ki" href="https://github.com/zt4ff/chat-app" rel="noopener ugc nofollow" target="_blank"> GitHub 资源库</a>中找到本文的代码。</p><p id="8d14" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了包含更多的挑战，您可以在聊天应用程序中包含这些功能</p><ul class=""><li id="33ac" class="lp lq in jm b jn jo jr js jv mn jz mo kd mp kh lw lx ly lz bi translated">通知用户是否有人离开或加入房间</li><li id="2b29" class="lp lq in jm b jn mq jr mr jv ms jz mt kd mu kh lw lx ly lz bi translated">将房间状态数组重构为更有效的数据结构</li><li id="95cc" class="lp lq in jm b jn mq jr mr jv ms jz mt kd mu kh lw lx ly lz bi translated">允许基于主题选择进行配对(您需要在房间对象中进行配置)</li></ul><p id="7d5b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要了解更多关于<a class="ae ki" href="http://socket.io/" rel="noopener ugc nofollow" target="_blank"> socket.io </a>的内容，可以访问官方文档。</p><p id="a82c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你喜欢读这篇文章，你可以考虑<a class="ae ki" href="https://www.buymeacoffee.com/kayode" rel="noopener ugc nofollow" target="_blank">请我喝杯咖啡</a>。</p></div></div>    
</body>
</html>