<html>
<head>
<title>Data Structures In A Nutshell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简而言之，数据结构</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/data-structures-in-a-nutshell-594195615752?source=collection_archive---------17-----------------------#2020-06-07">https://blog.devgenius.io/data-structures-in-a-nutshell-594195615752?source=collection_archive---------17-----------------------#2020-06-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="7a6f" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">简短但“扎实”地深入非原始数据结构</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi kc"><img src="../Images/70b88670cea19abd1aabce359a701e47.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*xGgaEhVE5dMD-R8krQG4PQ.gif"/></div></figure><p id="f95d" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">我们可以写很长很长的关于数据结构的文章，但是这会让任何人感到厌烦，相反，这篇文章是读者将要进入数据结构底层世界的一小步。</p><p id="3380" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">所以开始读吧。</p><h1 id="c984" class="lg lh in bd li lj lk ll lm ln lo lp lq jt lr ju ls jw lt jx lu jz lv ka lw lx bi translated">数据结构？</h1><p id="b7e8" class="pw-post-body-paragraph kk kl in km b kn ly jo kp kq lz jr ks kt ma kv kw kx mb kz la lb mc ld le lf ig bi translated">各种各样的人都需要数据结构，包括设计和开发任何系统或应用软件的计算机程序的人。</p><p id="b75b" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">数据值是程序占用的每个数据的表示。</p><p id="f3b5" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">每个程序的功能都依赖于数据值的结构和组织良好的格式。因此，我们可以说，</p><blockquote class="md"><p id="44e5" class="me mf in bd mg mh mi mj mk ml mm lf dk translated">有组织的有意安排或收集数据被称为<strong class="ak">数据结构</strong>。</p></blockquote><p id="375b" class="pw-post-body-paragraph kk kl in km b kn mn jo kp kq mo jr ks kt mp kv kw kx mq kz la lb mr ld le lf ig bi translated">通常描述的是</p><h2 id="2b2b" class="ms lh in bd li mt mu dn lm mv mw dp lq kt mx my ls kx mz na lu lb nb nc lw nd bi translated">数据结构=有组织的数据+允许的操作。</h2><h1 id="c65e" class="lg lh in bd li lj lk ll lm ln lo lp lq jt lr ju ls jw lt jx lu jz lv ka lw lx bi translated">两种类型的数据结构</h1><ol class=""><li id="f341" class="ne nf in km b kn ly kq lz kt ng kx nh lb ni lf nj nk nl nm bi translated">同构:在这里，所有的元素都是相同的类型。数组是其常见的例子，而</li><li id="fa46" class="ne nf in km b kn nn kq no kt np kx nq lb nr lf nj nk nl nm bi translated">非同质:示例包括记录。</li></ol><h2 id="45b1" class="ms lh in bd li mt mu dn lm mv mw dp lq kt mx my ls kx mz na lu lb nb nc lw nd bi translated">数据结构分类的另一种方式</h2><ol class=""><li id="917d" class="ne nf in km b kn ly kq lz kt ng kx nh lb ni lf nj nk nl nm bi translated">静态:这里，在编译时，与内存位置相关的大小和结构是固定的，并且</li><li id="0c65" class="ne nf in km b kn nn kq no kt np kx nq lb nr lf nj nk nl nm bi translated">动态:在这里，程序执行的需求需要结构的扩展或收缩以及相关存储位置的改变。</li></ol></div><div class="ab cl ns nt hr nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ig ih ii ij ik"><h1 id="568a" class="lg lh in bd li lj nz ll lm ln oa lp lq jt ob ju ls jw oc jx lu jz od ka lw lx bi translated">数组</h1><p id="f1cb" class="pw-post-body-paragraph kk kl in km b kn ly jo kp kq lz jr ks kt ma kv kw kx mb kz la lb mc ld le lf ig bi translated">数组实际上解决了涉及监控各种数据位的问题。</p><blockquote class="oe of og"><p id="65f6" class="kk kl oh km b kn ko jo kp kq kr jr ks oi ku kv kw oj ky kz la ok lc ld le lf ig bi translated">数组是一个有限的有序集合，其中的元素(本质上是同质的)存储在内存中的相邻单元中。</p></blockquote><p id="8505" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><em class="oh">阵列对回收元素很重要。</em></p><p id="2522" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">所有数组中最简单的是一个一维数组，也称为<strong class="km io">向量</strong>。</p><p id="36ea" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><code class="fe ol om on oo b">int anArrayName[n];</code>:这个C声明显示或者声明一个n个整数的一维数组。</p><blockquote class="oe of og"><p id="80ec" class="kk kl oh km b kn ko jo kp kq kr jr ks oi ku kv kw oj ky kz la ok lc ld le lf ig bi translated">注意，需要一个<strong class="km io">声明</strong>来正确分配适当的内存空间，并且C需要数组从零索引开始。</p></blockquote><p id="d492" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">同样的，<code class="fe ol om on oo b">int anArrayName[n][m];</code>是一个<strong class="km io">二维数组</strong>，有“<em class="oh">n”</em>行和“<em class="oh">m”</em>列。</p><p id="66ed" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">现在，1-D数组在映射上非常简单，可以线性地分配给存储单元。存储单元是地址和<strong class="km io">存储阵列的</strong>区域。大小和空间地址是分配数组所必需的。起始地址或基址是定位数组的一个重要部分。但由于数据是多维存储的，数据可以通过<strong class="km io">逐行</strong>或<strong class="km io">逐列</strong>存储在数组的单元中。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="oq or di os bf ot"><div class="gh gi op"><img src="../Images/393225f77a20c365039b3003af0d8b60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-7J59fzzcwJTJukFOaQdXw.png"/></div></div><figcaption class="ou ov gj gh gi ow ox bd b be z dk translated">行和列主要顺序的图示，来源:<a class="ae oy" href="https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Row_and_column_major_order.svg/170px-Row_and_column_major_order.svg.png" rel="noopener ugc nofollow" target="_blank">https://upload . wikimedia . org/Wikipedia/commons/thumb/4/4d/Row _ and _ column _ major _ order . SVG/170 px-Row _ and _ column _ major _ order . SVG . png</a></figcaption></figure><p id="40a3" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">我们通常给数组中的元素分配不同的非零值，但是当我们给大部分元素分配零元素时，会出现特殊类型的数组，称为<strong class="km io">稀疏数组</strong>。</p></div><div class="ab cl ns nt hr nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ig ih ii ij ik"><h1 id="5b84" class="lg lh in bd li lj nz ll lm ln oa lp lq jt ob ju ls jw oc jx lu jz od ka lw lx bi translated">列表</h1><p id="dc11" class="pw-post-body-paragraph kk kl in km b kn ly jo kp kq lz jr ks kt ma kv kw kx mb kz la lb mc ld le lf ig bi translated">像数组一样，列表是用来存储数据的。日常生活中常见的场景和现象可以使用列表结构轻松实现。</p><blockquote class="oe of og"><p id="f60a" class="kk kl oh km b kn ko jo kp kq kr jr ks oi ku kv kw oj ky kz la ok lc ld le lf ig bi translated">然而，列表是同一类别的线性数据对象。</p></blockquote><h2 id="1403" class="ms lh in bd li mt mu dn lm mv mw dp lq kt mx my ls kx mz na lu lb nb nc lw nd bi translated">可以在列表上执行的操作</h2><ol class=""><li id="141a" class="ne nf in km b kn ly kq lz kt ng kx nh lb ni lf nj nk nl nm bi translated">创建、排序、打印、删除列表。</li><li id="eb77" class="ne nf in km b kn nn kq no kt np kx nq lb nr lf nj nk nl nm bi translated">进行空列表检查。</li><li id="8a09" class="ne nf in km b kn nn kq no kt np kx nq lb nr lf nj nk nl nm bi translated">对于列表中的元素-搜索(包括搜索列表元素的前序和后继)、删除、在指定位置添加、检索、更新、确定其大小。</li></ol><blockquote class="oe of og"><p id="95de" class="kk kl oh km b kn ko jo kp kq kr jr ks oi ku kv kw oj ky kz la ok lc ld le lf ig bi translated">请注意，您可以统计地(最简单的实现)或动态地(使用数组索引或指针)放入一个列表。</p></blockquote><p id="4a90" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">内存存储空间的浪费，经常比声明的数组大小更短的列表以及数组大小对其大小的限制是<em class="oh">数组列表</em>实现的一些<strong class="km io">缺点</strong>。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi kc"><img src="../Images/8c62f5bd709810090789063403d682b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*hjqTSSGuZvTdQkGfewTkhg.gif"/></div><figcaption class="ou ov gj gh gi ow ox bd b be z dk translated">链表数据结构，来源:<a class="ae oy" href="https://visualgo.net/" rel="noopener ugc nofollow" target="_blank">https://visualgo.net/</a></figcaption></figure><p id="10a2" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><em class="oh">链表</em>是<strong class="km io">有利的</strong>，因为当它们的列表可以增长和收缩时，它们使用相同的空间，并且是灵活的，允许容易地快速访问列表中的任何不同项目，从而确保效率。</p><p id="89dc" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">为了克服<strong class="km io">单拉伸或链表</strong>、<strong class="km io"> <em class="oh">双或循环</em> </strong>链表结构的缺点，它们交替地使用链表的双向遍历(前者)和最后一个元素指向(后者先指向)。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="oq or di os bf ot"><div class="gh gi oz"><img src="../Images/ec17a600581f34794a1852032f0272da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*1KoGXA8mSGQdoQKdDhnQNg.gif"/></div></div><figcaption class="ou ov gj gh gi ow ox bd b be z dk translated">单向、双向和循环链表。</figcaption></figure><p id="7d10" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><strong class="km io">存储分配</strong>通过使用最佳拟合或第一fir算法，空闲空间管理重新定位碎片空闲空间，并使用垃圾收集压缩它以获得连续的空闲空间块。</p></div><div class="ab cl ns nt hr nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ig ih ii ij ik"><h1 id="8e8f" class="lg lh in bd li lj nz ll lm ln oa lp lq jt ob ju ls jw oc jx lu jz od ka lw lx bi translated">堆栈和队列</h1><blockquote class="oe of og"><p id="e4dd" class="kk kl oh km b kn ko jo kp kq kr jr ks oi ku kv kw oj ky kz la ok lc ld le lf ig bi translated">堆栈(<strong class="km io">list</strong>的特例)是一种线性数据结构，遵循后进先出(LIFO)的顺序存储和检索数据。</p></blockquote><p id="5fad" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">数据的存储和检索也称为<strong class="km io">数据移动</strong>。</p><p id="9a95" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">Stacks显示了一个与其他计算机程序类似的重要特征，那就是，它们在做其他任务的同时推迟一些任务。</p><p id="5a9c" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">由于栈只是列表的特例，这意味着它们也可以实现为数组和链表数据结构。</p><blockquote class="oe of og"><p id="fd71" class="kk kl oh km b kn ko jo kp kq kr jr ks oi ku kv kw oj ky kz la ok lc ld le lf ig bi translated">队列是另一种基本上限制访问的数据结构，在这种结构中，操作是按照接收的顺序进行的。</p></blockquote><p id="2214" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">队列在许多情况下被使用，例如在板球场排队，等待更新的选秀，保龄球堆积在队列中等等。</p><p id="167b" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">堆栈和队列的实现是相似的，因为它们涉及相似的基本操作:</p><ol class=""><li id="1e30" class="ne nf in km b kn ko kq kr kt pa kx pb lb pc lf nj nk nl nm bi translated">创建堆栈(或队列)</li><li id="d902" class="ne nf in km b kn nn kq no kt np kx nq lb nr lf nj nk nl nm bi translated">检查堆栈(或队列)是否为空</li><li id="a04a" class="ne nf in km b kn nn kq no kt np kx nq lb nr lf nj nk nl nm bi translated">检查堆栈(或队列)是否已满</li><li id="9ad3" class="ne nf in km b kn nn kq no kt np kx nq lb nr lf nj nk nl nm bi translated">初始化堆栈</li><li id="e741" class="ne nf in km b kn nn kq no kt np kx nq lb nr lf nj nk nl nm bi translated">将一个元素压入堆栈(如果未满)(或者在后面的队列中添加一个项目(入队))</li><li id="5983" class="ne nf in km b kn nn kq no kt np kx nq lb nr lf nj nk nl nm bi translated">从堆栈中弹出一个元素(如果不为空)(或者从队列前面移除一个项目(出列))</li><li id="0f91" class="ne nf in km b kn nn kq no kt np kx nq lb nr lf nj nk nl nm bi translated">读取栈顶(或队列的前面)，以及</li><li id="f075" class="ne nf in km b kn nn kq no kt np kx nq lb nr lf nj nk nl nm bi translated">打印整个堆栈(或整个队列)</li></ol></div><div class="ab cl ns nt hr nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ig ih ii ij ik"><h1 id="b19d" class="lg lh in bd li lj nz ll lm ln oa lp lq jt ob ju ls jw oc jx lu jz od ka lw lx bi translated">图表</h1><p id="395e" class="pw-post-body-paragraph kk kl in km b kn ly jo kp kq lz jr ks kt ma kv kw kx mb kz la lb mc ld le lf ig bi translated">我们知道，图是一种数学模型，在人类文明的各个领域的各种平台上都有应用。</p><blockquote class="oe of og"><p id="faec" class="kk kl oh km b kn ko jo kp kq kr jr ks oi ku kv kw oj ky kz la ok lc ld le lf ig bi translated">图由有限的顶点集(节点)和边集组成。</p></blockquote><h2 id="4519" class="ms lh in bd li mt mu dn lm mv mw dp lq kt mx my ls kx mz na lu lb nb nc lw nd bi translated">图形的类型</h2><ol class=""><li id="0016" class="ne nf in km b kn ly kq lz kt ng kx nh lb ni lf nj nk nl nm bi translated">未受指导的</li><li id="88ed" class="ne nf in km b kn nn kq no kt np kx nq lb nr lf nj nk nl nm bi translated">径直的</li><li id="001f" class="ne nf in km b kn nn kq no kt np kx nq lb nr lf nj nk nl nm bi translated">连接(弱连接或强连接)</li><li id="0976" class="ne nf in km b kn nn kq no kt np kx nq lb nr lf nj nk nl nm bi translated">未连接，以及</li><li id="78ba" class="ne nf in km b kn nn kq no kt np kx nq lb nr lf nj nk nl nm bi translated">树:连接但没有循环</li></ol><h2 id="db4c" class="ms lh in bd li mt mu dn lm mv mw dp lq kt mx my ls kx mz na lu lb nb nc lw nd bi translated">图表示</h2><ol class=""><li id="2e14" class="ne nf in km b kn ly kq lz kt ng kx nh lb ni lf nj nk nl nm bi translated">邻接矩阵:一种简单的图形表示方法，但是需要足够多的空间和时间来表示图和稀疏图</li><li id="7669" class="ne nf in km b kn nn kq no kt np kx nq lb nr lf nj nk nl nm bi translated">邻接表表示:解决了邻接矩阵表示的缺点。</li></ol><pre class="kd ke kf kg gt pd oo pe pf aw pg bi"><span id="230d" class="ms lh in oo b gy ph pi l pj pk">  A B C D<br/>A 0 1 1 1<br/>B 1 0 0 0<br/>C 1 0 0 1<br/>D 1 0 1 0</span><span id="4581" class="ms lh in oo b gy pl pi l pj pk"># A is adjacent to B, C, D<br/># C is adjacent to A, D</span><span id="c2d5" class="ms lh in oo b gy pl pi l pj pk">---------------------------------------------------------------</span><span id="bce2" class="ms lh in oo b gy pl pi l pj pk">follow = {<br/> “andromeda” : [“mars”, “ceres”],<br/> “magnum1BX” : [“ursa”, “polaris”],<br/> “earth” : [“horseheadnebula”]<br/>}</span></pre><p id="544d" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><strong class="km io">图遍历</strong>，深度优先，广度优先，意思是访问图的所有节点。</p><p id="a379" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><strong class="km io">寻找一个<strong class="km io">的最短路径问题</strong>最小成本生成树问题</strong>是由于圈的存在使得图的遍历具有挑战性而出现的一类问题。</p><blockquote class="oe of og"><p id="fce8" class="kk kl oh km b kn ko jo kp kq kr jr ks oi ku kv kw oj ky kz la ok lc ld le lf ig bi translated">注意，没有已知的有效算法来寻找旅行推销员问题，即访问加权图中每个顶点的最小成本旅行。</p></blockquote><h1 id="da78" class="lg lh in bd li lj lk ll lm ln lo lp lq jt lr ju ls jw lt jx lu jz lv ka lw lx bi translated">结论</h1><p id="5b09" class="pw-post-body-paragraph kk kl in km b kn ly jo kp kq lz jr ks kt ma kv kw kx mb kz la lb mc ld le lf ig bi translated">结构化和组织数据是开发计算机应用程序的一个基本方面。线性数据结构:数组、列表、堆栈和队列，以及数学结构:图形是学习和开始编程、设计和开发过程所必需的。我们充分意识到，图形和列表、数组一样，在我们的许多日常应用中有其用途。建议通过数据结构(包括原始数据结构)的每一节详细课程来引导自己，以获得这个领域的完整概念。</p><p id="bab4" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">希望这在某种程度上对你有益，再见！</p></div></div>    
</body>
</html>