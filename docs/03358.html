<html>
<head>
<title>A crash course on floating point numbers in a computer, Part III</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">计算机中浮点数的速成课程，第三部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/a-crash-course-on-floating-point-numbers-in-a-computer-part-iii-624f43a100aa?source=collection_archive---------2-----------------------#2020-10-26">https://blog.devgenius.io/a-crash-course-on-floating-point-numbers-in-a-computer-part-iii-624f43a100aa?source=collection_archive---------2-----------------------#2020-10-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/037794de56c63fc41edb74c9f10622bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IxlBAjmK5xAACAbo"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">詹·西奥多在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="2b96" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">计算机编程语言中的数字数据类型是什么？这是初学者首先要学的东西之一。在大多数情况下，初学者了解到该语言至少有一种整数类型和至少一种浮点数类型，这些类型是什么，以及这些类型的范围是什么。</p><p id="770d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">许多程序使用浮点计算，但是许多程序员没有意识到浮点运算的复杂性，直到精度损失导致令人不快的令人惊讶的问题。</p><p id="b072" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">初学者了解到整数类型有一个可以表示的最小整数(0 或负整数)和一个最大整数(几乎可以肯定是小于 2 的正整数)。</p><p id="feb9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">整数类型可以表示从最小值到最大值的任何整数。只要计算不超过最小值和最大值所限定的范围，就没有问题。</p><p id="c057" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">浮点类型也有它能表示的最小有理数和它能表示的最大有理数。然而，有无限多的有理数看起来在浮点类型的范围内，但它们必须是近似的。</p><p id="4e55" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而且几乎不用说，所有的无理数(像√2 和π)都必须用浮点数的有理数来近似，或者用正无穷大或者负无穷大来近似。</p><p id="2d9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">浮点数是如此的复杂，以至于这篇仅仅解释基础知识的文章也变得相当长。时间太长了，所以我决定把它分成两部分，后来又分成三部分。</p><p id="a56e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<a class="ae kc" href="https://medium.com/dev-genius/a-crash-course-on-floating-point-numbers-in-a-computer-part-i-a7a70f67a27" rel="noopener">第一部分</a>中，我解释了符号位、指数位和尾数位，浮点中“负”零的存在，以及符号、指数和尾数的什么组合代表无穷大和“不是一个数”(NaN)。</p><p id="a672" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我还解释了“正常”和“次正常”(或“反正常”)数字之间的区别。</p><p id="cd48" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第二部分的<a class="ae kc" href="https://medium.com/dev-genius/a-crash-course-on-floating-point-numbers-in-a-computer-part-ii-6fca16a0a321" rel="noopener">中，我解释了一点关于浮点运算的工作原理，以及浮点运算的优势和劣势。</a></p><p id="986e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果这些概念对你来说听起来很陌生，我强烈建议你在阅读这一部分之前先阅读第一部分和第二部分。</p><p id="3229" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二部分应该以浮点如何在主要的计算机编程语言中可用来结束。但我中断了内容，这就是这一部分的内容。</p><h1 id="0112" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">声明和初始化浮点变量</h1><p id="0c24" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">今天的 Java 程序员认为 Java 中的原始数据类型是理所当然的。这包括可作为 32 位“单精度”浮点的<code class="fe me mf mg mh b">float</code>和可作为 64 位“双精度”浮点的<code class="fe me mf mg mh b">double</code>。</p><p id="59ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">C#程序员同样认为 C#中的原始数据类型是理所当然的。这包括<code class="fe me mf mg mh b">float</code>和<code class="fe me mf mg mh b">double</code>，它们就像 Java 的一样，还有特殊类型<code class="fe me mf mg mh b">decimal</code>，它比<code class="fe me mf mg mh b">float</code>或<code class="fe me mf mg mh b">double</code>更适合表示美元和美分(但我仍然建议使用第三方库或创建自己的<code class="fe me mf mg mh b">CurrencyAmount</code>类)。</p><p id="3bdb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在。NET 方案的东西，C#类型<code class="fe me mf mg mh b">float</code>、<code class="fe me mf mg mh b">double</code>、<code class="fe me mf mg mh b">decimal</code>对应<code class="fe me mf mg mh b">System.Single</code>、<code class="fe me mf mg mh b">System.Double</code>、<code class="fe me mf mg mh b">System.Decimal</code>。想必这三个也适用于 Visual Basic。</p><p id="54b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">double</code>类型是 Java 中的“默认”浮点类型。任何包含小数点但不包含后缀“<code class="fe me mf mg mh b">f</code>”或“<code class="fe me mf mg mh b">F</code>”的数字文字都被理解为<code class="fe me mf mg mh b">double</code>。</p><p id="12a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，“<code class="fe me mf mg mh b">3.5</code>”被理解为一个<code class="fe me mf mg mh b">double</code>，即使它可以被表示为一个<code class="fe me mf mg mh b">float</code>而没有任何精度损失；如果它是一个<code class="fe me mf mg mh b">float</code>，你必须写下<code class="fe me mf mg mh b">3.5f</code>或者<code class="fe me mf mg mh b">3.5F</code>。</p><p id="d363" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 Java 和几乎所有具有浮点类型的编程语言中，使用小数点是编写浮点文字最明显的方式。</p><p id="13a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可能所有这些语言都提供了对数字文字的“科学记数法”，其中“<code class="fe me mf mg mh b">e</code>”或“<code class="fe me mf mg mh b">E</code>”后跟一个整数代表“× 10”的整数次方。比如，“<code class="fe me mf mg mh b">1.5E10</code>”表示 1.5×10⁰；<code class="fe me mf mg mh b">1.5E-10</code>表示 1.5 × 1/10 ⁰.</p><p id="b36b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这对于小数点一侧有很多零的数字来说非常方便。以下是一些例子:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="e201" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可能知道，在 Java 中，您可以使用十六进制来表示整数。原来在 Java 中，你也可以用十六进制来表示浮点文字。</p><p id="6c5b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，由于十六进制文字对阐明浮点数和位模式的关系没有什么帮助，所以它们与本文没有太大关系。在我看来，它们与十进制文字相比几乎没有任何优势。</p><p id="21a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">C++中有三种浮点类型:<code class="fe me mf mg mh b">float</code>、<code class="fe me mf mg mh b">double</code>和<code class="fe me mf mg mh b">long double</code>。但是 C++标准没有定义这些类型的字节长度，只定义了它们的最小值。所以<code class="fe me mf mg mh b">float</code>至少应该是 32 位，<code class="fe me mf mg mh b">double</code>至少应该是 64 位，<code class="fe me mf mg mh b">long double</code>应该比<code class="fe me mf mg mh b">double</code>长。</p><p id="25de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 C++中，你需要小心浮点文字。举例来说，如果你试图为一个<code class="fe me mf mg mh b">double</code>使用一个文字，但是把它放在一个<code class="fe me mf mg mh b">float</code>变量中，编译器将不得不转换它，并且转换可能是不正确的。</p><p id="1e8a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">仔细想想，不管使用什么编程语言，这都应该是一个问题。至少对于 Java，你会得到关于从<code class="fe me mf mg mh b">double</code>到<code class="fe me mf mg mh b">float</code>可能有损转换的非常明确的警告。</p><p id="e064" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Java 刚出来的时候，C++程序员不能依赖运行微软 Windows 的电脑拥有浮点硬件。例如，有必要检查 Intel 80386 的 CPU ID 的浮点单元位。</p><p id="781a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果该位为 on，程序可以使用更快的 80387 浮点指令(可以使用更老的 80287，它仍然有助于浮点计算的改进)。如果它是关闭的，浮点将不得不用整数模拟。那一定是件痛苦的事。</p><p id="7096" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Intel 80486 包括浮点功能而不需要额外的芯片，在 Java 刚出现时就已经出现了，但很可能当时仍在普遍使用较老的 80386 芯片。</p><p id="44b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着早期 Java 运行时的程序员必须考虑这些细节，从而使 Java 程序员不必担心任何特定的芯片是否能进行浮点运算。</p><p id="5b8e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我不打算试图弄清楚 C++中浮点类型的转换是如何工作的或者应该如何工作的。Java 中浮点变量的转换要简单得多，而且更有可能在不同的操作系统中保持一致。</p><p id="a15b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">万一您担心一些操作系统可能会以不同的方式执行浮点运算，Java 有<code class="fe me mf mg mh b">strictfp</code>关键字，它要求编译器和运行时严格按照 IEEE 754 标准执行浮点运算。</p><p id="cd35" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常的笑话是，有了<code class="fe me mf mg mh b">strictfp</code>，你可以保证浮点计算在所有操作系统中都是同样错误的。我还没有找到一个计算和硬件结合的具体例子，在这个例子中<code class="fe me mf mg mh b">strictfp</code>可以产生可以被检测到的最微小的差异。</p><p id="57a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当 Martin Odersky 创建 Scala 时，他继承了某些 Java 概念，但没有继承其他概念。Scala 拥有和 Java 一样的浮点“原语”类型(对于程序员来说是对象)，但是 Scala 一开始没有<code class="fe me mf mg mh b">strictfp</code>。</p><p id="1f0c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">直到最近，Scala 才添加了<code class="fe me mf mg mh b">@strictfp</code>注释，这表明 Odersky 最初并不认为<code class="fe me mf mg mh b">strictfp</code>是必要的，甚至是相关的，因为几乎所有的新 CPU 都有浮点功能。</p><p id="2263" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Java 不像 C++有<code class="fe me mf mg mh b">sizeof()</code>，但是 Java 包装类<code class="fe me mf mg mh b">Float</code>和<code class="fe me mf mg mh b">Double</code>都有常量<code class="fe me mf mg mh b">BYTES</code>。我们看到<code class="fe me mf mg mh b">Float.BYTES</code>总是 4，<code class="fe me mf mg mh b">Double.BYTES</code>总是 8。</p><p id="f881" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个 Java 包装器类都有一个常量<code class="fe me mf mg mh b">MAX_VALUE</code>，它保存该类型可以保存的最大正有限值。在<code class="fe me mf mg mh b">double</code>的情况下，那大概是 1.7976931348623157 × 10 ⁰⁸.</p><p id="7c6a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与整数原语的 Java 包装类不同，浮点原语的包装类中的每个<code class="fe me mf mg mh b">MIN_VALUE</code>常量都保存一个正数，而不是负数。</p><p id="8aee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那个正数只比零稍多一点。对于<code class="fe me mf mg mh b">float</code>和<code class="fe me mf mg mh b">double</code>，<code class="fe me mf mg mh b">MIN_VALUE</code>都是一个非规格化的数字。在<code class="fe me mf mg mh b">double</code>的情况下，它等于 1 除以 2 ⁰⁷⁴.对于<code class="fe me mf mg mh b">float</code>和<code class="fe me mf mg mh b">double</code>，<code class="fe me mf mg mh b">MIN_VALUE</code>的位模式分别对应于<code class="fe me mf mg mh b">int</code>和<code class="fe me mf mg mh b">long</code>中的 1。</p><p id="0047" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于浮点中正数和负数之间的对称性，不需要常数来保存该类型可以表示的离零最远的有限负数。如果你需要，你可以写<code class="fe me mf mg mh b">-Double.MAX_VALUE</code>。</p><p id="8377" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是在 Scala 中，<code class="fe me mf mg mh b">Float.MinValue</code>和<code class="fe me mf mg mh b">Double.MinValue</code>分别对应<code class="fe me mf mg mh b">-Float.MIN_VALUE</code>和<code class="fe me mf mg mh b">-Double.MIN_VALUE</code>。</p><p id="eab0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我重申，浮点数不能代表其所在区间的每一个有理数。例如，在<code class="fe me mf mg mh b">float</code>的情况下，这意味着一个<code class="fe me mf mg mh b">float</code>不能代表<code class="fe me mf mg mh b">Float.MIN_VALUE</code>和<code class="fe me mf mg mh b">Float.MAX_VALUE</code>之间的每一个正有理数。</p><p id="d4c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Double</code>和<code class="fe me mf mg mh b">Float</code>类有两个重要的函数，对我在本文中的研究很有帮助:<code class="fe me mf mg mh b">floatToIntBits()</code>和<code class="fe me mf mg mh b">doubleToLongBits()</code>。我用他们从我当地的斯卡拉 REPL。</p><p id="5167" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，Java 有一个“规范 NaN”的概念，在这个概念下，<code class="fe me mf mg mh b">floatToIntBits()</code>和<code class="fe me mf mg mh b">doubleToLongBits()</code>会“折叠”任何 NaN 值，对于<code class="fe me mf mg mh b">float</code>为 7FC0 0000，对于<code class="fe me mf mg mh b">double</code>为 7FF8 0000 0000 0000。但是<code class="fe me mf mg mh b">Float</code>和<code class="fe me mf mg mh b">Double</code>也提供了<code class="fe me mf mg mh b">floatToRawIntBits()</code>和<code class="fe me mf mg mh b">doubleToRawLongBits()</code>的功能。</p><p id="378a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我的系统上使用这些函数，<code class="fe me mf mg mh b">0f / 0</code>给出的 NaN 是 40 0000 而不是 7FC0 0000，操作<code class="fe me mf mg mh b">0 / 0</code>和调用<code class="fe me mf mg mh b">Math.sqrt(-1)</code>给出的 NaN 是 0000 0000 00 而不是 7FF8 0000 0000 0。我想我们可以称之为“积极的”和“消极的”NaNs。</p><p id="a8e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript(“脚本”语言只是表面上与 Java 相关)的许多奇怪之处之一是，它只有一种内置的数字数据类型，而且是 64 位浮点型。</p><p id="f127" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">几年前，我读到一个关于在 JavaScript 中添加“大整数”的提议。除了 Internet Explorer，似乎所有主要的网络浏览器现在都支持 JavaScript 中的<code class="fe me mf mg mh b">BigInt</code>(希望现在所有 Windows 10 用户都有 Edge)。</p><p id="143c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着 JavaScript 只有两种数值数据类型，TypeScript 也是如此。这两种语言都没有任何“大浮动”。</p><p id="d9c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">据我所知，FORTRAN 一直都有浮点数，但是就像 C++一样，它们也不是很标准化。显然 COBOL 确实有浮点运算，但它似乎非常依赖于系统。</p><p id="79b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我想我至少应该提到 Python。它有三种浮点类型，至少在名称上与 C#中的浮点类型相同。也许有人可以在评论里详细阐述一下。</p><h1 id="3fb1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在数字类型之间转换</h1><p id="86df" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">另一件我们认为理所当然的事情是不同数值类型之间的转换。有时我们需要从整数转换成浮点，有时反过来。</p><p id="7480" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其他时候，我们需要在不同位宽的整数类型或浮点类型之间进行转换。这些转换可以很容易地分为“缩小”转换和“扩大”转换。</p><p id="f3e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，作为 16 位有符号整数，3 和 7 分别具有位模式 0003 和 FFF9(十六进制是表示位模式的一种非常方便的方式，因为十六进制数字和二进制位之间存在 1 到 4 的对应关系)。</p><p id="e34a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将 16 位有符号整数扩展为 32 位有符号整数只需将符号位复制到额外的 16 位即可。例如，0003 扩展为 0000 0003，FFF9 扩展为 FFFF FFF9(为了可读性，我在两者中各加了一个空格)。</p><p id="66ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于收缩转换，“额外”的位被简单地砍掉。如果被截断的比特都是相同的，就不会有信息丢失。例如，FFFF FFF9 可以缩小到 FFF9，或者进一步缩小到 F9，在这两种情况下都表示 7(前提是这些都是有符号整数格式)。</p><p id="6cd6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是像 0003 FFF9 这样的 32 位有符号整数也会缩小到 FFF9 或 F9。在这两种情况下，变窄导致了不正确的符号更改，因为 262137 = 3 × 59 × 1481 超出了 8 位和 16 位整数的范围，无论有符号还是无符号。</p><p id="fa95" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">浮点类型之间的收缩转换一点也不简单，但是它们通常不会导致不正确的符号变化。尽管这肯定会降低精确度。</p><p id="fa01" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">比如 64 位浮点中的π，用位模式 4009 21FB 5444 2D18 来近似(见 Evan Wallace 的<a class="ae kc" href="http://evanw.github.io/float-toy/" rel="noopener ugc nofollow" target="_blank"> Float Toy </a>)。要将它缩小到 32 位浮点，必须去掉 32 位。</p><p id="fe18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是哪三十二位呢？特别是来自指数位的最低三位和来自尾数位的最低二十九位。以π为例，我们得到 4049 0FDA。</p><p id="00e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">表示的数字显示为 3.1415925。但是，64 位表示中显示的数字是 3.141592653589793。使用十进制运算，我们可能会将其四舍五入为 3.1415927。</p><p id="615f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过简单的截断，我们忽略了 1/16777216 的位，它是开的。为了补偿，我们应该将 1/16777216 向上舍入到 1/8388608，得到 4049 0FDB，显示为 3.1415927。</p><p id="563c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，这种简单的截断额外位的方法相当有效，部分原因是指数位偏置在这种情况下对我们有利，也就是说，2⁰总是偏置到前导指数位开启，其余的关闭。</p><p id="7512" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们想缩小 2π ≈ 6 的 64 位近似值的范围。28851 . 768686866866 位模式是 4019 21FB 5444 2D18。</p><p id="40a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是像前面那样截断得到的不是 40C9 0FDA 而是 4049 0FDA，对应的是 3.1415925 而不是 6.283185。这意味着加倍在指数位的截断中丢失了。</p><p id="88a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，为了完成缩小转换，尾数位可以被截断或舍入，这可能会导致精度损失，但指数位需要更仔细的调整。</p><p id="5fec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当收缩转换涉及到从正常转换到次正常转换时，就更加复杂了。例如，1/2 × 1/2 ⁶是一个可以用 64 位浮点精确表示为 36A0 0000 0000 0000 的数字。</p><p id="9cc1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它也可以用 32 位浮点精确表示，但请记住，在 32 位浮点中，指数只有 8 位，必要的指数 149 超出范围(也请记住，00000001 偏向 126，因此 10010101 偏向 22)。</p><p id="aacd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，这种收缩转换需要将 64 位的正常数字转换为 32 位的次正常数字。所有指数位都偏离 126，因此没有隐含的前导“1”第 23 个尾数位可以仅表示 1/2，而不是 1 + 1/2。</p><p id="678a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这使我们得到 1/2 ⁴⁹和位模式 0000 0000 0000 0001(这是十六进制的，并不重要)。所以 1/2 ⁴⁹是可以用 32 位浮点表示的最小正数。</p><p id="6478" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">任何可以用 64 位浮点表示的较小的正数在收缩转换为 32 位时都将丢失为零。</p><p id="84bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">浮点类型之间的扩大转换可以通过调整指数位并简单地在尾数位右边填充零来实现。</p><p id="ba1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是请注意，扩大转换不能弥补精度损失，就像对非常压缩的 JPEG 图像进行上采样几乎肯定不能恢复原始图像一样。</p><p id="0d07" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以π的 64 位近似值为例，我们将其“下采样”为 32 位。将其转换回 64 位浮点型，得到大约 3.1415927410125732，这对于大多数实际计算来说已经足够了，但对于天文计算来说可能不够。</p><p id="bd8d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，从整数到浮点的转换通常更有用，反之亦然。从有符号 32 位整数到 64 位浮点的转换可以看作是一种扩展转换。</p><p id="8f4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于 64 位浮点尾数有 52 位，因此任何 32 位有符号整数都可以用 64 位浮点精确表示。</p><p id="9e22" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，正如您可能已经想到的，这不是简单地将比特复制到正确的位置。如果整数是负的，就需要把它改成正的，并打开目标 64 位浮点数的符号位。当然，0 必须被视为一个特例，因为它是一个低于正常的数字。</p><p id="15c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于正数，删除最高有效位并移动其他位，以便第二个最高有效位现在是浮点数的最高有效显式尾数位。</p><p id="0c75" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，剩下要做的就是计算指数，加上偏差，并相应地设置指数位。如果 Java 还没有提供进行这种转换的方法，我们可能需要编写如下代码:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="b4ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者，不丢弃正整数的最高有效位，将它向左移动适当的空格数，然后用最低有效指数位替换最高有效位，可能会容易得多。</p><p id="0178" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">幸运的是，Java 为我们提供了一种简单的方法，通过使用强制转换语法将<code class="fe me mf mg mh b">int</code>转换成<code class="fe me mf mg mh b">double</code>。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="def7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于 Java 虚拟机来说，在任何语言中编写这样的函数都是不必要的，因为只要需要转换 32 位整数变量，编译器就可以使用<code class="fe me mf mg mh b">i2d</code>指令。</p><p id="247f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，人们希望编译器不要将这种转换应用于整数文字，而是将整数文字视为编写浮点文字，只要这样更有效。</p><p id="a618" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Scala 没有为这些转换使用强制转换语法，所有的“原始”数值类型都有<code class="fe me mf mg mh b">toDouble()</code>函数(为了一致，包括<code class="fe me mf mg mh b">Double</code>)。因此，如果<code class="fe me mf mg mh b">number</code>的类型是<code class="fe me mf mg mh b">Int</code>，<code class="fe me mf mg mh b">number.toDouble</code>得到的转换与<code class="fe me mf mg mh b">(double) number</code>在 Java 中得到的相同。</p><p id="02ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 Scala 中，你甚至可以做一些类似于<code class="fe me mf mg mh b">-73.toDouble</code>的事情，这当然比<code class="fe me mf mg mh b">-73.0</code>更冗长。我猜在科特林也差不多。</p><p id="f596" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果整数的绝对值不大于 2⁵，某些 64 位整数可以精确地转换为 64 位浮点。</p><p id="c734" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可能认为极限实际上是 2⁵，因为 64 位浮点只有 52 个尾数位。我也是这么想的，但是我忘了一个“正常”的浮点数实际上有五十三个尾数位:五十二个显式位和隐含的前导 1。</p><p id="4ee3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像 2⁵ + 7 = 4503599627370503 这样的数字可以用 64 位浮点精确表示，因为它变成了 4.5009627370503×10 ⁵.</p><p id="3f54" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是 2⁵ + 1 = 9007199254740993 在转换中变成了 9.007199254740992 × 10 ⁵。转换为 64 位浮点的最大有符号 64 位整数 9223372036854775807 显示为 9.223372036854776 × 10 ⁸.</p><p id="b1dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从技术上来说，2 到 2 ⁰的所有幂都可以用 64 位浮点精确表示，但不能用整数精度显示。和 2 ⁰ ⁴作为正无穷大丢失。</p><p id="96d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果这是一门有分数的实际课程，我会布置以下额外的学分问题:在 64 位浮点中变成正无穷大的最小整数是什么？提示:它大于 2 ⁰ + 2 ⁰。想通了就贴在评论里吧。</p><p id="0086" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回答这个额外的学分问题需要使用某种“大整数”类(<code class="fe me mf mg mh b">java.math.BigInteger</code>和<code class="fe me mf mg mh b">scala.math.BigInt</code>是您可能会有的几个选项)。</p><h1 id="894a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对浮点值进行操作</h1><p id="77b3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">这要等<a class="ae kc" href="https://medium.com/dev-genius/a-crash-course-on-floating-point-numbers-in-a-computer-part-iv-40549c7b7a93" rel="noopener">第四部</a>了。从那以后再也不会分开了，我保证。</p></div></div>    
</body>
</html>