<html>
<head>
<title>The Zen of grinding LeetCode problems: Day 12–Game of Life</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">研磨 LeetCode 问题的禅:第 12 天-生活的游戏</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/the-zen-of-grinding-leetcode-problems-day-11-game-of-life-5644995d1b0a?source=collection_archive---------6-----------------------#2022-06-17">https://blog.devgenius.io/the-zen-of-grinding-leetcode-problems-day-11-game-of-life-5644995d1b0a?source=collection_archive---------6-----------------------#2022-06-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="564e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">续<a class="ae ki" href="https://medium.com/@matei.danut.dm/the-zen-of-grinding-leetcode-problems-day-0-motivation-681842565166" rel="noopener"> <strong class="jm io"> LeetCode 日常练习系列</strong> </a> <strong class="jm io">。</strong>今日总结:<strong class="jm io"> 2 中</strong>问题<strong class="jm io"> 30 分钟。</strong>从现在开始，我将<em class="kj">过渡到灵媒</em>来迎接额外的挑战。我是这么做的。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi kk"><img src="../Images/7838f776ad82343c2682de9b129ef908.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*h105WN94-GkeMFUJ.gif"/></div></figure><h1 id="0248" class="ks kt in bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">2 的力量</h1><div class="lq lr gp gr ls lt"><a href="https://leetcode.com/problems/reordered-power-of-2/" rel="noopener  ugc nofollow" target="_blank"><div class="lu ab fo"><div class="lv ab lw cl cj lx"><h2 class="bd io gy z fp ly fr fs lz fu fw im bi translated">2 - LeetCode 的重排序幂</h2><div class="ma l"><h3 class="bd b gy z fp ly fr fs lz fu fw dk translated">给你一个整数 n。我们以任何顺序(包括原始顺序)对数字进行重新排序，这样前导…</h3></div><div class="mb l"><p class="bd b dl z fp ly fr fs lz fu fw dk translated">leetcode.com</p></div></div><div class="mc l"><div class="md l me mf mg mc mh kq lt"/></div></div></a></div><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="da16" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">见解</strong>:</p><ul class=""><li id="4aec" class="mk ml in jm b jn jo jr js jv mm jz mn kd mo kh mp mq mr ms bi translated">首先，我编写了一个函数，它接受一个数字并返回一个包含以下格式元组的集合:(digit，count)。通过这样做，我可以很容易地<strong class="jm io">检查两个数字是否有相同的数字</strong>，而不用关心它们的<em class="kj">顺序。</em>姑且称之为一个数<em class="kj">的<em class="kj">集合表示</em>。</em></li><li id="52f6" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">然后，我构建了一个列表，其中包含小于约束条件中给出的<em class="kj">限制的 2 的幂的所有集合表示</em></li><li id="4d12" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">最后，我检查了给定数字的集合表示是否在我的列表中</li><li id="4738" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">我本可以使用元组而不是集合，但是我认为这样更显而易见</li></ul><h1 id="7663" class="ks kt in bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">康威的生活游戏</h1><div class="lq lr gp gr ls lt"><a href="https://leetcode.com/problems/game-of-life/" rel="noopener  ugc nofollow" target="_blank"><div class="lu ab fo"><div class="lv ab lw cl cj lx"><h2 class="bd io gy z fp ly fr fs lz fu fw im bi translated">生活的游戏- LeetCode</h2><div class="ma l"><h3 class="bd b gy z fp ly fr fs lz fu fw dk translated">根据维基百科的文章:“生命的游戏，也简称为生命，是一个细胞自动机，由…</h3></div><div class="mb l"><p class="bd b dl z fp ly fr fs lz fu fw dk translated">leetcode.com</p></div></div><div class="mc l"><div class="my l me mf mg mc mh kq lt"/></div></div></a></div><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="812b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">见解</strong>:</p><ul class=""><li id="8730" class="mk ml in jm b jn jo jr js jv mm jz mn kd mo kh mp mq mr ms bi translated">试试谷歌“生活的游戏”，看看会发生什么:)</li><li id="4796" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated"><a class="ae ki" href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">生命的游戏</strong> </a>是一个相当简单的概念，意在展示复杂系统的<a class="ae ki" href="https://en.wikipedia.org/wiki/Emergence" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"/></a>从相对简单的规则中涌现出来。</li><li id="4138" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">它是被称为<a class="ae ki" href="https://en.wikipedia.org/wiki/Cellular_automaton" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">细胞自动机</strong> </a> <strong class="jm io">的更大一类“程序”的一部分。</strong>它们是一个简单的<strong class="jm io"> 2D 网格</strong>，带有开/关单元，以及一系列<strong class="jm io">条件</strong>，决定这些单元如何变化。</li><li id="f25b" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">如果你觉得这个主题特别吸引人，那么我强烈推荐史蒂夫·沃尔夫勒姆的书<a class="ae ki" href="https://www.wolframscience.com/nks/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"/></a><strong class="jm io"/>(是<em class="kj">免费网络版</em>的链接)。它在我的阅读清单上已经有很长一段时间了，因为它是一部跨越 1200 页的巨著，但考虑到它的作者是<a class="ae ki" href="https://www.wolframalpha.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> Wolfram Alpha </strong> </a>的创作者，我相信这是值得做的努力。</li><li id="b4d4" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated"><em class="kj">回到问题，</em>有<strong class="jm io"> 2 件事</strong>值得以后面试学习:<strong class="jm io">矩阵绑定检查</strong>和<strong class="jm io">编码信息</strong></li><li id="d7c4" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated"><em class="kj">绑定检查</em>很容易解释，基本上就是第 5 行和第 6 行。记住这一点，并在将来用它来解决你所面临的矩阵问题。这并不难，但是你应该能够在 10 秒钟之内稳定地写完，没有错误。</li><li id="c7a0" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">我之所以坚持这一点，是因为过去我决定使用<strong class="jm io"> try-except 块</strong>来编写函数，期望每当我<strong class="jm io">越界</strong>时就会出现<strong class="jm io">异常</strong>。我忘记了一个事实:在 Python 和<em class="kj"> </em>中<em class="kj">访问一个具有负索引的矩阵是可能的，它<strong class="jm io">不会触发任何异常。</strong></em></li><li id="d70a" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">编码信息是一个更宽泛的概念，但是这个概念是你想要尽可能高效地使用你正在使用的内存。在这个场景中，我可以为矩阵中的每个条目使用一个<em class="kj"> 2 元素元组</em>，一个用于旧状态<strong class="jm io">，一个用于新状态<strong class="jm io"/></strong></li><li id="a443" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">但我认为没有必要，因为我只需要<strong class="jm io"> 1s </strong>和<strong class="jm io"> 0s </strong>。所以这就是为什么我选择了一个 2 位数的表示法，第二个表示旧状态，第一个表示新状态</li><li id="1233" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">首先，我<strong class="jm io">计算新状态</strong>，并将其添加到矩阵中每个插槽的当前状态。然后，在我对所有的插槽都做了这个<em class="kj">之后，我可以用<strong class="jm io">除以 10 </strong>来得到旧的状态。现在，新的国家将取而代之。</em></li></ul></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><p id="cf63" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">结束语:</p><ul class=""><li id="c87d" class="mk ml in jm b jn jo jr js jv mm jz mn kd mo kh mp mq mr ms bi translated">我发现<strong class="jm io">计算机科学</strong>是一个有很多和<strong class="jm io">很多很酷的想法和概念要学习的领域</strong></li><li id="4c0e" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">完成了一个计算机工程大学项目后，我有足够多的机会学习这样的东西，并与许多和我有相同兴趣的人交流</li><li id="3da5" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">我意识到的是，大学毕业后，除非你去做研究，否则你开始越来越少地与生活游戏<strong class="jm io">之类的东西互动</strong></li><li id="caea" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">这并不是因为工作很无聊或者没有什么新东西要学，事实上与<strong class="jm io">相反的是真实的</strong>。但是<strong class="jm io">强调的是实用性</strong>，编写好的、可重用的代码，与他人互动，将需求转化为代码，思考架构等等。</li><li id="d912" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">尽管生活游戏很酷，但你永远不会用它来工作。也许如果你做研究并且愿意<strong class="jm io">投入数千小时</strong>，那么你可以说这是你工作的很大一部分，但除此之外它是非常小众的。</li><li id="b30b" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">那么<strong class="jm io">了解所有这些的意义是什么？</strong></li><li id="3b8c" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">一方面，<em class="kj">没有</em>。你的薪水不会增加，你不会更擅长与非程序员交谈，甚至可能会觉得无聊乏味。</li><li id="5ca9" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">另一方面，有一些公司专门寻找在计算机科学、数学、物理等领域拥有硕士学位和博士学位的人来雇佣他们，并付给他们一大笔钱来编写代码。他们写代码的速度没有那么快，但是他们的思维方式从根本上受到他们多年研究的影响</li><li id="ab44" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">那我们该怎么办？你是做<em class="kj"> 10 年的教育和研究</em>还是仅仅把它当成<em class="kj">正常的朝九晚五的工作</em>？你甚至可以是<strong class="jm io"> <em class="kj">中间的某个地方</em> </strong>？</li><li id="672e" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">我诚实的意见是，没有<strong class="jm io">没有</strong> <strong class="jm io">好答案，</strong>你应该检查你的<strong class="jm io"> <em class="kj">内在价值观和目标</em> </strong>是什么，然后<strong class="jm io"> <em class="kj">围绕它们</em> </strong>建立你的日常生活。</li><li id="b38b" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">回家并在周末合上笔记本电脑并没有本质上的好坏。一天花 10 个小时在周末<strong class="jm io">编程和看报纸上</strong>本质上没有好坏之分。只要确保你过着你想过的生活。</li></ul></div></div>    
</body>
</html>