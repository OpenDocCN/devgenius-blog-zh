<html>
<head>
<title>Node is not single-threaded!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">节点不是单线程的！</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/node-is-not-single-threaded-d73fa6a1450a?source=collection_archive---------6-----------------------#2022-10-25">https://blog.devgenius.io/node-is-not-single-threaded-d73fa6a1450a?source=collection_archive---------6-----------------------#2022-10-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="becf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可能经常在网上读到节点是单线程的。</p><p id="e351" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">人们说 node 是单线程的。然而，这并不是故事的全部。事实要复杂得多。因此，在这一节中，我们将开始研究 node 是否是真正的单线程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e992f09741584fcec697152722c9a18a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wt4oi91iDRKrjgXHJNCq3Q.png"/></div></div></figure><p id="a7b3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们用 node 启动一个程序时，事件循环的单个实例被创建并放入一个线程中。</p><p id="bfe6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这通常被认为是一件坏事，因为这意味着我们的程序只能在 CPU 的一个内核上运行。因此，如果我们的计算机上有许多 CPU 内核，那么 node 不会自动利用这些内核。</p><p id="f8d4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">换句话说，我们的程序可能无法尽可能快地运行，因为它被限制在一个单线程中。</p><p id="1cdd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，node 标准库中包含的一些函数实际上并不是单线程的。</p><p id="4ee1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">换句话说，我们运行的节点中包含的一些函数，运行在事件循环和单个线程之外。</p><p id="f83b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">事件循环使用单个线程，但是您和我编写的许多代码实际上并不完全在那个线程中执行。</p><p id="7cbf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以简单的宣称 node 是单线程并不是绝对正确的。</p><p id="c19d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了证明这一点，让我们看看下面这个简单的例子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ku"><img src="../Images/670195e017b5f28fbed98974ff1ac963.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A72yuSJ0ACQWexfOim41Dw.png"/></div></div></figure><p id="421a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们获取开始时间，我们调用函数，然后当回调被触发时，我们获取新的当前时间，我们减去旧的时间，我们应该得出计算这个哈希值用了多长时间(毫秒)。</p><p id="9498" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以看到它花了大约 600 毫秒完成(结果可能因您的机器而异)。</p><p id="7969" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，让我们再次复制并粘贴散列函数，并再次运行代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi kv"><img src="../Images/b5d077a74d75f32e07516fad70c1f018.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*927HymHYPusdjRs8ViicIA.png"/></div></div></figure><p id="cc99" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你将会看到两个与原始时间非常接近的时间。</p><p id="2482" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，当我们运行这个文件时，两个函数将几乎同时被调用。</p><p id="a2d6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请记住，一个线程对我们的 CPU 来说代表一系列线性指令，所以 CPU 必须按照它们出现的顺序来执行它们。</p><p id="d777" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们知道，调用 PBKDF2 一次大约需要 0.6 秒。</p><p id="4add" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果这真的是一个单线程系统，我预计整个过程总共需要 1.2 秒，我们得到 0.6 秒用于完成第一个调用，然后在 0.6 秒后，我们应该看到第二个控制台日志出现。</p><p id="71f2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，事实并非如此。</p><p id="b1f9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们运行我们的代码时，我们非常清楚地看到这两个日志基本上是在同一时间发生的，并且花费的时间与函数的最初运行时间差不多。</p><p id="7c0e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">实际情况是，我们在零秒启动程序，然后这两个函数调用到回调只花了 0.6 秒。</p><p id="3ef7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">很明显，这表明发生了一些事情，表明我们正在脱离 node 的单线程设置，因为如果我们只有一个单线程，我们会看到第一个函数调用完成，然后第二个函数启动。</p><p id="0707" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将稍微扩展一下这个例子，并弄清楚为什么我们会看到这种行为。</p><p id="20f6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，让我们来看一个图表，它显示了一个<strong class="jm io"> PBKDF2 </strong>函数在幕后实际发生了什么。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi kw"><img src="../Images/612424592d658d918caff1a2299ec72d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Di2ff7BgJ8VOFBbQszzjPg.png"/></div></div></figure><p id="5305" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你去 Github 上的节点<a class="ae kx" href="https://github.com/nodejs/node" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"/></a>，你会发现一堆不同的文件和文件夹。但是有两个文件夹与我们现在正在尝试做的事情非常相关，分别是<strong class="jm io"> lib </strong>和<strong class="jm io"> src </strong>文件夹。</p><p id="fe0b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> lib </strong>文件夹包含了你我在项目中需要的所有函数和模块的 JavaScript 定义。在<strong class="jm io"> src </strong>目录中是所有这些函数的 C++实现。</p><p id="3d50" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">src 目录是 node 实际放入<strong class="jm io"> libuv </strong>和<strong class="jm io"> V8 </strong>项目的地方，并且实际上清除了你我使用的所有模块的实现。</p><p id="f422" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以对于我们上面的例子，<strong class="jm io"> PBKDF2 </strong>函数实际上把所有要做的工作都委托给了 C++端。这就是实际的散列过程发生的地方。</p><p id="7e43" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">向你展示 node 如何在内部使用<strong class="jm io"> libuv </strong>会让这篇文章有点长，所以我把它留给你。</p><p id="4aa2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您还记得上一篇<a class="ae kx" href="https://yonatan-merkebu.medium.com/internal-of-snode-js-b3d2d1b2b7b3" rel="noopener">文章</a>，<strong class="jm io"> libuv </strong>给了节点<strong class="jm io">一些对底层操作系统的</strong>访问。</p><p id="3b58" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> libuv </strong>模块还有另一个职责，与标准库中<strong class="jm io">一些</strong>非常特殊的函数相关。</p><p id="b562" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于<strong class="jm io">一些</strong>标准库函数调用，<strong class="jm io">节点 C++端</strong>和<strong class="jm io"> libuv </strong>决定完全在事件循环之外进行昂贵的计算。</p><p id="d96d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">取而代之的是，他们使用一种叫做<strong class="jm io">线程池</strong>的东西。</p><p id="63c9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">线程池</strong>是一系列四个线程，可用于运行计算密集型任务，如<strong class="jm io"> PBKDF2 </strong>。</p><p id="cd76" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">默认情况下，<strong class="jm io"> libuv </strong>会在这个线程池中创建四个线程。这意味着除了用于事件循环的线程之外，还有四个<strong class="jm io">其他线程可以用来卸载需要在我们的应用程序内部进行的昂贵计算。</strong></p><p id="773b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">许多函数，包括节点标准库，将自动使用这个线程池。正如你可能想象的那样，<strong class="jm io"> PBKDF2 </strong>函数就是其中之一。</p><p id="c5f7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果<strong class="jm io">事件循环</strong>负责完成这项计算密集型任务，这意味着当我们运行<strong class="jm io"> PBKDF2 </strong>函数时，我们的节点应用程序完全不能做任何其他事情。因此，通过使用<strong class="jm io">线程池</strong>，我们可以在其他繁重的计算发生时，在我们的<strong class="jm io">事件循环</strong>中做其他事情。</p><p id="0388" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这表明 node 实际上并不完全是单线程的。在下一篇文章中，我们将更深入地研究<strong class="jm io">线程池</strong>以及我们如何有效地使用它们。所以一定要遵守。</p></div></div>    
</body>
</html>