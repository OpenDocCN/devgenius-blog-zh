<html>
<head>
<title>IndexedDB Manipulation with Dexie — Offsets, Or, and Raw Results</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带Dexie的IndexedDB操作—偏移、Or和原始结果</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/indexeddb-manipulation-with-dexie-offsets-or-and-raw-results-112c0433146?source=collection_archive---------2-----------------------#2021-02-27">https://blog.devgenius.io/indexeddb-manipulation-with-dexie-offsets-or-and-raw-results-112c0433146?source=collection_archive---------2-----------------------#2021-02-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9c1f1ddc3d53f742415e3d22683df09c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*75p9-spM0w0BmVbR"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@mattjonesdp?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马特·琼斯</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="30f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">IndexedDB是在浏览器中存储数据的一种方式。</p><p id="f967" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它允许我们以异步方式存储比本地存储更多的数据。</p><p id="d713" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Dexie使得使用IndexedDB更加容易。</p><p id="bfd0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解如何使用Dexie开始使用IndexedDB。</p><h1 id="0ebf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">忽略给定偏移量之前的前n项</h1><p id="7297" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以调用<code class="fe me mf mg mh b">offset</code>方法来返回给定偏移量后的第一个<code class="fe me mf mg mh b">n</code>项。</p><p id="ea61" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以这样使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1e1f" class="mq lc iq mh b gy mr ms l mt mu">const db = new Dexie("friends");<br/>db.version(1).stores({<br/>  friends: "id, name, age"<br/>});<br/>(async () =&gt; {<br/>  await db.friends.put({<br/>    id: 1,<br/>    name: "jane",<br/>    age: 78<br/>  });<br/>  await db.friends.put({<br/>    id: 2,<br/>    name: "mary",<br/>    age: 76<br/>  });<br/>  await db.friends<br/>    .orderBy('name')<br/>    .offset(10);<br/>})()</span></pre><p id="dbc0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们跳过集合中的前10个结果，包括其余的结果。</p><h1 id="babf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">逻辑或运算</h1><p id="c3ab" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">or</code>方法在查询中用逻辑OR运算符将两个条件组合在一起。</p><p id="e143" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8357" class="mq lc iq mh b gy mr ms l mt mu">const db = new Dexie("friends");<br/>db.version(1).stores({<br/>  friends: "id, name, age"<br/>});<br/>(async () =&gt; {<br/>  await db.friends.put({<br/>    id: 1,<br/>    name: "jane",<br/>    age: 78<br/>  });<br/>  await db.friends.put({<br/>    id: 2,<br/>    name: "mary",<br/>    age: 76<br/>  });<br/>  const someFriends = await db.friends<br/>    .where("name")<br/>    .equalsIgnoreCase("jane")<br/>    .or("age")<br/>    .above(40)<br/>    .sortBy("name")<br/>  console.log(someFriends)<br/>})()</span></pre><p id="d6d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe me mf mg mh b">'name'</code>参数调用<code class="fe me mf mg mh b">where</code>来查询名称。</p><p id="e461" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe me mf mg mh b">equalsIgnoreCase</code>找到具有给定名称的条目。</p><p id="0fde" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用<code class="fe me mf mg mh b">or</code>来查找<code class="fe me mf mg mh b">age</code>大于40的项目。</p><p id="f871" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe me mf mg mh b">sortBy</code>来按照<code class="fe me mf mg mh b">name</code>字段排序。</p><h1 id="cdc9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">获取包含集合中所有主键的数组</h1><p id="3472" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">primaryKeys</code>方法返回一个带有集合中主键数组的承诺。</p><p id="6def" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以这样使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="93d5" class="mq lc iq mh b gy mr ms l mt mu">const db = new Dexie("friends");<br/>db.version(1).stores({<br/>  friends: "id, name, age"<br/>});<br/>(async () =&gt; {<br/>  await db.friends.put({<br/>    id: 1,<br/>    name: "jane",<br/>    age: 78<br/>  });<br/>  await db.friends.put({<br/>    id: 2,<br/>    name: "mary",<br/>    age: 76<br/>  });<br/>  const keys = await db.friends<br/>    .where("name")<br/>    .equalsIgnoreCase("jane")<br/>    .primaryKeys()<br/>  console.log(keys)<br/>})()</span></pre><p id="ee3d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">id</code>是每个条目的主键。</p><p id="eb5b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用<code class="fe me mf mg mh b">primaryKeys</code>返回一个带有主键数组的承诺。</p><h1 id="f165" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">获得原始结果</h1><p id="8f88" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">raw</code>方法从查询中获得原始结果。</p><p id="0066" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果不会通过阅读挂钩过滤。</p><p id="b011" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4e52" class="mq lc iq mh b gy mr ms l mt mu">const db = new Dexie("friends");<br/>db.version(1).stores({<br/>  friends: "id, name, age"<br/>});<br/>(async () =&gt; {<br/>  await db.friends.put({<br/>    id: 1,<br/>    name: "jane",<br/>    age: 78<br/>  });<br/>  await db.friends.put({<br/>    id: 2,<br/>    name: "mary",<br/>    age: 76<br/>  });<br/>  const keys = await db.friends<br/>    .where("name")<br/>    .equalsIgnoreCase("jane")<br/>    .raw()<br/>    .toArray()<br/>  console.log(keys)<br/>})()</span></pre><p id="dce1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">去使用它。</p><p id="be81" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe me mf mg mh b">raw</code>不会将对象映射到它们映射的类。</p><h1 id="5c99" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="3df0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以忽略结果中的第一个<code class="fe me mf mg mh b">n</code>项，获取主键，并使用Dexie从IndexedDB集合中获取原始结果。</p></div></div>    
</body>
</html>