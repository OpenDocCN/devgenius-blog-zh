<html>
<head>
<title>Software Engineer must know about HTTP Keep Alive (Demo Using Wireshark)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">软件工程师必须了解 HTTP Keep Alive(使用 Wireshark 演示)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/software-engineer-must-know-about-http-keep-alive-demo-using-wireshark-8bb2803eecf3?source=collection_archive---------12-----------------------#2022-07-04">https://blog.devgenius.io/software-engineer-must-know-about-http-keep-alive-demo-using-wireshark-8bb2803eecf3?source=collection_archive---------12-----------------------#2022-07-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="58b6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">读者们好，</p><p id="c68c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi ki translated">每次工作时，每个后端开发者都会抱怨系统太慢或者没有响应或者服务太慢。有时开发人员说系统运行良好，但有时很慢。我们需要弄清楚为什么慢或者为什么它有时变得很慢。如果您认为可以添加更多实例来扩展它。但是它制造了更多问题，却没有解决问题。这是一个关键问题为什么？问题传递给不同的团队，例如开发团队传递给网络团队说网络慢，网络团队说不，这是服务器端的问题，问题传递到每个地方。因为这是你的服务，你不能告诉谁是错的，否则你有一个明确的证据，为什么它很慢。</p><p id="c3b9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们使用 HTTP 时，有两个分支叫做<br/> 1。持久性 HTTP <br/> 2。非持久性 HTTP</p><p id="67d3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">非持久性 HTTP 主要是 HTTP 1.0，我们不使用它，但有时当我们处理遗留系统时，您可能会使用它。然而，当我们打开一个连接时，我们发送一条消息，得到响应，然后关闭连接。</p><p id="bb76" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们有一个叫<strong class="jm io"> RTT 的东西，往返时间。</strong>因此，你将数据包发送到服务器，然后返回到客户端，这就是我们所说的往返时间。为了发送消息，我们需要打开一个连接，发送消息，获得响应，然后关闭连接。</p><p id="9696" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，假设您需要打开一个包含 10 个 JavaScript 文件的 HTML 页面。现在，您必须向服务器发送 10 个不同的请求来获取文件。所以这个过程很慢，所以他们引入了 HTTP 1.1，即<strong class="jm io">持久性 HTTP </strong>。</p><p id="7536" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">再次强调持久性 HTTP 有两个部分。<br/> 1。隧道<br/> 2。没有隧道</p><p id="04c6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">主要是<strong class="jm io"> HTTP 1.1 走隧道</strong>。这是如何工作的，你建立连接，你发送消息，你得到响应，最后你关闭连接。这个程序很像 TCP。但是这里有一个棘手的部分。<br/>如果你正在发送一个请求到后端服务器，服务器正在做一些任务或忙于任务。由于此 HTTP get 关闭连接，因为服务器没有响应。为了避免这种情况，我们使用了一种叫做<strong class="jm io">保持活动状态</strong>的特殊技术。这意味着我们只需向服务器发送 ping 命令，告诉它保持连接。有时，如果我们发送一个请求，你得到响应，你发送另一个请求，告诉服务器保持连接。</p><p id="b2b9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看一看 Wireshark 的演示</p><h2 id="f62b" class="kr ks in bd kt ku kv dn kw kx ky dp kz jv la lb lc jz ld le lf kd lg lh li lj bi translated">考虑场景 1:</h2><h2 id="d84b" class="kr ks in bd kt ku kv dn kw kx ky dp kz jv la lb lc jz ld le lf kd lg lh li lj bi translated"><strong class="ak">第一步:</strong> <br/>我们需要使用<strong class="ak"> Express 模块编写 Node.js 代码。然后我们需要运行代码</strong></h2><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi lk"><img src="../Images/36abcf0a46135cbe7ad4f2aa8b5c313e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gfVOsSGr5-j66XZ5i542gA.png"/></div></div></figure><blockquote class="lw lx ly"><p id="b5aa" class="jk jl lz jm b jn jo jp jq jr js jt ju ma jw jx jy mb ka kb kc mc ke kf kg kh ig bi translated">如果您的项目中没有安装 express，只需在您的 PowerShell 上使用以下代码<br/><strong class="jm io">NPM install Express<br/></strong>安装 Express 并获取所需的文档</p></blockquote><h2 id="092d" class="kr ks in bd kt ku kv dn kw kx ky dp kz jv la lb lc jz ld le lf kd lg lh li lj bi translated"><strong class="ak">第二步:<br/> </strong>打开 Wireshark，打开环回接口，过滤 8191 端口流量。<br/><strong class="ak"><em class="md">TCP . port = = 8191</em></strong></h2><h2 id="9d17" class="kr ks in bd kt ku kv dn kw kx ky dp kz jv la lb lc jz ld le lf kd lg lh li lj bi translated"><strong class="ak">第三步:<br/> </strong>打开你最喜欢的浏览器，在搜索栏上输入“<strong class="ak"><em class="md">【localhost:8191/wait】</em></strong>，点击回车键。</h2><h2 id="7526" class="kr ks in bd kt ku kv dn kw kx ky dp kz jv la lb lc jz ld le lf kd lg lh li lj bi translated">步骤 4: <br/>检查 Wireshark</h2><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi me"><img src="../Images/952b1aa3975fb4ec6abd6e2694826cd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nagb5HNBL_gmCCVLe92q3Q.png"/></div></div></figure><p id="b5d1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Wireshark 连接中的前 3 行以<strong class="jm io"> SYN </strong>开始，然后是 TCP 3 次握手中的<strong class="jm io"> SYN ACK </strong>和<strong class="jm io"> ACK </strong>。之后，我们可以看到 HTTP 发送请求并得到响应。<br/>第 18 行服务器<strong class="jm io">发送 FIN </strong>关闭连接，对于响应客户端也发送 ACK，但是<strong class="jm io">客户端没有关闭连接。<br/>后</strong>指不定客户端发送 Keep-alive 以保持连接。因此，服务器正在做的是<strong class="jm io">向客户端</strong>发送一个重置包(最后一行红色)。</p><h2 id="24ff" class="kr ks in bd kt ku kv dn kw kx ky dp kz jv la lb lc jz ld le lf kd lg lh li lj bi translated">考虑场景 2:</h2><p id="9940" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">如果我们连续发送请求，让我们检查后端如何表现。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi mk"><img src="../Images/cb07a43f1c652bb89fee9af28c7594dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WdKPVDqhJFb-3jta5je0sA.png"/></div></div></figure><p id="61b7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我在浏览器中处于私人模式，并不断发送请求。我们可以看到连接在前 3 行打开，我们请求 HTTP 上的连接，得到响应并继续。我们可以看到<strong class="jm io">没有鳍。<br/> </strong>这里发生的是，<strong class="jm io">客户端只是跳过了与后端的对话，后端并没有试图关闭连接。</strong>这就是<strong class="jm io">持久性 HTTP </strong>的含义。</p><h2 id="2bed" class="kr ks in bd kt ku kv dn kw kx ky dp kz jv la lb lc jz ld le lf kd lg lh li lj bi translated">考虑场景 3:</h2><p id="93af" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">在这里，我所做的是发送一个请求，得到响应并关闭浏览器。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi ml"><img src="../Images/e2c0a4f89190a703b1ec58279f621207.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aHARXhYLmf_W6BFnnP7bWg.png"/></div></div></figure><p id="6888" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以看到，在发送消息之前，连接照常初始化。之后，HTTP 发送消息，客户端得到响应。这是一个重要的部分。在服务器<strong class="jm io">关闭连接发送 FIN </strong>和客户端响应<strong class="jm io">之后，当我们关闭浏览器</strong>时，这意味着<strong class="jm io">客户端也通过发送 FIN 包到服务器</strong>来关闭连接。这是一个完整的循环。</p><h2 id="a0bc" class="kr ks in bd kt ku kv dn kw kx ky dp kz jv la lb lc jz ld le lf kd lg lh li lj bi translated">考虑场景 4:</h2><p id="f23c" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">在这种情况下，我们需要对代码做一个小的修改。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi mm"><img src="../Images/8b3d82d203a50115e018663e9bd5968a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dcE-bZUfn9vV6OXC-3evaQ.png"/></div></div></figure><p id="e82e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，请求将到来并等待 1 分钟，然后服务器将响应。看看 Wireshark 会发生什么。</p><p id="05f8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">发送消息等待 1 分钟。在浏览器中等待响应。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi mn"><img src="../Images/ffa6c9bc8c9f9216d13e24477d29a26b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SX52pyjLI8VZ7tMkQggrGg.png"/></div></div></figure><p id="5364" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因为它没有接收到任何发送保持活动响应客户端</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi mo"><img src="../Images/2e385c4d6b14fcb4697a7dbca3f08315.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*67or7BtdEtGeJoP_iPJ1rQ.png"/></div></div></figure><p id="7a93" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">1 分钟后，客户端得到服务器的响应。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi mo"><img src="../Images/151869029401613dc6d120ad2947bf6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d9P8J_AJGrVYqNuuP8br2Q.png"/></div></div></figure><h2 id="48f5" class="kr ks in bd kt ku kv dn kw kx ky dp kz jv la lb lc jz ld le lf kd lg lh li lj bi translated">惊人的正确！！！</h2><h2 id="e9ef" class="kr ks in bd kt ku kv dn kw kx ky dp kz jv la lb lc jz ld le lf kd lg lh li lj bi translated">我们还有另一种情况:</h2><p id="21f5" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">让我们检查一下，如果我们在 1 分钟内关闭服务器，会发生什么。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/7ee70e24dd81f9a7576f5e4a20f5b6e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*nNyAGASdf3nlz0FAUXB_1A.png"/></div></figure><p id="5d46" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种情况下，在完成连接之前，服务器由于某种原因崩溃了。自从保活时间后服务器没有响应，现在服务器不断向客户端发送 RST 数据包。因为客户端试图启动与服务器的新连接。客户端向服务器发送请求，但服务器关闭连接。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi mq"><img src="../Images/a356c631fbf4593e945b1b5cd2396ba2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZmyqdWneHIcebcGq7rhOrw.png"/></div></div></figure><p id="acdc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">参考—<a class="ae mr" href="https://youtu.be/Yf06faA5-JY" rel="noopener ugc nofollow" target="_blank">https://youtu.be/Yf06faA5-JY</a></p></div></div>    
</body>
</html>