<html>
<head>
<title>Best of Modern JavaScript — Errors, Strings, and Arrays</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代 JavaScript 的精华——错误、字符串和数组</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/best-of-modern-javascript-errors-strings-and-arrays-8251e8af2d4?source=collection_archive---------6-----------------------#2020-09-05">https://blog.devgenius.io/best-of-modern-javascript-errors-strings-and-arrays-8251e8af2d4?source=collection_archive---------6-----------------------#2020-09-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ec22697465d989fc7d7e76135994b23e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mdX5MPynqbeDN09G"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图片由<a class="ae kc" href="https://unsplash.com/@visuals?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">视觉效果</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="e19a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自 2015 年以来，JavaScript 有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究 JavaScript 的核心特性。</p><h1 id="cb22" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有更多自定义错误构造函数</h1><p id="475f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在 ES6 或更高版本中，我们不必再编写自己的错误构造函数。</p><p id="9f25" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们只是创建了一个<code class="fe me mf mg mh b">Error</code>的子类，这样我们就可以用一致的信息创建错误，比如堆栈跟踪。</p><p id="8601" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4e67" class="mq lc iq mh b gy mr ms l mt mu">function FancyError() {<br/>  var parent = Error.apply(null, arguments);<br/>  copyProperties(this, parent);<br/>}<br/>FancyError.prototype = Object.create(Error.prototype);<br/>FancyError.prototype.constructor = FancyError;</span><span id="73a8" class="mq lc iq mh b gy mv ms l mt mu">function copyProperties(target, source) {<br/>  Object.getOwnPropertyNames(source)<br/>    .forEach(function(propKey) {<br/>      var desc = Object.getOwnPropertyDescriptor(source, propKey);<br/>      Object.defineProperty(target, propKey, desc);<br/>    });<br/>};</span></pre><p id="0ca7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了创建<code class="fe me mf mg mh b">Error</code>的子构造函数，我们编写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0c43" class="mq lc iq mh b gy mr ms l mt mu">class FancyError extends Error {<br/>}</span></pre><p id="4e4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们没有通过调用带有一些参数的<code class="fe me mf mg mh b">Error</code>构造函数来创建<code class="fe me mf mg mh b">FancyError</code>构造函数，而是使用<code class="fe me mf mg mh b">extends</code>来创建子类。</p><p id="6598" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">构造函数没有属性<code class="fe me mf mg mh b">Error</code>，所以我们必须像第一个例子一样用<code class="fe me mf mg mh b">copyProperties</code>函数复制它们。</p><p id="d38e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe me mf mg mh b">Error</code>对象获取属性描述符，并调用<code class="fe me mf mg mh b">Object.defineProperty</code>来创建属性。</p><p id="2477" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于第二个例子，我们什么都不用做。</p><p id="c342" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些属性将被自动继承。</p><h1 id="2a3a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对象到地图</h1><p id="b7aa" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在 ES6 或更高版本中，我们可以使用映射来存储键值对。</p><p id="45ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 ES6 之前，我们所有的都是普通对象。</p><p id="5d1c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 ES6 或更高版本中，我们可以使用<code class="fe me mf mg mh b">Map</code>构造函数通过编写以下内容来创建我们的地图:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="604e" class="mq lc iq mh b gy mr ms l mt mu">const map = new Map();<br/>map.set('foo', 'bar');<br/>map.set('count', 1);</span></pre><p id="fb93" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe me mf mg mh b">set</code>方法，将键和值作为第一个和第二个参数来添加或更新它们的键-值对。</p><h1 id="0c7e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">字符串方法</h1><p id="f55d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">ES6 提供了我们可以使用的新的字符串方法。</p><p id="8b84" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">startsWith</code>方法让我们检查一个字符串是否以给定的子字符串开始。</p><p id="48b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c04b" class="mq lc iq mh b gy mr ms l mt mu">str.startsWith('x')</span></pre><p id="78e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，字符串有<code class="fe me mf mg mh b">endsWith</code>方法让我们检查一个字符串是否以给定的子字符串结尾。</p><p id="9a7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="06dd" class="mq lc iq mh b gy mr ms l mt mu">str.endsWith('x')</span></pre><p id="9517" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果以给定的子字符串开始或结束，它们都返回<code class="fe me mf mg mh b">true</code>。</p><p id="9b0b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">includes</code>方法让我们检查一个字符串是否包含给定的子字符串。</p><p id="f86a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6c78" class="mq lc iq mh b gy mr ms l mt mu">str.includes('x')</span></pre><p id="0618" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe me mf mg mh b">str</code>上的<code class="fe me mf mg mh b">includes</code>来检查<code class="fe me mf mg mh b">'x'</code>是否包含在内。</p><p id="8b45" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果包含，则返回<code class="fe me mf mg mh b">true</code>，否则返回<code class="fe me mf mg mh b">false</code>。</p><p id="f5a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">repeat</code>方法来重复一个字符串。</p><p id="c8e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ae24" class="mq lc iq mh b gy mr ms l mt mu">'foo'.repeat(3)</span></pre><p id="bcee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">重复<code class="fe me mf mg mh b">'foo'</code> 3 次。</p><h1 id="0559" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">数组方法</h1><p id="0870" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">ES6 提供了新的数组方法，使得数组操作更加容易。</p><p id="69f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">findIndex</code>方法来返回数组条目的索引。</p><p id="5d78" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它需要一个回调函数来处理我们正在寻找的条件。</p><p id="e582" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8d44" class="mq lc iq mh b gy mr ms l mt mu">const arr = ['foo', NaN, 'bar'];<br/>arr.findIndex(x =&gt; Number.isNaN(x));</span></pre><p id="31b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们传递了一个回调函数来检查<code class="fe me mf mg mh b">NaN</code>是否在<code class="fe me mf mg mh b">arr</code>数组中。</p><p id="ad0d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这比<code class="fe me mf mg mh b">indexOf</code>更有用，因为它不需要回调来检查。</p><p id="71cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者 spread 操作符让我们将可迭代对象转换成数组。</p><p id="a354" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 ES6 之前，我们只有<code class="fe me mf mg mh b">slice</code>方法。</p><p id="1434" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5b5c" class="mq lc iq mh b gy mr ms l mt mu">var arr1 = Array.prototype.slice.call(arguments);</span></pre><p id="e724" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 ES5 或更早的版本中，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f434" class="mq lc iq mh b gy mr ms l mt mu">const args = Array.from(arguments);</span></pre><p id="0ab2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="bfeb" class="mq lc iq mh b gy mr ms l mt mu">const args = [...arguments];</span></pre><p id="3aa6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用 ES6 或更高版本。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/23b13f3a9442ddf050d55337ad9e4525.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DsmZ-1tmSfNJSvew"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@hhh13?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">傅甬 华</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="860d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="3168" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">ES6 对字符串、数组和错误进行了许多有用的增强。</p><p id="78df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没有他们很难活下去。</p></div></div>    
</body>
</html>