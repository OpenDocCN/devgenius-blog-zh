<html>
<head>
<title>Algorithms With JavaScript: Merge k Sorted Lists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript算法:合并k个排序列表</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/algorithms-with-javascript-merge-k-sorted-lists-2a76b39ddd8?source=collection_archive---------6-----------------------#2020-07-10">https://blog.devgenius.io/algorithms-with-javascript-merge-k-sorted-lists-2a76b39ddd8?source=collection_archive---------6-----------------------#2020-07-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1715" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">像往常一样，在这篇博文中，我们将练习解决算法问题。而今天我们的leetcode问题是:<a class="ae kl" href="https://leetcode.com/problems/merge-k-sorted-lists" rel="noopener ugc nofollow" target="_blank">合并k个排序列表</a>。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/aec87d9b42fb0bfb0b9b99664391aef8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uYKlpkbBDlicuNXQKLJDRg.jpeg"/></div></div></figure><p id="4c1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">问题定义:</strong></p><p id="0756" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="ky">合并k个排序链表，作为一个排序链表返回。</em></p><p id="79ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="ky">举例:</em></p><pre class="kn ko kp kq gt kz la lb lc aw ld bi"><span id="1392" class="le lf iq la b gy lg lh l li lj"><em class="ky">Input:</em></span><span id="74a4" class="le lf iq la b gy lk lh l li lj"><em class="ky">[</em></span><span id="ad78" class="le lf iq la b gy lk lh l li lj"><em class="ky">1-&gt;4-&gt;5,</em></span><span id="47fc" class="le lf iq la b gy lk lh l li lj"><em class="ky">1-&gt;3-&gt;4,</em></span><span id="07f0" class="le lf iq la b gy lk lh l li lj"><em class="ky">2-&gt;6</em></span><span id="553b" class="le lf iq la b gy lk lh l li lj"><em class="ky">]</em></span><span id="668e" class="le lf iq la b gy lk lh l li lj"><em class="ky">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</em></span></pre><p id="5f4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">两个排序列表</strong></p><p id="412f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在只有两个排序列表的情况下，我们可以使用带有两个指针的简单二分搜索法。类似地，就像我们对两个排序列表的中位数问题所做的一样。但是当我们有3个或更多的列表要遍历时，就变得有点复杂了。</p><p id="8286" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> K排序列表</strong></p><p id="29f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先让我们检查我们的输入中有多少列表。这将帮助我们确定我们需要多少个指针。在两个列表的情况下，我们可以硬编码两个指针，这样就可以了。但是对于未知数量的列表，我们需要不同的方法来跟踪指针和它们的位置。</p><p id="c37c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，我们将有一个问题越来越复杂的比较。在两个列表的情况下，我们将只需要做一次比较操作，在4个列表的情况下，做4次操作，以此类推。如果我们有100个列表，那么硬编码条件就不那么优雅了。我们需要想出一个聪明的方法来同时比较所有的数字。</p><p id="28a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="ky">每次迭代进行K次比较的时间复杂度:</em></p><pre class="kn ko kp kq gt kz la lb lc aw ld bi"><span id="7ecc" class="le lf iq la b gy lg lh l li lj"><em class="ky">O(N * K * K)</em></span></pre><p id="2e4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="ky">排序算法的时间复杂度:</em></p><pre class="kn ko kp kq gt kz la lb lc aw ld bi"><span id="9772" class="le lf iq la b gy lg lh l li lj"><em class="ky">O(N * K * log(N * K))</em></span></pre><p id="5a23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Seams like it把所有列表组合在一个长列表中，然后编写这个列表的排序算法，效率会变得更高。</p><p id="fa5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">两人站成一排</strong></p><p id="2524" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先让我们写一个while循环，它将合并所有的列表，不管我们输入了多少个列表。我们将同时处理两个列表，并且会一直进行下去，直到输入列表的长度超过1。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ll"><img src="../Images/cc0d234419e114a9028576ae691c8ff6.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*c2ah5GGuoKe6mw7ipRUjcQ.png"/></div></figure><p id="832b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">合并功能</strong></p><p id="e70b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你在上面的图片中看到的，我们递归地使用了<strong class="jp ir">合并列表</strong>。这个函数负责排序和合并当时的两个列表。请记住，这些列表已经单独排序，这意味着我们可以对它们执行简单的二分搜索法。我们将使用另一个while循环，它将一直工作到a或b列表不为空。在循环内部，我们有一个条件，如果a小于b，那么我们更新指针，移动到列表的下一个值，如果它大于b，那么我们更新指针，移动到列表的下一个值。下面是margeLists 函数的样子:</p><p id="48d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">解决方案</strong></p><p id="f632" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在所有的列表被合并和排序后，我们在列表变量中只有一个列表。我们在这个变量中返回0索引。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="2f28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">结论</strong></p><p id="2590" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于软件工程师来说，使用不同的数据结构是很重要的。以下是leetcode对我们解决方案效率的看法:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/0e0ed4cdd81a6793b4a931011be4b150.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*RQE5rKF0hV6eGGW7xCdnxg.png"/></div></figure><p id="fe6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看起来我们的解决方案的效率还可以更高。我会继续努力优化，并尝试不同的方法来解决这个问题。敬请期待！</p><p id="a525" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不断学习，不断成长！</p><p id="db65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们上<a class="ae kl" href="https://www.linkedin.com/in/pavel-ilin" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>连线吧！</p></div></div>    
</body>
</html>