<html>
<head>
<title>Observer Design Pattern Tutorial</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">观察者设计模式教程</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/observer-pattern-explanation-a-trial-of-blending-theory-with-practical-d68c8a482f38?source=collection_archive---------3-----------------------#2020-07-17">https://blog.devgenius.io/observer-pattern-explanation-a-trial-of-blending-theory-with-practical-d68c8a482f38?source=collection_archive---------3-----------------------#2020-07-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="332c" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://codeburst.io/design-patterns-101-9fe18d5a1bd9?source=friends_link&amp;sk=e0a82f4a24100530f9c079a71fe5a706" rel="noopener" target="_blank">设计模式101 </a></h2><div class=""/><div class=""><h2 id="befc" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">脸书集团的订阅和通知系统是观察者模式的一个很好的例子。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/6a9d51c9845d961779d43de48a8d323e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UAu9tmn4rQdGqSbl2i5_VA.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@joy_photo" rel="noopener ugc nofollow" target="_blank">乔伊·查克拉博蒂</a>拍摄</figcaption></figure><p id="ec4a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">设计模式是软件工程中<strong class="lh ja"> <em class="mb">最重要但又令人害怕的</em> </strong>方面之一，尤其是对于那些刚接触这个话题的人来说。当我开始我的助理架构课程时，我自己很难理解不同软件设计模式的思想。</p><blockquote class="mc md me"><p id="44b9" class="lf lg mb lh b li lj ka lk ll lm kd ln mf lp lq lr mg lt lu lv mh lx ly lz ma ij bi translated"><strong class="lh ja">学习设计模式困难的主要原因是模式中使用的术语一开始很难理解。作为一名开发人员，程序员更容易从代码中理解这个想法，那么这些术语就不会显得那么复杂。所以，这是一次将理论和代码融合在一起的尝试。</strong></p></blockquote><p id="65ee" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><em class="mb">第一部分从一个重要的模式开始，观察者设计模式。</em></p><blockquote class="mi"><p id="c19c" class="mj mk iq bd ml mm mn mo mp mq mr ma dk translated">根据维基百科，观察者模式是一种软件设计模式，在这种模式中，一个名为subject的对象维护一个名为observer的依赖者列表，并自动通知它们任何状态变化，通常是通过调用它们的方法之一。</p></blockquote><p id="e449" class="pw-post-body-paragraph lf lg iq lh b li ms ka lk ll mt kd ln lo mu lq lr ls mv lu lv lw mw ly lz ma ij bi translated">如果你是第一次设计模式，那么这个定义有点难以理解。让我们来看一个例子。现在是数字媒体的时代。我们都知道脸书或任何社交媒体上的团体订阅和通知。因此，当你试图描绘观察者模式时，一个群组订阅服务，其群组是发布者，用户是订阅者，这是一个很好的可视化模式的方式。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mx"><img src="../Images/dd9dc191381fe4e448a6e714085e5ffd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KTKBBRTdrRbOGFSHM-kqiA.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">图1:作为观察者模式示例的组订阅和通知</figcaption></figure><p id="ee81" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">您关注您感兴趣的群组以获取该群组的更新。所以你是那个团体的订阅者/追随者。现在，如果有帖子更新，来自该群的通知将出现在您的时间线中。Y <strong class="lh ja">你是订阅者，群组是发布者，群组拥有你的个人资料信息，因此当有新帖子更新时，它会向你发送通知。</strong>这种<strong class="lh ja"> </strong> <em class="mb">订阅机制</em> <strong class="lh ja"> </strong>正是我们需要观察者设计模式的地方。</p><p id="be0e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果你了解MVC模式，模型-视图-控制器的“视图”部分可以描述为观察者。当UI元素更改状态时，它的所有依赖项都会得到通知并自动更新。</p><p id="f7c3" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">为了理解观察者，我们需要把观察者模式分成三个部分。观察者模式有<strong class="lh ja">三个部分。</strong></p><p id="8cc6" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">I)主题/出版商</p><p id="b181" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">ii)观察员/订户，以及</p><p id="4782" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">iii)客户。</p><p id="6707" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在观察者模式中，我们称发布者为<strong class="lh ja">主体</strong>，订阅者为<strong class="lh ja">观察者</strong>。客户端仅仅意味着<strong class="lh ja">主</strong>函数，所以不需要担心这个。所以我们可能会这样想:</p><blockquote class="mi"><p id="a9f4" class="mj mk iq bd ml mm mn mo mp mq mr ma dk translated">发布者+订阅者=观察者模式。</p></blockquote><p id="e648" class="pw-post-body-paragraph lf lg iq lh b li ms ka lk ll mt kd ln lo mu lq lr ls mv lu lv lw mw ly lz ma ij bi translated">仅仅通过阅读理论来学习设计模式有点困难，因为模式中使用了不同的术语。例如在这个模式中，我们有<strong class="lh ja">主体</strong>、<strong class="lh ja">观察者</strong>和<strong class="lh ja">客户端</strong>。程序员更容易从代码中理解这个想法。所以我会用代码来描述模式。示例代码是用java编写的，您可以使用自己喜欢的任何面向对象的语言。也许以后我会尝试用其他语言代码链接编辑文章。</p><p id="6c76" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><em class="mb">对于刚开始设计图案的人，请尝试自己写一次，会对你有奇效。</em></p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="5f49" class="nf ng iq bd nh ni nj nk nl nm nn no np kf nq kg nr ki ns kj nt kl nu km nv nw bi translated">主题/出版商:</h1><p id="3a36" class="pw-post-body-paragraph lf lg iq lh b li nx ka lk ll ny kd ln lo nz lq lr ls oa lu lv lw ob ly lz ma ij bi translated">在观察者模式中，发布者被称为<strong class="lh ja">主题。</strong><strong class="lh ja">主体</strong>维护一个<strong class="lh ja">观察者</strong>列表，并自动通知他们任何状态<strong class="lh ja">变化</strong>。观察者模式中的主体有三个任务:</p><blockquote class="mc md me"><p id="5156" class="lf lg mb lh b li lj ka lk ll lm kd ln mf lp lq lr mg lt lu lv mh lx ly lz ma ij bi translated">提供注册和删除观察者的方法。</p><p id="73d1" class="lf lg mb lh b li lj ka lk ll lm kd ln mf lp lq lr mg lt lu lv mh lx ly lz ma ij bi translated">ii)维护其观察员/订户的列表。</p><p id="8a89" class="lf lg mb lh b li lj ka lk ll lm kd ln mf lp lq lr mg lt lu lv mh lx ly lz ma ij bi translated">iii)并在任何状态改变时自动通知它们。主体向所有注册的观察者广播事件。</p></blockquote><blockquote class="mi"><p id="e0dd" class="mj mk iq bd ml mm oc od oe of og ma dk translated">因为它将通知观察者对象它的状态的变化，所以它也被称为发布者。</p></blockquote><p id="1a52" class="pw-post-body-paragraph lf lg iq lh b li ms ka lk ll mt kd ln lo mu lq lr ls mv lu lv lw mw ly lz ma ij bi translated"><em class="mb">为了实现，我们将定义一个</em> <strong class="lh ja"> <em class="mb">接口</em> </strong> <em class="mb">作为主体。</em>任何实现这个接口的类都是观察者模式中的主体。该类必须定义下面代码中给出的这三个函数。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oh oi l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">主题接口代码</figcaption></figure><p id="998f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">从图1中可以看出，用户订阅了一个组，当有新帖子更新时，用户会收到通知。我们例子中的组类是<strong class="lh ja">主题</strong> / <strong class="lh ja">发布者</strong>。因此，它必须实现<strong class="lh ja">主题</strong>接口。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oj"><img src="../Images/b272306bff0b1d9f72f4d06c49e68e57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N7nmbbIuif9pO_4uK3n33g.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">图二。类图</figcaption></figure><p id="8f0d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在很多书和网站上，你会看到他们放了一个带有concreteSubject或者concreteObserver的概化结构图。我发现作为一个初学者很难把这么多通用公式联系起来。因此，为了更好的理解，我们在这里保留了一个类图。完成这个实现后，你应该回过头去查看任何一本书或网站上的结构图。对你来说应该更有意义，至少我是这么希望的。</p><p id="9b4f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">从类图中，可以看到组类实现了<em class="mb">主题接口。所以在这个例子中，Group class是主语。</em>用户类实现了<em class="mb">观察者接口。所以用户类是观察者。和组有一个观察者对象列表。因此，用户可以使用register和removeobervser方法成为组类的观察者。</em>和组类可以用更新的方法通知观察者。</p><p id="f6a7" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在我们进入编码部分。下面给出了组类的代码。文末给出了代码链接。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oh oi l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">Group类实现Subject接口</figcaption></figure><p id="4b55" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在让我们分解它来理解观察者模式。<strong class="lh ja">观察者可以在列表中添加或删除，观察者列表会跟踪对象列表。</strong>下面是主题类组提供给观察者使用的两种方法。</p><pre class="kp kq kr ks gt ok ol om on aw oo bi"><span id="cb1e" class="op ng iq ol b gy oq or l os ot"><strong class="ol ja">public void registerObserver(Observer o) {<br/>  observers.add(o);<br/>}</strong></span><span id="4daa" class="op ng iq ol b gy ou or l os ot"><strong class="ol ja">public void removeObserver(Observer o) {<br/>  observers.remove(o);<br/>}</strong></span></pre><p id="9e95" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在，让我们检查我们主题的最后一个任务，即<strong class="lh ja">组</strong>类:通知观察者。当一个新帖子被发布时，<strong class="lh ja"> notifyObserver </strong>方法获取所有观察者的列表，并通过<strong class="lh ja"> update </strong>方法将帖子发送给观察者对象。</p><pre class="kp kq kr ks gt ok ol om on aw oo bi"><span id="e72d" class="op ng iq ol b gy oq or l os ot">public void newPost(String post) {<br/>  this.post = post;<br/>  notifyObserver();<br/>}</span><span id="4453" class="op ng iq ol b gy ou or l os ot">public void notifyObserver() {<br/>  for (Observer observer : observers) {<br/>    observer.update();    //update posts for observers<br/>  }<br/>}</span></pre><p id="4986" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在，我们可以知道在observer中需要有一个<strong class="lh ja">更新</strong>功能。我们将在下一节讨论这一点。</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="aee4" class="nf ng iq bd nh ni nj nk nl nm nn no np kf nq kg nr ki ns kj nt kl nu km nv nw bi translated">观察员/订户:</h1><p id="a4e1" class="pw-post-body-paragraph lf lg iq lh b li nx ka lk ll ny kd ln lo nz lq lr ls oa lu lv lw ob ly lz ma ij bi translated">Observer是这个设计模式中的一个actor类，有时它会引起混淆，因为设计模式名称和actor名称是相同的。因为这些对象订阅了主题，所以它们也被称为<strong class="lh ja">订阅者</strong>。观察者依赖于主体。当受试者的状态改变时，观察者会得到通知。在我们的例子中，如果有一个新的帖子，观察者会得到通知。</p><p id="c040" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">观察者订阅和取消订阅主题。通常，作为观察者的对象执行两项任务:</p><blockquote class="mi"><p id="4948" class="mj mk iq bd ml mm mn mo mp mq mr ma dk translated">I)使用主题提供的方法作为观察者订阅和取消订阅。</p><p id="0bd7" class="mj mk iq bd ml mm mn mo mp mq mr ma dk translated">ii)实现观察者接口以从主题获取更新。</p></blockquote><figure class="ow ox oy oz pa kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ov"><img src="../Images/5ac30d784e4de8a19a00b29772d52ff9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uF9dcnqz_1r-RVGhDDdJUw.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">图:观察者和主体之间的关系</figcaption></figure><p id="751f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">下面是观察者界面的代码，其中有<strong class="lh ja"> <em class="mb">更新</em> </strong>功能。所以想要获得组更新通知的对象必须实现这个Observer接口。我们将在用户类描述中看到其他类是如何使用这个类和方法的。观察者界面只有一个功能</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oh oi l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">观察者界面</figcaption></figure><p id="33c5" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">用户类实现了这个观察者<strong class="lh ja"> <em class="mb">接口</em> </strong>。所以user类的所有对象现在都将是<strong class="lh ja"> <em class="mb">观察者</em> </strong>。</p><p id="293f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">用户使用Subscribe函数中的<strong class="lh ja"> registerObserver </strong>方法注册为观察者。也可以从调用<strong class="lh ja"> removeObserver </strong>方法的组类的观察者列表中注销用户。集团可以通过<strong class="lh ja"> <em class="mb">更新</em> </strong> <em class="mb">功能更新新帖通知。</em></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oh oi l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">用户类通过实现观察者接口成为观察者</figcaption></figure><h1 id="5a04" class="nf ng iq bd nh ni pb nk nl nm pc no np kf pd kg nr ki pe kj nt kl pf km nv nw bi translated">客户端/主功能:</h1><p id="e2ef" class="pw-post-body-paragraph lf lg iq lh b li nx ka lk ll ny kd ln lo nz lq lr ls oa lu lv lw ob ly lz ma ij bi translated">通常设计模式例子中的客户端代码实际上是<strong class="lh ja">主函数</strong>中的代码。它的功能取决于编码器的实现。Main函数定义了观察者的数量和类型。</p><p id="9710" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在client中，我们创建了一个组，为一些用户输入内容，这些用户订阅了该组。当一个新的帖子进入群组时，所有订阅的用户都会收到通知。最后一个用户取消订阅该组。所以，下次用户没有收到新帖子时。</p><p id="7d08" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在设计模式教程中，Main函数被称为客户端</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oh oi l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">主要功能/客户代码</figcaption></figure><h1 id="1b3e" class="nf ng iq bd nh ni pb nk nl nm pc no np kf pd kg nr ki pe kj nt kl pf km nv nw bi translated">样本输出:</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pg"><img src="../Images/8177c09088d899361819292f90929512.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N2GI__5t-0tBE7XcPrgLVQ.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">图4:观察测试程序的输出</figcaption></figure><p id="644c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">谢谢你的耐心。希望这篇文章能让你对观察者设计模式有更好的了解。下面是<a class="ae le" href="https://github.com/ashis041/DesignPattern/tree/master/ObserverDesignPattern" rel="noopener ugc nofollow" target="_blank"> <strong class="lh ja">代码链接</strong></a><strong class="lh ja"/>它目前在java中。我会尝试更新其他语言的代码。</p><blockquote class="mc md me"><p id="285a" class="lf lg mb lh b li lj ka lk ll lm kd ln mf lp lq lr mg lt lu lv mh lx ly lz ma ij bi translated"><strong class="lh ja"> <em class="iq">如果你是设计模式的新手，请不要复制粘贴代码，</em> </strong> <a class="ae le" href="https://medium.com/dev-genius/design-pattern-for-newbies-fb11b676b061?source=your_stories_page---------------------------" rel="noopener"> <strong class="lh ja"> <em class="iq">试着自己写代码</em> </strong> </a> <strong class="lh ja"> <em class="iq">，这对你理解模式会有奇效。如果你需要任何帮助或者有任何提高我写作的建议，请告诉我。</em> </strong></p><p id="e1e4" class="lf lg mb lh b li lj ka lk ll lm kd ln mf lp lq lr mg lt lu lv mh lx ly lz ma ij bi translated">感谢你阅读这篇文章。祝你愉快。😃</p></blockquote><p id="d803" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">资源:sourcemaking、refactoringGuru和Head-First设计模式书。</p></div></div>    
</body>
</html>