<html>
<head>
<title>@JsonIgnore, @JsonProperty and @JsonAlias importance in Spring boot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">@JsonIgnore、@JsonProperty 和@JsonAlias 在春季开机中的重要性</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/three-jackson-annotations-which-all-spring-boot-developers-should-know-1b6304dda19?source=collection_archive---------0-----------------------#2022-01-17">https://blog.devgenius.io/three-jackson-annotations-which-all-spring-boot-developers-should-know-1b6304dda19?source=collection_archive---------0-----------------------#2022-01-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="04fd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文中，我将详细介绍三种广泛使用的 Jackson 注释，它们在 Spring boot 的各种用例中都很有用。</p><p id="662a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> First @JsonIgnore </strong></p><p id="e844" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">当 Java 类被序列化为 JSON 对象时，这个注释有助于我们忽略它的某些属性。</em></p><p id="cc2e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们先来了解一下，既然反正是要忽略的，为什么还需要这样的属性。可能有各种原因，比如</p><ol class=""><li id="aea1" class="kj kk in jm b jn jo jr js jv kl jz km kd kn kh ko kp kq kr bi translated">你想对客户隐藏数据，如密码，出生日期等。</li><li id="50cb" class="kj kk in jm b jn ks jr kt jv ku jz kv kd kw kh ko kp kq kr bi translated">客户不想要你未经处理的原始数据，如 JSON 字符串等。</li></ol><p id="d9fe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要做到这一点，你需要做什么？您只需在特定字段上方添加一个@JsonIgnore 注释。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="6b20" class="lg lh in lc b gy li lj l lk ll"><a class="ae lm" href="http://twitter.com/Builder" rel="noopener ugc nofollow" target="_blank">@Builder</a><br/><a class="ae lm" href="http://twitter.com/NoArgsConstructor" rel="noopener ugc nofollow" target="_blank">@NoArgsConstructor</a><br/><a class="ae lm" href="http://twitter.com/AllArgsConstructor" rel="noopener ugc nofollow" target="_blank">@AllArgsConstructor</a><br/><a class="ae lm" href="http://twitter.com/Data" rel="noopener ugc nofollow" target="_blank">@Data</a><br/>public class Student implements Serializable {<br/> private static final long serialVersionUID = 1L;</span><span id="d47c" class="lg lh in lc b gy ln lj l lk ll"> private Integer id;<br/> private String name;<br/> private String class;<br/> <br/> // Client don't want this unprocessed data<br/> <a class="ae lm" href="http://twitter.com/JsonIgnore" rel="noopener ugc nofollow" target="_blank">@JsonIgnore</a><br/> private String jsonResult; <br/> <br/> // They want processed data instead<br/> private Result result;<br/>}</span></pre><p id="3fce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，这里我们忽略了<code class="fe lo lp lq lc b">jsonResult</code>，当这个 Java 对象被序列化时，它不会出现在 JSON 对象中。它看起来会像这样。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="eba1" class="lg lh in lc b gy li lj l lk ll">{<br/> "id": 1,<br/> "name": "Ram",<br/> "class": 9,<br/> "result": {<br/>  "math": 90,<br/>  "science": 95,<br/>  "english": 80<br/> }<br/>}</span></pre><p id="3bfe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这不是使用该注释的唯一方式。假设您对 GET Response 和 POST 请求主体使用一个公共类。在这种情况下，您可能必须允许客户端设置该属性，但限制他们获取该属性。要做到这一点，只需将@JsonIgnore 添加到 Getter 方法中，并保留 Setter 方法。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="95d8" class="lg lh in lc b gy li lj l lk ll">public class User {<br/>    private String name;<br/>    private String password;</span><span id="b896" class="lg lh in lc b gy ln lj l lk ll">    // We are still hiding it from the client in the Get Request<br/>    <a class="ae lm" href="http://twitter.com/JsonIgnore" rel="noopener ugc nofollow" target="_blank">@JsonIgnore</a><br/>    public String getPassword() {<br/>        return password;<br/>    }</span><span id="64f1" class="lg lh in lc b gy ln lj l lk ll">    // But allowing them to set it in the POST request<br/>    public void setPassword(String password) {<br/>        this.password = password;<br/>    }<br/>}</span></pre><p id="0d92" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">秒@JsonProperty </strong></p><p id="343c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">这个注释帮助我们为一个字段定义一个逻辑属性，这个属性将被用于序列化和反序列化。</em></p><p id="9593" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们讨论@JsonProperty 的一些常见用例。</p><ol class=""><li id="6d8c" class="kj kk in jm b jn jo jr js jv kl jz km kd kn kh ko kp kq kr bi translated">如果您使用自动生成的 getters 和 setters，那么您可以将@JsonProperty 用于像<code class="fe lo lp lq lc b">isActive</code>这样的布尔字段，这样 JSON 对象和 Java 对象就有了一致的字段名<code class="fe lo lp lq lc b">isActive</code>。否则，默认情况下，Jackson 将从 getter 或 setter 中确定属性名，您可能会看到 JSON 和 Java 对象中的差异。</li><li id="ffc3" class="kj kk in jm b jn ks jr kt jv ku jz kv kd kw kh ko kp kq kr bi translated">假设我们从某个 API 获取数据，其中属性名在 snake_case 或 PascalCase 中，但我们遵循 camelCase，那么我们也可以使用@JsonProperty。</li></ol><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="b01d" class="lg lh in lc b gy li lj l lk ll">public class Student implements Serializable {<br/> private static final long serialVersionUID = 1L;</span><span id="ede0" class="lg lh in lc b gy ln lj l lk ll"> private Integer id;<br/> private String name;<br/> private String class;<br/> <br/> @JsonProperty("isActive")<br/> private boolean isActive;<br/> <br/> @JsonProperty("rollNumber")<br/> private boolean ROLL_NUMBER;<br/>}</span></pre><p id="5635" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，这里我们将字段<code class="fe lo lp lq lc b">isActive</code>的属性名定义为 isActive，这样即使是 JSON 对象也可以有相同的属性名，而不是像<code class="fe lo lp lq lc b">active</code>那样。</p><p id="e715" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">其次，对于<code class="fe lo lp lq lc b">ROLL_NUMBER</code>字段，我们将属性名定义为 rollNumber，这样 JSON 对象可以在 camelCase 中而不是 UPPER_CASE 中有一个属性名。</p><p id="00f7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第三个@JsonAlias </strong></p><p id="616b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">这个注释帮助我们在反序列化过程中为要映射到 Java 字段的 JSON 属性定义不同的别名。</em></p><p id="e1ea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们通过一个例子来理解这一点。</p><p id="8eeb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">假设我们正在聚合来自各种流媒体平台 API 的电影和电视剧数据，并将其存储在我们的应用程序类中。让我们假设，我们有一门电影课和一门电视剧课。</p><p id="5b3e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们从各种来源获取数据时，我们可以预期属性名的各种命名约定，但是我们希望将相似的数据映射到一个 Java 字段，对吗？这就是@JsonAlias 的用武之地。怎么会？</p><p id="11ea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看一遍电影课的例子。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="b668" class="lg lh in lc b gy li lj l lk ll">public class Movie {</span><span id="bf9b" class="lg lh in lc b gy ln lj l lk ll">    // This way our application will consider<br/>    // title, movieName and name all three during deserialization.<br/>    @JsonProperty("name")<br/>    @JsonAlias({"title", "movieName"})<br/>    private String name;<br/> <br/>    // Similarly here, it would consider all name  <br/>    // like genre, type and category<br/>    @JsonProperty("genre")<br/>    @JsonAlias({"type", "category"})<br/>    private String genre;<br/> <br/>    private String streamingPlatform;<br/>}</span></pre><p id="2614" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，这里我们有两个 Java 字段，其中 JSON 属性可以有不同的名称，这取决于数据来自哪个 API。因此，通过给定别名如<code class="fe lo lp lq lc b">title</code>和<code class="fe lo lp lq lc b">movieName</code>，我们告诉我们的应用程序，每当它在 JSON 对象中遇到这些属性名时，它应该设置我们的<code class="fe lo lp lq lc b">name</code>字段。通过使用@JsonProperty，我们可以为 Java 字段定义一个逻辑属性名，它将在序列化和反序列化中使用。</p></div><div class="ab cl lr ls hr lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ig ih ii ij ik"><p id="c321" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这些是杰克逊的一些注释，我已经见过很多次了，随身带着这些工具很方便。</p><p id="e2f0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是也有许多其他注释可以用在不同的场景中。如果您感兴趣，您可以在此详细浏览所有这些内容。</p><ol class=""><li id="cd5b" class="kj kk in jm b jn jo jr js jv kl jz km kd kn kh ko kp kq kr bi translated"><a class="ae lm" href="https://www.baeldung.com/jackson-annotations" rel="noopener ugc nofollow" target="_blank">https://www.baeldung.com/jackson-annotations</a></li><li id="e41e" class="kj kk in jm b jn ks jr kt jv ku jz kv kd kw kh ko kp kq kr bi translated"><a class="ae lm" href="https://github.com/FasterXML/jackson-annotations/wiki/Jackson-Annotations" rel="noopener ugc nofollow" target="_blank">https://github . com/faster XML/Jackson-Annotations/wiki/Jackson-Annotations</a></li><li id="c485" class="kj kk in jm b jn ks jr kt jv ku jz kv kd kw kh ko kp kq kr bi translated"><a class="ae lm" href="https://github.com/FasterXML/jackson-databind/wiki/Databind-Annotations" rel="noopener ugc nofollow" target="_blank">https://github . com/faster XML/Jackson-Databind/wiki/Databind-Annotations</a></li></ol></div></div>    
</body>
</html>