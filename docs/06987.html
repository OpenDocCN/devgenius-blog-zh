<html>
<head>
<title>Moving views around in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 SwiftUI 中移动视图</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/moving-views-around-in-swiftui-271b5bb4fdd8?source=collection_archive---------6-----------------------#2022-02-16">https://blog.devgenius.io/moving-views-around-in-swiftui-271b5bb4fdd8?source=collection_archive---------6-----------------------#2022-02-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/e6c460456c3b35b88aad903674334a47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HWv86a0a0zYLf-iYefy9xQ.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">我们来玩个游戏吧！</figcaption></figure><p id="3b70" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在 SwiftUI 的早期，我组装了一个纸牌游戏(为了好玩),大部分都做得很好，但我不知道如何将纸牌从牌堆中移到玩家手中。iOS 14 此时处于测试阶段，我发现了对其新的<em class="kx">matchegeometryeffect</em>修改器的引用，这似乎是答案。不幸的是，当时我还不能利用测试版的特性，所以这个项目陷入了停顿。</p><p id="fd47" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">快进到现在，我终于发现自己回到了在 SwiftUI 中移动扑克牌的概念，现在可以愉快地使用<em class="kx">matchegeometryeffect</em>！我挣扎了一会儿，想知道如何让它工作起来，我没有遇到任何博客处理我所面临的具体问题(他们都专注于为“英雄动画”移动<em class="kx">视图</em>，这有点不同)，所以我想我应该写下我的发现，希望它能帮助其他人！</p><p id="aa60" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">总结一下我所追求的行为:</p><ul class=""><li id="0b25" class="ky kz in kb b kc kd kg kh kk la ko lb ks lc kw ld le lf lg bi translated">卡片在移动时不会改变大小</li><li id="70ee" class="ky kz in kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">当纸牌需要在不同的手牌和/或主副牌之间移动时，它们应该以真实的方式平稳地移动</li></ul><p id="8b3a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">对于那些渴望获得完整代码解决方案的人，你可以在我的 GitHub <a class="ae lm" href="https://github.com/ChrisMash/SwiftUI-Playing-Cards" rel="noopener ugc nofollow" target="_blank">这里</a>查看完整的示例项目。对于那些想了解这一过程的人，请继续阅读！</p><h1 id="1aaf" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">第一步:模特</h1><p id="ed39" class="pw-post-body-paragraph jz ka in kb b kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw ig bi translated">首先，我们需要纸牌游戏中的对象的一些模型:</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="c215" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们有一张<em class="kx">牌</em>和一只<em class="kx">手</em>，其中包含一组<em class="kx">牌</em>。</p><p id="4e65" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="kx">卡片</em>是<em class="kx">可识别的，</em>是 SwiftUI 经常需要的(因此它知道如何处理不同于另一个视图的视图的引入或移除)，并且<em class="kx">等同于</em>以便于在数组中找到卡片。<em class="kx">牌</em>拥有的唯一其他数据是一个代表其价值的数字(在这个例子中没有花色或牌面)。</p><p id="52a6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">出于同样的原因，<em class="kx">手</em>也是<em class="kx">可识别的</em>，并且它是一个<em class="kx">可观察的对象</em>，因为我们的<em class="kx">视图</em> s 想要知道牌何时被添加到手上，或者何时被移除。<em class="kx"> cards </em>数组使用<em class="kx">@ Published</em>property<em class="kx"/>包装器，以便它自动向正在监视变化的<em class="kx">视图</em>报告变化。</p><h1 id="e88f" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">第二步:游戏状态</h1><p id="5e93" class="pw-post-body-paragraph jz ka in kb b kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw ig bi translated">接下来让我们创建一个对象来保存游戏的状态:</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="50b0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">它只是保存了一副牌(由<em class="kx">手</em>模型表示，因为它完成了我们当前需要它做的工作)和一组代表游戏中玩家的<em class="kx">手</em>模型。</p><p id="f71e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="kx"> init </em>用 20 张牌设置一副牌，洗牌，然后创建两个<em class="kx">手</em>和一个<em class="kx">牌</em>开始游戏。</p><h1 id="3df3" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">第三步:卡片视图</h1><p id="f288" class="pw-post-body-paragraph jz ka in kb b kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw ig bi translated">接下来让我们创建一个<em class="kx">视图</em>来表示一张<em class="kx">卡片</em>:</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="c2da" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">大多数情况下相当简单。我们已经有了一个带有两个代表卡片背景和边框的<em class="kx"> ZStack </em>和两个<em class="kx"> RoundedRectangle </em>，在此之上，我们用一个<em class="kx">文本</em>呈现卡片的值。</p><p id="9cd0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们有一个<em class="kx">名称空间</em>属性，类型为<em class="kx">名称空间。ID </em>，被传入<em class="kx">视图</em>。这是对<em class="kx"> matchedGeometryEffect </em>的一个要求，提供卡片存在的上下文。在这个例子中，我使用了<em class="kx">卡</em>的值作为<em class="kx">matchegeometryeffect</em>的 id，因为它足够唯一，可以在<em class="kx">卡</em>在<em class="kx">视图</em>之间移动时识别出它。</p><p id="b24e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">根据我找到的一些其他博客，我遇到的第一个问题是，虽然我可以让卡片动画到它们的新位置，但有一个渐变动画被应用。这张卡片似乎立刻从原来的位置消失了，然后在移动到新位置时又消失了:</p><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/60df690b1c624f08401401857d805bb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*Zxx3ST3O-5-Lc_IAmHPnvg.gif"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">除了卡片在移动过程中褪色之外，一切都很好</figcaption></figure><p id="e925" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这种行为在我看到的其他博客中没有显示，所以我不确定这是 iOS 14 和 15 之间的差异还是我的代码中有细微的不同。</p><p id="d38c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">经过更多的挖掘，我偶然发现了一个博客，它指出这是应用于视图动画的默认过渡样式(在任何场景中，不仅仅是使用<em class="kx">matchegeometryeffect</em>)。我研究了改变过渡到不影响不透明度的东西，最终我发现使用缩放过渡，设置为 1，是我所能找到的最好的选项，用于期望的“不要影响<em class="kx">视图</em>的外观，只是将它移动到新的位置”。</p><p id="91bb" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我想在这里指出的另一件事是，我阅读的关于英雄动画的其他博客说，你应该将<em class="kx">matchegeometryeffect</em>修改器放在任何<em class="kx">帧</em>修改器之前，以获得想要的效果。对于英雄动画，你需要考虑到帧的变化，这样才有意义。在我的例子中，框架保持不变，所以没有必要。事实上，在把我的例子放在一起的时候，它<strong class="kb io">有</strong>要放在帧之后，否则，动画就全乱了。实际上，我现在不能重现这个问题，但它可能是你遇到的问题，所以请记住视图修饰符的顺序通常很重要！这对所有 SwiftUI 工作来说都是公平的好建议！</p><h1 id="7ac2" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">步骤 4:预览和名称空间</h1><p id="7d72" class="pw-post-body-paragraph jz ka in kb b kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw ig bi translated">我发现我必须对这个<em class="kx">视图</em>的<em class="kx"> PreviewProvider </em>结构进行一点创新，因为名称空间被传入并且<em class="kx"> previews </em>属性是<em class="kx"> static </em>:</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="8244" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">基本上，我们定义了一个<em class="kx">视图</em>，它包含了<em class="kx"> CardView </em>，并且可以传入一个<em class="kx">名称空间。ID </em>这就是我们从<em class="kx">预览</em>中返回的内容。</p><h1 id="3a86" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">第五步:手的视角</h1><p id="1f80" class="pw-post-body-paragraph jz ka in kb b kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw ig bi translated">接下来让我们创建一个<em class="kx">视图</em>来表示一只<em class="kx">手</em>:</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="83fe" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这里我们将传入<em class="kx">手</em>，<em class="kx">名称空间。ID </em>和当卡片被点击时的关闭。手使用<em class="kx"> @ObservedObject </em>属性包装器，以便<em class="kx">视图</em>响应手发布的更改(即添加/删除卡片)并在必要时重新构建自己。</p><p id="0260" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们简单地有一个<em class="kx"> HStack </em>来呈现<em class="kx">手</em>中的每个<em class="kx">卡片</em>，如果它们中的任何一个被点击，它就调用传递到<em class="kx">视图</em>中的闭包。</p><h1 id="f0a6" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">第六步:甲板景观</h1><p id="6d60" class="pw-post-body-paragraph jz ka in kb b kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw ig bi translated">接下来让我们创建一个<em class="kx">视图</em>来表示主副牌:</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="9f74" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">与<em class="kx"> HandView </em>非常相似，但是我们只渲染了<em class="kx"> ZStack </em>中的最后两张卡片，所以它们在彼此之上，就像一副叠起来的卡片。</p><h1 id="ebed" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">第七步:把所有东西放在一起</h1><p id="97f0" class="pw-post-body-paragraph jz ka in kb b kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw ig bi translated">最后，让我们一起把它放入主<em class="kx">内容视图</em>:</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="dfd8" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="kx"> ContentView </em>创建<em class="kx"> GameState </em>并持有它(根据您的层次结构，您可能希望将它传递到视图中)。它还为传递给每个<em class="kx"> CardView </em>的<em class="kx">matchegeometryeffect</em>提供顶级<em class="kx"> @Namespace </em>上下文。</p><p id="11eb" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这个<em class="kx">视图</em>非常简单。顶部有一些简短的说明，解释你如何与卡片互动，随后是<em class="kx">桌面视图</em>和<em class="kx">手视图</em>根据<em class="kx">游戏状态</em>中的<em class="kx">手</em>。每个<em class="kx">手视图</em>还有一个“+”<em class="kx">按钮</em>，它允许你将<em class="kx">卡片视图</em>从<em class="kx">桌面视图</em>拖到那个<em class="kx">手视图</em>中，每当你点击<em class="kx">手视图</em>中的<em class="kx">卡片视图</em>时，它就将它移回<em class="kx">桌面视图</em></p><p id="255c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">通过在相关的<em class="kx">手</em>模型之间移动<em class="kx">卡片</em>模型，在带有动画关闭的<em class="kx">内移动卡片，就可以简单地在卡片组和手之间移动卡片，这样 UI 就知道我们想要它动画。<em class="kx"> CardView </em>中的<em class="kx"> matchedGeometryEffect </em>和<em class="kx"> transition </em>修改器向 SwiftUI 提供关于它应该如何执行这些动画的信息。</em></p><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/1df6de395c41ec2e734ff39c96153cb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*xWX5TE1l3Tq9LXRGoVm7VQ.gif"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">最后的结果！</figcaption></figure><p id="53a0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">就是这样！如前所述，在我的 GitHub <a class="ae lm" href="https://github.com/ChrisMash/SwiftUI-Playing-Cards" rel="noopener ugc nofollow" target="_blank">这里有一个完整的示例项目。</a></p><p id="888d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">欢迎留下任何反馈意见或问题！</p><h1 id="21c6" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">您仍可能面临的问题</h1><h2 id="5c24" class="mx lo in bd lp my mz dn lt na nb dp lx kk nc nd mb ko ne nf mf ks ng nh mj ni bi translated">不同的 iOS 版本</h2><p id="b11b" class="pw-post-body-paragraph jz ka in kb b kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw ig bi translated"><em class="kx">iOS 14 提供了 matchegeometryeffect</em>，不过我只在 iOS 15 上测试了我的例子，所以如果你想在 iOS 14 上使用它，可能会有一些不同。该示例针对 iOS 14 进行了编译，但 SwiftUI 仍处于初级阶段，因此不同的操作系统版本可能会有问题！</p><h2 id="1896" class="mx lo in bd lp my mz dn lt na nb dp lx kk nc nd mb ko ne nf mf ks ng nh mj ni bi translated">重复视图错误</h2><p id="53a2" class="pw-post-body-paragraph jz ka in kb b kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw ig bi translated">我在观察不同的<em class="kx">手</em>之间的纸牌移动时遇到了一些麻烦。有时动画不会发生，控制台会记录一个错误，提示不同的<em class="kx">视图</em>同时出现重复的 id。因此，这可能是你最终会遇到的事情，并且很难找出如何避免它。</p><p id="b59b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在我引入<em class="kx"> DeckView </em>之前，我的设置没有成功，只是将它的<em class="kx"> ZStack </em>直接包含在<em class="kx"> ContentView </em>中。因为无法观察到<em class="kx">游戏状态</em>的牌组的<em class="kx">手</em>，这意味着当卡片移入/移出牌组时，SwiftUI 会重建一些<em class="kx">视图</em>，但并不认为牌组本身需要重建。所以只要试着确保任何可以改变的东西都被观察到，这样 SwiftUI 就知道它需要重建了！</p><h2 id="97a0" class="mx lo in bd lp my mz dn lt na nb dp lx kk nc nd mb ko ne nf mf ks ng nh mj ni bi translated">滚动查看问题</h2><p id="ea70" class="pw-post-body-paragraph jz ka in kb b kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw ig bi translated">将卡片放在<em class="kx">滚动视图</em>中对玩家的手来说可能是可取的，否则它很容易离开屏幕，特别是在纵向 iPhone 上。不幸的是，这种转变并不顺利。当卡片从卡片组移动到手中时，它呈现在<em class="kx"> ScrollView </em>的裁剪过的画布上，而不是在顶部，所以你会看到它不知从哪里滑了进来。希望这是在未来的 iOS 版本中可以解决的问题！</p><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/97de390af67be3a2449d5f0771912f6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*RBW-w9UiU9-y_zE8aCo2jw.gif"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">ScrollView 错误！</figcaption></figure></div></div>    
</body>
</html>