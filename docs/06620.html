<html>
<head>
<title>All You Need To Know About JVM Cache Management and Garbage Collection (With Commands) Pt. 1/2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于 JVM 缓存管理和垃圾收集(使用命令)Pt，您需要知道的全部内容。1/2</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/all-you-need-to-know-about-jvm-cache-management-and-garbage-collection-with-commands-pt-1-2-6bb8d18cd4e2?source=collection_archive---------7-----------------------#2022-01-20">https://blog.devgenius.io/all-you-need-to-know-about-jvm-cache-management-and-garbage-collection-with-commands-pt-1-2-6bb8d18cd4e2?source=collection_archive---------7-----------------------#2022-01-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/607a3056844ea8b03ff090ef6462b59f.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*k0_t6KAH6rBkag7QN79aNQ.jpeg"/></div></div></figure><h1 id="4566" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">JVM 结构</h1><p id="91ab" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">我以前写过一篇关于 JVM 的简要概述:</p><div class="lr ls gp gr lt lu"><a href="https://medium.com/@wdn0612/java-backend-developer-interview-questions-pt-1-10-1c74c76442bd" rel="noopener follow" target="_blank"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd io gy z fp lz fr fs ma fu fw im bi translated">Java 后端开发人员面试问题(Pt。1–10)</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">1.JVM 的作用是什么？JVM 是 Java 虚拟机的简称。它为 Java 代码提供了一个运行时环境…</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">medium.com</p></div></div><div class="md l"><div class="me l mf mg mh md mi jt lu"/></div></div></a></div><p id="9974" class="pw-post-body-paragraph kt ku in kv b kw mj ky kz la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq ig bi translated">在这里，我们将更深入地研究 JVM 运行时数据区。在这一部分，我们将主要介绍<strong class="kv io">缓存管理</strong>和<strong class="kv io">垃圾收集</strong>。第 1 部分将关注 JVM 缓存管理，第 2 部分(即将推出)将讨论 JVM 垃圾收集。这两个概念在 JVM 性能优化中都很重要。正确的理解和适当的配置将使您的 Java 应用程序适应更大的数据流量并允许更快的执行。</p><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/71a7e83cac47a356eebd4349be3c6fb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*FHS1NuAQlR5uW-dFhbmILA.jpeg"/></div></figure><h2 id="fa37" class="mt jw in bd jx mu mv dn kb mw mx dp kf le my mz kj li na nb kn lm nc nd kr ne bi translated">方法区域</h2><p id="9bce" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">方法区域存储与类相关的信息，例如类名、类中的静态变量、最终变量、类中的字段、方法信息等。例如，当我们使用 getters、setters 或其他与业务逻辑相关的方法时，它们驻留在方法区域中。方法区域在线程之间共享。在 Hotspot VM 中，方法区域对应于永久生成。</p><p id="8fb6" class="pw-post-body-paragraph kt ku in kv b kw mj ky kz la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq ig bi translated"><strong class="kv io"> JVM 方法区域配置</strong></p><ul class=""><li id="f62b" class="nf ng in kv b kw mj la mk le nh li ni lm nj lq nk nl nm nn bi translated"><strong class="kv io"> Maxsize </strong></li></ul><pre class="mp mq mr ms gt no np nq nr aw ns bi"><span id="5268" class="mt jw in np b gy nt nu l nv nw">-XX:MaxPermSize &lt;value&gt;</span></pre><ul class=""><li id="f2f6" class="nf ng in kv b kw mj la mk le nh li ni lm nj lq nk nl nm nn bi translated"><strong class="kv io">最小尺寸</strong></li></ul><pre class="mp mq mr ms gt no np nq nr aw ns bi"><span id="afea" class="mt jw in np b gy nt nu l nv nw">-XX:PermSize &lt;value&gt;</span></pre><h2 id="31f2" class="mt jw in bd jx mu mv dn kb mw mx dp kf le my mz kj li na nb kn lm nc nd kr ne bi translated">堆区域</h2><p id="34b8" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">堆区域由线程共享。它是在 JVM 启动时构造的。使用“new”创建的所有实例都分配在堆区域中。</p><p id="e814" class="pw-post-body-paragraph kt ku in kv b kw mj ky kz la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq ig bi translated"><strong class="kv io">堆大小配置</strong></p><pre class="mp mq mr ms gt no np nq nr aw ns bi"><span id="2f50" class="mt jw in np b gy nt nu l nv nw">-Xms &lt;value&gt;<br/>-Xmx &lt;value&gt;</span></pre><p id="bf47" class="pw-post-body-paragraph kt ku in kv b kw mj ky kz la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq ig bi translated">-Xms 是 JVM <strong class="kv io"> s </strong>启动时获取的堆大小。它默认为物理内存的 1/64，但小于 1GB。-Xmx 是允许的最大堆大小。它默认为物理内存的 1/4，但小于 1GB。默认情况下，当剩余堆空间小于 40%时，JVM 会将堆大小增加到-Xmx 值。我们可以用<strong class="kv io">-XX:minheafpreeratio</strong>来控制这个比例。如果剩余的堆大小大于 70%，JVM 会将堆空间减少到-Xms 值。我们可以用<strong class="kv io"> -XX:MaxHeapFreeRatio </strong>来控制这个。</p><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/0a37e818a6bca45ecce05880013efe42.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*iMRYC0ho-XfSczadR7wNJQ.png"/></div></figure><ul class=""><li id="ade9" class="nf ng in kv b kw mj la mk le nh li ni lm nj lq nk nl nm nn bi translated"><strong class="kv io">年轻一代</strong></li></ul><p id="7ff8" class="pw-post-body-paragraph kt ku in kv b kw mj ky kz la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq ig bi translated">创建实例时，会在年轻一代中分配(但大实例可以在老一代中分配)。当年轻一代需要回收时，触发次要垃圾回收(Young GC)。</p><p id="0350" class="pw-post-body-paragraph kt ku in kv b kw mj ky kz la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq ig bi translated">年轻一代包括伊甸园空间和两个同等大小的幸存者空间(S0 和 S1)。</p><p id="6cdc" class="pw-post-body-paragraph kt ku in kv b kw mj ky kz la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq ig bi translated"><strong class="kv io">年轻一代规模配置</strong></p><pre class="mp mq mr ms gt no np nq nr aw ns bi"><span id="f691" class="mt jw in np b gy nt nu l nv nw">-Xmn &lt;value&gt;</span></pre><p id="c758" class="pw-post-body-paragraph kt ku in kv b kw mj ky kz la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq ig bi translated"><strong class="kv io">幸存者空间/伊甸园空间配置</strong></p><pre class="mp mq mr ms gt no np nq nr aw ns bi"><span id="48c9" class="mt jw in np b gy nt nu l nv nw">-XX:SurvivorRatio=&lt;value&gt;</span></pre><ul class=""><li id="8326" class="nf ng in kv b kw mj la mk le nh li ni lm nj lq nk nl nm nn bi translated"><strong class="kv io">老一代</strong></li></ul><p id="8553" class="pw-post-body-paragraph kt ku in kv b kw mj ky kz la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq ig bi translated">当实例在年轻的一代中存活了一定的时间而没有被清除时，它们将被提升到老的一代。这意味着老一代存储的实例在较小的 GC 之后仍然存在。如果超过某个阈值，新实例将被分配到旧代中。在旧的一代满了之后，它触发垃圾收集，这就是所谓的主要垃圾收集。</p><p id="7cdd" class="pw-post-body-paragraph kt ku in kv b kw mj ky kz la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq ig bi translated"><strong class="kv io">老一代实例阈值配置</strong></p><pre class="mp mq mr ms gt no np nq nr aw ns bi"><span id="9954" class="mt jw in np b gy nt nu l nv nw">-XX:PretenureSizeThreshold=&lt;value&gt;</span></pre><h2 id="0fc1" class="mt jw in bd jx mu mv dn kb mw mx dp kf le my mz kj li na nb kn lm nc nd kr ne bi translated">JVM 堆栈</h2><p id="7aac" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">应用程序中的每个线程将占用 JVM 堆栈中的一个堆栈。当每个方法被执行时，一个堆栈帧将被执行。堆栈帧由局部变量、操作数堆栈、帧数据、出口地址等部分组成。当调用一个方法时，堆栈帧进入线程堆栈。完成后，堆栈帧退出堆栈。</p><h2 id="7885" class="mt jw in bd jx mu mv dn kb mw mx dp kf le my mz kj li na nb kn lm nc nd kr ne bi translated">本机方法区域</h2><p id="fce6" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">本地方法是那些用 java 以外的语言编写的方法。本地库通过 JNI (Java 本地接口)或 JNA(Java 本地访问)链接到 Java 程序。本机方法也与每个线程相关联。</p><h2 id="1805" class="mt jw in bd jx mu mv dn kb mw mx dp kf le my mz kj li na nb kn lm nc nd kr ne bi translated"><strong class="ak"> PC 寄存器</strong></h2><p id="7f1b" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">PC 寄存器主要存储当前执行线程的行号。因为它记录了每个线程的行号，所以 PC 寄存器是线程私有的。由于 PC 寄存器只记录当前指令的地址，所以它是 JVM 中唯一没有定义 OutOfMemoryError 的区域。</p><h2 id="984d" class="mt jw in bd jx mu mv dn kb mw mx dp kf le my mz kj li na nb kn lm nc nd kr ne bi translated">举个例子…</h2><p id="ce53" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">假设我们有以下代码:</p><pre class="mp mq mr ms gt no np nq nr aw ns bi"><span id="b8e6" class="mt jw in np b gy nt nu l nv nw">String myName = new String("DN Tech")</span></pre><ol class=""><li id="45c5" class="nf ng in kv b kw mj la mk le nh li ni lm nj lq ny nl nm nn bi translated"><em class="nz">我的名字</em>是当前线程中的引用。它将存储在 JVM 堆栈的局部变量中。</li><li id="935f" class="nf ng in kv b kw oa la ob le oc li od lm oe lq ny nl nm nn bi translated"><em class="nz"> new String("DN Tech") </em>是实际的对象实例，它将被存储在堆区域中。</li><li id="e33b" class="nf ng in kv b kw oa la ob le oc li od lm oe lq ny nl nm nn bi translated">堆区还记录了与该对象相关的地址，如<em class="nz"> equals() </em>和<em class="nz"> indexof() </em>，但实际的方法实现和数据都存储在方法区。</li></ol><h1 id="1481" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">JVM 缓存分配</h1><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div class="gh gi of"><img src="../Images/f5ae30b2ca855585bd4c1bb17121c75b.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*cLE4NWnsORQ6W3Agrw87WQ.png"/></div></figure><p id="0432" class="pw-post-body-paragraph kt ku in kv b kw mj ky kz la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq ig bi translated">Java 实例大多在堆区。由于堆区域是在线程之间共享的，所以堆分配需要引入锁来确保线程安全，这导致实例创建的成本更高。为了提高分配效率，HostSpot 虚拟机年轻一代中的 Eden 空间使用了两种技术来实现这一点——指针碰撞和 TLAB(线程本地分配缓冲区)。Bump-the-pointer 旨在跟踪创建的最后一个实例，因此当创建一个新实例时，我们只需要检查最后一个实例之后是否有足够的空间。TLAB 属于多线程。它将在 Eden Space 中为每个新线程创建一个新空间。TLAB 的大小可以使用<strong class="kv io">-XX:TLABWasteTargetPercent</strong>(默认为 1%)进行配置。通常，JVM 会优先分配 TLAB。如果实例太大或者没有空间留给 TLAB，JVM 将继续在堆区域中分配。</p></div><div class="ab cl og oh hr oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="ig ih ii ij ik"><p id="0217" class="pw-post-body-paragraph kt ku in kv b kw mj ky kz la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq ig bi translated">我希望这篇文章对你有所帮助。如果你像我一样渴望学习一些与技术相关的东西或定期反思工作和生活，请关注我的频道，了解我日常工作和生活中的最新灵感。</p><p id="732a" class="pw-post-body-paragraph kt ku in kv b kw mj ky kz la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq ig bi translated"><strong class="kv io">接下来</strong>:关于 JVM 缓存管理和垃圾收集(用命令)Pt 你需要知道的一切。2/2(即将推出)</p></div><div class="ab cl og oh hr oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="ig ih ii ij ik"><p id="85bd" class="pw-post-body-paragraph kt ku in kv b kw mj ky kz la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq ig bi translated">演职员表:<br/><a class="ae on" href="https://stackoverflow.com/questions/18824798/what-is-difference-between-java-method-and-native-method" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/18824798/what-is-difference-before-Java-method-and-native-method</a><br/><a class="ae on" href="https://www.hackerearth.com/practice/notes/runtime-data-areas-of-java/#:~:text=5.Native%20Method%20Stack,is%20used%20for%20native%20methods" rel="noopener ugc nofollow" target="_blank">https://www . hackere earth . com/practice/notes/runtime-data-areas-of-Java</a><br/><a class="ae on" href="https://blog.csdn.net/suifeng3051/article/details/48292193" rel="noopener ugc nofollow" target="_blank">https://blog.csdn.net/suifeng3051/article/details/48292193</a></p></div></div>    
</body>
</html>