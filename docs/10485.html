<html>
<head>
<title>Nodejs and libuv’s thread pool</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Nodejs 和 libuv 的线程池</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/nodejs-and-libuvs-thread-pool-69b2cc225738?source=collection_archive---------3-----------------------#2022-11-05">https://blog.devgenius.io/nodejs-and-libuvs-thread-pool-69b2cc225738?source=collection_archive---------3-----------------------#2022-11-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/e9dc8b46b28bca169552a8b905baae2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0aK2S13TX1oZFaaNVnnJ8g.png"/></div></div></figure><p id="c580" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上一篇<a class="ae kt" rel="noopener ugc nofollow" target="_blank" href="/node-is-not-single-threaded-d73fa6a1450a">帖子</a>中，我们谈到了<strong class="jx io"> libuv </strong>如何提供一个<strong class="jx io">线程池</strong>来卸载在非常昂贵的函数调用上完成的工作。在这篇文章中，我们将检测这四个为我们自动创建的线程的存在。</p><p id="60e8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们再复制粘贴三次<strong class="jx io"> PBKDF2 </strong>散列函数并运行它。</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ku"><img src="../Images/73cce671ff44e208c3a135be750540e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0D565zDM_3t-k_deOHJUVA.png"/></div></div></figure><p id="3078" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们得到第一个<strong class="jx io">四个</strong>结果，稍作停顿，然后第五个结果突然出现<strong class="jx io">。</strong></p><p id="79d3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以使用这些结果来推测一些关于<strong class="jx io">线程池</strong>及其工作原理的信息。</p><p id="92b8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一个小提示。根据您机器的<strong class="jx io"> CPU </strong>，您可能会在这里看到一些不同的结果，这完全是<strong class="jx io"> OK </strong>。让我给你解释一下我的电脑是怎么回事，然后你也可以推断出你自己的电脑是怎么回事。</p><p id="e4b4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，注意第一个<strong class="jx io">四个</strong>电话都花了完全相同的时间，它们花的时间与之前(之前<a class="ae kt" rel="noopener ugc nofollow" target="_blank" href="/node-is-not-single-threaded-d73fa6a1450a">帖子</a>上)的时间大致相等。</p><p id="b756" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我希望您注意的第二件事是，第五次<strong class="jx io">呼叫花费了额外的 0.6 秒。</strong></p><p id="3b86" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我要给你看一张我的电脑图。通过理解我的计算机内部的硬件，我们将对为什么我们在所有这些函数调用中看到不同的计时有更好的理解。</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi kz"><img src="../Images/fda09d8f8c2ee2215896bb4dd9c92a6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sF5aR6E7WZeeB8TTf9f7pQ.png"/></div></div></figure><p id="f3ef" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我的电脑有一个四核处理器。另外，记住默认情况下<strong class="jx io"> libuv </strong>会创建<strong class="jx io">四个线程。</strong></p><p id="50ef" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对<strong class="jx io"> PBKDF2 </strong>的第一个<strong class="jx io">四个</strong>调用各自被分配到<strong class="jx io">线程池中各自的<strong class="jx io">线程</strong>。</strong>然后这些<strong class="jx io">线程</strong>中的每一个都在 CPU 的<strong class="jx io">一个</strong>内核中执行。</p><p id="477a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一旦这些都完成了，前四个任务也完成了，node 就可以继续进行第五个<strong class="jx io">函数调用了。因此，可能该内核被分配给<strong class="jx io">四号线程</strong>，然后四号线程被分配给<strong class="jx io">二号内核</strong>。这就是第五</strong>功能<strong class="jx io">延迟执行的原因。</strong></p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi la"><img src="../Images/a88fd0a90c43c9e3879c151893b14f80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HN8gSO_rc75qb-sIbVxTFg.png"/></div></div></figure><p id="b80d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们现在要继续前进一点，弄清楚我们如何使用和定制<strong class="jx io">线程池</strong>。</p><p id="15fe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将添加一点代码来处理一些线程，这些线程是在我们启动程序时创建的。</p><p id="aa3e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">运行 threads.js 文件时，我将更新一个环境变量。所以我会像这样运行它。</p><pre class="kv kw kx ky gt lb lc ld le aw lf bi"><span id="1fa5" class="lg lh in lc b gy li lj l lk ll">UV_THREADPOOL_SIZE=5 node threads.js</span></pre><p id="6f21" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">链接:<a class="ae kt" href="https://nodejs.org/api/cli.html#uv_threadpool_sizesize" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/api/cli.html#uv_threadpool_sizesize</a></p><p id="f042" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将告诉<strong class="jx io"> libuv </strong>每当它创建线程池时，它应该在那里创建<strong class="jx io">五个</strong>线程。</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lm"><img src="../Images/1b2b67d4c6ed2da5c29f8ff4b7bbdb8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VatCmZ0YLi9SLB75A5hq0Q.png"/></div></div></figure><p id="0e8c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这次看起来花了一段时间，但当它最终解决时，总共花了大约 0.75 秒，所有事情几乎在同一时间完成。</p><p id="06b0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们现在的情况是这样的。</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ln"><img src="../Images/064c8480f8fbb8bd25bea3bcdeae5fd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f1etru1FP0vRbfp3GIhK-Q.png"/></div></div></figure><p id="45af" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们有与散列函数调用数量相等的线程数量。因此，每个散列函数调用都会立即分配到自己的线程。</p><p id="4223" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的 CPU 可以使用它内部的所有内核在多个线程之间处理工作。操作系统调度程序决定了如何平衡所有可用内核背后的工作。所以在一天结束时，所有五个线程获得大致相等的 CPU 时间。这就是为什么我们同时看到了所有的东西。</p><p id="8237" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一个内核处理一个哈希需要 0.6 秒。因此，当我们同时有五个哈希时，用四个内核计算大约需要 0.75 秒。</p><p id="7d86" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是这篇文章的内容。在下一篇文章中，我们将看到集群和工作线程，所以请务必关注。</p></div></div>    
</body>
</html>