<html>
<head>
<title>Golang Data Structures: Binary Search Tree #3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">戈朗数据结构:二叉查找树#3</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/golang-data-structures-binary-search-tree-3-5a342d9df2cf?source=collection_archive---------5-----------------------#2022-11-22">https://blog.devgenius.io/golang-data-structures-binary-search-tree-3-5a342d9df2cf?source=collection_archive---------5-----------------------#2022-11-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="07f7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我将谈论下一个数据结构，这是一个二叉查找树。让我们开始吧。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/161476d7c88c281525832cac47458a5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BzPEWloY7YsxFFU58QDlfA.png"/></div></div></figure><h1 id="0eef" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">二叉查找树</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/561ee07ada559a5ef5d24ea8045f58b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:564/0*DWT4W88mt8_unYHa"/></div></figure><p id="88d8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">二叉查找树由通常有父节点和子节点的节点集合组成。子元素被排序，右边的子元素总是比父元素大，左边的子元素总是比父元素小。因为树是排序的，所以当我们进行搜索时，它表现得非常好，特别是如果它是平衡的。通常，二叉查找树是由一个链表构成的。以下是二叉查找树的利与弊。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/3425a96060de1716b4d745df0a8e73eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*j4URrhGmfIgpbNHKhvaYlw.png"/></div></figure><p id="8c82" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">二叉查找树有三个操作:</p><ul class=""><li id="e473" class="lu lv in jm b jn jo jr js jv lw jz lx kd ly kh lz ma mb mc bi translated">检查</li><li id="454d" class="lu lv in jm b jn md jr me jv mf jz mg kd mh kh lz ma mb mc bi translated">插入</li><li id="b53e" class="lu lv in jm b jn md jr me jv mf jz mg kd mh kh lz ma mb mc bi translated">删除</li></ul><p id="82d7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以下是数组和二叉查找树之间的区别。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mi"><img src="../Images/aff6f85e16f955fcda0e7b7323e39464.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IaTUoaN3Kl3lIHGiDD8JBA.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/cfeba0a0080e8ef72be3d82fee9f29f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rAwmysZ4h6QVhmoT"/></div></div></figure><p id="e875" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如我们从大 O 备忘单中看到的，二叉查找树执行得非常好，因为所有的操作都是 O(log n)。但是我们必须确保我们的树是平衡的，如果我们的树是不平衡的，那么我们将有 O(n)时间复杂度。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/b8f9717d695f7a3250b502f5b8bf1c8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/0*t3yHN3U7zY3_yE5p"/></div></div></figure><p id="737d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如上图，我们的二叉查找树是不平衡的，所以操作就像一个普通的链表。</p><h1 id="3fee" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">操作</h1><p id="f5a7" class="pw-post-body-paragraph jk jl in jm b jn ml jp jq jr mm jt ju jv mn jx jy jz mo kb kc kd mp kf kg kh ig bi translated">在创建我们的树之前，我们必须准备两个结构体。第一个是表示元素的节点。每个节点有两个子节点，左边和右边。另外，创建一个新的 BinaryTree 结构来存储我们的根节点。接下来，我们将把操作作为方法附加到 BinaryTree 结构上。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mq"><img src="../Images/47f0143c7a4df7f259af3751ca3ed9e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_7Svv21Wj6aFXMXR"/></div></div></figure><h2 id="3721" class="mr kv in bd kw ms mt dn la mu mv dp le jv mw mx li jz my mz lm kd na nb lq nc bi translated">插入</h2><p id="4759" class="pw-post-body-paragraph jk jl in jm b jn ml jp jq jr mm jt ju jv mn jx jy jz mo kb kc kd mp kf kg kh ig bi translated">插入是一种操作，我们在树中插入一个新的节点。对于插入，我们必须检查我们想要插入的数字。如果它小于当前节点，那么我们去左边的子节点，如果它大于当前节点，那么我们去右边的子节点。重复该步骤，直到我们遇到一个空值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/8051b28bc6a42874a107638df05ec808.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/0*hrSZBcT0yy7L988F.gif"/></div></figure><p id="885e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是上述逻辑的代码实现。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mq"><img src="../Images/b555459a99660e0ef1c7ac7d7c14d8eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*25IYWs_5Ntg0rBFa"/></div></div></figure><h2 id="e5e1" class="mr kv in bd kw ms mt dn la mu mv dp le jv mw mx li jz my mz lm kd na nb lq nc bi translated">检查</h2><p id="9829" class="pw-post-body-paragraph jk jl in jm b jn ml jp jq jr mm jt ju jv mn jx jy jz mo kb kc kd mp kf kg kh ig bi translated">Lookup 是在我们的树中搜索特定值的操作。要找到具体的值，逻辑类似于插入操作。我们必须检查我们想要搜索的值，如果值小于当前节点，则转到左边的子节点，否则转到右边的子节点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/a904228d411bfbb584156248d2305a3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7bJOqzM2RLb2D7VK"/></div></div></figure><p id="7c15" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是上述逻辑的代码实现。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mq"><img src="../Images/3f9d0e9dcd6661f2da28d6aae12b8c5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*83m7uKgmmV5immIW"/></div></div></figure><h2 id="a713" class="mr kv in bd kw ms mt dn la mu mv dp le jv mw mx li jz my mz lm kd na nb lq nc bi translated">删除</h2><p id="1a95" class="pw-post-body-paragraph jk jl in jm b jn ml jp jq jr mm jt ju jv mn jx jy jz mo kb kc kd mp kf kg kh ig bi translated">删除是一种操作，我们在树中删除一个节点。这是一个有点棘手的操作，我建议你看这个动画来理解其中的逻辑。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/cf01a5f6a592233b29a483bcba34af45.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/0*Iad_MfLIMzeadwq6.gif"/></div></figure><p id="a130" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从上面的动画中，我们可以看到，当我们想要删除 62 个节点时，我们必须先遍历到右边，然后遍历左边的子节点，直到找到一个空值。之后，我们交换价值。为了清楚地理解它，我推荐你试试这个<a class="ae ng" href="https://visualgo.net/en/bst" rel="noopener ugc nofollow" target="_blank">二叉查找树可视化</a>。下面是上述逻辑的代码实现</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mq"><img src="../Images/c4a6e42257fb716f51348bdbfdda02fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ufTpAUClkh3ENCVQ"/></div></div></figure><h1 id="94cd" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结论</h1><p id="e8bf" class="pw-post-body-paragraph jk jl in jm b jn ml jp jq jr mm jt ju jv mn jx jy jz mo kb kc kd mp kf kg kh ig bi translated">在本文中，我们介绍了二叉查找树数据结构，这是最重要的数据结构之一。当我们有可以用小于/大于方式比较的元素时，二叉查找树是有用的。</p></div><div class="ab cl nh ni hr nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ig ih ii ij ik"><p id="28cc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本文到此为止，别忘了留下一个赞，分享给别人。如果你有任何建议或推荐，我会很高兴你在下面留下评论。感谢你阅读这篇文章，祝你有美好的一天👋。</p></div></div>    
</body>
</html>