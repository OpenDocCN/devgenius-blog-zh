<html>
<head>
<title>Handling asynchronous errors in PHP with Laravel Queues, Symfony Messenger and Ecotone</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Laravel 队列、Symfony Messenger 和 econtero 处理 PHP 中的异步错误</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/handling-asynchronous-errors-in-php-with-laravel-queues-symfony-messenger-and-ecotone-9becba7fba46?source=collection_archive---------3-----------------------#2022-09-25">https://blog.devgenius.io/handling-asynchronous-errors-in-php-with-laravel-queues-symfony-messenger-and-ecotone-9becba7fba46?source=collection_archive---------3-----------------------#2022-09-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/3ff55275a944e990be64169f823c1566.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IytAChXcGPwQxm0ebGUpXA.jpeg"/></div></div></figure><p id="de6f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可能已经在 RabbitMQ、SQS、Beanstalkd 等消息平台上使用了<a class="ae kt" href="http://essing-in-php-symfony-messenger-laravel-queues-and-ecotone-8ca17102c5b2" rel="noopener ugc nofollow" target="_blank">异步处理</a>。<br/>或者你可能使用其中一个框架(<a class="ae kt" href="https://docs.ecotone.tech/" rel="noopener ugc nofollow" target="_blank">生态区</a>、<a class="ae kt" href="https://symfony.com/doc/current/messenger.html" rel="noopener ugc nofollow" target="_blank"> Symfony Messenger </a>或<a class="ae kt" href="https://laravel.com/docs/9.x/queues" rel="noopener ugc nofollow" target="_blank"> Laravel Queues </a>)来隐藏消息平台的详细信息。<br/>不管你用什么，处理消息时迟早会面临错误。那么，当你的代码异步运行时，你如何处理失败呢？</p><p id="b42e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">优雅地处理错误实际上可能会改变您的编码方式，使您的应用程序更易维护、更健壮。</p><h1 id="fd82" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">尽可能自动恢复</h1><p id="3309" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">所有的框架都带有在失败时重新传递消息的功能。<br/>这是你避免在晚上被叫或有支援轮班的第一道防线。</p><p id="78d6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">存在可以自动恢复的错误，如连接失败、第三方服务不可用或乐观锁定异常。</p><blockquote class="lx ly lz"><p id="089f" class="jv jw ma jx b jy jz ka kb kc kd ke kf mb kh ki kj mc kl km kn md kp kq kr ks ig bi translated">我们的主要目标应该是尽可能地自我修复。消息有时会失败，这是不可避免的，可避免的是人工干预。</p></blockquote><p id="ca28" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您希望以更大延迟重新传递这些消息，以获得更高的自愈机会。</p><h1 id="e9cc" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">处理 HTTP 请求中的所有内容</h1><p id="b46a" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">可能有处理一切事情的诱惑，比如下订单、发送电子邮件、在 HTTP 请求中接受付款。<br/>这可能会产生一个基于 try catches 和保存错误的解决方案，以便有人可以在以后找到并修复它。<br/>这使得我们编写自定义代码来处理故障，并可能导致不可恢复状态或手动干预以便恢复。</p><blockquote class="lx ly lz"><p id="1ef0" class="jv jw ma jx b jy jz ka kb kc kd ke kf mb kh ki kj mc kl km kn md kp kq kr ks ig bi translated">系统可以自动恢复，无需编写任何额外的代码。消息传递框架会处理它，因为您的代码可以专注于业务问题，而不是技术问题。</p></blockquote><p id="dea2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是消息传递平台存在的原因之一，它可以帮助您构建更加可靠和稳定的代码。<br/>让你的 HTTP 请求做单个动作，比如下订单，然后<code class="fe me mf mg mh b">as a effect</code>发送一个事件消息，声明订单已经下了。从那里，您可以订阅该事件，并以异步方式完成剩余的工作。</p><h1 id="9089" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">单个消息的多个处理程序</h1><p id="a677" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">如果您的事件消息由多个处理程序处理，那么在由于失败而重新发送此类消息的情况下，您可以发送两次电子邮件或进行第二次支付。<br/>一些外部提供商允许使用<code class="fe me mf mg mh b">imdepodency keys</code>，这允许处理重复的呼叫，但情况并非总是如此。</p><p id="2415" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最好的方法是每条消息都有一个动作，当需要两个或更多的动作时，如何实现呢？<br/>让我们以下订单的情况为例，结果我们想要发送电子邮件并从信用卡中付款。</p><h1 id="e9f7" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">Symfony 信使</h1><p id="c505" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">主要实现如下所示:</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="dafa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果将有一个失败，我们可能会以双重付款或电子邮件结束。为了解决这个问题，我们需要创建自定义处理程序。</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="54c8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这解决了主要问题，但是引入了通常不存在的额外消息，增加了代码的复杂性。<br/>我们可以尝试在下单后直接发送<code class="fe me mf mg mh b">SendPlaceOrderEmail</code>和<code class="fe me mf mg mh b">MakePayment</code>消息来解决这个问题，而不是发送<code class="fe me mf mg mh b">OrderWasPlaced</code>消息。<br/>然而，这将把责任放在下订单期间制作这些信息上，并将颠倒责任。下单本身就是一个完整的行为，以上行为只是它的结果。</p><h1 id="e875" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">群落交错区</h1><p id="449c" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">在生态交错的情况下，我们将给定的处理程序标记为异步，而不是消息。<br/>然后，一个消息的副本被传递给每个处理程序。<br/>这意味着每个异步处理程序以原子的方式工作，并分别处理消息。</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="68e8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在失败的情况下，只有单个处理程序会失败，重试是安全的。</p><h1 id="4dc5" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">Laravel 队列</h1><p id="b5a3" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">在 Laravel 队列的情况下，没有处理事件消息的概念，一切都是完成给定动作的工作。<br/>这通过设计解决了主要问题，但是它颠倒了责任，并使下订单操作知道通常会订阅它的事情。</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h1 id="98a2" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak">暂时中断流程</strong></h1><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mo"><img src="../Images/44513750fb5e8fc09e74c548a8d31f65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dLbGcVh6iTY4QfGQwBOIkw.jpeg"/></div></div></figure><p id="9bd5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不熟悉消息传递体系结构的开发人员倾向于构建周围的处理代码，而不是允许消息失败。<br/>这可能是类似<code class="fe me mf mg mh b">wasEmailSent</code>的数据库中的一个字段，每当电子邮件发送失败时，由 try catch 填充。</p><blockquote class="lx ly lz"><p id="3d74" class="jv jw ma jx b jy jz ka kb kc kd ke kf mb kh ki kj mc kl km kn md kp kq kr ks ig bi translated">我们可以编写与基础设施错误无关的代码，并跟踪它们，而无需为每个错误增加额外的存储空间。</p></blockquote><p id="725b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">信息是一等公民，而不仅仅是一项工作。它们实际上告诉了我们一个故事，在我们的系统中流动是什么样子的。消息可能由于各种原因而失败，但是如果失败，我们将自动恢复，如果没有，我们将调查、修复并重播。</p><blockquote class="lx ly lz"><p id="a8eb" class="jv jw ma jx b jy jz ka kb kc kd ke kf mb kh ki kj mc kl km kn md kp kq kr ks ig bi translated">将消息视为可以临时中断的流的一部分，修复问题后，流将恢复。</p></blockquote><h1 id="54a7" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">不可恢复的错误</h1><p id="9156" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">有些情况下，错误是不可恢复的，或者需要很长时间才能自动恢复。</p><p id="0e69" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这类错误大多与应用程序代码问题、不正确的调用/与第三方 API 的兼容性中断，或者我们使用的服务长时间停机有关。<br/>应用程序级别的错误可能真的有益</p><blockquote class="lx ly lz"><p id="f44c" class="jv jw ma jx b jy jz ka kb kc kd ke kf mb kh ki kj mc kl km kn md kp kq kr ks ig bi translated">不可恢复的错误是学习发生的地方，因为它可能揭示我们以前没有想到的场景。</p></blockquote><p id="bddb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，作为关闭账户的结果，我们想要终止电子钱包，然而钱包有正余额，这以异常结束。<br/>在这种情况下，我们应该怎么做，把钱支付到客户的银行账户上，还是关闭账户？<br/>这些错误可能会向我们的产品负责人/领域专家提出问题，以便更多地了解业务是如何运作的。</p><h1 id="4b2b" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">死信队列</h1><p id="d27e" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">死信队列是不可恢复的错误消息所在的地方，我们需要进行手动干预来解决问题。<br/>修复错误后，我们可以重放错误消息以正确处理它并恢复流程。</p><blockquote class="lx ly lz"><p id="118b" class="jv jw ma jx b jy jz ka kb kc kd ke kf mb kh ki kj mc kl km kn md kp kq kr ks ig bi translated">死信队列是您在出现无法自动恢复的错误时的最后一道防线。</p></blockquote><p id="1b3b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们检查一下我们的框架是如何处理这些的。</p><h1 id="14fc" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">Symfony</h1><p id="37e5" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">Symfony 提供了存储不可恢复的错误的方法，这样你就可以查看，重放或删除它们。<br/>您可以从控制台或直接从数据库查看错误消息。</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="mm mn l"/></div></figure><blockquote class="lx ly lz"><p id="726d" class="jv jw ma jx b jy jz ka kb kc kd ke kf mb kh ki kj mc kl km kn md kp kq kr ks ig bi translated"><em class="in">当您的故障数据库存储关闭时，Symfony 将</em> <a class="ae kt" href="https://github.com/symfony/symfony/issues/36870" rel="noopener ugc nofollow" target="_blank"> <em class="in">删除您的错误消息</em> </a> <em class="in">，您将无法恢复它。</em></p></blockquote><h1 id="eddc" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">群落交错区</h1><p id="f03e" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">生态区提供了存储不可恢复的错误的方法，这样你就可以查看、重放或删除它们。<br/>您可以直接从控制台和数据库查看错误。</p><p id="cb35" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了从单一位置控制所有服务的错误消息，创建了<code class="fe me mf mg mh b"><a class="ae kt" href="https://docs.ecotone.tech/modules/ecotone-pulse" rel="noopener ugc nofollow" target="_blank">Ecotone Pulse</a></code>。它允许您使用单个应用程序来查看、重放和删除错误消息。</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mp"><img src="../Images/f85aefaad4c2853801dd388ff6620c4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g8jQ0y0p-4vLntVxSkO7LA.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">过渡带脉冲</figcaption></figure><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="mm mn l"/></div></figure><blockquote class="lx ly lz"><p id="ad1f" class="jv jw ma jx b jy jz ka kb kc kd ke kf mb kh ki kj mc kl km kn md kp kq kr ks ig bi translated"><em class="in">当您的故障数据库存储关闭时，econtero 会将您的消息保留在队列中，直到您的数据库恢复在线。</em></p></blockquote><h1 id="c4fe" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">拉勒韦尔</h1><p id="86fa" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">Laravel 提供了存储不可恢复的错误的方法，这样你就可以查看、重放或删除它们。<br/>您可以直接从控制台和数据库查看错误。</p><pre class="mi mj mk ml gt mu mh mv mw aw mx bi"><span id="fbb7" class="my kv in mh b gy mz na l nb nc">php artisan queue:work redis --tries=3 --backoff=3</span></pre><blockquote class="lx ly lz"><p id="208f" class="jv jw ma jx b jy jz ka kb kc kd ke kf mb kh ki kj mc kl km kn md kp kq kr ks ig bi translated">当您的故障数据库存储关闭时，Laravel 会将您的消息保留在队列中，直到您的数据库恢复在线。</p></blockquote><h1 id="6661" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">摘要</h1><p id="de0e" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">现有的框架提供了各种经过实战检验的解决方案，这将有助于您构建更加可靠和稳定的应用程序。</p><p id="39e1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">无论我们测试或设计代码有多好，都会发生一些错误，这就是为什么我们需要支持工具来帮助我们从这些错误中恢复。<br/>最后，它是关于客户拥有良好的体验，这意味着系统以稳定的方式工作，即使添加了大量新功能:)</p></div></div>    
</body>
</html>