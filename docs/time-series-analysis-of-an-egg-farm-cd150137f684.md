# 一个鸡蛋场的时间序列分析

> 原文：<https://blog.devgenius.io/time-series-analysis-of-an-egg-farm-cd150137f684?source=collection_archive---------6----------------------->

## 使用大量的时间序列模型和 R

在这篇文章中，我想向你展示我在鸡蛋农场使用自动化数据模拟鸡蛋产量和其他几个结果的方法。它的商业数据，所以我不能附上数据，但这个例子本身应该提供足够的身体，看看我做了什么，为什么我这样做。这不是我第一次发表关于分析[家禽数据](https://medium.com/mlearning-ai/looking-for-uniformity-in-chickens-763ca9c18a1e)的文章，但这是第一次将[时间序列](https://medium.com/@marc.jacobs012/time-series-analysis-in-sas-8b6c03b39fd4?source=your_stories_page----------------------------------------)应用于鸡蛋生产。让我们玩得开心！

我从包含数据的 Azure blob 存储中导入了数据。请记住，这是商业数据，所以我不能分享。不幸的是。

![](img/1be0a9a012d019b42249886fd08f111c.png)

最后，我得到了一个包含我每天需要的所有数据的 tibble。这不一定是我将要开始探索的数据集。我将从原来的几套开始，看看我有什么。

我想事先警告你。有很多情节在等着你。这只是理解你在看什么，以及你需要什么和不需要什么来构建模型的正常部分。和往常一样，至少 50%的时间将用于绘制数据。另外 49%是数据角力。

![](img/c43c2c3b5377ea7eeff36fb1c3c286c2.png)

关于在鸡蛋农场什么是“正常”的数据。

![](img/13094d1634e0ecb64fd146963f0a201c.png)![](img/c5e6d735bc50271a6f880dc2d7e065a4.png)![](img/6deacc2c76eeb2daf6dc60a50510be6e.png)![](img/aded3b6e7443b999a0fb07580246ba13.png)![](img/d6e4ae609abd149bf7e10a33215af365.png)![](img/5c1ee681a39d78d6403cf1c90993e987.png)![](img/bd36c280c096fe4dbd26617a91a36594.png)![](img/f7852cc6811b2bd40e310d682d464f01.png)![](img/c0cbeb26f44a228b575f5e5214a0208a.png)![](img/a0dab6f3d1af3251b3a10b7dfbcdb72e.png)![](img/053782f9ebac9f302644cf99ec66aa1a.png)![](img/3992c92cd1ffa47d1641b16fbb9d9538.png)![](img/a35893e8002d24143ecfacec8995d308.png)![](img/91d868dd8c1c5fe91c57422bd86209ec.png)![](img/ec35d725430ad6e7c5c6e91e4a4f2d26.png)![](img/5c83a6563c8b34066001880bfa8e6c2c.png)![](img/8f50d73bf8a24c05acc0af238ef9681e.png)![](img/558aff9fdd6ea760f6beeba34963bff7.png)![](img/e16e7e02357b562686c20208960439ac.png)![](img/c37faf601efcf967787684eb30f4aa51.png)![](img/12e5cf4cf767f197d46854af9a3ec0f7.png)![](img/e8a91bf5a6893e1fc5769f7107256371.png)![](img/7369f16d3dfdb4840e585a19b6f1b25d.png)![](img/32f31b72996dc30efdddee5aa7a9e204.png)![](img/852660d5041c816fa1ff6a161c379f03.png)![](img/f1195c5d9ed80cf815adbabc321d76c0.png)![](img/06f69b05a92d833edee102d789a73d80.png)

和大量图表来查看数据的各个部分。有些可能有用，有些可能没用。你永远不会事先知道。此外，它让您对数据的粒度有了一个很好的了解，有些地方的数据更稀疏，有些地方的数据很好。这可能有助于您构建模型，并找出您在哪里以及为什么会遇到模型收敛问题。表格数据很少揭示这些。

让我们转到第一批时间序列模型——指数平滑模型(ESM / ETS)。我真的很喜欢 ESM 模型，因为它们易于应用，让你对数据质量及其提供合理预测的能力有一个很好的感觉。

![](img/7f778e99220955fd0d679f2e68018618.png)

农场位置的 ETS 模型残差。

![](img/a5d6fd9ef909f5a37300192911de2b77.png)

由三个 ETS 模型组成的表。

![](img/0baebcb46cd39b29922df11d053351d1.png)

显示每个位置的预测。没有预测区间的事实让我很担心。这通常不是一个好现象。要么是数据不充分，要么是我在编程部分搞砸了什么。

![](img/0296f8a2378716a78a4e38d8ec118d64.png)

以及将模型拟合反馈给数据时得到的数据集。

![](img/770c47687440f535ba74b6f3cca351d7.png)

不太令人印象深刻的预测。这甚至不是一个天真的预测，这只是预测一个单一的值。

现在，上面并没有承诺一个好的开始，所以让我们试着再次回到数据上来。我将构建单独的 ts 对象，然后将它们合并以构建预测( *dfy* )和预测( *dfx* )数据集。让我第一个说，我下面做事情的方式不是最干净的代码，但是重复是精通的必要条件。

![](img/b56b5cb89fa97d1e6f23124dcdacc371.png)![](img/c6b4b11c012e29e89c0eb9230adff51a.png)

数据绘制成图，并作为自相关残差。

![](img/8eb186fb098f55e7fc4dd5d8276ef9b6.png)![](img/61fb0c5d56715d60b171af48647ce94f.png)![](img/64d4d16fbedbb753ed60232c582c2a49.png)

**dfy** 各部分分解分析。这些分析有助于发现模式，如果它们存在的话。他们还可以根据你所看到的和你所知道的(生物学上的)来指导你选择一个模型，而不是在一个列表中运行 20 个模型，让自动选择来决定哪一个是“最好的”。

![](img/480d0e41c92128ec516b2701d8eb3b55.png)

这个图帮助你解释为什么 ETS 模型走直线。这是因为尽管这些数据有很多起伏，但平均来说用一条直线很容易捕捉到。

现在，如果你看到这样的东西，你通常知道你完成了。但是，让我们看看是否可以通过执行[向量自回归模型](/the-effect-of-covid-measures-on-covid-outcomes-a-vector-autoregressive-moving-average-exogenous-dd7fa6c3774f)来添加一些额外的信息。他们肯定在过去帮助过我，例如，在分析新冠肺炎的数据时。

![](img/7f4981a9dc93b81324dd9cc8e202d9eb.png)

指定的型号。

![](img/00c0dca11ad6c19865eccefcd31fd479.png)

还有天气预报。真实与拟合。还不错。

让我们更深入地研究风险值模型，但要注意:

1.  序列相关误差的测试
2.  误差的异质性检验
3.  误差正态性检验
4.  误差稳定性测试
5.  因果关系检验
6.  冲动测试——这实际上是因果关系测试的一部分。

现在，正如你所预料的，有很多数据可以测试，但是我会试着让你不要做这种测试。统计检验通常并不稳健，数据越多，它们就越容易达到替代假设。更好的方法是查看曲线图，看看误差是否自相关、正常、同质和稳定。

![](img/f1b70098f317e1e6b1572c6079a2eb9e.png)![](img/c24afe3a0993070344d8f8be2be70cf2.png)![](img/10af81efb42b87a4a75b26388b744bad.png)![](img/257258185a84632640ecfccb3401502b.png)

看起来不错，都在线内。

![](img/0baf22d5b092404c92e1e9ece27719d3.png)![](img/6ce6b0d1d87f67d9faf50d7ce782684d.png)

看起来不错。

![](img/523b1261ce055c817100dde97c275fb6.png)![](img/536a2e17573b529d5b4b498c559d0c05.png)![](img/cd6e1138427508177cadac1972e94456.png)

饲料对鸡蛋有影响，但水似乎没有。

![](img/a61d7b8b7449c75d0286a9b9f5aecee3.png)

这是一个非常好的情节。它显示了，在 14 个滞后中，饲料、水和蛋对饲料、水和蛋的影响。你要寻找的是如何预测滞后值。如你所见，每个变量大多是通过自身预测的，但随着时间的推移，其他变量也会加入进来。

评估模型的最佳方法是使用外部验证数据。我将这些数据放在一个单独的文件中，我将加载该文件，建立我需要的格式来测试预测，然后将它与我看到的进行比较。老实说，这不是最好的编程方式，但它确实有用。

哦，这提醒了我。当处理时间序列数据，构建 [ts](https://stat.ethz.ch/R-manual/R-devel/library/stats/html/ts.html) 或 [xts 或动物园对象](https://rstudio-pubs-static.s3.amazonaws.com/288218_117e183e74964557a5da4fc5902fc671.html)时，你必须记住数据中集成了时间成分。并且当将数据分成训练和测试(或者甚至验证对象)时，根据数据的频率来划分数据。我有很多例子可以说明，我错过了这些，导致了奇怪的预测或者根本没有预测。事实上，在这篇文章的后面你会看到一些混乱。

![](img/2c57ffbf9cdd0a31b92b8bde1dac34b9.png)

温度数据的自动绘图。

![](img/d22afff0a6bcc445b11b10e5a572c081.png)![](img/6df760fb6829ee8999511e20bcb96690.png)

来自风险值模型的预测。同样的预测，但是绘制的方式不同。

![](img/b296372c312453794b478e17385354da.png)

以及显示外部数据帧预测的组合图。老实说，这看起来真的很好。

多步预测和单步预测是有区别的。这不是一个很大的区别，但它可以产生相当大的影响。简而言之:多步预测围绕着预测一系列值，其中在点 1 做出的预测也会影响在点 2 做出的预测。这就是为什么它被称为多步。

让我们在这里做同样的事情，使用一段代码，我相信在一个函数中它会变得更加容易。但至少你可以看到正在发生的事情。我试着提前五步做多步预测。

![](img/93eeb73eb3228367b320febce7e73b0f.png)

预测热图

![](img/42f1c5176af03fd06e2c87edb77042dd.png)

你可以看到，预测变得越大，就越不零星。然而，由于某种原因，我不能让它走到观察值的末尾甚至更远，这使我认为绘图程序是不正确的。如果时序对象的时间部分没有对齐，就会出现这种情况。如果你不小心，它会让你很忙。我会让它值回票价，但我很确定我在函数本身犯了一个错误。此外，我注意到许多程序并不真正喜欢日常数据。

让我们通过另一种方式尝试多步预测，使用[预测包](https://www.rdocumentation.org/packages/forecast/versions/8.16)的内置功能。当进行时间序列分析时，预测包是您的首选包。自创建以来，已经开发了许多其他时间序列包，可以与预测包结合使用。与 R 中的许多事情一样，至少有 10 种方法可以做完全相同的事情。

下面是交叉验证函数中使用的自动 Arima 模型。简单化编程的危险就在这里。

![](img/d63067a390568eb039b36d3d30a521bd.png)

这是一个 ARIMA (3，0，2)，意味着滞后 3 自相关，无差异，滞后 2 移动平均线。

![](img/48c70b09988ee285329771ca1f763853.png)![](img/505b9ed6d57bf71992fd7c6a9d12ab0f.png)![](img/a001e8fc591ed1537e24a1493c156e5c.png)

ARIMA(3，0，2)系数似乎在圆圈内，这是你想看到的。然后，对残差进行评估，然后进行预测。同样在这里，几乎是一条直线(不要让小波浪愚弄你)。

让我们看看模型在测试数据上的表现。当然，这不是测试一个训练好的模型的方法，但是如果数据有相同的模式，这确实有助于获得一种感觉。尽管样本量有限，但我至少希望在列车和测试数据上有一个类似的模型。至少，我希望如此。

![](img/f42cc2be8023273d4ef5fef4cff1e7ab.png)![](img/0f36b398844098ca63d8da4b922dc3ff.png)

一样的型号，一样的东西。

就像我说的，这不是验证模型的方法。有更好的方式来实现这个目标。一个特别好的方法是使用[插件](https://topepo.github.io/caret/model-training-and-tuning.html)包中的预测窗口(*时间片*)。时间片确实如其名所言——它对时间进行切片。在下面的例子中，我指定前 50 天用于培训(因为我的数据是以天为单位的)。然后，每个 7 天的连续窗口是每个新的训练程序。

![](img/389ef1e1c74f431783520f46b7be43a1.png)

Timeslice 解释道。在这里，您可以看到初始窗口的大小(红色)、地平线(蓝色)以及窗口是否固定。这是一种跨时间训练数据的巧妙方法。该模型不一定是时序模型。

![](img/4aa30b5a6f9162ebbb8d6b6a47330547.png)

以及，使用几个机器学习模型的最终结果。显然，ctree 模型是最好的，尽管其他模型也很接近。从技术上讲，您可以对这些置信区间进行统计分析，但我真的认为没有必要，因为除了纯粹的预测能力之外，还有更多模型类型的选择(这通常仍然是部分过度拟合，不考虑验证)。

虽然上面的建模可能足以建立一个概念验证模型，但我想给一个时间序列模型一个最后的尝试。所以，我又来了，使用 ARIMAX 模型(带有外生预测因子的 ARIMA)。

![](img/a3526a9b117c7f55e6ac0b5dfafd751b.png)![](img/726289a6023ecdace8d4c169667532ee.png)![](img/e4752d2be14798e437e669984680064b.png)

实际上看起来不错！

新的尝试。这一次，我将把预测保存到最初提取数据的原始 Azure Blob 存储中。这样的话，我们可以自动操作。

![](img/fd930d6e534191be7c20f96aa8932659.png)

看起来不错，但不完美。

![](img/4e01158d1d67a095fa1094533b273913.png)

看起来也不错。似乎，我们有一个时间序列的概念验证模型。

我希望你喜欢这个例子！请让我知道如果事情需要补充或如果你发现错误！