<html>
<head>
<title>Serverless web scraping with NiFi and OpenFaaS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用NiFi和OpenFaaS的无服务器网络抓取</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/serverless-web-scraping-with-nifi-and-openfaas-ba7ac675a200?source=collection_archive---------6-----------------------#2021-12-13">https://blog.devgenius.io/serverless-web-scraping-with-nifi-and-openfaas-ba7ac675a200?source=collection_archive---------6-----------------------#2021-12-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="948c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">TL；DR </strong>:如何创建一个Selenium无服务器报废器并将其与Apache Nifi集成</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/aa6576a0fb2fe1c978649b89363f90ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pgf28hP8wlxUB5t996BlfQ.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">NiFi + OpenFaaS + Selenium =无服务器刮刀</figcaption></figure><h1 id="01c2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">动机</h1><p id="3e00" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated"><a class="ae me" href="https://www.openfaas.com/" rel="noopener ugc nofollow" target="_blank"> OpenFaaS </a>是一个很棒的无服务器框架。在我的上一篇文章中，我展示了如何以快速开发周期的方式创建无服务器功能。</p><div class="mf mg gp gr mh mi"><a href="https://jmrobles.medium.com/develop-openfaas-functions-quickly-with-okteto-ef6a80365b97" rel="noopener follow" target="_blank"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd ir gy z fp mn fr fs mo fu fw ip bi translated">用Okteto快速开发OpenFaaS函数</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">用Okteto加速你的无服务器功能开发</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">jmrobles.medium.com</p></div></div><div class="mr l"><div class="ms l mt mu mv mr mw kv mi"/></div></div></a></div><p id="7db4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">无服务器模式的一大优势是灵活性。您可以从任何地方调用无服务器功能。</p><p id="f920" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通常你从一个orchestrator调用一个无服务器函数，比如Airflow、Prefetch、Apache Nifi等等</p><p id="7a93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天，我们开发了一个无服务器功能，使用Selenium和Chromium删除URL列表的内容。</p><p id="9cb6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们需要创建一个支持Selenium的OpenFaaS模板。使用我们的新模板，我们创建了一个简单的web scrapper。最后，我们从Apache NiFi调用函数。</p><h1 id="3127" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">1.一个新的Selenium-ready OpenFaaS模板</h1><p id="c67f" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">你可能知道，有了OpenFaaS，你可以使用许多不同种类的模板。</p><p id="f24f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">模板充当HTTP请求和您的“处理程序”函数之间的包装器。</p><p id="d0c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当OpenFaaS构建您的无服务器功能时，它会用模板和您的功能代码生成一个Docker映像。</p><p id="5e3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于我们的模板，我们派生出“python3-http”模板。</p><p id="5ba6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我喜欢这个模板，因为它基于Python Flask，我们可以访问请求/响应头。</p><p id="e848" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用头部来验证函数的使用。</p><p id="776e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要做的最大改变是包含selenium和chromium驱动程序的<strong class="jp ir"> apk </strong>库并安装它们。</p><p id="993e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以从GitHub签出模板。</p><div class="mf mg gp gr mh mi"><a href="https://github.com/jmrobles/python3-http-selenium" rel="noopener  ugc nofollow" target="_blank"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd ir gy z fp mn fr fs mo fu fw ip bi translated">GitHub-jmrobles/python 3-http-selenium:open FAAS python 3 Flask模板，支持Selenium</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">支持Selenium的OpenFaaS Python3 Flask模板-GitHub-jmrobles/python 3-http-Selenium:open FAAS python 3 Flask…</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">github.com</p></div></div><div class="mr l"><div class="mx l mt mu mv mr mw kv mi"/></div></div></a></div><p id="05d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了使用它，我们为我们的无服务器项目创建了一个新文件夹，<code class="fe my mz na nb b">of-scrapper</code>,并检查了模板代码</p><pre class="km kn ko kp gt nc nb nd ne aw nf bi"><span id="22dc" class="ng lc iq nb b gy nh ni l nj nk">faas template pull https://github.com/jmrobles/python3-http-selenium</span></pre><h1 id="d75e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">2.一个简单的web scraper无服务器</h1><p id="53f2" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">有了模板，是时候创建和编码我们的函数了。</p><pre class="km kn ko kp gt nc nb nd ne aw nf bi"><span id="c958" class="ng lc iq nb b gy nh ni l nj nk">faas new --lang python3-http-selenium of-scraper</span></pre><p id="ea95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">前面的命令为我们的函数创建了存根代码。</p><p id="f949" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用以下要点内容替换<code class="fe my mz na nb b">handler.py</code></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="549d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的报废功能很简单。我们传递一个URL列表，该函数打开一个新的chrome会话，并为每个URL获取一些基本信息:标题、标题、文本内容和图像。</p><p id="17f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了防止未经授权使用计算资源，我们添加了一个基于共享机密的简单身份认证。我们传递头“auth-code”来传递我们的授权码。</p><p id="5bd3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当工作完成时，它关闭Chromium会话并返回所有结果。</p><p id="f32b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个耗时的操作。单个URL平均需要大约1分钟。因此，我们需要设置所有东西的超时(OpenFaaS执行器、OpenFaaS引擎和Kubernetes入口)。</p><p id="71e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们函数的YAML必须类似于下面的要点。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="94eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于OpenFaaS引擎中的超时，我们需要更新pod“gateway”(gateway和faas-netes容器)的环境变量中的<strong class="jp ir"> read_timeout </strong>、<strong class="jp ir"> write_timeout </strong>和<strong class="jp ir"> exec_timeout </strong>。</p><p id="618b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们需要添加一些注释来配置入口超时。在nginx进入的情况下，<code class="fe my mz na nb b">proxy-connect-timeout</code>、<code class="fe my mz na nb b">proxy-send-timeout</code>和<code class="fe my mz na nb b">proxy-read-timeout</code>。</p><p id="3900" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将入口超时设置为“1800”(30分钟)。</p><p id="b540" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们只需构建映像并进行部署。</p><pre class="km kn ko kp gt nc nb nd ne aw nf bi"><span id="b6c7" class="ng lc iq nb b gy nh ni l nj nk">$ faas publish --platforms linux/amd64 -f of-scraper.yml<br/>$ faas deploy -f of-scraper.yml</span></pre><h1 id="d109" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">3.从Apache NiFi呼叫</h1><p id="9d7b" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">最后但同样重要的是如何从Apache NiFi调用我们的新函数。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nn"><img src="../Images/52474a9f87c3d21600c6319c5fd91660.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pBCEoZdbqX7uuDAqtS_HfQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">我们简单的NiFi废料管道</figcaption></figure><p id="5036" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了进行测试，我们添加了以下三个处理器:</p><ul class=""><li id="99da" class="no np iq jp b jq jr ju jv jy nq kc nr kg ns kk nt nu nv nw bi translated"><strong class="jp ir">生成流文件</strong>:使用“自定义文本”属性，我们设置JSON请求和头</li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nx"><img src="../Images/53698cae6afce413737f25cd2440999b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jV2TbBmftSUB5RMBgXwfKg.png"/></div></div></figure><ul class=""><li id="5335" class="no np iq jp b jq jr ju jv jy nq kc nr kg ns kk nt nu nv nw bi translated"><strong class="jp ir"> InvokeHTTP </strong>:这是对我们的无服务器函数的真实调用。</li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ny"><img src="../Images/3eb2d34d896fb7213f059a520cb5ab6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*43DZ-evDus_EuqtYFxR1tA.png"/></div></div></figure><p id="f8d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用“POST”HTTP动词，并将读取超时修改为一个较大的数字(10分钟)。</p><ul class=""><li id="0b41" class="no np iq jp b jq jr ju jv jy nq kc nr kg ns kk nt nu nv nw bi translated"><strong class="jp ir"> PutFile </strong>:为了检查我们的scrap函数是否工作正常，我们将输出写入文件。我们将它们保存到一个临时目录(/tmp/scraped-web)中。您可以通过访问NiFi容器并对文件进行“ls/cat”来检查它。<br/>我们将InvokeHTTP的“失败”和“响应”输出链接到这个写文件处理器。</li></ul><h1 id="79de" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">仅此而已！</h1><p id="5302" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">我们在云中有一个强大的网络抓取器。如果需要，我们可以向外扩展。其他可能的解决方案是使用<a class="ae me" href="https://www.selenium.dev/documentation/grid/" rel="noopener ugc nofollow" target="_blank"> Selenium Grid </a>，它允许以批量/并行方式报废(或应用e2e测试)。</p></div></div>    
</body>
</html>