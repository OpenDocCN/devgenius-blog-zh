<html>
<head>
<title>User Management with Okta SDK and Spring Boot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Okta SDK和Spring Boot进行用户管理</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/user-management-with-okta-sdk-and-spring-boot-11c6a780926a?source=collection_archive---------6-----------------------#2021-03-07">https://blog.devgenius.io/user-management-with-okta-sdk-and-spring-boot-11c6a780926a?source=collection_archive---------6-----------------------#2021-03-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="13bc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这篇文章中，我将展示我们如何用Okta SDK和Spring Boot构建用户管理和认证。</p><h1 id="4942" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">介绍</h1><p id="09af" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">作为任何应用程序的一部分，开发人员必须小心如何构建身份验证。尽管我们长期以来一直使用基于表单的身份验证，但它并不是最安全的。在这篇文章中，我计划展示基于表单的身份验证，在这种情况下，用户不必通过对照数据库中存储的密码来验证他们的加密密码。如果你想了解更多关于不同认证流程的Spring安全性，我最近发布了一本书<a class="ae ll" href="https://betterjavacode.com/programming/simplifying-spring-security" rel="noopener ugc nofollow" target="_blank">简化Spring安全性</a>。你可以在这里买到这本书<a class="ae ll" href="https://gumroad.com/l/VgSdH" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="91d3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Okta是一个身份提供商。这是一个应用程序，提供不同协议的用户管理和认证。</p><h1 id="e9b9" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">Okta SDK APIs</h1><p id="dff2" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">Okta为用户管理API和认证提供了两个库<code class="fe lm ln lo lp b">okta-sdk-java</code>和<code class="fe lm ln lo lp b">okta-auth-java</code>。</p><p id="0f8d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这些图书馆适合你吗？这取决于您的用例。Okta还提供了<code class="fe lm ln lo lp b">okta-spring-boot-starter</code>库，在您的Spring Boot应用程序中为不同的OAuth流使用okta。我们不会在这个演示中使用这个库。</p><p id="67e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以在这里和这里找到关于这些库<a class="ae ll" href="https://github.com/okta/okta-sdk-java" rel="noopener ugc nofollow" target="_blank">的更多细节。</a></p><p id="5223" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将这些库包括在项目中，如下所示:</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="2089" class="ly kj in lp b gy lz ma l mb mc">implementation 'com.okta.authn.sdk:okta-authn-sdk-api:2.0.1' runtimeOnly 'com.okta.authn.sdk:okta-authn-sdk-impl:2.0.1' runtimeOnly 'com.okta.sdk:okta-sdk-httpclient:3.0.1'</span></pre><h1 id="fed7" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">Okta SDK在Spring Boot应用中的用户管理</h1><p id="89d3" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">在这个演示中，我有一个待办事项列表的示例应用程序。当用户启动应用程序时，用户将看到一个登录屏幕。它有注册选项。如果用户在应用程序中不存在，用户必须创建一个帐户。</p><p id="787d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在注册页面，当用户输入“提交”按钮时，我们会将用户保存在我们的数据库中，然后调用Okta SDK API在Okta端创建用户。</p><p id="4b35" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要实现这一点，我们需要Okta客户端。</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="4e9a" class="ly kj in lp b gy lz ma l mb mc">    @Bean<br/>    public Client client()<br/>    {<br/><br/>        Client clientConfig =<br/>                Clients.builder().setOrgUrl("https://oktadomainurl").setClientCredentials(new TokenClientCredentials(secret))<br/>                        .build();<br/><br/><br/>        return clientConfig;<br/><br/>    }</span></pre><p id="01a9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如您在上面看到的，我们正在创建一个客户端，我们将使用它来调用Okta API。“秘密”是你可以在Okta管理界面中找到的API令牌。如果您找不到它，要么您没有管理员权限，要么您尚未创建令牌。还有另一种方法来创建带有访问令牌的客户机。</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="1f05" class="ly kj in lp b gy lz ma l mb mc">    @Bean<br/>    public Client client()<br/>    {<br/><br/>        Client clientConfig =<br/>                Clients.builder().setOrgUrl("https://oktadomainurl")<br/>                      .setAuthorizationMode(AuthorizationMode.PRIVATE_KEY).setClientId("{clientId}")<br/>                      .setScopes(new HashSet&lt;&gt;(Arrays.asList("okta.users.read", "okta.apps.read")))<br/>                      .setPrivateKey("/path/to/yourPrivateKey.pem")<br/><br/><br/>        return clientConfig;<br/><br/>    }</span></pre><p id="8d3c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种客户机配置的优点是，您不需要知道基于管理员权限创建的API访问令牌。</p><p id="5677" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，在我的控制器端，我将使用这个客户端在Okta中创建用户，如下所示:</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="c714" class="ly kj in lp b gy lz ma l mb mc">        UserDto userDto = new UserDto();<br/>        userDto.setEmail(email);<br/>        userDto.setFirstName(firstname);<br/>        userDto.setLastName(lastname);<br/>        userDto.setPassword(encodedPassword);<br/>        userDto.setRole("ADMIN");<br/>        userDto.setEnabled(true);<br/><br/>        UserDto returnedUser = usersManager.createUser(userDto);<br/><br/>        LOGGER.info("Create the user in Okta");<br/><br/>        User oktaUser = UserBuilder.instance().setEmail(returnedUser.getEmail())<br/>                .setFirstName(returnedUser.getFirstName())<br/>                .setLastName(returnedUser.getLastName())<br/>                .buildAndCreate(client);</span></pre><p id="d3ca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这包括了用户管理部分。您可以类似地调用<code class="fe lm ln lo lp b">GET</code>或<code class="fe lm ln lo lp b">DELETE</code> API来管理用户。</p><h1 id="a8eb" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">用户认证</h1><p id="e129" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">现在到了认证的关键部分。在许多企业应用中，当使用第三方身份提供者时，麻烦总是伴随着用户数据同步。这两个应用程序都需要存储用户数据。</p><p id="5996" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于认证，我们将需要<code class="fe lm ln lo lp b">authenticationClient</code> bean。这个客户端将允许我们调用Okta API进行身份验证。</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="8b23" class="ly kj in lp b gy lz ma l mb mc">    @Bean<br/>    public AuthenticationClient authenticationClient()<br/>    {<br/>        AuthenticationClient authenticationClient =<br/>                AuthenticationClients.builder()<br/>                        .setOrgUrl("https://oktadomainurl")<br/>                        .build();<br/><br/>        return authenticationClient;<br/>    }</span></pre><p id="6327" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们的安全配置中，我将用一个定制的登录页面覆盖基于表单的登录。</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="d573" class="ly kj in lp b gy lz ma l mb mc">    @Autowired<br/>    private CustomAuthenticationProvider customAuthenticationProvider;<br/><br/>    @Bean(BeanIds.AUTHENTICATION_MANAGER)<br/>    @Override<br/>    public AuthenticationManager authenticationManagerBean() throws Exception<br/>    {<br/>        return super.authenticationManagerBean();<br/>    }<br/><br/><br/>    @Override<br/>    protected void configure(HttpSecurity httpSecurity) throws Exception<br/>    {<br/><br/>        httpSecurity.authorizeRequests()<br/>                .antMatchers("/js/**","/css/**","/img/**").permitAll()<br/>                .antMatchers("/signup","/forgotpassword").permitAll()<br/>                .anyRequest().authenticated()<br/>                .and()<br/>                .formLogin()<br/>                .loginPage("/login")<br/>                .permitAll();<br/><br/>    }</span></pre><p id="f05c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如你在上面的代码中看到的，我正在使用<code class="fe lm ln lo lp b">customAuthenticationProvider</code>，这个提供者将使用<code class="fe lm ln lo lp b">authenticationClient</code>与Okta进行认证。此AuthenticationProvider将如下所示:</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="00bf" class="ly kj in lp b gy lz ma l mb mc">package com.betterjavacode.sss.todolist.clients;<br/><br/>import com.betterjavacode.sss.todolist.security.AuthenticationStateHandler;<br/>import com.okta.authn.sdk.client.AuthenticationClient;<br/>import com.okta.authn.sdk.resource.AuthenticationResponse;<br/>import org.slf4j.Logger;<br/>import org.slf4j.LoggerFactory;<br/>import org.springframework.beans.factory.annotation.Autowired;<br/>import org.springframework.security.authentication.AuthenticationProvider;<br/>import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;<br/>import org.springframework.security.core.Authentication;<br/>import org.springframework.security.core.AuthenticationException;<br/>import org.springframework.security.core.GrantedAuthority;<br/>import org.springframework.security.core.authority.SimpleGrantedAuthority;<br/>import org.springframework.security.core.userdetails.User;<br/>import org.springframework.security.core.userdetails.UserDetails;<br/>import org.springframework.stereotype.Component;<br/><br/>import java.util.ArrayList;<br/>import java.util.List;<br/><br/>@Component<br/>public class CustomAuthenticationProvider implements AuthenticationProvider<br/>{<br/><br/>    private static final Logger LOGGER = LoggerFactory.getLogger(CustomAuthenticationProvider.class);<br/><br/>    @Autowired<br/>    private AuthenticationClient authenticationClient;<br/><br/>    @Autowired<br/>    private AuthenticationStateHandler authenticationStateHandler;<br/><br/>    @Override<br/>    public Authentication authenticate (Authentication authentication) throws AuthenticationException<br/>    {<br/>        String username = authentication.getName();<br/>        String password = authentication.getCredentials().toString();<br/>        String relayState = "/index";<br/>        AuthenticationResponse authnResponse = null;<br/>        try<br/>        {<br/>            LOGGER.info("Going to connect to Okta");<br/>            authnResponse = authenticationClient.authenticate(username, password.toCharArray(),<br/>                    relayState,<br/>                    authenticationStateHandler);<br/>        }<br/>        catch(com.okta.authn.sdk.AuthenticationException e)<br/>        {<br/>            LOGGER.error("Unable to authentcate the user", e);<br/>        }<br/><br/>        if(authnResponse != null)<br/>        {<br/>            final List grantedAuths = new ArrayList&lt;&gt;();<br/>            grantedAuths.add(new SimpleGrantedAuthority("ROLE_ADMIN"));<br/>            final UserDetails principal = new User(username, password, grantedAuths);<br/>            final Authentication authen = new UsernamePasswordAuthenticationToken(principal,<br/>                    password, grantedAuths);<br/>            return authen;<br/>        }<br/>        else<br/>        {<br/>            LOGGER.info("Unable to authenticate");<br/>            return null;<br/>        }<br/><br/>    }<br/><br/>    @Override<br/>    public boolean supports (Class&lt;?&gt; authentication)<br/>    {<br/>        return true;<br/>    }<br/>}</span></pre><p id="1d59" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们使用<code class="fe lm ln lo lp b">authenticationClient</code>来调用认证方法。<code class="fe lm ln lo lp b">AuthenticationStateHandler</code>基本处理身份认证。该句柄的实现如下所示:</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="4b8b" class="ly kj in lp b gy lz ma l mb mc">package com.betterjavacode.sss.todolist.security;<br/><br/>import com.okta.authn.sdk.AuthenticationStateHandlerAdapter;<br/>import com.okta.authn.sdk.resource.AuthenticationResponse;<br/>import com.okta.commons.lang.Strings;<br/>import org.slf4j.Logger;<br/>import org.slf4j.LoggerFactory;<br/>import org.springframework.stereotype.Component;<br/><br/>@Component<br/>public class AuthenticationStateHandler extends AuthenticationStateHandlerAdapter<br/>{<br/>    private static final Logger LOGGER = LoggerFactory.getLogger(AuthenticationStateHandler.class);<br/><br/>    @Override<br/>    public void handleUnknown (AuthenticationResponse unknownResponse)<br/>    {<br/>        // TO DO<br/>    }<br/><br/>    @Override<br/>    public void handleSuccess (AuthenticationResponse successResponse)<br/>    {<br/>        if (Strings.hasLength(successResponse.getSessionToken()))<br/>        {<br/>            LOGGER.info("Login successful");<br/>            String relayState = successResponse.getRelayState();<br/>            String dest = relayState != null ? relayState : "/";<br/><br/>        }<br/>    }<br/>}</span></pre><p id="ef5a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">仅此而已。这包括用户认证。请记住，这仍然是基于表单的身份验证，您在自定义登录页面上输入用户凭证，并在屏幕后面调用Okta API进行身份验证。</p><p id="d2e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我的书<a class="ae ll" href="https://gum.co/VgSdH" rel="noopener ugc nofollow" target="_blank">简化Spring安全</a>中，我还添加了使用Okta OAuth登录的演示。</p><h1 id="7a93" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">结论</h1><p id="f7a9" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">在这篇文章中，我展示了如何在Spring Boot应用程序中使用Okta SDK进行用户管理和认证。如果你有任何问题，欢迎通过订阅我的博客<a class="ae ll" href="https://betterjavacode.com/subscribe" rel="noopener ugc nofollow" target="_blank">给我发邮件。</a></p></div><div class="ab cl md me hr mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ig ih ii ij ik"><p id="89b5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mk">原载于2021年3月7日https://betterjavacode.com</em><a class="ae ll" href="https://betterjavacode.com/spring-boot/user-management-with-okta-sdk-and-spring-boot" rel="noopener ugc nofollow" target="_blank"><em class="mk"/></a><em class="mk">。</em></p></div></div>    
</body>
</html>