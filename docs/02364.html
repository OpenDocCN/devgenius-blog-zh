<html>
<head>
<title>React Tips — Conditional Prop Validation, and React Router Basics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React 提示—条件属性验证和 React 路由器基础</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/react-tips-conditional-prop-validation-and-react-router-basics-9bfd65127975?source=collection_archive---------17-----------------------#2020-07-30">https://blog.devgenius.io/react-tips-conditional-prop-validation-and-react-router-basics-9bfd65127975?source=collection_archive---------17-----------------------#2020-07-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/783f66818b7dd83d54f602d28ec7803c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4m6gYHuavize0wly"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@heftiba?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">托阿·海夫蒂巴</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="d5fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React 是一个用于创建 web 应用程序和移动应用程序的流行库。</p><p id="f2a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解一些编写更好的 React 应用程序的技巧。</p><h1 id="91f0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">如果另一个 Prop 为 null 或 Prop-Types 为空，则需要在 Prop 上设置 is</h1><p id="b12b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Prop-types 允许我们使用自定义验证来验证另一个 Prop。</p><p id="3f8b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1fec" class="mn lc iq mj b gy mo mp l mq mr">import PropTypes from 'prop-types';</span><span id="7c06" class="mn lc iq mj b gy ms mp l mq mr">//...</span><span id="124b" class="mn lc iq mj b gy ms mp l mq mr">Item.propTypes = {<br/>  showDelete: PropTypes.bool,<br/>  handleDelete: (props, propName, componentName) =&gt; {<br/>    if (props.showDelete === true &amp;&amp; typeof props[propName] !== 'function') {<br/>      return new Error('handleDelete must be a function');<br/>    }<br/>  },<br/>}</span></pre><p id="1b97" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一个<code class="fe mt mu mv mj b">Item</code>组件，我们在其中设置了<code class="fe mt mu mv mj b">propTypes</code>属性来进行一些验证。</p><p id="9036" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将<code class="fe mt mu mv mj b">showDelete</code>设置为一个布尔属性。</p><p id="99f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且通过检查<code class="fe mt mu mv mj b">showDelete</code>道具是否为<code class="fe mt mu mv mj b">true</code>以及<code class="fe mt mu mv mj b">handleDelete</code>道具是否为函数的函数来验证<code class="fe mt mu mv mj b">handleDelete</code>。</p><p id="0fc0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">propName</code>是我们当前正在验证的道具的名称。</p><p id="070f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以<code class="fe mt mu mv mj b">propName</code>就是<code class="fe mt mu mv mj b">handleDelete</code>道具。</p><p id="1652" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们确保如果<code class="fe mt mu mv mj b">props.showDelete</code>是<code class="fe mt mu mv mj b">true</code>，那么<code class="fe mt mu mv mj b">handleDelete</code>属性是一个函数。</p><p id="0c37" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有 react-required-if 包，让我们可以简化代码。</p><p id="d540" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8edb" class="mn lc iq mj b gy mo mp l mq mr">import requiredIf from 'react-required-if';<br/>import PropTypes from 'prop-types';</span><span id="002c" class="mn lc iq mj b gy ms mp l mq mr">//...</span><span id="7ef2" class="mn lc iq mj b gy ms mp l mq mr">Item.propTypes = {<br/>  showDelete: PropTypes.bool,<br/>  handleDelete: requiredIf(PropTypes.func, props =&gt; props.showDelete === true)<br/>};</span></pre><p id="f02a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们确定当<code class="fe mt mu mv mj b">showDelete</code>是带有<code class="fe mt mu mv mj b">requiredIf</code>功能的<code class="fe mt mu mv mj b">true</code>时<code class="fe mt mu mv mj b">handleDelete</code>是一个功能。</p><h1 id="616c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">React 呈现的列表中有错误的组件</h1><p id="4725" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们正在呈现一个项目列表，我们应该为列表中的每个项目分配一个唯一的<code class="fe mt mu mv mj b">key</code>属性值。</p><p id="8f41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="184f" class="mn lc iq mj b gy mo mp l mq mr">&lt;div&gt;<br/>  &lt;div className="packages"&gt;<br/>    &lt;div key={0}&gt;<br/>      &lt;button&gt;X&lt;/button&gt;<br/>      &lt;Package name="a" /&gt;<br/>    &lt;/div&gt;<br/>    &lt;div key={1}&gt;<br/>      &lt;button&gt;X&lt;/button&gt;<br/>      &lt;Package name="b" /&gt;<br/>    &lt;/div&gt;<br/>    &lt;div key={2}&gt;<br/>      &lt;button&gt;X&lt;/button&gt;<br/>      &lt;Package name="c" /&gt;<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="0e29" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一个物品列表，并且我们为每个<code class="fe mt mu mv mj b">key</code>道具分配了一个唯一的值。</p><p id="e18e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，无论我们对它们做什么，它们都会被正确渲染。</p><p id="fdc3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们渲染一个项目，我们应该写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ab20" class="mn lc iq mj b gy mo mp l mq mr">consr packages = this.state.packages.map((package, i) =&gt; {<br/>  return (<br/>    &lt;div key={package}&gt;<br/>      &lt;button onClick={this.removePackage.bind(this, package)}&gt;X&lt;/button&gt;<br/>      &lt;Package name={package.name} /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>});</span></pre><p id="3ef6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们确保为<code class="fe mt mu mv mj b">key</code>属性传入一个唯一的值。</p><p id="873c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后当我们操作数组并重新渲染它时，一切都会被正确渲染。</p><p id="2f7b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不应该使用数组索引作为键，因为它们可以改变，并且可能不是唯一的。</p><h1 id="8cc7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">如何使用 React 创建具有多个页面的应用程序</h1><p id="dffa" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了让我们在 React 中创建一个具有多个页面的应用程序，我们必须使用 React Router 来进行路由。</p><p id="2e00" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通过运行以下命令来安装它:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e137" class="mn lc iq mj b gy mo mp l mq mr">npm install react-router-dom</span></pre><p id="1042" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3e2a" class="mn lc iq mj b gy mo mp l mq mr">import {<br/>  BrowserRouter as Router,<br/>  Switch,<br/>  Route,<br/>  Link<br/>} from "react-router-dom";</span><span id="4bb4" class="mn lc iq mj b gy ms mp l mq mr">const Home = () =&gt; {<br/>  return &lt;h2&gt;Home&lt;/h2&gt;;<br/>}</span><span id="9771" class="mn lc iq mj b gy ms mp l mq mr">const About = () =&gt; {<br/>  return &lt;h2&gt;About&lt;/h2&gt;;<br/>}</span><span id="36d9" class="mn lc iq mj b gy ms mp l mq mr">const Profile = () =&gt; {<br/>  return &lt;h2&gt;Profile&lt;/h2&gt;;<br/>}</span><span id="fed9" class="mn lc iq mj b gy ms mp l mq mr">export default function App() {<br/>  return (<br/>    &lt;Router&gt;<br/>      &lt;div&gt;<br/>        &lt;nav&gt;<br/>          &lt;ul&gt;<br/>            &lt;li&gt;<br/>              &lt;Link to="/"&gt;Home&lt;/Link&gt;<br/>            &lt;/li&gt;<br/>            &lt;li&gt;<br/>              &lt;Link to="/about"&gt;About&lt;/Link&gt;<br/>            &lt;/li&gt;<br/>            &lt;li&gt;<br/>              &lt;Link to="/profile"&gt;Profile&lt;/Link&gt;<br/>            &lt;/li&gt;<br/>          &lt;/ul&gt;<br/>        &lt;/nav&gt;</span><span id="e4a1" class="mn lc iq mj b gy ms mp l mq mr">        &lt;Switch&gt;<br/>          &lt;Route path="/about"&gt;<br/>            &lt;About /&gt;<br/>          &lt;/Route&gt;<br/>          &lt;Route path="/profile"&gt;<br/>            &lt;Profile /&gt;<br/>          &lt;/Route&gt;<br/>          &lt;Route path="/"&gt;<br/>            &lt;Home /&gt;<br/>          &lt;/Route&gt;<br/>        &lt;/Switch&gt;<br/>      &lt;/div&gt;<br/>    &lt;/Router&gt;<br/>  );<br/>}</span></pre><p id="0a44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建了 3 个功能组件，用作路线的内容。</p><p id="7616" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在<code class="fe mt mu mv mj b">App</code>组件中，我们导入<code class="fe mt mu mv mj b">Switch</code>组件并在其中添加路由。</p><p id="d5a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">Route</code>组件让我们创建路线。</p><p id="8786" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">path</code>是我们想要映射到组件的 URL 路径。</p><p id="8d3c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将想要显示的组件添加到<code class="fe mt mu mv mj b">Route</code>组件中。</p><p id="3349" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">Link</code>由 React 路由器提供，以便我们转到我们想去的 URL。</p><p id="56d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它还可以处理嵌套路线、自定义链接、默认路线、查询字符串和 URL 参数。</p><p id="bcf5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过编写以下内容来添加嵌套路由:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e94f" class="mn lc iq mj b gy mo mp l mq mr">loads the Topics component, which renders any further &lt;Route&gt;'s conditionally on the paths :id value.import React from "react";<br/>import {<br/>  BrowserRouter as Router,<br/>  Switch,<br/>  Route,<br/>  Link,<br/>  useRouteMatch,<br/>  useParams<br/>} from "react-router-dom";</span><span id="1c55" class="mn lc iq mj b gy ms mp l mq mr">export default function App() {<br/>  return (<br/>    &lt;Router&gt;<br/>      &lt;div&gt;<br/>        &lt;ul&gt;<br/>          &lt;li&gt;<br/>            &lt;Link to="/"&gt;Home&lt;/Link&gt;<br/>          &lt;/li&gt;<br/>          &lt;li&gt;<br/>            &lt;Link to="/about"&gt;About&lt;/Link&gt;<br/>          &lt;/li&gt;<br/>          &lt;li&gt;<br/>            &lt;Link to="/topics"&gt;Topics&lt;/Link&gt;<br/>          &lt;/li&gt;<br/>        &lt;/ul&gt;</span><span id="4c83" class="mn lc iq mj b gy ms mp l mq mr">        &lt;Switch&gt;<br/>          &lt;Route path="/topics"&gt;<br/>            &lt;Topics /&gt;<br/>          &lt;/Route&gt;<br/>        &lt;/Switch&gt;<br/>      &lt;/div&gt;<br/>    &lt;/Router&gt;<br/>  );<br/>}</span><span id="837a" class="mn lc iq mj b gy ms mp l mq mr">function Topics() {<br/>  let match = useRouteMatch();</span><span id="8754" class="mn lc iq mj b gy ms mp l mq mr">  return (<br/>    &lt;div&gt;<br/>      &lt;h2&gt;Topics&lt;/h2&gt;</span><span id="603e" class="mn lc iq mj b gy ms mp l mq mr">      &lt;ul&gt;<br/>        &lt;li&gt;<br/>          &lt;Link to='about'&gt;About&lt;/Link&gt;<br/>        &lt;/li&gt;<br/>      &lt;/ul&gt;</span><span id="5a6a" class="mn lc iq mj b gy ms mp l mq mr">     &lt;Switch&gt;<br/>        &lt;Route path='/about' &gt;<br/>          &lt;About /&gt;<br/>        &lt;/Route&gt;<br/>      &lt;/Switch&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span><span id="e4e9" class="mn lc iq mj b gy ms mp l mq mr">function About() {<br/>  return &lt;h2&gt;About&lt;/h2&gt;;<br/>}</span></pre><p id="89f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只是在组件中嵌套路由来嵌套它们。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/a71adb323607e07b7c48dca2c26a575f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*twnZoVWM0XoCVRtg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@teddyosterblom?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Teddy sterblom</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="d4e3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="7322" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们用 React Router 创建了一个包含多个页面的应用程序。</p><p id="81d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以有条件地用函数或第三方库来验证 props。</p><p id="b1f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该总是为每个列表项添加一个具有唯一值的<code class="fe mt mu mv mj b">key</code>道具。</p></div></div>    
</body>
</html>