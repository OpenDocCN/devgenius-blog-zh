<html>
<head>
<title>Debugging with Dashbird: AWS Lambda Process Exited Before Completing Request</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Dashbird进行调试:AWS Lambda进程在完成请求之前退出</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/debugging-with-dashbird-aws-lambda-process-exited-before-completing-request-56564c5cea11?source=collection_archive---------10-----------------------#2021-07-08">https://blog.devgenius.io/debugging-with-dashbird-aws-lambda-process-exited-before-completing-request-56564c5cea11?source=collection_archive---------10-----------------------#2021-07-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/af4b8b2e89eddbc982b103f6663bb113.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8uMrLQA4iT5i8V1cA794Eg.png"/></div></div></figure><div class=""/><p id="3b24" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">另一个常见错误消息</strong>来自我们最喜欢的FaaS供应商AWS Lambda。</p><p id="1422" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">同样，出现这个问题有多种原因。让我们先看看AWS Lambda 的<a class="ae kt" href="https://dashbird.io/knowledge-base/aws-lambda/introduction-to-aws-lambda/" rel="noopener ugc nofollow" target="_blank">基础，以便在以后出现问题时有更好的直觉。</a></p><h1 id="7e60" class="ku kv iy bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">AWS Lambda是异步的</h1><p id="a754" class="pw-post-body-paragraph jv jw iy jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">Lambda本质上是一个<strong class="jx iz">异步的基于事件的服务</strong>。Lambda服务异步调用您的函数——这并不意味着所有的事件都被异步处理，但是<strong class="jx iz">主要与您必须在函数中使用的编程模型</strong>有关。</p><p id="a44c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">这不应该与Lambda的事件处理</strong>混淆，后者可以是同步的，也可以是异步的。</p><p id="944c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">在同步事件处理</strong>中，例如，当您的函数处理一个<a class="ae kt" href="https://dashbird.io/knowledge-base/api-gateway/what-is-aws-api-gateway/" rel="noopener ugc nofollow" target="_blank"> API Gateway </a>事件时，事件提供程序会一直等待，直到您处理了该事件，以便它可以向自己的客户端提供您的结果。</p><p id="694f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">浏览器向API Gateway发送请求，API Gateway反过来将请求作为事件发送给Lambda函数。浏览器现在将等待响应，API Gateway将等待处理该事件。函数运行的时间越长，浏览器和API网关等待的时间就越长。<strong class="jx iz">直到最多30秒，API Gateway才会收工，并告诉浏览器您的功能超时</strong>。</p><p id="7613" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">在异步事件处理</strong>中，事件提供者只会把事件交给Lambda，然后就收工了。<strong class="jx iz">它不会等待你的Lambda函数的回答</strong>，不管是三秒还是十分钟。</p><p id="e112" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你从S3上传中触发了一个Lambda函数, S3服务将永远不会注意到Lambda函数在处理事件时是成功还是失败。它只会触发该功能，然后继续其他任务。</p><h1 id="feb4" class="ku kv iy bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">异步事件处理</h1><p id="d663" class="pw-post-body-paragraph jv jw iy jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">在Lambda函数中，你必须编写异步代码。你不能简单地接受一些参数，然后直接返回你的计算结果，就像下面的例子。</p><blockquote class="lx ly lz"><p id="d318" class="jv jw ma jx b jy jz ka kb kc kd ke kf mb kh ki kj mc kl km kn md kp kq kr ks ig bi translated">exports.handler = <strong class="jx iz"> ( </strong>事件，上下文<strong class="jx iz">)</strong>=<strong class="jx iz">&gt;</strong><strong class="jx iz">{<br/></strong>const result = event . data . x<strong class="jx iz">*</strong>event . data . x；<br/>T12】返回T14】{status code:200，body:result<strong class="jx iz">}</strong>；<br/><strong class="jx iz">})</strong>；</p></blockquote><p id="d4f4" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">你必须使用一些异步计算结构来处理结果。在AWS Lambda当前支持的Node.js运行时版本中，您必须使用承诺或异步函数来处理您的返回值。</strong></p><p id="3ff6" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一个有希望版本应该是这样的:</p><blockquote class="lx ly lz"><p id="05cd" class="jv jw ma jx b jy jz ka kb kc kd ke kf mb kh ki kj mc kl km kn md kp kq kr ks ig bi translated">exports . handler =<strong class="jx iz">(</strong>event，context<strong class="jx iz">)</strong>=<strong class="jx iz">&gt;</strong><strong class="jx iz">new</strong>Promise<strong class="jx iz">(</strong>resolve，reject<strong class="jx iz">)</strong>=<strong class="jx iz">&gt;</strong><strong class="jx iz">{<br/></strong>const result = event . data . x<strong class="jx iz">*</strong>event . data . x；<br/>解析<strong class="jx iz"> ({ </strong> statusCode: 200，body:result<strong class="jx iz">})</strong>；<br/><strong class="jx iz">})</strong>；</p></blockquote><p id="2840" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您的处理函数将直接返回一个新的promise对象，该对象将在将来被解析。如果一切顺利，您可以调用resolve，如果遇到错误，您可以调用reject。</p><p id="31ab" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">相应的异步函数如下所示:</p><blockquote class="lx ly lz"><p id="3c88" class="jv jw ma jx b jy jz ka kb kc kd ke kf mb kh ki kj mc kl km kn md kp kq kr ks ig bi translated">exports . handler = async<strong class="jx iz">(</strong>事件，上下文<strong class="jx iz">)</strong>=<strong class="jx iz">&gt;</strong><strong class="jx iz">{<br/></strong>const result = event . data . x<strong class="jx iz">*</strong>event . data . x；<br/> <strong class="jx iz">返回</strong> <strong class="jx iz"> { </strong> statusCode: 200，body:result<strong class="jx iz">}</strong>；<br/><strong class="jx iz">})</strong>；</p></blockquote><p id="18c0" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">异步函数是开头标有async的常规函数。这个关键字将整个函数包装在一个promise中，因此您不必手动完成。如果你回来了，承诺就解决了。如果你抛出一个错误，承诺将被拒绝。这样，<strong class="jx iz">你可以编写看起来同步但行为异步的代码</strong>。</p><p id="3bde" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用异步函数是编写Lambda处理程序的“事实上的”标准。</p><h1 id="dc9c" class="ku kv iy bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">传统方式</h1><p id="39b9" class="pw-post-body-paragraph jv jw iy jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">当Node.js版本11仍然受支持时，您必须使用上下文或回调进行返回。</p><p id="86f8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上下文版本如下所示:</p><blockquote class="lx ly lz"><p id="568e" class="jv jw ma jx b jy jz ka kb kc kd ke kf mb kh ki kj mc kl km kn md kp kq kr ks ig bi translated">exports.handler = <strong class="jx iz"> ( </strong>事件，上下文<strong class="jx iz">)</strong>=<strong class="jx iz">&gt;</strong><strong class="jx iz">{<br/></strong>const result = event . data . x<strong class="jx iz">*</strong>event . data . x；<br/> context.done <strong class="jx iz"> (null </strong>，<strong class="jx iz"> { </strong> statusCode: 200，body:result<strong class="jx iz">})</strong>；<br/><strong class="jx iz">})</strong>；</p></blockquote><p id="530e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里context.done的第一个参数是一个错误对象；如果不存在，我们可以使用null。</p><p id="472b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">回调版本看起来像这样:</p><blockquote class="lx ly lz"><p id="89bd" class="jv jw ma jx b jy jz ka kb kc kd ke kf mb kh ki kj mc kl km kn md kp kq kr ks ig bi translated">exports.handler = <strong class="jx iz"> ( </strong>事件，上下文，回调<strong class="jx iz">)</strong>=<strong class="jx iz">&gt;</strong><strong class="jx iz">{<br/></strong>const result = event . data . x<strong class="jx iz">*</strong>event . data . x；<br/>回调<strong class="jx iz"> ({ </strong> statusCode: 200，body:result<strong class="jx iz">})</strong>；<br/><strong class="jx iz">})</strong>；</p></blockquote><p id="2975" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如你所看到的，异步事件处理在<a class="ae kt" href="https://dashbird.io/blog/aws-lambda-nodejs-10-vs-14/" rel="noopener ugc nofollow" target="_blank">新的Node.js版本</a>中得到了简化，所以你只需要从一个异步函数返回，Node.js会处理剩下的事情。</p><h1 id="1ffe" class="ku kv iy bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">完成一个请求意味着什么？</h1><p id="9f3e" class="pw-post-body-paragraph jv jw iy jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">现在我们对AWS Lambda的工作原理有了基本的了解，让我们看看我们的错误。</p><p id="0120" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ma"> AWS Lambda流程在完成请求之前退出</em></p><p id="4a04" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的代码示例中，我们看到了当我们完成一个请求时的样子，所以您可能知道什么会导致错误发生。</p><p id="e385" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在使用<code class="fe me mf mg mh b">context.done</code>或<code class="fe me mf mg mh b">callback</code>、<strong class="jx iz">的遗留代码中，当您的代码没有到达其中一个调用</strong>时，就会发生这个错误。</p><p id="6b17" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在当前使用承诺或异步函数的版本中，<strong class="jx iz">如果承诺没有解决或者函数没有返回</strong>就会出现这个错误。</p><p id="93db" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以，你的函数代码完成了所有的工作，但是没有达到这四个结束状态中的一个。</p><p id="58bc" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果没有剩余代码要处理，异步函数会隐式返回，因此即使您不编写return语句，它仍然会“完成”,只是没有任何返回值。完成的其他三个版本要求你显式地调用某个东西，无论是<code class="fe me mf mg mh b">context.done</code>、<code class="fe me mf mg mh b">callback</code>还是<code class="fe me mf mg mh b">resolve</code>。</p><h1 id="463c" class="ku kv iy bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">是什么导致了这个错误？</h1><p id="14d3" class="pw-post-body-paragraph jv jw iy jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated"><strong class="jx iz">该错误主要与遗留行为</strong>有关。如今，除了这个错误，还会触发其他错误。所以，这个错误主要是一个“捕捉剩下的”类型的错误。</p><p id="b3ee" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在函数退出之前没有调用显式返回函数有多种原因，但是<strong class="jx iz">大多数都会导致超时或者超出内存限制</strong>类的错误。</p><p id="c7f9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您编写的代码落入其他错误未涉及的领域的可能性很大。如果您调用上游服务，比如DynamoDB，并且它们由于某种原因无声无息地失败了，这种情况就会发生。</p><h1 id="db3b" class="ku kv iy bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">这个错误怎么解决？</h1><p id="b78a" class="pw-post-body-paragraph jv jw iy jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">使用一个独立的Lambda函数没有多大意义——通常，您使用一个函数来连接其他具有某种转换和业务逻辑的服务。</p><p id="1703" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">在这里，你最好的做法是查看这些服务的</strong> <a class="ae kt" href="https://dashbird.io/blog/exploring-lambda-limitations/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx iz">限制</strong> </a>，以及你用AWS SDK调用它们的所有地方。如果您一次发送了太多的数据，或者在SDK调用中忘记了一些属性，事情可能会失败，并且没有任何明确的错误消息。</p><p id="0fb2" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你使用异步函数风格来表示你的函数已经完成，你就不能忘记在最后调用正确的函数了。</p></div></div>    
</body>
</html>