<html>
<head>
<title>Ain’t Got No Strings…</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">没有任何束缚…</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/aint-got-no-strings-344b30142904?source=collection_archive---------8-----------------------#2020-08-31">https://blog.devgenius.io/aint-got-no-strings-344b30142904?source=collection_archive---------8-----------------------#2020-08-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="a256" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">为什么应该使用枚举</h2><div class=""/><div class=""><h2 id="7f87" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">“魔法”字符串在 Swift 中并不那么神奇</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/b19b7c55a9ab97fde5e070cab533a21c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HwjVBkdjdU_Dx7tVbFleQw.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">不要让魔法线让你看起来很傻</figcaption></figure><p id="209a" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi ma translated">将字符串作为控制应用程序流程的一种方式，无论是你正在检查的一些条件、标识符还是许多其他东西，都不是一种很好的体验。尤其是当你的应用程序越来越大的时候。</p><p id="330d" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我知道我们都曾花时间思考过，“那个标识符叫什么来着？”…然后你回去找，等你找到它并复制它的时候，你已经忘了你最初需要它做什么了。你的思维过程暂时脱轨，因为你不得不停下来思考一些你从未真正需要停下来思考的事情！</p><p id="fe79" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">更糟糕的是，你确实记得它，却拼错了！呃……邻居走了。现在你的应用崩溃了，因为<code class="fe mk ml mm mn b">"PreformDetailSegue"</code>不是一个有效的标识符。</p><p id="b033" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这些类型的值就是我们所说的<code class="fe mk ml mm mn b"><strong class="lg ja"><em class="mj">Magic Values</em></strong></code> <strong class="lg ja"> <em class="mj"> </em> </strong>，因为如果你不熟悉代码库，它们可能会突然出现，并且它们可能会对你的应用程序的开发生命周期产生深远的影响。尽可能避免它们，但不一定要不惜一切代价。</p><p id="7c61" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在这个故事中，我们将探索一种简单的方法来避免魔术字符串。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mo"><img src="../Images/f6e1b3917376708711942050ef91440b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EVg2NB4fl-Fm9M6I.png"/></div></div></figure><p id="47ef" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">上述情况并不是世界末日。很多事情会让我们的思维过程脱轨，或者让我们不得不回头调试代码。这就是问题的关键。</p><p id="e178" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们能摆脱的这些事情越多，我们就越能专注于解决手头的问题，而不是记住那个序列标识符是什么。</p><p id="432e" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们已经有了“决策疲劳”(罗伊·f·鲍梅斯特研究的一个术语)，精神疲劳，大脑模糊，3 点钟的低迷，以及更多要担心的事情。所以，让我们来学习如何消除这些担忧——一点一滴都有帮助！</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mo"><img src="../Images/69ccf768c37f3af31af047c01d21ce6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rOAe-pWzqn9pm90o.png"/></div></div></figure><p id="5ab9" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">假设我们正在构建一个包含我们的 ID ( <code class="fe mk ml mm mn b">accountNumber</code> ) <code class="fe mk ml mm mn b">firstName</code>、<code class="fe mk ml mm mn b">lastName</code>、<code class="fe mk ml mm mn b">latitude</code>和<code class="fe mk ml mm mn b">longitude</code>的字典。因为字典键必须是可散列的，而字符串是可散列的…然而我们的值，在这种情况下，可以是字符串或双精度，我们将需要一个类型为<code class="fe mk ml mm mn b">[String: Any]</code>的字典。</p><p id="5ae9" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们可以使用普通的字符串作为关键字来构建这个字典，但是这样一来，我们就容易出现输入错误和零值。相反，我们可以快速构建一两个枚举，并使用这些值来代替字符串。这样，我们避免了由打字错误引起的错误(你不会避免打字错误，但至少你会保持一致，并有一个更容易的时间重构！)</p><h2 id="d732" class="mq mr iq bd ms mt mu dn mv mw mx dp my ln mz na nb lr nc nd ne lv nf ng nh iw bi translated">首先，在 Swift 中构建[String: Any]字典的传统方式:</h2><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/2f651dcbe70d2b348b7bc83714d150d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*gQjRe6Rkf64OfXrTXearSg.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">你发现拼写错误了吗？</figcaption></figure><p id="2cf0" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我在上面的字典中犯了一个拼写错误。如果你没有发现它，这是纬度键或<code class="fe mk ml mm mn b">latitiude</code>键。我故意犯这个错误是为了强调一点，但是在开发这个简单的例子时，实际上犯了一个让我头疼了一分钟的错误，迫使我回去检查我的字符串。</p><p id="5cde" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">如果稍后，我们试图从<code class="fe mk ml mm mn b">CurrentLocation</code>字典中取出<code class="fe mk ml mm mn b">latitude</code>键，我们将得到一个零错误。如果我们正确处理它，我们会有意想不到的行为。否则，我们的应用程序将会崩溃。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nj"><img src="../Images/89bddb67951fc007d0facc607dbef848.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t-c0jtH0WT0RuDRFdpj0Dw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">如您所见，我们的“纬度”值为零，因为我们将其拼写为“latitiude”</figcaption></figure><p id="9694" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">让我们完全用枚举键和我们的用户值来构建它。这样，除了编译器错误，我们不可能有任何错误。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nk"><img src="../Images/f062ce4c49a58b7cc5a33ffb3b3164a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bDRu8dJZeogDhLdXbKF-Cw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">没有出错的余地！(编译器错误除外)</figcaption></figure><h1 id="785a" class="nl mr iq bd ms nm nn no mv np nq nr my kf ns kg nb ki nt kj ne kl nu km nh nv bi translated">让我们组织起来</h1><p id="edea" class="pw-post-body-paragraph le lf iq lg b lh nw ka lj lk nx kd lm ln ny lp lq lr nz lt lu lv oa lx ly lz ij bi translated">我喜欢为常见用例创建较小的枚举，而不是一个包含所有标识符的大型枚举。随着你的应用程序变得越来越大，你会越来越喜欢这个策略。</p><h2 id="f029" class="mq mr iq bd ms mt mu dn mv mw mx dp my ln mz na nb lr nc nd ne lv nf ng nh iw bi translated">让我们从第一个枚举 NameKey 开始。</h2><p id="6301" class="pw-post-body-paragraph le lf iq lg b lh nw ka lj lk nx kd lm ln ny lp lq lr nz lt lu lv oa lx ly lz ij bi translated">在其中，我们将存储我们的帐号、名字和姓氏。仔细想想，这可以更恰当地命名为 UserIdentifierKey。可能看起来很奇怪，我对 enum 使用了单数形式，因为它包含 key <strong class="lg ja"> s </strong>而不是单个键，但是我遵循了标准的 Swift 命名约定。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/967085d0a503a55036ea482267a63a75.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/1*ySYXCfnXz-8m7K4jaYLr5A.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">这看起来比绳子更好，不是吗？</figcaption></figure><p id="1288" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">关键字<code class="fe mk ml mm mn b">enum</code>将它标识为一个枚举，就像<code class="fe mk ml mm mn b">class</code>标识一个类一样。然后是名字，就像识别一个类一样(<code class="fe mk ml mm mn b">class SomeViewController: UIViewController</code>)。接下来的部分有点不一样。通常我们称之为类型，但是对于枚举，我们称之为原始值。</p><p id="c7e4" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">原始值为我们的枚举案例提供了一个关联的类型。通常当我们声明一个带有原始值的枚举时，我们必须给每种情况一个相关的原始值。但是，带有 String 类型的 rawValue 的枚举带有一个与事例名称相关联的自由值。所以上面，<code class="fe mk ml mm mn b">accountNumber</code>的 rawValue 等于“accountNumber”。如果我们希望它与不同的值相关联，我们可以很容易地做到这一点…但让我们保持简单，继续我们的位置枚举。</p><h2 id="dc27" class="mq mr iq bd ms mt mu dn mv mw mx dp my ln mz na nb lr nc nd ne lv nf ng nh iw bi translated">LocationKey 枚举</h2><p id="d25d" class="pw-post-body-paragraph le lf iq lg b lh nw ka lj lk nx kd lm ln ny lp lq lr nz lt lu lv oa lx ly lz ij bi translated">当我第一次开始使用 enums 时，这部分让我感到困惑。假设我们正在构建一个这样的字典，我会将原始值与字典中的键所代表的值混淆。没那么复杂…我们正在构建一个 enum，只有  <em class="mj"> </em>表示我们的字符串键，所以它也有一个 String 的 rawValue。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/7494b8c4bdf02313d8f39b33ae1f1574.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*Xee8S3rX9v3mlHM1hykd8Q.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">enums 帮助我们保持有序！</figcaption></figure><p id="e8a6" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">现在我们有了一个存放字典中所有字符串值的地方。让我们建立我们的字典。为了得到字符串，我们需要访问每个案例的原始值。如果您忘记了<code class="fe mk ml mm mn b">.rawValue</code>，并且您明确地将您的字典键入为<code class="fe mk ml mm mn b">[String: Any]</code>，编译器将会中断您一天的工作，并显示一个错误，告诉您它无法将您的类型<code class="fe mk ml mm mn b">LocationKey</code>转换为预期的类型:<code class="fe mk ml mm mn b">String</code>。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi od"><img src="../Images/efb9da92fac18a71d31474217e4d1f14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*Y-vjA0Zfmv6iEDO9HGK6tw.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">LocationKey 类型不是字符串，但它的 rawValue 是！</figcaption></figure><p id="0a36" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">你要做的是使用<code class="fe mk ml mm mn b">LocationKey.currentLocation.rawValue</code>。这将访问案例的<code class="fe mk ml mm mn b">rawValue</code>并将我们的<code class="fe mk ml mm mn b">String</code>值放在我们想要的位置——我们从未键入单精度(或双精度🤓)引号。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mo"><img src="../Images/f6e1b3917376708711942050ef91440b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EVg2NB4fl-Fm9M6I.png"/></div></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/7bd14655b79ac11db644c6772a92b3f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*OBIwDmHas2nJxDH3ktrQ4Q.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">看起来干净多了！</figcaption></figure><p id="6654" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">你可以用。大写后。rawValue 如果你想要一个大写首字母，或者打破命名惯例，用一个大写首字母来命名你的 case。在这个例子中，currentLocation 是小写的，尽管在我们的字符串例子中它是大写的。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mo"><img src="../Images/f6e1b3917376708711942050ef91440b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EVg2NB4fl-Fm9M6I.png"/></div></div></figure><p id="1653" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">现在，以后当我们想要取出一个值时，我们只需使用我们的枚举作为字典的键，我们几乎可以保证得到一个值！</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ca"><img src="../Images/d6b31b5511109840eacb3d0e14e61724.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h4T3Pl2cHkkt7hRW5-S7Rw.png"/></div></div></figure><h2 id="5be0" class="mq mr iq bd ms mt mu dn mv mw mx dp my ln mz na nb lr nc nd ne lv nf ng nh iw bi translated">最后</h2><p id="1de4" class="pw-post-body-paragraph le lf iq lg b lh nw ka lj lk nx kd lm ln ny lp lq lr nz lt lu lv oa lx ly lz ij bi translated">当你已经做了这么多工作的时候，设置这些枚举看起来似乎太多了，而且它确实让一个简单的任务变得不那么简单了。但是它防止了后续的错误，而后续的错误才是真正问题的开始。</p><p id="a3b6" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">例如，当您开发了这个代码库之后，已经开发了几个代码库，现在是时候回去添加一个特性了，祝您好运记住所有这些字符串值！至少如果你不记得了，或者没有恰当地给你的枚举命名，你可以回去看看，以便快速参考。当然，你可以用你当时创建的字典做同样的事情，但是我们大多数人都把我们的自定义类型放在文件中的特定位置，这样它们更容易被找到。</p><p id="825b" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">避免神奇的字符串，尽可能避免神奇的数字。为你的代码库和未来的你工作的其他开发人员会感谢你的。枚举是避免这两者的好方法！</p></div></div>    
</body>
</html>