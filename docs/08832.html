<html>
<head>
<title>Web Application Performance Optimization — HTTP Caching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Web 应用程序性能优化— HTTP 缓存</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/web-application-performance-optimization-http-caching-791eeda4509e?source=collection_archive---------5-----------------------#2022-07-13">https://blog.devgenius.io/web-application-performance-optimization-http-caching-791eeda4509e?source=collection_archive---------5-----------------------#2022-07-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c81b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">HTTP 缓存的最佳实践是什么？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/77dd46438c2cedeb87efa7c027bbcf78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*So5-s-egg3_AMBjm"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@redaquamedia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">丹尼·米勒</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="8b53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文将介绍 web 应用程序性能优化的一个非常重要的部分——HTTP 缓存。</p><p id="d7dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了 HTTP 缓存，我们甚至可以在不建立网络连接的情况下加快资源获取的速度。这不仅提高了应用程序的响应速度，还减轻了服务器的压力。</p><p id="9d20" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">HTTP 缓存可以分为两类，一类是强缓存，另一类是协商缓存。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="4cbc" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">强大的缓存</h1><p id="3d1e" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">如果有有效的强缓存，那么浏览器不会发送真正的请求，而是直接读取本地缓存。在 Chrome 中，本地存储位置可能是磁盘缓存或内存缓存。同时，HTTP 状态代码是 200。</p><p id="d1fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有三个响应头可用于设置强缓存，即 Expires、Cache-Control 和 Pragma。</p><h2 id="d36d" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">期满</h2><p id="9406" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">它是在 HTTP/1.0 中添加的。它的值被设置为日期。当再次发出相同的请求时，浏览器会将系统时间与 Expires 值进行比较。如果超过，缓存将失效，请求将重新启动。否则，将使用缓存。</p><p id="783e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是系统时间有很大的不确定性，会导致缓存时间不准确。</p><h2 id="c09e" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">缓存控制</h2><p id="8ba8" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">它是在 HTTP/1.1 中添加的。它的值更复杂，可以设置多个指令值:</p><ul class=""><li id="e950" class="ni nj iq ky b kz la lc ld lf nk lj nl ln nm lr nn no np nq bi translated"><code class="fe nr ns nt nu b">max-age</code>:<code class="fe nr ns nt nu b">max-age=N</code>表示响应产生后<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#freshness" rel="noopener ugc nofollow" target="_blank">到<em class="nv"> N </em>秒前</a>保持新鲜。</li><li id="bf54" class="ni nj iq ky b kz nw lc nx lf ny lj nz ln oa lr nn no np nq bi translated"><code class="fe nr ns nt nu b">s-maxage</code>:它还指示响应在多长时间内<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#freshness" rel="noopener ugc nofollow" target="_blank">保持</a>新鲜(类似于<code class="fe nr ns nt nu b">max-age</code>)——但它是特定于共享缓存的，当<code class="fe nr ns nt nu b">max-age</code>出现时，它们会忽略它。</li><li id="aff5" class="ni nj iq ky b kz nw lc nx lf ny lj nz ln oa lr nn no np nq bi translated"><code class="fe nr ns nt nu b">no-cache</code>:表示响应可以存储在缓存中，但每次重用前必须经过原服务器验证。并不是说“不缓存”。</li><li id="54a3" class="ni nj iq ky b kz nw lc nx lf ny lj nz ln oa lr nn no np nq bi translated"><code class="fe nr ns nt nu b">no-store</code>:这意味着任何类型的缓存(私有的或共享的)都不应该存储这个响应。</li><li id="657d" class="ni nj iq ky b kz nw lc nx lf ny lj nz ln oa lr nn no np nq bi translated"><code class="fe nr ns nt nu b">immutable</code>:表示响应在<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#freshness" rel="noopener ugc nofollow" target="_blank">新鲜</a>时不会更新。</li><li id="53f1" class="ni nj iq ky b kz nw lc nx lf ny lj nz ln oa lr nn no np nq bi translated"><code class="fe nr ns nt nu b">public</code>:表示响应可以存储在共享缓存中，如中间代理、CDN 等。</li><li id="b8eb" class="ni nj iq ky b kz nw lc nx lf ny lj nz ln oa lr nn no np nq bi translated"><code class="fe nr ns nt nu b">private</code>:表示响应只能存储在私有缓存中(例如浏览器中的本地缓存)。</li></ul><p id="d727" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了这些，还有<code class="fe nr ns nt nu b">must-revalidate</code>、<code class="fe nr ns nt nu b">proxy-revalidate</code>、<code class="fe nr ns nt nu b">must-understand</code>、<code class="fe nr ns nt nu b">no-transform</code>等指令。关于他们的更多信息，你可以查看一下。</p><h2 id="8be1" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">杂注</h2><p id="8fb6" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">它用于在没有 Cache-Control HTTP/1.1 头的情况下向后兼容 HTTP/1.0 缓存。它的语法只能是<code class="fe nr ns nt nu b">Pragma: no-cache</code>。和<code class="fe nr ns nt nu b">Cache-Control: no-cache</code>有异曲同工之妙。</p><p id="e4c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当两者都存在时，<code class="fe nr ns nt nu b">Cache-Control</code>优先于<code class="fe nr ns nt nu b">Expires</code>使用。和<code class="fe nr ns nt nu b">Pragma</code>应该仅用于向后兼容。</p><h1 id="725f" class="lz ma iq bd mb mc ob me mf mg oc mi mj jw od jx ml jz oe ka mn kc of kd mp mq bi translated">协商缓存</h1><p id="8632" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">如果强缓存未使用或已过期，将尝试协商缓存。协商的缓存将发送真正的请求，但只携带一些信息到服务器进行验证。如果它仍然有效，将直接使用本地缓存。同时，HTTP 状态代码是 304，没有任何主体。</p><p id="f93d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">设置协商缓存可以使用 Last-Modified 和 ETag 响应头。</p><h2 id="1a3a" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">上次修改/如果修改-自</h2><p id="d453" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">它是在 HTTP/1.0 中添加的。<code class="fe nr ns nt nu b">Last-Modified</code>设置在响应头中，<code class="fe nr ns nt nu b">If-Modified-Since</code>设置在请求头中。它们的值表示响应内容的最后修改时间，精确到秒。</p><p id="fca8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用方法:当发出第一个请求时，服务器会将<code class="fe nr ns nt nu b">Last-Modified</code>添加到响应头中。浏览器再次启动时，会将<code class="fe nr ns nt nu b">Last-Modified</code>的值作为<code class="fe nr ns nt nu b">If-Modified-Since</code>的值，与服务器协商是否有变化，如有变化则重新下载。</p><p id="41d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是不够精确。例如，当文件的修改时间小于一秒时，<code class="fe nr ns nt nu b">Last-Modified</code>的值不变，这也导致浏览器使用过期的缓存。或者，如果修改后的文件内容与原文件一致，浏览器会丢弃缓存，重新下载。</p><h2 id="88e3" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">ETag/如果不匹配</h2><p id="7eef" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">它是在 HTTP/1.1 中添加的。类似于<code class="fe nr ns nt nu b">Last-Modified/If-Modified-Since</code> , <code class="fe nr ns nt nu b">ETag/If-None-Match</code>分别是响应头和请求头。它们的值代表该响应内容的标识符，类似于文件指纹。拥有唯一的内容标识符解决了我上面提到的<code class="fe nr ns nt nu b">Last-Modified/If-Modified-Since</code>缺陷。所以浏览器会更喜欢用<code class="fe nr ns nt nu b">ETag/If-None-Match</code>。</p><p id="73bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，<code class="fe nr ns nt nu b">ETag/If-None-Match</code>还支持强验证器和弱验证器来满足不同的情况，可以通过<code class="fe nr ns nt nu b">'W/'</code>来设置，详见<a class="ae kv" href="https://developer.%20mozilla.org/en-US/docs/Web/HTTP/Headers/ETag#directives" rel="noopener ugc nofollow" target="_blank"> MDN </a>。</p><h1 id="e1a8" class="lz ma iq bd mb mc ob me mf mg oc mi mj jw od jx ml jz oe ka mn kc of kd mp mq bi translated">结论</h1><p id="349c" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">当面临强缓存或协商缓存时，浏览器客户端更喜欢使用“较新”版本的 HTTP 响应/请求头。例如，优先使用<code class="fe nr ns nt nu b">ETag/If-None-Match</code>而不是<code class="fe nr ns nt nu b">Last-Modified/If-Modified-Since</code>。</p><p id="819d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在实践中，根据不同的响应类型选择不同的缓存类型。例如，不常改变的资源倾向于使用强缓存。如果您的 web 应用程序是<a class="ae kv" href="https://en.wikipedia.org/wiki/Single-page_application" rel="noopener ugc nofollow" target="_blank"> SPA </a>，那么根条目的 HTML 通常被设置为协商缓存，而那些 JS 和 CSS 文件通常被设置为具有足够大的时间值的强缓存。这是因为那些 JS 和 CSS 文件名的后缀通常由打包工具(例如 Webpack)添加到文件哈希中，并且每次更新时，根条目 HTML 将指向最新的 JS 和 CSS 文件。</p><p id="a5ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">网络条件不可靠，所以 HTTP 缓存可以大大提高应用程序性能，尤其是当响应内容很大时。那么你在使用 HTTP 缓存吗？欢迎和我分享你的想法！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="e042" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nv">感谢阅读。如果你喜欢这样的故事，想支持我，请考虑成为</em> <a class="ae kv" href="https://medium.com/@islizeqiang/membership" rel="noopener"> <em class="nv">中等会员</em> </a> <em class="nv">。每月 5 美元，你可以无限制地访问媒体内容。如果你通过</em> <a class="ae kv" href="https://medium.com/@islizeqiang/membership" rel="noopener"> <em class="nv">我的链接</em> </a> <em class="nv">报名，我会得到一点佣金。</em></p><p id="849e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你的支持对我来说非常重要——谢谢。</p></div></div>    
</body>
</html>