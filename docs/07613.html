<html>
<head>
<title>Hoisting in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Javascript 中提升</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/hoisting-in-javascript-c90f6d03d2df?source=collection_archive---------8-----------------------#2022-04-10">https://blog.devgenius.io/hoisting-in-javascript-c90f6d03d2df?source=collection_archive---------8-----------------------#2022-04-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/5abaac7efcf45c2478222b513a837f93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0QyovjXxG-PVvbyEk0JyKA.jpeg"/></div></div></figure><p id="fd45" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在声明变量和函数之前访问它们的机制称为提升。</p><p id="7ec9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">考虑下面这段代码:</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="a817" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是，JavaScript 只提升声明，不提升初始化。这意味着变量的初始化会一直进行到相关的代码行被执行，即使变量最初被初始化然后被声明，或者声明和初始化在同一行。</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="0335" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为什么会这样？为什么我们能够访问变量，甚至在变量声明之前初始化它们？奇怪的 Javascript，对吧？实际上，这就是 Javascript 中<strong class="jx io">执行上下文</strong>的工作方式。在 Javascript 的<strong class="jx io">代码执行阶段</strong>发生之前，在 Javascript 的<strong class="jx io">内存分配阶段</strong>期间，Javascript 引擎浏览代码并用<code class="fe kz la lb lc b">undefined</code>初始化<code class="fe kz la lb lc b">var</code>的所有变量声明。你可以在这里阅读更多关于<strong class="jx io">执行上下文</strong>和 Javascript 如何工作的信息<a class="ae ld" href="https://rabisiddique.medium.com/how-javascript-runs-in-the-browser-part-1-7a2b3ce7f5e5" rel="noopener">。</a></p><h2 id="9dbd" class="le lf in bd lg lh li dn lj lk ll dp lm kg ln lo lp kk lq lr ls ko lt lu lv lw bi translated">是否悬挂 let 和 const 声明？</h2><p id="834f" class="pw-post-body-paragraph jv jw in jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">问题的答案是肯定的！<code class="fe kz la lb lc b">let</code>和<code class="fe kz la lb lc b">const</code>声明挂在 Javascript 中。但是，在初始化之前，我们无法访问这些声明。试图在初始化之前访问这样的声明会导致 Javascript 抛出一个<code class="fe kz la lb lc b">ReferenceError</code></p><p id="798d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">考虑下面这段代码:</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="8217" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上述代码片段将导致以下错误:</p><p id="56a9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kz la lb lc b">ReferenceError: Cannot access ‘name’ before initialization</code></p><p id="bc62" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该错误信息意味着<code class="fe kz la lb lc b">name</code>变量已经存在于内存中。如前所述的<code class="fe kz la lb lc b">let</code>和<code class="fe kz la lb lc b">const</code>由 Javascript 引擎提升，但与<code class="fe kz la lb lc b">var</code>声明不同，它们没有使用<code class="fe kz la lb lc b">undefined.</code> <code class="fe kz la lb lc b">let</code>进行初始化，并且<code class="fe kz la lb lc b">const</code>遵循<strong class="jx io">时间死区</strong>的原则。由于时间死区的原理，试图在声明之前访问<code class="fe kz la lb lc b">let</code>和<code class="fe kz la lb lc b">const</code>总是会给<code class="fe kz la lb lc b">ReferenceError</code>。</p><blockquote class="mc md me"><p id="8d99" class="jv jw mf jx b jy jz ka kb kc kd ke kf mg kh ki kj mh kl km kn mi kp kq kr ks ig bi translated">一个<strong class="jx io">时间死区(TDZ) </strong>是一个变量在计算机用一个值完全初始化之前不可访问的块区域。</p></blockquote><p id="3b7e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">简而言之，临时死区是在代码执行阶段，从<code class="fe kz la lb lc b">let</code>和<code class="fe kz la lb lc b">const</code>声明被提升到这些声明被初始化为某个值的时间。当<code class="fe kz la lb lc b">let </code>和<code class="fe kz la lb lc b">const</code>声明已经在代码中初始化/赋值时，时间死区结束。</p><p id="869c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意，如果你访问一个不存在的变量，JavaScript 抛出一个不同的<code class="fe kz la lb lc b">ReferenceError</code>:</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="880c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于<code class="fe kz la lb lc b">lastname</code>不存在，Javascript 抛出:</p><p id="e75d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kz la lb lc b">ReferenceError: lastname is not defined</code></p><p id="8dea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">到目前为止，我们已经在代码片段示例中使用了<code class="fe kz la lb lc b">let</code>。如果我们使用了<code class="fe kz la lb lc b">const</code>，会出现什么情况？嗯，使用<code class="fe kz la lb lc b">const</code>而不是<code class="fe kz la lb lc b">let</code>会显示相同的行为。<code class="fe kz la lb lc b">let</code>和<code class="fe kz la lb lc b">const</code>声明之间唯一的关键区别在于初始化。与<code class="fe kz la lb lc b">let</code>声明不同，<code class="fe kz la lb lc b">const declarations</code>必须在声明时初始化，否则 Javascript 会抛出一个<code class="fe kz la lb lc b">SyntaxError</code>。</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="5307" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们用<code class="fe kz la lb lc b">let</code>声明了<code class="fe kz la lb lc b">name</code>，上面的代码片段显示了完全相同的行为，即抛出:</p><p id="bcdb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kz la lb lc b">ReferenceError: Cannot access 'name' before initialization</code></p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="376d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然而，不像上面的代码片段那样初始化<code class="fe kz la lb lc b">const</code>声明会导致:</p><p id="46dc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kz la lb lc b">SyntaxError: Missing initializer in const declaration</code></p><p id="d3ae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此外，与<code class="fe kz la lb lc b">var</code>声明不同的是，<code class="fe kz la lb lc b">const</code>和<code class="fe kz la lb lc b">let</code>声明没有附加到全局<code class="fe kz la lb lc b">window</code>对象上。<code class="fe kz la lb lc b">const</code>和<code class="fe kz la lb lc b">let</code>声明出现在一个单独的空格中。因此，我们不能使用全局<code class="fe kz la lb lc b">window</code>对象访问这些声明。</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="333d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的代码片段中，如果我们试图使用<code class="fe kz la lb lc b">window</code>对象打印<code class="fe kz la lb lc b">middleName</code>和<code class="fe kz la lb lc b">lastName</code>的<code class="fe kz la lb lc b">let</code>和<code class="fe kz la lb lc b">const</code>声明的值，那么<code class="fe kz la lb lc b">undefined</code>将被打印在控制台上。当试图在没有<code class="fe kz la lb lc b">window </code>对象的情况下访问它们时，将打印这些声明的实际值。</p><h2 id="6473" class="le lf in bd lg lh li dn lj lk ll dp lm kg ln lo lp kk lq lr ls ko lt lu lv lw bi translated">函数声明和函数表达式的提升</h2><p id="1d79" class="pw-post-body-paragraph jv jw in jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">就像变量一样，函数声明也在 Javascript 中被挂起。<br/>此处详细解释了<a class="ae ld" href="https://rabisiddique.medium.com/function-buzzwords-in-javascript-af24c3488a75" rel="noopener">中函数声明和函数表达式的区别。</a></p><p id="fc86" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在执行上下文的内存分配阶段，函数声明被放在内存堆中。因此，我们能够在函数声明之前调用它。</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="1012" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">考虑到上面的代码片段，调用函数声明，在声明之前先调用<code class="fe kz la lb lc b">sayMyName</code>，总是可行的。</p><p id="169c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那么，函数表达式呢？不，它们在 Javascript 中没有被提升。</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="8bd9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当上面的代码片段执行时，它将导致:</p><p id="36a0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kz la lb lc b">TypeError: sayMyName is not a function</code></p><p id="bee4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是因为，在执行上下文的内存分配阶段，变量<code class="fe kz la lb lc b">sayMyName</code>存储在内存中，并用值<code class="fe kz la lb lc b">undefined</code>初始化</p><p id="9e66" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">只有在代码执行阶段，控制台上打印的匿名函数<code class="fe kz la lb lc b">Heisenberg</code>才被分配给变量<code class="fe kz la lb lc b">sayMyName</code></p><p id="1b24" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，函数表达式在 Javascript 中不会被提升。这同样适用于箭头函数，它会抛出同样的错误。因为箭头函数只是定义函数表达式的语法糖。</p><h2 id="d788" class="le lf in bd lg lh li dn lj lk ll dp lm kg ln lo lp kk lq lr ls ko lt lu lv lw bi translated">优先顺序</h2><p id="e460" class="pw-post-body-paragraph jv jw in jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">如果一个变量和函数有相同的名字，并且变量被初始化，那么变量赋值优先于函数声明。</p><blockquote class="mc md me"><p id="979a" class="jv jw mf jx b jy jz ka kb kc kd ke kf mg kh ki kj mh kl km kn mi kp kq kr ks ig bi translated"><strong class="jx io"> <em class="in">变量赋值超过函数声明</em> </strong></p></blockquote><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="47d6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">而如果变量没有初始化，那么函数声明优先于变量声明。</p><blockquote class="mc md me"><p id="c23b" class="jv jw mf jx b jy jz ka kb kc kd ke kf mg kh ki kj mh kl km kn mi kp kq kr ks ig bi translated"><strong class="jx io"> <em class="in">函数声明超过变量声明</em> </strong></p></blockquote><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="7e34" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">非常感谢你花时间阅读这篇博客。</p><p id="6f8b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们连接:</p><ul class=""><li id="3d43" class="mj mk in jx b jy jz kc kd kg ml kk mm ko mn ks mo mp mq mr bi translated"><a class="ae ld" href="https://www.linkedin.com/in/rabi-siddique-b6b4971a0/" rel="noopener ugc nofollow" target="_blank">领英</a></li><li id="7341" class="mj mk in jx b jy ms kc mt kg mu kk mv ko mw ks mo mp mq mr bi translated"><a class="ae ld" href="https://twitter.com/rabisiddique234" rel="noopener ugc nofollow" target="_blank">推特</a></li></ul></div></div>    
</body>
</html>