<html>
<head>
<title>Protobuf Best Practices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Protobuf最佳实践</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/protobuf-best-practices-f20e6940b9c5?source=collection_archive---------1-----------------------#2021-07-01">https://blog.devgenius.io/protobuf-best-practices-f20e6940b9c5?source=collection_archive---------1-----------------------#2021-07-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="bc53" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">proto3的约定</p><p id="0dff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你使用protobuf作为序列化器。Protobuf更喜欢结构化数据，具有更严格的向后兼容性，并且在网络传输方面非常高效。Protobuf和gRPC是一个强大的组合，下面是一组推荐的最佳实践</p><p id="3774" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Protobuf有3种主要类型的组件:服务、消息和枚举。原型文件可以有任意数量的这样的组件</p><h1 id="dfd5" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">服务</h1><p id="f167" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">顾名思义，它用于定义资源封装API。<br/>首选协议:grpc</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="5c1d" class="lu kj in lq b gy lv lw l lx ly">service UserService {<br/>    rpc getUser(GetUserRequest) returns (GetUserResponse);<br/>    rpc creatUser(CreatUserRequest) returns (CreatUserResponse) {}<br/>}</span></pre><ul class=""><li id="c8a5" class="lz ma in jm b jn jo jr js jv mb jz mc kd md kh me mf mg mh bi translated">为每个域实体创建一个服务。</li><li id="6f6d" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated">结尾为；或{}，两者都有效。传统上优选；</li><li id="476f" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated">DTO消息名称应为<api>请求和<api>响应，分别为请求、响应消息。</api></api></li></ul><p id="d304" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意:<a class="ae mn" href="https://docs.buf.build/style-guide/" rel="noopener ugc nofollow" target="_blank">风格指南</a>命名约定</p><h1 id="fa82" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">消息</h1><p id="e8f7" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">这是一个传统的物体造型空间。消息包含3个重要方面，属性名、数据类型和唯一字段号。</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="03e8" class="lu kj in lq b gy lv lw l lx ly">message SearchRequest {<br/>    <em class="mo">repeated</em> string params = 1;<br/>    int32 page_number = 2;<br/>    int32 result_per_page = 3;<br/>    reserved 14, 15;<br/>}</span></pre><ul class=""><li id="c279" class="lz ma in jm b jn jo jr js jv mb jz mc kd md kh me mf mg mh bi translated">我们可以嵌套“消息”</li></ul><h2 id="a3ad" class="lu kj in bd kk mp mq dn ko mr ms dp ks jv mt mu kw jz mv mw la kd mx my le mz bi translated">现场会议</h2><ul class=""><li id="93a9" class="lz ma in jm b jn lg jr lh jv na jz nb kd nc kh me mf mg mh bi translated">属性名首选snake_case</li></ul><p id="b8d5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果发布的源协议带有额外的字段，并且客户端使用的是旧版本的契约，比版本3.5更新的序列化程序会忽略这些字段；类似于`<em class="mo">JsonIgnoreProperties(ignoreUnknown = true)`</em></p><h2 id="5c76" class="lu kj in bd kk mp mq dn ko mr ms dp ks jv mt mu kw jz mv mw la kd mx my le mz bi translated">选择什么数据类型？</h2><p id="8c75" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">数据类型可以是原始数据类型或自定义数据类型(其他消息/枚举)。</p><p id="c927" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae mn" href="https://developers.google.com/protocol-buffers/docs/proto3#scalar" rel="noopener ugc nofollow" target="_blank">不同语言的原型数据类型映射</a></p><ul class=""><li id="36c0" class="lz ma in jm b jn jo jr js jv mb jz mc kd md kh me mf mg mh bi translated">检查你的选择，明智地选择。例如int32对int64</li><li id="559b" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated">`重复'关键字用于定义有序集合</li><li id="1615" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated">原始数据类型有默认值，即字符串-"，布尔值-false，<em class="mo">数字</em> -0</li><li id="7018" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated">避免将没有模式的开放字段建模为字符串/映射，例如json、xml</li><li id="7bfa" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated">` Any '是一种特殊的数据类型。这就像嵌入了任何未知的“信息”。<br/> &gt; &gt;这是一个占位符，实际上可以包含任何“消息”<br/> &gt; &gt;只有当域不理解内容时才使用“任何”,便于存储。例如，元字段<br/>&gt;&gt;“<a class="ae mn" href="https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/any.proto" rel="noopener ugc nofollow" target="_blank">Any</a>”字段具有动态嵌入的消息原型的值和schemaTypeUrl。<br/> &gt; &gt;因此，在将它反序列化为本机实体时，建议在这种情况下同时拥有值和模式属性</li></ul><h1 id="976f" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">如何给一个属性编号？</h1><ul class=""><li id="1209" class="lz ma in jm b jn lg jr lh jv na jz nb kd nc kh me mf mg mh bi translated">字段编号是一个重要的补充。为了向后兼容，建议<strong class="jm io">不要更改客户正在使用的</strong>号。</li><li id="c121" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated">另一个需要注意的重要事情是，字段编号1到15编码为1个字节，然后16到2047编码为2个字节(更多关于<a class="ae mn" href="https://developers.google.com/protocol-buffers/docs/encoding#structure" rel="noopener ugc nofollow" target="_blank"> protobuf编码</a>)。因此，为了优化性能:</li><li id="8a57" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated">对于<strong class="jm io">所有强制的、更频繁的字段，使用字段编号1到15 </strong>，以优化消息有效载荷的大小</li><li id="4da1" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated">为将来的扩展保留几个空槽。要阻止这样的缓冲区，使用保留的关键字<br/>例如，在上面的请求中，数字14，15</li><li id="1b38" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated">对最不常用的属性使用16位以上的数字</li></ul><h1 id="3f91" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">列举型别</h1><p id="05ee" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">顾名思义，这只是另一个用于配置枚举值的传统白名单块。“枚举”也可以是任何“消息”的一部分</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="2ae4" class="lu kj in lq b gy lv lw l lx ly">enum OrderStatus {<br/>    ORDER_STATUS_UNSPECIFIED = 0;<br/>    ORDER_STATUS_CREATED = 1;<br/>    ORDER_STATUS_PAID = 2;<br/>    ORDER_STATUS_DISPATCHED = 3;<br/>}</span></pre><ul class=""><li id="3280" class="lz ma in jm b jn jo jr js jv mb jz mc kd md kh me mf mg mh bi translated">值的首选大写字母</li><li id="44ae" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated">按照惯例，以未指定的值0开始，以允许<null/></li><li id="ce5a" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated">编译器生成一个带有一个额外值的枚举，该值对于Java这样的严格枚举语言来说是不可识别的。</li><li id="abc4" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated">因此，在处理请求之前，请确保验证该值不是不可识别的。</li></ul><h1 id="ebbc" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">不常用的功能</h1><h1 id="6071" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">之一</h1><p id="da2e" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">有多少次您不想添加自定义验证，而客户端应该发送externalId或clientReferenceId。现在你可以用一个。</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="cc49" class="lu kj in lq b gy lv lw l lx ly">oneof id {<br/>    external_id = 2;<br/>    client_reference_id = 6;<br/>}</span></pre><p id="d309" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，即使客户端同时提供了这两个属性，也只有oneof的最后一个属性被反序列化</p><h1 id="05af" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">地图</h1><p id="3f7b" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">这只是传统的地图，有一个警告，它不能“重复”</p><h1 id="c5b3" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">参考</h1><div class="nd ne gp gr nf ng"><a href="https://developers.google.com/protocol-buffers/docs/proto3" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd io gy z fp nl fr fs nm fu fw im bi translated">语言指南(proto3) |协议缓冲区| Google开发者</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">本指南描述了如何使用协议缓冲区语言来构建您的协议缓冲区数据，包括。原型…</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">developers.google.com</p></div></div><div class="np l"><div class="nq l nr ns nt np nu nv ng"/></div></div></a></div><div class="nd ne gp gr nf ng"><a href="https://docs.buf.build/style-guide/" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd io gy z fp nl fr fs nm fu fw im bi translated">风格指南| Buf</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">这是我们的Protobuf风格指南。本文档有意做到简明扼要，旨在作为…的简短参考</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">doc . buf . build</p></div></div><div class="np l"><div class="nw l nr ns nt np nu nv ng"/></div></div></a></div></div></div>    
</body>
</html>