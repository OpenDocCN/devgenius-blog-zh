<html>
<head>
<title>SQL Practice questions — #5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL 练习题— #5</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/sql-practice-questions-5-456cfb41757a?source=collection_archive---------16-----------------------#2022-08-15">https://blog.devgenius.io/sql-practice-questions-5-456cfb41757a?source=collection_archive---------16-----------------------#2022-08-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="b269" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">SQL 练习题的第五部分</p><p id="fa2a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">点击此处查看<a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/sql-practice-questions-1-800ed65d99b2">第一部分</a> <a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/sql-practice-questions-2-f1116b1f5402">第二部分</a> <a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/sql-practice-questions-3-9fd3d6e56058">第三部分</a> <a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/sql-practice-questions-4-e24a6bdb32d4">第四部分</a></p><p id="8d2b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">问题 1</p><p id="ffa2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">编写一个 SQL 查询来报告电影院中所有连续的可用座位。按升序返回由<code class="fe kj kk kl km b">seat_id</code> <strong class="jm io">排序</strong>的结果表<strong class="jm io">。测试用例的生成使得两个以上的座位连续可用。</strong></p><p id="1aff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">例如:</strong></p><pre class="kn ko kp kq gt kr km ks kt aw ku bi"><span id="f37c" class="kv kw in km b gy kx ky l kz la"><strong class="km io">Input:</strong> <br/>Cinema table:<br/>+---------+------+<br/>| seat_id | free |<br/>+---------+------+<br/>| 1       | 1    |<br/>| 2       | 0    |<br/>| 3       | 1    |<br/>| 4       | 1    |<br/>| 5       | 1    |<br/>+---------+------+<br/><strong class="km io">Output:</strong> <br/>+---------+<br/>| seat_id |<br/>+---------+<br/>| 3       |<br/>| 4       |<br/>| 5       |<br/>+---------+</span></pre><p id="2840" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">方法:</strong>我们需要检查两行是否是连续的并且都是空闲的，我们可以通过使用</p><pre class="kn ko kp kq gt kr km ks kt aw ku bi"><span id="cedc" class="kv kw in km b gy kx ky l kz la">SELECT DISTINCT a.seat_id<br/>FROM cinema a INNER JOIN cinema b<br/>ON abs(a.seat_id - b.seat_id) = 1<br/>  AND a.free = 1 and b.free = 1<br/>ORDER BY a.seat_id</span></pre><h1 id="f956" class="lb kw in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">问题 2</h1><p id="225b" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">编写一个 SQL 查询来查找应该从 Leetflex 中禁止的帐户的<code class="fe kj kk kl km b">user_id</code>。一个帐户应该被禁止，如果它在某个时刻从两个不同的 IP 地址登录。返回<strong class="jm io">任意顺序</strong>中的结果表。</p><p id="385b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">例 1: </strong></p><pre class="kn ko kp kq gt kr km ks kt aw ku bi"><span id="f4d6" class="kv kw in km b gy kx ky l kz la"><strong class="km io">Input:</strong> <br/>LogInfo table:<br/>+---------+------------+---------------------+---------------------+<br/>| user_id | ip_address | login               | logout              |<br/>+---------+------------+---------------------+---------------------+<br/>| 1       | 1          | 2021-02-01 09:00:00 | 2021-02-01 09:30:00 |<br/>| 1       | 2          | 2021-02-01 08:00:00 | 2021-02-01 11:30:00 |<br/>| 2       | 6          | 2021-02-01 20:30:00 | 2021-02-01 22:00:00 |<br/>| 2       | 7          | 2021-02-02 20:30:00 | 2021-02-02 22:00:00 |<br/>| 3       | 9          | 2021-02-01 16:00:00 | 2021-02-01 16:59:59 |<br/>| 3       | 13         | 2021-02-01 17:00:00 | 2021-02-01 17:59:59 |<br/>| 4       | 10         | 2021-02-01 16:00:00 | 2021-02-01 17:00:00 |<br/>| 4       | 11         | 2021-02-01 17:00:00 | 2021-02-01 17:59:59 |<br/>+---------+------------+---------------------+---------------------+<br/><strong class="km io">Output:</strong> <br/>+------------+<br/>| user_id |<br/>+------------+<br/>| 1          |<br/>| 4          |<br/>+------------+</span></pre><p id="0e09" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">方法:</strong>我们需要为相同的 user_id 找到两行，它们在登录和注销时间上重叠。我们通过在相同的 user_id 和不同的 IP 上使用 self join 来实现，然后检查它们的登录和注销时间之间的重叠。</p><pre class="kn ko kp kq gt kr km ks kt aw ku bi"><span id="5d62" class="kv kw in km b gy kx ky l kz la">SELECT distinct l1.user_id<br/>FROM LogInfo l1<br/>INNER JOIN LogInfo l2<br/>ON l1.user_id = l2.user_id and l1.ip_address != l2.ip_address<br/>WHERE (l2.login &lt;= l1.logout and l2.login &gt;= l1.login) OR <br/>    (l2.logout &lt;= l1.logout and l2.logout &gt;= l1.login)</span></pre><h1 id="73cd" class="lb kw in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">问题 3</h1><p id="782b" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">编写一个 SQL 查询来报告所有<strong class="jm io">经理</strong>的 id 和姓名、直接向他们报告<strong class="jm io">的员工数量</strong>，以及四舍五入为最接近整数的报告的平均年龄。返回由<code class="fe kj kk kl km b">employee_id</code>排序的结果表。</p><p id="cb03" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">例 1: </strong></p><pre class="kn ko kp kq gt kr km ks kt aw ku bi"><span id="cd8a" class="kv kw in km b gy kx ky l kz la"><strong class="km io">Input:</strong> <br/>Employees table:<br/>+-------------+---------+------------+-----+<br/>| employee_id | name    | reports_to | age |<br/>+-------------+---------+------------+-----+<br/>| 9           | Hercy   | null       | 43  |<br/>| 6           | Alice   | 9          | 41  |<br/>| 4           | Bob     | 9          | 36  |<br/>| 2           | Winston | null       | 37  |<br/>+-------------+---------+------------+-----+<br/><strong class="km io">Output:</strong> <br/>+-------------+-------+---------------+-------------+<br/>| employee_id | name  | reports_count | average_age |<br/>+-------------+-------+---------------+-------------+<br/>| 9           | Hercy | 2             | 39          |<br/>+-------------+-------+---------------+-------------+</span></pre><p id="3f13" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">方法:</strong>我们需要对 reports_to 执行 Grroup by，然后执行 self join 来查找员工的 nmae。</p><pre class="kn ko kp kq gt kr km ks kt aw ku bi"><span id="5d60" class="kv kw in km b gy kx ky l kz la">SELECT e1.employee_id, e1.name, <br/>    count(e1.employee_id) as reports_count, <br/>    round(avg(e2.age)) as average_age<br/>FROM employees e1 INNER JOIN employees e2<br/>ON e1.employee_id = e2.reports_to<br/>GROUP BY e1.employee_id<br/>ORDER BY e1.employee_id</span></pre><h1 id="b927" class="lb kw in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">问题 4</h1><p id="bc28" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">编写一个 SQL 查询来查找至少连续出现三次的所有数字。返回<strong class="jm io">任意顺序</strong>中的结果表。</p><p id="e047" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">例 1: </strong></p><pre class="kn ko kp kq gt kr km ks kt aw ku bi"><span id="082c" class="kv kw in km b gy kx ky l kz la"><strong class="km io">Input:</strong> <br/>Logs table:<br/>+----+-----+<br/>| id | num |<br/>+----+-----+<br/>| 1  | 1   |<br/>| 2  | 1   |<br/>| 3  | 1   |<br/>| 4  | 2   |<br/>| 5  | 1   |<br/>| 6  | 2   |<br/>| 7  | 2   |<br/>+----+-----+<br/><strong class="km io">Output:</strong> <br/>+-----------------+<br/>| ConsecutiveNums |<br/>+-----------------+<br/>| 1               |<br/>+-----------------+</span></pre><p id="1c07" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">方法:</strong>这个问题要求连续三次，所以如果检查 prev、cur 和 next 是否相等，我们就能找到解决方法。我们可以使用<code class="fe kj kk kl km b">LEAD &amp; LAG</code>函数来实现同样的功能。</p><pre class="kn ko kp kq gt kr km ks kt aw ku bi"><span id="8d28" class="kv kw in km b gy kx ky l kz la">WITH cte as (<br/>    SELECT num, <br/>        LEAD(num, 1) OVER() AS next_num, <br/>        LAG(num) OVER (ORDER BY id) AS prev_num<br/>    FROM `Logs`<br/>)<br/>SELECT DISTINCT num as ConsecutiveNums <br/>FROM cte WHERE num=next_num and num=prev_num;</span></pre></div></div>    
</body>
</html>