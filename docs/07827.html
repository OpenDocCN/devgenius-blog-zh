<html>
<head>
<title>Learning go — Boost your journey (part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习 go —加速您的旅程(第 1 部分)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/learning-go-in-2022-boost-your-journey-6edc606ed030?source=collection_archive---------2-----------------------#2022-04-26">https://blog.devgenius.io/learning-go-in-2022-boost-your-journey-6edc606ed030?source=collection_archive---------2-----------------------#2022-04-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="4c43" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我成为 Node.js 开发人员已经有 5 年了，但是在我的开发生涯中，我一直热衷于学习新事物和新技术。我不会在这里解释为什么学习围棋，因为我认为有很多文章已经做得很好了。相反，我会努力帮助你踏上这一旅程，让你的生活变得更轻松:)</p><p id="369e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每次我试图<strong class="jm io">学习一门新的编程语言</strong>，事实上，我问自己的问题总是相同的:<strong class="jm io">我可以从哪里开始获得提升？</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8f66f037e5d493646164042637bf98c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0sHw45SwHyIIHq8reHEG3Q.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://github.com/MariaLetta/free-gophers-pack" rel="noopener ugc nofollow" target="_blank">https://github.com/MariaLetta/free-gophers-pack</a></figcaption></figure><h1 id="1694" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">开始—先从基础做起</h1><p id="fcf0" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">首先，我需要<strong class="jm io">学习一些语法</strong>，以便能够开始读写一些 Go 代码。谷歌了一下，我找到了我要找的东西:<a class="ae ky" href="https://gobyexample.com/" rel="noopener ugc nofollow" target="_blank">举例</a>。这个网站真的很简单，但是它有你需要的一切让你快速开始。以下是我的一些建议，可以帮助你快速入门:</p><ul class=""><li id="9ec9" class="mc md in jm b jn jo jr js jv me jz mf kd mg kh mh mi mj mk bi translated">使用<code class="fe ml mm mn mo b">var</code>声明<strong class="jm io">变量</strong>，使用<code class="fe ml mm mn mo b">const</code>声明<strong class="jm io">常量</strong>。你总是可以用快捷键<code class="fe ml mm mn mo b">a := 42</code>将声明为一个变量<strong class="jm io">并同时给</strong>赋值</li><li id="a96f" class="mc md in jm b jn mp jr mq jv mr jz ms kd mt kh mh mi mj mk bi translated">Go 支持<code class="fe ml mm mn mo b">for</code>作为<strong class="jm io">唯一的循环构造</strong>，但是它非常灵活和强大。它实际上支持以下符号:<br/>–经典:<code class="fe ml mm mn mo b">for i := 0; i &lt; 3; i++ { ... }</code><br/>–单一条件:<code class="fe ml mm mn mo b">for i &lt; 3 { ... i += 1 }<br/></code>–无条件(无限循环):<code class="fe ml mm mn mo b">for { ... }</code> <br/>在单一条件的情况下，你必须记住递增计数器。</li><li id="0288" class="mc md in jm b jn mp jr mq jv mr jz ms kd mt kh mh mi mj mk bi translated"><code class="fe ml mm mn mo b">range</code>构造可以用于<strong class="jm io">迭代数据结构</strong>。例如，给定一个数组<code class="fe ml mm mn mo b">nums</code>，我们可以做类似<code class="fe ml mm mn mo b">for index, num := range nums { ... }</code>的事情。范围运算符对于迭代地图也很有帮助。例如，给定一个地图<code class="fe ml mm mn mo b">myMap</code>，我们可以这样做:<code class="fe ml mm mn mo b">for key, value := range myMap { ... }</code></li><li id="1886" class="mc md in jm b jn mp jr mq jv mr jz ms kd mt kh mh mi mj mk bi translated"><strong class="jm io">三进制</strong>不支持<strong class="jm io"/>，但是我们仍然可以利用经典的<code class="fe ml mm mn mo b">if ... else</code></li><li id="0736" class="mc md in jm b jn mp jr mq jv mr jz ms kd mt kh mh mi mj mk bi translated">围棋中主要的<a class="ae ky" href="https://go.dev/tour/basics/11" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"/></a>原语类型有:<code class="fe ml mm mn mo b">bool</code>、<code class="fe ml mm mn mo b">string</code>、<code class="fe ml mm mn mo b">int</code>、&amp;、<code class="fe ml mm mn mo b">uint</code> (16 - 32 - 64)、<code class="fe ml mm mn mo b">float</code> (32 - 64)、<code class="fe ml mm mn mo b">complex</code> (64 -128)</li><li id="a5d9" class="mc md in jm b jn mp jr mq jv mr jz ms kd mt kh mh mi mj mk bi translated">当一些东西没有在 Go 中初始化时，它被赋予零值(例如，int，float-&gt; 0，string -&gt; " "，bool -&gt; false</li><li id="3c7c" class="mc md in jm b jn mp jr mq jv mr jz ms kd mt kh mh mi mj mk bi translated">正如所料，Go 支持将<strong class="jm io">数组</strong>(例如<code class="fe ml mm mn mo b">var a [5]int</code>)作为具有<strong class="jm io">特定长度</strong>的编号元素序列。<br/>当处理可能需要扩展或收缩的数据集合时，可以使用<a class="ae ky" href="https://gobyexample.com/slices" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">切片</strong> </a>。为了创建切片，您可以简单地做:<code class="fe ml mm mn mo b">s := make([]string, 3)</code></li><li id="583b" class="mc md in jm b jn mp jr mq jv mr jz ms kd mt kh mh mi mj mk bi translated">如果你需要一个<strong class="jm io">映射</strong>，你可以简单地做<code class="fe ml mm mn mo b">m := make(map[key] value)</code>，这里 key 是键类型，value 是你的值类型</li><li id="e5f2" class="mc md in jm b jn mp jr mq jv mr jz ms kd mt kh mh mi mj mk bi translated">Go 支持<a class="ae ky" href="https://gobyexample.com/closures" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">一级函数</strong> </a>，为此你可以创建匿名函数，从函数中返回一个函数，传递一个函数作为回调函数等等…</li></ul><h1 id="1a84" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结构体</h1><p id="06ec" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">现在，从一个 typescript 上下文中，我开始思考，<strong class="jm io">我怎样才能创建一个类</strong>来使我的代码更加结构化？</p><p id="e1ce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Go 不是面向对象的语言(更多细节见这里的<a class="ae ky" href="https://go.dev/doc/faq#Is_Go_an_object-oriented_language" rel="noopener ugc nofollow" target="_blank">和这个<strong class="jm io">没有类</strong>，但是你可以利用<strong class="jm io">结构</strong>。在 Go 中，struct 是一个<strong class="jm io">类型化的字段集合。</strong></a></p><p id="68b9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看看如何在 Go 中用一个简单的 getArea 方法创建一个矩形:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Go 结构示例</figcaption></figure><p id="8c92" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的例子中，我们有:</p><ol class=""><li id="883c" class="mc md in jm b jn jo jr js jv me jz mf kd mg kh mw mi mj mk bi translated"><code class="fe ml mm mn mo b">Rectangle</code>是一种新型</li><li id="1b00" class="mc md in jm b jn mp jr mq jv mr jz ms kd mt kh mw mi mj mk bi translated"><code class="fe ml mm mn mo b">getArea</code>是将<code class="fe ml mm mn mo b">Rectangle</code>设置为<strong class="jm io">接收器</strong>的功能。从现在开始，每一个<code class="fe ml mm mn mo b">Rectangle</code>都可以在自身上调用<code class="fe ml mm mn mo b">getArea</code>方法。<br/>对于来自 python 或 javascript 等其他语言的人来说，接收者<code class="fe ml mm mn mo b">r</code>可以被视为与<code class="fe ml mm mn mo b">self</code>或<code class="fe ml mm mn mo b">this</code>关键字相同。</li></ol><h1 id="b462" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">接口</h1><p id="c3fd" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">现在，<strong class="jm io">界面呢？</strong> Go 支持接口，为了实现一个接口，没有<strong class="jm io">实现关键字</strong>可以使用。谁想实现它就够了，<strong class="jm io">简单定义了所有需要的方法。</strong></p><p id="9d12" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看看如何创建一个简单的几何图形界面，以及如何“实现”它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Go 接口示例</figcaption></figure><p id="e61a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">既然我们已经有了基本的概念，并且知道如何使我们的代码更加结构化，让我们跳到语言的一些重要概念:</p><ol class=""><li id="6eca" class="mc md in jm b jn jo jr js jv me jz mf kd mg kh mw mi mj mk bi translated">Defer 关键字</li><li id="cd11" class="mc md in jm b jn mp jr mq jv mr jz ms kd mt kh mw mi mj mk bi translated">两颗北极指极星</li><li id="f4d5" class="mc md in jm b jn mp jr mq jv mr jz ms kd mt kh mw mi mj mk bi translated">错误与恐慌</li><li id="2965" class="mc md in jm b jn mp jr mq jv mr jz ms kd mt kh mw mi mj mk bi translated">基本 JSON 处理</li></ol><h1 id="6ebc" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">Defer 关键字</h1><p id="6181" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated"><code class="fe ml mm mn mo b">defer</code>关键字是<strong class="jm io">通常</strong>用于<strong class="jm io">清理目的。</strong>一般来说，defer 语句<strong class="jm io">推迟函数的执行，直到周围的函数返回。</strong>立即计算延迟调用的参数，但是直到周围的函数返回，才执行函数调用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">延期关键字示例</figcaption></figure><h1 id="7c04" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">两颗北极指极星</h1><p id="6887" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">Go 支持指针，允许你在程序中传递对你的值的引用。指针是一个广泛的话题，应该单独写一篇文章，但是为了开始，我尝试了一些我认为重要的事情。</p><p id="60fb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">指针<strong class="jm io">保存一个值的存储地址。</strong>其 Go 中的零值为<code class="fe ml mm mn mo b">nil</code></p><p id="bc4c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">语法非常简单:</p><ol class=""><li id="cb80" class="mc md in jm b jn jo jr js jv me jz mf kd mg kh mw mi mj mk bi translated">使用<code class="fe ml mm mn mo b">*</code>取消对指针值的引用</li><li id="2c21" class="mc md in jm b jn mp jr mq jv mr jz ms kd mt kh mw mi mj mk bi translated">使用<code class="fe ml mm mn mo b">&amp;</code>获取特定变量的地址</li></ol><p id="2c40" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看一个基本的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="56f4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，让我们澄清一个常见的误解。<strong class="jm io">支持指针不代表 Go 支持通过引用传递参数。</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx mv l"/></div></figure><p id="be5d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">事实上，在 Go 中一切都是通过值传递的，没有所谓的通过引用传递。这意味着，每次我们传递一个参数给一个函数，这个参数就会被复制。你只能控制你是否想要<strong class="jm io">传递一个值的副本</strong> <strong class="jm io">或者</strong> <strong class="jm io">一个值的引用的副本。</strong></p><p id="7e26" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一般来说，在 Go 中，每个函数参数都是通过值来传递的，通过改变函数体中的参数值，原始值不会受到影响。此规则的唯一例外是<strong class="jm io">切片</strong>和<strong class="jm io">贴图</strong>。它们仍然通过值传递，但是因为它们是<strong class="jm io">引用类型</strong>，任何改变都会改变底层变量。</p><p id="6286" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">什么时候使用指针，什么时候不使用似乎是围棋界的热门话题，为此我建议你看看这个。</p><h1 id="e171" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">错误与恐慌</h1><p id="745b" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">在 go by example 中我们了解到，在 go 中，通过一个<strong class="jm io">显式的、单独的返回值来传达错误是惯用的。</strong>按照惯例，<strong class="jm io">错误是最后一个返回值</strong>，有<strong class="jm io">类型错误</strong>，内置接口。</p><p id="7df1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如:<code class="fe ml mm mn mo b">return -1, errors.New("Something went wrong")</code></p><p id="1e78" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">错误位置的<code class="fe ml mm mn mo b">nil</code>值表示<strong class="jm io">没有错误。</strong></p><p id="837b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">也可以通过在定制类型上实现 Error()方法，将定制类型用作 Error。</p><p id="0a92" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么，什么时候应该用恐慌来代替呢？<code class="fe ml mm mn mo b">panic</code>通常指事情发生了<strong class="jm io">意想不到的错误</strong>。大多数情况下，它用于快速失败在正常操作期间不应该发生的错误。例如:<code class="fe ml mm mn mo b">panic("Something really bad happened")</code></p><p id="2fe6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">总的来说，</strong>从我的理解来说，你应该<strong class="jm io">总是</strong> <strong class="jm io">尽可能喜欢错误。</strong></p><h1 id="cc4c" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">JSON 处理</h1><p id="dec3" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">迟早我们都要处理一些 JSON。来自 Node.js 环境的我习惯了经典的<code class="fe ml mm mn mo b">JSON.stringify</code>和<code class="fe ml mm mn mo b">JSON.parse</code>方法。Go 还为 JSON 编码和解码提供了<strong class="jm io">内置支持，包括使用<code class="fe ml mm mn mo b">encoding/json</code>包与内置和自定义数据类型之间的相互转换。让我们深入一个例子，因为它值得百万字:</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="1432" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有一些重要的事情要记住:</p><ol class=""><li id="8db8" class="mc md in jm b jn jo jr js jv me jz mf kd mg kh mw mi mj mk bi translated">编码/解码时，<strong class="jm io">仅考虑大写字段</strong>，因此它们被称为<strong class="jm io">导出字段。</strong>在响应结构中写入<code class="fe ml mm mn mo b">Message</code>或<code class="fe ml mm mn mo b">message</code>则完全不同，因为在编码/解码中不会考虑最新的一个。</li><li id="35d5" class="mc md in jm b jn mp jr mq jv mr jz ms kd mt kh mw mi mj mk bi translated">当<strong class="jm io">编码</strong>时，如果你使用了<strong class="jm io">自定义标签</strong>(参见上面代码中的注释)，Go 将在编码到 JSON 时使用那些标签。</li><li id="96c5" class="mc md in jm b jn mp jr mq jv mr jz ms kd mt kh mw mi mj mk bi translated">当<strong class="jm io">解码时，</strong>如果使用了<strong class="jm io">自定义标签，</strong> Go 将在 JSON 中搜索那些用于解码的标签。</li></ol><p id="7491" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请记住，也可以将 JSON 编码直接流式传输到 HTTP 响应体:)</p><h1 id="7846" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="d6e9" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">这仅仅是旅程的开始，显然还有很多内容要讲。Go 的设计考虑到了并发性，因此我的<strong class="jm io">下一步探索</strong>将集中在<strong class="jm io"> Go 例程</strong>和<strong class="jm io">通道上。</strong>如果你渴望阅读它，你可以在这里找到它<a class="ae ky" href="https://medium.com/@alessandropetraro/learning-go-in-2022-boost-your-journey-part-2-2c23c401c7b5" rel="noopener"/>:)</p><p id="ba26" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你喜欢这篇文章，并且想让我知道，请给我一些掌声👏如果您不想错过我的下一篇文章，请关注我；)</p><p id="28e6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下次探索再见:)</p></div></div>    
</body>
</html>