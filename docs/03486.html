<html>
<head>
<title>Best of Modern JavaScript — Proxy and Object</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代JavaScript的精华——代理和对象</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/best-of-modern-javascript-proxy-and-object-c42e037492c3?source=collection_archive---------3-----------------------#2020-11-10">https://blog.devgenius.io/best-of-modern-javascript-proxy-and-object-c42e037492c3?source=collection_archive---------3-----------------------#2020-11-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/beae8b75803e96275258c4bbf4da994f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HsWLse12ZZw3G6Tj"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@webaliser?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">ярославалексеенко</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="4624" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自2015年以来，JavaScript有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究使用JavaScript代理的元编程。</p><h1 id="71d6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">可撤销的代理</h1><p id="beb6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用ES6创建可撤销的代理。</p><p id="7ffb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们调用带有<code class="fe me mf mg mh b">target</code>和<code class="fe me mf mg mh b">handler</code>参数的<code class="fe me mf mg mh b">Proxy.revocable</code>方法。</p><p id="6f65" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="be6a" class="mq lc iq mh b gy mr ms l mt mu">const target = {};<br/>const handler = {<br/>  get(target, propKey, receiver) {<br/>    return 'foo';<br/>  },</span><span id="c224" class="mq lc iq mh b gy mv ms l mt mu">  has(target, propKey) {<br/>    return true;<br/>  }<br/>};<br/>const {<br/>  proxy,<br/>  revoke<br/>} = Proxy.revocable(target, handler);</span></pre><p id="0ee3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Proxy.revocable</code>函数接受我们想要改变其行为的<code class="fe me mf mg mh b">target</code>对象。</p><p id="d1c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">handler</code>是一个对象，它有各种方法让我们控制<code class="fe me mf mg mh b">target</code>的行为。</p><p id="7aea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它返回一个带有<code class="fe me mf mg mh b">proxy</code>对象和<code class="fe me mf mg mh b">revoke</code>函数的对象来撤销代理。</p><p id="4574" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以调用<code class="fe me mf mg mh b">revoke</code>停止使用代理。</p><p id="92a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9fa7" class="mq lc iq mh b gy mr ms l mt mu">const target = {};<br/>const handler = {<br/>  get(target, propKey, receiver) {<br/>    return target[propKey];<br/>  },</span><span id="b86a" class="mq lc iq mh b gy mv ms l mt mu">has(target, propKey) {<br/>    return true;<br/>  }<br/>};<br/>const {<br/>  proxy,<br/>  revoke<br/>} = Proxy.revocable(target, handler);</span><span id="8bb4" class="mq lc iq mh b gy mv ms l mt mu">proxy.foo = 'bar';<br/>console.log(proxy.foo);</span><span id="c0c4" class="mq lc iq mh b gy mv ms l mt mu">revoke();</span><span id="5071" class="mq lc iq mh b gy mv ms l mt mu">console.log(proxy.foo);</span></pre><p id="5e89" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后第二个控制台日志会给我们一个错误，因为代理已经用<code class="fe me mf mg mh b">revoke</code>函数撤销了。</p><p id="ab7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们得到“未捕获的类型错误:无法在已撤销的代理上执行“get”。</p><h1 id="3af0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">作为原型的代理</h1><p id="b476" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用代理作为对象的原型。</p><p id="8e5b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="70c0" class="mq lc iq mh b gy mr ms l mt mu">const target = {};<br/>const handler = {<br/>  get(target, propKey, receiver) {<br/>    return target[propKey];<br/>  },</span><span id="8bea" class="mq lc iq mh b gy mv ms l mt mu">  has(target, propKey) {<br/>    return true;<br/>  }<br/>};<br/>const proto = new Proxy(target, handler);<br/>const obj = Object.create(proto);</span></pre><p id="be41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe me mf mg mh b">Object.create</code>方法创建一个代理对象并将其作为原型。</p><h1 id="a17b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">转发截获的操作</h1><p id="bf2a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用代理转发截获的操作。</p><p id="08b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7f89" class="mq lc iq mh b gy mr ms l mt mu">const target = {};<br/>const handler = {<br/>  deleteProperty(target, propKey) {<br/>    return delete target[propKey];<br/>  },<br/>  has(target, propKey) {<br/>    return propKey in target;<br/>  },<br/>}</span><span id="26d6" class="mq lc iq mh b gy mv ms l mt mu">const proto = new Proxy(target, handler);</span></pre><p id="4b9c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">增加前进<code class="fe me mf mg mh b">delete</code>操作和<code class="fe me mf mg mh b">in</code>操作。</p><p id="ec49" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只是在没有代理的情况下在<code class="fe me mf mg mh b">handler</code>方法中做同样的事情。</p><h1 id="cde2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">包裹物体会影响<code class="fe me mf mg mh b">this</code></h1><p id="bbf6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">由于<code class="fe me mf mg mh b">handler</code>是一个对象，它有自己的值<code class="fe me mf mg mh b">this</code>。</p><p id="42db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="213f" class="mq lc iq mh b gy mr ms l mt mu">const target = {<br/>  foo() {<br/>    console.log(this === target)<br/>    console.log(this === proxy)<br/>  }<br/>};<br/>const handler = {};<br/>const proxy = new Proxy(target, handler);</span><span id="7bfb" class="mq lc iq mh b gy mv ms l mt mu">proxy.foo()</span></pre><p id="1b6e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后第一个控制台日志是<code class="fe me mf mg mh b">false</code>，第二个是<code class="fe me mf mg mh b">true</code>，因为我们在<code class="fe me mf mg mh b">proxy</code>上调用了<code class="fe me mf mg mh b">foo</code>。</p><p id="fde4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="484f" class="mq lc iq mh b gy mr ms l mt mu">const target = {<br/>  foo() {<br/>    console.log(this === target)<br/>    console.log(this === proxy)<br/>  }<br/>};<br/>const handler = {};<br/>const proxy = new Proxy(target, handler);</span><span id="7909" class="mq lc iq mh b gy mv ms l mt mu">target.foo()</span></pre><p id="3689" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么第一个控制台日志是<code class="fe me mf mg mh b">true</code>，第二个是<code class="fe me mf mg mh b">false</code>。</p><h1 id="3a1c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">无法透明包装的对象</h1><p id="ead2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果一个对象有一些私有数据，那么代理就不能透明地包装这个对象。</p><p id="319f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="15aa" class="mq lc iq mh b gy mr ms l mt mu">const _name = new WeakMap();<br/>class Animal {<br/>  constructor(name) {<br/>    _name.set(this, name);<br/>  }<br/>  get name() {<br/>    return _name.get(this);<br/>  }<br/>}</span></pre><p id="1682" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d303" class="mq lc iq mh b gy mr ms l mt mu">const mary = new Animal('mary');<br/>const proxy = new Proxy(mary, {});<br/>console.log(proxy.name);</span></pre><p id="627c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到了<code class="fe me mf mg mh b">undefined</code>中的<code class="fe me mf mg mh b">name</code>属性。</p><p id="7417" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为<code class="fe me mf mg mh b">name</code>存储在WeakMap中，而不是作为<code class="fe me mf mg mh b">this</code>本身的直接属性。</p><p id="519c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">this</code>是代理，所以它没有<code class="fe me mf mg mh b">name</code>属性。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/d06219541898386ed35a15ef02c910d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PBBinXzQR3aAJ6vO"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@silverkakan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Karin Hiselius </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="3477" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="4df8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">代理是可撤销的，代理和原始对象之间的<code class="fe me mf mg mh b">this</code>值是不同的。</p></div></div>    
</body>
</html>