<html>
<head>
<title>Build Your Own PHP Framework Step By Step — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">逐步构建自己的 PHP 框架——第 1 部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/build-your-own-php-framework-step-by-step-part-1-f59e0a39e54b?source=collection_archive---------5-----------------------#2022-11-30">https://blog.devgenius.io/build-your-own-php-framework-step-by-step-part-1-f59e0a39e54b?source=collection_archive---------5-----------------------#2022-11-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/24eab317351ffaee0216e97ea109e585.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HQ0uP3B_yIVqkV-Gp90h-A.png"/></div></div></figure><p id="b3d1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本指南中，我们将介绍如何用比你预期的更少的代码来构建你自己的 PHP 框架。你不需要对 PHP 有很深的理解，尽管它会有所帮助。代码相当简单易懂，所以本指南应该适合大多数经验水平。</p><p id="d1e5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在过去，PHP 没有框架。代码笨拙，没有结构。应用程序和模型代码与视图混合在一起。第一版脸书的代码是这样的，它已经被泄露到网络上。如果你在网上搜索，你可能会毫不费力地找到一本，但我不会在这里链接到它。</p><p id="d2da" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从这些黑暗时代开始，出现了框架。框架允许你将你的应用程序、模型和视图代码分成不同的层，并为你的代码提供一个基本的结构。</p><p id="f2bc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">大多数 PHP 项目使用流行的框架之一，如 Symfony 或 Zend。但是就像生活中所有“好”的东西一样，使用别人构建的框架也有缺点。</p><ul class=""><li id="c20b" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">大多数框架都打包了很多你永远不会用到的库</li><li id="51b0" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">框架把你锁在里面，很难迁移和升级。尝试从 Zend 1 升级到最新版本，或者从 Yii 1 升级到 Yii 2。或者从 Symfony 到 Zend，反之亦然。</li><li id="850e" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">当你可以使用 PHP 内置的框架不可知代码或<code class="fe lh li lj lk b">composer</code>依赖时，框架鼓励为普通操作编写特定于框架的代码，如 GET/POST 输入和验证。这使得锁定变得更糟，使得升级和转换框架更加困难。</li><li id="2d0d" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">框架包含很多你可能不需要的额外处理，这对性能有很大的影响。</li><li id="f1f6" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">您将使用框架维护者喜欢的库，而不是您喜欢的库。当框架使用教条时，更喜欢使用 RedbeanPHP 作为您的 ORM？你需要违背框架来实现你想要的。</li><li id="9323" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">给你的团队增加新成员更难，你需要那些使用过你所使用的第三方框架的人。否则，他们需要在工作中学习。</li><li id="fe53" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">大多数框架的文档都不是很好，而且你可能会遇到很多未记录的怪癖。</li></ul><p id="bd10" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是我们仍然需要一个框架，否则我们又回到了糟糕的意大利面条式代码时代。解决方案是什么？构建自己的轻量级框架！。</p><p id="7928" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">许多框架如此臃肿的原因是它们最初是在<code class="fe lh li lj lk b">composer</code>之前的世界中创建的，所以框架试图提供你可能需要的一切。</p><p id="71e2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们有 PHP 的<code class="fe lh li lj lk b">composer</code>。你可以根据需要单独安装<code class="fe lh li lj lk b">composer</code>包，而不是获得一个提供大量库的框架，这些库会增加你的代码库，并且你可能永远不会使用。<code class="fe lh li lj lk b">composer</code>还提供了一个免费的 PSR 自动加载器，你可以用它来构建你的代码。</p><p id="f561" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不再需要使用第三方框架。<code class="fe lh li lj lk b">composer</code>依赖项和内置的 PHP 功能提供了用最少的代码创建自己的框架所需的一切。</p><h2 id="d1f2" class="ll lm in bd ln lo lp dn lq lr ls dp lt kg lu lv lw kk lx ly lz ko ma mb mc md bi translated">先决条件</h2><p id="0b1b" class="pw-post-body-paragraph jv jw in jx b jy me ka kb kc mf ke kf kg mg ki kj kk mh km kn ko mi kq kr ks ig bi translated">要用 PHP 构建一个基本的 MVC 框架，您需要</p><ul class=""><li id="49c6" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">PHP 8.1 或更高版本</li><li id="7862" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated"><code class="fe lh li lj lk b">composer</code>为附属国。因为您不会使用预构建的框架，所以您将只安装将要使用的依赖项，而不安装其他任何东西。</li></ul><h2 id="f362" class="ll lm in bd ln lo lp dn lq lr ls dp lt kg lu lv lw kk lx ly lz ko ma mb mc md bi translated">设置作曲家</h2><p id="8789" class="pw-post-body-paragraph jv jw in jx b jy me ka kb kc mf ke kf kg mg ki kj kk mh km kn ko mi kq kr ks ig bi translated">要构建自己的 PHP 框架，您需要从<code class="fe lh li lj lk b">composer</code>获取一些依赖项。</p><p id="dc41" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">用以下内容创建一个<code class="fe lh li lj lk b">composer.json</code>文件。</p><pre class="mj mk ml mm gt mn lk mo bn mp mq bi"><span id="c1b8" class="mr lm in lk b be ms mt l mu mv">{<br/>    "name": "cipher-code/phpframework",<br/>    "description": "PHP Framework",<br/>    "type": "project",<br/>    "license": "MIT",<br/>    "autoload": {<br/>        "psr-4": {<br/>            "Framework": "src/"<br/>        }<br/>    },<br/>    "require": {<br/>        "slim/slim": "4.11.0",<br/>        "slim/psr7": " ^1.6",<br/>        "php-di/php-di": "^6.4"<br/>    }<br/>}</span></pre><p id="f57f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后运行<code class="fe lh li lj lk b">composer install</code>来安装初始依赖项并初始化您的自动加载程序。</p><h2 id="5f0c" class="ll lm in bd ln lo lp dn lq lr ls dp lt kg lu lv lw kk lx ly lz ko ma mb mc md bi translated">设置初始<code class="fe lh li lj lk b">public/index.php</code></h2><p id="475e" class="pw-post-body-paragraph jv jw in jx b jy me ka kb kc mf ke kf kg mg ki kj kk mh km kn ko mi kq kr ks ig bi translated">像大多数 PHP 应用程序一样，您需要一个<code class="fe lh li lj lk b">index.php</code>脚本作为“前端控制器”或应用程序的入口点。</p><p id="258a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">用以下内容创建文件<code class="fe lh li lj lk b">public/index.php</code>。</p><pre class="mj mk ml mm gt mn lk mo bn mp mq bi"><span id="4605" class="mr lm in lk b be ms mt l mu mv">&lt;?php<br/>// public/index.php<br/>use Psr\Http\Message\ResponseInterface as Response;<br/>use Psr\Http\Message\ServerRequestInterface as Request;<br/>use Slim\Factory\AppFactory;<br/>use DI\Container;</span></pre><pre class="mw mn lk mx my aw mz bi"><span id="78c0" class="ll lm in lk b gy na nb l nc mv">// This will make referencing files by path much simpler<br/>$rootDir = realpath(__DIR__ . '/..');<br/>define('ROOT_DIR', $rootDir);</span><span id="40d9" class="ll lm in lk b gy nd nb l nc mv">require ROOT_DIR . '/vendor/autoload.php';</span><span id="9f2a" class="ll lm in lk b gy nd nb l nc mv">$app = AppFactory::create();</span><span id="5e61" class="ll lm in lk b gy nd nb l nc mv">$container = new Container();</span><span id="e4e2" class="ll lm in lk b gy nd nb l nc mv">$app-&gt;get('/hello/{name}', function (Request $request, Response $response, array $args) {<br/>    $name = $args['name'];<br/>    $response-&gt;getBody()-&gt;write("Hello, $name");<br/>    return $response;<br/>});</span><span id="672c" class="ll lm in lk b gy nd nb l nc mv">$app-&gt;run();</span></pre><p id="163e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我们将<code class="fe lh li lj lk b">ROOT_DIR</code>定义为一个常量，将来我们可以用它来引用代码库中所有其他的文件路径。不再做<code class="fe lh li lj lk b">__DIR__ . '/../../../Folder/file.php</code>。您可以从<code class="fe lh li lj lk b">ROOT_DIR</code>开始，即<code class="fe lh li lj lk b">ROOT_DIR . '/Folder/file.php</code>。</p><p id="a82b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后我们使用这个<code class="fe lh li lj lk b">ROOT_DIR</code>常量来加载<code class="fe lh li lj lk b">composer</code>。在幕后，<code class="fe lh li lj lk b">composer</code>然后为您设置<code class="fe lh li lj lk b">autoloader</code>，以便您可以命名您的代码。</p><h2 id="85f1" class="ll lm in bd ln lo lp dn lq lr ls dp lt kg lu lv lw kk lx ly lz ko ma mb mc md bi translated">路由器</h2><p id="a512" class="pw-post-body-paragraph jv jw in jx b jy me ka kb kc mf ke kf kg mg ki kj kk mh km kn ko mi kq kr ks ig bi translated">任何框架的核心组件都是路由器，它用于将传入的请求分派给正确的控制器动作。例如，这就是 Symfony 和 Zend 可能知道如何将<code class="fe lh li lj lk b">/hello/{name}</code>路由到<code class="fe lh li lj lk b">HelloController-&gt;hello()</code>的方式。</p><p id="ec96" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要构建自己的 PHP 框架，你需要一个路由器。</p><p id="1072" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们已经安装了<code class="fe lh li lj lk b">Slim</code>，一个超级轻量级的框架。在我们的代码中，我们只使用了<code class="fe lh li lj lk b">Slim</code>路由器来建立<code class="fe lh li lj lk b">/hello/{name}</code>路由。Slim 不是一个完整的 MVC 框架，它只是提供了一组基本的核心组件，比如路由器，你可以用它来创建你自己的框架。</p><p id="31af" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这还不是一个完整的 MVC 框架，因为它只是使用了一个简单的回调函数，还没有任何控制器。然而，它足以测试我们的设置，以确保一切都是正确的。</p><h2 id="f03b" class="ll lm in bd ln lo lp dn lq lr ls dp lt kg lu lv lw kk lx ly lz ko ma mb mc md bi translated">用内置在 web 服务器上的 PHP 确认设置</h2><p id="5ecf" class="pw-post-body-paragraph jv jw in jx b jy me ka kb kc mf ke kf kg mg ki kj kk mh km kn ko mi kq kr ks ig bi translated">用以下命令启动 PHP 内置的 web 服务器</p><pre class="mj mk ml mm gt mn lk mo bn mp mq bi"><span id="fc1d" class="mr lm in lk b be ms mt l mu mv">php -S localhost:8080 -t public public/index.php</span></pre><p id="e691" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后在浏览器中点击<code class="fe lh li lj lk b">http://localhost:8080/hello/&lt;your name&gt;</code>。</p><p id="062f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您应该会看到如下所示的页面。如果没有，回去检查你的工作。</p><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/8ece8de50cbd4e83ca8dce5a7d0d3eaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/0*HJZjDXR49BgPTH5O.png"/></div></figure><h2 id="c9b3" class="ll lm in bd ln lo lp dn lq lr ls dp lt kg lu lv lw kk lx ly lz ko ma mb mc md bi translated">创造<code class="fe lh li lj lk b">src/Controller/HelloController.php</code></h2><p id="54ae" class="pw-post-body-paragraph jv jw in jx b jy me ka kb kc mf ke kf kg mg ki kj kk mh km kn ko mi kq kr ks ig bi translated">如前所述，我们使用一个简单的回调来响应请求，所以这不是一个完整的 MVC 框架。下一步是添加控制器。因此，让我们添加<code class="fe lh li lj lk b">HelloController</code>来处理对<code class="fe lh li lj lk b">/hello/{name}</code>的请求。</p><pre class="mj mk ml mm gt mn lk mo bn mp mq bi"><span id="f860" class="mr lm in lk b be ms mt l mu mv">&lt;?php<br/>namespace Framework\Controller;</span></pre><pre class="mw mn lk mx my aw mz bi"><span id="a94c" class="ll lm in lk b gy na nb l nc mv">use Slim\Psr7\Request;<br/>use Slim\Psr7\Response;</span><span id="939c" class="ll lm in lk b gy nd nb l nc mv">class HelloController<br/>{<br/>    public function hello(Request $request, Response $response, array $args) {<br/>        $name = $args['name'];<br/>        $response-&gt;getBody()-&gt;write("Hello, $name");<br/>        return $response;<br/>    }<br/>}</span></pre><h2 id="1a01" class="ll lm in bd ln lo lp dn lq lr ls dp lt kg lu lv lw kk lx ly lz ko ma mb mc md bi translated">给你的控制器接线</h2><p id="6690" class="pw-post-body-paragraph jv jw in jx b jy me ka kb kc mf ke kf kg mg ki kj kk mh km kn ko mi kq kr ks ig bi translated">更新<code class="fe lh li lj lk b">index.php</code>以匹配以下内容。不要忘记导入新的名称空间！</p><pre class="mj mk ml mm gt mn lk mo bn mp mq bi"><span id="f753" class="mr lm in lk b be ms mt l mu mv">&lt;?php<br/>// public/index.php<br/>use Psr\Http\Message\ResponseInterface as Response;<br/>use Psr\Http\Message\ServerRequestInterface as Request;<br/>use Slim\Factory\AppFactory;<br/>use DI\Container;<br/>use Framework\Controller\HelloController;</span></pre><pre class="mw mn lk mx my aw mz bi"><span id="7072" class="ll lm in lk b gy na nb l nc mv">// This will make referencing files by path much simpler<br/>$rootDir = realpath(__DIR__ . '/..');<br/>define('ROOT_DIR', $rootDir);</span><span id="32d8" class="ll lm in lk b gy nd nb l nc mv">require ROOT_DIR . '/vendor/autoload.php';</span><span id="95db" class="ll lm in lk b gy nd nb l nc mv">$app = AppFactory::create();</span><span id="c872" class="ll lm in lk b gy nd nb l nc mv">$container = new Container();</span><span id="e420" class="ll lm in lk b gy nd nb l nc mv">$app-&gt;get('/hello/{name}', function (Request $request, Response $response, array $args) use ($container) {<br/>    /** @var Framework\Controller\HelloController */<br/>    $helloController = $container-&gt;get(HelloController::class);<br/>    return $helloController-&gt;hello($request, $response, $args);<br/>});</span><span id="f836" class="ll lm in lk b gy nd nb l nc mv">$app-&gt;run();</span></pre><p id="28fe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里，我们使用<a class="ae nf" href="https://php-di.org/doc/autowiring.html" rel="noopener ugc nofollow" target="_blank"> PHP-DI 自动连线</a>来获得带有<code class="fe lh li lj lk b">$container-&gt;get(HelloController::class)</code>的控制器，而不是调用<code class="fe lh li lj lk b">new HelloController()</code>，如果我没有告诉你，你可能会尝试这样做。这是为了以后我们可以用依赖注入来注入依赖。</p><p id="3955" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在再次启动 PHP 内置的 web 服务器。再次点击<code class="fe lh li lj lk b">http://localhost:8080/hello/&lt;your name&gt;</code>，你应该会看到和之前一样的结果。如果没有，回去检查你的工作。</p><h2 id="1fcf" class="ll lm in bd ln lo lp dn lq lr ls dp lt kg lu lv lw kk lx ly lz ko ma mb mc md bi translated">创建<code class="fe lh li lj lk b">src/Util/Greeter.php</code></h2><p id="4e83" class="pw-post-body-paragraph jv jw in jx b jy me ka kb kc mf ke kf kg mg ki kj kk mh km kn ko mi kq kr ks ig bi translated">现在我们有一个控制器来分派请求，但是我们有一个设计问题。</p><p id="47d6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的管理员做得太多了。它不仅处理问候语的输出，还自己生成它！我们应该遵循<a class="ae nf" href="https://en.wikipedia.org/wiki/SOLID" rel="noopener ugc nofollow" target="_blank">坚实的原则</a>，其中之一就是单一目的。</p><p id="1f49" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">目前，问候还不太复杂，只支持英语。让我们想象一下，未来你需要用多种语言打招呼！。对于当前的设置，这意味着在代码中引入大量的逻辑。如果<code class="fe lh li lj lk b">$language</code>是西班牙语，输出西班牙语问候语等等。</p><p id="deb7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">控制器会变得比实际需要的大很多。任何框架都要遵循的一个好原则是“瘦控制器”。因此，您只需在控制器中放入最少量的代码来处理请求。繁重的工作应该在别处完成。</p><p id="2020" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们将问候生成卸载到另一个类，我们可以使用它作为未来结构的基础，我们可以轻松地支持多种语言，而不需要太多的逻辑。</p><p id="f72b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以，让我们把生成问候的任务交给一个新的<code class="fe lh li lj lk b">Greeter</code>类。</p><pre class="mj mk ml mm gt mn lk mo bn mp mq bi"><span id="6a5b" class="mr lm in lk b be ms mt l mu mv">&lt;?php<br/>// src/Util/Greeter.php<br/>namespace Framework\Util;</span></pre><pre class="mw mn lk mx my aw mz bi"><span id="2ea4" class="ll lm in lk b gy na nb l nc mv">class Greeter<br/>{<br/>    public function greet(string $name) : string<br/>    {<br/>        return "Hello, $name";<br/>    }<br/>}</span></pre><p id="cd30" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">更新<code class="fe lh li lj lk b">HelloController</code>以使用<code class="fe lh li lj lk b">Greeter</code>。</p><pre class="mj mk ml mm gt mn lk mo bn mp mq bi"><span id="7cf3" class="mr lm in lk b be ms mt l mu mv">&lt;?php<br/>// src/Controller/HelloController.php<br/>namespace Framework\Controller;</span></pre><pre class="mw mn lk mx my aw mz bi"><span id="b13d" class="ll lm in lk b gy na nb l nc mv">use Framework\Util\Greeter;<br/>use Slim\Psr7\Request;<br/>use Slim\Psr7\Response;</span><span id="9545" class="ll lm in lk b gy nd nb l nc mv">class HelloController<br/>{<br/>    public function __construct(<br/>        protected Greeter $greeter<br/>    ) {}</span><span id="5efa" class="ll lm in lk b gy nd nb l nc mv">    public function hello(Request $request, Response $response, array $args) <br/>    {<br/>        $name = $args['name'];<br/>        $response-&gt;getBody()-&gt;write($this-&gt;greeter-&gt;greet($name));<br/>        return $response;<br/>    }<br/>}</span></pre><p id="e8d4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是我们第一次使用依赖注入。在构造函数中，我们使用 PHP 属性提升，所以我们只需要定义一次依赖关系。PHP-DI 自动布线使用<a class="ae nf" href="https://www.php.net/manual/en/book.reflection.php" rel="noopener ugc nofollow" target="_blank">反射</a>提前检查类需要什么，然后在运行时自动注入。</p><p id="50a9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这使得管理依赖性和坚持坚实的原则变得更加容易。</p><h2 id="e9ca" class="ll lm in bd ln lo lp dn lq lr ls dp lt kg lu lv lw kk lx ly lz ko ma mb mc md bi translated">结束第 1 部分</h2><p id="6fab" class="pw-post-body-paragraph jv jw in jx b jy me ka kb kc mf ke kf kg mg ki kj kk mh km kn ko mi kq kr ks ig bi translated">现在你有了一个简单的框架，包括一个路由器、DI 和一个控制器。它主要是遵循坚实的原则，我们还没有任何测试。</p><p id="9605" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要实现完整的 MVC，我们需要一个模型和视图层。这将在“构建自己的 PHP 框架—第 2 部分”中介绍。如果你想给我额外的动力，让我更快地创作第 2 部分，请使用提供的链接在你所有的社交网站上分享这篇文章。我看到的参与越多，我就能越快地创作第二部分！。</p></div></div>    
</body>
</html>