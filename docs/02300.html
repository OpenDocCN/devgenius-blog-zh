<html>
<head>
<title>Demystifying Microservices pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭秘微服务模式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/demystifying-microservices-pattern-95d26f0feb3b?source=collection_archive---------14-----------------------#2020-07-27">https://blog.devgenius.io/demystifying-microservices-pattern-95d26f0feb3b?source=collection_archive---------14-----------------------#2020-07-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/bd8d8967fc3b6b5f5c98d078de5cd854.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2hMe-phi5hO5gI8OXY8-ZQ.png"/></div></div></figure><p id="9e98" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">随着数字化和云技术的兴起，构建和维护微服务是软件行业最受欢迎的技能之一。在开始微服务架构的模式之前，让我们看看微服务到底是什么。</p><p id="dccd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">什么是微服务架构？</strong></p><p id="9529" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它是一种面向服务的架构风格，将应用程序安排为松散耦合的服务，可以独立开发、部署和维护。在理想情况下，每个服务都通过API相互通信。</p><blockquote class="kt ku kv"><p id="1b16" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">在整个博客中，我们将着眼于订单服务和票务服务来理解不同的模式。订单服务负责下订单和管理机票订单，而票务服务处理机票的创建/更新。</p></blockquote><p id="0441" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">共享数据库模式</strong></p><figure class="lb lc ld le gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi la"><img src="../Images/f0046fdd5b66444cf88c71794996c87a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v8BmffflxmkUvfeX3799-g.png"/></div></div></figure><p id="a1db" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如上面的架构图所示，订单和票务服务在共享数据库上运行。这两种服务都可以独立管理和部署，但是，它们共享一个数据库依赖关系，每当必须进行与数据库相关的更改时，都必须主动进行沟通。在一个<a class="ae lf" href="https://en.wikipedia.org/wiki/Agile_software_development" rel="noopener ugc nofollow" target="_blank">敏捷</a>设置中，如果这些服务归两个不同的团队所有，他们将永远无法作为绝对独立的单元运作。</p><p id="2f7e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">共享服务模式</strong></p><figure class="lb lc ld le gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lg"><img src="../Images/53d1a30c268c12b90304a8684aff0c1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*85uA2OaZgutfs-X-yMDSGw.png"/></div></div></figure><p id="22ca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这种模式中，数据库归共享服务所有，消费者应用程序不需要担心数据库的任何变化。订单和票务服务将能够通过共享服务公开的API进行数据库更新。这种设置使两个服务成为绝对独立的单元。但是，如果共享服务关闭，将导致所有消费者应用程序不可用。</p><p id="adb0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">基于事件的模式</strong></p><figure class="lb lc ld le gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lh"><img src="../Images/b62a165108db6dc7d7a86d913eff4dbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tiXH580aNRBr4d-nSh3JgA.png"/></div></div></figure><p id="3f43" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是所有模式中最复杂的，但同时在管理和维护方面具有最大的灵活性。每个服务拥有一个数据库，并且总是在其数据库中进行更新。不同服务之间的数据库同步使用事件总线进行，事件总线本身是一个独立的服务。</p><p id="3c51" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了更清楚起见，我们来看一个在票务数据库中创建票据的场景。票务服务将发布一个活动，该活动将由活动总线挑选并在全球范围内发布。订购服务将侦听传入的票据创建事件，并在其数据库中进行更新，以便可以在新创建的票据上创建订单。类似地，在票据上创建订单时，订单服务会发布一个事件，以便票据服务更新其数据库中的票据状态。</p><p id="db41" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当您选择这种模式时，必须考虑许多并发场景。然而，该模式使得服务在真正意义上是独立的。</p><p id="d0d1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你喜欢读这篇文章，别忘了鼓掌。👏👏</p><p id="5610" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你也可以在twitter <a class="ae lf" href="https://twitter.com/Akash940" rel="noopener ugc nofollow" target="_blank"> @Akash940 </a>上关注我的JavaScript或React更新。</p><p id="5d2e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">谢谢你！</p></div></div>    
</body>
</html>