<html>
<head>
<title>Why C/C++ don’t have a garbage collector? Can we build one?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么 C/C++没有垃圾收集器？我们能造一个吗？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/why-c-c-dont-have-a-garbage-collector-can-we-build-one-427992121c1e?source=collection_archive---------10-----------------------#2022-12-24">https://blog.devgenius.io/why-c-c-dont-have-a-garbage-collector-can-we-build-one-427992121c1e?source=collection_archive---------10-----------------------#2022-12-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="f15d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">像 Java、Python、Go、C#等许多语言都已经建立了垃圾收集器，但是像 C/C++这样的原始语言却没有。我们将在 C++中通过引用计数来构建垃圾收集。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d699c0e02a4749219b6b6682a08c4465.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cifTmWHK2uOWjPtOiM9YqA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图 1:通过引用计数的 GC 代码(被我点击)</figcaption></figure><p id="401c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">条款范围</strong></p><ul class=""><li id="83a1" class="ky kz in jm b jn jo jr js jv la jz lb kd lc kh ld le lf lg bi translated">什么是垃圾收集？我们为什么需要它们？</li><li id="8c77" class="ky kz in jm b jn lh jr li jv lj jz lk kd ll kh ld le lf lg bi translated">为什么 C/C++缺少垃圾回收？</li><li id="5df6" class="ky kz in jm b jn lh jr li jv lj jz lk kd ll kh ld le lf lg bi translated">我们能造一个吗？</li><li id="08a6" class="ky kz in jm b jn lh jr li jv lj jz lk kd ll kh ld le lf lg bi translated">通过引用计数进行垃圾收集</li></ul><h1 id="cb2e" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">简介-什么是垃圾收集？我们为什么需要它们？</h1><p id="7bee" class="pw-post-body-paragraph jk jl in jm b jn mk jp jq jr ml jt ju jv mm jx jy jz mn kb kc kd mo kf kg kh ig bi translated">在第一部分，我们将探索什么是垃圾收集以及对它们的需求。</p><p id="ef1e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的程序涉及内存，以变量和对象的形式。对象被分配在堆栈或堆上。堆栈存储局部声明的变量，如“int a = 10”在函数的堆栈框架上，因此当函数返回时，值从堆栈框架中弹出，使它们不存在。所以我们不需要对栈进行垃圾收集。</p><p id="eeeb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一方面，堆是不同的。使用“new”或“malloc”函数分配堆变量。为这些东西创建的对象空间在 RAM 中。当我们使用完它们时，必须显式地释放它们，因为它们比函数作用域和执行时间都长。对于堆，我们需要一个内置于编程语言中的自动内存恢复特性，称为垃圾收集器。缺少垃圾收集器会导致内存泄漏和悬空指针。</p><h1 id="c5a1" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">为什么 C/C++缺少垃圾回收？</h1><ol class=""><li id="1bc1" class="ky kz in jm b jn mk jr ml jv mp jz mq kd mr kh ms le lf lg bi translated">性能:垃圾收集可能是资源密集型的，会对程序的性能产生负面影响。在 C/C++中，开发人员能够手动管理内存，这可以更有效地利用资源。C/C++必须能够在裸机上快速运行。</li><li id="ea5e" class="ky kz in jm b jn lh jr li jv lj jz lk kd ll kh ms le lf lg bi translated">控制:C/C++允许开发人员完全控制内存的分配和释放，允许他们针对特定的用例优化代码。使用垃圾收集，开发人员可能无法控制内存的分配和释放。</li><li id="8eea" class="ky kz in jm b jn lh jr li jv lj jz lk kd ll kh ms le lf lg bi translated">兼容性:C/C++常用于编写低级系统库和驱动程序，需要对内存管理进行精确控制。垃圾收集可能与这些类型的应用程序不兼容。</li><li id="d2e3" class="ky kz in jm b jn lh jr li jv lj jz lk kd ll kh ms le lf lg bi translated">复杂性:在 C/C++中实现垃圾收集可能很复杂，因为它需要向语言中添加额外的代码。这可能会增加语言的复杂性，对于一些开发人员来说可能不值得这样做。</li><li id="d517" class="ky kz in jm b jn lh jr li jv lj jz lk kd ll kh ms le lf lg bi translated">遗留代码:C/C++已经存在了很长时间，并且拥有大量依赖于手动内存管理的现有代码库。向语言中添加垃圾收集可能会破坏这些代码库，并给依赖它们的开发人员带来问题。</li></ol><h1 id="04ac" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated"><strong class="ak">我们能造一个吗？</strong></h1><p id="d923" class="pw-post-body-paragraph jk jl in jm b jn mk jp jq jr ml jt ju jv mm jx jy jz mn kb kc kd mo kf kg kh ig bi translated">是的，为 C/C++建立一个垃圾收集系统是可能的。有几个第三方库为 C/C++提供了垃圾收集，比如博姆-德默斯-魏泽垃圾收集器。但是，这些系统可能无法处理所有 C/C++代码，并且与手动内存管理相比，可能会有一些性能开销。此外，在 C/C++中实现垃圾收集可能比在本机支持垃圾收集的语言中更复杂，需要更多的努力。</p><p id="b919" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 C 和 C++中，可以使用引用计数、标记和清除、跟踪垃圾收集等方法实现垃圾收集。</p><p id="ccfc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">奖励:通过引用计数进行垃圾收集。</strong></p><pre class="kj kk kl km gt mt mu mv bn mw mx bi"><span id="821d" class="my ln in mu b be mz na l nb nc">#include &lt;iostream&gt;<br/>#include &lt;unordered_map&gt;<br/>#include &lt;memory&gt;<br/><br/>// A simple garbage collected object<br/>class GCObject {<br/>public:<br/>    // Constructor increments the reference count<br/>    GCObject() : refCount(1) {}<br/><br/>    // Destructor decrements the reference count<br/>    virtual ~GCObject() {<br/>        refCount--;<br/>        // If the reference count is 0, delete the object<br/>        if (refCount == 0) {<br/>            delete this;<br/>        }<br/>    }<br/><br/>    // Increment the reference count<br/>    void AddRef() {<br/>        refCount++;<br/>    }<br/><br/>private:<br/>    int refCount;<br/>};<br/><br/>// A garbage collector class<br/>class GC {<br/>public:<br/>    // Add an object to the garbage collector<br/>    static void AddObject(GCObject* obj) {<br/>        objects[obj] = obj;<br/>    }<br/><br/>    // Remove an object from the garbage collector<br/>    static void RemoveObject(GCObject* obj) {<br/>        objects.erase(obj);<br/>    }<br/><br/>    // Collect garbage by deleting objects with a reference count of 0<br/>    static void Collect() {<br/>        for (auto&amp; [obj, count] : objects) {<br/>            if (obj-&gt;refCount == 0) {<br/>                delete obj;<br/>            }<br/>        }<br/>    }<br/><br/>private:<br/>    static std::unordered_map&lt;GCObject*, GCObject*&gt; objects;<br/>};<br/><br/>// Initialize the static objects map<br/>std::unordered_map&lt;GCObject*, GCObject*&gt; GC::objects;<br/><br/>int main() {<br/>    // Create a garbage collected object<br/>    GCObject* obj = new GCObject();<br/><br/>    // Add the object to the garbage collector<br/>    GC::AddObject(obj);<br/><br/>    // Remove the object from the garbage collector<br/>    GC::RemoveObject(obj);<br/><br/>    // Collect garbage<br/>    GC::Collect();<br/><br/>    return 0;<br/>}</span></pre><p id="f476" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个<code class="fe nd ne nf mu b">GCObject</code>类中，通过维护一个<code class="fe nd ne nf mu b">refCount</code>字段来实现引用计数。<code class="fe nd ne nf mu b">GCObject</code>构造函数增加引用计数，析构函数减少引用计数。如果引用计数变为 0，对象将删除自身。</p><p id="efd7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe nd ne nf mu b">GC</code>类是一个简单的垃圾收集器，它维护对象及其引用计数的映射。<code class="fe nd ne nf mu b">AddObject</code>和<code class="fe nd ne nf mu b">RemoveObject</code>方法分别在地图上添加和移除对象。<code class="fe nd ne nf mu b">Collect</code>方法遍历地图中的对象，删除任何引用计数为 0 的对象。</p><p id="73a0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">总而言之……</strong></p><p id="de5a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">总之，虽然垃圾收集是编程语言中管理内存的有用工具，但它有可能对性能产生负面影响，并且可能与某些类型的应用程序不兼容。C/C++开发人员可以选择手动管理内存，这可以提供更多的控制，并可能更有效地利用资源。然而，在 C/C++中实现垃圾收集可能会很复杂，对于一些开发人员来说可能不值得这样做。此外，在 C/C++中，大量依赖手动内存管理的遗留代码库可能会给将垃圾收集合并到语言中带来挑战。</p></div></div>    
</body>
</html>