<html>
<head>
<title>Database Design 101</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据库设计</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/database-design-101-7c019d69b97f?source=collection_archive---------2-----------------------#2022-04-16">https://blog.devgenius.io/database-design-101-7c019d69b97f?source=collection_archive---------2-----------------------#2022-04-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="1afa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这篇博客是我们从零开始讨论 101 个<strong class="jm io"> </strong>概念的系列文章的一部分，读者的入门知识有限。这篇文章属于<em class="ki">中级</em>系列，因为它涉及到理解<strong class="jm io">数据库设计原则的基础，</strong>主要用于关系数据库用例。</p><p id="7052" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">101 系列中的一些早期博客如下:</p><p id="9295" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/api-101-773ec501b485"><strong class="jm io">API 101</strong></a><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/async-communication-101-b04d5c95333a"><strong class="jm io"><br/>异步通信 101</strong></a><strong class="jm io"><br/></strong><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/database-101-13d593ec4078"><strong class="jm io">数据库 101 </strong> </a></p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/45987472ce0386d600b6c3932b976bbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xh6p3Z8NJEm09k2XHf4D5g.png"/></div></div></figure><h1 id="69a7" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">什么是数据库设计？</h1><p id="b8df" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated"><a class="ae kj" href="https://en.wikipedia.org/wiki/Database_design" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">数据库设计</strong> </a> <strong class="jm io"> </strong>是整个架构设计过程中的一个重要步骤，它使用数据库<strong class="jm io"> <em class="ki">模式、表格、视图等来确定与业务领域相关的数据的逻辑组织。</em>在用于应用程序设计的<a class="ae kj" href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> MVC </strong> </a>模型中，模型层与实际的数据库进行交互，并且通常从任何数据库模式变化中抽象出来。</strong></p><h1 id="ba55" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">常用术语</h1><ul class=""><li id="17f1" class="lz ma in jm b jn lu jr lv jv mb jz mc kd md kh me mf mg mh bi translated"><strong class="jm io">行</strong> —数据库表中的每个数据记录都存储为横线。订单管理系统中的每个客户记录都是唯一的一行。</li><li id="97a8" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><strong class="jm io">列— </strong>在数据库中，列存储特定类型的数据。<em class="ki">例如:字符串、日期、整数等</em></li><li id="59ff" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><strong class="jm io">表格— </strong>行和列的集合称为表格。表是根据整体架构中的实体进行分类的，例如客户、订单、项目都是独立的。表是一个订单管理系统。</li><li id="849a" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><strong class="jm io">查询— </strong>查询是用于创建、读取、更新、删除、截断数据库表中的数据的 SQL 命令。</li><li id="5bdd" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><strong class="jm io">视图— </strong>视图是由原始表的行和列的子集创建的虚拟表，以提高复杂性和更好的访问控制。</li><li id="82ee" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><strong class="jm io">索引— </strong>索引用于通过使用磁盘上的额外存储来改进数据查找。</li><li id="d4b2" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><strong class="jm io">主键—</strong>用于唯一标识数据库表中行/记录的列或列元组。</li><li id="5471" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><strong class="jm io">外键— </strong>用于导出多个表之间的关系，表的外键是连接器，因为它引用另一个表的主键。</li></ul><h1 id="28f5" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">数据库设计过程</h1><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/4a5cc2018fc9ad8d3d224b1fd7889e66.png" data-original-src="https://miro.medium.com/v2/resize:fit:718/format:webp/1*K8ValggcYPtnPBfW36-n9w.jpeg"/></div></figure><h1 id="bcd1" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">DDL 与 DML</h1><p id="d77b" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">在数据库管理系统上运行的查询操作可以大致分为两大类</p><ul class=""><li id="247c" class="lz ma in jm b jn jo jr js jv mo jz mp kd mq kh me mf mg mh bi translated"><strong class="jm io"> DDL </strong>，代表<strong class="jm io">数据定义语言</strong>，定义数据库中表格的基本数据结构/模式。E <em class="ki"> x-创建表格，修改表格。</em><em class="ki"/>DDL<em class="ki">q</em>查询影响表的列，并根据模式的需要定义任何约束。</li><li id="5f49" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><strong class="jm io">另一方面，DML </strong>代表<strong class="jm io">数据操作语言</strong>，即使用 DDL 查询修改已经定义的模式的表内容。<strong class="jm io">E<em class="ki">x-Insert INTO table _ name，UPDATE table _ name</em>T23<em class="ki">。</em> DML 查询影响数据行 us</strong></li></ul><h1 id="1b2a" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">数据库规范化</h1><p id="bb16" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">数据库规范化是一个设计步骤，它消除了以大型整体表形式存储的冗余数据，从而简化了整个查询的执行。这种规范化数据的主要目的是使用表之间的关系对数据进行逻辑存储。正如 Edgar Codd 最初提出的，从 1NF 到 6NF 的整个过程包括六个步骤，如下所述。大多数现代数据库遵循一个标准，直到 4NF 步骤。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi mr"><img src="../Images/3837e78b15aaa19157aea0672774e3e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sPHMhZrssF7mcktY3l-S5A.png"/></div></div></figure><p id="0dfc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">详细阅读整体步骤—<a class="ae kj" href="https://docs.microsoft.com/en-us/office/troubleshoot/access/database-normalization-description" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/office/trouble shooting/access/database-normalization-description</a></p><h1 id="467d" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">实体关系设计</h1><p id="a074" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">实体是指<strong class="jm io"> <em class="ki">客户/订单/付款/项目</em> </strong>等，其属性以行和列的形式存储，并在逻辑上分组为数据库中的表。因此，在实际业务领域中这些实体之间导出的数据库设计部分被称为<strong class="jm io">实体关系设计</strong>。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi ms"><img src="../Images/15635df0188096c9da64dbd6807c2549.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L4d_-hi8tccDqd1ob_Pz2A.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated"><strong class="bd ky">大学生 ER 图样本</strong></figcaption></figure><h2 id="eeec" class="mx kx in bd ky my mz dn lc na nb dp lg jv nc nd lk jz ne nf lo kd ng nh ls ni bi translated">一对多关系</h2><p id="0bf0" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">在订单管理系统中，<strong class="jm io"> <em class="ki"> vendor_table </em> </strong>和<strong class="jm io"><em class="ki">product _ table</em></strong>有一对多的实体关系，即一个供应商可以发送多个产品。</p><h2 id="ba76" class="mx kx in bd ky my mz dn lc na nb dp lg jv nc nd lk jz ne nf lo kd ng nh ls ni bi translated">多对多关系</h2><p id="195e" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">在订单管理系统中，<strong class="jm io">产品</strong>和<strong class="jm io">订单</strong>实体具有多对多实体关系，因为单个产品可以出现在多个订单中，并且一个订单可以包含多个产品。为了解决这些用例，推荐使用包含<strong class="jm io">订单表</strong>和<strong class="jm io">产品表</strong>主键的连接表。</p><h2 id="8720" class="mx kx in bd ky my mz dn lc na nb dp lg jv nc nd lk jz ne nf lo kd ng nh ls ni bi translated">一对一的关系</h2><p id="66f0" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">当实体的子类(如<strong class="jm io">产品</strong>)具有表中所有行都没有的附加属性时，通常使用一对一关系。在这种情况下，建议使用主键为<strong class="jm io">产品标识</strong>的<strong class="jm io">产品补充表</strong>。</p><h1 id="cd6e" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">查询优化</h1><p id="c942" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">以下是一些适用于数据库模式和查询原则的一般建议，以确保满足最终客户和产品对数据库访问的正确性能 SLA 要求</p><ul class=""><li id="b248" class="lz ma in jm b jn jo jr js jv mo jz mp kd mq kh me mf mg mh bi translated">在查询数据时，使用<strong class="jm io">选择字段</strong>而不是<strong class="jm io">选择* </strong>来只读视图或控制器中的必要字段。此外，为了获取不同的项目<strong class="jm io">，选择 ID 优先于<strong class="jm io">选择不同的</strong>命令。</strong></li><li id="0e11" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated">使用<strong class="jm io">EXIST()</strong>over<strong class="jm io">r COUNT()to</strong>查找单个记录的存在，因为在 EXIST 命令的情况下，查询在表中的第一个匹配处停止。</li><li id="dae9" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated">使用一个<strong class="jm io"> WHERE </strong>子句，而不是 have for 条件查询，因为前者在实际分组之前过滤数据，从而使速度更快。</li><li id="be23" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated">简化<strong class="jm io"> JOIN </strong>命令，因为从多个表中获取数据是最大的瓶颈。使用 JOIN 时，从结果集较少的表开始有助于减少总的执行时间。</li></ul><p id="cd05" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用聚集和非聚集索引，可以针对应用程序用例进一步优化对最常见列的数据访问。</p><p id="347c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">如需反馈，请留言至</em><strong class="jm io"><em class="ki">Amit[dot]894[at]Gmail[dot]com</em></strong><em class="ki">或联系</em><a class="ae kj" href="https://about.me/amit_raj" rel="noopener ugc nofollow" target="_blank"><em class="ki">https://about.me/amit_raj</em></a><em class="ki">的任何链接。</em></p></div></div>    
</body>
</html>