<html>
<head>
<title>Row level transactions on S3 Data Lake</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">S3 数据湖上的行级事务</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/row-level-transactions-on-s3-data-lake-c6e44ecf85e8?source=collection_archive---------4-----------------------#2022-11-23">https://blog.devgenius.io/row-level-transactions-on-s3-data-lake-c6e44ecf85e8?source=collection_archive---------4-----------------------#2022-11-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="cea7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在基于不可变对象存储的数据湖中，行级操作总是很棘手。为了克服这个问题，我们编写了 ETL，以便在每次检测到更新或删除时覆盖整个分区甚至整个表。但是现在冰山表的行级操作变得更加容易，因为 Athena 对冰山的支持增加了很多。我们将讨论同样的例子和一些可能发生的常见错误。</p><h1 id="cecc" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">冰山—数据湖的表格格式</h1><p id="8fda" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">在像 MySQL 这样的 RDBMS 中，与底层数据的所有交互，比如读写，都是由数据库的存储引擎处理的。类似地，像 Iceberg 这样的表格式的主要目标是向人和工具提供表的抽象，并允许他们有效地与表的底层数据进行交互。冰山做到这一点的帮助下，额外的元数据层上的实际数据文件的 S3。你可以在这篇<a class="ae ll" href="https://www.dremio.com/resources/guides/apache-iceberg-an-architectural-look-under-the-covers/" rel="noopener ugc nofollow" target="_blank">详细而简单的文章</a>中阅读更多冰山架构</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi lm"><img src="../Images/fb9792f1e991b2d3272b22ea1b88099a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NKzcplWD-rf7Mo6CxUS9YA.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">图片来自 Dremio 博客</figcaption></figure><h1 id="788a" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">雅典娜和冰山</h1><p id="8f53" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">Athena 支持 Iceberg table 已经有一段时间了——但是非常有限。现在有了引擎 v3，新的版本最近来了，冰山支持加强:</p><ul class=""><li id="799d" class="mc md in jm b jn jo jr js jv me jz mf kd mg kh mh mi mj mk bi translated"><strong class="jm io"> ORC 和 Avro 支持</strong> —使用<a class="ae ll" href="https://avro.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Avro </a>和<a class="ae ll" href="https://orc.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache ORC </a>基于行和列的文件格式创建 Iceberg 表。对这些格式的支持是对现有拼花支持的补充。</li><li id="5892" class="mc md in jm b jn ml jr mm jv mn jz mo kd mp kh mh mi mj mk bi translated"><strong class="jm io">合并到</strong> —使用<code class="fe mq mr ms mt b">MERGE INTO</code>命令有效合并大规模数据。<code class="fe mq mr ms mt b">MERGE INTO</code>将<code class="fe mq mr ms mt b">INSERT</code>、<code class="fe mq mr ms mt b">UPDATE</code>和<code class="fe mq mr ms mt b">DELETE</code>操作组合成一个事务。这减少了数据管道中的处理开销，并且需要编写更少的 SQL。更多信息参见<a class="ae ll" href="https://docs.aws.amazon.com/athena/latest/ug/querying-iceberg-updating-iceberg-table-data.html" rel="noopener ugc nofollow" target="_blank">更新冰山表数据</a>和<a class="ae ll" href="https://docs.aws.amazon.com/athena/latest/ug/merge-into-statement.html" rel="noopener ugc nofollow" target="_blank">合并到</a>。</li><li id="4015" class="mc md in jm b jn ml jr mm jv mn jz mo kd mp kh mh mi mj mk bi translated"><strong class="jm io"> CTAS 和视图支持</strong> —在冰山表中使用<code class="fe mq mr ms mt b">CREATE TABLE AS SELECT</code> (CTAS)和<code class="fe mq mr ms mt b">CREATE VIEW</code>语句。更多信息，参见<a class="ae ll" href="https://docs.aws.amazon.com/athena/latest/ug/create-table-as.html" rel="noopener ugc nofollow" target="_blank">创建表格为</a>和<a class="ae ll" href="https://docs.aws.amazon.com/athena/latest/ug/create-view.html" rel="noopener ugc nofollow" target="_blank">创建视图</a>。</li><li id="edf2" class="mc md in jm b jn ml jr mm jv mn jz mo kd mp kh mh mi mj mk bi translated"><strong class="jm io">真空支持</strong> —您可以使用<code class="fe mq mr ms mt b">VACUUM</code>语句通过删除不再需要的快照和数据来优化您的数据湖。您可以使用此功能来提高读取性能，并满足监管要求，如 GDPR 。更多信息，参见<a class="ae ll" href="https://docs.aws.amazon.com/athena/latest/ug/querying-iceberg-data-optimization.html" rel="noopener ugc nofollow" target="_blank">优化冰山表</a>和<a class="ae ll" href="https://docs.aws.amazon.com/athena/latest/ug/vacuum-statement.html" rel="noopener ugc nofollow" target="_blank">真空</a>。</li></ul><h2 id="cded" class="mu kj in bd kk mv mw dn ko mx my dp ks jv mz na kw jz nb nc la kd nd ne le nf bi translated">使用 CTAS 创建冰山表</h2><p id="8800" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">CTAS 可以用来从一个正常的雅典娜表创建一个冰山表:</p><pre class="ln lo lp lq gt ng mt nh bn ni nj bi"><span id="9da7" class="nk kj in mt b be nl nm l nn no">CREATE TABLE icb_test.icb_bucket_initial<br/>WITH (table_type = 'ICEBERG',<br/>      format = 'PARQUET', <br/>      location = 's3://athena-icb-bucket-test/icb_test/icb_bucket_1/', <br/>      is_external = false,<br/>      vacuum_min_snapshots_to_keep = 10<br/>   ) <br/>AS SELECT device_id,<br/>truck_id,<br/>order_uuid,<br/>ticket_number<br/>from athena_normal_tables.ticket<br/>where year = '2022' and month='11' and day='10' and hour = '11';</span></pre><p id="70e3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，如果在源表中有一个<code class="fe mq mr ms mt b">timestamp</code>列，可能会得到一个错误<em class="np">NOT _ SUPPORTED:Iceberg 不支持时间戳精度(3)。请改用“时间戳(6)”。</em>转换如下所示的时间戳列类型来解决这个问题:</p><pre class="ln lo lp lq gt ng mt nh bn ni nj bi"><span id="0314" class="nk kj in mt b be nl nm l nn no">CREATE TABLE icb_test.icb_bucket_timestamp<br/>WITH (table_type = 'ICEBERG',<br/>      format = 'PARQUET', <br/>      location = 's3://athena-icb-bucket-test/icb_test/icb_bucket_1/', <br/>      is_external = false,<br/>      vacuum_min_snapshots_to_keep = 10<br/>   ) <br/>AS SELECT device_id,<br/>truck_id,<br/>order_uuid,<br/>ticket_number,<br/>cast(ingestion_timestamp_utc as timestamp(6)) as ingestion_timestamp_utc -- Typecasting<br/>from athena_normal_tables.ticket<br/>where year = '2022' and month='11' and day='10' and hour = '11';</span></pre><p id="7741" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用<code class="fe mq mr ms mt b">WITH NO DATA</code>创建没有数据的表格:</p><pre class="ln lo lp lq gt ng mt nh bn ni nj bi"><span id="8166" class="nk kj in mt b be nl nm l nn no">CREATE TABLE icb_test.icb_bucket_with_no_data<br/>WITH (table_type = 'ICEBERG',<br/>      format = 'PARQUET', <br/>      location = 's3://athena-icb-bucket-test/icb_test/icb_bucket_1/', <br/>      is_external = false,<br/>      vacuum_min_snapshots_to_keep = 10<br/>   ) <br/>AS SELECT device_id,<br/>truck_id,<br/>order_uuid,<br/>ticket_number,<br/>cast(ingestion_timestamp_utc as timestamp(6)) as ingestion_timestamp_utc -- Typecasting<br/>from athena_normal_tables.ticket<br/>WITH NO DATA</span></pre><h1 id="a8a7" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">冰山表上的行级操作</h1><p id="aedb" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">现在让我们讨论如何从 Iceberg 表中插入/更新/删除行</p><h2 id="3f5c" class="mu kj in bd kk mv mw dn ko mx my dp ks jv mz na kw jz nb nc la kd nd ne le nf bi translated">插入</h2><p id="149e" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">一旦创建了 Iceberg 表，您就可以使用<code class="fe mq mr ms mt b">INSERT INTO</code>或<code class="fe mq mr ms mt b">MERGE</code>语句从普通的 Athena 表中插入数据</p><pre class="ln lo lp lq gt ng mt nh bn ni nj bi"><span id="c225" class="nk kj in mt b be nl nm l nn no">INSERT INTO iceberg_table (col1, col2, ...) VALUES (val1, val2, ...)<br/>INSERT INTO iceberg_table SELECT * FROM another_normal_table<br/><br/>-- Eg:<br/>INSERT INTO icb_test.icb_test.icb_bucket_with_no_data<br/>SELECT device_id,<br/>truck_id,<br/>order_uuid,<br/>ticket_number,<br/>ingestion_timestamp_utc<br/>from athena_normal_tables.ticket<br/>-- Note that there is no typecasting of timestamp column is <br/>-- needed while insrerting the data</span></pre><p id="7b51" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们也使用<code class="fe mq mr ms mt b">MERGE</code>语句来插入数据。我们将在后面详细讨论完整的<code class="fe mq mr ms mt b">MERGE</code>命令。</p><pre class="ln lo lp lq gt ng mt nh bn ni nj bi"><span id="6a18" class="nk kj in mt b be nl nm l nn no">-- Insert the records which are not present in account and present in <br/>-- monthly_accounts_update<br/>-- Here monthly_accounts_update can be a normal Athena table or Icb table but account must bean Iceberg table<br/>MERGE INTO accounts t USING monthly_accounts_update s<br/>    ON (t.customer = s.customer)<br/>    WHEN NOT MATCHED<br/>        THEN INSERT (customer, purchases, address)<br/>              VALUES(s.customer, s.purchases, s.address)</span></pre><p id="bea3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用<code class="fe mq mr ms mt b">MERGE</code>时，需要注意的是，当单个目标表行匹配多个源行时会出现错误。因此，请确保您在这里有一对一的加入。如果源表有重复项，您可以使用重复数据删除，如下所示</p><pre class="ln lo lp lq gt ng mt nh bn ni nj bi"><span id="64ff" class="nk kj in mt b be nl nm l nn no">MERGE INTO accounts t USING <br/>( with rw as(select *,row_number() over(partition by customer,purchases,address) rn <br/>from monthly_accounts_update)<br/>select customer,purchases,address from rw where rn = 1) as s<br/>    ON (t.customer = s.customer)<br/>    WHEN NOT MATCHED<br/>        THEN INSERT (customer, purchases, address)<br/>              VALUES(s.customer, s.purchases, s.address)</span></pre><h2 id="6375" class="mu kj in bd kk mv mw dn ko mx my dp ks jv mz na kw jz nb nc la kd nd ne le nf bi translated">删除</h2><p id="126d" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">有<code class="fe mq mr ms mt b">DELETE</code>命令，但它非常有限，不能用于连接或嵌套其他表。只能与如下静态值一起使用</p><pre class="ln lo lp lq gt ng mt nh bn ni nj bi"><span id="a2c5" class="nk kj in mt b be nl nm l nn no">DELETE FROM iceberg_table WHERE category='c3'</span></pre><p id="fd93" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要在查看其他表的基础上正确删除行，可以使用<code class="fe mq mr ms mt b">MERGE</code></p><pre class="ln lo lp lq gt ng mt nh bn ni nj bi"><span id="15be" class="nk kj in mt b be nl nm l nn no">-- deletes all customers from table accounts that are in the source table monthly_accounts_update.<br/>-- also,monthly_accounts_update can be a normal Athena table or Icb table but account must bean Iceberg table<br/>MERGE INTO accounts t USING monthly_accounts_update s<br/>ON t.customer = s.customer<br/>WHEN MATCHED<br/>THEN DELETE</span></pre><h2 id="34cf" class="mu kj in bd kk mv mw dn ko mx my dp ks jv mz na kw jz nb nc la kd nd ne le nf bi translated">更新</h2><p id="0306" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">就像 delete 一样，只有非常有限的<code class="fe mq mr ms mt b">UPDATE</code>语句只能用于静态值</p><pre class="ln lo lp lq gt ng mt nh bn ni nj bi"><span id="3ed7" class="nk kj in mt b be nl nm l nn no">UPDATE iceberg_table SET category='c4' WHERE category='c1'</span></pre><p id="f2ac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们又有了更多用例的<code class="fe mq mr ms mt b">MERGE</code>。我们上面讨论的插入/删除的所有条件在这里都适用。</p><pre class="ln lo lp lq gt ng mt nh bn ni nj bi"><span id="da74" class="nk kj in mt b be nl nm l nn no">MERGE INTO accounts t USING monthly_accounts_update s<br/>    ON (t.customer = s.customer)<br/>    WHEN MATCHED<br/>        THEN UPDATE<br/>            SET purchases = s.purchases + t.purchases, address = s.address</span></pre><h1 id="75e8" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">Merge 语句</h1><p id="da5b" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">正如我们看到的，上面的<code class="fe mq mr ms mt b">MERGE</code>是一个强大的命令，可以有条件地更新、删除或插入冰山表中的行。</p><p id="2869" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">命令结构如下:</p><pre class="ln lo lp lq gt ng mt nh bn ni nj bi"><span id="a3da" class="nk kj in mt b be nl nm l nn no">MERGE INTO target_table as target_alias <br/>USING { source_table or query } as source_alias <br/>ON {join condition to join s and t}<br/>WHEN MATCHED [ AND condition ] <br/>    THEN DELETE / UPDATE<br/>WHEN NOT MATCHED [ AND condition ]<br/>    THEN INSERT <br/></span></pre><ul class=""><li id="1829" class="mc md in jm b jn jo jr js jv me jz mf kd mg kh mh mi mj mk bi translated"><code class="fe mq mr ms mt b">MERGE</code>支持任意数量的具有不同<code class="fe mq mr ms mt b">MATCHED</code>条件的<code class="fe mq mr ms mt b">WHEN</code>子句。条件子句执行由<code class="fe mq mr ms mt b">MATCHED</code>状态和匹配条件选择的第一个<code class="fe mq mr ms mt b">WHEN</code>子句中的<code class="fe mq mr ms mt b">DELETE</code>、<code class="fe mq mr ms mt b">UPDATE</code>或<code class="fe mq mr ms mt b">INSERT</code>操作。</li><li id="5dd2" class="mc md in jm b jn ml jr mm jv mn jz mo kd mp kh mh mi mj mk bi translated">如果源行与任何<code class="fe mq mr ms mt b">WHEN</code>子句都不匹配，并且没有<code class="fe mq mr ms mt b">WHEN NOT MATCHED</code>子句，则源行被忽略。</li></ul><p id="1629" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是一个完整的例子:</p><pre class="ln lo lp lq gt ng mt nh bn ni nj bi"><span id="577f" class="nk kj in mt b be nl nm l nn no">MERGE INTO accounts t USING monthly_accounts_update s<br/>    ON (t.customer = s.customer)<br/>-- deletes any matching target row for which the source address is Centreville.<br/>    WHEN MATCHED AND s.address = 'Centreville'<br/>        THEN DELETE<br/>    WHEN MATCHED<br/>        THEN UPDATE<br/>            SET purchases = s.purchases + t.purchases, address = s.address<br/>    WHEN NOT MATCHED<br/>        THEN INSERT (customer, purchases, address)<br/>              VALUES(s.customer, s.purchases, s.address)</span></pre><h1 id="32cc" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">结论</h1><p id="a532" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">数据团队使用昂贵的仓库解决方案的主要原因之一是行级事务。随着像 Iceberg 这样的表格式的出现，开放式数据湖的能力大大增强，现在我们可以重新考虑数据堆栈，使其更具成本效益。</p></div></div>    
</body>
</html>