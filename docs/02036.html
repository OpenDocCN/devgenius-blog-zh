<html>
<head>
<title>Python Decorators — Everything You Need to Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">python Decorators——你需要知道的一切</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/everything-you-need-to-know-about-python-decorators-f066f6abbbcb?source=collection_archive---------13-----------------------#2020-07-17">https://blog.devgenius.io/everything-you-need-to-know-about-python-decorators-f066f6abbbcb?source=collection_archive---------13-----------------------#2020-07-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="9c91" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是一个关于 Python decorators 的结构、目的和实际应用的内容丰富的教程，提供了大量的程序代码示例。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a13db5fb9349857cc129146e095412bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z5J0AiGci0T47mLQ9TrYWQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者插图</figcaption></figure><p id="3578" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这篇装饰者指南中，我们将回顾它们是什么，如何创建和使用它们。根据定义，装饰器是一个函数，它接受另一个函数并扩展后者的行为，而不显式地改变它。在本教程中，我们将尝试理解这意味着什么以及它是如何实现的。</p><h1 id="1a2b" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">1.先决条件—功能</h1><p id="21b3" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">在我们开始理解 decorators 之前，让我们先谈一点对他们的理解很重要的函数的属性。</p><h2 id="f018" class="mb kz in bd la mc md dn le me mf dp li jv mg mh lm jz mi mj lq kd mk ml lu mm bi translated">1.1.将函数作为参数传递</h2><p id="97ec" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">在 Python 中，函数可以像任何其他对象一样作为参数传递和使用。考虑以下三个函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="4921" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里的<code class="fe mp mq mr ms b">say_hello()</code> <strong class="jm io"> </strong>和<code class="fe mp mq mr ms b">be_awersome()</code> <strong class="jm io"> </strong>是接收一个字符串变量名的普通函数。函数<code class="fe mp mq mr ms b">greet_john()</code> <strong class="jm io"> </strong>接收另一个函数作为参数，例如，<strong class="jm io"> </strong> <code class="fe mp mq mr ms b">say_hello()</code>或<code class="fe mp mq mr ms b">be_awesome()</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="13ff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当作为参数传递时，函数名不带括号，只传递对函数的引用。直到函数被调用<code class="fe mp mq mr ms b">greet_john()</code>，函数本身才被执行。</p><h2 id="e8ef" class="mb kz in bd la mc md dn le me mf dp li jv mg mh lm jz mi mj lq kd mk ml lu mm bi translated">1.2.内部功能</h2><p id="93f8" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">定义在其他函数内部的函数称为内部函数。具有两个内部函数的函数示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="5a9d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">函数被调用<code class="fe mp mq mr ms b">parent()</code>会发生什么？停下来想想。输出如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="e2ce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请注意，内部函数的定义顺序并不重要。只有当函数被调用时，打印才会发生。</p><p id="b2c0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在调用父函数之前，不会定义内部函数。也就是说，它们是局部受限的<code class="fe mp mq mr ms b">parent()</code>，只存在于其中，作为局部变量。当在边界外调用函数<code class="fe mp mq mr ms b">first_child()</code>，<code class="fe mp mq mr ms b">parent()</code>时，我们会得到一个错误:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><h2 id="2827" class="mb kz in bd la mc md dn le me mf dp li jv mg mh lm jz mi mj lq kd mk ml lu mm bi translated">1.3.从函数返回函数</h2><p id="9f77" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">Python 允许将函数用作返回值。以下示例返回外部函数<code class="fe mp mq mr ms b">parent()</code>的内部函数之一:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="2db4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">语句<code class="fe mp mq mr ms b">return</code>返回对函数的引用，也就是说，函数的名字是不带括号指定的(否则将返回函数执行的结果)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="68c7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在给定的例子中，<code class="fe mp mq mr ms b">first</code>和<code class="fe mp mq mr ms b">second</code>是变量，其中对本地函数<code class="fe mp mq mr ms b">first_child()</code>和<code class="fe mp mq mr ms b">second_child()</code>的引用被写成<code class="fe mp mq mr ms b">parent()</code>。现在<code class="fe mp mq mr ms b">first</code> it <code class="fe mp mq mr ms b">second</code>可以作为普通函数使用，尽管它们指向的函数不能直接访问:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="09f0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意，在前面关于内部函数的部分中，我们没有访问<code class="fe mp mq mr ms b">first_child()</code>的权限。在上一个例子中，我们收到了每个函数的链接，以后可以调用它们。</p></div><div class="ab cl mt mu hr mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ig ih ii ij ik"><h1 id="ad5d" class="ky kz in bd la lb na ld le lf nb lh li lj nc ll lm ln nd lp lq lr ne lt lu lv bi translated">2.简单的装饰者💅</h1><h2 id="7093" class="mb kz in bd la mc md dn le me mf dp li jv mg mh lm jz mi mj lq kd mk ml lu mm bi translated">2.1.总体思路:运用函数知识</h2><p id="e372" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">既然我们已经看到了 Python 中的函数就像任何其他对象一样，那么我们就更容易理解 decorators 的“魔力”了。让我们用一个假的例子来说明这个想法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="4e9b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你知道叫<code class="fe mp mq mr ms b">say_where()</code>会发生什么吗？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="9219" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了理解发生了什么，让我们回头看看前面的例子。我们只是运用了目前为止所学的一切。装饰发生在最后一行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="4d13" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将函数<code class="fe mp mq mr ms b">my_decorator()</code>的引用传递给函数<code class="fe mp mq mr ms b">say_whee</code>。B <code class="fe mp mq mr ms b">my_decorator()</code>有一个内部函数<code class="fe mp mq mr ms b">wrapper()</code>在<code class="fe mp mq mr ms b">return</code>外部函数语句中被引用。因此，我们将<code class="fe mp mq mr ms b">my_decorator()</code>一个<em class="nf">链接</em>作为一个参数传递给一个函数，并接收一个返回到其包装函数的链接。</p><p id="b936" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在的名字<code class="fe mp mq mr ms b">say_whee</code>指向内部函数<code class="fe mp mq mr ms b">wrapper</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="7dcb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，它<code class="fe mp mq mr ms b">wrapper()</code>包含对原始<code class="fe mp mq mr ms b">say_whee()</code>的引用，并在两次调用<code class="fe mp mq mr ms b">print()</code>之间调用该函数。</p><blockquote class="ng nh ni"><p id="394e" class="jk jl nf jm b jn jo jp jq jr js jt ju nj jw jx jy nk ka kb kc nl ke kf kg kh ig bi translated"><strong class="jm io">简单来说:</strong></p><p id="b681" class="jk jl nf jm b jn jo jp jq jr js jt ju nj jw jx jy nk ka kb kc nl ke kf kg kh ig bi translated">装饰者包装一个函数，改变它的行为。</p></blockquote><p id="d866" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们添加扬声器。考虑说明装饰者动态行为的第二个例子。让我们让我们的函数尖叫“万岁！”只有在白天。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="d592" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">装饰函数<code class="fe mp mq mr ms b">say_whee()</code>只有在 8:00 到 22:00 之间运行时<code class="fe mp mq mr ms b">"Whee!"</code>才会输出(为了检查行为上的差异，“扭转箭头”)⏰).</p><h2 id="c7e4" class="mb kz in bd la mc md dn le me mf dp li jv mg mh lm jz mi mj lq kd mk ml lu mm bi translated">2.2.一点句法糖！🍭</h2><p id="567a" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">坦白说，我们装饰的方式看起来很尴尬。在上一个例子中，我们使用了这个名字三次<code class="fe mp mq mr ms b">say_whee</code>:在定义原始函数的时候，在传递对函数的引用的时候，<code class="fe mp mq mr ms b">not_during_the_night()</code>，以及在覆盖这个名字来创建对装饰器的引用的时候。</p><p id="e39b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了不做这种无聊的事，在 Python 中你可以使用符号<code class="fe mp mq mr ms b">@</code>创建一个装饰器。以下代码相当于我们看到的第一个示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="3619" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">也就是说，在函数定义之前的指令<code class="fe mp mq mr ms b">@my_decorator,</code>是等同于指令<code class="fe mp mq mr ms b">say_whee = my_decorator(say_whee)</code>的<code class="fe mp mq mr ms b">say_whee()</code>。</p><h2 id="09dd" class="mb kz in bd la mc md dn le me mf dp li jv mg mh lm jz mi mj lq kd mk ml lu mm bi translated">2.3.重用装饰者</h2><p id="e11d" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">像任何其他函数一样，装饰器可以放在一个单独的模块中，用于各种目的。例如，创建一个包含以下内容的文件<code class="fe mp mq mr ms b">decorators.py</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="8607" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们从模块中导入函数，并将它用作装饰器。通过调用修饰函数，我们得到原始函数被执行两次:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure></div><div class="ab cl mt mu hr mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ig ih ii ij ik"><h1 id="6bf9" class="ky kz in bd la lb na ld le lf nb lh li lj nc ll lm ln nd lp lq lr ne lt lu lv bi translated">结论</h1><p id="93ab" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">恭喜你，你已经到达文章的结尾了！🎖️</p><p id="89c2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在你知道了:</p><ul class=""><li id="5f0c" class="nm nn in jm b jn jo jr js jv no jz np kd nq kh nr ns nt nu bi translated">如何创建函数和类装饰器？</li><li id="424a" class="nm nn in jm b jn nv jr nw jv nx jz ny kd nz kh nr ns nt nu bi translated">如何将参数传递给 decorators 并从中返回值。</li><li id="c7dd" class="nm nn in jm b jn nv jr nw jv nx jz ny kd nz kh nr ns nt nu bi translated">为什么装修工要用@ functools.wraps。</li><li id="b16e" class="nm nn in jm b jn nv jr nw jv nx jz ny kd nz kh nr ns nt nu bi translated">如何使用嵌套装饰器？</li></ul><p id="b321" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">装修工的定义没有什么魔力。通常，一切都旨在创建一个充当包装器的函数或类。为了传递参数，通常使用符号<code class="fe mp mq mr ms b">*args</code>和<code class="fe mp mq mr ms b">**kwargs</code>。而符号<code class="fe mp mq mr ms b">@</code>的使用只是语法糖，方便了 decorators 的调用。</p><p id="313d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">装饰者可以非常方便地修改函数和类的行为，为它们的处理创建额外的逻辑。此外，这种修改模式很容易使用嵌套的装饰器相互叠加。要删除装饰，只需删除提到装饰者的那一行。</p><p id="016d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要更深入地了解 decorator，请查看历史<a class="ae oa" href="https://www.python.org/dev/peps/pep-0318/" rel="noopener ugc nofollow" target="_blank"> PEP 318 </a>，以及<a class="ae oa" href="https://wiki.python.org/moin/PythonDecorators" rel="noopener ugc nofollow" target="_blank"> Python decorator wiki 页面</a>。</p><p id="a7ff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第三方<a class="ae oa" href="https://realpython.com/primer-on-python-decorators/" rel="noopener ugc nofollow" target="_blank">装饰器</a>模块也将帮助你创建你自己的装饰器。它的<a class="ae oa" href="https://github.com/micheles/decorator/blob/master/docs/documentation.md" rel="noopener ugc nofollow" target="_blank">文档</a>包含了更多使用 decorators 的例子。</p></div></div>    
</body>
</html>