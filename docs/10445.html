<html>
<head>
<title>React.memo and useMemo explained in the right way: You should know this</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React.memo 和 useMemo 用正确的方式解释:你应该知道这个</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/react-memo-and-usememo-explained-in-the-right-way-you-should-know-this-af10a805e620?source=collection_archive---------1-----------------------#2022-11-02">https://blog.devgenius.io/react-memo-and-usememo-explained-in-the-right-way-you-should-know-this-af10a805e620?source=collection_archive---------1-----------------------#2022-11-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/6629cfde583aea947f82edf03e0b5933.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dNaW1CID8rDNX-bdrjdeTw.png"/></div></div></figure><p id="9bbc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这篇博客中，我们将了解<strong class="jx io"> React.memo </strong>和<strong class="jx io"> useMemo </strong> hook。我们将从介绍开始，然后举一些例子，看看什么时候使用哪一个。</p><p id="7b7f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们开始使用<strong class="jx io"> React.memo </strong>和<strong class="jx io"> useMemo </strong>之前，我们首先需要了解<a class="ae kt" href="https://rajeshi.medium.com/learn-memoization-in-javascript-to-optimize-your-code-653dc5cb36cc" rel="noopener"> <strong class="jx io">什么是记忆化？</strong> </a> <strong class="jx io"> </strong>然后我们将推进记忆化的反应概念。</p><h1 id="f69d" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">记忆入门</h1><p id="33a1" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">记忆化是一种优化技术，在这种技术中，代价高昂的函数调用的结果或输出会被缓存，以便下次使用相同的输入调用该函数时可以立即返回结果。</p><p id="43ab" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">简单地说，我们用给定的输入运行一次函数，然后在某个地方缓存/存储它的结果。因此，下次用相同的输入调用函数时，我们只需返回存储的值，而不是再次运行整个函数。</p><p id="9cfe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过不再运行整个函数，我们节省了一些计算时间，因此我们最终使我们的代码更快。点击<a class="ae kt" href="https://rajeshi.medium.com/learn-memoization-in-javascript-to-optimize-your-code-653dc5cb36cc" rel="noopener"> <strong class="jx io">这里</strong> </a>可以阅读更多关于记忆化的内容</p><h1 id="57de" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">React 中的重渲染和记忆介绍？</h1><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lx"><img src="../Images/0d6098470992f3e5446f792321e5d8ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vrwOjcZCNJL2yb7m"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">Pierre chtel-Innocenti 在<a class="ae kt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="c100" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了更好地理解 React 中的记忆，您需要知道 React 何时重新渲染组件。</p><p id="285b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当道具或状态改变时，React 重新渲染组件。当一个组件被重新渲染时，所有的子组件也将被重新渲染。</p><h1 id="dd5e" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">重新渲染组件的问题是</h1><p id="c6d5" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">重新呈现组件意味着重新呈现所有子组件，尽管子组件的属性和状态可能不会改变，它将返回与以前相同的输出。组件重新渲染经历了一个复杂的计算过程。</p><p id="aa8d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">重新渲染子组件而不改变其属性或状态是一个性能缺陷。这会降低我们代码的性能。为了解决这个问题，React 引入了名为 React.memo 的高阶组件</p><h1 id="065e" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">React.memo 简介</h1><p id="8b26" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">React 组件只是基于某些计算返回 JSX 的 JavaScript 函数。所以 react 为我们提供了 React.memo 来记忆组件。这防止了组件的重新渲染，并且仅在依赖项(如道具)发生变化时才允许。</p><h1 id="c217" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">何时记忆反应成分？</h1><p id="74af" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">最好只在组件很重并且有一些复杂的计算要执行时才进行记忆。您不应该在每个组件中都使用内存化，因为内存化会占用内存，在某些情况下会降低性能。</p><h1 id="c979" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">何时不要记忆反应成分？</h1><p id="ea18" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">当组件计算不够复杂并且道具不断变化而组件不能接收相同的道具时，应该避免使用 React.memo。</p><h1 id="fa96" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">如何在 react 组件中实现记忆化？</h1><blockquote class="mg"><p id="c076" class="mh mi in bd mj mk ml mm mn mo mp ks dk translated">首先，让我们看一个没有实现记忆的例子。</p></blockquote><blockquote class="mq mr ms"><p id="5fe3" class="jv jw mt jx b jy mu ka kb kc mv ke kf mw mx ki kj my mz km kn na nb kq kr ks ig bi translated"><strong class="jx io"> App.js 组件(父级)</strong></p></blockquote><figure class="ly lz ma mb gt jo"><div class="bz fp l di"><div class="nc nd l"/></div></figure><blockquote class="mq mr ms"><p id="b13e" class="jv jw mt jx b jy jz ka kb kc kd ke kf mw kh ki kj my kl km kn na kp kq kr ks ig bi translated"><strong class="jx io"> Child.js 组件(子组件)</strong></p></blockquote><figure class="ly lz ma mb gt jo"><div class="bz fp l di"><div class="nc nd l"/></div></figure><blockquote class="mq mr ms"><p id="be3a" class="jv jw mt jx b jy jz ka kb kc kd ke kf mw kh ki kj my kl km kn na kp kq kr ks ig bi translated"><strong class="jx io">输出</strong></p></blockquote><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ne"><img src="../Images/831e686d8020a9e73eaeef18dd4c1b03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TB_smlwt5-RV_QWeKUPMdw.png"/></div></div></figure><p id="ec69" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如您所见，当我们单击“添加父数据”按钮时，它也会呈现子组件。但是子组件的道具和前面的一样。因此子组件不应再次重新呈现。</p><blockquote class="mg"><p id="3f9b" class="mh mi in bd mj mk ml mm mn mo mp ks dk translated">对子组件实现记忆</p></blockquote><blockquote class="mq mr ms"><p id="1c00" class="jv jw mt jx b jy mu ka kb kc mv ke kf mw mx ki kj my mz km kn na nb kq kr ks ig bi translated">App.js 组件将完全相同。我们只需要记住子组件。</p><p id="964c" class="jv jw mt jx b jy jz ka kb kc kd ke kf mw kh ki kj my kl km kn na kp kq kr ks ig bi translated"><strong class="jx io"> Child.js 组件</strong></p></blockquote><figure class="ly lz ma mb gt jo"><div class="bz fp l di"><div class="nc nd l"/></div></figure><blockquote class="mq mr ms"><p id="6ae5" class="jv jw mt jx b jy jz ka kb kc kd ke kf mw kh ki kj my kl km kn na kp kq kr ks ig bi translated"><strong class="jx io">输出</strong></p></blockquote><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/9e7a54cf0dc4dba7de964c5d5510b0eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jL1oDNeWN_HHk5_vFvPbnQ.png"/></div></div></figure><p id="e36b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在你可以看到，当我们多次点击“添加父数据”按钮时，只有父组件得到重新呈现，而不是子组件。仅当页面被加载并且子组件的属性或状态被改变时，子组件才被呈现</p><h2 id="a5e6" class="ng kv in bd kw nh ni dn la nj nk dp le kg nl nm li kk nn no lm ko np nq lq nr bi translated">React.memo 的缺点</h2><p id="0e19" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">默认情况下，React.memo 对道具做了简单的比较。这意味着它只检查顶层属性是否改变。您可以添加第二个参数来自定义 props 比较。</p><pre class="ly lz ma mb gt ns nt nu nv aw nw bi"><span id="4e87" class="ng kv in nt b gy nx ny l nz oa">React.memo(Component, [areEqual(prevProps, nextProps)]);</span></pre><blockquote class="mg"><p id="b226" class="mh mi in bd mj mk ob oc od oe of ks dk translated">随着 React.memo 被排序，现在让我们转向 useMemo，看看它是什么</p></blockquote><figure class="oh oi oj ok ol jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi og"><img src="../Images/c4051d5b5d3103c2b370139d4818e028.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mMlVd_B3QRkz-ih5"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">照片由<a class="ae kt" href="https://unsplash.com/@terra_gallery?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> TERRA </a>在<a class="ae kt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="f0ad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当一个组件经历重新渲染时，组件内部声明的每个函数都会被再次执行。可能有一个计算量很大的函数，但它经常得到相同的输入，因此返回相同的输出。</p><p id="e813" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这种情况下，我们可以在组件内部记忆函数，而不是在每个组件重新渲染时执行函数，从而提高应用程序的性能。这可以通过使用 useMemo()钩子来实现。</p><h1 id="27d2" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">什么是 useMemo 挂钩？</h1><p id="7d8a" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">useMemo 钩子可以用来防止昂贵的、资源密集的函数不必要地在组件内部运行，从而导致相同的输出。</p><h2 id="a4cb" class="ng kv in bd kw nh ni dn la nj nk dp le kg nl nm li kk nn no lm ko np nq lq nr bi translated">你需要传递两个东西来使用 Memo: </h2><ol class=""><li id="4a67" class="om on in jx b jy ls kc lt kg oo kk op ko oq ks or os ot ou bi translated">需要记忆的昂贵功能。</li><li id="2a8d" class="om on in jx b jy ov kc ow kg ox kk oy ko oz ks or os ot ou bi translated">一个依赖数组，包含了你的组件中每一个在你的昂贵函数中使用的值。</li></ol><pre class="ly lz ma mb gt ns nt nu nv aw nw bi"><span id="4206" class="ng kv in nt b gy nx ny l nz oa">import { useMemo } from 'react';<br/>const value = useMemo(() =&gt; expensiveFunction(param), [param]);</span></pre><h1 id="c5b5" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">如何在函数中实现 useMemo？</h1><blockquote class="mg"><p id="c43c" class="mh mi in bd mj mk ml mm mn mo mp ks dk translated">首先，让我们看一个没有实现 useMemo 的例子。</p></blockquote><blockquote class="mq mr ms"><p id="776a" class="jv jw mt jx b jy mu ka kb kc mv ke kf mw mx ki kj my mz km kn na nb kq kr ks ig bi translated"><strong class="jx io"> App.js 组件</strong></p></blockquote><figure class="ly lz ma mb gt jo"><div class="bz fp l di"><div class="nc nd l"/></div></figure><blockquote class="mq mr ms"><p id="3152" class="jv jw mt jx b jy jz ka kb kc kd ke kf mw kh ki kj my kl km kn na kp kq kr ks ig bi translated">钩子组件. js</p></blockquote><figure class="ly lz ma mb gt jo"><div class="bz fp l di"><div class="nc nd l"/></div></figure><blockquote class="mq mr ms"><p id="5b9c" class="jv jw mt jx b jy jz ka kb kc kd ke kf mw kh ki kj my kl km kn na kp kq kr ks ig bi translated"><strong class="jx io">输出</strong></p></blockquote><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi pa"><img src="../Images/e27e272ec9dd399202bdde001c48b2d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gfm-WTivRirXYQ5NMA_sbA.png"/></div></div></figure><p id="7866" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如你所见，当我们点击“加载更多鞋子”按钮时，totalTshirts 函数被执行，因为组件被重新渲染。在这里，我们清楚地知道，当单击“Load more Shoes”按钮时，totalTshirts 函数将给出与之前相同的输出。所以我们可以记住这个 totalTshirts 函数并优化我们的代码。</p><blockquote class="mg"><p id="fdba" class="mh mi in bd mj mk ml mm mn mo mp ks dk translated">对 HookComponent 实现 useMemo</p></blockquote><blockquote class="mq mr ms"><p id="207e" class="jv jw mt jx b jy mu ka kb kc mv ke kf mw mx ki kj my mz km kn na nb kq kr ks ig bi translated">App.js 组件将完全相同。我们只需要记住 HookComponent.js。</p><p id="599c" class="jv jw mt jx b jy jz ka kb kc kd ke kf mw kh ki kj my kl km kn na kp kq kr ks ig bi translated"><strong class="jx io"> HookComponent.js 组件</strong></p></blockquote><figure class="ly lz ma mb gt jo"><div class="bz fp l di"><div class="nc nd l"/></div></figure><blockquote class="mq mr ms"><p id="64ae" class="jv jw mt jx b jy jz ka kb kc kd ke kf mw kh ki kj my kl km kn na kp kq kr ks ig bi translated"><strong class="jx io">输出</strong></p></blockquote><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi pb"><img src="../Images/5843312d9d1e545876f0bc77c66e9b00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kbDOVJWkIWmMDkNEOw6NZA.png"/></div></div></figure><p id="c007" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，当我们多次点击“加载更多鞋子”按钮时，memoizedTotalTshirts 函数没有被执行，它只在页面加载时运行了一次。</p><h1 id="9b06" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">React.memo 和 useMemo 挂钩的主要区别</h1><ol class=""><li id="4f13" class="om on in jx b jy ls kc lt kg oo kk op ko oq ks or os ot ou bi translated">React.memo 是一个高阶组件，用来记忆整个功能组件。</li><li id="e6e0" class="om on in jx b jy ov kc ow kg ox kk oy ko oz ks or os ot ou bi translated">useMemo 是一个 react 钩子，用来在一个功能组件中记忆一个函数。</li></ol><p id="03d7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">感谢你读到这里。我希望现在你明白了记忆在反应中的重要性。</strong></p><h1 id="5893" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">如果你想要更多这样的内容，请在媒体上关注我，并订阅我的 YouTube 频道。</h1><h1 id="acb4" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">有疑问吗？通过推特<a class="ae kt" href="https://twitter.com/izrajesh" rel="noopener ugc nofollow" target="_blank">联系我</a></h1></div></div>    
</body>
</html>