<html>
<head>
<title>Improve your architecture by abstract your code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过抽象您代码来改进您的架构</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/improve-your-architecture-by-abstract-your-code-ad97fe9baf71?source=collection_archive---------3-----------------------#2022-03-18">https://blog.devgenius.io/improve-your-architecture-by-abstract-your-code-ad97fe9baf71?source=collection_archive---------3-----------------------#2022-03-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2834f882c0719223ad0c23d1222b3e18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qAAVgGP1Plzt5TIHKcNghw.png"/></div></div></figure><p id="3119" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> Info 注:</strong>本文并不呈现所有代码，尤其是 UI 实现，其重点是业务逻辑和架构。别担心，你可以在这里访问所有的代码和资源<a class="ae kw" href="https://github.com/iOSifMol/AbstractCode" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="e8b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我想向你展示一种在可重用性、封装甚至测试方面改进你的代码架构的方法。我的建议是抽象你的代码，使之基于协议。在应用程序级别，你的代码代表了你定义的实际对象(模型)的具体世界，你越深入应用程序子层，这个世界就变得越抽象，越面向协议。换句话说，你的模型是抽象的，如果你可以这么说的话，类似于:模块 X 期望“某物”像这样运行，并返回“某物”像这样运行。</p><p id="0afc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你看到“某物”这个词，它指的是抽象的东西，但同时它在一些约束之间起作用。在编码过程中，协议很好地表现了有约束的东西。例如，<code class="fe le lf lg lh b">Equatable</code>协议允许相等比较，但是它约束符合它的类型，以覆盖<code class="fe le lf lg lh b">==</code>操作符。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="aa0b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们更实际一点，举一个真实的例子，看看这种基于协议的方法如何抽象您的代码。出于示例目的，我使用了一个纸牌游戏，它将与网络以及持久性存储交互。为简单起见，这个游戏将只画一手牌，每按一个按钮，然后将它保存到数据库中。所以你可以在以后继续从同一副牌中抽牌。我将使用<a class="ae kw" href="https://deckofcardsapi.com/" rel="noopener ugc nofollow" target="_blank">deckofcardsapi.com</a>API 来获得创建一副牌、抽一手牌和重新洗牌的支持，至于持久存储，我将使用 CoreData。架构图可能如下所示:</p><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi li"><img src="../Images/6ac5723645a04b318a5c9f0f3b45d951.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GKET8MPlg90rDj-4LaVW4A.png"/></div></div></figure><p id="d262" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该应用程序依赖于三个子模块，一个负责所有服务器-应用程序通信的网络层，一个管理应用程序状态的持久层，以及最后但同样重要的一个抽象层，它定义了一系列约束和描述应用程序模型的协议。接下来，我们将在每个模块中选择一个 be one 进行研究。</p><h1 id="c7a9" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">模型</h1><p id="ea8b" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">模型层是一个 100%抽象的层，它定义了应用模型的外观和行为。在我们的例子中，纸牌游戏意味着三个协议。像一副牌一样的东西，像一手牌一样的东西，像一张牌一样的东西。这里我们有这些协议:</p><figure class="lj lk ll lm gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="0a03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的代码片段中，您可以观察到每个协议名称的后缀“able ”,以更好地表明它应该像一副牌、一只手等一样，而不是具体的东西。有了这三个定义，我们的应用模型就得到很好的描述。</p><h1 id="e73e" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated"><strong class="ak">联网</strong></h1><p id="bbac" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">就输出而言，网络层也是一个抽象层，同时也是一个通用层。它的作用是建立 api 和 app 之间的通信。api 规范:</p><figure class="lj lk ll lm gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="a8fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基于 api 规范，我定义了一个 enum 来描述所有的路线，比如:</p><figure class="lj lk ll lm gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="8d34" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Enum associated values 表示构成端点 URL 路径的实际参数，这样构成路径变得非常简单。一旦我们有了合适的路由，让我们看看 api 通信实际上是如何实现的:</p><figure class="lj lk ll lm gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="fec9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们有一个通用方法来覆盖所有的 api 调用，作为输入，它接收要执行的路由和来自响应的预期输出类型。方法输出返回一个<code class="fe le lf lg lh b">Result</code>,如果成功，它将传递预期的对象，另一方面，如果失败，它将传递一个适当的错误。这个方法的实现非常简单，它基于给定的路由创建一个<code class="fe le lf lg lh b">URL</code>,然后向 api 发送一个数据任务并解析响应。响应解析作为休闲完成:</p><figure class="lj lk ll lm gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h1 id="1ba1" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">持续疮</h1><p id="5a67" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">为了持久化状态，我使用了 CoreData，它需要具体的模型来保存状态。为了保持这个模块的抽象接口，我们必须创建一个系统来将输入和输出对象转换成 CoreData 对象或从 CoreData 对象转换过来。这个系统允许我们有一个很好的封装，所以模块接口对核心数据层没有依赖性。通过一些小步骤，让我们看看模型是什么样子，包装系统是如何工作的。</p><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/e53ee51cf64ab54ee32bddb62e94e949.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*4KNSjmM8KZ74KY6kMlgyTQ.png"/></div></figure><figure class="lj lk ll lm gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="7ce7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从 DBHand / DBCard 转换到 cartable/hand able 的包装系统是在提供两种方法的扩展中完成的:</p><ul class=""><li id="f1ca" class="mt mu iq ka b kb kc kf kg kj mv kn mw kr mx kv my mz na nb bi translated"><code class="fe le lf lg lh b">cardable</code> / <code class="fe le lf lg lh b">handable</code>将核心数据对象转换成抽象对象；</li><li id="94aa" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated"><code class="fe le lf lg lh b">create</code>从给定抽象对象创建核心数据对象并将其插入到当前上下文中；</li></ul><p id="9bc2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在代码数据模型已经就绪，我们可以转到实际的数据库实现了:</p><figure class="lj lk ll lm gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="68ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">DB 实现也很简单，我们有助手方法来创建持久存储和获取当前上下文。接下来我们有公共方法，一个从数据库中拉出一只手，另一个保存它。</p><h1 id="1f44" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">应用</h1><p id="a9f1" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">这是混凝土世界的顶层。在这里，我们的抽象模型获得了生命。我们只需要遵守我们创建的协议，一切都会好的。</p><figure class="lj lk ll lm gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="75e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这么简单，只是一个简单的定义，一切都是有联系的。利用我们刚刚创建的层也很简单:</p><figure class="lj lk ll lm gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h1 id="3e06" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">结论</h1><p id="7d54" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">抽象代码有很多好处。我们明确区分了具体层和抽象层，这也是拥有单组模型(来自应用程序的模型)的优势，所有子模块都依赖于抽象协议。提供了良好的封装，例如 DB 模块，其中所有的 CoreData 实现都隐藏在接口之外。最后但并非最不重要的一点是，它为测试提供了良好的结构，您可以在单元测试中定义具体的模拟模型。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="e49e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">希望你喜欢这篇文章，并找到有用的信息。别忘了你在这里有所有可用的资源。</p></div></div>    
</body>
</html>