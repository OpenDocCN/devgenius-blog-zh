<html>
<head>
<title>Unit Test Networking Code in Swift Without Making Loads of Mock Classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift中对网络代码进行单元测试，而无需创建大量模拟类</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/unit-test-networking-code-in-swift-without-making-loads-of-mock-classes-74489d0b12a8?source=collection_archive---------0-----------------------#2020-07-27">https://blog.devgenius.io/unit-test-networking-code-in-swift-without-making-loads-of-mock-classes-74489d0b12a8?source=collection_archive---------0-----------------------#2020-07-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="59f0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">子类化URLProtocol以模拟URLSession网络请求</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/98e835adac456ab74c518b877dbb07b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YECeOxlko9KoOJNw8RNm3A.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">艾莉娜·格鲁布尼亚克在<a class="ae ky" href="https://unsplash.com/s/photos/network?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="e90f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">嗨，</p><p id="86df" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文中，我分享了一个在Swift中单元测试网络代码的简洁方法；其中我们将实现对URLSession网络请求的模拟，而不必为每个API构建大量模拟类。</p><h1 id="f74a" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">模仿网络请求的目的</h1><p id="3ba5" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">在单元测试网络代码时，模拟网络请求而不实际与服务器通信是标准的行业最佳实践。</p><p id="a7ee" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">造成这种情况的原因有很多，下面列出了一些原因-</p><ul class=""><li id="0779" class="mc md in jm b jn jo jr js jv me jz mf kd mg kh mh mi mj mk bi translated"><strong class="jm io">单元测试应该是快速可靠的。</strong>实际上与服务器通信不仅会使单元测试非常慢，而且由于依赖于互联网连接而不可靠。</li><li id="a08d" class="mc md in jm b jn ml jr mm jv mn jz mo kd mp kh mh mi mj mk bi translated">实际上与服务器通信会中断后端。例子:假设你正在单元测试网络代码来删除一个用户。对服务器进行实际的调用会导致用户的实际删除，我们不希望这样:P</li></ul><h1 id="8275" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">履行</h1><blockquote class="mq mr ms"><p id="e041" class="jk jl mt jm b jn jo jp jq jr js jt ju mu jw jx jy mv ka kb kc mw ke kf kg kh ig bi translated">注意:本文和实施仅适用于Swift中的<a class="ae ky" href="https://developer.apple.com/documentation/foundation/urlsession" rel="noopener ugc nofollow" target="_blank"> URLSession </a>。</p></blockquote><p id="3f70" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文中，我们将为URLSession使用<a class="ae ky" href="https://developer.apple.com/documentation/combine" rel="noopener ugc nofollow" target="_blank">Combine</a>dataTaskPublisher。但是，我们也可以使用标准的URLSession.dataTask来代替。概念保持不变。</p><p id="8e93" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们开始吧！</p><h2 id="5c78" class="mx la in bd lb my mz dn lf na nb dp lj jv nc nd ln jz ne nf lr kd ng nh lv ni bi translated">1.REST API网络类(起点)</h2><p id="fa6f" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">假设我们正在使用一个后端REST API来加载用户的概要文件。</p><p id="a7ac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们使用URLSession与这个后端API联网的类可能看起来像这样—</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="daaf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们在类中定义了一个方法“getProfile()”，它与后端API联网并返回用户。对于这个简单的例子，我们只需打印收到的用户名(第19行)。</p><p id="8b8f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以用这个类让用户简单地像这样—</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="11b0" class="mx la in nm b gy nq nr l ns nt"><strong class="nm io">Code<br/></strong>let profileAPI = ProfileAPI()<br/>profileAPI.getProfile()</span><span id="04a6" class="mx la in nm b gy nu nr l ns nt"><strong class="nm io">Sample Output<br/></strong>Yugantar</span></pre><h2 id="d6a2" class="mx la in bd lb my mz dn lf na nb dp lj jv nc nd ln jz ne nf lr kd ng nh lv ni bi translated">2.使REST API网络类可测试</h2><p id="cec0" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">我们的ProfileAPI类还不可测试，还不能进行模拟。</p><p id="6d88" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了能够模拟它，我们必须对它进行一些修改，之后最终的类可能看起来像这样—</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="d13c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了使ProfileAPI类可测试，我们做了两个主要的修改。</p><p id="737b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">引入URLSession类型的属性“session”—</strong></p><p id="9926" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们不再总是使用URLSession.shared进行联网，而是使用' Session '属性(第19行)。</p><p id="0e2d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">默认情况下，“session”将等于URLSession.shared (init方法)，因此，不需要每次都不必要地指定它或更新现有代码。</p><p id="91aa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，也可以在需要时注入不同的urlSession类型(例如，用于单元测试的定制模拟URL会话)。</p><p id="9877" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">声明一个完成处理程序，并在接收操作符中使用它— </strong></p><p id="d40c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在第18行，我们在getProfile()方法中声明了一个完成处理程序作为函数参数。然后在sink操作符中使用这个完成处理程序，代替print语句。</p><p id="2e08" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">完成处理程序已经被实现为一个<a class="ae ky" href="http://We need to build the project and login before running the test suite." rel="noopener ugc nofollow" target="_blank">转义闭包</a>；这很重要，因为URLSession和网络通常是高度异步的。</p><p id="60ad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用完成处理程序而不是直接在API类中定义我们的逻辑不仅有助于模块化，而且使其可测试。从现在开始，assert语句可以在我们的单元测试中的完成处理程序中使用。</p><p id="8a90" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">现在，使用类来获取用户看起来像这样— </strong></p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="645d" class="mx la in nm b gy nq nr l ns nt"><strong class="nm io">Code<br/></strong>let profileAPI = ProfileAPI()<br/>profileAPI.getProfile { user in<br/>    print(user.name)<br/>}</span><span id="eec2" class="mx la in nm b gy nu nr l ns nt"><strong class="nm io">Sample Output<br/></strong>Yugantar</span></pre><h2 id="d032" class="mx la in bd lb my mz dn lf na nb dp lj jv nc nd ln jz ne nf lr kd ng nh lv ni bi translated">3.子类URLProtocol用于模仿，并对我们的API类进行单元测试</h2><p id="fe4e" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">通常，为了实现模拟和测试网络代码，模拟类是为每个不直接与服务器通信的API类构建的。</p><p id="ca30" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这通常会导致代码的大量重复；正如您所想象的，随着API类数量的增加，这很容易变成一项麻烦的任务。</p><p id="20e3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">相反，Apple建议子类化URLProtocol来构建一个可以用于每个API类的MockURLProtocol。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/0430faaa09281b0523520253df87c7b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LF-fxujAL8XUe-gdTIWhJw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://developer.apple.com/videos/play/wwdc2018/417/" rel="noopener ugc nofollow" target="_blank">测试技巧&amp;技巧，WWDC18苹果开发者大会</a></figcaption></figure><p id="40e6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们在继承URLProtocol的基础上开发的MockURLProtocol是样板代码，所以让我们把这段代码添加到我们的测试用例文件中——</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><blockquote class="nw"><p id="5c23" class="nx ny in bd nz oa ob oc od oe of kh dk translated">我们现在都准备好了！让我们对我们的网络代码进行单元测试—</p></blockquote><figure class="og oh oi oj ok kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="1195" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们使用setUpWithError()方法来设置我们的自定义url会话以进行模仿(这也是样板文件，可以照原样复制)并分配它。</p><p id="5033" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们的测试方法(testGetProfile)中，我们为ProfileAPI类声明了一个对象，并在其中注入了我们的自定义url会话。</p><p id="4098" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">之后，我们设置我们期望在成功的请求上接收的自定义数据，并告诉MockURLProtocol返回该数据(我们在sink操作符中获得的数据)。</p><p id="5258" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的完成处理器得到这个数据(在sink中，我们做<code class="fe ol om on nm b">completion(user)</code>)。</p><p id="a6d5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们使用XCTestExpectation(用于测试异步代码)，并在断言语句之后的闭包中实现它(用于测试)。最后，我们稍微等待一下这个期望。我们完事了。</p><h1 id="170f" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">参考:</h1><p id="251a" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated"><a class="ae ky" href="https://developer.apple.com/videos/play/wwdc2018/417/" rel="noopener ugc nofollow" target="_blank">测试技巧&amp;窍门，WWDC18苹果开发者大会</a></p></div><div class="ab cl oo op hr oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="ig ih ii ij ik"><h1 id="774d" class="kz la in bd lb lc ov le lf lg ow li lj lk ox lm ln lo oy lq lr ls oz lu lv lw bi translated"><strong class="ak">感谢您的阅读！</strong></h1><p id="e024" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated"><em class="mt">请随时联系我并联系，查看我们的项目，或者加入我们的开源社区:<br/></em><a class="ae ky" href="https://www.linkedin.com/in/yugantar-jain-1a7820158/" rel="noopener ugc nofollow" target="_blank"><em class="mt">LinkedIn</em></a><em class="mt">，</em><a class="ae ky" href="http://github.com/yugantarjain" rel="noopener ugc nofollow" target="_blank"><em class="mt">GitHub</em></a><em class="mt">，</em> <a class="ae ky" href="https://github.com/anitab-org/mentorship-ios" rel="noopener ugc nofollow" target="_blank"> <em class="mt">导师iOS </em> </a> <em class="mt">，</em><a class="ae ky" href="https://anitab-org.zulipchat.com" rel="noopener ugc nofollow" target="_blank"><em class="mt">AnitaB.org社区</em> </a></p></div></div>    
</body>
</html>