<html>
<head>
<title>Python Up Your Code: Modules and Packages</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python Up 你的代码:模块和包</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/python-up-your-code-modules-and-packages-13b05ae04226?source=collection_archive---------11-----------------------#2022-07-05">https://blog.devgenius.io/python-up-your-code-modules-and-packages-13b05ae04226?source=collection_archive---------11-----------------------#2022-07-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="64ef" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">试图澄清“模块 vs 包”的困境</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bbcd12355bc14e6b91821096c81b2781.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4DgX8bxwDIfymX7xw0O8ww.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Jr Korpa 在<a class="ae kv" href="https://unsplash.com/s/photos/abstract?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="88bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文旨在阐明并正确界定这两个概念，因为对于什么使模块成为模块，什么构成 Python 中的实际包，似乎仍然存在某种程度的混淆。</p><h2 id="01f2" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">那么，Python 中的模块是什么？</h2><p id="f9ec" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">最简单的回答是:这是一个文件。仅此而已。一旦我们清除了这个文件，我们应该注意一些使这个文件成为真正的 Python 模块的特征:</p><ul class=""><li id="f5a7" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">它有通常的<code class="fe mz na nb nc b">py</code>扩展名(例如，<code class="fe mz na nb nc b">my_module.py</code>是模块名的一个很好的例子)；</li><li id="4c68" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated">它的名字(这更像是一种约定)应该很短，所有的小写字母和下划线都是允许的，如果它们能提高可读性的话。更多关于这个<a class="ae kv" href="https://peps.python.org/pep-0008/#package-and-module-names" rel="noopener ugc nofollow" target="_blank">这里</a>。其他类型的字符，比如连字符，或者几乎所有不能用于变量名的字符，在这里也是严格禁止的；</li><li id="a50b" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated">它包含 Python 定义(如类定义、函数定义等等)和/或语句。</li></ul><p id="4054" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们构建这样一个模块，然后看看如何很好地利用它:</p><ul class=""><li id="793a" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><strong class="ky ir"><em class="ni">my _ module . py:</em></strong></li></ul><pre class="kg kh ki kj gt nj nc nk nl aw nm bi"><span id="c0d0" class="ls lt iq nc b gy nn no l np nq"><strong class="nc ir">def</strong> my_func():<br/>    <strong class="nc ir">print</strong>("Hello from my_func!")</span><span id="37af" class="ls lt iq nc b gy nr no l np nq"><strong class="nc ir"><br/>def</strong> my_other_func():<br/>    <strong class="nc ir">print</strong>("Hello from my_other_func!")</span></pre><p id="3a05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，为了使用它，我们需要把它<code class="fe mz na nb nc b">import</code>融入到我们的工作中。因此，假设我们正在处理某个文件，该文件应该使用我们刚刚构建的模块，并且该文件名为<code class="fe mz na nb nc b">hello_world.py</code>，下面是我们必须要做的事情:</p><ul class=""><li id="ec3e" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><strong class="ky ir"><em class="ni">hello _ world . py:</em></strong></li></ul><pre class="kg kh ki kj gt nj nc nk nl aw nm bi"><span id="02f4" class="ls lt iq nc b gy nn no l np nq"><em class="ni"># import the module into our global namespace<br/></em><strong class="nc ir">import</strong> my_module</span><span id="ec1a" class="ls lt iq nc b gy nr no l np nq"><em class="ni"><br/># run the functions contained in that module<br/></em>my_module.<strong class="nc ir">my_func</strong>()<br/>my_module.<strong class="nc ir">my_other_func</strong>()</span><span id="4afb" class="ls lt iq nc b gy nr no l np nq">Output:<br/>Hello from my_func!<br/>Hello from my_other_func!</span></pre><p id="eec2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们刚刚做的是<strong class="ky ir">将<code class="fe mz na nb nc b">my_module</code> Python 模块</strong>导入到我们的<code class="fe mz na nb nc b">hello_world.py</code>全局名称空间中(为了验证这一点，只需在 import 语句:<code class="fe mz na nb nc b"><strong class="ky ir">print</strong>(<strong class="ky ir">globals</strong>())</code>之后添加这个代码，它将向您显示全局名称空间中的所有标识符，包括<code class="fe mz na nb nc b">my_module</code>)。通过这个<code class="fe mz na nb nc b">my_module</code>标识符，我们现在可以访问包含在那个模块中的两个函数。</p><p id="373b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，正如我们刚才所做的，导入整个模块并不意味着函数本身是<strong class="ky ir">导入的</strong>。相反，它们可以通过全局名称空间中新添加的模块进行访问。</p><p id="2271" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以这样做的另一种方法如下:</p><pre class="kg kh ki kj gt nj nc nk nl aw nm bi"><span id="432c" class="ls lt iq nc b gy nn no l np nq"><em class="ni"># only import the function(s) that we need from the module<br/></em><strong class="nc ir">from</strong> my_module <strong class="nc ir">import</strong> my_func</span><span id="e9d3" class="ls lt iq nc b gy nr no l np nq"><em class="ni"><br/># run the function<br/></em>my_func()</span><span id="5936" class="ls lt iq nc b gy nr no l np nq">Output:<br/>Hello from my_func!</span></pre><p id="ba6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用这种替代形式的导入，我们没有导入整个模块，而是只导入了我们需要使用的函数。因此，我们可以只通过它的名字来调用这个函数，不需要任何模块前缀，不像我们的第一个例子，这个函数只能通过我们导入的模块来访问。</p><h2 id="ba50" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">__name__ 和“__main__”的事情</h2><p id="676b" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在 Python 脚本中，我们并不经常遇到这行代码:</p><pre class="kg kh ki kj gt nj nc nk nl aw nm bi"><span id="2071" class="ls lt iq nc b gy nn no l np nq"><strong class="nc ir">if</strong> __name__ == "__main__":<br/><em class="ni">    # code</em></span></pre><p id="8e4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是这到底有什么用呢？</p><p id="d939" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先分享一些背景/知识。执行文件时，Python 为这个模块定义了一个变量。其标识符为<code class="fe mz na nb nc b">__name__</code>，其值通常为<code class="fe mz na nb nc b">__main__</code>。但是如果这个模块没有被直接运行，而是被导入到另一个模块中，那么这个<code class="fe mz na nb nc b">__name__</code>变量将获得导入模块的名称。因此，<code class="fe mz na nb nc b">if __name__ == "__main__"</code>条件验证了这一点，并允许模块的不同行为，这取决于它是作为主程序运行，还是仅仅导入到另一个作为主程序运行的模块中。</p><ul class=""><li id="efa7" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><strong class="ky ir"> <em class="ni"> my_module.py </em> </strong></li></ul><pre class="kg kh ki kj gt nj nc nk nl aw nm bi"><span id="234d" class="ls lt iq nc b gy nn no l np nq"><strong class="nc ir">if</strong> <!-- -->__name__ ==<!-- --> <!-- -->"__main__":<br/>    <strong class="nc ir">print</strong> (f"My name is {__name__} and I run as a main program")<br/><strong class="nc ir">else</strong>:<br/>    <strong class="nc ir">print</strong> (f"My name is {__name__} and I am being imported")</span></pre><p id="6da1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行该程序(作为主程序)会产生以下结果:</p><pre class="kg kh ki kj gt nj nc nk nl aw nm bi"><span id="3c7a" class="ls lt iq nc b gy nn no l np nq">My name is __main__ and I run as a main program</span></pre><p id="6f35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是运行一个不同的导入<code class="fe mz na nb nc b">my_module</code>的模块:</p><ul class=""><li id="1508" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><strong class="ky ir"><em class="ni">my _ other _ module . py</em></strong></li></ul><pre class="kg kh ki kj gt nj nc nk nl aw nm bi"><span id="b933" class="ls lt iq nc b gy nn no l np nq"><strong class="nc ir">import</strong> my_module<br/><em class="ni"># or "</em><strong class="nc ir"><em class="ni">from</em></strong><em class="ni"> my_module </em><strong class="nc ir"><em class="ni">import</em></strong><em class="ni"> my_func", we'd have the same result</em></span></pre><p id="6800" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">会给我们带来以下结果:</p><pre class="kg kh ki kj gt nj nc nk nl aw nm bi"><span id="97aa" class="ls lt iq nc b gy nn no l np nq">My name is my_module and I am being imported</span></pre><p id="5b53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它通常在没有我前面提到的<code class="fe mz na nb nc b">else</code>子句的情况下使用，它最广泛的用途是防止代码在导入时被执行。通常，当我们打算将模块作为主程序运行时，我们只希望执行模块的代码:</p><pre class="kg kh ki kj gt nj nc nk nl aw nm bi"><span id="4135" class="ls lt iq nc b gy nn no l np nq"><strong class="nc ir">def</strong> my_func()<br/>    print("Hello")</span><span id="d92b" class="ls lt iq nc b gy nr no l np nq"><em class="ni"># only execute when being run as a main script/module</em><strong class="nc ir"><br/>if</strong> __name__ == "__main__":<br/>    my_func()</span></pre><h2 id="359a" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">好吧，那包裹是什么？</h2><p id="8c76" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">Python 中的包——非常简单地说——是一个目录。有一些特殊的特征:</p><ul class=""><li id="7bf3" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">它应该包含一个(或多个)Python 模块文件；</li><li id="76b4" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated">它还必须包含一个名为<code class="fe mz na nb nc b">__init__.py</code>的特殊 Python 文件。这个文件在 Python 将我们的目录识别为一个包的过程中起着重要的作用。简而言之，<code class="fe mz na nb nc b">__init__.py</code>很可能是空的。它的存在确保 Python 将我们的目录视为一个包。</li></ul><p id="6662" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mz na nb nc b">__init__.py</code>还有另一个用途，那就是定义从模块中导入什么资源。这些资源将可以使用包标识符直接访问。举个例子吧。</p><p id="48a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们有一个名为<code class="fe mz na nb nc b">my_package</code>的目录，包含两个文件:<code class="fe mz na nb nc b">__init__.py</code>和一个模块:<code class="fe mz na nb nc b">my_module.py</code>。这些文件的内容如下:</p><ul class=""><li id="6af1" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><strong class="ky ir"> <em class="ni"> my_module.py </em> </strong>:</li></ul><pre class="kg kh ki kj gt nj nc nk nl aw nm bi"><span id="4745" class="ls lt iq nc b gy nn no l np nq"><strong class="nc ir">def</strong> my_func():<br/>    <strong class="nc ir">print</strong>("Hello from my_func!")</span><span id="38ab" class="ls lt iq nc b gy nr no l np nq"><strong class="nc ir">def</strong> my_other_func():<br/>    <strong class="nc ir">print</strong>("Hello from my_other_func!")</span></pre><ul class=""><li id="438f" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><strong class="ky ir"> <em class="ni"> __init__。py </em> </strong>:</li></ul><pre class="kg kh ki kj gt nj nc nk nl aw nm bi"><span id="5cb2" class="ls lt iq nc b gy nn no l np nq"><em class="ni"># only make "my_func" available from my module</em><strong class="nc ir"><br/>from</strong> .my_module <strong class="nc ir">import</strong> my_func</span></pre><p id="0fce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，假设我们有一个脚本文件<code class="fe mz na nb nc b">my_script.py</code>，与我们的包(目录)在同一层:</p><pre class="kg kh ki kj gt nj nc nk nl aw nm bi"><span id="54d9" class="ls lt iq nc b gy nn no l np nq"><em class="ni"># import the package</em><strong class="nc ir"><br/>import</strong> my_package</span><span id="099a" class="ls lt iq nc b gy nr no l np nq"><em class="ni"><br/># only my_func is now available to import from the package,<br/># as specified in the package's __init__.py file</em><br/>my_package.<strong class="nc ir">my_func</strong>()</span><span id="1dec" class="ls lt iq nc b gy nr no l np nq"><em class="ni"># as such, this will throw an exception<br/></em>my_package.<strong class="nc ir">my_other_func</strong>()</span><span id="f00e" class="ls lt iq nc b gy nr no l np nq">Output:<br/>Hello from my_func!<br/>Traceback (most recent call last):<br/>  ...<br/>    my_package.my_other_func()<br/>AttributeError: module 'my_package' has no attribute 'my_other_func'</span></pre><p id="5748" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们得到的那个异常已经被抛出，因为我们的<code class="fe mz na nb nc b">__init__.py</code>文件只从<code class="fe mz na nb nc b">my_module</code>导入了<code class="fe mz na nb nc b">my_func</code>。当然，这都可以通过从包中显式导入模块并使用它所提供的所有功能来绕过:</p><pre class="kg kh ki kj gt nj nc nk nl aw nm bi"><span id="dcd3" class="ls lt iq nc b gy nn no l np nq"><em class="ni"># import the module directly</em><strong class="nc ir"><br/>import</strong> my_package.my_module</span><span id="961c" class="ls lt iq nc b gy nr no l np nq"><em class="ni"># now we have access to all its functions</em><br/>my_package.my_module.<strong class="nc ir">my_func</strong>()<br/>my_package.my_module.<strong class="nc ir">my_other_func</strong>()</span><span id="06a2" class="ls lt iq nc b gy nr no l np nq">Output:<br/>Hello from my_func!<br/>Hello from my_other_func!</span></pre><p id="4993" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然这是一次非常整洁的模块与包之旅，但我对这两个概念的概述已经接近尾声。确保你也查看了关于这个主题的官方文档，我相信你会在那里找到很多其他的好东西(在知识方面)。</p><p id="a8a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">直到<a class="ae kv" href="https://medium.com/@deck451/python-up-your-code-the-diamond-problem-fb3748ad4ad8" rel="noopener">下一个</a>时间！祝编码愉快，保持安全！</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="0ff7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ni"> Deck 是软件工程师、导师、作家，有时甚至是老师。他拥有 12 年以上的软件工程经验，现在是 Python 编程语言的真正倡导者，同时他的热情是帮助人们提高他们的 Python(以及一般的编程)技能。你可以在</em><a class="ae kv" href="https://www.linkedin.com/in/deck451/" rel="noopener ugc nofollow" target="_blank"><em class="ni">【Linkedin】</em></a><em class="ni"/><a class="ae kv" href="https://www.facebook.com/deck451/" rel="noopener ugc nofollow" target="_blank"><em class="ni">脸书</em></a><em class="ni"/><a class="ae kv" href="https://twitter.com/Deck45100" rel="noopener ugc nofollow" target="_blank"><em class="ni">推特</em> </a> <em class="ni">，以及</em> <a class="ae kv" href="https://discord.com" rel="noopener ugc nofollow" target="_blank"> <em class="ni">不和</em> </a> <em class="ni"> : Deck451#6188，以及跟随他在这里写作的</em> <a class="ae kv" href="https://medium.com/@deck451" rel="noopener"> <em class="ni">中</em></a></p><p id="6c20" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ni">更多内容请看</em><a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="ni">plain English . io</em></strong></a><em class="ni">。报名参加我们的</em> <a class="ae kv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ni">免费周报</em> </strong> </a> <em class="ni">。关注我们关于</em><a class="ae kv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="ni">Twitter</em></strong></a><em class="ni">和</em><a class="ae kv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="ni">LinkedIn</em></strong></a><em class="ni">。查看我们的</em> <a class="ae kv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ni">社区不和谐</em> </strong> </a> <em class="ni">加入我们的</em> <a class="ae kv" href="https://inplainenglish.pallet.com/talent/welcome" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ni">人才集体</em> </strong> </a> <em class="ni">。</em></p></div></div>    
</body>
</html>