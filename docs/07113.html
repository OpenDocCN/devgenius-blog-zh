<html>
<head>
<title>Working with application properties in Spring Boot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Spring Boot 使用应用程序属性</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/working-with-application-properties-in-spring-boot-79e72630bba0?source=collection_archive---------2-----------------------#2022-02-27">https://blog.devgenius.io/working-with-application-properties-in-spring-boot-79e72630bba0?source=collection_archive---------2-----------------------#2022-02-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ec231c92e1370f465f523208ab4d4c2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n7gHG8lLyZgECFP_FIvPxw.png"/></div></div></figure><p id="04a2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，在 Spring Boot 中，我们可以定义一些静态应用程序属性，这些属性将在运行时加载一次。我们可以通过各种方式做到这一点，我将介绍我知道哪些是可能的，以及我在开发和生产中使用的方法。</p><p id="b18d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我还将简要介绍如何设置一个测试环境以及一个测试属性文件，这样我们就可以为我们的应用程序进行一些自定义设置。</p><p id="0f2f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当初始化一个新的 Spring Boot 项目时，我们会自动得到一个标准的<strong class="jx io"> application.properties </strong>文件。我将不会讲述如何做到这一点，因为我已经在之前的教程中介绍过了。如果你想知道怎么做，可以查看<a class="ae kt" href="https://medium.com/@mjovanc/spring-boot-with-postgresql-and-hibernate-26dc00de27e" rel="noopener">https://medium . com/@ mjovanc/spring-boot-with-PostgreSQL-and-hibernate-26 DC 00 de 27 e</a>。</p><p id="5844" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">标准的<strong class="jx io"> application.properties </strong>最初通常只是一个空文件。在上一个教程中，我们在其中添加了以下内容:</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="e623" class="ld le in kz b gy lf lg l lh li">spring.datasource.url=jdbc:postgresql://localhost:5432/blog<br/>spring.datasource.username=&lt;db username&gt;<br/>spring.datasource.password=&lt;your password here&gt;<br/>spring.jpa.hibernate.ddl-auto=update</span></pre><p id="4987" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另一种方法是现在用 YAML 编写一个应用程序属性文件，这样我们可以在一个名为<strong class="jx io"> application.yml </strong>的新文件中定义我们的设置:</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="1e4a" class="ld le in kz b gy lf lg l lh li">spring:<br/>  datasource:<br/>    url: jdbc:postgresql://${POSTGRESQL_HOSTNAME}:${POSTGRESQL_PORT}/${POSTGRESQL_DB_NAME}<br/>    username: ${POSTGRESQL_DB_USER}<br/>    password: ${POSTGRESQL_DB_PASSWORD}<br/>  jpa:<br/>    hibernate:<br/>      ddl-auto: update</span></pre><p id="cd5f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以添加<strong class="jx io">环境变量</strong>，而不是在属性文件中硬编码我们的值，这样它将从系统中加载，而不是在我们的存储库中保密，这不是一种安全的工作方式。然而，在开发中这并不重要，但无论如何这都是一个很好的实践。如果您在 IntelliJ 中工作，您可以将这些环境变量放在我们的应用程序运行/调试配置中:</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lk"><img src="../Images/c9b39207cb4bcc81e9d74c45dfcecc65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qCM-q1aGeQ6u1IvLmpXoaw.png"/></div></div></figure><p id="0d07" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在您看到<em class="lj">环境变量</em>的地方，您可以创建一个<strong class="jx io">键-值对</strong>，在这里用分号分隔变量，它将在运行应用程序时被加载。非常整洁。</p><p id="9eca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们也可以这样定义我们的<strong class="jx io"> application.yml </strong>文件:</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="f463" class="ld le in kz b gy lf lg l lh li">spring:<br/>  datasource:<br/>    url: jdbc:postgresql://${POSTGRESQL_HOSTNAME:localhost}:${POSTGRESQL_PORT:5432}/${POSTGRESQL_DB_NAME:blogdb_dev}<br/>    username: ${POSTGRESQL_DB_USER:postgres}<br/>    password: ${POSTGRESQL_DB_PASSWORD:test1234}<br/>  jpa:<br/>    hibernate:<br/>      ddl-auto: update</span></pre><p id="1a9e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们设置了环境变量，但是如果没有设置环境变量，我们还设置了一个<em class="lj">回退</em>值。因此，如果我们不能从环境变量中获取值，这不会产生任何问题。</p><p id="3481" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是 YAML 和 T21 使用应用程序属性的基本方式。但是如何共享不同设置的应用程序属性呢？例如，如果我们希望根据目标平台加载不同的应用程序属性，我们可以创建这些文件:</p><ul class=""><li id="9476" class="ll lm in jx b jy jz kc kd kg ln kk lo ko lp ks lq lr ls lt bi translated">应用程序. yml</li><li id="e00c" class="ll lm in jx b jy lu kc lv kg lw kk lx ko ly ks lq lr ls lt bi translated">应用程序开发人员</li><li id="b6de" class="ll lm in jx b jy lu kc lv kg lw kk lx ko ly ks lq lr ls lt bi translated">应用测试. yml</li><li id="018f" class="ll lm in jx b jy lu kc lv kg lw kk lx ko ly ks lq lr ls lt bi translated">应用阶段. yml</li><li id="4415" class="ll lm in jx b jy lu kc lv kg lw kk lx ko ly ks lq lr ls lt bi translated">应用产品 yml</li></ul><p id="69e7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> application.yml </strong>将是存储应该在不同文件之间共享的所有内容的地方。这些其他文件被称为<strong class="jx io">概要文件</strong>。因此，我们可以在启动我们的<em class="lj"> Spring Boot </em>应用程序时使用一个标志来指定应该使用什么配置文件。我们可以在 IntelliJ 中这样做:</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lk"><img src="../Images/a43c24403cdca5f567fc303f9598ad53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aUdSEkd2veh1CCpYok_o1g.png"/></div></div></figure><p id="2620" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以指定<strong class="jx io"> VM 选项</strong>，您可以在<em class="lj"> java 17 SDK </em>定义下看到，或者我们可以指定<strong class="jx io">程序参数</strong>。显然我们不需要两者。当使用以下命名约定时，Spring Boot 将知道这些文件是概要文件:</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="9340" class="ld le in kz b gy lf lg l lh li">application-&lt;profile&gt;.yml</span></pre><p id="5a51" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">也可以设置一个<strong class="jx io">环境变量</strong>来指定应该使用什么配置文件:</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="cb12" class="ld le in kz b gy lf lg l lh li">SPRING_PROFILES_ACTIVE=dev</span></pre><p id="3a9d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，我们可以将它放在<em class="lj">应用运行/调试配置</em>中，就像我们之前看到的那样。如果我们在构建应用程序或构建 Docker 映像时有 CI 管道，我们还可以使用其他方法。</p><p id="6acf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，让我们来看一个例子，如何利用使用<em class="lj">配置文件</em>来分割它们。首先让我们看看我们的<strong class="jx io">应用程序:</strong></p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="96fe" class="ld le in kz b gy lf lg l lh li">server:<br/>  error:<br/>    whitelabel:<br/>      enabled: false<br/><br/>spring:<br/>  application:<br/>    name: Blog<br/>  main:<br/>    allow-bean-definition-overriding: true<br/><br/>springdoc:<br/>  api-docs:<br/>    enabled: true<br/>    path: /v1/docs<br/>  swagger-ui:<br/>    enabled: true<br/>    path: /v1/docs/index.html<br/>    operationsSorter: method<br/>    syntaxHighlight:<br/>      theme: obsidian<br/>    disable-swagger-default-url: true<br/>    supported-submit-methods: []</span></pre><p id="fc6d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们定义了一些基本的东西，比如我们不想显示白标错误页面，因为我们将使用<em class="lj">百里香叶</em>来呈现我们自己的定制 HTML 文档，用于不同的错误，如<em class="lj"> 400 </em>、<em class="lj"> 404 </em>或<em class="lj"> 500 </em>。但我们不会在这里深入讨论百里香叶，这只是为了说明这将在每个配置文件中使用。我们还定义了应用程序名称和<em class="lj"> springdoc </em> (Swagger UI)配置。</p><p id="17f3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，这将包括在每个配置文件中，以便我们可以开始查看其他配置文件。</p><p id="5576" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">应用开发 yml: </strong></p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="551b" class="ld le in kz b gy lf lg l lh li">spring:<br/>  datasource:<br/>    url: jdbc:postgresql://${POSTGRESQL_HOSTNAME:localhost}:${POSTGRESQL_PORT:5432}/${POSTGRESQL_DB_NAME:blogdb_dev}<br/>    username: ${POSTGRESQL_DB_USER:postgres}<br/>    password: ${POSTGRESQL_DB_PASSWORD:test1234}<br/>  jpa:<br/>    hibernate:<br/>      ddl-auto: update<br/><br/>keycloak:<br/>  auth-server-url: http://${KEYCLOAK_HOSTNAME}:${KEYCLOAK_PORT}/auth<br/>  realm: BlogAPIKeycloak<br/>  resource: dev-login-app<br/>  public-client: true<br/>  bearer-only: true</span></pre><p id="5b24" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们定义了 Spring datasource 和<em class="lj"> Keycloak </em>配置，我们将在其他文件中使用相同的配置，但是使用不同的资源名，所以我们需要在每个概要文件中再次指定。</p><p id="175d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">申请-测试. yml: </strong></p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="5458" class="ld le in kz b gy lf lg l lh li">spring:<br/>  datasource:<br/>    driver-class-name: org.h2.Driver<br/>    url: jdbc:h2:mem:db;DB_CLOSE_DELAY=-1<br/>    username: h2<br/>    password: test1234</span></pre><p id="a96b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意，这里我们使用不同的数据源，因为当运行我们的单元测试时，我们不需要使用我们的关系数据库，所以我们利用 H2，它基本上是一个内存数据库，非常适合测试目的。例如，当使用 CI/CD 管道时，这非常好，因为我们不需要连接到关系数据库来测试 API 端点。</p><p id="65c2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">申请阶段. yml: </strong></p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="0c41" class="ld le in kz b gy lf lg l lh li">spring:<br/>  datasource:<br/>    url: jdbc:postgresql://${POSTGRESQL_HOSTNAME:localhost}:${POSTGRESQL_PORT:5432}/${POSTGRESQL_DB_NAME:blogdb_dev}<br/>    username: ${POSTGRESQL_DB_USER:postgres}<br/>    password: ${POSTGRESQL_DB_PASSWORD:test1234}<br/>  jpa:<br/>    hibernate:<br/>      ddl-auto: update<br/><br/>keycloak:<br/>  auth-server-url: http://${KEYCLOAK_HOSTNAME}:${KEYCLOAK_PORT}/auth<br/>  realm: BlogAPIKeycloak<br/>  resource: stage-login-app<br/>  public-client: true<br/>  bearer-only: true</span></pre><p id="6074" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">应用产品名称:</strong></p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="c4ae" class="ld le in kz b gy lf lg l lh li">spring:<br/>  datasource:<br/>    url: jdbc:postgresql://${POSTGRESQL_HOSTNAME:localhost}:${POSTGRESQL_PORT:5432}/${POSTGRESQL_DB_NAME:blogdb_dev}<br/>    username: ${POSTGRESQL_DB_USER:postgres}<br/>    password: ${POSTGRESQL_DB_PASSWORD:test1234}<br/>  jpa:<br/>    hibernate:<br/>      ddl-auto: update<br/><br/>keycloak:<br/>  auth-server-url: http://${KEYCLOAK_HOSTNAME}:${KEYCLOAK_PORT}/auth<br/>  realm: BlogAPIKeycloak<br/>  resource: prod-login-app<br/>  public-client: true<br/>  bearer-only: true</span></pre><p id="5632" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，这基本上是当使用<strong class="jx io"> YAML </strong>文件与应用程序属性。但是也有一种方法来使用它。属性文件，我将展示如何用它来做同样的事情。我个人更喜欢用<strong class="jx io"> YAML </strong>，但是知道我们如何以不同的方式做到这一点也很好。</p><p id="8207" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">同<strong class="jx io">。属性</strong>文件类似的做法是:</p><ul class=""><li id="cdde" class="ll lm in jx b jy jz kc kd kg ln kk lo ko lp ks lq lr ls lt bi translated">应用程序.属性</li><li id="2c70" class="ll lm in jx b jy lu kc lv kg lw kk lx ko ly ks lq lr ls lt bi translated">应用程序开发属性</li><li id="d502" class="ll lm in jx b jy lu kc lv kg lw kk lx ko ly ks lq lr ls lt bi translated">应用程序测试属性</li><li id="26a5" class="ll lm in jx b jy lu kc lv kg lw kk lx ko ly ks lq lr ls lt bi translated">应用程序阶段.属性</li><li id="482f" class="ll lm in jx b jy lu kc lv kg lw kk lx ko ly ks lq lr ls lt bi translated">应用产品属性</li></ul><p id="ac3b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，我们只需像以前一样添加一个自定义配置文件名称，Spring 就会知道这是一个配置文件:</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="f128" class="ld le in kz b gy lf lg l lh li">application-&lt;profile&gt;.properties</span></pre><p id="e702" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以我们不需要深入细节并展示如何放置代码，因为它与教程如何编写<strong class="jx io">开头的例子非常相似。属性</strong>文件。</p><p id="90d2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">好了，我们现在知道如何编写应用程序属性文件了。如何装饰一些应该只用于特定概要文件的特定代码呢？</p><p id="981e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以通过在一个类上添加装饰器<strong class="jx io">配置文件</strong>来做到这一点，在这个例子中，我们将使用一个仅用于配置文件<strong class="jx io"> dev </strong>的播种器:</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="eb88" class="ld le in kz b gy lf lg l lh li">@Profile("dev")<br/>@Component<br/>public class Seeder implements ApplicationRunner {<br/><br/>    @Autowired<br/>    private BlogPostRepository blogPostRepository;<br/><br/>    public void seed() {<br/>        // Creating BlogPost objects<br/>        BlogPost blogPost1 = new BlogPost("Blog Title 1", "Some text.",<br/>                "2017-07-01T14:59:55.711'+0000'", "2017-07-01T14:59:55.711'+0000'");<br/><br/>        BlogPost blogPost2 = new BlogPost("Blog Title 2", "Some text 2.",<br/>                "2017-07-01T14:59:55.711'+0000'", "2017-07-01T14:59:55.711'+0000'");<br/><br/>        // Saving BlogPost objects to database<br/>        blogPostRepository.save(blogPost1);<br/>        blogPostRepository.save(blogPost2);<br/>    }<br/><br/>    @Override<br/>    public void run(ApplicationArguments args) {<br/>        if (blogPostRepository.count() == 0) {<br/>            seed();<br/>        }<br/>    }<br/>}</span></pre><p id="bf40" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">很明显，我们可以用它做更多的事情。在他们的官方 Spring 文档中查看:<a class="ae kt" href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties.core" rel="noopener ugc nofollow" target="_blank">https://docs . Spring . io/Spring-boot/docs/current/reference/html/application-properties . html # appendix . application-properties . core</a></p><p id="72bc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">差不多就是这样。:)</p></div></div>    
</body>
</html>