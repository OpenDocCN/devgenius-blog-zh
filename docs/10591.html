<html>
<head>
<title>What is Property Observer in Swift?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift 中的物业观察员是什么？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/property-observers-in-swift-fb3ba5b2c4d7?source=collection_archive---------4-----------------------#2022-11-14">https://blog.devgenius.io/property-observers-in-swift-fb3ba5b2c4d7?source=collection_archive---------4-----------------------#2022-11-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="93e4" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">当属性值发生变化时，willSet 和 didSet 会发出通知</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/cc40d1b9c8786080d2dbd2dc318804f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ptZQQWUXzhVqVTx0fiKzPg.png"/></div></div></figure><p id="a22d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在 iOS 应用程序开发中，观察者是在特定事件中通知用户的对象。财产观察者观察并响应财产价值的变化。每次设置属性值时都会调用它们，即使新值与属性值的当前值相同。它们提供了一种监视属性更改的方法。</p><p id="3bd4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">对于一个属性，我们可以有两个以下的观察者:</p><ul class=""><li id="08c3" class="lk ll in kq b kr ks ku kv kx lm lb ln lf lo lj lp lq lr ls bi translated"><strong class="kq io">将设置</strong>，在保存值之前调用。它带有一个包含 newValue 的常量参数，默认名称为 newValue。</li><li id="d7eb" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated"><strong class="kq io"> didSet </strong>在新值保存后立即被调用。它带有一个包含 oldValue 的常量参数，默认名称为 oldValue。</li></ul><blockquote class="ly lz ma"><p id="d127" class="ko kp mb kq b kr ks jo kt ku kv jr kw mc ky kz la md lc ld le me lg lh li lj ig bi translated">我们可以覆盖这些参数名中的任何一个(newValue，oldValue)，但是如果没有提供名称，则使用默认值。</p></blockquote><p id="f3f2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">根据苹果公司的说法，我们可以在以下地方添加物业观察员:</p><ol class=""><li id="b958" class="lk ll in kq b kr ks ku kv kx lm lb ln lf lo lj mf lq lr ls bi translated"><strong class="kq io">存储您定义的属性</strong></li></ol><pre class="kd ke kf kg gt mg mh mi bn mj mk bi"><span id="7fb2" class="ml mm in mh b be mn mo l mp mq">struct Employee {<br/>    var name: String<br/>    var age: Int {<br/>        willSet(newValue) {<br/>            print("\(name) age is set to \(newValue)")<br/>        }<br/>        didSet {<br/>            print("\(name) age changed from \(oldValue) to \(age)")<br/>        }<br/>    }<br/>}<br/><br/>var emp = Employee(name: "Tom", age: 20)<br/>emp.age = 30<br/><br/>// Tom age is set to 30<br/>// Tom age changed from 20 to 30</span></pre><p id="d2be" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">2.<strong class="kq io">您继承的存储属性</strong></p><pre class="kd ke kf kg gt mg mh mi bn mj mk bi"><span id="b605" class="ml mm in mh b be mn mo l mp mq">class Vehicle {<br/>    var currentSpeed = 0.0<br/>    var description: String {<br/>        return "traveling at \(currentSpeed) miles per hour"<br/>    }<br/>}<br/><br/>class Car: Vehicle {<br/>    var gear = 1<br/>    override var description: String {<br/>        return super.description + " in gear \(gear)"<br/>    }<br/>}<br/><br/>class AutomaticCar: Car {<br/>    override var currentSpeed: Double { // inherit Stored property<br/>        didSet {<br/>            gear = Int(currentSpeed / 10.0) + 1<br/>        }<br/>    }<br/>}<br/><br/>let automatic = AutomaticCar()<br/>automatic.currentSpeed = 35.0<br/>print("AutomaticCar: \(automatic.description)")<br/><br/>// AutomaticCar: traveling at 35.0 miles per hour in gear 4</span></pre><blockquote class="ly lz ma"><p id="4c1d" class="ko kp mb kq b kr ks jo kt ku kv jr kw mc ky kz la md lc ld le me lg lh li lj ig bi translated">对于继承的属性，您可以通过在子类中覆盖该属性来添加属性观察器。</p></blockquote><p id="a2a5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">3.<strong class="kq io">您继承的计算属性</strong></p><pre class="kd ke kf kg gt mg mh mi bn mj mk bi"><span id="f009" class="ml mm in mh b be mn mo l mp mq">class Shape {<br/>    var width = 0.0<br/>    var height = 0.0<br/>    <br/>    var area: Double {<br/>        get {<br/>            return width * height<br/>        }<br/>        set {<br/>            self.width = sqrt(newValue)<br/>            self.height = sqrt(newValue)<br/>        }<br/>    }<br/>}<br/><br/>class Rectangle: Shape {<br/>    override var area: Double {<br/>        didSet {<br/>            print("Old value is \(oldValue)")<br/>        }<br/>        willSet {<br/>            print("New value is \(newValue)")<br/>        }<br/>    }<br/>}</span></pre><p id="7cb5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">对于您定义的计算属性，请使用该属性的 setter 来观察和响应值的更改，而不是尝试创建一个观察器。</p><pre class="kd ke kf kg gt mg mh mi bn mj mk bi"><span id="3ebb" class="ml mm in mh b be mn mo l mp mq">struct Rectangle {<br/>    var width = 0.0<br/>    var height = 0.0<br/>    <br/>    var area: Double {<br/>        get {<br/>            return width * height<br/>        }<br/>        set {<br/>            self.width = sqrt(newValue)<br/>            self.height = sqrt(newValue)<br/>        }<br/>    }<br/>}<br/><br/>var rectAngle = Rectangle(width: 10, height: 10)<br/>print(rectAngle.area)</span></pre><p id="7dc9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">从 Swift 5.3 开始，属性观察者现在可以附加到<strong class="kq io">懒惰</strong>属性。</p><pre class="kd ke kf kg gt mg mh mi bn mj mk bi"><span id="261b" class="ml mm in mh b be mn mo l mp mq">class GreetingClass {<br/>    lazy var greeting: String = "Hi" {<br/>        willSet(newValue) {<br/>            print(newValue)<br/>        }<br/>       didSet {<br/>        print(oldValue)<br/>      }<br/>    }<br/>}<br/><br/>var obj = GreetingClass()<br/>obj.greeting = "Hello"</span></pre><h2 id="edd5" class="mr mm in bd ms mt mu dn mv mw mx dp my kx mz na nb lb nc nd ne lf nf ng nh ni bi translated">物业观察员需要记住的要点</h2><ul class=""><li id="f4f6" class="lk ll in kq b kr nj ku nk kx nl lb nm lf nn lj lp lq lr ls bi translated">当在初始值设定项中设置属性时，不能调用 willSet 和 didSet 观察器，或者当设置默认值时。</li><li id="a23e" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">属性观察器对<em class="mb">计算属性</em>不可用，因为您可以通过属性设置器来响应更改。但是，当它们被覆盖时，它们在<em class="mb">继承的计算属性</em>中可用</li></ul><blockquote class="ly lz ma"><p id="ad3d" class="ko kp mb kq b kr ks jo kt ku kv jr kw mc ky kz la md lc ld le me lg lh li lj ig bi translated">超类属性的<strong class="kq io"> willSet </strong>和<strong class="kq io"> didSet </strong>观察器在超类初始化器被调用后，在子类初始化器中设置属性时被调用。在调用超类初始化器之前，类在设置自己的属性时不会调用它们。</p></blockquote><h2 id="956f" class="mr mm in bd ms mt mu dn mv mw mx dp my kx mz na nb lb nc nd ne lf nf ng nh ni bi translated">结论</h2><p id="c2ab" class="pw-post-body-paragraph ko kp in kq b kr nj jo kt ku nk jr kw kx no kz la lb np ld le lf nq lh li lj ig bi translated">属性观察器对于值更改通知很有用。理想的场景是，当我们需要添加一些逻辑或者需要在属性值发生变化时更改用户界面时，使用属性观察器。</p></div><div class="ab cl nr ns hr nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ig ih ii ij ik"><p id="b32f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">感谢阅读。如果您有任何意见、问题或建议，请在下面的评论区发表！👇。请<strong class="kq io">分享</strong>并给予<strong class="kq io">掌声</strong>👏👏如果你喜欢这个帖子。</p></div></div>    
</body>
</html>