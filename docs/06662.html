<html>
<head>
<title>Build your first CI/CD pipeline using Docker, Github Actions, and Webhooks while creating your own web curriculum</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建您自己的网络课程时，使用 Docker、Github Actions 和 Webhooks 构建您的第一个 CI/CD 管道</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/build-your-first-ci-cd-pipeline-using-docker-github-actions-and-webhooks-while-creating-your-own-da783110e151?source=collection_archive---------3-----------------------#2022-01-24">https://blog.devgenius.io/build-your-first-ci-cd-pipeline-using-docker-github-actions-and-webhooks-while-creating-your-own-da783110e151?source=collection_archive---------3-----------------------#2022-01-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="b1b8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本教程中，您将学习一种通过将自动化引入开发阶段(称为持续集成/持续交付)来频繁向客户端交付应用程序的基本方法。</p><p id="6906" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我们将使用 JSON Resume，这是一个由社区创建的开源项目，旨在创建一个基于 JSON 的简历标准，帮助我们更快地发布我们的课程。该工具使用命令行工具从 JSON 文件创建 HTML 简历。</p><p id="281e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，Github actions 将允许我们使用一个基本的 httpd 服务器创建一个 docker 映像，其中包括我们在上一步中生成的 HTML，每次我们的存储库被更新时。此外，该图像将被自动推送到 DockerHub。</p><p id="58cd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后一步，我们将使用<a class="ae ki" href="https://github.com/adnanh/webhook" rel="noopener ugc nofollow" target="_blank"> adnanh/webhook </a>来重新创建我们的容器，只要有新的图像被推送到我们的 Docker Hub 存储库。Webhook 是一个用 Go 编写的简单、轻量级的应用程序，它允许您轻松地在您的服务器上创建 HTTP 端点，这些端点可用于执行命令。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/fe5e95cd50c89c5cf957cb412756d66f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-kQXcyS6lQR4GA3r_YdGVQ.jpeg"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">项目示意图</figcaption></figure><p id="88f9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这只是做这件事的一种方法，还有很多。您可以使用 Github 操作来构建 HTML 文件，而不是在本地构建并推送到存储库之后复制它。这只是一个很酷的小项目，因为它基本上只是一个学习 Docker、Github 动作的实验室…</p><p id="69fb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">假设你们中的大多数人对创建 GitHub 库、致力于它等等都有基本的了解。同样重要的是，您的计算机上安装了 docker、npm 和 git，这应该足够了。如果你有任何问题，请告诉我，我可以帮助你或者更新这篇文章。</p><h2 id="1c2e" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">创建简历</h2><p id="db27" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">您需要做的第一件事是创建一个 GitHub 存储库并在本地克隆它。之后，我们可以安装 resume-cli，JSON Resume 命令行工具。为此，请在项目的根目录下运行以下命令:</p><p id="07ec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> npm 安装恢复命令行界面</strong></p><p id="6ab8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一般来说，我更喜欢在本地(项目内)安装软件包，而不是全局安装，所以如果我的项目永远不会被删除，我也不必记得卸载全局软件包。此外，该项目更具可移植性。如果您全局安装软件包，则没有必要通过 npx 运行 resume-cli。</p><p id="802a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的下一步是初始化一份新简历:</p><p id="47d4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">简历初始</strong></p><p id="084d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您将被要求输入您的姓名和电子邮件地址。将会有一个名为 resume.json 的新 JSON 文件，其中包含关于您的简历的信息。有几种方法可以定制你的简历，每种方法都有多个选项。我们邀请您查看它们，并选择最符合您需求的<a class="ae ki" href="https://jsonresume.org/themes/" rel="noopener ugc nofollow" target="_blank">主题</a>。请记住，如果你想要一个不同的主题，这将需要额外的配置。</p><p id="cbf4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们现在生成我们的 HTML 简历:</p><p id="1703" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">【resume.html npx 恢复出口】T2</p><p id="5996" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦您将其推送到您的存储库，我们就可以进入下一部分。</p><h2 id="9091" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">DOCKER 图像</h2><p id="3983" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">假设您已经完成了上一部分，让我们构建一个 docker 映像，它包含基本的 Httpd web 服务器和之前创建的 resume.html。为了做到这一点，我们将制作一个相当简单的 order 文件，只有两行。在项目根目录中，创建一个名为 Dockerfile 的文件，其中包含以下几行:</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="61df" class="kz la in ly b gy mc md l me mf"><strong class="ly io">FROM httpd:latest<br/>COPY resume.html /usr/local/apache2/htdocs/index.html</strong></span></pre><p id="2a57" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第一行简单地声明我们将使用 Httpd 的最新版本作为我们的基础映像。最后一行把我们的简历复制到服务器的公共文件夹。为了确保一切按预期运行，我们将在本地测试我们的映像。第一步是构建我们的图像，并用一个标签 resume-test 保存它，这样在我们启动容器后，这个标签就可用了。</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="e290" class="kz la in ly b gy mc md l me mf"><strong class="ly io">docker build . -t resume-test</strong></span></pre><p id="e7c9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下一步，我们将使用以下命令运行名为 container-resume 的容器:</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="28ea" class="kz la in ly b gy mc md l me mf"><strong class="ly io">docker run -p 80:80 -d --name container-resume resume-test</strong></span></pre><p id="defe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="mg"> -p </em> </strong> <em class="mg">你的 _ 机器 _ 港口:集装箱 _ 港口。如果你前往 docker.hub 上的</em> <a class="ae ki" href="https://hub.docker.com/_/httpd" rel="noopener ugc nofollow" target="_blank"> <em class="mg"> httpd 文档</em> </a> <em class="mg">它们会在 80 端口暴露服务器。</em></p><p id="d4b7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="mg"> -d </em> </strong> <em class="mg">在后台运行容器并打印容器 ID，我们仍然可以在同一终端上工作。</em></p><p id="3625" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，在浏览器中键入 localhost 后，您的课程表就会出现。如果没有，请检查您的终端是否有任何错误，并重复该过程。</p><p id="ca14" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了停止并删除机器上的容器，您必须运行以下命令:</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="786e" class="kz la in ly b gy mc md l me mf"><strong class="ly io">docker container stop container-resume<br/>docker container rm container-resume</strong></span></pre><h2 id="9dc0" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">GITHUB 操作</h2><p id="cc99" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">我最喜欢的部分，在这里你将学习如何使用 GitHub actions 来构建我们的应用程序，每次有新的贡献加入到我们的库中。此外，在构建完成后，这会将图像上传到我们的 Docker Hub 存储库中。Docker 上有一个很棒的<a class="ae ki" href="https://docs.docker.com/ci-cd/github-actions/" rel="noopener ugc nofollow" target="_blank">文档</a>展示了如何做到这一点，这只是最简单的部分。如果您想了解如何实现更多自动化，请看看这个。</p><p id="4929" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，你应该去<a class="ae ki" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> docker hub </a>创建一个账户。之后，您需要将存储库命名为 web-resume，或者您想叫它什么都行。在接下来的步骤中，您将需要该名称。</p><p id="9a12" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">创建存储库后，进入<strong class="jm io"> <em class="mg">账户设置- &gt;安全- &gt;访问令牌</em> </strong>并创建新令牌。请务必保存令牌，稍后会用到它。您现在可以在您的<strong class="jm io"> <em class="mg"> GitHub 资源库的设置中添加以下两个秘密:Secrets-&gt;New Secret</em></strong>。</p><p id="2adb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mh mi mj ly b">DOCKER_HUB_USERNAME</code>使用您的 docker hub 用户名。</p><p id="5da2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mh mi mj ly b">DOCKER_HUB_ACCESS_TOKEN</code>使用之前创建的令牌。</p><p id="1a6e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们现在准备开始编写很酷的 GitHub actions YAML 文件。导航到顶部菜单<strong class="jm io"> <em class="mg">您的存储库- &gt;操作- &gt;新建工作流- &gt;自行设置工作流</em> </strong>。<strong class="jm io"> <em class="mg"> </em> </strong>复制以下文本并粘贴:</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="7d62" class="kz la in ly b gy mc md l me mf"># This is a basic workflow to help you get started with Actions<br/>name: CI<br/># Controls when the workflow will run<br/>on:<br/>  # Triggers the workflow on push or pull request events but only for the master branch<br/>  push:<br/>    branches: [ master ]<br/>  pull_request:<br/>    branches: [ master ]</span><span id="29ff" class="kz la in ly b gy mk md l me mf"># Allows you to run this workflow manually from the Actions tab<br/>  workflow_dispatch:</span><span id="cd9f" class="kz la in ly b gy mk md l me mf"># A workflow run is made up of one or more jobs that can run sequentially or in parallel<br/>jobs:<br/>  # This workflow contains a single job called "build"<br/>  build:<br/>    # The type of runner that the job will run on<br/>    runs-on: ubuntu-latest</span><span id="c965" class="kz la in ly b gy mk md l me mf"># Steps represent a sequence of tasks that will be executed as part of the job<br/>    steps:<br/>      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it<br/>      - uses: actions/checkout@v2<br/>      <br/>        name: Login to Docker Hub<br/>      - uses: docker/login-action@v1<br/>        with:<br/>          username: ${{ secrets.DOCKER_HUB_USERNAME }}<br/>          password: ${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}<br/>      -<br/>        name: Set up Docker Buildx<br/>        uses: docker/setup-buildx-action@v1<br/>      -<br/>        name: Build and push<br/>        uses: docker/build-push-action@v2<br/>        with:<br/>          context: .<br/>          file: ./Dockerfile<br/>          push: true<br/>          tags: ${{ secrets.DOCKER_HUB_USERNAME }}/<strong class="ly io"><em class="mg">YOUR-DOCKER-HUB-REPO-NAME</em></strong>:latest</span></pre><p id="5504" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面的代码摘自我前面提到的文档。这是有据可查的，也很容易理解。请注意，标题为“设置 Docker Buildx”的部分远程创建了我们的 Dockerfile 映像，就像我们在本地所做的一样。最后，我还用粗体字突出了“<strong class="jm io"><em class="mg">YOUR-DOCKER-HUB-REPO-NAME</em></strong>”。如果你给你的 Docker hub repo 起了不同的名字，我想是这样的，那么一定要把这个名字改成你选择的那个名字。</p><p id="9bc8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，每当您将某个东西推送到 master 时，都会构建一个新的映像并保存到您的存储库中，所以请继续测试它。</p><h2 id="a77a" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">重建我们的容器</h2><p id="440d" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">我们的项目几乎完成了，所以我们需要一种方法来创建我们的容器，其中包含了在我们的存储库上构建的最后一个映像。Docker Hub 存储库中的菜单上有一个名为 Webhooks 的部分。这让您可以在每次存储库中有 push 事件时发送一个 HTTP/S 请求，以及一堆关于它的<a class="ae ki" href="https://docs.docker.com/docker-hub/webhooks/" rel="noopener ugc nofollow" target="_blank">信息</a>。因此，剩下的唯一事情就是接收请求。为此，我将使用<a class="ae ki" href="https://github.com/adnanh/webhook" rel="noopener ugc nofollow" target="_blank"> adnanh/webhook </a>。我们可以用它轻松地启动一个端点，并在几个步骤中设置好它。</p><p id="1eec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在开始下一部分之前，需要一个服务器。可以使用你自己的电脑，但是要确保你有一个公共的 IP 地址，这样 webhook 请求才能找到你的电脑。我用的是最便宜最基本的<a class="ae ki" href="https://www.hetzner.com/cloud?country=de" rel="noopener ugc nofollow" target="_blank"> Hertzner Cloud </a>基本服务器搭配 Ubuntu。确保 Docker 安装在您的服务器上，并登录到您的 Docker 帐户，以便能够下载新创建的图像。这可以通过以下方式轻松实现:</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="3400" class="kz la in ly b gy mc md l me mf"><strong class="ly io">docker login</strong></span></pre><p id="796f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在安装 Webhook 工具之前，我们将首先启动我们的容器，并编写用于重启它的 shell 脚本。要启动容器:</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="46fe" class="kz la in ly b gy mc md l me mf"><strong class="ly io">docker run -p 80:80 -d --name YOUR-CONTAINER-NAME YOUR-DOCKER-HUB-USER/YOUR-DOCKER-HUB-REPO-NAME</strong></span></pre><p id="7fcf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，在 shell 脚本中包含以下内容: (记住名称并添加执行权限<strong class="jm io"> chmod +x </strong>)</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="0dcd" class="kz la in ly b gy mc md l me mf"><em class="mg">#!/bin/sh<br/># Pull latest version of the image</em><br/><strong class="ly io">docker pull <em class="mg">YOUR-DOCKER-HUB-USER/YOUR-DOCKER-HUB-REPO-NAME</em><br/></strong><em class="mg"># Remove unused images</em><strong class="ly io"><br/>docker image prune -f</strong><br/><em class="mg"># Stop the container</em><br/><strong class="ly io">docker stop YOUR-CONTAINER-NAME<br/></strong># Remove <em class="mg">the container</em><strong class="ly io"><br/>docker rm YOUR-CONTAINER-NAME<br/></strong># Recreate the container<strong class="ly io"><br/>docker run -p 80:80 -d --name YOUR-CONTAINER-NAME YOUR-DOCKER-HUB-USER/YOUR-DOCKER-HUB-REPO-NAME</strong></span></pre><p id="40cd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">是时候安装<a class="ae ki" href="https://github.com/adnanh/webhook" rel="noopener ugc nofollow" target="_blank"> adnanh/webhook </a>了。在 Ubuntu 中，就像这样简单:</p><p id="d1ab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> sudo apt-get 安装 webhook </strong></p><p id="49dc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您也可以参考其他操作系统的文档。我们的下一步是创建另一个 JSON 文件，它将包含以下端点配置信息:</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="c413" class="kz la in ly b gy mc md l me mf">[<br/>    { <br/>      "id": "<strong class="ly io">ENDPOINT-NAME</strong>",<br/>      "execute-command": "./script.sh",<br/>      "command-working-directory": "/etc/scripts",<br/>      "response-message": "Executing redeploy web resume container",<br/>      "trigger-rule":<br/>      {<br/>        "match":<br/>        {<br/>          "type": "value",<br/>          "value": "<strong class="ly io">CREATE-YOUR-OWN-TOKEN</strong>",<br/>          "parameter":<br/>          {<br/>            "source": "url",<br/>            "name": "<strong class="ly io">GET-PARAM</strong>"<br/>          }<br/>        }<br/>      }<br/>    }<br/>]</span></pre><p id="e0d9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> id </strong>:指定您想要的任何名称，但是记住它将作为端点的名称 http://your server:9000/hooks/<strong class="jm io">id</strong></p><p id="2721" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> execute-comand </strong>:在这里写下我们之前创建的 shell 脚本的名称。</p><p id="66d3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">命令-工作目录</strong>:要指定存储脚本的工作目录，请输入保存脚本的目录路径。</p><p id="6f6d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">用一个安全令牌更改<strong class="jm io"> CREATE-YOUR-OWN-TOKEN </strong>的值，以验证是您在请求重新部署容器。以及<strong class="jm io"> GET-PARAM </strong>，可以随意重命名。我们的网址会是<strong class="jm io"/>http://your server:9000/hooks/id？<strong class="jm io"> GET-PARAM </strong> = <strong class="jm io">创建自己的令牌</strong>。</p><p id="8cf0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">只剩下两个步骤，第一步是启动我们的端点(如果您在后台运行这个命令将是最好的):</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="47c2" class="kz la in ly b gy mc md l me mf"><strong class="ly io">webhook -hooks web-resume.json -verbose</strong></span></pre><p id="c0bb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，但并非最不重要。转到 docker hub 的 webhooks 部分，创建一个新的 webhook。在那里键入您的 URL，并随意命名，记住您的 URL 格式是:</p><p id="812f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">http://your server:9000/hooks/id？<strong class="jm io"> GET-PARAM </strong> = <strong class="jm io">创建自己的令牌</strong>。</p><p id="aff5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Buala，现在当你更新你的 GitHub 网络课程时，将它推送到 master，你应该在几秒钟内看到更新的在线课程。</p><p id="19ba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 joanplaja.com 查看我的网络简历。除了域名，我还在我的网站上添加了 SSL 证书。如果你不知道如何做到这一点，我邀请你更新你的项目，以便能够做到这一点。如果你喜欢这个项目，请与你的朋友分享。</p></div></div>    
</body>
</html>