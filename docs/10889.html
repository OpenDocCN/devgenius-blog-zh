<html>
<head>
<title>Creating Game AI using supervised imitation learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用监督模仿学习创建游戏人工智能</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/creating-game-ai-using-supervised-imitation-learning-c8aaf1e357bd?source=collection_archive---------20-----------------------#2022-12-05">https://blog.devgenius.io/creating-game-ai-using-supervised-imitation-learning-c8aaf1e357bd?source=collection_archive---------20-----------------------#2022-12-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="57c1" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">用深度学习玩神庙逃亡 2</h2></div><figure class="kc kd ke kf gt kg"><div class="bz fp l di"><div class="kh ki l"/></div></figure><p id="4815" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">使用一个简单的卷积神经网络，我创建了一个可以在 Temple Run 2 中实现 2000+米跑的 AI。这绝对是简单卷积神经网络的一个不常见的应用。如果你对这个项目有任何疑问，欢迎在评论中提问。</p><h2 id="757d" class="lf lg in bd lh li lj dn lk ll lm dp ln ks lo lp lq kw lr ls lt la lu lv lw lx bi translated">什么是神庙逃亡 2？</h2><p id="ddf5" class="pw-post-body-paragraph kj kk in kl b km ly jo ko kp lz jr kr ks ma ku kv kw mb ky kz la mc lc ld le ig bi translated">Temple run 2 是一款无限跑者游戏，玩家必须跳跃、闪避并向左/右转弯以克服障碍。</p><h1 id="4df8" class="md lg in bd lh me mf mg lk mh mi mj ln jt mk ju lq jw ml jx lt jz mm ka lw mn bi translated">什么是监督模仿学习？</h1><p id="c228" class="pw-post-body-paragraph kj kk in kl b km ly jo ko kp lz jr kr ks ma ku kv kw mb ky kz la mc lc ld le ig bi translated">“我想教一个神经网络玩神庙逃亡”</p><p id="17d0" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">这是典型的强化学习任务，但是̶i̶̶h̶a̶v̶e̶̶n̶o̶̶i̶d̶e̶a̶̶h̶o̶w̶̶r̶e̶i̶n̶f̶o̶r̶c̶e̶m̶e̶n̶t̶̶l̶e̶a̶r̶n̶i̶n̶g̶̶w̶o̶r̶k̶s̶，我们也可以把它重新表述为监督学习任务。</p><p id="0804" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">模仿学习是当一个模型看到另一个实体执行一项任务(例如，一个人玩视频游戏)，并学习预测该实体将采取的行动，有效地“模仿”该实体的行为。</p><p id="ebbc" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">例如在 OpenAI 的这个<a class="ae mo" href="https://openai.com/blog/vpt/" rel="noopener ugc nofollow" target="_blank">帖子</a>中，一个模型根据游戏的几帧画面预测了游戏中玩家的行为<em class="mp">《我的世界》</em>，让模型模仿人类的行为。</p><p id="9ca3" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">在 Temple Run 的上下文中，我决定训练一个模型来预测玩家是否应该跳跃、闪避、左转、右转等。基于游戏的单个框架。我收集了许多障碍物的数据，并给它们贴上了相应的标签。</p><figure class="kc kd ke kf gt kg gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/a15ca75921772d47928df73c65f3b9f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:476/format:webp/1*D0vhwy2o8XBA8R22jUzfzg.jpeg"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">这一帧被标记为“w ”,表示鸭子，表示玩家应该在这一点上低头。</figcaption></figure><p id="45d3" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">在监督模仿学习之后，该模型通常会在真实的游戏场景中进行微调。然而，我并没有在这个项目中追求这一点。</p><h1 id="09b7" class="md lg in bd lh me mf mg lk mh mi mj ln jt mk ju lq jw ml jx lt jz mm ka lw mn bi translated">技术设置</h1><p id="999d" class="pw-post-body-paragraph kj kk in kl b km ly jo ko kp lz jr kr ks ma ku kv kw mb ky kz la mc lc ld le ig bi translated">项目的总体设置如下:</p><ul class=""><li id="4430" class="mx my in kl b km kn kp kq ks mz kw na la nb le nc nd ne nf bi translated">我用了一个 android 模拟器 Bluestacks 来玩《神庙逃亡》</li><li id="6c90" class="mx my in kl b km ng kp nh ks ni kw nj la nk le nc nd ne nf bi translated">我用 pyautogui 与电脑进行交互，并对游戏进行截图。</li><li id="a337" class="mx my in kl b km ng kp nh ks ni kw nj la nk le nc nd ne nf bi translated">我在 pytorch 训练我的模特。</li></ul><h1 id="cda9" class="md lg in bd lh me mf mg lk mh mi mj ln jt mk ju lq jw ml jx lt jz mm ka lw mn bi translated">型号选择</h1><p id="d170" class="pw-post-body-paragraph kj kk in kl b km ly jo ko kp lz jr kr ks ma ku kv kw mb ky kz la mc lc ld le ig bi translated">对于我的模型，我决定使用预先训练的 Shufflenet V2 模型进行迁移学习。</p><p id="ffd4" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">这款机型针对速度进行了优化，专为移动设备设计。因此，它可以在一秒钟内实时做出许多预测，非常适合我的项目。</p><p id="729c" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">由于我的训练数据有限，我使用了一个预训练的模型，并进行了一些迁移学习，教它对我收集的数据集中的图像进行分类。</p><h1 id="be51" class="md lg in bd lh me mf mg lk mh mi mj ln jt mk ju lq jw ml jx lt jz mm ka lw mn bi translated">主要问题</h1><p id="a791" class="pw-post-body-paragraph kj kk in kl b km ly jo ko kp lz jr kr ks ma ku kv kw mb ky kz la mc lc ld le ig bi translated">我在训练模型时遇到了一些问题</p><h2 id="abf8" class="lf lg in bd lh li lj dn lk ll lm dp ln ks lo lp lq kw lr ls lt la lu lv lw lx bi translated">过度拟合</h2><p id="258e" class="pw-post-body-paragraph kj kk in kl b km ly jo ko kp lz jr kr ks ma ku kv kw mb ky kz la mc lc ld le ig bi translated">特别是对于小数据集，过度拟合是一个问题。</p><p id="ad38" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">我使用了以下方法来处理过度拟合</p><ul class=""><li id="8b37" class="mx my in kl b km kn kp kq ks mz kw na la nb le nc nd ne nf bi translated">对训练图像应用随机变换</li><li id="3b48" class="mx my in kl b km ng kp nh ks ni kw nj la nk le nc nd ne nf bi translated">使用批处理规范化(已经存在于模型架构中)</li><li id="c17a" class="mx my in kl b km ng kp nh ks ni kw nj la nk le nc nd ne nf bi translated">收集更多训练数据</li><li id="e989" class="mx my in kl b km ng kp nh ks ni kw nj la nk le nc nd ne nf bi translated">切换到更小的 Shufflenet 0.5x 型号，以获得更简单的架构</li></ul><p id="277d" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">然而，我最想优化的是准确性，因为当面对游戏中的障碍时，模型会因为做出错误的决定而受到严重惩罚。因此，我会允许一些过度拟合发生。</p><h2 id="265f" class="lf lg in bd lh li lj dn lk ll lm dp ln ks lo lp lq kw lr ls lt la lu lv lw lx bi translated">不平衡障碍等级</h2><p id="505d" class="pw-post-body-paragraph kj kk in kl b km ly jo ko kp lz jr kr ks ma ku kv kw mb ky kz la mc lc ld le ig bi translated">在每个类别中(如跳跃)，有许多不同类别的障碍(如有缺口的桥，不同种类的墙等)。)</p><p id="90f3" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">当在游戏中运行模型时，我很快注意到它似乎在与特定的障碍进行斗争。我推测，这是因为在训练数据中很少有这些障碍的图像，如果模型有点过度拟合，这些障碍就会不成比例地出现。</p><p id="24c2" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">我对这个问题的解决方案是手动收集更多模型遇到的障碍的数据，以平衡这些类别。</p><p id="bcff" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">在游戏的某些部分，玩家进入矿车或河流，障碍会完全改变。这些部分出现的概率很低，因此我缺乏这些部分的训练数据，当它们出现在游戏中时，模型几乎总是会死亡。</p><h2 id="6fa1" class="lf lg in bd lh li lj dn lk ll lm dp ln ks lo lp lq kw lr ls lt la lu lv lw lx bi translated">数据的概化</h2><p id="f3ab" class="pw-post-body-paragraph kj kk in kl b km ly jo ko kp lz jr kr ks ma ku kv kw mb ky kz la mc lc ld le ig bi translated">当赛跑者继续跑时，游戏改变速度。所以随着游戏的进行，跳跃的时机是不一样的。这是我的模型无法预料的问题，它降低了它的准确性，因为它一次只能查看一帧，并且没有办法判断游戏的速度。</p><p id="f1d3" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">为了减轻这个问题的影响，我从游戏的早期收集了更多的数据，以保证模型有良好的平均时间。因此，根据早期和晚期游戏数据训练的模型的早期迭代有很高的概率在早期死亡，但也能够设定高分。这些模型是在我注意到这个问题之前创建的。</p><p id="b014" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">后来的迭代更关注早期的游戏和获得像样的平均分数。我平衡了一下数据集，增加了更多早期游戏的数据。</p><h1 id="8f8f" class="md lg in bd lh me mf mg lk mh mi mj ln jt mk ju lq jw ml jx lt jz mm ka lw mn bi translated">最终的模型</h1><figure class="kc kd ke kf gt kg gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi nl"><img src="../Images/bb8a8e03fcf35bbbfbcb29269c3586ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NFsmP2WmlTJ9mgy5Sk75pg.png"/></div></div></figure><p id="226f" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">对于每个模型，我运行了 10 次，并绘制了结果。</p><p id="fc4e" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">我使用 log distance(每次跑步的 ln 距离)作为我的性能指标。这是因为游戏随着时间的推移而加速，所以游戏中后来的 500 米比游戏中早些时候的 500 米快得多(并且障碍更少)。</p><p id="6235" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">然而，我在这里也包括了行程距离图。</p><figure class="kc kd ke kf gt kg gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi nq"><img src="../Images/8037e8d53b4487b07af8733a7c22fb65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sC8XWf_04Y-XrsBW2MuXFA.png"/></div></div></figure><p id="3215" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">(注意，除了这些记录的运行，我还在测试期间多次观察了这些模型的性能)</p><p id="f78a" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">第一个模型是根据一些数据天真地创建和训练的。它通常跑&lt;500m, but occasionally, and I mean <em class="mp">非常</em>偶尔，达到 2000 米以上的成绩。几乎没有中间环节。</p><p id="ae76" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">第二个模型(模型 3)使用许多技术来处理过拟合，并使用与模型 1 相同的数据集。它表现类似，但现在有一些运行在 500 和 2000 米之间。</p><p id="bfd9" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">第三个模型(模型 4)在更多的早期游戏训练数据上被训练。它有更好的平均跑步距离，但无法达到令人印象深刻的(&gt; 2000 米)跑步。总的来说，这个模型并没有给我留下深刻的印象。与其他 x1.0 型号相比，这个型号也是一个 Shufflenetx0.5，所以较小的型号架构可能影响了它在游戏中的性能。</p><p id="1ff7" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">在最终的模型(模型 5)中，我增加了一些游戏后期的数据，平衡了一些障碍等级。我还将该模型恢复为 Shufflenet x1.0。该模型能够获得更好的平均时间，也可以接近 2000 米。但从未超过 2000m。</p><h1 id="bc32" class="md lg in bd lh me mf mg lk mh mi mj ln jt mk ju lq jw ml jx lt jz mm ka lw mn bi translated">结论</h1><p id="2c4f" class="pw-post-body-paragraph kj kk in kl b km ly jo ko kp lz jr kr ks ma ku kv kw mb ky kz la mc lc ld le ig bi translated">完整的文章和代码可以在<a class="ae mo" href="https://github.com/dungwoong/Temple-Run-AI/blob/main/TempleRun%20Writeup.pdf" rel="noopener ugc nofollow" target="_blank">这里</a>找到。目前，我计划通过创建一个可以同时查看游戏的多个帧的模型来扩展这个项目。</p><p id="9c65" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">在真实的游戏场景中看到一个分类模型的表现是令人瞩目的，并且令人鼓舞的是发现它可以很好地通过障碍。总的来说，我对问题有了更好的理解，并且在追求这个项目后对 ConvNets 有了更好的理解。</p><p id="3256" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">如果您有任何问题，请不要犹豫地问，因为它们可能会帮助我扩展项目。</p></div></div>    
</body>
</html>