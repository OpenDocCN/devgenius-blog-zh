<html>
<head>
<title>Assembly by example: Compute string hash. Part 1: functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">按示例汇编:计算字符串哈希。第 1 部分:功能</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/assembly-by-example-compute-string-hash-part-1-functions-a575240cbc5b?source=collection_archive---------9-----------------------#2022-05-06">https://blog.devgenius.io/assembly-by-example-compute-string-hash-part-1-functions-a575240cbc5b?source=collection_archive---------9-----------------------#2022-05-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="03ad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这一系列的文章中，我们将讨论如何用汇编语言编写一个有趣、简单且有教育意义的程序来计算字符串散列。</p><p id="81d5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了让您对我们将要构建的内容有一个大致的了解，下面是测试汇编和 Java 中生成的哈希是否相等的代码。</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="kn ko l"/></div></figure><p id="1d19" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如您可能已经猜到的，我们将生成<code class="fe kp kq kr ks b">hashes</code>二进制文件(第 6 行)。</p><p id="a9c6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">假设您有一些编程经验，并知道一点点汇编。如果你不知道，这些是关键概念:</p><ul class=""><li id="f46c" class="kt ku in jm b jn jo jr js jv kv jz kw kd kx kh ky kz la lb bi translated"><strong class="jm io">寄存器</strong>是 CPU 内部的内存存储位置。<code class="fe kp kq kr ks b">rax</code>是 64 位注册表，<code class="fe kp kq kr ks b">eax</code>是<code class="fe kp kq kr ks b">rax</code>的下半部分(32 位)，<code class="fe kp kq kr ks b">ah</code>是<code class="fe kp kq kr ks b">eax</code>的下半部分(16 位)，<code class="fe kp kq kr ks b">al</code>是<code class="fe kp kq kr ks b">ah</code>的下半部分(8 位)。</li></ul><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi lc"><img src="../Images/a3db5eddc0013da718e993a57fdacaa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:516/format:webp/1*es8bv6I3zHXatsGIXsAyIA.png"/></div></figure><ul class=""><li id="98d2" class="kt ku in jm b jn jo jr js jv kv jz kw kd kx kh ky kz la lb bi translated"><strong class="jm io">注释</strong>前面有分号<code class="fe kp kq kr ks b">;</code></li><li id="12ec" class="kt ku in jm b jn lf jr lg jv lh jz li kd lj kh ky kz la lb bi translated">汇编不是一种结构化语言，因此不存在函数、循环等。但是有<strong class="jm io">指令</strong>。你可以在这里找到最常见的<a class="ae lk" href="https://en.wikibooks.org/wiki/X86_Assembly/Control_Flow" rel="noopener ugc nofollow" target="_blank">的综合列表</a>。</li><li id="d49f" class="kt ku in jm b jn lf jr lg jv lh jz li kd lj kh ky kz la lb bi translated"><strong class="jm io">堆栈向下</strong>增长，即地址<code class="fe kp kq kr ks b">0x0f</code>更靠近堆栈顶部，而<code class="fe kp kq kr ks b">0xff</code>更靠近底部。</li><li id="3aa9" class="kt ku in jm b jn lf jr lg jv lh jz li kd lj kh ky kz la lb bi translated"><strong class="jm io">基址指针</strong>是一个指针，其值作为访问堆栈帧数据的参考。一般来说，低于它的值是局部变量，高于它的值是函数参数。</li><li id="0ca2" class="kt ku in jm b jn lf jr lg jv lh jz li kd lj kh ky kz la lb bi translated"><strong class="jm io">堆栈指针</strong>是指向堆栈顶部的指针。</li><li id="72d9" class="kt ku in jm b jn lf jr lg jv lh jz li kd lj kh ky kz la lb bi translated"><strong class="jm io">指令指针</strong>保存指向下一条要执行的指令的指针。</li></ul><p id="0835" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">汇编总结结束，我们进入编码！</p><h1 id="9070" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">积木</h1><p id="eb1e" class="pw-post-body-paragraph jk jl in jm b jn mj jp jq jr mk jt ju jv ml jx jy jz mm kb kc kd mn kf kg kh ig bi translated">我们将使用与<a class="ae lk" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#hashCode()" rel="noopener ugc nofollow" target="_blank"> Java </a>相同的字符串散列定义，定义如下</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/6c7b7a260fd6d6c12ebed9b5089ef1ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/0*ORGZ7Ohuhh2rtvq-.png"/></div></figure><p id="2ae6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当然，你可以改变这个函数。实际上，这将是一件有趣的事情，因为更正式的哈希函数应该是这样的</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/26a7f170d82ac42e59503c22dfa428a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/0*LVTXRCrHZciPTOrU.png"/></div></figure><p id="3768" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">其中 p 和 q 是质数。在 Java 的情况下，由于性能原因，不考虑模运算，为了方便起见，使用 31。</p><p id="c1ec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">抛开这个不谈，我们似乎需要编写两个辅助函数:<code class="fe kp kq kr ks b">strlen</code>来计算字符串长度|s|，以及<code class="fe kp kq kr ks b">pow31</code>来计算 31 的非负整数次幂(这实际上是不需要的，但是我们将在后面的<a class="ae lk" rel="noopener ugc nofollow" target="_blank" href="/assembly-by-example-compute-string-hash-part-2-loops-ba39de0ff6d6">中使用</a>)。这两个功能都将在本文的第二部分中进行编码。现在，让我解释一下“函数”在汇编中是如何工作的。</p><h1 id="ce5f" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">装配中的功能</h1><h2 id="3e27" class="mq lm in bd ln mr ms dn lr mt mu dp lv jv mv mw lz jz mx my md kd mz na mh nb bi translated">没有参数的函数</h2><p id="19aa" class="pw-post-body-paragraph jk jl in jm b jn mj jp jq jr mk jt ju jv ml jx jy jz mm kb kc kd mn kf kg kh ig bi translated">汇编不是一种结构化语言，它本身没有“函数”。然而，我们可以用跳转和汇编语言的其他特性来“模拟”一个函数。例如:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="kn ko l"/></div></figure><p id="b45e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，<code class="fe kp kq kr ks b">call prepare_exit</code>将:</p><ul class=""><li id="4151" class="kt ku in jm b jn jo jr js jv kv jz kw kd kx kh ky kz la lb bi translated">将<code class="fe kp kq kr ks b">prepare_exit</code>的地址加载到 IP(指令指针)中，这样它就是执行的下一条指令(这被称为<em class="nc">跳转</em>)</li><li id="31b6" class="kt ku in jm b jn lf jr lg jv lh jz li kd lj kh ky kz la lb bi translated"><code class="fe kp kq kr ks b">prepare_exit </code>完成后，将下一条要执行的指令压入堆栈，即加载<code class="fe kp kq kr ks b">int 0x80</code>的地址</li></ul><p id="0782" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kp kq kr ks b">prepare_exit</code>将<em class="nc">退出</em>系统调用的“id”加载到<code class="fe kp kq kr ks b">eax</code>中，该系统调用将退出状态代码作为单个参数接收，该代码存储在<code class="fe kp kq kr ks b">ebx</code>中，等于 0。然后，<code class="fe kp kq kr ks b">ret</code>将栈顶的值(也就是指令<code class="fe kp kq kr ks b">int 0x80</code>的地址)弹出，加载到 IP。</p><p id="72bb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以在<code class="fe kp kq kr ks b">/usr/include/asm/unistd*.h</code>中看到可用的系统调用列表。例如:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/11f0ebef3284fb1d0b718fee6a2e3a49.png" data-original-src="https://miro.medium.com/v2/resize:fit:792/format:webp/1*fJUAqfXCGiiV3NA6RESA7Q.png"/></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">32 位系统调用列表</figcaption></figure><p id="1d0a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kp kq kr ks b">int 0x80</code>是一个中断，用于将控制转移到内核，以执行存储在注册表<code class="fe kp kq kr ks b">eax</code>中的 syscall。</p><p id="ffe5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了更好的理解，让我们用<a class="ae lk" href="https://www.sourceware.org/gdb/" rel="noopener ugc nofollow" target="_blank"> gdb </a>调试代码。(要构建二进制代码，使用<code class="fe kp kq kr ks b">nasm -f elf32 -g functions.asm</code>生成<a class="ae lk" href="https://en.wikipedia.org/wiki/Object_code" rel="noopener ugc nofollow" target="_blank">目标代码</a>并将<code class="fe kp kq kr ks b">ld -m elf_i386 functions.o -o functions</code>链接到<a class="ae lk" href="https://www.geeksforgeeks.org/linker/" rel="noopener ugc nofollow" target="_blank">目标代码</a>)</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi ni"><img src="../Images/9e0b9113db556a2476860ce40ebf36ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ek8ps9Wj4lwuHO58hGbGlg.png"/></div></div></figure><p id="4254" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我知道，一开始可能看起来很吓人，但别担心，我会解释发生了什么。</p><ol class=""><li id="86cf" class="kt ku in jm b jn jo jr js jv kv jz kw kd kx kh nn kz la lb bi translated">(第 4 行)IP 设置为 0x08049000，即<code class="fe kp kq kr ks b">call prepare_exit</code>的地址。</li><li id="b7f9" class="kt ku in jm b jn lf jr lg jv lh jz li kd lj kh nn kz la lb bi translated">(第 7 行)一旦 0x08049000 处的指令被执行，就会发生两件事:首先，IP 被设置为<code class="fe kp kq kr ks b">prepare_exit</code>中第一条指令的地址。第二，地址 0x08049005(绿色)被推到堆栈顶部，这被称为<strong class="jm io">返回地址</strong>，是函数结束后应该执行的地址。</li><li id="0ff8" class="kt ku in jm b jn lf jr lg jv lh jz li kd lj kh nn kz la lb bi translated">(第 8 行)执行 0x08049007 处的指令，并且<code class="fe kp kq kr ks b">eax</code>注册表的值为 1。</li><li id="fe2d" class="kt ku in jm b jn lf jr lg jv lh jz li kd lj kh nn kz la lb bi translated">(第 9 行)执行 0x0804900c 处的指令，并且<code class="fe kp kq kr ks b">ebx</code>注册表的值为 0。</li></ol><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi no"><img src="../Images/184b218af296dc354413d1f800adeb20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hgsWz-Hu0AFcKkFwyBMKjw.png"/></div></div></figure><p id="fc22" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后，在<code class="fe kp kq kr ks b">ret</code>被执行后(第 5 行),栈顶被弹出，该值(0x08049005)被加载到 IP 中。</p><p id="babf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，执行 0x08049005 处的指令，进程正常退出。</p><h2 id="4e45" class="mq lm in bd ln mr ms dn lr mt mu dp lv jv mv mw lz jz mx my md kd mz na mh nb bi translated">带参数的函数</h2><p id="7432" class="pw-post-body-paragraph jk jl in jm b jn mj jp jq jr mk jt ju jv ml jx jy jz mm kb kc kd mn kf kg kh ig bi translated">现在让我们看看带参数的函数是如何工作的。有两种主要的方法可以将参数传递给函数:</p><ol class=""><li id="2f8e" class="kt ku in jm b jn jo jr js jv kv jz kw kd kx kh nn kz la lb bi translated">通过在调用函数之前设置寄存器。我们已经这样做了，还记得<code class="fe kp kq kr ks b">ebx</code>是退出状态代码吗？这是退出系统调用的参数。这种方式是最简单的，通常用于系统调用。</li><li id="35e6" class="kt ku in jm b jn lf jr lg jv lh jz li kd lj kh nn kz la lb bi translated">将它们推到堆栈中。我们将详细讨论这一点。</li></ol><p id="6391" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们举下面的例子</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="kn ko l"/></div></figure><p id="3adb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我来解释程序的每一部分。同样，我将通过使用 gdb 来这样做。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi np"><img src="../Images/450ecb930383af8dc505cda466432593.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MU6FCqMR7eKu9-ntY9pkjA.png"/></div></div></figure><ol class=""><li id="0d98" class="kt ku in jm b jn jo jr js jv kv jz kw kd kx kh nn kz la lb bi translated">(第 4 行和第 5 行)堆栈是“空的”。或者我们可以这样认为，因为我们没有向它推送任何东西，但它实际上并不为空，因为它包含了命令收到的参数数量和参数本身(在<a class="ae lk" rel="noopener ugc nofollow" target="_blank" href="/assembly-by-example-compute-string-hash-part-3-cli-args-and-external-functions-c3b533e99cdd">第 3 部分</a>我们将详细讨论这一点)。</li><li id="c37f" class="kt ku in jm b jn lf jr lg jv lh jz li kd lj kh nn kz la lb bi translated">(第 6 行)堆栈现在有两个 int 参数(6 和 7)。</li><li id="11b1" class="kt ku in jm b jn lf jr lg jv lh jz li kd lj kh nn kz la lb bi translated">(第 12 行)将当前的基址指针(在<em class="nc">之前的</em>堆栈框架中使用)保存到堆栈中，因为我们将对其进行修改，但我们需要在<code class="fe kp kq kr ks b">add</code>功能完成后恢复它。否则，调用函数中可能会发生不好的事情🔥(参见附录 B)。</li><li id="56c6" class="kt ku in jm b jn lf jr lg jv lh jz li kd lj kh nn kz la lb bi translated">(第 13 行)当前基址指针在<em class="nc">前一个</em>堆栈框架中使用，在当前堆栈框架中没有用，所以我们把与堆栈指针相同的地址装入其中。这样，我们可以很容易地访问局部变量和参数。我们可以通过将堆栈指针而不是基指针作为引用来做同样的事情，但是这并不常见，并且在使用局部变量时可能会变得复杂(因为在这种情况下，<code class="fe kp kq kr ks b">ebp != esp</code>和<code class="fe kp kq kr ks b">esp</code>可能会改变，而<code class="fe kp kq kr ks b">ebp</code>不会)。</li></ol><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi nq"><img src="../Images/fdbf22de62d87b00d8ce2d31d6756ff8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bvwLkD9qNdm_iizT8Xp1ag.png"/></div></div></figure><p id="32b5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">5.(第 18、19 和 20 行)将参数加载到<code class="fe kp kq kr ks b">eax</code>和<code class="fe kp kq kr ks b">ebx</code>中，这样我们就可以计算它们的总和(我们不能直接对<code class="fe kp kq kr ks b">[ebp+12]</code>和<code class="fe kp kq kr ks b">[ebp+8]</code>求和，需要寄存器)。</p><p id="0d0b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">6.(第 21 行)还记得我在第 3 步解释过恢复基指针状态的重要性吗？这是在第 21 行完成的(在这种情况下，不这样做不会有很大的后果，因为它被恢复到 0x0，但是想想如果不是这样会发生什么。参见附录 B)</p><p id="5dcc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">7.(第 22 行)执行时，该指令弹出返回地址并存储在 IP 中，然后从堆栈中弹出对应于函数参数的 8 个字节。这样，堆栈将像开始时一样结束</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi nr"><img src="../Images/ab0df18bdd8d00117ae2e870030c7bed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XMaiM13EgvLJsP3sBAd0Cw.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">退出代码 015(八进制)相当于 13(十进制)</figcaption></figure><h2 id="ea91" class="mq lm in bd ln mr ms dn lr mt mu dp lv jv mv mw lz jz mx my md kd mz na mh nb bi translated">带参数和局部变量的函数</h2><p id="04fe" class="pw-post-body-paragraph jk jl in jm b jn mj jp jq jr mk jt ju jv ml jx jy jz mm kb kc kd mn kf kg kh ig bi translated">使用数据寄存器非常快，但因为它们(通常)限于 4 个寄存器(eax、ebx、ecx、edx ),我们不能同时存储超过 4 个不同的值。我们可以通过使用堆栈或堆内存来克服这个限制。</p><p id="e243" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用堆内存需要使用像<a class="ae lk" href="https://man7.org/linux/man-pages/man2/sbrk.2.html" rel="noopener ugc nofollow" target="_blank"> sbrk </a>这样的系统调用，但是在这篇文章中我们不打算看一看。还有另一个存储变量的部分叫做<a class="ae lk" href="https://en.wikipedia.org/wiki/.bss" rel="noopener ugc nofollow" target="_blank"> bss </a>，但是使用它没有使用局部变量有趣。所以，我忽略它，现在我将讨论如何在堆栈中存储局部变量，因为这很容易做到，因为它是一个固定大小的内存，内核在开始执行程序时会保留它。</p><p id="2e63" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们举下面的例子</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="kn ko l"/></div></figure><p id="e35e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如您所见，使用局部变量并不复杂。本质上，它可以归结为三个步骤:</p><ol class=""><li id="2253" class="kt ku in jm b jn jo jr js jv kv jz kw kd kx kh nn kz la lb bi translated">为变量“保留”堆栈内存。<code class="fe kp kq kr ks b">sub esp, 8</code>“保留”8 个字节的内存，每个局部变量 4 个字节。“Reserves”在引号之间，因为记住堆栈内存有固定的大小，所以我们不能实际分配或保留内存。我们可以说这是一个“合乎逻辑”的保留。</li><li id="ff9f" class="kt ku in jm b jn lf jr lg jv lh jz li kd lj kh nn kz la lb bi translated">使用局部变量。</li><li id="55c6" class="kt ku in jm b jn lf jr lg jv lh jz li kd lj kh nn kz la lb bi translated">完成后，将堆栈指针重置为基指针。这样就忽略了局部变量。需要注意的是，它们不会被删除，仍然可以访问。</li></ol><p id="188e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第一部分到此结束。我们已经介绍了理解第 2 部分<a class="ae lk" rel="noopener ugc nofollow" target="_blank" href="/assembly-by-example-compute-string-hash-part-2-loops-ba39de0ff6d6">所需的基础知识，在第 2 部分</a>中，我们将编写助手函数来计算字符串散列。</p><p id="95cb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一如既往，如果你认为有什么地方错了或者有什么地方可以改进，请告诉我。</p></div><div class="ab cl ns nt hr nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ig ih ii ij ik"><h2 id="e0e8" class="mq lm in bd ln mr ms dn lr mt mu dp lv jv mv mw lz jz mx my md kd mz na mh nb bi translated">附录 A:我的 gdb 配置</h2><p id="155b" class="pw-post-body-paragraph jk jl in jm b jn mj jp jq jr mk jt ju jv ml jx jy jz mm kb kc kd mn kf kg kh ig bi translated">我个人对 gdb ( <code class="fe kp kq kr ks b">~/.gdbinit</code>)的配置其实挺简单的。</p><pre class="ki kj kk kl gt nz ks oa ob aw oc bi"><span id="158b" class="mq lm in ks b gy od oe l of og">set debuginfod enabled off<br/>set disassemble-next-line on</span></pre><p id="a7ab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在所有前面的图像中，字节都是以大端格式显示的。然而，有时以小尾顺序显示它们会很方便。为此，您可以使用下面的代码行。</p><pre class="ki kj kk kl gt nz ks oa ob aw oc bi"><span id="d7f7" class="mq lm in ks b gy od oe l of og">set endian little</span></pre><h2 id="49e8" class="mq lm in bd ln mr ms dn lr mt mu dp lv jv mv mw lz jz mx my md kd mz na mh nb bi translated">附录 B:如果先前的基指针没有被恢复会发生什么？</h2><p id="1d94" class="pw-post-body-paragraph jk jl in jm b jn mj jp jq jr mk jt ju jv ml jx jy jz mm kb kc kd mn kf kg kh ig bi translated">如前所述，坏事🔥如果函数结束后没有恢复基指针，可能会发生这种情况。举下面的例子</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="kn ko l"/></div></figure><p id="a077" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您执行它，您将看到我们没有得到预期的输出(并且可能更糟)。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi oh"><img src="../Images/61b8d1d319f1edad8c7e6b0b5fb2ee0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VO1dejzunGjimBD2OAXjgw.png"/></div></div></figure><p id="cdef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我会让你发现为什么我们会有这种行为。</p><p id="8724" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="nc">注</em>:你想想看，你可以根据需要多次解引用<code class="fe kp kq kr ks b">ebp</code>，直到它有空值(0x0)，从而得到一个函数的<strong class="jm io">栈迹</strong>，因为<code class="fe kp kq kr ks b">ebp</code>指向的值始终是<code class="fe kp kq kr ks b">ebp</code>的前一个值。</p></div></div>    
</body>
</html>