# 日志结构化合并树

> 原文：<https://blog.devgenius.io/log-structured-merge-tree-a8733ce152b2?source=collection_archive---------4----------------------->

许多 NoSQL 数据库背后的秘方

日志结构合并是许多现代 NoSQL 数据库中使用的一种重要技术，例如 BigTable、Cassandra、HBase、RocksDB 和 DynamoDB。它为长期经历高更新率的文件提供了低成本的索引。

写入首先进入内存中的平衡二叉树(红黑树或 Skiplist)。这种内存中的数据结构也称为 MemTable。在写入之前，会将条目附加到预写日志(WAL)文件中，以防止崩溃并确保持久性。当达到 MemTable 阈值时，WAL 被刷新并用新的替换。

![](img/8f923e188e889a062a95512adb9bd4a7.png)

当达到某个阈值时，Memtables 将作为已排序的字符串表(SSTable)刷新到磁盘。这些表是不可变的，并且使用顺序的磁盘 I/O。SSTable 由称为 Segment 的多个排序文件组成。SSTable 分为数据文件、索引文件和摘要文件。

![](img/b09eb5b79f48b8a61ac0088def6e6de6.png)

## 表摘要文件

表摘要文件保存在内存中，并为索引文件中的快速查找提供了一个键示例。可以把它想象成一个表索引文件的索引。要搜索某个特定的键，首先要查阅摘要文件，找出可以找到该键的小范围位置，然后将该特定偏移量加载到内存中。

## 表索引文件

索引文件按顺序列出数据文件中的键，给出每个键在数据文件中的位置。

## 稳定数据文件

该表包含存储在称为块的块中的键值条目。这些数据文件是经过编码的。这些块也被压缩以节省磁盘空间。不同级别的压缩算法可能不同。对于数据完整性，使用校验和。

![](img/853373459b03db048a1be85e3ea8a307.png)

## 压缩/合并表

压缩是一个后台过程，不断将旧数据段组合成新数据段。LSM 树的读写性能受压缩方式的影响很大。

> 层压缩—写优化(Cassandra)
> 级别压缩—读优化(RocksDB)
> 时间窗口— InfluxDB
> 快照压缩
> 混合压缩— ScyllaDB

![](img/8c432b34ac6ea2573a7f550e7dc29f91.png)

在实现方面，使用专用的后台线程来执行压缩。作为一种优化，可能有多个专用的压缩器线程在给定的时间点运行(如在 RocksDB 中)来压缩 SSTables 文件。压缩线程还负责在任何合并后更新稀疏索引，以指向新表文件中键的新偏移量。

## 阅读 LSM

我们首先搜索内存表。由于 MemTables 位于内存中，所以查找速度很快，如果我们在 Memtables 上找到任何数据，我们就将结果返回给客户机。如果 MemTables 上没有这个键，那么我们就在表中搜索这个键，Bloom filters 帮助我们缩小了搜索范围。我们会从最新的部分开始，然后回到最老的部分，直到找到我们要找的那个键。这意味着我们能够更快地检索最近写入的密钥。一个简单的优化是保持内存中的稀疏索引。

![](img/63f6b01ee34d5db7b97f72c58435356c.png)

## 删除 LSM

删除实际上遵循与写入数据完全相同的路径。每当接收到删除请求时，就会为该键写入一个称为 *tombstone* 的唯一标记。最终，墓碑会被压缩掉，这样这个值就不再存在于磁盘上了。

## LSM 树的缺点

*   压缩是资源密集型的
*   需要更多空间(即使删除也会增加存储)
*   读取速度较慢

感谢阅读！！