<html>
<head>
<title>Don’t Use Native DOM Manipulations In Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要在 Angular 中使用本机 DOM 操作</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/dont-use-native-dom-manipulations-in-angular-6c8db13f463f?source=collection_archive---------10-----------------------#2020-07-12">https://blog.devgenius.io/dont-use-native-dom-manipulations-in-angular-6c8db13f463f?source=collection_archive---------10-----------------------#2020-07-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/7e1ece473d35d101df6da9965497c24d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1bwJ1pCXKQE4SQmZ7lfY8Q.png"/></div></div></figure><p id="d091" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">大多数前端项目都有根据各种条件改变 DOM 结构的需求。例如为特定用户显示或隐藏页面的一部分。这些类型的活动可以通过 DOM 操作来实现。</p><p id="cad7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Angular 提供了各种结构指令来实现这一点。但是对于其他需要进行多种 DOM 操作并且操作逻辑非常复杂的复杂场景，您可能希望使用您的 typescript 代码进行 DOM 操作。</p><p id="9497" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我们可能会开始使用像<strong class="jx io"> document.getElementById </strong>或<strong class="jx io"> document.appendChild </strong>这样的方法，它们是本地 DOM 操作方法。但是如果我们仔细查看 Angular 的文档<a class="ae kt" href="https://angular.io/api/core/Renderer2" rel="noopener ugc nofollow" target="_blank">你会发现一个名为 Renderer2 的 API 用于 DOM 操作。但是这些方法中的大多数什么都不是，只是原生 DOM 操作 API 的包装。让我们在这里看到他们</a><a class="ae kt" href="https://github.com/angular/angular/blob/e3140ae888ac4037a5f119efaec7b1eaf8726286/packages/platform-browser/src/dom/dom_renderer.ts#L102" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="e4bd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你看它的代码，你会注意到在它的内部，它使用相同的原生 DOM API 进行操作。那么 Angular 为什么建议使用自己的 Renderer2 API 而不是原生 DOM 操作呢？</p><p id="ecf6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这主要有两个原因。</p><ol class=""><li id="f0ea" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks kz la lb lc bi translated"><strong class="jx io">服务器端渲染(角度通用)</strong></li><li id="73de" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated"><strong class="jx io">安全</strong></li></ol><p id="a05e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们一个一个地谈论它们:-</p><ol class=""><li id="fd83" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks kz la lb lc bi translated"><strong class="jx io">服务器端渲染(角度通用)</strong></li></ol><p id="b8b6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以下是 Angular Universal Page 的官方声明:-</p><blockquote class="li lj lk"><p id="05a7" class="jv jw ll jx b jy jz ka kb kc kd ke kf lm kh ki kj ln kl km kn lo kp kq kr ks ig bi translated">因为通用应用程序不能在浏览器中执行，所以服务器上可能会缺少一些浏览器 API 和功能。</p><p id="a156" class="jv jw ll jx b jy jz ka kb kc kd ke kf lm kh ki kj ln kl km kn lo kp kq kr ks ig bi translated">例如，服务器端应用程序不能引用浏览器专用的全局对象，如<code class="fe lp lq lr ls b">window</code>、<code class="fe lp lq lr ls b">document</code>、<code class="fe lp lq lr ls b">navigator</code>或<code class="fe lp lq lr ls b">location</code>。</p><p id="0ce9" class="jv jw ll jx b jy jz ka kb kc kd ke kf lm kh ki kj ln kl km kn lo kp kq kr ks ig bi translated">Angular 为这些对象提供了一些可注入的抽象，比如<code class="fe lp lq lr ls b"><a class="ae kt" href="https://angular.io/api/common/Location" rel="noopener ugc nofollow" target="_blank">Location</a></code>或<code class="fe lp lq lr ls b"><a class="ae kt" href="https://angular.io/api/common/DOCUMENT" rel="noopener ugc nofollow" target="_blank">DOCUMENT</a></code>；它可以充分替代这些原料药。如果 Angular 不提供它，可以编写新的抽象，在浏览器中委托给浏览器 API，在服务器上委托给替代实现(也称为 shimming)。</p></blockquote><p id="0af7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 2。安全</strong></p><p id="9254" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设您想创建一个指令，在使用该指令的地方将元素高亮显示为红色。这可以通过执行下面提到的代码来实现</p><figure class="lt lu lv lw gt jo"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="01ce" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将很好地工作，但首先让我们听听 Angular 团队告诉我们如何使用 ElementRef <a class="ae kt" href="https://angular.io/api/core/ElementRef#properties" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><blockquote class="li lj lk"><p id="7638" class="jv jw ll jx b jy jz ka kb kc kd ke kf lm kh ki kj ln kl km kn lo kp kq kr ks ig bi translated">当需要直接访问 DOM 时，使用这个 API 作为最后的手段。请改用 Angular 提供的模板和数据绑定。或者，您可以看一看<code class="fe lp lq lr ls b"><a class="ae kt" href="https://angular.io/api/core/Renderer2" rel="noopener ugc nofollow" target="_blank">Renderer2</a></code>,它提供了即使不支持直接访问本地元素也可以安全使用的 API。</p><p id="496c" class="jv jw ll jx b jy jz ka kb kc kd ke kf lm kh ki kj ln kl km kn lo kp kq kr ks ig bi translated">依赖于直接 DOM 访问会在应用程序和呈现层之间产生紧密耦合，这使得不可能将两者分开并将应用程序部署到 web worker 中。</p></blockquote><p id="e0db" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">同样的指令可以如下实现。</p><figure class="lt lu lv lw gt jo"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="c8ce" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您也可以选择实现自己的 Renderer2 实现。因为这是渲染 2 <a class="ae kt" href="https://angular.io/api/core/Renderer2" rel="noopener ugc nofollow" target="_blank">的官方声明，这里是</a>。</p><blockquote class="li lj lk"><p id="3e18" class="jv jw ll jx b jy jz ka kb kc kd ke kf lm kh ki kj ln kl km kn lo kp kq kr ks ig bi translated">扩展此基类以实现自定义呈现。默认情况下，Angular 将模板呈现到 DOM 中。您可以使用自定义渲染来拦截渲染调用，或者渲染到<strong class="jx io">而不是 DOM </strong>。</p></blockquote><p id="0a62" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可能会这样想，因为我们在项目中没有使用服务器端渲染，所以可以使用原生 DOM APIs，但将来您可能希望从提高应用程序性能中受益。此外，Renderer2 可以实现为支持除 DOM 之外的其他东西的呈现。这仅仅意味着它是未来的证明。</p><blockquote class="li lj lk"><p id="5094" class="jv jw ll jx b jy jz ka kb kc kd ke kf lm kh ki kj ln kl km kn lo kp kq kr ks ig bi translated">Angular 的未来将会看到更多与服务器端渲染、Web Workers 等领域的性能相关的改进。减少构建规模只会在一定程度上增加。让您的项目准备好开始从现在可用的和将来可能可用的这些改进中获益。你应该开始使用 Angular 提供的 Renderer2 API，而不是使用原生的 DOM 操纵 API。</p></blockquote></div></div>    
</body>
</html>