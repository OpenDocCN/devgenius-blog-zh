<html>
<head>
<title>Creating Elasticsearch Analyzers Programmatically</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以编程方式创建弹性搜索分析器</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/creating-elasticsearch-analyzers-programmatically-b37fff196ee3?source=collection_archive---------1-----------------------#2020-12-28">https://blog.devgenius.io/creating-elasticsearch-analyzers-programmatically-b37fff196ee3?source=collection_archive---------1-----------------------#2020-12-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/0232b1911621ea7f8fa3c62fb5996c10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2rlou6uvBfnI8OUl96HObg.png"/></div></div></figure><p id="4266" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Elasticsearch(以及底层的Lucene)在其强大的搜索引擎中提供了强大的文本分析功能。您可以在Elasticsearch上选择一个预配置的分析器，或者配置您的自定义分析器来分析文本并获取其标记，甚至不需要配置索引或插入文档。然而，你需要一个Elasticsearch实例，还需要进行远程调用(HTTP或TCP)来分析文本。</p><p id="1ac7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这篇博文中，我将讨论如何通过编程创建一个定制的分析器，而不需要部署Elasticsearch。我们所需要的就是在我们的类路径中包含Elasticsearch和几行代码。这个实现是用Kotlin实现的，但是可以很容易地转换成Java或任何JVM语言。</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="b3a2" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">分析仪成分</h1><p id="e9c4" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">在这一点上，重温与Elasticsearch (Lucene)文本分析器相关的概念可能是有用的。文本分析器由以下组件组成:</p><ul class=""><li id="cb51" class="md me in jx b jy jz kc kd kg mf kk mg ko mh ks mi mj mk ml bi translated">标记器(强制)</li><li id="1101" class="md me in jx b jy mm kc mn kg mo kk mp ko mq ks mi mj mk ml bi translated">字符过滤器列表(可选)</li><li id="58f0" class="md me in jx b jy mm kc mn kg mo kk mp ko mq ks mi mj mk ml bi translated">令牌过滤器列表(可选)</li></ul><p id="3c72" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Elasticsearch默认提供了各种记号赋予器、字符过滤器和记号过滤器实现。您可以组合它们中的任何一个来创建您的定制分析器或者实现您的分析器。</p><p id="cb34" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Tokenizer是分析器中的核心组件，它将输入文本分解成标记。空白和标准记号赋予器是Elasticsearch提供的最流行的两种。</p><p id="5f69" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">字符过滤器用于在标记器处理文本之前对文本进行预处理。使用字符过滤器，可以删除HTML元素(HTML条形过滤器)或替换某些字符(模式替换过滤器)。</p><p id="fd86" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">令牌过滤器用于操作由令牌化器生成的令牌。您可以通过应用一系列令牌过滤器，将生成的令牌转换为小写，删除停用词，扩展/减少同义词，执行词干分析或许多其他操作。</p><p id="ca8d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如需全面的文档，请访问<a class="ae mr" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-custom-analyzer.html" rel="noopener ugc nofollow" target="_blank"> Elasticsearch Reference </a>。</p><h1 id="f8a3" class="la lb in bd lc ld ms lf lg lh mt lj lk ll mu ln lo lp mv lr ls lt mw lv lw lx bi translated">我们的定制分析仪</h1><p id="9a45" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">在本例中，我们将实现一个满足以下要求的定制分析器:</p><ul class=""><li id="1202" class="md me in jx b jy jz kc kd kg mf kk mg ko mh ks mi mj mk ml bi translated">HTML字符被剥离。</li><li id="b5e4" class="md me in jx b jy mm kc mn kg mo kk mp ko mq ks mi mj mk ml bi translated">文本由空格标记。</li></ul><p id="2b29" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">令牌过滤规则描述为:</p><ul class=""><li id="91b3" class="md me in jx b jy jz kc kd kg mf kk mg ko mh ks mi mj mk ml bi translated">标记被转换成小写。</li><li id="dc34" class="md me in jx b jy mm kc mn kg mo kk mp ko mq ks mi mj mk ml bi translated">标记“a”、“an”和“on”被视为停止字，并从输出中删除</li><li id="def0" class="md me in jx b jy mm kc mn kg mo kk mp ko mq ks mi mj mk ml bi translated">“blogpost”被认为是同义词，被简化为“Blog post”。</li></ul><p id="6fbf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此输入，<em class="mx">在&lt;b&gt;elastic search&lt;/b&gt;"</em>上的一篇博文被分析为以下令牌:</p><ul class=""><li id="74f8" class="md me in jx b jy jz kc kd kg mf kk mg ko mh ks mi mj mk ml bi translated">博客帖子</li><li id="71e8" class="md me in jx b jy mm kc mn kg mo kk mp ko mq ks mi mj mk ml bi translated">弹性搜索</li></ul><p id="fb65" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意，首先过滤HTML标签；然后文本被标记化。所有标记都被转换成小写，停用词“a”和“on”被移除，并且“blog post”通过同义词减少被转换成“blogpost”。</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="a52c" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">履行</h1><h2 id="03e8" class="my lb in bd lc mz na dn lg nb nc dp lk kg nd ne lo kk nf ng ls ko nh ni lw nj bi translated">属国</h2><p id="f7e5" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">Elasticsearch应该被添加到依赖项中的类路径中，你可以看到一个如下的gradle.kts版本:</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="f64d" class="my lb in np b gy nt nu l nv nw"><em class="mx">implementation</em>(“org.elasticsearch:elasticsearch:7.8.1”)</span></pre><h2 id="3739" class="my lb in bd lc mz na dn lg nb nc dp lk kg nd ne lo kk nf ng ls ko nh ni lw nj bi translated">标记器</h2><p id="5db0" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">Elasticsearch Analyzer中的组件是为每个分析请求创建的。出于这个原因，分析器不是由组件本身组成，而是由负责实例化这些组件的工厂组成。</p><p id="c265" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面你可以看到一个记号赋予器工厂是如何作为一个匿名对象被创建的。</p><figure class="nk nl nm nn gt jo"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h2 id="4cda" class="my lb in bd lc mz na dn lg nb nc dp lk kg nd ne lo kk nf ng ls ko nh ni lw nj bi translated">字符过滤器</h2><p id="59b7" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">与TokenizerFactory类似，我们创建一个CharFilterFactory对象数组。在下面的示例中，您可以看到如何创建这样的数组，以及如何添加HTMLStripCharFilter的工厂。</p><figure class="nk nl nm nn gt jo"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h2 id="ff69" class="my lb in bd lc mz na dn lg nb nc dp lk kg nd ne lo kk nf ng ls ko nh ni lw nj bi translated">令牌过滤器</h2><p id="de35" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">与字符筛选器类似，必须为自定义分析器创建一个TokenFilterFactory对象数组。在下面的代码中，您可以看到小写过滤器、停用词过滤器和同义词过滤器的工厂是如何创建的。</p><p id="86f5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于停用词和同义词，请注意我们在过滤器中硬编码停用词和同义词词典。</p><figure class="nk nl nm nn gt jo"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h2 id="b87c" class="my lb in bd lc mz na dn lg nb nc dp lk kg nd ne lo kk nf ng ls ko nh ni lw nj bi translated">将它们结合在一起</h2><p id="0a1b" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">一旦我们创建了记号赋予器和过滤器工厂，我们就可以将它们组合起来创建我们的定制分析器，如下所示:</p><figure class="nk nl nm nn gt jo"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h2 id="a357" class="my lb in bd lc mz na dn lg nb nc dp lk kg nd ne lo kk nf ng ls ko nh ni lw nj bi translated">调用分析器</h2><p id="30ff" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">创建分析器之后，您可以看到如何使用它将文本分解成标记。</p><figure class="nk nl nm nn gt jo"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="d487" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">内部分析器组件的工作类似于<a class="ae mr" href="https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern" rel="noopener ugc nofollow" target="_blank">责任链</a>，每个令牌都被传递给链中的下一个组件。在每次递增(<em class="mx"> incrementToken() </em>)时，分析器链提取并使用下一个令牌。在链的末端，分析器链已经设置了一组属性。在上面的例子中，我们提取CharTermAttribute(即:令牌的文本)并添加到我们的结果列表中。也有可能提取其他信息，如位置信息等。从代币上。</p><p id="fc28" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当所有的令牌都被消耗掉后，我们就可以返回我们分析过的令牌列表了。</p><p id="7c74" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面您可以看到一个单元测试中的分析器调用示例:</p><figure class="nk nl nm nn gt jo"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h1 id="7263" class="la lb in bd lc ld ms lf lg lh mt lj lk ll mu ln lo lp mv lr ls lt mw lv lw lx bi translated">摘要</h1><p id="4339" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">在本文中，我们讨论了如何在不部署Elasticsearch集群的情况下以编程方式实现Elasticsearch/Lucene分析器。为此，我们手动配置了一个Tokenizer、一组CharFilterFactory和TokenFilter实例来创建一个分析器，并将文本分析作为一种方法公开。你可以在这个github <a class="ae mr" href="https://github.com/itasyurt/elastic7-analyzers" rel="noopener ugc nofollow" target="_blank"> repo </a>中找到完整的源代码。</p></div></div>    
</body>
</html>