<html>
<head>
<title>Binary Search Tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">二叉查找树</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/binary-search-tree-3691726e8474?source=collection_archive---------0-----------------------#2020-04-26">https://blog.devgenius.io/binary-search-tree-3691726e8474?source=collection_archive---------0-----------------------#2020-04-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="0b8c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">什么是二叉查找树？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4bf9c9c3b226702582ab238650faa1bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W8AsjsEofoZxenr34RgRMA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">我的一些代码img 1</figcaption></figure><p id="d698" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">二叉查找树是数据结构之一。树有根，孩子的二叉树有两个孩子，因为它是一个二叉树:D，二叉查找树由节点而来。没有子节点的节点称为叶节点。</p><p id="bf9a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">二叉查找树有两个孩子</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ky"><img src="../Images/0ba4166bab4f55a5a1d3f16d8afee29d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YQ1t6ZVjdR9rNvpegFC4Qg.png"/></div></div></figure><p id="39e3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">二叉查找树由节点组成。每个节点保存树数据，左子地址和右子地址。</p><p id="8795" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如何创造一个新的二叉查找树？</p><p id="6b29" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们从根节点开始，将第一个数据保存在根节点中，如果新数据大于根节点，它将成为右子节点，如果新节点小于根节点，它将成为根节点的左子节点。</p><p id="37d7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">遍历树</p><p id="0cef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">4种方法拯救所有的树</p><ol class=""><li id="3978" class="kz la in jm b jn jo jr js jv lb jz lc kd ld kh le lf lg lh bi translated">Inorder遍历:inorder遍历是先递归访问当前节点的左子树，然后是当前节点本身，最后递归访问当前节点的右子树。</li><li id="ca52" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">前序:前序遍历是先访问当前节点，然后递归访问当前节点的左子树，最后递归访问当前节点的右子树。</li><li id="f89d" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">后序:后序遍历是先访问当前节点的左子树，再访问当前节点的右子树，最后访问当前节点本身。</li><li id="c373" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">广度优先:广度优先遍历是逐层访问节点。首先访问根，然后从左到右访问根的所有子代，然后从左到右访问根的孙代，依此类推。</li></ol><p id="bdcc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如何从二叉查找树中删除元素？</p><p id="f3c9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要从二叉树中删除一个元素，首先需要找到包含该元素的节点及其父节点。</p><p id="d117" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让current指向包含二叉树中元素的节点，parent指向当前节点的父节点。将当前节点中的元素值替换为最右节点中的元素值，将parentOfRightMost节点与最右节点的左子节点连接，删除最右节点，如图右所示。</p><p id="b155" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有两种情况:</p><p id="61a7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">情况1:当前节点没有左子节点，如图左侧所示。只需将父节点与当前节点的右子节点连接起来，如图右侧所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/c39b45aad8d5b9ad39e979b976792b53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*-WuDl_eT2P70FBec6qbURw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">案例1</figcaption></figure><p id="6959" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">案例1:当前节点有一个左子节点。</p><p id="0983" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让right right指向当前节点左子树中包含最大元素的节点，parentOfRightMost指向最右边节点的父节点，如图左边所示。</p><p id="8b0d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请注意，最右边的节点不能有右子节点，但可以有左子节点。</p><p id="ee71" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将当前节点中的元素值替换为最右节点中的元素值，将parentOfRightMost节点与最右节点的左子节点连接，删除最右节点，如图右所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lo"><img src="../Images/babb505830989f599a4d5445d4ad50b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Hhr-br9UJT_5umk5SUYYA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">案例2</figcaption></figure><p id="8035" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">二叉查找树时间复杂度</p><p id="4904" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">很明显，顺序、前顺序和后顺序的时间复杂度是O(n ),因为每个节点只被遍历一次。</p><p id="3d34" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">搜索、插入和删除的时间复杂度是树的高度。</p><p id="7cdc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在最坏的情况下，树的高度是O(n)。</p><p id="1a26" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是我的一些代码</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lp lq l"/></div></figure></div></div>    
</body>
</html>