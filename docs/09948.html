<html>
<head>
<title>9 tips on writing cleaner SQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写更简洁 SQL 的 9 个技巧</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/9-tips-on-writing-cleaner-sql-d3cb22e30302?source=collection_archive---------4-----------------------#2022-09-25">https://blog.devgenius.io/9-tips-on-writing-cleaner-sql-d3cb22e30302?source=collection_archive---------4-----------------------#2022-09-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="a3f2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">结构化查询语言以其首字母缩写 SQL(无论您将其发音为 es-queue-el 还是 sequel)而广为人知，是检索和处理数据最广泛使用的语言之一。虽然它已经存在了半个世纪，但没有迹象表明它会很快消失。数百万数据库管理员、开发人员、数据分析师和数据工程师每天都在编写 SQL 命令。</p><p id="ace1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这篇短文中，我们将探讨一些如何改进 SQL 查询的技巧，使它们更具可读性、整洁性和可维护性。</p><h1 id="2a06" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">格式化您的查询</h1><p id="ab7c" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">我们首先需要考虑的是如何格式化查询。有很多方法可以做到这一点，但下面应该是一个好的开始。请记住，阅读 SQL(由您自己或他人编写)会花费大量时间，因此，从长远来看，在整理代码方面付出一点努力是值得的。</p><h2 id="4b17" class="ll kj in bd kk lm ln dn ko lo lp dp ks jv lq lr kw jz ls lt la kd lu lv le lw bi translated">大写 SQL 关键字</h2><p id="57be" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">SQL 不强制关键字的大小写，但是如果您将 SQL 关键字大写以直观地将它们与列名和表名区分开来，可能会使核心更具可读性。</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="mc md l"/></div></figure><h2 id="5a01" class="ll kj in bd kk lm ln dn ko lo lp dp ks jv lq lr kw jz ls lt la kd lu lv le lw bi translated">使用一致的缩进</h2><p id="68bc" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">选择一个缩进模式并保持一致是很好的。我建议使用制表符而不是空格来缩进。</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="mc md l"/></div></figure><h2 id="24fd" class="ll kj in bd kk lm ln dn ko lo lp dp ks jv lq lr kw jz ls lt la kd lu lv le lw bi translated">错认假频伪信号</h2><p id="92b6" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">避免隐式列别名，因为它是混淆的来源。</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="b473" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为列、cte、子查询和表提供简洁而有意义的别名，同时遵守一致的命名约定</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="17da" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果从多个表中选择数据，请使用选择列表中的表名或表别名来标识哪个列来自哪个表。</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="mc md l"/></div></figure><h2 id="cf93" class="ll kj in bd kk lm ln dn ko lo lp dp ks jv lq lr kw jz ls lt la kd lu lv le lw bi translated">避免选择*</h2><p id="efb9" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">选择*可能看起来很方便，但是它为大量令人头疼的维护和性能问题打开了大门。最好显式地命名您想要选择的列。</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="mc md l"/></div></figure><h1 id="f9d2" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">评论</h1><p id="a6e9" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">在维护别人编写的代码时，注释可能会非常有用，因为可能缺少其他文档。当声明的意图与代码所做的不一致(或者不再一致)时，它还可以帮助识别 bug。当然，在提供太多信息和提供不够上下文之间需要找到一个中间点。</p><ul class=""><li id="391c" class="me mf in jm b jn jo jr js jv mg jz mh kd mi kh mj mk ml mm bi translated">使用多行注释来解释特定脚本的预期意图，以获得详细的解释或说明。</li><li id="0ccc" class="me mf in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated">使用单行注释来注释你的代码，以便于维护。</li></ul><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="mc md l"/></div></figure><h1 id="3e32" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">避免嵌套查询，使用 cte</h1><p id="3953" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">虽然嵌套查询和公共表表达式(CTE)应该(至少在理论上)具有相同的性能，但是 CTE 在调试时可读性更好，也更方便。</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="c446" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">随着查询复杂性的增加，这变得更加明显。</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="mc md l"/></div></figure><h1 id="6355" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">仅处理您需要的数据</h1><p id="28c2" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">当处理包含 cte 或子查询的复杂查询时，如果我们只查询以某种方式使用的列和行，会有所帮助。</p><p id="208c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，尽早过滤掉尽可能多的数据。尽可能减少解决问题所需的列数和行数。<strong class="jm io">同样，只保留你需要的列和行</strong>。</p><h1 id="706c" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">如果某件事很乏味，可能有更聪明的方法</h1><p id="0589" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">例如，在 SQL Server 中，当尝试透视结果集时，您需要提供新的列名。如果你有一打的专栏，或者如果这些事情改变了，这可能是一个乏味的任务。快速搜索可能有助于找到更好的方法来解决这个问题。</p><p id="002d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">参见 SQL Server 示例<a class="ae ms" href="https://stackoverflow.com/questions/10404348/sql-server-dynamic-pivot-query" rel="noopener ugc nofollow" target="_blank">这里的</a>。</p><h1 id="b59c" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">开发和调试方法</h1><p id="eb55" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">调试是使用 SQL 的一个重要部分。不管是你还是其他人写的一段代码，拥有正确的方法可能有助于找到根本原因。</p><ul class=""><li id="98c1" class="me mf in jm b jn jo jr js jv mg jz mh kd mi kh mj mk ml mm bi translated">从小处着手:使用你熟悉的数据子集。更好地理解数据的形状，不管它是否干净，一点一点地执行更大的查询。</li><li id="447a" class="me mf in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated">调试单个示例:当执行计算时，从一个特定的观察开始(例如一个人或一个订单)</li><li id="eb59" class="me mf in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated">以正确的粒度工作:根据查询需要解决的任务来设计数据。如果你每月计算一次国家指标，那么在将它们结合在一起之前，中间步骤需要有相同的粒度<strong class="jm io">。</strong></li></ul><h1 id="43df" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">如果您重用(并且如果可以的话)，请具体化</h1><p id="256a" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">当处理在同一个查询中(甚至在多个查询中)多次重用的结果集时，请考虑具体化该数据，以避免不必要的计算。您可以在 SQL 实现中使用手边的工具，比如临时表或常规表。</p><h1 id="968c" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">正确使用 DISTINCT 和 UNION</h1><p id="cd86" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">消除重复数据无疑非常重要，DISTINCT 和 UNION 关键字非常方便。但是使用它们是要付出性能代价的，所以我们需要注意我们是否需要它。</p><ul class=""><li id="1626" class="me mf in jm b jn jo jr js jv mg jz mh kd mi kh mj mk ml mm bi translated">如果已知要合并的结果集不同，请使用 UNION ALL 而不是 UNION。这将节省不必要的处理。</li><li id="4b1d" class="me mf in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated">显然，当我们清楚地表明每一行都是唯一的时，就没有必要使用 DISTINCT</li><li id="2854" class="me mf in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated">如果不清楚您要删除的是什么(例如，多个列包含或将来可能包含重复项)，请选择使用明确的删除重复步骤，例如使用 ROW_NUMBER。</li></ul><h1 id="a29f" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">使用您的 SQL 实现(及其版本)的全部功能</h1><p id="935f" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">虽然 SQL 有一个标准，但是各个数据库引擎实现并不总是以相同的方式遵循它。因此，当试图解决一个问题时，总是寻求理解如何解决问题。</p><p id="3665" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">定期检查您的产品文档，寻找可能会让您的生活变得轻松的新内容。我最近发现 BigQuery 中的<a class="ae ms" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax#with_clause" rel="noopener ugc nofollow" target="_blank">递归 cte 现在已经被添加到预览版</a>中。</p><h1 id="2fc6" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">结论</h1><p id="244c" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">这当然不是 SQL 最佳实践的详尽列表，而且，在某些情况下，需求或环境可能会要求不这样做。像往常一样，就像所有的技巧一样，我们应该始终根据具体情况进行权衡，并把事情做好。总而言之，我希望以上快速提示对你的日常工作有用。</p><p id="324d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">快乐 SQLing！</p></div></div>    
</body>
</html>