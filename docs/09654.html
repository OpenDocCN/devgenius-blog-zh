<html>
<head>
<title>Ktor REST Apis - Integrating SQL Database using Ktorm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Ktorm 集成 SQL 数据库</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/ktor-rest-apis-integrating-sql-database-using-ktorm-7adacdf41003?source=collection_archive---------2-----------------------#2022-09-03">https://blog.devgenius.io/ktor-rest-apis-integrating-sql-database-using-ktorm-7adacdf41003?source=collection_archive---------2-----------------------#2022-09-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><h2 id="326b" class="il im in bd b dl io ip iq ir is it dk iu translated" aria-label="kicker paragraph">后端教程</h2><div class=""/><div class=""><h2 id="05c1" class="pw-subtitle-paragraph jt iw in bd b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk dk translated">数据库里有吗？</h2></div><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/723ab5c5c69355bb53a1061553080ff1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oJHHU4rCQd1eYvih.png"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">来源:BMC 软件</figcaption></figure><p id="80c1" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">在我以前的文章中，展示了如何使用 Ktor 框架设置、创建和测试简单的静态 rest apis。本文是这三个系列文章的延伸，在这一篇中，我们将探索如何将数据库添加到我们的 API 中。我们将使用 SQL 数据库。</p><p id="6243" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">万一你想从头开始，请阅读以下内容，你不会失望的。</p><blockquote class="lt lu lv"><p id="306c" class="kx ky lw kz b la lb jx lc ld le ka lf lx lh li lj ly ll lm ln lz lp lq lr ls ig bi translated"><a class="ae ma" href="https://proandroiddev.com/build-rest-apis-using-ktor-framework-i-dbbf36b332bb" rel="noopener ugc nofollow" target="_blank">Ktor REST API—第 1 部分(项目设置)</a><br/><a class="ae ma" href="https://proandroiddev.com/build-rest-apis-using-ktor-framework-ii-47948e89f1d6" rel="noopener ugc nofollow" target="_blank">Ktor REST API—第 2 部分(创建路线)</a><br/><a class="ae ma" href="https://proandroiddev.com/build-rest-apis-using-ktor-framework-iii-87e579a7258e" rel="noopener ugc nofollow" target="_blank">Ktor REST API—第 3 部分(测试路线)</a></p></blockquote></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><h1 id="1a4e" class="mi mj in bd mk ml mm mn mo mp mq mr ms kc mt kd mu kf mv kg mw ki mx kj my mz bi translated">数据库服务器设置</h1><p id="2d76" class="pw-post-body-paragraph kx ky in kz b la na jx lc ld nb ka lf lg nc li lj lk nd lm ln lo ne lq lr ls ig bi translated">首先，我们需要一个本地数据库服务器启动并运行，以连接到 SQL 客户端应用程序。Sql 客户端应用程序将呈现我们的数据库，并让我们非常顺利地执行查询。按照以下步骤进行设置:</p><ul class=""><li id="ccfa" class="nf ng in kz b la lb ld le lg nh lk ni lo nj ls nk nl nm nn bi translated">下载任何 SQL 客户端应用程序。我用的是<a class="ae ma" href="https://dev.mysql.com/downloads/mysql/8.0.html" rel="noopener ugc nofollow" target="_blank"> MySqlWorkBench </a></li><li id="cb35" class="nf ng in kz b la no ld np lg nq lk nr lo ns ls nk nl nm nn bi translated">安装应用程序</li><li id="c0b5" class="nf ng in kz b la no ld np lg nq lk nr lo ns ls nk nl nm nn bi translated">进入系统偏好设置启动服务器，你会在底部看到一个图标。点击它并启动服务器。</li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi nt"><img src="../Images/a436be689c40385982448cfe11a9c218.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T7ERLw2T5VmcZTP6yQTHag.png"/></div></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">系统偏好设置-&gt; MySql</figcaption></figure><p id="0037" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">工作台应用程序如下所示</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi ny"><img src="../Images/8a28e8d328abbb837a2eadb4aa791909.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CEAYaABqsOQAN8uguUXwag.png"/></div></div></figure><p id="e330" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">就这样了。让我们进入下一步。</p></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><h1 id="5af9" class="mi mj in bd mk ml mm mn mo mp mq mr ms kc mt kd mu kf mv kg mw ki mx kj my mz bi translated">数据库设置</h1><p id="4589" class="pw-post-body-paragraph kx ky in kz b la na jx lc ld nb ka lf lg nc li lj lk nd lm ln lo ne lq lr ls ig bi translated">因为我们正在阅读，这意味着我们知道 Ktor 的基本结构和术语。所以直接建立我们的数据库将是第一步。</p><p id="929c" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">虽然 Ktor 提供了基本的 SQL 特性支持，但是我们会使用 ORM 框架<strong class="kz ix">k ORM</strong>。</p><blockquote class="nz"><p id="4560" class="oa ob in bd oc od oe of og oh oi ls dk translated">Ktorm 是一个直接基于纯 JDBC 的轻量级高效的 Kotlin 框架，并且是开源的。它提供了强类型和灵活的 SQL DSL 和方便的序列 API，以减少我们在数据库操作上的重复工作。当然，所有 SQL 语句都是自动生成的。</p></blockquote><p id="c4c4" class="pw-post-body-paragraph kx ky in kz b la oj jx lc ld ok ka lf lg ol li lj lk om lm ln lo on lq lr ls ig bi translated">要添加 Ktorm，我们将在 build.gradle 文件中添加以下依赖项。</p><pre class="km kn ko kp gt oo op oq or aw os bi"><span id="7c39" class="ot mj in op b gy ou ov l ow ox">// ktorm<br/>implementation 'org.ktorm:ktorm-core:3.5.0'<br/>implementation 'org.ktorm:ktorm-support-mysql:3.5.0'</span></pre><p id="e2d5" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">这就是我们需要添加为依赖项的全部内容。</p><p id="3aeb" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">现在我们需要连接到我们的数据库。使用 Ktorm 非常简单。</p><pre class="km kn ko kp gt oo op oq or aw os bi"><span id="219e" class="ot mj in op b gy ou ov l ow ox">fun database() = Database.connect(<br/>    dbUrl,<br/>    user = dbUser,<br/>    password = dbPwd<br/>)</span></pre><p id="fa16" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">是啊！就是这样。</p><p id="0eba" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">接下来，我们将在我们的<strong class="kz ix"> application.conf </strong>文件中添加一些配置，如下所示:</p><pre class="km kn ko kp gt oo op oq or aw os bi"><span id="5cd9" class="ot mj in op b gy ou ov l ow ox">db {<br/>    config {<br/>        db_url = ${?DB_URL}<br/>        db_user = ${?DB_USER}<br/>        db_pwd = ${?DB_PWD}<br/>    }<br/>}</span></pre><p id="f3ef" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">为什么会这样？因为将数据库(或任何类型的)凭证保存在代码中是不安全的。因此，我们通过配置文件访问变量，这些配置变量的值来自系统环境变量。</p></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><h2 id="adab" class="ot mj in bd mk oy oz dn mo pa pb dp ms lg pc pd mu lk pe pf mw lo pg ph my it bi translated">环境变量设置</h2><p id="d112" class="pw-post-body-paragraph kx ky in kz b la na jx lc ld nb ka lf lg nc li lj lk nd lm ln lo ne lq lr ls ig bi translated">让我们在我们的环境中添加如下价值。</p><p id="a02f" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated"><strong class="kz ix">步骤 1 </strong>:点击工具栏中的应用选项，然后进入编辑配置。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi pi"><img src="../Images/5e2c4f59deb3fc54c9a8dea5f4d560ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4eUElb9eMAtQJAIAU4aUVQ.png"/></div></div></figure><p id="c8e0" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated"><strong class="kz ix">第二步</strong>:进入虚拟机选项，复制粘贴以下内容</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="pj pk l"/></div></figure><p id="4b72" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated"><strong class="kz ix">第三步</strong>:现在创建一个对象 DBHelper.kt，如下所示</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="pj pk l"/></div></figure><p id="449d" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">请注意，环境变量可以在应用程序上下文中访问。因此，我们为应用程序上下文创建了一个扩展函数<em class="lw"> configureDbVariables </em>，现在我们可以提取环境变量值，如下所示</p><pre class="km kn ko kp gt oo op oq or aw os bi"><span id="77bc" class="ot mj in op b gy ou ov l ow ox">dbUrl = environment.config.propertyOrNull(<em class="lw">KEY_DB_URL</em>)?.getString() ?: ""</span></pre><p id="c42d" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">在应用程序的最开始，我们需要这些值，所以我们将从主模块本身调用这个函数。</p><pre class="km kn ko kp gt oo op oq or aw os bi"><span id="a851" class="ot mj in op b gy ou ov l ow ox">fun Application.module() {<br/>    <em class="lw">configureDbVariables</em>()<br/>}</span></pre><p id="87aa" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">好吧！现在，我们访问和配置数据库的设置已经完成。</p></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><h2 id="e2f6" class="ot mj in bd mk oy oz dn mo pa pb dp ms lg pc pd mu lk pe pf mw lo pg ph my it bi translated">数据库管理器</h2><p id="2341" class="pw-post-body-paragraph kx ky in kz b la na jx lc ld nb ka lf lg nc li lj lk nd lm ln lo ne lq lr ls ig bi translated">现在，我们将为我们的数据库设置一个管理器层，这样我们的数据库就不会从该层暴露出来，将来如果我们想为它提供不同的实现，我们也可以轻松地做到这一点。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="pj pk l"/></div></figure><p id="2829" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">这将是我们的知识库将访问的一个接口。我们将在本文后面看到它的实现。</p></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><h2 id="ce29" class="ot mj in bd mk oy oz dn mo pa pb dp ms lg pc pd mu lk pe pf mw lo pg ph my it bi translated">创建表</h2><p id="2b7f" class="pw-post-body-paragraph kx ky in kz b la na jx lc ld nb ka lf lg nc li lj lk nd lm ln lo ne lq lr ls ig bi translated">表是作为 Ktorm 中的对象创建的，k torm 扩展了<strong class="kz ix">表&lt;实体&gt; (table_name) </strong>。但是因为我们在这里没有使用任何实体绑定，所以我们没有传递任何东西。</p><p id="6c62" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">要创建一个列，我们只需用列名作为参数定义数据类型。例如，<strong class="kz ix"> int </strong>是 Ktorm 提供的 sql 类型，而“id”是列名。</p><pre class="km kn ko kp gt oo op oq or aw os bi"><span id="b764" class="ot mj in op b gy ou ov l ow ox">val id = <em class="lw">int</em>("id").<em class="lw">primaryKey</em>()</span></pre><p id="68fb" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">类似地，对于字符串，我们使用 varchar 等其他数据类型，您可以在<a class="ae ma" href="https://www.ktorm.org/en/schema-definition.html" rel="noopener ugc nofollow" target="_blank">这一</a>页面上找到。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="pj pk l"/></div></figure><p id="c13e" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">所以，现在我们的表被定义了。现在是数据库集成的重要部分，我们需要查询数据库中的 CRUD 操作。让我们看看如何在 Ktorm 中做到这一点。</p></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><h2 id="daa9" class="ot mj in bd mk oy oz dn mo pa pb dp ms lg pc pd mu lk pe pf mw lo pg ph my it bi translated">查询数据库</h2><p id="d83b" class="pw-post-body-paragraph kx ky in kz b la na jx lc ld nb ka lf lg nc li lj lk nd lm ln lo ne lq lr ls ig bi translated">正如我们上面讨论的，我们将在应用程序的最开始设置数据库对象。所以当我们在 api 端点访问它们时，数据库已经准备好了。</p><p id="dc3d" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">可以通过以下方式访问数据库对象</p><pre class="km kn ko kp gt oo op oq or aw os bi"><span id="aec1" class="ot mj in op b gy ou ov l ow ox">private val database = DBHelper.database()</span></pre><h2 id="3dd0" class="ot mj in bd mk oy oz dn mo pa pb dp ms lg pc pd mu lk pe pf mw lo pg ph my it bi translated">添加对象</h2><p id="c0f3" class="pw-post-body-paragraph kx ky in kz b la na jx lc ld nb ka lf lg nc li lj lk nd lm ln lo ne lq lr ls ig bi translated">我们可以调用数据库对象上的函数，如下所示</p><pre class="km kn ko kp gt oo op oq or aw os bi"><span id="d12c" class="ot mj in op b gy ou ov l ow ox">override fun addUser(user: User): User {<br/>    database.<em class="lw">insert</em>(UserTable) <strong class="op ix">{<br/>        </strong>set(<strong class="op ix">it</strong>.first_name, user.first_name)<br/>        set(<strong class="op ix">it</strong>.last_name, user.last_name)<br/>        set(<strong class="op ix">it</strong>.dob, user.dob)<br/>        set(<strong class="op ix">it</strong>.age, user.age)<br/>    <strong class="op ix">}<br/>    </strong>return user<br/>}</span></pre><p id="8ccb" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">它返回给我们一个为这个用户生成的 id。</p><h2 id="7521" class="ot mj in bd mk oy oz dn mo pa pb dp ms lg pc pd mu lk pe pf mw lo pg ph my it bi translated">删除对象</h2><pre class="km kn ko kp gt oo op oq or aw os bi"><span id="379b" class="ot mj in op b gy ou ov l ow ox">override fun delete(id: Int): Boolean {<br/>    val affectedRow = database.<em class="lw">delete</em>(UserTable) <strong class="op ix">{ it</strong>.id <em class="lw">eq </em>id <strong class="op ix">}<br/>    </strong>return affectedRow == 1<br/>}</span></pre><p id="4c05" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">它返回受操作影响的行数。</p><h2 id="1121" class="ot mj in bd mk oy oz dn mo pa pb dp ms lg pc pd mu lk pe pf mw lo pg ph my it bi translated">获取所有对象</h2><pre class="km kn ko kp gt oo op oq or aw os bi"><span id="311a" class="ot mj in op b gy ou ov l ow ox">override fun getAllUsers(): List&lt;User&gt; {<br/>    val dbUser = database.<em class="lw">from</em>(UserTable).<em class="lw">select</em>()<br/>    return dbUser.rowSet.<em class="lw">asIterable</em>().<em class="lw">map </em><strong class="op ix">{ </strong>row <strong class="op ix">-&gt;<br/>        </strong>User(<br/>            row[UserTable.id] ?: -1,<br/>            "${row[UserTable.first_name] ?: ""}",<br/>            "${row[UserTable.last_name] ?: ""}",<br/>            row[UserTable.age] ?: -1,<br/>            row[UserTable.dob] ?: "",<br/>            row[UserTable.city] ?: ""<br/>        )<br/>    <strong class="op ix">}<br/></strong>}</span></pre><p id="7b01" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">这里，我们调用 select()函数，它返回一个查询对象。这个查询对象包含所有返回的行。所以我们将它视为一个 iterable，并将每个 UserTable 对象映射到我们的域用户对象中。</p><h2 id="8c52" class="ot mj in bd mk oy oz dn mo pa pb dp ms lg pc pd mu lk pe pf mw lo pg ph my it bi translated">按 Id 获取对象</h2><pre class="km kn ko kp gt oo op oq or aw os bi"><span id="a357" class="ot mj in op b gy ou ov l ow ox">override fun getById(id: Int): User? {<br/>    val dbUser = database.<em class="lw">from</em>(UserTable).<em class="lw">select</em>().<em class="lw">where </em><strong class="op ix">{ </strong>UserTable.id <em class="lw">eq </em>id <strong class="op ix">}<br/>    </strong>val row = dbUser.rowSet.<em class="lw">asIterable</em>().<em class="lw">firstOrNull</em>()<br/>    return row?.<em class="lw">let </em><strong class="op ix">{<br/>        </strong>User(<br/>            <strong class="op ix">it</strong>[UserTable.id] ?: -1,<br/>            "${<strong class="op ix">it</strong>[UserTable.first_name] ?: ""}",<br/>            "${<strong class="op ix">it</strong>[UserTable.last_name] ?: ""}",<br/>            <strong class="op ix">it</strong>[UserTable.age] ?: -1,<br/>            <strong class="op ix">it</strong>[UserTable.dob] ?: "",<br/>            <strong class="op ix">it</strong>[UserTable.city] ?: ""<br/>        )<br/>    <strong class="op ix">}</strong>?: null<br/>}</span></pre><p id="65ac" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">这个查询类似于 Get All Users，但是这里我们添加了一个 where 子句，并检查 iterable 的第一项。</p></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><p id="3a34" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">还有 Bamn！我们已经使用 Ktorm 成功地将数据库与 Rest APIs 集成在一起。现在，我们可以使用不同的查询来查看所有的操作。我将在以后文章中写更多的高级部分。但是现在这是一个很好的开始。</p><div class="pl pm gp gr pn po"><a href="https://github.com/aqua30/Apis-using-Ktor/tree/database-set-up" rel="noopener  ugc nofollow" target="_blank"><div class="pp ab fo"><div class="pq ab pr cl cj ps"><h2 class="bd ix gy z fp pt fr fs pu fu fw iw bi translated">GitHub-aqua 30/Apis-在数据库设置时使用-Ktor</h2><div class="pv l"><h3 class="bd b gy z fp pt fr fs pu fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="pw l"><p class="bd b dl z fp pt fr fs pu fu fw dk translated">github.com</p></div></div><div class="px l"><div class="py l pz qa qb px qc kr po"/></div></div></a></div></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><h1 id="7a0e" class="mi mj in bd mk ml mm mn mo mp mq mr ms kc mt kd mu kf mv kg mw ki mx kj my mz bi translated">目前就这些了！敬请期待！</h1><p id="09d1" class="pw-post-body-paragraph kx ky in kz b la na jx lc ld nb ka lf lg nc li lj lk nd lm ln lo ne lq lr ls ig bi translated">通过 medium(如果内容对您有帮助)或<a class="ae ma" href="https://github.com/aqua30" rel="noopener ugc nofollow" target="_blank"> GitHub </a>与我联系，并订阅电子邮件以同步了解更多关于 Android/IOS/Backend/Web 的有趣话题。</p><p id="29ca" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">直到下一次…</p><p id="3ccf" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">干杯！</p></div></div>    
</body>
</html>