<html>
<head>
<title>3 Different Ways to Implement Value Object in C# 10</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C# 10 中实现值对象的 3 种不同方法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/3-different-ways-to-implement-value-object-in-csharp-10-d8f43e1fa4dc?source=collection_archive---------0-----------------------#2022-01-07">https://blog.devgenius.io/3-different-ways-to-implement-value-object-in-csharp-10-d8f43e1fa4dc?source=collection_archive---------0-----------------------#2022-01-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="f3fc" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">领域驱动设计</h2><div class=""/><div class=""><h2 id="642e" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">让我们来看看如何用 EF Core 6.0 实现值对象，并将它们映射到一个数据库表。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/2d8dabf7aec7f7e91bbdae02461b3b47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*165G7NewRnAYk_x-OHc7Nw.jpeg"/></div></div></figure><h1 id="e4a1" class="la lb iq bd lc ld le lf lg lh li lj lk kf ll kg lm ki ln kj lo kl lp km lq lr bi translated">什么是价值对象</h1><p id="43e7" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">值对象是没有显式标识符的对象。它的第一个主要特点是<strong class="lu ja">不需要身份</strong>。</p><p id="fbaf" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">第二个主要特征是值对象必须是不可变的。这意味着一旦值对象属性被初始化，我们就不能改变它们的值。您只能通过在其属性中引入具有不同值的新值对象来更改它们。</p><p id="6a75" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">一个很好的例子是<strong class="lu ja">地址</strong>。它由城市、街道和邮政编码组成。一旦你改变了其中的一个，你就改变了整个地址。它是完整的。</p><p id="1ce0" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">值对象的第三个主要特征也是<strong class="lu ja">值</strong> <strong class="lu ja">相等</strong>。一旦值对象的类型和属性值相等，它们就相等。值对象的每个实现都必须支持这样的行为。</p><p id="7144" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">值对象是<strong class="lu ja">领域驱动设计</strong>模式之一，作为领域建模的实体和集合。我已经在下面的另一篇文章中写了一些关于 DDD 的内容。</p><p id="9fb3" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">如果你刚到 DDD，你仍然可以从这篇文章中获得令人兴奋的知识。但是我也建议看看朱莉·勒曼和史蒂夫·史密斯的 Pluralsight 课程<a class="ae mx" href="https://www.pluralsight.com/courses/fundamentals-domain-driven-design" rel="noopener ugc nofollow" target="_blank">领域驱动设计基础</a>。</p><div class="my mz gp gr na nb"><a href="https://levelup.gitconnected.com/3-domain-centric-architectures-every-software-developer-should-know-a15727ada79f" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd ja gy z fp ng fr fs nh fu fw iz bi translated">每个软件开发人员都应该知道的 3 个以领域为中心的架构</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">建筑师首先关心的是确保房子是可用的，而不是确保房子是…</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nk l"><div class="nl l nm nn no nk np ky nb"/></div></div></a></div></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><h1 id="222e" class="la lb iq bd lc ld nx lf lg lh ny lj lk kf nz kg lm ki oa kj lo kl ob km lq lr bi translated">不同的实施方式</h1><h2 id="1aba" class="oc lb iq bd lc od oe dn lg of og dp lk mb oh oi lm mf oj ok lo mj ol om lq iw bi translated">值对象父级</h2><p id="8d69" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">C#中值对象的第一个典型实现之一是<code class="fe mt mu mv mw b">ValueObject</code>抽象类。从它继承的每个类都被认为是一个值对象。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="a182" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">您可以看到一个被覆盖的<code class="fe mt mu mv mw b">GetHashCode</code>方法。此方法用于返回对象实例的哈希代码。哈希代码用于标识基于哈希的集合中的对象。该方法为需要快速检查对象相等性的算法提供哈希代码。</p><p id="fd09" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">如果我们想将对象作为值对象进行比较，我们必须根据其属性的散列码来计算散列码。属性的值由<code class="fe mt mu mv mw b">GetEqualityComponents</code>抽象方法提供。</p><p id="822f" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated"><code class="fe mt mu mv mw b">ValueObject</code>父节点的每个子节点都必须实现<code class="fe mt mu mv mw b">GetEqualityComponents</code>方法。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="on oo l"/></div><figcaption class="op oq gj gh gi or os bd b be z dk translated">地址类别</figcaption></figure><p id="4af4" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">注意，我在每个属性上使用了<code class="fe mt mu mv mw b">init</code>关键字，而不是特定的<code class="fe mt mu mv mw b">set</code>关键字。这样，您将属性定义为<a class="ae mx" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-9.0/init" rel="noopener ugc nofollow" target="_blank"> Init Only </a>，并且您可以确定它的不变性。</p><h2 id="5686" class="oc lb iq bd lc od oe dn lg of og dp lk mb oh oi lm mf oj ok lo mj ol om lq iw bi translated">记录</h2><p id="d82b" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">从 C# 9 开始，记录就一直伴随着我们。您可以使用<code class="fe mt mu mv mw b">record</code>关键字来定义一个引用类型，为封装数据提供<strong class="lu ja">内置功能。内置功能是由编译器自己在编译时添加的。</strong></p><p id="acca" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">对于<code class="fe mt mu mv mw b">record</code>关键字，我们可以使用<strong class="lu ja">位置语法</strong>。这是定义自动不可变类的一种更简单的方法:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="428c" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">因此，通过使用位置语法，我们满足了一个主要特征— <strong class="lu ja">不变性</strong>。</p><p id="5bfc" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">另一个特点是<strong class="lu ja">值相等</strong>。微软文档是这样描述记录类的:</p><blockquote class="ot ou ov"><p id="abcb" class="ls lt ow lu b lv mo ka lx ly mp kd ma ox mq md me oy mr mh mi oz ms ml mm mn ij bi translated">对于记录类型，包括记录结构和只读记录结构，如果两个对象属于同一类型并存储相同的值，则它们是相等的。</p></blockquote><p id="62c8" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated"><strong class="lu ja">值相等</strong>行为是安全的，这要感谢编译时内置的对<code class="fe mt mu mv mw b">Equals</code>方法的覆盖。</p><p id="65d2" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">最后一个特征是<strong class="lu ja">标识符</strong>的效力。既然我们不会引入任何独特的属性，我们应该是好的。</p><p id="f449" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">我们可以说 record 类是定义值对象的一种快速而直接的方式。</p><h2 id="4f3d" class="oc lb iq bd lc od oe dn lg of og dp lk mb oh oi lm mf oj ok lo mj ol om lq iw bi translated">结构</h2><p id="9044" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">结构是值类型。意味着结构类型变量<strong class="lu ja">直接包含一个实例</strong>，而不是引用。变量值在赋值时被复制，将一个参数传递给一个方法，并返回一个方法结果。</p><p id="8c97" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">另一方面，引用类型变量包含一个对实例的<strong class="lu ja">引用。Assign 语句不复制实例，而只传递其引用。此外，将引用类型变量传递给方法意味着对方法的修改是在同一个实例上进行的，而不是在它的副本上。</strong></p><p id="7950" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">该结构也可以用关键字<code class="fe mt mu mv mw b">record</code>和<strong class="lu ja">位置语法</strong>来定义。</p><p id="1b55" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated"><code class="fe mt mu mv mw b">public record struct Address(string Street, string ZipCode, string City);</code></p><p id="67a9" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">因此，我们再次满足所有三个主要特征— <strong class="lu ja">不变性，标识符的效力，</strong>和<strong class="lu ja">值相等</strong>。所以 struct 是实现值对象的另一种可靠方式。</p><h2 id="3b96" class="oc lb iq bd lc od oe dn lg of og dp lk mb oh oi lm mf oj ok lo mj ol om lq iw bi translated">摘要</h2><p id="b865" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">Value object parent 是最复杂的实现，我建议更高级的 DDD 开发人员使用它。Vladimir Khorikov 做了一篇关于价值对象父优于记录的伟大文章<a class="ae mx" href="https://enterprisecraftsmanship.com/posts/csharp-records-value-objects/" rel="noopener ugc nofollow" target="_blank">在这里</a>。</p><p id="4f13" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">我在较低的层次上使用值对象，我更“亲记录”，所以我将在我的最后一句话中关注它们。</p><p id="4964" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated"><strong class="lu ja">什么时候我们应该用</strong> <code class="fe mt mu mv mw b"><strong class="lu ja">record class</strong></code> <strong class="lu ja">而不是</strong> <code class="fe mt mu mv mw b"><strong class="lu ja">record struct</strong></code> <strong class="lu ja">反之亦然？</strong>两者都满足值对象实现的主要要求。</p><p id="7dc5" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">结构在堆栈上分配。结构应该很小。<strong class="lu ja">如果数据太大，那么在方法之间传递数据的成本会很高，因为我们每次传递都会创建一个值类型的新实例</strong>。当保存的数据量有限时使用它们。</p><p id="11cd" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">在堆上分配一个类。它是一个引用类型，<strong class="lu ja">所以通过方法传递对象的开销并不大</strong>。如果要定义更重要的值对象，应该使用类。</p><p id="59d9" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">更多的是关于<strong class="lu ja">何时使用引用类型和值类型</strong>。微软文档中有一篇文章专门解答这个问题<a class="ae mx" href="https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/choosing-between-class-and-struct?redirectedfrom=MSDN" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="d46f" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">值对象是预定义为保存在实体中并持久保存在数据库中的不可变变量。<strong class="lu ja">在方法间传递的次数总是更多，这意味着</strong>记录类(引用类型)比记录结构(值类型)更适合值对象的实现。</p></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><h1 id="b97d" class="la lb iq bd lc ld nx lf lg lh ny lj lk kf nz kg lm ki oa kj lo kl ob km lq lr bi translated">价值目标和 EF 核心</h1><h2 id="7f5f" class="oc lb iq bd lc od oe dn lg of og dp lk mb oh oi lm mf oj ok lo mj ol om lq iw bi translated">拥有的类型</h2><p id="074e" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">用于映射值对象的<strong class="lu ja">实体框架核心</strong>的便利特性是拥有类型。微软文档中的定义是:</p><p id="0e81" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">EF Core 允许你对只能出现在其他实体类型的导航属性中的实体类型进行建模。这些被称为拥有的实体类型。包含拥有的实体类型的实体是其所有者。</p><p id="d17a" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">所以，从 EF 核心的观点来看，价值对象不能没有它的拥有者而存在。大多数情况下，所有者是某个<strong class="lu ja">实体</strong>。想象一个类<code class="fe mt mu mv mw b">Person</code>作为一个实体(所有者)，类型<code class="fe mt mu mv mw b">Address</code>的属性作为它的值类型(拥有类型)。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="on oo l"/></div><figcaption class="op oq gj gh gi or os bd b be z dk translated">Person.cs</figcaption></figure><p id="9f80" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">为了将实体<code class="fe mt mu mv mw b">Person</code>映射到数据库表，我将使用 fluent model builder 并直接在<code class="fe mt mu mv mw b">DbContext</code>类中覆盖方法<code class="fe mt mu mv mw b">OnModelCreating</code>。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="on oo l"/></div><figcaption class="op oq gj gh gi or os bd b be z dk translated">AppDbContext.cs</figcaption></figure><p id="af0f" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">如你所见，我对 EF Core 说,<code class="fe mt mu mv mw b">Person</code>拥有一个地址，然后在它的子构建器中定义了<code class="fe mt mu mv mw b">address</code>属性。生成的数据库表如下所示。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/f741e4f29ac3fe692aef3a48bfde4bdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*l_iUxMvXuV44jPSV9LdnEw.png"/></div></figure><p id="9df2" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">地址属性的值存储在 Persons 表的列中，其名称带有特定的指令——“ValueObjectName _ property name”</p><p id="de85" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">但是如果我有一个<strong class="lu ja">地址集合</strong>呢？如果你在一个实体中有一个值对象的集合，你应该使用方法<code class="fe mt mu mv mw b">OwnsMany</code>，EF Core 将把它们映射到带有外键<code class="fe mt mu mv mw b">PersonId</code>的表中。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="on oo l"/></div><figcaption class="op oq gj gh gi or os bd b be z dk translated">OwnsMany</figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/f75e4b9a34eb7da834eb3c7f2ba70aa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*jp2C7Ppvpy5uUVXbjt-1Jg.png"/></div><figcaption class="op oq gj gh gi or os bd b be z dk translated">地址表的列</figcaption></figure><p id="fb8d" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">但是如果你选择<code class="fe mt mu mv mw b">struct</code>作为你的值对象，你<strong class="lu ja">还不能为它使用拥有的类型</strong>。您必须将值对象序列化为 JSON，并将其存储在 varchar 列中。<a class="ae mx" href="https://docs.microsoft.com/en-us/ef/core/what-is-new/ef-core-7.0/plan#value-objects" rel="noopener ugc nofollow" target="_blank">但随着 EF Core 7.0 的推出，可能会有所改变。</a></p><p id="3f8c" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">引入从 address 到 JSON 的转换非常简单，但是您不会更方便地读取数据库，就像 address 属性的值都存储在其列中一样。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="on oo l"/></div><figcaption class="op oq gj gh gi or os bd b be z dk translated">价值对象文章</figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pc"><img src="../Images/aa23bb0f128a91bedfc4c1687ce3e54c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tWP0C9jBNKYM13GY8YUqNg.png"/></div></div><figcaption class="op oq gj gh gi or os bd b be z dk translated">数据库中的结构地址</figcaption></figure><p id="b1d5" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">从 EF Core 6.0 开始，我们可以使用特性<strong class="lu ja">预约定模型配置</strong>，并通过为值对象类型引入<code class="fe mt mu mv mw b">ValueConverter</code>并在<code class="fe mt mu mv mw b">DbContext</code>类的<code class="fe mt mu mv mw b">ConfigureConventions</code>方法中配置它来全局定义从类型<code class="fe mt mu mv mw b">Address</code>到 JSON 的转换。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="on oo l"/></div><figcaption class="op oq gj gh gi or os bd b be z dk translated">地址转换器</figcaption></figure><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="on oo l"/></div></figure></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><h1 id="8c10" class="la lb iq bd lc ld nx lf lg lh ny lj lk kf nz kg lm ki oa kj lo kl ob km lq lr bi translated">来源</h1><ul class=""><li id="7fd8" class="pd pe iq lu b lv lw ly lz mb pf mf pg mj ph mn pi pj pk pl bi translated"><a class="ae mx" href="https://enterprisecraftsmanship.com/posts/csharp-records-value-objects/" rel="noopener ugc nofollow" target="_blank"> C# 9 记录作为 DDD 价值对象的弗拉基米尔·霍里科夫。</a></li><li id="2b1f" class="pd pe iq lu b lv pm ly pn mb po mf pp mj pq mn pi pj pk pl bi translated"><a class="ae mx" href="https://docs.microsoft.com/en-us/ef/core/what-is-new/ef-core-6.0/whatsnew#pre-convention-model-configuration" rel="noopener ugc nofollow" target="_blank">EF Core 6.0 中的新特性。</a></li><li id="95e7" class="pd pe iq lu b lv pm ly pn mb po mf pp mj pq mn pi pj pk pl bi translated"><a class="ae mx" href="https://docs.microsoft.com/en-us/ef/core/modeling/value-conversions?tabs=data-annotations#examples" rel="noopener ugc nofollow" target="_blank">微软文档中的数值转换。</a></li><li id="0ef5" class="pd pe iq lu b lv pm ly pn mb po mf pp mj pq mn pi pj pk pl bi translated">在微软文档中选择类和结构。</li><li id="26f9" class="pd pe iq lu b lv pm ly pn mb po mf pp mj pq mn pi pj pk pl bi translated"><a class="ae mx" href="http://Choosing between immutable objects and structs for value objects" rel="noopener ugc nofollow" target="_blank">在 StackOverflow 上为值对象选择不可变对象和结构。</a></li><li id="c33b" class="pd pe iq lu b lv pm ly pn mb po mf pp mj pq mn pi pj pk pl bi translated"><a class="ae mx" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/struct#readonly-struct" rel="noopener ugc nofollow" target="_blank">微软文档中的结构类型。</a></li><li id="fe80" class="pd pe iq lu b lv pm ly pn mb po mf pp mj pq mn pi pj pk pl bi translated"><a class="ae mx" href="https://www.pluralsight.com/courses/fundamentals-domain-driven-design" rel="noopener ugc nofollow" target="_blank"> Pluralsight 课程领域驱动设计基础。</a></li></ul></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><h1 id="b112" class="la lb iq bd lc ld nx lf lg lh ny lj lk kf nz kg lm ki oa kj lo kl ob km lq lr bi translated">遗言</h1><p id="29d4" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">感谢你的关注。我在这里为我的每篇博文列出了非限制性链接。我是 Itixo 公司的一员。NET 中欧会议，<a class="ae mx" href="https://www.updateconference.net/en" rel="noopener ugc nofollow" target="_blank">布拉格更新会议</a>。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pr"><img src="../Images/051cbf06ec01ddcb9375b4e2332cacf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_4KbsTC9-iH6WotZ.png"/></div></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ps"><img src="../Images/4d995343e438a73d8804024a7ca560b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*xApsIwR_xId_WZtr.png"/></div><figcaption class="op oq gj gh gi or os bd b be z dk translated">赞助商</figcaption></figure><h1 id="d449" class="la lb iq bd lc ld le lf lg lh li lj lk kf ll kg lm ki ln kj lo kl lp km lq lr bi translated">进一步阅读</h1><div class="my mz gp gr na nb"><a href="https://levelup.gitconnected.com/layers-in-software-architecture-that-every-sofware-architect-should-know-76b2452b9d9a" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd ja gy z fp ng fr fs nh fu fw iz bi translated">每个软件架构师都应该知道的软件体系结构的层次</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">“所有的架构都有相同的目标——关注点的分离。都是通过分软件来实现的…</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nk l"><div class="pt l nm nn no nk np ky nb"/></div></div></a></div><div class="my mz gp gr na nb"><a href="https://levelup.gitconnected.com/3-cqrs-architectures-that-every-software-architect-should-know-a7f69aae8b6c" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd ja gy z fp ng fr fs nh fu fw iz bi translated">每个软件架构师都应该知道的 3 个 CQRS 架构</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">关注点分离是一种有效整理一个人思想的技术。你应该集中注意力…</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nk l"><div class="pu l nm nn no nk np ky nb"/></div></div></a></div><div class="my mz gp gr na nb"><a href="https://levelup.gitconnected.com/how-i-upgrade-my-code-style-of-mediatr-pipeline-using-net-6-ed49aca61f47" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd ja gy z fp ng fr fs nh fu fw iz bi translated">我如何使用？网络 6</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">我想和你分享一下。NET 6 的新特性。扩展。AttributedBehaviors NuGet 包帮助…</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nk l"><div class="pv l nm nn no nk np ky nb"/></div></div></a></div></div></div>    
</body>
</html>