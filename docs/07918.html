<html>
<head>
<title>Learning go — Boost your journey (part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习 go —加速您的旅程(第 2 部分)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/learning-go-in-2022-boost-your-journey-part-2-2c23c401c7b5?source=collection_archive---------7-----------------------#2022-05-03">https://blog.devgenius.io/learning-go-in-2022-boost-your-journey-part-2-2c23c401c7b5?source=collection_archive---------7-----------------------#2022-05-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/4e144f7750ca9110a55441017537e37c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1XlW6esECPCnxEcuEvwIrQ.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">致谢:<a class="ae ja" href="https://github.com/MariaLetta/free-gophers-pack" rel="noopener ugc nofollow" target="_blank">https://github.com/MariaLetta/free-gophers-pack</a></figcaption></figure><div class=""/><p id="32d5" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">本文是学习围棋的第二部分——提升你的旅程。如果你错过了第一部分，点击查看<a class="ae ja" rel="noopener ugc nofollow" target="_blank" href="/learning-go-in-2022-boost-your-journey-6edc606ed030">。</a></p><p id="bbdc" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本文中，我将重点介绍一些<strong class="kc je">“高级”Go 功能</strong>，它们可以提升您的编程体验，并帮助您开始构建考虑到<strong class="kc je">并发性</strong>的 Go 应用程序:</p><ul class=""><li id="b9eb" class="ky kz jd kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">戈鲁廷斯</li><li id="5a6a" class="ky kz jd kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">频道</li><li id="a28b" class="ky kz jd kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">Goroutine 同步</li><li id="e62d" class="ky kz jd kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">选择—多通道操作</li><li id="e7e1" class="ky kz jd kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">原子计数器和互斥</li></ul><p id="4606" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以，我们开始吧:)</p><h1 id="ce77" class="lm ln jd bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">戈鲁廷斯</h1><p id="b561" class="pw-post-body-paragraph ka kb jd kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">正如我们在<a class="ae ja" href="https://gobyexample.com/goroutines" rel="noopener ugc nofollow" target="_blank"> go by example </a>中看到的，Goroutine 是一个轻量级的执行线程<strong class="kc je">。Goroutines 就像线程，但是更便宜，并且可以与其他函数和方法并发运行。</strong></p><p id="ecbd" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">给定一个函数<code class="fe mp mq mr ms b">printSomething</code>，为了在 Goroutine 中运行它，您可以简单地编写:<code class="fe mp mq mr ms b">go printSomething()</code>。Go 还支持将 Goroutines 作为<strong class="kc je">匿名函数</strong>运行，语法:<code class="fe mp mq mr ms b">go func() { ... do something ...}()</code></p><p id="d5d4" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们启动 Go 程序时，默认情况下会运行一个主 Go 例程。这个特殊的 Go 例程控制程序何时退出，为此，如果你创建了一个或多个子 Go 例程，你需要一种方法在退出程序之前等待它们完成。</p><p id="d643" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了做到这一点，Go 提供了一个很好的机制来使它们通信和同步:<strong class="kc je">通道</strong>。</p><h1 id="6ebf" class="lm ln jd bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">频道</h1><p id="0a76" class="pw-post-body-paragraph ka kb jd kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">我们可以将通道视为一个<strong class="kc je">管道</strong>，它帮助我们<strong class="kc je">连接</strong>和<strong class="kc je">同步</strong> <strong class="kc je">并发的 Goroutines。</strong>让我们来看看通道的一些基本语法，以加速我们的开发:</p><ul class=""><li id="6d7b" class="ky kz jd kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated"><strong class="kc je">创建</strong>一个通道:<code class="fe mp mq mr ms b">make(chan val-type)</code> <em class="mt">(例如</em> <code class="fe mp mq mr ms b"><em class="mt">make(chan string)</em></code> <em class="mt"> ) </em></li><li id="2c6c" class="ky kz jd kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">通过一个通道发送一个值(<strong class="kc je">写</strong>)<strong class="kc je"/>:<code class="fe mp mq mr ms b">channel &lt;- myValue</code></li><li id="3ac9" class="ky kz jd kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">从通道<code class="fe mp mq mr ms b">myVar := &lt;- channel</code>接收值(<strong class="kc je">读取</strong>)</li><li id="d82a" class="ky kz jd kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated"><strong class="kc je">关闭</strong> a 通道:<code class="fe mp mq mr ms b">close(channel)</code>。关闭一个通道意味着<strong class="kc je">上不再有值被发送</strong>，这对于通知接收者不再有消息通过关闭的通道发送是有用的。<br/>总是可以关闭一个非空通道，但仍然可以接收剩余的值</li><li id="5f2a" class="ky kz jd kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">将通道传递给函数时，您可以使用语法将它们标记为<strong class="kc je">readonly</strong>/<strong class="kc je">write only</strong>通道:<br/>–readonly→<code class="fe mp mq mr ms b">func f(myReadOnlyChannel &lt;-chan string)</code><br/>–write only→<code class="fe mp mq mr ms b">func f(myWriteOnlyChannel chan&lt;- string)</code></li></ul><p id="fc5d" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">知道<strong class="kc je">默认:</strong>真的很重要</p><ol class=""><li id="50ae" class="ky kz jd kc b kd ke kh ki kl la kp lb kt lc kx mu le lf lg bi translated"><strong class="kc je">发送</strong>和<strong class="kc je">接收</strong>都被<strong class="kc je">阻塞</strong>。这意味着每次:<br/>–你通过通道发送一个值，线程阻塞等待消息被接收<br/>–你从通道接收一个值，线程阻塞等待消息出现在通道中</li><li id="dab7" class="ky kz jd kc b kd lh kh li kl lj kp lk kt ll kx mu le lf lg bi translated">通道<strong class="kc je">无缓冲</strong>意味着它们的<strong class="kc je">缓冲容量为零。</strong> <br/>带缓冲容量我指的是<strong class="kc je">阻塞</strong>之前你的进程可以发送/接收<strong class="kc je">的消息量</strong></li></ol><p id="2935" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你不知道自己在做什么，无缓冲通道加上发送和接收阻塞语法使你的 Go 程序成为死锁的好选择。</p><p id="f7aa" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看一个例子更清楚:</p><figure class="mv mw mx my gt ip"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">死锁示例</figcaption></figure><p id="7f1c" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以用两种方法来克服上面的僵局:</p><p id="2afd" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">(1)使用一个<strong class="kc je">缓冲通道→ </strong>在这种解决方案中，我们在某种程度上破解了默认的 Go 通道语义，使其在达到缓冲限制之前不会阻塞</p><figure class="mv mw mx my gt ip"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">死锁解决方案 1</figcaption></figure><p id="f8e7" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">(2)在这个解决方案中使用一个<strong class="kc je"> Goroutine → </strong>,我们保持 Go 阻塞语义不变，并引入一个并发执行线程来避免死锁</p><figure class="mv mw mx my gt ip"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">死锁解决方案 2</figcaption></figure><h1 id="59b0" class="lm ln jd bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">Goroutines 同步</h1><p id="e373" class="pw-post-body-paragraph ka kb jd kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">通道对于<strong class="kc je">跨多个<strong class="kc je">go routine 同步</strong>执行非常有用。</strong>在 Go 中，根据使用情况，可以通过不同的方式实现同步。</p><p id="f809" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">(1)当<strong class="kc je">用<strong class="kc je">单条线</strong>处理</strong>时，一条粗线通道就能完成</p><figure class="mv mw mx my gt ip"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">单路同步</figcaption></figure><p id="f39a" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">(2)对于涉及<strong class="kc je">多个 Goroutines </strong>的更复杂的场景，我们可以利用包<code class="fe mp mq mr ms b">sync</code>提供的内置 Go <code class="fe mp mq mr ms b">WaitGroup</code></p><figure class="mv mw mx my gt ip"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="5fff" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc je">注意:</strong>如果一个 WaitGroup 被显式地传递到函数中，它应该通过指针来完成</p><h1 id="f8ce" class="lm ln jd bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">选择—多通道操作</h1><p id="bba9" class="pw-post-body-paragraph ka kb jd kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">当处理多个通道时，Go 提供了一个真正强大的编程构造，帮助我们使代码更加简洁:<strong class="kc je"> Select。</strong></p><p id="7c84" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">选择允许您<strong class="kc je">等待多通道操作</strong>。你可以把 Select 想象成一个<code class="fe mp mq mr ms b">switch...case</code>，在这里，你不是打开一个条件，而是<strong class="kc je">选择</strong>代码来执行<strong class="kc je">，这取决于</strong>哪个<strong class="kc je">通道</strong>通过接收/发送一个消息<strong class="kc je">解除阻塞</strong>。事实上，如上所述，Go 通道是无缓冲的，默认情况下具有阻塞语义。</p><p id="fb63" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">与在<code class="fe mp mq mr ms b">switch...case</code>中一样，在不满足任何条件的情况下执行<code class="fe mp mq mr ms b">default</code>情况，这在<code class="fe mp mq mr ms b">select</code>语句中解释为:没有通道接收到消息或者没有通道能够发送消息。正如您可能注意到的，有一个<code class="fe mp mq mr ms b">default</code>案例将<code class="fe mp mq mr ms b">select</code>语义从阻塞转换为不阻塞。</p><p id="0544" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在下面的例子中，我简单地说:</p><ol class=""><li id="ab4c" class="ky kz jd kc b kd ke kh ki kl la kp lb kt lc kx mu le lf lg bi translated">创建 2 个频道</li><li id="8796" class="ky kz jd kc b kd lh kh li kl lj kp lk kt ll kx mu le lf lg bi translated">启动一个 Goroutine，在一个无限循环中，使用<code class="fe mp mq mr ms b">select</code>打印一条消息</li><li id="46b9" class="ky kz jd kc b kd lh kh li kl lj kp lk kt ll kx mu le lf lg bi translated">Goroutine 和 main 进程使用简单的 bool 通道进行同步</li></ol><p id="ef48" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看一个简单的例子:</p><figure class="mv mw mx my gt ip"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">选择示例</figcaption></figure><h1 id="e441" class="lm ln jd bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">原子计数器和互斥</h1><p id="50c1" class="pw-post-body-paragraph ka kb jd kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">Go 中管理状态的主要机制是通过通道进行通信，但是还有其他一些选项值得一提。</p><ol class=""><li id="e849" class="ky kz jd kc b kd ke kh ki kl la kp lb kt lc kx mu le lf lg bi translated"><strong class="kc je">原子包→ </strong>正如<a class="ae ja" href="https://pkg.go.dev/sync/atomic" rel="noopener ugc nofollow" target="_blank">官方文档</a>中提到的，原子包中包含的所有功能都需要<strong class="kc je">非常小心才能正确使用</strong>。出于这个原因，除了特殊的、低级别的应用，他们建议与频道或同步包的设施进行同步。无论如何，原子包的一个用例可能是构建一个简单的<strong class="kc je">原子计数器。</strong>例如，为了给一个 Goroutine 共享变量<code class="fe mp mq mr ms b">myCounter</code>自动加 1，你可以简单地导入<code class="fe mp mq mr ms b">sync/atomic</code>包并像<br/> <code class="fe mp mq mr ms b">atomic.AddUint64(&amp;myCounter, 1)</code>一样使用它</li><li id="a77f" class="ky kz jd kc b kd lh kh li kl lj kp lk kt ll kx mu le lf lg bi translated"><strong class="kc je">互斥体→ </strong>互斥体可以用来处理更复杂的状态。正如<a class="ae ja" href="https://pkg.go.dev/sync#Mutex" rel="noopener ugc nofollow" target="_blank">官方文档</a>中所述，互斥体的零值是一个解锁的互斥体。对互斥体可以做的主要操作有:<br/>–<strong class="kc je">声明</strong> → <code class="fe mp mq mr ms b">var myMutex sync.Mutex</code>。<strong class="kc je"><br/></strong>–<strong class="kc je">锁定</strong> → <code class="fe mp mq mr ms b">myMutex.Lock()</code>(阻塞直到互斥可用)<br/>–<strong class="kc je">解锁</strong> → <code class="fe mp mq mr ms b">myMutex.Unlock()</code>(如果互斥未锁定则抛出)</li></ol><h1 id="da4a" class="lm ln jd bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">结论</h1><p id="c2fd" class="pw-post-body-paragraph ka kb jd kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">这只是对 Goroutines 和 Channels 的介绍，但我认为掌握这些概念可以帮助你为下一个 Go 项目打下坚实的基础。</p><p id="0235" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你喜欢这篇文章，并且想让我知道，请给我一些掌声👏如果您不想错过我的下一篇文章，请关注我；)</p><p id="a6af" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下一次，我将介绍一些更高级的同步技术，包括有状态的 Goroutines、定时器和 Tickers。</p><p id="4908" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下次探索再见:)</p></div></div>    
</body>
</html>