<html>
<head>
<title>3 Tips to Become Better At Unit Testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高单元测试水平的 3 个技巧</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/3-tips-to-become-better-at-unit-testing-a2833cc4827b?source=collection_archive---------4-----------------------#2021-01-26">https://blog.devgenius.io/3-tips-to-become-better-at-unit-testing-a2833cc4827b?source=collection_archive---------4-----------------------#2021-01-26</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="8d7c" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">如何提高你的单元测试技能</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/b739f8e84c0e5d93271dcbeb97c9b880.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RfLvKiFK0BaLqdoD"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated"><a class="ae kw" href="https://unsplash.com/@nci?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">国家癌症研究所</a>在<a class="ae kw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="8904" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">测试对于任何软件都是至关重要的。尤其是单元测试和集成测试。</p><p id="30f7" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">你写了一个算法，做了一些手工测试，它工作了。你错了。个别组件可能会断裂，或者出现边缘情况。</p><p id="ab8f" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">你是一个好的开发者，你不会让失败发生。创建单元测试和集成测试降低了失败的风险。</p><p id="3fc9" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">记住这一点，让我们继续学习 3 个技巧来改进你的单元测试。</p><p id="1312" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这篇文章的灵感来自于阅读<em class="lt">“单元测试的艺术”。</em></p><div class="lu lv gq gs lw lx"><a href="https://www.artofunittesting.com/" rel="noopener  ugc nofollow" target="_blank"><div class="ly ab fp"><div class="lz ab ma cl cj mb"><h2 class="bd is gz z fq mc fs ft md fv fx iq bi translated">单元测试的艺术</h2><div class="me l"><h3 class="bd b gz z fq mc fs ft md fv fx dk translated">这个扩展版以函数式、模块化和面向对象的风格教授模拟、存根和依赖注入…</h3></div><div class="mf l"><p class="bd b dl z fq mc fs ft md fv fx dk translated">www.artofunittesting.com</p></div></div><div class="mg l"><div class="mh l mi mj mk mg ml kq lx"/></div></div></a></div></div><div class="ab cl mm mn hv mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ik il im in io"><h1 id="4957" class="mt mu ir bd mv mw mx my mz na nb nc nd jx ne jy nf ka ng kb nh kd ni ke nj nk bi translated">你创建可维护的测试吗？</h1><p id="0938" class="pw-post-body-paragraph kx ky ir kz b la nl js lc ld nm jv lf lg nn li lj lk no lm ln lo np lq lr ls ik bi translated">没有人会改变难以维护的测试。没人。您需要通过编写干净、易于使用的测试来铺平道路。</p><p id="368c" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">你应该总是测试类的契约。内部的私有方法需要改变。公共方法应该向类显示接口，并且不应该改变行为。</p><p id="be73" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">测试私有方法容易出错。这就是为什么你应该避免这些测试。</p><blockquote class="nq"><p id="65cf" class="nr ns ir bd nt nu nv nw nx ny nz ls dk translated">"测试私有方法的功能可能会导致测试中断，即使整体功能是正确的."</p><p id="8791" class="nr ns ir bd nt nu nv nw nx ny nz ls dk translated">—罗伊·奥舍洛夫</p></blockquote><p id="65e5" class="pw-post-body-paragraph kx ky ir kz b la oa js lc ld ob jv lf lg oc li lj lk od lm ln lo oe lq lr ls ik bi translated">将所有方法都公开并不是正确的做法。拥有大量公共方法违反了单一责任原则。</p><blockquote class="nq"><p id="30f0" class="nr ns ir bd nt nu nv nw nx ny nz ls dk translated">不应该强迫客户端依赖他们不使用的接口</p><p id="f1e0" class="nr ns ir bd nt nu nv nw nx ny nz ls dk translated">罗伯特·马丁</p></blockquote><p id="fb13" class="pw-post-body-paragraph kx ky ir kz b la oa js lc ld ob jv lf lg oc li lj lk od lm ln lo oe lq lr ls ik bi translated">记住这一点，隔离你的界面。遵循<a class="ae kw" href="https://stackify.com/interface-segregation-principle/" rel="noopener ugc nofollow" target="_blank">这篇关于接口分离的好文章</a>。</p><p id="84aa" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">要点是避免用不属于你的方法填充你的接口。分离导致更好的单元测试，因为你有小块的代码要测试。</p></div><div class="ab cl mm mn hv mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ik il im in io"><h1 id="524c" class="mt mu ir bd mv mw mx my mz na nb nc nd jx ne jy nf ka ng kb nh kd ni ke nj nk bi translated">你隔离你的测试吗？</h1><p id="b26c" class="pw-post-body-paragraph kx ky ir kz b la nl js lc ld nm jv lf lg nn li lj lk no lm ln lo np lq lr ls ik bi translated">单元测试应遵循<a class="ae kw" href="https://www.geeksforgeeks.org/software-engineering-white-box-testing/" rel="noopener ugc nofollow" target="_blank">白盒测试</a>原则。覆盖正反向流，覆盖所有决策分支。</p><p id="21fe" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">不良的测试隔离会导致不稳定的、易变的测试。创建易变测试的技巧:</p><blockquote class="nq"><p id="5cc6" class="nr ns ir bd nt nu nv nw nx ny nz ls dk translated"><strong class="ak">流程测试</strong> —开发人员编写必须以特定顺序运行的测试，以便他们可以测试流程执行、由许多操作组成的大用例，或者每个测试都是完整测试中的一个步骤的完整集成测试。</p><p id="3041" class="nr ns ir bd nt nu nv nw nx ny nz ls dk translated">清理中的懒惰 —开发人员很懒惰，不会返回任何她测试可能已经改变回原始形式的状态。</p><p id="99c1" class="nr ns ir bd nt nu nv nw nx ny nz ls dk translated">—摘自单元测试的艺术</p></blockquote><p id="cbe0" class="pw-post-body-paragraph kx ky ir kz b la oa js lc ld ob jv lf lg oc li lj lk od lm ln lo oe lq lr ls ik bi translated">我们都对上述情况感到内疚。单元测试中的测试流程，而不是使用集成测试。整理单元测试的状态，并安排测试通过。</p><p id="00fe" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">通过改变你的习惯来对抗这些。完成测试后，清理数据库。测试后立即初始化。将流程测试转移到集成测试。</p></div><div class="ab cl mm mn hv mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ik il im in io"><h1 id="8419" class="mt mu ir bd mv mw mx my mz na nb nc nd jx ne jy nf ka ng kb nh kd ni ke nj nk bi translated">你测试什么会出错吗？</h1><p id="83c0" class="pw-post-body-paragraph kx ky ir kz b la nl js lc ld nm jv lf lg nn li lj lk no lm ln lo np lq lr ls ik bi translated">我们是乐观的开发者，从不认为任何事情会出错。这本身就是错误的。我们需要首先想到最坏的情况。</p><p id="13f1" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">写了很多行代码后，我发现我们错过了负面场景测试。这会导致错误和不良功能。从概述负面场景的测试用例开始编码。</p><p id="ae86" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">例如，您必须创建一个将两个数相除的方法。从负面测试案例开始。</p><pre class="kh ki kj kk gu og oh oi oj aw ok bi"><span id="f56f" class="ol mu ir oh b gz om on l oo op">@Test(expected = IllegalArgumentException.class)<br/>public void divide_OneNumberIsNull_ThrowException(){...}</span><span id="8481" class="ol mu ir oh b gz oq on l oo op">@Test(expected = IllegalArgumentException.class)<br/>public void divide_BothNumbersAreNull_ThrowException(){...}</span><span id="d91a" class="ol mu ir oh b gz oq on l oo op">@Test(expected = IllegalArgumentException.class)<br/>public void divide_DivideByZero_ThrowException(){...}</span></pre><p id="2075" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">先做消极的场景会解开新的想法。你会看到一些可能发生的新情况。用测试驱动开发总是有好的回报。</p></div><div class="ab cl mm mn hv mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ik il im in io"><p id="f039" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">感谢阅读！</p><div class="lu lv gq gs lw lx"><a href="https://www.artofunittesting.com/" rel="noopener  ugc nofollow" target="_blank"><div class="ly ab fp"><div class="lz ab ma cl cj mb"><h2 class="bd is gz z fq mc fs ft md fv fx iq bi translated">单元测试的艺术</h2><div class="me l"><h3 class="bd b gz z fq mc fs ft md fv fx dk translated">这个扩展版以函数式、模块化和面向对象的风格教授模拟、存根和依赖注入…</h3></div><div class="mf l"><p class="bd b dl z fq mc fs ft md fv fx dk translated">www.artofunittesting.com</p></div></div><div class="mg l"><div class="or l mi mj mk mg ml kq lx"/></div></div></a></div></div></div>    
</body>
</html>