<html>
<head>
<title>Why Refactoring Does Not Mean a Complete Overhaul?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么重构不意味着彻底检修？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/why-refactoring-does-not-mean-a-complete-overhaul-b232f5d80eb8?source=collection_archive---------8-----------------------#2022-01-30">https://blog.devgenius.io/why-refactoring-does-not-mean-a-complete-overhaul-b232f5d80eb8?source=collection_archive---------8-----------------------#2022-01-30</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="1995" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">采取小步骤来改进代码的设计是可以的</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/4f8403243a3197270db070dcf9cb25d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EjzuDk5sRp8dOEMX1SL_Pg.jpeg"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated">重构时迈出一小步，照片由 Pixabay 上的<a class="ae kw" href="https://pixabay.com/users/retyiretyi-501347/" rel="noopener ugc nofollow" target="_blank"> RetyiRetyi </a>拍摄</figcaption></figure><p id="858b" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在最近与我的同事 Tom 的一次谈话中，我们讨论了重构代码以使其更易于维护和扩展的重要性。Tom 提到他计划在添加新特性之前重构整个库，重构过程需要几天时间。</p><p id="4c8d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我对 Tom 重构整个库的决定感到好奇，并问他是如何确定这是必要的。Tom 解释说，他希望通过预测未来的变化并使库更好地适应这些变化，使他的方法变得积极主动和“防御性”。他觉得现在通过重构库，从长远来看，他可以避免潜在的问题并节省时间。</p><p id="1a56" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我不同意我们必须完全重构这个库。仅重构库的一部分将会改进代码，并降低破坏现有功能的风险。</p><p id="717c" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">对我来说，重构由一小步一小步组成。这些步骤可能非常小。让我举一个我认为是一小步的例子。</p><p id="c3db" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在我们讨论的库中，两个类包含几乎相同的功能。明显违背了不要重复自己(DRY)的原则，是重构的候选者。</p><p id="79e5" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">一小步是将两种功能更紧密地结合在一起。从一个类中提取一个方法，将其复制到另一个类中，然后更改调用方。那就是了。代码会更好，也更容易修改，因为你不太可能忘记修改其他函数。让我给你看完整图片的代码。</p><p id="774a" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我们在不同的类中有两种方法。你可以在下面看到的第一个<code class="fe lt lu lv lw b">parseMedia,</code>。这个方法在<code class="fe lt lu lv lw b">VideoDbBuilder</code>类中，解析带有电影的 JSON 文件，并将它们保存在本地 SQLite 数据库中。该类是运行在 Android Tv 上的应用程序的一部分。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="lx ly l"/></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated">来自 VideoDbBuilder 类的 parseMedia</figcaption></figure><p id="f9c4" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">第二种方法具有相同的签名，称为<code class="fe lt lu lv lw b">parseMovies</code>。这个方法是<code class="fe lt lu lv lw b">MovieManagement</code>类的一部分。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="lx ly l"/></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated">来自 MovieManagement 类的 parseMovies</figcaption></figure><p id="7ad5" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这两种方法具有相同的签名，并共享许多功能。显然，这些类和方法应该被重构。我建议的重构是将<code class="fe lt lu lv lw b">parseMovies</code>方法移到<code class="fe lt lu lv lw b">VideoDbBuilder</code>类中，并将调用代码改为使用 VideoDbBuilder 类而不是<code class="fe lt lu lv lw b">MovieManagement</code>类。这样，两种方法会更接近。</p><p id="f5a0" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">汤姆不同意。他说这不符合露营规则。露营规则来自马丁·福勒的《重构改进现有代码的设计》。上面写着。</p><blockquote class="lz ma mb"><p id="f470" class="kx ky mc kz b la lb js lc ld le jv lf md lh li lj me ll lm ln mf lp lq lr ls ik bi translated">编程时，遵循露营规则:总是让代码库比你发现它时更健康。</p></blockquote><p id="7dc4" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我不同意，因为代码库在改变后更健康了。</p><p id="903e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我决定重读《重构》的部分内容，看看是否有答案。我问汤姆是否也能这样做。</p></div><div class="ab cl mg mh hv mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ik il im in io"><h1 id="9160" class="mn mo ir bd mp mq mr ms mt mu mv mw mx jx my jy mz ka na kb nb kd nc ke nd ne bi translated">重构改进现有代码的设计</h1><p id="c6f3" class="pw-post-body-paragraph kx ky ir kz b la nf js lc ld ng jv lf lg nh li lj lk ni lm ln lo nj lq lr ls ik bi translated">我完整地重读了马丁·福勒的《重构，改进现有代码的设计》第二版。这本书将重构描述为一个名词和一个动词。该书将动词重构描述为:</p><blockquote class="lz ma mb"><p id="7dfc" class="kx ky mc kz b la lb js lc ld le jv lf md lh li lj me ll lm ln mf lp lq lr ls ik bi translated">重构是通过应用一系列重构来重构软件的过程。</p></blockquote><p id="b3fd" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这本书把这个名词描述为:</p><blockquote class="lz ma mb"><p id="7232" class="kx ky mc kz b la lb js lc ld le jv lf md lh li lj me ll lm ln mf lp lq lr ls ik bi translated">重构是对软件内部结构的一种改变，使其更容易理解，修改起来更便宜，而不改变其可观察的行为。</p></blockquote><p id="d7c2" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我最感兴趣的是书中是否有描述重构规模的内容。这本书的前 40 页展示了重构。它优化了一个计算和创建剧院公司发票的应用程序。它使用了书中的一些重构模式。</p><p id="a699" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">尽管这个例子有时采取了一些小步骤，比如重命名一个变量，但是它需要指出重构的最佳规模。</p><p id="afb3" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这本书的第二章着眼于重构的一些原则。它包含一个有趣的报价。</p><blockquote class="lz ma mb"><p id="d8b2" class="kx ky mc kz b la lb js lc ld le jv lf md lh li lj me ll lm ln mf lp lq lr ls ik bi translated">如果有人说他们的代码在重构时被破坏了几天，你可以很确定他们没有重构。</p></blockquote><p id="6439" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在第 51 页的同一章中，它说。</p><blockquote class="lz ma mb"><p id="0cff" class="kx ky mc kz b la lb js lc ld le jv lf md lh li lj me ll lm ln mf lp lq lr ls ik bi translated">重构的好处在于，我不会在每一小步都破坏代码，因此，有时需要几个月才能完成工作，但即使我进行到一半，代码也不会被破坏。</p></blockquote><p id="2d2a" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">此外，在第 52 页，Martin Fowler 说他不愿意让一个团队专门做重构。他描述了这个有用的策略。</p><blockquote class="lz ma mb"><p id="55aa" class="kx ky mc kz b la lb js lc ld le jv lf md lh li lj me ll lm ln mf lp lq lr ls ik bi translated">一个有用的重构策略是在接下来的几周里解决这个问题。每当任何人接近重构区域中的任何代码时，他们都会向他们想要改进的方向移动一点。</p></blockquote><p id="981e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">本书的其余部分描述了各种重构。其中一个有趣的重构是“移动函数”。move 函数是我在本文第一部分中描述的重构。</p><p id="1b71" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">另一个有趣的规则是三分法，它指出了何时重构。上面写着。</p><blockquote class="lz ma mb"><p id="631a" class="kx ky mc kz b la lb js lc ld le jv lf md lh li lj me ll lm ln mf lp lq lr ls ik bi translated">第一次做一件事，你就去做。当你第二次做类似的事情时，你会因为重复而退缩，但你还是做了重复的事情。第三次你做类似的事情，你重构。</p></blockquote><p id="75fa" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">重读这本书的第二版给了我想要的答案。</p></div><div class="ab cl mg mh hv mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ik il im in io"><h1 id="e339" class="mn mo ir bd mp mq mr ms mt mu mv mw mx jx my jy mz ka na kb nb kd nc ke nd ne bi translated">展望未来，重构指南</h1><p id="70e5" class="pw-post-body-paragraph kx ky ir kz b la nf js lc ld ng jv lf lg nh li lj lk ni lm ln lo nj lq lr ls ik bi translated">重读这本书后，汤姆和我讨论了我们认为最有趣的内容。基于我们的发现，我们创建了重构指南，可以作为开发团队使用。</p><p id="1090" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我们想出了以下方法。</p><ul class=""><li id="7220" class="nk nl ir kz b la lb ld le lg nm lk nn lo no ls np nq nr ns bi translated">重构应该很小，并且不应该破坏现有的代码。</li><li id="988c" class="nk nl ir kz b la nt ld nu lg nv lk nw lo nx ls np nq nr ns bi translated">永远遵守露营规则。让代码库比你发现它时更健康。变化可以很小。</li><li id="3cf6" class="nk nl ir kz b la nt ld nu lg nv lk nw lo nx ls np nq nr ns bi translated">我们不会创造重构故事。重构应该是典型开发人员日常工作的一部分。</li><li id="15d7" class="nk nl ir kz b la nt ld nu lg nv lk nw lo nx ls np nq nr ns bi translated">如果我们需要重构系统或库的很大一部分，我们会让团队共同努力。每当任何人接近重构区域中的任何代码时，我们都将它向我们想要改进的方向移动一点。</li></ul><p id="1c29" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">目前，我们正在使用这些指南。如果需要，我们将不断完善它们。我会让你知道事情的进展。感谢阅读，永远记得继续学习。</p><p id="a52c" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">你呢？你使用重构的指导方针吗？如果有，是哪一个？</p></div></div>    
</body>
</html>