<html>
<head>
<title>Algorithms — An Introduction to Binary Search</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法——二分搜索法导论</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/algorithms-an-introduction-to-binary-search-46fa131de30a?source=collection_archive---------30-----------------------#2020-06-29">https://blog.devgenius.io/algorithms-an-introduction-to-binary-search-46fa131de30a?source=collection_archive---------30-----------------------#2020-06-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/817d91d64c013c9a5a4de3fc898f2887.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CWbGnoe6ZOy8VqZq"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">凯文·Ku 在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="7ef2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这篇文章旨在向软件开发新手介绍二分搜索法。要理解二分搜索法背后的价值，理解大 O 符号和时间复杂性是很重要的。为了更好地介绍 Big O，我推荐你在这篇文章的地方停下来，读一下科尔顿·凯泽的《媒体邮报》，在这里找到了<a class="ae jz" href="https://levelup.gitconnected.com/big-o-time-complexity-what-it-is-and-why-it-matters-for-your-code-6c08dd97ad59" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="d0f6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们都在同一页上，让我们考虑数组以及如何在数组中找到值。假设给你一个数组，数组的值从 1 到 10，从最小到最大排序。如果您不知道数组的结构，并要求查找 8 是否在数组中并返回它的索引，您可以用几种方法来实现这个目标。你可以写一个循环。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="a2cd" class="lh li in ld b gy lj lk l ll lm">function findValue(array, value){<br/>    for (const i in array){<br/>        if (array[i] === value){<br/>            return i;<br/>        }<br/>    }<br/>    return false;<br/>}</span></pre><p id="048c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">或者也可以使用 find 方法。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="ec57" class="lh li in ld b gy lj lk l ll lm">function findValue(array, value){<br/>    return array.findIndex(i =&gt; i === value);<br/>}</span></pre><p id="0d6c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这看起来很好，很干净，更好的是，它的工作！但是让我们考虑一下大 O 符号。如果数组是 1–1000，并且我们想从这个索引中取出索引 999，会发生什么情况？我简化了很多，但是假装我们不知道答案是 998，我们会有糟糕的代码。就像我们的循环 findIndex 会从头开始，一个接一个地检查数组中那个索引的值是否匹配我们的参数。它必须比较 998 个值，才能最终找到我们要找的那个值。这是很多的比较！这意味着最好的情况是，我们的时间复杂度是 O(1)，其中数组的第一个索引包含我们要寻找的值，最坏的情况是 O(n)，其中答案在最后一个索引中。这被称为<strong class="kc io">线性搜索</strong>，虽然它可以完成非常小规模的情况，但它的时间复杂度会很快超出我们可能认为可以接受的范围。</p><p id="c7cf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">谢天谢地，有更好的方法！欢迎二分搜索法。二分搜索法是一种解决问题的策略，仅当数组包含一个单一的、排序的、可比较的数据类型时，它才可以有效地用于查找数组的值，<strong class="kc io">。</strong>它是如何工作的？我们不是从数组的开头开始，而是从中间开始指针。我们构建了一个循环，一旦指针匹配我们要搜索的值，循环就会中断。如果在循环的任何一次循环中，指针都不匹配，我们就测试这个值是大于还是小于指针。有了这些信息，我们每次都将数组中需要搜索的区域减少一半，而不是每次减少 1。让我们看看那是什么样子。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="0f52" class="lh li in ld b gy lj lk l ll lm">function findValue(array, value){<br/>    let max = array.lenght - 1;<br/>    let min = 0;<br/>    let middle = Math.floor((min+max)/2));<br/>    while(array[middle] != value &amp;&amp; min &lt;= max){<br/>      if(value &lt; array[middle]) max = middle - 1;<br/>      else min = middle + 1;<br/>      middle = Math.floor((min+max)/2));<br/>    }<br/>    return array[middle] === value ? middle : -1;<br/>}</span></pre><p id="3d5d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我来分析一下这里发生了什么。在函数的第一行，我们创建了一个变量“max ”,设置为数组中的最后一个索引。然后，我们创建一个设置为 0(第一个索引)的变量“min ”,并将“middle”设置为数组的中间索引，方法是将 min 和 max 相加，然后除以 2(并考虑小数)。所以如果一个数组中有 9 个值，那么它的 array.length 就是 9。(9 + 0)/ 2 = 4 向下舍入。4 是数组的中间索引。继续这个函数，我们开始一个循环，直到“中间”索引的值等于我们要搜索的值，或者直到循环已经超出所有选项。因此，如果我们还没有找到中间变量的正确值，我们就遍历这个循环，首先测试我们要寻找的值是大于还是小于中间变量指向的值。如果中间值更大，我们将最大值设置为比中间值小 1，否则我们将最小值设置为比中间值大 1。然后，我们使用这个更新的赋值来重新计算“中间”是什么，这实际上将我们的搜索减少了一半。我们继续这样做，直到找到值，或者直到我们的窗口只有 2 宽，这将设置 min ≥= max，触发我们的函数退出并返回-1。让我试着说明正在发生的事情。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="18af" class="lh li in ld b gy lj lk l ll lm">array = [9,10,15,20,77,136,720]</span><span id="ff2d" class="lh li in ld b gy ln lk l ll lm">function findValue(array, 136)<br/>max = 6 (array.lenght - 1)<br/>min = 0<br/>middle = 3, so array[middle] === 20</span><span id="80d4" class="lh li in ld b gy ln lk l ll lm">first test =&gt; [9,10,15,<strong class="ld io">20</strong>,77,136,720]<br/>// 136 is greater than 20, so we step into the loop<br/>// since 136 is greater, min is set to middle + 1 (so min = 4)<br/>// now middle is recalculated, middle = 5 = ((4+6)/2)<br/>// array[middle] now does equal 136, so we return middle<br/>return middle<br/>=&gt; 5</span></pre><p id="7963" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用线性搜索，我们会在检查 6 个值后找到正确的值，但使用二分搜索法，我们在 2 个值后得到正确的值。这是一个简单的数组，但它也可以处理字符串数组，例如，随着数组变长，时间复杂度优势变得惊人地好。在最好的情况下，二分搜索法也将有 O(1)的时间复杂度，但在最坏的情况下，它将有 O(log n ),这比线性搜索 O(n)好得多。回到具有 1000 索引数组的例子。最坏的情况是，线性搜索必须检查所有 1000 个值才能找到正确的值，但二分搜索法只需检查 10 个值。</p><p id="3cfa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我希望这有助于您理解为什么二分搜索法如此有用和重要，并进一步解释时间复杂性是您代码中的一个重要考虑因素。</p></div></div>    
</body>
</html>