<html>
<head>
<title>Concurrency in Go — Using Channels and Handling Race Conditions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go中的并发性——使用通道和处理竞争条件</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/concurrency-in-go-using-channels-mutex-and-handling-race-conditions-6d263b9a2e9d?source=collection_archive---------4-----------------------#2020-08-05">https://blog.devgenius.io/concurrency-in-go-using-channels-mutex-and-handling-race-conditions-6d263b9a2e9d?source=collection_archive---------4-----------------------#2020-08-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/03f51961dd429ce2e861e3b81adb1bea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jH82IhOhhcx2z2oYL3rHRg.jpeg"/></div></div></figure><p id="478b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我每周系列<em class="kw">学习围棋</em>的第十二篇。上周我谈到了使用Goroutines和WaitGroups来利用Go中的并发模式。本周我将继续扩展并发性的话题，向您展示如何使用Go的几个更有用的特性:<em class="kw">通道和互斥</em>。我还将带您了解如何在代码中识别和修复潜在的竞态条件。我们开始吧！</p><h1 id="dcc4" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">频道</h1><blockquote class="lw lx ly"><p id="4ad4" class="jy jz kw ka b kb kc kd ke kf kg kh ki lz kk kl km ma ko kp kq mb ks kt ku kv ij bi translated">允许您在并发Goroutines中发送和接收值的“管道”</p></blockquote><p id="c2a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从本质上来说，<em class="kw">通道</em>可以被认为是信使，你可以将它们发送到不同的Goroutines来传递或获取价值</p><ul class=""><li id="4607" class="mc md iq ka b kb kc kf kg kj me kn mf kr mg kv mh mi mj mk bi translated">频道阻塞</li><li id="dc9f" class="mc md iq ka b kb ml kf mm kj mn kn mo kr mp kv mh mi mj mk bi translated">它们是同步的</li><li id="e0d3" class="mc md iq ka b kb ml kf mm kj mn kn mo kr mp kv mh mi mj mk bi translated">它们必须同时传递或接收值</li></ul><p id="3ae5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通道有两个重要的语法片段<code class="fe mq mr ms mt b">&lt;-</code>和<code class="fe mq mr ms mt b">-&gt;</code></p><p id="73d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当你想把数据<em class="kw">发送到信道</em>时，你可以使用这个语法<code class="fe mq mr ms mt b">channel &lt;-</code></p><p id="6c65" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当您想要从通道中检索数据<em class="kw">时，您可以使用以下语法<code class="fe mq mr ms mt b">&lt;- channel</code></em></p><p id="948a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我给你看一个简单的例子，看看渠道的作用</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="bbbe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的<code class="fe mq mr ms mt b">func</code> <code class="fe mq mr ms mt b">main</code>中，我们使用短声明操作符创建一个带有标识符<code class="fe mq mr ms mt b">c</code>的新变量。我们使用<code class="fe mq mr ms mt b">make</code>关键字来创建一个新的<code class="fe mq mr ms mt b">chan</code>，它的类型是<code class="fe mq mr ms mt b">int</code></p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="b094" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们创建一个匿名的<em class="kw"> Goroutine </em>。在这个<em class="kw"> Goroutine </em>内部，我们使用<code class="fe mq mr ms mt b">c &lt;-</code>语法将值<code class="fe mq mr ms mt b">29</code>发送到我们的<code class="fe mq mr ms mt b">c</code> <em class="kw">通道</em>。我们使用<code class="fe mq mr ms mt b">()</code>来立即运行这个<em class="kw"> Goroutine </em></p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="22cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用<code class="fe mq mr ms mt b">&lt;- c</code>语法获取通道的值，并打印<code class="fe mq mr ms mt b">c</code>的值。当我们去的时候，我们得到值<code class="fe mq mr ms mt b">29</code>应该是不足为奇的。酷！我们已经成功地向<em class="kw">通道</em>发送了数据，并从<em class="kw">通道</em>接收了一个值。</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="6379" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们想限制发送到我们创建的<em class="kw">通道</em>上的数据量，该怎么办？Go通过使用一个叫做<em class="kw">通道缓冲</em>的特性来实现这一点</p><p id="c0ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">默认情况下，<em class="kw">通道</em>无缓冲，这意味着在<em class="kw">通道</em>上可以发送和存储的数据量没有限制。你可以想象，这可能会很快失控。只要有可能，使用<em class="kw">通道缓冲</em>总是一个好主意。</p><p id="c945" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我给你看一个例子:</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="eaab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这应该是个惊喜，对吧？如你所见，我们有5条消息发送到<code class="fe mq mr ms mt b">chat</code>，并成功使用<code class="fe mq mr ms mt b">fmt.Println()</code>打印出每一条记录。但是如果我们试图给<code class="fe mq mr ms mt b">chat</code>添加另一个条目会发生什么呢？</p><p id="52de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，如果我试图向我们的<em class="kw">通道</em>添加另一个<code class="fe mq mr ms mt b">string</code>值，会发生什么呢？让我们来看看:</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="b570" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是相同的代码，除了这一次我们试图添加<code class="fe mq mr ms mt b">No spoilers please!</code>到我们的<code class="fe mq mr ms mt b">chat</code> <em class="kw">频道</em>。围棋不喜欢这样。当我们试图运行我们的应用程序时，Go给出了这个错误:</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="e237" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管错误通常被认为是令人讨厌的，但Go深思熟虑地引入了它们，以帮助您防止应用程序中不必要的副作用。</p><h1 id="3ea9" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">定向渠道</h1><p id="2522" class="pw-post-body-paragraph jy jz iq ka b kb na kd ke kf nb kh ki kj nc kl km kn nd kp kq kr ne kt ku kv ij bi translated">当您开始使用<em class="kw">通道</em>时，您会很快意识到创建只能接收值或只能发送值的<em class="kw">通道</em>是多么有用。Go bakes在这个特性中变成了<code class="fe mq mr ms mt b">chan</code>类型，让我给你看几个例子:</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="655c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe mq mr ms mt b">func</code> <code class="fe mq mr ms mt b">main</code>内部，我们创建了一个标识符为<code class="fe mq mr ms mt b">c</code>的新变量，其类型为<code class="fe mq mr ms mt b">chan</code>，包含类型为<code class="fe mq mr ms mt b">int</code>的值</p><p id="8b75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，我们通过将值<code class="fe mq mr ms mt b">1</code>作为第二个参数传递给<code class="fe mq mr ms mt b">make</code>，使<code class="fe mq mr ms mt b">c</code>成为<em class="kw">缓冲通道</em>。在这种情况下，我们的<em class="kw">缓冲通道</em>只能包含一个值。</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="0b95" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们将值<code class="fe mq mr ms mt b">29</code>发送到我们的<code class="fe mq mr ms mt b">c</code> <em class="kw">通道</em></p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="f086" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这看起来很简单，不是吗？当执行<code class="fe mq mr ms mt b">fmt.Println(&lt;-c)</code>时，我们应该期望打印出值<code class="fe mq mr ms mt b">29</code>，对吗？没有。这是<em class="kw">定向频道</em>在做他们的工作。还记得我们创建<code class="fe mq mr ms mt b">c</code>频道的时候吗？我们明确地告诉Go，当我们使用这个语法<code class="fe mq mr ms mt b">chan &lt;- int</code>时，这个<code class="fe mq mr ms mt b">c</code>通道只会是一个<em class="kw">发送</em>通道</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="f6ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们试图运行这段代码时，Go会阻止我们，并给出一个非常有用的错误消息</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="106c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我给你看另一个使用<em class="kw">定向频道</em>的例子</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="3f7a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个例子中，我们创建了一个标识符为<code class="fe mq mr ms mt b">c</code>的新变量，它的类型为<code class="fe mq mr ms mt b">chan</code>，包含类型为<code class="fe mq mr ms mt b">int</code>的值；然而，在本例中，我们创建了一个只能接收值的<em class="kw">方向通道</em></p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="1ed1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，当我们试图将值<code class="fe mq mr ms mt b">29</code>发送到<code class="fe mq mr ms mt b">c</code> <em class="kw">通道</em>时，我们得到这个错误消息</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="42d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">方向通道</em>可以在组织你的代码中扮演重要的角色。现在，您可以显式创建一个<em class="kw">发送通道</em>和一个<em class="kw">接收通道</em>。如果您放心地让这两个通道都得到缓冲，那么您将在代码中获得很多可预测性。</p><p id="c726" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我给你看一个使用<em class="kw">缓冲定向通道</em>的更深入的例子</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="3225" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个例子中，我们使用了一个<em class="kw">缓冲通道</em>，并且我们创建了两个函数:一个向我们的<em class="kw">通道</em>发送一个值，另一个从我们的<em class="kw">通道</em>接收一个值</p><p id="626e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">重要的事情先来。我们创建一个标识符为<code class="fe mq mr ms mt b">c</code>的新变量，它的类型为<code class="fe mq mr ms mt b">chan</code>，包含类型为<code class="fe mq mr ms mt b">int</code>的值。我们的<code class="fe mq mr ms mt b">make</code>函数中的<code class="fe mq mr ms mt b">1</code>参数使<code class="fe mq mr ms mt b">c</code>成为<em class="kw">缓冲通道</em></p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="b46a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们调用一个带有标识符<code class="fe mq mr ms mt b">send</code>的函数，并传递我们的<code class="fe mq mr ms mt b">c</code> <em class="kw">通道</em>作为唯一的参数，我们对带有标识符<code class="fe mq mr ms mt b">receive</code>的函数做同样的事情</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="6ebe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们创建一个标识符为<code class="fe mq mr ms mt b">send</code>的函数，它有一个参数，即<em class="kw">发送通道</em> ( <em class="kw">通道</em>，您只能向其发送值)。这个<em class="kw">通道</em>将包含类型<code class="fe mq mr ms mt b">int</code>的值。在这个函数内部，我们<em class="kw">将值29发送到我们的<code class="fe mq mr ms mt b">c</code> <em class="kw">通道</em></em></p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="1b95" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们创建一个标识符为<code class="fe mq mr ms mt b">receive</code>的函数，它有一个参数，这个参数是一个<em class="kw">接收通道</em>(一个<em class="kw">通道</em>，您只能从这个通道接收值)。这个<em class="kw">通道</em>将包含<code class="fe mq mr ms mt b">int</code>类型的值。在这个函数中，我们<em class="kw">在我们的<code class="fe mq mr ms mt b">c</code> <em class="kw">通道</em>上接收</em>值29，并使用<code class="fe mq mr ms mt b">fmt</code>包打印该值</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="5eee" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">互斥和竞争条件</h1><p id="7fa9" class="pw-post-body-paragraph jy jz iq ka b kb na kd ke kf nb kh ki kj nc kl km kn nd kp kq kr ne kt ku kv ij bi translated">我们已经了解了如何通过<em class="kw">通道</em>发送和接收数据，但是如果多个<em class="kw"> Goroutines </em>需要访问一个共享的状态，会发生什么呢？我们国家的可靠性很容易受到损害，我们不希望这样。</p><p id="bdb7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我给你看一个例子，当多个<em class="kw"> Goroutines </em>使用一个共享的状态会产生不需要的结果</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="3feb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意:为了这个例子，我将使用<a class="ae kx" href="https://golang.org/pkg/runtime/" rel="noopener ugc nofollow" target="_blank">运行时</a>包来使用<a class="ae kx" href="https://golang.org/pkg/runtime/#Gosched" rel="noopener ugc nofollow" target="_blank"> Gosched() </a>方法。这个方法将允许我发射一个新的Goroutine。</p><p id="dae8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我想确保我正在导入将要使用的包；因此，我导入了<code class="fe mq mr ms mt b">fmt</code>、<code class="fe mq mr ms mt b">runtime</code>和<code class="fe mq mr ms mt b">sync</code>包</p><p id="2976" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe mq mr ms mt b">func</code> <code class="fe mq mr ms mt b">main</code>内部，我们声明了一个新的变量，它的标识符<code class="fe mq mr ms mt b">counter</code>被赋给了值<code class="fe mq mr ms mt b">0</code></p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="2626" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我创建一个标识符为<code class="fe mq mr ms mt b">gs</code>的变量(它代表<em class="kw"> Go Schedule </em>，我将很快介绍这一点)，该变量被赋值为<code class="fe mq mr ms mt b">5</code></p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="3edd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我创建了一个标识符为<code class="fe mq mr ms mt b">wg</code>的变量，并赋予它一个新的<em class="kw"> WaitGroup </em>的值</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="66d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将使用<code class="fe mq mr ms mt b">gs</code>的值进行迭代；因此，我要确保我的<code class="fe mq mr ms mt b">Add</code> <code class="fe mq mr ms mt b">5</code> <em class="kw"> WaitGroups </em></p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="d2db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们创建一个<code class="fe mq mr ms mt b">for</code>循环，它将使用<code class="fe mq mr ms mt b">condition statement</code>中<code class="fe mq mr ms mt b">gs</code>的值。在这个<code class="fe mq mr ms mt b">for</code>循环中，我们创建了一个匿名的<em class="kw"> _Goroutine_ </em>并立即调用<em class="kw"> Goroutine </em>。</p><p id="a95c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的匿名<em class="kw"> Goroutine </em>中，我们用标识符<code class="fe mq mr ms mt b">v</code>声明了一个新变量，并赋予了值<code class="fe mq mr ms mt b">counter</code></p><p id="3b85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用<code class="fe mq mr ms mt b">runtime</code>包来调用<code class="fe mq mr ms mt b">Gosched()</code>方法，从而触发一个新的<em class="kw"> Goroutine </em></p><p id="be34" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下一行，我们增加我们的<code class="fe mq mr ms mt b">v</code>变量，并将<code class="fe mq mr ms mt b">counter</code>变量赋给<code class="fe mq mr ms mt b">v</code>变量</p><p id="0f5b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用<code class="fe mq mr ms mt b">fmt</code>包打印出<code class="fe mq mr ms mt b">counter</code>的值，并使用<code class="fe mq mr ms mt b">wg</code>变量调用<code class="fe mq mr ms mt b">Done()</code>方法，这将让Go运行时知道我们的<code class="fe mq mr ms mt b">WaitGroup</code>已经完成</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="e6f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们总共重复这个过程5次</p><p id="59f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe mq mr ms mt b">for</code>循环之外，我们调用从<code class="fe mq mr ms mt b">wg</code>变量访问的<code class="fe mq mr ms mt b">Wait()</code>方法。<code class="fe mq mr ms mt b">Wait()</code>方法阻止我们的<code class="fe mq mr ms mt b">main</code>函数退出</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="84e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦我们的<em class="kw">等待组</em>全部完成，我们的<code class="fe mq mr ms mt b">main</code>函数就退出</p><p id="2f61" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你注意到我们的<code class="fe mq mr ms mt b">for</code>循环为<code class="fe mq mr ms mt b">counter</code>的值打印了什么吗？目前，每次迭代的值是<code class="fe mq mr ms mt b">1</code>。这是为什么呢？</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="0475" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">目前，我们立即调用了5个Goroutines，但没有告诉Go运行时如何处理它们；因此，它们随机运行、访问和更新我们的<code class="fe mq mr ms mt b">counter</code>状态。没有办法预测这些<em class="kw"> Goroutines </em>的顺序。不过，有一种方法可以解决这个问题！</p><p id="9314" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一次只希望一个<em class="kw"> Goroutine </em>访问一个状态，从而避免冲突的概念被称为<em class="kw">互斥</em>。共享这种方法的数据结构的传统名称叫做<em class="kw">互斥</em></p><p id="0171" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Go标准库提供的<code class="fe mq mr ms mt b">sync</code>包为我们提供了<code class="fe mq mr ms mt b">sync.Mutex</code>两个重要的方法:<code class="fe mq mr ms mt b">Lock</code>和<code class="fe mq mr ms mt b">Unlock</code></p><p id="87f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我给你看一个使用<code class="fe mq mr ms mt b">Mutex</code>的例子</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="3d3f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除了几处不同，上面的代码是一样的。让我解释一下在使用互斥锁<em class="kw">时我们代码中的不同之处</em></p><p id="df0f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了让我们使用一个<em class="kw">互斥体</em>，我们创建了一个标识符为<code class="fe mq mr ms mt b">mu</code>的新变量，它的值为从<code class="fe mq mr ms mt b">sync</code>包中获得的<code class="fe mq mr ms mt b">Mutex</code></p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="8317" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的匿名<em class="kw"> Goroutine </em>的第一行，我们使用我们的<code class="fe mq mr ms mt b">mu</code>变量来调用<code class="fe mq mr ms mt b">Lock()</code>方法。这种方法确保独占访问我们的状态。一旦我们完成了状态更新，我们就调用<code class="fe mq mr ms mt b">Unlock()</code>方法，这个方法也是由我们的<code class="fe mq mr ms mt b">mu</code>变量提供的</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="8628" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以看到我们的<code class="fe mq mr ms mt b">counter</code>日志看起来更像我们所期望的</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="04f8" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">概括起来</h1><p id="79bb" class="pw-post-body-paragraph jy jz iq ka b kb na kd ke kf nb kh ki kj nc kl km kn nd kp kq kr ne kt ku kv ij bi translated">很酷吧？我们现在了解了什么是<em class="kw">通道</em>、<em class="kw">缓冲通道</em>和<em class="kw">定向通道</em>以及如何有效地使用它们。我们还学习了<em class="kw">互斥体</em>以及如何在我们的围棋程序中充分利用它们，以确保我们永远不会污染我们的状态并制造任何竞争条件。</p><p id="3556" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我的<em class="kw">学围棋</em>系列到此结束。我希望你喜欢阅读！虽然这是本系列的最后一篇文章，但您可以期待将来会有更多关于Go的文章！与此同时，考虑订阅我的简讯，在那里我会发布软件行业的新帖子以及有用的工具和技巧。我偶尔也会附上一两张我的金毛猎犬的照片。👋🏻</p></div></div>    
</body>
</html>