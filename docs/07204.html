<html>
<head>
<title>Gravity in software</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">软件中的引力</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/gravity-in-software-5fdf9d243a62?source=collection_archive---------9-----------------------#2022-03-05">https://blog.devgenius.io/gravity-in-software-5fdf9d243a62?source=collection_archive---------9-----------------------#2022-03-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2201" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">物理学有一些基本定律，我们用来创造事物和对抗更强/更常见的力，例如重力。这是工程师努力去做的，也是我们在软件中应该做的。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/14c9a3eebad4a3fd638247514f30a8e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DffsREljFeyvZ3BUONKdBg.jpeg"/></div></div></figure><p id="bb79" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我是喜欢理解物理的人之一，但是谁不想花几个小时学习数学来支持他们。这种方法的问题是，我不能为了自己的利益管理这些法律。但至少我能理解为什么其他人决定以某种方式来形成他们的解决方案。不无知是理解他人观点的关键。<br/>例如，我们人类世界中所有不可思议的事情都是因为人们利用物理定律使克服重力成为可能。这也适用于自然，一只鸟能飞是因为它被设计成一种平衡重力的方式，利用其他物理学原理。</p><p id="1343" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大自然通过进化做到了这一点，虽然人类可以减少时间，因为我们有思考的能力，但我们可以使用相同的原则来理解潜在的原因，并将其用于我们的利益。我们的前置时间更短，我们能够不用等待进化就能飞行，这要感谢科学方法，我们能够比自然更快地检查我们的实验。</p><p id="4ce0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">工程师是填补科学基础和现实世界(不确定性更高)中这些想法的实现之间的空白的一群人。如果一个工程师忽略了这些科学原理中的一个，结果就是混乱，例如倒塌的建筑物。</p><p id="270d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在软件中也是一样，有一些我们不能忽视的基本原则。在现实世界中，重力是存在的更可见的力，在软件中重力是耦合。</p><h2 id="4488" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">连接</h2><p id="aae5" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">重力的大小取决于相互作用的物体的质量。软件的质量可以通过代码行来衡量，大模块往往会增加它们在系统中的耦合。因此，从某种意义上来说，模块越大，从系统中移除它就越困难，因为耦合力违背了这一理念。</p><p id="1f10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">想象一下把地球撞出轨道有多难。这不是不可能的，但是你需要的能量是如此之大，以至于没有人会在这上面投资(我希望没有人想这么做)。<br/>想象一个有一千行代码的类或函数，如果你意识到这个类可以通过不同的方法移除，你认为会发生什么？。<br/>由于这个类太大了，而且与你的系统紧密相连，所以很难从你的代码库中移除这个单元。</p><p id="7b0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但这不是一个仅仅因为我找到了更好的方法就改进设计的问题，而是耦合反对改变。所以每次你试图给你的系统添加一个新的特性时，你可能会和那个大的、高度耦合的单元交谈，使得在你的代码中引入那个变化变得越来越困难。即使你能够引入这种改变，你也会给你的<a class="ae lv" href="https://en.wikipedia.org/wiki/God_object" rel="noopener ugc nofollow" target="_blank">上帝对象</a>添加更多的代码。所以当地球在他们的创造中，越来越多的质量/代码将被添加到地球/单位中，仅仅因为它很大，使它变得更大。</p><p id="4dc8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">自然法则就像软件法则一样，容易产生难以消除、难以改变的混乱局面。</p><h2 id="908e" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">软件设计/架构</h2><p id="178d" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">简单的答案是，如果我们不关心我们的代码，不关心我们的设计，自然会发生混乱。混乱的代码在我们的代码库中是很自然的事情，如果我们想创建一个易于更改的系统，我们需要与它作斗争。</p><p id="ad02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">耦合是一种像重力一样依赖于距离的力，所以不同代码库之间的耦合不是很高。但这并不意味着耦合能预测整个环境中的一切。<br/>想象两个聊天式的服务通过同步调用非常频繁地相互交谈，它们会非常耦合。改变其中一个很可能会产生改变另一个。<br/>我们创造了一个<a class="ae lv" href="https://en.wikipedia.org/wiki/Binary_star" rel="noopener ugc nofollow" target="_blank">双星系统</a>，其中引力(耦合)使得在不改变另一个的情况下重构其中一个非常困难。</p><p id="f53b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想设计一个寿命长达数年的系统，你的系统将会改变。然后你需要开始在每个方面与耦合做斗争，在你的代码库内部，也在你的服务之间，它们是如何交互的，等等。</p><h2 id="dc1b" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">何时重构</h2><p id="296e" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">正如我们所说的，问题始于大小，在一个类、模块、方法或函数中有太多的行会使那部分代码难以更改。此外，像重力一样，这些单位会推动它们内部的变化。因此，为了保持一个易于改变的系统，我们必须在事情小的时候采取行动，我们需要在事情小的时候进化我们的代码和架构，因为能量的数量(在我们的例子中是时间)会更少。</p><p id="0f53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">按照这个想法，我们可能会认为我们可以从一开始就设计一个易于改变的系统。这是不可能的，因为另一个原则也存在于现实生活中，未来是未知的。我们不知道未来会发生什么，所以试图猜测我们系统的哪一部分会频繁改变是很困难的。<br/>如果我们试图从一开始就设计低耦合的一切，我们可能会过度工程化我们的解决方案。过度工程的问题是，我们将为一些不会发生的事情(至少我们不知道)付出额外的复杂性。<br/>所以大多数情况下，这是一项从来没有回报的投资，甚至更多，我们将在我们开发的每个功能中支付并发症(<a class="ae lv" href="https://www.youtube.com/watch?v=WSes_PexXcA" rel="noopener ugc nofollow" target="_blank">意外并发症</a>)。</p><p id="e4ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们需要在中间找到一个空间来管理耦合，而不是过度设计我们的解决方案。有一些规则可以帮助你，例如<a class="ae lv" rel="noopener ugc nofollow" target="_blank" href="/minesweeper-and-lrm-3f621d28ed59?sk=16c12f824d552c47fa26b9a4b7d1c821">最后责任时刻或 YAGNI </a>。</p><h2 id="0adc" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">最后负责的时刻</h2><p id="d552" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">当你有大的代码库或架构时，很难注意到最后负责任的时刻。</p><ul class=""><li id="cbdf" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mb mc md me bi translated">在代码库级别，这更容易，因为改变代码的是我们自己，所以这是一个创建一个环境的问题，在这个环境中<em class="mf">耦合</em>很重要，我们知道如何管理它(开始作为工程师工作)。<br/> <a class="ae lv" rel="noopener ugc nofollow" target="_blank" href="/software-teams-karate-421ff1ce5425?sk=35ae3ddbd707d5d86d681e1d8a08524b">优化学习在这里是关键。</a></li><li id="aa6f" class="lw lx iq jp b jq mg ju mh jy mi kc mj kg mk kk mb mc md me bi translated">在架构级别，注意架构问题的最简单的方法是测量。如何度量耦合，这很困难，但一种方法是创建服务间交互的实时文档。内部或外部涂有更多线条的服务将是耦合性更强的服务，在我们创建一个混乱的东西之前，尝试改变您的系统。</li></ul><p id="7d0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">忽略耦合就像忽略重力</strong></p></div></div>    
</body>
</html>