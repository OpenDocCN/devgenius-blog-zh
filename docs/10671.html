<html>
<head>
<title>CCC ’13 S4 — Who is Taller?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CCC '13 S4 —谁更高？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/ccc-13-s4-who-is-taller-2fadd58fce?source=collection_archive---------12-----------------------#2022-11-20">https://blog.devgenius.io/ccc-13-s4-who-is-taller-2fadd58fce?source=collection_archive---------12-----------------------#2022-11-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/10677ae1f1722cc8015d7a04a909f179.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SbFuEbYgYINYht2mMoacPQ.png"/></div></div></figure><p id="b7a2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我想分享我解决这个问题的方法。这是我尝试并解决的许多图形问题中的第一个，我想分享一下我是如何解决这个问题的。让我们从分析样本输入开始:</p><pre class="ku kv kw kx gt ky kz la bn lb lc bi"><span id="51fd" class="ld le in kz b be lf lg l lh li">10 3<br/>8 4<br/>3 8<br/>4 2<br/>3 2</span></pre><p id="33c9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第一个数字(10)是班上的学生人数。第二个数字是进行比较的次数，我们称之为 M。接下来的 M 行由 2 个数字组成，根据比较的结果，高的和矮的人依次排列。这可以用图表来表示。最后两个数字是你要作的比较(用图表来决定哪一个较高)。万一这还不明显，我们正在处理一个有向无环图，简称 DAG。让我们画出这张图表，看看我们在处理什么。这是它看起来的样子:</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lj"><img src="../Images/8cf1ca4fa488de4dda00ebd92f2f48c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_7bFyH2JXFjw2Z8zHc43Vw.jpeg"/></div></div></figure><p id="aa6f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们要问的问题是，3 比 2 高吗？从这张图可以看出，答案是肯定的。所以我最初的方法是从个子较小的人开始进行广度优先搜索，如果个子较高的人进行深度优先搜索，那么我们可以输出 yes。然而，如果我们不知道，或者根据图表，假定的高个子并不算高呢？这需要更多的分析。然而，让我们首先快速实现深度优先搜索并处理所有输入。</p><pre class="ku kv kw kx gt ky kz la bn lb lc bi"><span id="890c" class="ld le in kz b be lf lg l lh li">#include &lt;vector&gt;<br/>#include &lt;math.h&gt;<br/>#include &lt;iostream&gt;<br/>#include &lt;bitset&gt;<br/>#include &lt;cstdio&gt;<br/>#include &lt;algorithm&gt;<br/>#include &lt;map&gt;<br/>#include &lt;climits&gt;<br/>#include &lt;unordered_map&gt;<br/>#include &lt;stack&gt;<br/>#include &lt;cmath&gt;<br/><br/>using namespace std;<br/><br/>#define endl "\n"<br/>#define scan(x) do{while((x=getchar())&lt;'0'); for(x-='0'; '0'&lt;=(_=getchar()); x=(x&lt;&lt;3)+(x&lt;&lt;1)+_-'0');}while(0)<br/><br/><br/><br/>bool dfs(int p1, int p2, int N, map&lt;int, vector&lt;int&gt;&gt; graph) {<br/> stack&lt;int&gt; stack1;<br/> int current;<br/> stack1.push(p2);<br/> vector&lt;bool&gt; visited(N + 1, false);<br/> while (!stack1.empty()) {<br/>  current = stack1.top();<br/>  visited[current] = true;<br/>  stack1.pop();<br/>  if (current == p1) {<br/>   return true;<br/>  }<br/>  for (int i = 0; i &lt; graph[current].size(); i++) {<br/>   if (!visited[graph[current][i]]) {<br/>    stack1.push(graph[current][i]);<br/>   }<br/>  }<br/> }<br/> return false;<br/>}<br/><br/>int main()<br/>{<br/><br/> int N, M;<br/> cin &gt;&gt; N &gt;&gt; M;<br/> map&lt;int, vector&lt;int&gt;&gt; graph;<br/> vector&lt;int&gt; visited(N + 1, false);<br/> for (int i = 0; i &lt; M; i++) {<br/>  int t1, t2;<br/>  cin &gt;&gt; t1 &gt;&gt; t2;<br/>  graph[t2].push_back(t1);<br/> }<br/> int taller, shorter;<br/> cin &gt;&gt; taller &gt;&gt; shorter;<br/><br/> if (bfs(taller, shorter, N, graph)) {<br/>  cout &lt;&lt; "yes" &lt;&lt; endl;<br/> }<br/>}</span></pre><p id="f0af" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如您在代码中看到的，我们使用 hashmap 结构来存储点，并使用堆栈来遍历图形。我们也将这些点标记为已访问，以防止在错误的情况下循环，这是一个好的做法。请随意分析深度优先搜索，如果您想知道如何实现它，这里有几个链接可以帮助您理解它:</p><div class="lk ll gp gr lm ln"><a href="https://www.geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph/" rel="noopener  ugc nofollow" target="_blank"><div class="lo ab fo"><div class="lp ab lq cl cj lr"><h2 class="bd io gy z fp ls fr fs lt fu fw im bi translated">深度优先搜索或图的 DFS</h2><div class="lu l"><h3 class="bd b gy z fp ls fr fs lt fu fw dk translated">图的深度优先遍历(或搜索)类似于树的深度优先遍历。这里唯一的问题是…</h3></div><div class="lv l"><p class="bd b dl z fp ls fr fs lt fu fw dk translated">www.geeksforgeeks.org</p></div></div><div class="lw l"><div class="lx l ly lz ma lw mb jt ln"/></div></div></a></div><div class="lk ll gp gr lm ln"><a href="https://www.programiz.com/dsa/graph-dfs" rel="noopener  ugc nofollow" target="_blank"><div class="lo ab fo"><div class="lp ab lq cl cj lr"><h2 class="bd io gy z fp ls fr fs lt fu fw im bi translated">深度优先搜索</h2><div class="lu l"><h3 class="bd b gy z fp ls fr fs lt fu fw dk translated">深度优先搜索或深度优先遍历是一种递归算法，用于搜索图或树的所有顶点…</h3></div><div class="lv l"><p class="bd b dl z fp ls fr fs lt fu fw dk translated">www.programiz.com</p></div></div><div class="lw l"><div class="mc l ly lz ma lw mb jt ln"/></div></div></a></div><p id="6fba" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我不会重复如何做这件事。然而，让我们回到我们早先谈论的逻辑。如果你还没有想出来，不要担心，我也花了很多帮助和指导来解决这个问题。基本上，在高个子实际上是矮个子的情况下，我们永远不会在矮个子的图表中找到它。所以，我们可以做的是，我们可以再次调用深度优先搜索功能，不过这次是从高个子的角度，就好像我们在寻找矮个子一样。基本上，在样本输入中，想象一下 3 不是在 8 之后，而是在 2 之前。在第一次深度优先搜索中，我们不会找到它，因为 3 在 2 之前。然而，如果我们从较高的人(3)开始，向前移动，我们找到了 2(较矮的人)，我们可以返回 true 并输出“no ”,这意味着较高的人不比较矮的人高。这看起来会像这样:</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lj"><img src="../Images/787850b2f7f69374b63cf706259aa991.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S7N7eXsiP--IdshDjdEnaA.jpeg"/></div></div></figure><p id="ee42" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然而，如果事实并非如此呢？如果我们找不到这两个问题的答案，并且这两个人在图中没有联系，会怎么样？嗯，这意味着没有足够的信息来解决问题，也就是说我们输出“未知”作为问题状态。</p><p id="1995" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们编写第二个深度优先搜索调用并实现逻辑。</p><pre class="ku kv kw kx gt ky kz la bn lb lc bi"><span id="3385" class="ld le in kz b be lf lg l lh li">#include &lt;vector&gt;<br/>#include &lt;math.h&gt;<br/>#include &lt;iostream&gt;<br/>#include &lt;bitset&gt;<br/>#include &lt;cstdio&gt;<br/>#include &lt;algorithm&gt;<br/>#include &lt;map&gt;<br/>#include &lt;climits&gt;<br/>#include &lt;unordered_map&gt;<br/>#include &lt;stack&gt;<br/>#include &lt;cmath&gt;<br/><br/>using namespace std;<br/><br/>#define endl "\n"<br/>#define scan(x) do{while((x=getchar())&lt;'0'); for(x-='0'; '0'&lt;=(_=getchar()); x=(x&lt;&lt;3)+(x&lt;&lt;1)+_-'0');}while(0)<br/><br/>bool dfs(int p1, int p2, int N, map&lt;int, vector&lt;int&gt;&gt; graph) {<br/> stack&lt;int&gt; stack1;<br/> int current;<br/> stack1.push(p2);<br/> vector&lt;bool&gt; visited(N + 1, false);<br/> while (!stack1.empty()) {<br/>  current = stack1.top();<br/>  visited[current] = true;<br/>  stack1.pop();<br/>  if (current == p1) {<br/>   return true;<br/>  }<br/>  for (int i = 0; i &lt; graph[current].size(); i++) {<br/>   if (!visited[graph[current][i]]) {<br/>    stack1.push(graph[current][i]);<br/>   }<br/>  }<br/> }<br/> return false;<br/>}<br/><br/>int main()<br/>{<br/><br/> int N, M;<br/> cin &gt;&gt; N &gt;&gt; M;<br/> map&lt;int, vector&lt;int&gt;&gt; graph;<br/> vector&lt;int&gt; visited(N + 1, false);<br/> for (int i = 0; i &lt; M; i++) {<br/>  int t1, t2;<br/>  cin &gt;&gt; t1 &gt;&gt; t2;<br/>  graph[t2].push_back(t1);<br/> }<br/> int taller, shorter;<br/> cin &gt;&gt; taller &gt;&gt; shorter;<br/><br/> if (bfs(taller, shorter, N, graph)) {<br/>  cout &lt;&lt; "yes" &lt;&lt; endl;<br/> }<br/>else if (bfs(shorter, taller, N, graph)){<br/>  cout &lt;&lt; "no" &lt;&lt; endl;<br/>}<br/>else {<br/>  cout &lt;&lt; "unknown" &lt;&lt; endl;<br/>}</span></pre><p id="f6b5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这会给你一个完整的解决方案。我希望这个逻辑已经帮助你更好地理解了这种类型的图形问题。留下评论让我知道你想让我接下来尝试什么问题。</p></div></div>    
</body>
</html>