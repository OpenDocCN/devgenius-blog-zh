<html>
<head>
<title>Elasticsearch. Basics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">弹性搜索。基础</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/elasticsearch-basics-657fb6223cfb?source=collection_archive---------4-----------------------#2021-12-22">https://blog.devgenius.io/elasticsearch-basics-657fb6223cfb?source=collection_archive---------4-----------------------#2021-12-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/6d6a7706d8447da1a82fea5128d1b3e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qTjrEE_SCYFGsB10W5h_-g.png"/></div></div></figure><h1 id="718e" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">弹性研究基本概念</h1><p id="2245" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">Elasticsearch 是一个快速的、水平可伸缩的、免费的 NoSQL 混合数据库，可以在其中搜索数据。然而，可以关闭存储，然后只保留搜索引擎，返回曾经被索引的文档的 id。</p><p id="3998" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">虽然它最初是一个文本搜索引擎，但现在已经发展成为一个分析引擎，不仅可以提供搜索，还可以提供复杂的聚合。Elasticsearch 支持自动完成、基于位置的过滤、多级聚合等功能。</p><p id="0c27" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">本文将介绍弹性搜索的基本概念和操作。</p><p id="bfbd" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">首先，我们来看看 Elasticsearch 中的术语。如果您熟悉 SQL，下表显示了在 Elasticsearch 中等价的术语。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lx"><img src="../Images/0bd505a4d8b9cadfc39cc2c2205dad31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PWyWZbOtzkd6g9U4DQwofQ.png"/></div></div></figure><h2 id="5c28" class="mc jw in bd jx md me dn kb mf mg dp kf le mh mi kj li mj mk kn lm ml mm kr mn bi translated">索引</h2><p id="b10c" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">索引就像一个数据库，如果你熟悉关系数据库，它绝不是数据库索引。换句话说，索引是类型(表)的容器。</p><h2 id="1e23" class="mc jw in bd jx md me dn kb mf mg dp kf le mh mi kj li mj mk kn lm ml mm kr mn bi translated">类型</h2><p id="dc8b" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">该类型可以被认为是一个数据库表。因此，每个索引可以包含几种类型。</p><p id="6941" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">假设我们正在创建一个博客应用程序，我们想要创建两种类型，文章和评论。</p><p id="3518" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">文章类型:</p><figure class="ly lz ma mb gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="2e7b" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">注释类型:</p><figure class="ly lz ma mb gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="1690" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">重要的是要知道你可以定义类型之间的关系，一对一，一对多和多对多(如果你想知道更多的关系，请在评论中写下来，我会单独写一篇文章)。</p><h2 id="3c3c" class="mc jw in bd jx md me dn kb mf mg dp kf le mh mi kj li mj mk kn lm ml mm kr mn bi translated">文件</h2><p id="f3c4" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">Elasticsearch 将数据存储为<a class="ae lr" href="https://www.json.org/json-en.html" rel="noopener ugc nofollow" target="_blank"> JSON </a>，因为它方便、简单、灵活。Elasticsearch 中的文档可以看作关系数据库中的字符串。</p><p id="0b0b" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">我们还可以在 Elasticsearch 中存储嵌套的对象。</p><figure class="ly lz ma mb gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="6a4c" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">Elasticsearch 是为处理非结构化数据而构建的，可以自动检测文档字段的数据类型。也就是说，您可以索引新文档或添加新字段，而无需更改模式。</p><h2 id="4343" class="mc jw in bd jx md me dn kb mf mg dp kf le mh mi kj li mj mk kn lm ml mm kr mn bi translated">集群和节点</h2><p id="35eb" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">在传统数据库中，我们通常只有一台服务器来处理所有请求，但 elasticsearch 的工作方式不同。</p><p id="a5e4" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">Elasticsearch 是一个分布式系统。这意味着它由一个或多个作为一个整体工作的节点组成，这允许您扩展和处理超过单个服务器所能处理的负载。</p><p id="a17e" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">每个节点(服务器)都有一段数据。您可以只在一个节点上运行 Elasticsearch，然后在数据量超过一台服务器的容量时扩展集群。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lx"><img src="../Images/049e3a2aa4a32030382cff303f3b9816.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cJ5E8RHZbRrDkCC4tdPVow.png"/></div></div></figure><p id="76a7" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">在上图中，我描绘了一个包含三个节点的集群:elasticsearch1、elasticsearch2 和 elasticsearch3。这些节点作为一个单元来处理所有索引请求和数据检索。</p><h2 id="91b1" class="mc jw in bd jx md me dn kb mf mg dp kf le mh mi kj li mj mk kn lm ml mm kr mn bi translated">碎片</h2><p id="3f3d" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">Elasticsearch 使用<a class="ae lr" href="https://lucene.apache.org" rel="noopener ugc nofollow" target="_blank"> Apach Lucene </a>进行索引和查询处理。</p><p id="9ed0" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">Shard 是 Apache Lucene 的一个实例。该索引可以存储一个或多个碎片。因此，Elasticsearch 可以存储超过一台服务器容量的信息。</p><h1 id="fe1f" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">实践</h1><p id="ea9b" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">你可以从<a class="ae lr" href="https://www.elastic.co/downloads/elasticsearch" rel="noopener ugc nofollow" target="_blank">官方网站</a>下载 Elasticsearch，也可以在 Docker 中运行。</p><p id="356a" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated"><code class="fe mq mr ms mt b">docker run -d -p 9200:9200 elasticsearch</code></p><p id="ad45" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">所以，安装之后，我们需要发送一个请求，Elasticsearch 通过 REST API 进行通信，你可能已经注意到了，它默认运行在端口 9200 上。</p><p id="39b0" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">我将通过<a class="ae lr" href="https://www.postman.com" rel="noopener ugc nofollow" target="_blank"> Postman </a>进行交流(所有例子，我将通过 Postman 展示)，你也可以使用编程语言的客户端库。本质上，这些库是 REST API 的包装器。</p><p id="27a1" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">要检查 Elasticsearch 是否正常工作，请发送一个 GET 请求</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mu"><img src="../Images/436e82e0bcdb3c52988fa26a94280c0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j0Xn7fYujepbDKXiEbxASg.png"/></div></div></figure><p id="5a95" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">我的回答是:</p><figure class="ly lz ma mb gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="2637" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">举个例子，假设我们正在创建我们的博客，并希望使用 Elasticsearch 作为我们的搜索引擎。我们将把所有类型为<strong class="kv io">文章</strong>的文章存储在<strong class="kv io">博客</strong>索引中。我们要索引的每篇文章都是一个 JSON 文档。</p><h2 id="ee64" class="mc jw in bd jx md me dn kb mf mg dp kf le mh mi kj li mj mk kn lm ml mm kr mn bi translated">文档创建</h2><p id="c60b" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">让我们创建一个新的索引，并向它添加一个类型。</p><p id="a875" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">添加一篇文章会是这样的。请求正文是我们想要添加的文章文档。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/e3dffeaa47dea421d411ea24feca0370.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*V80ppECzT8JCifQvhiFU4Q.png"/></div></figure><blockquote class="mw mx my"><p id="a3f7" class="kt ku mz kv b kw ls ky kz la lt lc ld na lu lg lh nb lv lk ll nc lw lo lp lq ig bi translated">如果还不存在的话，Elasticsearch 会自动创建<strong class="kv io">博客</strong>索引和<strong class="kv io">文章</strong>类型。</p></blockquote><p id="d076" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">用有关文档和索引的信息进行响应:</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/a22043cafff7739b567ae38934151401.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*JYI5ma5ym_GFPIwedvo2jw.png"/></div></figure><p id="cb17" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">因为我们使用 HTTP PUT 方法创建了文档，所以我们需要设置文档的 id，否则，我们将得到一个错误。</p><pre class="ly lz ma mb gt ne mt nf ng aw nh bi"><span id="7030" class="mc jw in mt b gy ni nj l nk nl">No handler found for uri [/blog/article/] and method [PUT]</span></pre><p id="6bc9" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">如果您没有唯一的 id，您可以使用 HTTP POST，然后 Elasticsearch 会为您创建一个唯一的 id。例如:</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/275611000f5bf5475bafc41eea441e22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*W0BDvXnn9nU-GXU2Q_U9Rw.png"/></div></figure><p id="8d92" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">回应:</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/cd8ceef87ed80798697b252f316ba139.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*NRleXn5UmEZLt0pTFH9lHw.png"/></div></figure><p id="65bd" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">如果您尝试发出一个 PUT 请求并传递一个现有的 id，文档将被更新，版本参数将增加:</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div class="gh gi no"><img src="../Images/e68b5df34b9abce79f639e14428ffee6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*908CnNyiZta4eApdAf6qIQ.png"/></div></figure><p id="b030" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">回应:</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div class="gh gi np"><img src="../Images/d4f9273004db06d1a55adbc59e787db5.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*-GoOqCsPVfNoVQdHKp9ujQ.png"/></div></figure><p id="5ecd" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">正如你注意到的<code class="fe mq mr ms mt b">_version</code> = 2 和<code class="fe mq mr ms mt b">result</code> =更新。</p><h2 id="76ef" class="mc jw in bd jx md me dn kb mf mg dp kf le mh mi kj li mj mk kn lm ml mm kr mn bi translated">获取现有文档</h2><p id="befe" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">要获取一个文档，我们需要知道文档的<strong class="kv io">索引</strong>、<strong class="kv io">类型</strong>和<strong class="kv io">唯一标识符</strong>。让我们尝试使用以下查询来获取新创建的文档:</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nq"><img src="../Images/edbcd352811c72c525c39c66d3c96552.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6cW7MnjSL2EdZJKV8M3VMw.png"/></div></div></figure><p id="620e" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">如你所见，结果不仅包含文档本身，它存储在<code class="fe mq mr ms mt b">_source</code>层，还包含附加信息，例如，文档被发现<code class="fe mq mr ms mt b">found</code> =真，当前版本<code class="fe mq mr ms mt b">_version</code> = 1，让我提醒你，每次文档被更改时它都会增加。</p><h2 id="1f82" class="mc jw in bd jx md me dn kb mf mg dp kf le mh mi kj li mj mk kn lm ml mm kr mn bi translated">更新现有文档</h2><p id="fc3e" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">在 Elasticsearch 中更新文档比在传统的 SQL 数据库中更复杂。在 Elasticsearch 的幕后，您签出文档，应用更改，然后重新插入文档。非常昂贵的手术。</p><p id="4511" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">让我们更新新创建文档的类别:</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/824be791555b47cd40bddac861c327f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*-uLboBSygn3uihBFK36Tzw.png"/></div></figure><p id="8aa8" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">回应:</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/51b1740e83df38d1c3cbb601af9bee2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*G3HUNPt820wci95LUZFh_g.png"/></div></figure><p id="e6df" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated"><code class="fe mq mr ms mt b">result: updated</code>表示一切顺利，通知<code class="fe mq mr ms mt b">_version</code>也增加了。还有更复杂的升级场景，但我不会在本文中介绍它们。</p><h2 id="7671" class="mc jw in bd jx md me dn kb mf mg dp kf le mh mi kj li mj mk kn lm ml mm kr mn bi translated">删除现有文档</h2><p id="721e" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">要删除现有的文档，我们需要使用 HTTP DELETE 方法，将路径传递给它，就像获取文档一样。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nt"><img src="../Images/152d600ea374a87030572028e5ecc9ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wu2fCSVUQRI-J34WCf3esQ.png"/></div></div></figure><p id="4761" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">回应:</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/b98786822d82c473b604ef5a2e4353b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*O0LtJ75jaPruE30DPoeTrQ.png"/></div></figure><p id="b53f" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated"><code class="fe mq mr ms mt b">result = deleted</code>，则操作成功，文档被删除。</p><h2 id="6588" class="mc jw in bd jx md me dn kb mf mg dp kf le mh mi kj li mj mk kn lm ml mm kr mn bi translated">搜索</h2><p id="892e" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">但是许多 NoSQL 数据库能够添加和接收 JSON。elasticsearch 最强大的当然是<strong class="kv io">搜索</strong>。通过索引搜索文档有两种方法:用于简单搜索查询的<strong class="kv io"> REST 请求 API </strong>，以及更高级的<strong class="kv io">查询 DSL。</strong></p><blockquote class="mw mx my"><p id="5045" class="kt ku mz kv b kw ls ky kz la lt lc ld na lu lg lh nb lv lk ll nc lw lo lp lq ig bi translated">Elasticsearch 中的所有数据都作为倒排索引存储在 Apache Lucene 中。</p></blockquote><p id="3225" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">假设我们有一个文章表，我们想找到 Stasoz 写的所有文章，SQL 如下所示:</p><pre class="ly lz ma mb gt ne mt nf ng aw nh bi"><span id="92d0" class="mc jw in mt b gy ni nj l nk nl">SELECT * FROM Article WHERE Author like '%Stasoz%'</span></pre><p id="4f34" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">弹性搜索查询:</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nv"><img src="../Images/5188a5f682b0a86e6b1eb083d482247c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kh-8-uHvjIZ_SseNynf4tw.png"/></div></div></figure><p id="d34b" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">使用 URL 参数的请求最适合用于简单的事情。对于更复杂的情况，最好使用位于 POST 请求主体中的 JSON 请求(查询 DSL)。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nw"><img src="../Images/08fd7be24c36f04134ba80517486797f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d9BCD2Yt9pzHlOERznxjJw.png"/></div></div></figure><p id="6290" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">回应:</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/c6bf5ebc62e90a969345c6978c3685b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*cod_vlyZwro-Ls7pjv23pw.png"/></div></figure><p id="a871" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">搜索 API 非常灵活，支持不同种类的过滤、排序、分页和聚合。</p><p id="76b8" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">搜索 API 值得单独撰写一篇文章。如果你想知道更多关于搜索 API 的信息，请在评论中写下，我会写的。</p></div><div class="ab cl ny nz hr oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ig ih ii ij ik"><p id="6a8d" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">感谢您阅读本文！如果你想了解更多关于 Elasticsearch 的特定主题(安装、类型之间的关系、Kibana、倒排索引等)，请在评论中写下。</p><p id="1369" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">快乐编码:)</p><h1 id="0fe8" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">学到了新东西？</h1><p id="00c0" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">如果你喜欢这篇文章，你可以<a class="ae lr" href="https://www.buymeacoffee.com/stasoz" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io">给我买杯咖啡</strong> </a>我写下一篇文章的时候再喝:)</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><a href="https://www.buymeacoffee.com/stasoz"><div class="gh gi of"><img src="../Images/cf79c871f5a738ec15a7f5802d80017f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lviQAsrtgJB0dMiercB9ig.png"/></div></a></figure></div></div>    
</body>
</html>