<html>
<head>
<title>SpriteKit Physics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">精神物理学</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/spritekit-physics-c8849475c21?source=collection_archive---------2-----------------------#2020-05-30">https://blog.devgenius.io/spritekit-physics-c8849475c21?source=collection_archive---------2-----------------------#2020-05-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ceda03ffddc870c55edb94c15f9d9979.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6XtWecBHkyJ0sjy4"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">照片由<a class="ae jz" href="https://unsplash.com/@kaip?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯·皮尔格</a>在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="2372" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">绪论</h1><p id="b5fd" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">截至本文撰写时，我已经使用苹果的SpriteKit框架大约6个月了。在这段时间里，我逐渐认识到，SpriteKit是一种了解游戏开发的好方法，因为与使用Unity等游戏引擎相比，你会做更多的低级工作，我认为在转向全面的游戏引擎之前，掌握基础知识是很重要的。从我的理解来说，底层工作与动画、物理、音频、网络、渲染有关，而高层工作侧重于用户界面和游戏性。如果这是不正确的，并且你知道这是不正确的，请让我知道。</p><p id="4553" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">我坚持用SpriteKit开发我的第一个游戏，因为它给了我游戏开发的这一方面，加上我是一名iOS开发者，所以当专注于iOS游戏时，向游戏开发的过渡更容易一些。然而，我确实计划在未来转向Unity进行更有雄心的项目。</p><p id="f9a7" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">我写这篇博客的目的是告诉你关于SpriteKit中的物理系统，基于我在开发中使用它的情况。我要说的是，说到精神，我还有很多东西要学，所以请不要把这当成“一站式、无所不知”的指南。我鼓励你亲自阅读苹果文档，并通过构建一个游戏来体验SpriteKit。</p><p id="15e1" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">话虽如此，我们还是开始吧。(可以在这里找到所指项目的回购:<a class="ae jz" href="https://github.com/andrew-lundy/balls-v-walls/tree/spritekit-physics" rel="noopener ugc nofollow" target="_blank">https://github . com/Andrew-lundy/balls-v-walls/tree/sprite kit-physics</a>)。</p><h1 id="a01a" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">物理学导论</h1><p id="80c6" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">正如预期的那样，斯普里特物理系统的行为方式与我们在地球上所经历的类似。通过在游戏中加入物理学，你可以模拟重力、速度、碰撞检测等等。同样，SpriteKit中有一些东西我还没有接触过，比如<code class="fe mb mc md me b">SKPhysicsContact</code>和<code class="fe mb mc md me b">SKField</code>节点，所以我将坚持使用我已经使用过的东西。截至目前，这包括<code class="fe mb mc md me b">SKPhysicsWorld</code>、<code class="fe mb mc md me b">SKPhysicsBody</code>、<code class="fe mb mc md me b">SKPhysicsContatDelegate</code>。</p><h1 id="ab77" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">物理学的2D世界</h1><p id="9708" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">在SpriteKit中，SKPhysicsWorld是场景中的驱动物理引擎。它可以让你设置重力和速度，在物理碰撞之间作出反应，并进行自定义点击测试。</p><p id="5dac" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">每个场景都会自动创建一个physicsWorld属性，这意味着您不必担心自己创建一个<code class="fe mb mc md me b">SKPhysicsWorld</code>对象。重力属性是一个以米/秒为单位的<code class="fe mb mc md me b">CGVector</code>。重力的默认值是<code class="fe mb mc md me b">(0.0, -9.8)</code>，代表地球的重力。你可以很容易地改变游戏的重心，创造一些很酷的效果。</p><p id="b0ee" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在我的一个名为“Balls v. Walls”的废弃游戏中(这是连接到本博客的项目)，我通过将游戏设置为<code class="fe mb mc md me b">(0.0, 9.8)</code>来反转游戏的重力。在这个例子中，这发生在玩家得了2分，并且“球”被拉向屏幕的顶部而不是被拉向底部之后。</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="d71b" class="mn kb in me b gy mo mp l mq mr">if score == 2 {<br/>    GlobalVariables.shared.gameState = GameState.antiGravity<br/>    SKAction.run {<br/>        SKAction.wait(forDuration: 1)<br/>    }<br/>    self.physicsWorld.gravity = CGVector(dx: 0, dy: 9.8)<br/>}</span></pre><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="72f3" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated"><code class="fe mb mc md me b">physicsWorld</code>也能让你增加或减少场景中模拟的速率。这个属性叫做速度，正如你所看到的，把它设置为“2”，游戏的速度就提高了。</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="bff7" class="mn kb in me b gy mo mp l mq mr">override func didMove(to view: SKView) {<br/>    physicsWorld.speed = 2 <br/>}</span></pre><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="6c7e" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">我之前提到过，physicsWorld允许游戏开发者对他们游戏中的碰撞做出反应。这是通过一个名为contactDelegate的属性和一个名为<code class="fe mb mc md me b">SKPhysicsContactDelegate</code>的协议完成的。在进入这个话题之前，我们先来谈谈<code class="fe mb mc md me b">SKPhysicsBody</code>。</p><p id="f146" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated"><strong class="la io">SKPhysicsBody</strong><br/>An<code class="fe mb mc md me b">SKPhysicsBody</code>为节点定义物理实体的形状和模拟参数。在<code class="fe mb mc md me b">SKPhysicsBody</code>中，你可以改变物理实体的物理属性，改变力如何影响物理实体，管理物理实体的碰撞&amp;接触，应用脉冲等等。</p><p id="349c" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">与<code class="fe mb mc md me b">SKPhysicsWorld</code>不同，您必须为您的节点手动创建一个<code class="fe mb mc md me b">SKPhysicsBody</code>。您创建一个<code class="fe mb mc md me b">SKPhysicsBody</code>对象，将其分配给您为其创建物理实体的任何节点的<code class="fe mb mc md me b">physicsBody</code>属性，然后为其设置属性。您可以从形状或纹理创建一个<code class="fe mb mc md me b">SKPhysicsBody</code>。</p><p id="5930" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">SpriteKit中有三种类型的物理实体——<em class="mu">动态</em>、<em class="mu">静态</em>和<em class="mu">边缘</em>。<em class="mu">动态</em>物体是一个物理物体，它会受到物理系统中的力和碰撞的影响。一个静态的物体是一个不受力和碰撞影响的物理物体。这些通常是您希望在场景中保持静止的节点。一个静止的物体仍然保持体积，因此其他物理物体仍然可以反弹。一个<em class="mu">边</em>是一个静态的无体积体。这些用于表示场景中的负空间，并且从不移动。很多时候，你会用一条边来表示场景的边界。</p><p id="19c0" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">一个物理实体可以由三种形状和一种纹理组成。这些形状包括圆形、矩形和多边形。</p><p id="cf75" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在<a class="ae jz" href="https://developer.apple.com/documentation/spritekit/skphysicsbody" rel="noopener ugc nofollow" target="_blank">苹果文档</a>中阅读更多关于<code class="fe mb mc md me b">SKPhysicsBody</code>的信息。</p><p id="6255" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">下面是一个简单的例子，一个<code class="fe mb mc md me b">SKPhysicsBody</code>被创建并分配给“球对墙”中的球它是由一定的半径大小产生的。然后，设置两个属性；那些是<code class="fe mb mc md me b">restitution</code>和<code class="fe mb mc md me b">isDynamic</code>。物理物体的<code class="fe mb mc md me b">restitution</code>基本上是它的弹性。<code class="fe mb mc md me b">isDynamic</code>属性是一个布尔值，表示物理实体是否是动态的。如果此属性设置为true，则物理实体将在物理模拟中移动。</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="3d84" class="mn kb in me b gy mo mp l mq mr">func createBall() {<br/>    // Create the SKPhysicsBody for the ball.<br/>    ball.physicsBody = SKPhysicsBody(circleOfRadius: 50)<br/>    // Set the restitution (bounciness) of the ball.<br/>    ball.physicsBody?.restitution = 0.6<br/>    // Set the ball to be dynamic.<br/>    ball.physicsBody?.isDynamic = true<br/>}</span></pre><p id="a7eb" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">关于<code class="fe mb mc md me b">SKPhysicsBody</code>，我想谈的下一件事是位掩码类型。位掩码是定义节点的<code class="fe mb mc md me b">physicsBody</code>如何与场景中其他节点上的碰撞和接触进行交互的掩码。</p><p id="edc3" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">下面是苹果对接触和碰撞的描述:<br/> **1。)当你需要知道两个物体相互接触时，就要用到接触。在大多数情况下，当冲突发生时，当你需要改变游戏时，你可以使用隐形眼镜。</p><p id="5f83" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">2.)碰撞用于防止两个物体互相穿透。当一个物体撞击另一个物体时，SpriteKit会自动计算碰撞的结果，并将脉冲应用于碰撞中的物体。**</p><p id="71bc" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">我们要讲的第一个面具是<code class="fe mb mc md me b">categoryBitMask</code>。该遮罩定义了物理实体所属的类别。一个物理实体可以被分配到32个不同的类别。这取决于开发者在他们的游戏中定义掩码值。我使用了一个名为<code class="fe mb mc md me b">CollisionTypes</code>的枚举来定义“球对墙”中的不同类别。</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="d3e6" class="mn kb in me b gy mo mp l mq mr">enum CollisionTypes: UInt32 {<br/>    case ball = 1<br/>    case wall = 2<br/>    case ground = 4<br/>    case scoreDetect = 8<br/>}</span></pre><p id="017e" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">下面是一个更新的<code class="fe mb mc md me b">createBall</code>方法，包括设置球的<code class="fe mb mc md me b">categoryBitMask</code>。</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="fff9" class="mn kb in me b gy mo mp l mq mr">func createBall() {<br/>    ball.physicsBody = SKPhysicsBody(circleOfRadius: 50)<br/>    ball.physicsBody?.restitution = 0.6<br/>    ball.physicsBody?.isDynamic = true<br/>    // Set the categoryBitMask of the ball<br/>    ball.physicsBody?.categoryBitMask = CollisionTypes.ball.rawValue<br/>}</span></pre><p id="0213" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">接下来是<code class="fe mb mc md me b">contactTestBitMask</code>。该掩码定义了哪些类别会引起与节点物理实体的相交通知。请注意，两个节点可以接触，但它们并不总是会导致冲突。当两个物体最终共享同一个空间时，它们的类别位掩码会相互测试，如果它们产生非零值，就会创建一个<code class="fe mb mc md me b">SKPhysicsContact</code>对象并将其传递给物理世界代理。在“球对墙”中，当球穿过墙的相应部分时，我用这个来增加分数。</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="72cd" class="mn kb in me b gy mo mp l mq mr">func createBall() {<br/>    ball.physicsBody = SKPhysicsBody(circleOfRadius: 50)<br/>    ball.physicsBody?.restitution = 0.6<br/>    ball.physicsBody?.isDynamic = true<br/>    ball.physicsBody?.categoryBitMask = CollisionTypes.ball.rawValue<br/>    // Set the contactTestBitMask of the ball. This will let the physics<br/>    // system know that the ball and wall have made contact.<br/>    ball.physicsBody?.contactTestBitMask = CollisionTypes.wall.rawValue<br/> }</span></pre><p id="8887" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">最后，我们有了<code class="fe mb mc md me b">collisionBitMask</code>。正如您可能期望的那样，该遮罩定义了可以与节点碰撞的物理实体的类别。它的工作方式与<code class="fe mb mc md me b">contactTestBitMask</code>类似，当物理物体发生碰撞时，它会执行逻辑与运算。同样，如果结果是非零的值，物体会受到碰撞的影响。</p><p id="b737" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">下面，你可以看到我将球的<code class="fe mb mc md me b">collisionBitMask</code>设置为两个值- <code class="fe mb mc md me b">CollisionTypes.ground.rawValue</code>和<code class="fe mb mc md me b">CollisionTypes.wall.rawValue</code>。这保证了球会与地面和墙壁发生碰撞。此处的管道符号允许您为<code class="fe mb mc md me b">collisionBitMask</code>设置多个值。</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="a90e" class="mn kb in me b gy mo mp l mq mr">func createBall() {<br/>    ball.physicsBody = SKPhysicsBody(circleOfRadius: 50)<br/>    ball.physicsBody?.restitution = 0.6<br/>    ball.physicsBody?.isDynamic = true<br/>    ball.physicsBody?.categoryBitMask = CollisionTypes.ball.rawValue<br/>    ball.physicsBody?.contactTestBitMask = CollisionTypes.wall.rawValue<br/>    // Set the collisionBitMask of the ball. This lets the ball collide with the ball and the wall.<br/>    ball.physicsBody?.collisionBitMask = CollisionTypes.ground.rawValue | CollisionTypes.wall.rawValue<br/>}</span></pre><p id="8e59" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">您可以设置所有您想要的位掩码，但是除非您集成了<code class="fe mb mc md me b">SKPhysicsContactDelegate</code>，否则这些东西都不会工作。</p><p id="ae23" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated"><strong class="la io">SKPhysicsContactDelegate</strong>该方法赋予一致性对象响应基于其<code class="fe mb mc md me b">contactTestBitMask</code>相互接触的物理实体的能力。为了使用该协议，您只需在一个类中采用它，就像任何其他Swift协议一样。在这种情况下，我的<code class="fe mb mc md me b">GameScene</code>类采用了<code class="fe mb mc md me b">SKPhysicsContactDelegate</code>。</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="bf46" class="mn kb in me b gy mo mp l mq mr">class GameScene: SKScene, SKPhysicsContactDelegate {<br/>    override func didMove(to view: SKView) {<br/>        physicsWorld.contactDelegate = self<br/>    }<br/>}</span></pre><p id="5a71" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">我从<code class="fe mb mc md me b">SKPhysicsContactDelegate</code>开始使用的主要方法是<code class="fe mb mc md me b">didBegin(_ contact:)</code>方法，当两个物理实体相互接触时调用该方法。在“Balls v. Walls”中，我检查了发生冲突的两个节点，然后使用自定义方法来处理这些点击。</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="818a" class="mn kb in me b gy mo mp l mq mr">func didBegin(_ contact: SKPhysicsContact) {<br/>    guard let nodeA = contact.bodyA.node else { return }<br/>    guard let nodeB = contact.bodyB.node else { return }</span><span id="23cc" class="mn kb in me b gy mv mp l mq mr">    if nodeA == newBall {<br/>        ballCollided(with: nodeB)<br/>        } else if nodeB == newBall {<br/>            ballCollided(with: nodeA)<br/>        }<br/>    }<br/>}</span></pre><h1 id="ceae" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">结论</h1><p id="480c" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">使用SpriteKit可以做很多事情，我真的鼓励你亲自去看看。如果你是一名iOS开发者，学习SpriteKit会相当顺利。如果你不是iOS开发者，也没有写过Swift，我会建议你在开发游戏之前先把这种语言的基础弄好——但是我承认每个人学习的方式都不一样，所以请做你觉得舒服的事情！</p><p id="3be3" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">除了SpriteKit还有很多其他的选择，比如Unity、Godot、GameMaker等等。使用最适合您的项目的方法——并尝试帮助社区中可能有疑问的人！</p><p id="236a" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">安德鲁</p></div></div>    
</body>
</html>