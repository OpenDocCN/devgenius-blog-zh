<html>
<head>
<title>Best of Modern JavaScript — Set Operations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代 JavaScript 的精华——集合操作</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/best-of-modern-javascript-set-operations-aa2b3fd05b9?source=collection_archive---------5-----------------------#2020-10-26">https://blog.devgenius.io/best-of-modern-javascript-set-operations-aa2b3fd05b9?source=collection_archive---------5-----------------------#2020-10-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/76a6532370ea261a5dacd53df54e9547.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GIU1TKVivhTBZ8gU"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@jakobowens1?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">雅各布·欧文</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="d6c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自 2015 年以来，JavaScript 有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将看看集合。</p><h1 id="dbf3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">遍历集合</h1><p id="9d68" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用 for-of 循环遍历集合，因为集合是可迭代的对象。</p><p id="6b98" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a152" class="mn lc iq mj b gy mo mp l mq mr">const set = new Set(['foo', 'bar', 'baz']);<br/>for (const x of set) {<br/>  console.log(x);<br/>}</span></pre><p id="3137" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ffba" class="mn lc iq mj b gy mo mp l mq mr">foo<br/>bar<br/>baz</span></pre><p id="48c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">记录在案。</p><p id="af02" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">spread 运算符使用 iterables 将它们转换为数组。</p><p id="5a7f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这包括集合，所以我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="dd7a" class="mn lc iq mj b gy mo mp l mq mr">const set = new Set(['foo', 'bar', 'baz']);<br/>const arr = [...set];</span></pre><p id="c47b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而<code class="fe ms mt mu mj b">arr</code>就是<code class="fe ms mt mu mj b">[“foo”, “bar”, “baz”]</code>。</p><h1 id="a4c8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">映射和过滤</h1><p id="f46b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了进行映射和过滤操作，我们可以使用 spread 操作符将集合转换为数组。</p><p id="7b7e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以在这些方法上调用<code class="fe ms mt mu mj b">map</code>和<code class="fe ms mt mu mj b">filter</code>方法。</p><p id="6242" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以通过编写以下内容将集合项目映射到新值:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="275b" class="mn lc iq mj b gy mo mp l mq mr">const set = new Set([1, 2, 3]);<br/>const squares = new Set([...set].map(x =&gt; x ** 2));</span></pre><p id="f0bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="144f" class="mn lc iq mj b gy mo mp l mq mr">{1, 4, 9}</span></pre><p id="76ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f088" class="mn lc iq mj b gy mo mp l mq mr">{1, 2, 3}</span></pre><p id="41ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要过滤项目，我们可以在数组上调用<code class="fe ms mt mu mj b">filter</code>方法:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3433" class="mn lc iq mj b gy mo mp l mq mr">const set = new Set([1, 2, 3]);<br/>const filtered = new Set([...set].filter(x =&gt; (x % 3) == 0));</span></pre><p id="7015" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们过滤掉所有不能被 3 整除的东西，所以我们得到:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6d73" class="mn lc iq mj b gy mo mp l mq mr">{3}</span></pre><h1 id="76ae" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">并集、交集和差集</h1><p id="76a7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用各种数组运算来计算两个集合的并、交和差。</p><h1 id="12a1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">联合</h1><p id="5d48" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">并集是同时包含集合<code class="fe ms mt mu mj b">a</code>和<code class="fe ms mt mu mj b">b</code>元素的集合。</p><p id="20bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用 spread 运算符创建一个并集。</p><p id="a35a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="07d1" class="mn lc iq mj b gy mo mp l mq mr">const a = new Set([1, 2, 3]);<br/>const b = new Set([1, 3, 5]);<br/>const union = new Set([...a, ...b]);</span></pre><p id="c646" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而<code class="fe ms mt mu mj b">union</code>就是<code class="fe ms mt mu mj b">{1, 2, 3, 5}</code>。</p><p id="9060" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">spread 运算符将两个集合组合成一个数组。</p><p id="d3a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">[...a, ...b]</code>相当于<code class="fe ms mt mu mj b">[...a].concat([...b])</code>。</p><p id="b2b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">Set</code>构造函数将它转换回一个集合，并在这个过程中删除重复项。</p><h1 id="d88d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">交集</h1><p id="f7d1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">集合交集是指集合<code class="fe ms mt mu mj b">a</code>中的元素也在集合<code class="fe ms mt mu mj b">b</code>中的集合。</p><p id="917d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要从 2 个集合创建交集，我们可以写为:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9dea" class="mn lc iq mj b gy mo mp l mq mr">const a = new Set([1, 2, 3]);<br/>const b = new Set([1, 3, 5]);<br/>const intersection = new Set(<br/>  [...a].filter(x =&gt; b.has(x)));</span></pre><p id="c80d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建 2 个集合<code class="fe ms mt mu mj b">a</code>和<code class="fe ms mt mu mj b">b</code>。</p><p id="8029" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以用<code class="fe ms mt mu mj b">filter</code>方法得到<code class="fe ms mt mu mj b">a</code>中的所有项目，这些项目也在<code class="fe ms mt mu mj b">b</code>中。</p><p id="89fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">has</code>方法检查<code class="fe ms mt mu mj b">b</code>是否也有相同的项目。</p><p id="5886" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">Set</code>构造函数将数组转换回集合。</p><p id="8b94" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们得到:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9d36" class="mn lc iq mj b gy mo mp l mq mr">{1, 3}</span></pre><p id="a827" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">fot <code class="fe ms mt mu mj b">intersection</code>。</p><h1 id="fbbb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">集合差异</h1><p id="3a59" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">集合差异允许我们从 2 个集合<code class="fe ms mt mu mj b">a</code>和<code class="fe ms mt mu mj b">b</code>中创建一个集合，其中集合<code class="fe ms mt mu mj b">a</code>中的项目不在集合<code class="fe ms mt mu mj b">b</code>中。</p><p id="d522" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要创建集合差异，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0437" class="mn lc iq mj b gy mo mp l mq mr">const a = new Set([1, 2, 3]);<br/>const b = new Set([1, 3, 5]);<br/>const difference = new Set(<br/>  [...a].filter(x =&gt; !b.has(x)));</span></pre><p id="fbe5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用一个回调函数调用<code class="fe ms mt mu mj b">filter</code>，该回调函数否定<code class="fe ms mt mu mj b">has</code>中返回的内容，以返回所有不在<code class="fe ms mt mu mj b">b</code>中但在<code class="fe ms mt mu mj b">a</code>中的项目。</p><p id="a8ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们得到:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="875e" class="mn lc iq mj b gy mo mp l mq mr">{2}</span></pre><p id="c327" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为<code class="fe ms mt mu mj b">difference</code>的值。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/ea45082b0b05029689f2a4bc9e1e4598.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bwnZYPWI9sSLkXom"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kc" href="https://unsplash.com/@kalvisuals?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> KAL VISUALS </a>拍摄的照片</figcaption></figure><h1 id="6a6d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="13e1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以遍历集合，用数组运算来计算并、差和交。</p></div></div>    
</body>
</html>