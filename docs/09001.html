<html>
<head>
<title>How To Apply Redis Cache To GraphQL In Node Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在节点应用中将 Redis 缓存应用到 GraphQL 中</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-apply-redis-cache-to-graphql-in-node-application-407c57fc9ab8?source=collection_archive---------3-----------------------#2022-07-24">https://blog.devgenius.io/how-to-apply-redis-cache-to-graphql-in-node-application-407c57fc9ab8?source=collection_archive---------3-----------------------#2022-07-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="f674" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="2638" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">这篇文章的灵感来自于<a class="ae lg" href="https://github.com/oslabs-beta/rediQLess" rel="noopener ugc nofollow" target="_blank"> rediQLess </a>。基于它的想法，我开发了一个简单的节点应用程序，并将其集成到 GraphQL 和 Apollo Server 中。</p><p id="1651" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">如果你对我的工作和开源贡献感兴趣，请访问这个项目的 GitHub，并留下你遇到的任何问题。非常感谢社区！</p><h1 id="c5d2" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">催单</h1><p id="4099" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在本文中，我不打算解释关于 GraphQL 和 Apollo 服务器设置的细节。网上有很多很棒的教程，强烈推荐你先看看。</p><h1 id="fda8" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">介绍</h1><p id="c22e" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">GraphQL 的本质解决了 RESTFul APIs 的某些缺点，因此近年来它在许多科技公司中变得流行。</p><p id="5e42" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">然而，在我们开始学习之前，我们不应该忽视它的高学习曲线和性能问题。</p><p id="8487" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">今天，我将使用 ExpressJS 和 Apollo Server 发送一个简单的 GraphQL 查询，然后使用 Redis 缓存该查询的结果。</p><h1 id="da19" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">磨快你的工具</h1><p id="f792" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">这是我的工作环境:</p><ol class=""><li id="fe93" class="lm ln in kk b kl lh kp li kt lo kx lp lb lq lf lr ls lt lu bi translated">节点 v17.0.1</li><li id="508f" class="lm ln in kk b kl lv kp lw kt lx kx ly lb lz lf lr ls lt lu bi translated">npm 版本 8.1.0</li><li id="203c" class="lm ln in kk b kl lv kp lw kt lx kx ly lb lz lf lr ls lt lu bi translated">采用 macOS v11.6 和英特尔 x86 CPU 的 MacBook Pro</li></ol><p id="aaf5" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">*MacBook Pro 比较棘手，因为它可能使用 ARM 或 x86，在编译时会导致一些问题。</p><p id="3fa8" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">并安装了最新的依赖项。详情请看我的<code class="fe ma mb mc md b">apollo-server-example/package-json</code>。</p><h1 id="0ebf" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">项目设置</h1><p id="c772" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">运行<code class="fe ma mb mc md b">git clone https://github.com/IMingGarson/rediQLess.git</code>并运行<code class="fe ma mb mc md b">npm install</code>，然后 cd 进入<code class="fe ma mb mc md b">apollo-server-example</code>文件夹并再次运行<code class="fe ma mb mc md b">npm install</code>来安装所有需要的依赖项。</p><p id="457d" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">一旦完成，运行<code class="fe ma mb mc md b">apollo-server-example</code>文件夹中的<code class="fe ma mb mc md b">npm start</code>来启动一个 nodemon，你可以在<code class="fe ma mb mc md b">http://localhost:4000</code>和<code class="fe ma mb mc md b"><a class="ae lg" href="http://localhost:4000/graphql." rel="noopener ugc nofollow" target="_blank">http://localhost:4000/graphql</a></code>中查看你的结果。执行此操作时，请确保您的环境兼容。</p><h1 id="cb61" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">路线说明</h1><p id="b363" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在 Apollo Server 中，根路由<code class="fe ma mb mc md b">/</code>默认用于 GraphQL playground。但是因为我想集成 ExpressJS，所以我保存了<code class="fe ma mb mc md b">/</code>用于端点发送 GraphQL 请求，而<code class="fe ma mb mc md b">/graphql</code>用于实际的 GraphQL 平台。</p><p id="b023" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">一旦运行，您将在<code class="fe ma mb mc md b">/</code>中看到 JSON 响应:</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi me"><img src="../Images/8f446ee19769cd57d08cd77b2a0dbf25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MJvwV68GfpHJB5hlmkR-lQ.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">这是 JSON 查看器 UI。</figcaption></figure><p id="6915" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">还有<code class="fe ma mb mc md b">/graphql</code>里的 GraphQL 游乐场:</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mu"><img src="../Images/965b9ccd6691ab3583d35a1625628ee1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sn_7jCUV0twCYKVb5YifYQ.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">这是一个阿波罗服务器用户界面。</figcaption></figure><h1 id="4975" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">快速模式概述</h1><p id="e71c" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">我为 GraphQL 创建了一个简单的<code class="fe ma mb mc md b">books</code>数据结构。假设一个<code class="fe ma mb mc md b">book</code>有<code class="fe ma mb mc md b">title</code>、<code class="fe ma mb mc md b">ISBN</code>、<code class="fe ma mb mc md b">author(s)</code>、<code class="fe ma mb mc md b">publisher</code>等属性。</p><p id="9fe7" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">为了更好地理解这些属性和一本书之间的关系，让我们尝试这样的查询:</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="26bb" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">我们会看到这样的结果:</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/fa7611834e111a6ee0a9d9e3181d848c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/1*QvkaisJGq_DeMJrFHaqkSA.png"/></div></figure><h1 id="22e2" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">将结果存储在 Redis 中</h1><p id="40a8" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在开始之前，让我们考虑 RESTful APIs 如何与 Redis 一起工作。</p><p id="a4dc" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">假设我们有一个 API 端点<code class="fe ma mb mc md b"><a class="ae lg" href="https://demo.com/api/getAllBooks." rel="noopener ugc nofollow" target="_blank">https://demo.com/api/getAllBooks</a></code>。假设<strong class="kk io">从特定的表中获取所有图书数据</strong>。</p><p id="577c" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">我们可以很容易地将从数据库中检索到的数据存储在 Redis 中。当下一次发送相同的请求时，我们可以简单地返回缓存的结果，而无需连接到数据库。</p><p id="aa25" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">这个案例怎么样:<code class="fe ma mb mc md b"><a class="ae lg" href="https://demo.com/api/getAllBooks?author_id=1." rel="noopener ugc nofollow" target="_blank">https://demo.com/api/getAllBooks?author_id=1</a></code>。假设<strong class="kk io">从一个特定的表中获取作者 1 </strong>写的所有书籍。</p><p id="e7c0" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">原始缓存似乎无效<strong class="kk io"> </strong>，因为<strong class="kk io">作者 1 的书可能只是所有书的子集</strong>，所以<strong class="kk io"> </strong>我们不能返回整个缓存数据，即使端点看起来几乎相同。</p><p id="2569" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">现在考虑 GraphQL，它同样很棘手。下面的查询与前面的有什么不同？</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="3117" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">唯一的区别是:这里省略了<code class="fe ma mb mc md b">ISBN</code>字段。</p><p id="e739" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">现在我们意识到一个微小的变化可以改变我们获取数据的方式。实际上，对于 RESTful APIs，我们可以在 Redis 中为每个作者创建一个条目，其中键是作者的 id，值是该作者写的书。</p><p id="6396" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">这个想法也可以应用于 GraphQL 查询，但是要复杂得多。</p><h1 id="89f7" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">查询结构— AST</h1><p id="7f8b" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">分解 GraphQL 查询是繁重的。一个查询可能包含字段、嵌套查询和附加扩充。幸运的是，有一些方便的工具可以将查询字符串转换成 AST，供我们使用。</p><p id="de43" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">AST，即抽象语法树，是一种人类可读的结构化对象，从 GraphQL 查询字符串派生而来。<a class="ae lg" href="https://www.youtube.com/watch?v=sbOe6fU0SCI&amp;ab_channel=Contentful" rel="noopener ugc nofollow" target="_blank">模式的 graph QL AST—Dawn</a>对 AST 有深入的解释。</p><h1 id="8554" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">制造键值结构</h1><p id="fbf6" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">一旦我们有了 AST，让我们关注它的每一个<code class="fe ma mb mc md b">name.value</code>字段。这些字段表示我们在查询字符串中指定的内容。只要我们能够获得我们想要的字段，我们就可以创建缓存键。</p><p id="254b" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">让我们回到<code class="fe ma mb mc md b">FetchBooks</code>查询。从它的 AST 中，我们可以获得作为主标识符的<code class="fe ma mb mc md b">HarryPotter</code>，并将其连接到它的字段，在本例中是:<code class="fe ma mb mc md b">ISBN</code>、<code class="fe ma mb mc md b">name</code>、<code class="fe ma mb mc md b">authors</code>和<code class="fe ma mb mc md b">publisher</code>。</p><p id="70d5" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">因此，我们可以有多个键，例如，如果用分号连接和分隔，<code class="fe ma mb mc md b">HarryPotter:ISBN</code>、<code class="fe ma mb mc md b">HarryPotter:name</code>和<code class="fe ma mb mc md b">HarryPotter:authors</code>…等。</p><p id="aed2" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">即使<code class="fe ma mb mc md b">authors</code>和<code class="fe ma mb mc md b">publisher</code>是嵌套查询，它仍然适用。我们可以递归地分解这些查询，并为每个条目创建多个键。比如<code class="fe ma mb mc md b">HarryPotter:authors:name</code>或者<code class="fe ma mb mc md b">HarryPotter:publisher:date</code>等等。</p><p id="bd95" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">一旦完成了键，我们就可以相应地将值存储在 Redis 中。</p><h1 id="3407" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">Mjolnir，值得吗？</h1><p id="b361" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">说实话，我对这个过程有疑问。虽然它确实解决了我的问题，但它似乎不是最佳选择。</p><p id="4503" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">为了遍历我们想要的字段，在这个过程中不可避免地要创建大量的键。随着查询变得越来越大、越来越复杂，这肯定会带来麻烦。</p><p id="51e1" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">我想举一个例子来证明我的论点。假设作者 1 写了书 1。</p><p id="9d91" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">如果我们获取第一本书及其作者，我们可以有这样的键<code class="fe ma mb mc md b">FetchBook:1</code>，<code class="fe ma mb mc md b">FetchBook:1:authors:1:name</code>。See 每个字段创建额外的键，这取决于我们在主查询和嵌套查询中需要多少个字段。</p><p id="6052" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">另外，GraphQL 描述了一个到另一个的关系，所以缓存键是不可互换的。例如，如果我们查询作者 1 的所有书籍，我们可以有像<code class="fe ma mb mc md b">FetchAuthor:1</code>、<code class="fe ma mb mc md b">FetchAuthor:1:books:1:title</code>这样的关键字。</p><p id="9b50" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">我的观点是，第一本书的数据可以在<code class="fe ma mb mc md b">FetchBook:1</code>和<code class="fe ma mb mc md b">FetchAuthor:1:books:1</code>中缓存。这样，我们必须创建两个不同的键来存储相同的数据(或者几乎相同，唯一的区别是我们在这些查询中要求的字段数量)。</p><h1 id="74b6" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">坚持住，回头看</h1><p id="aedd" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">RESTful APIs 也有同样的困境吗？嗯，不太一样。</p><p id="d8cb" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">传统上，我们可以用键<code class="fe ma mb mc md b">RESTfulBook:1</code>存储第一本书的数据，而用键<code class="fe ma mb mc md b">RESTfulAuthor:1</code>创作第一本书的数据。</p><p id="2ede" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">如果我们需要来自书籍或作者的任何字段，我们可以发送请求分别从这些键获取数据。</p><p id="0615" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">然而，这就出现了<strong class="kk io">取多</strong>的问题。这是另一个故事了。</p><h1 id="e70a" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">结论</h1><p id="0d80" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">我没有偏见。RESTful APIs 和 GraphQL 各有利弊，因为为项目选择合适的工具总是很重要的。</p><p id="c1e4" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">我们怎么做呢？只要看看他们的优点和缺点，看看他们是否适合你的系统，优雅地解决你的问题。通过更仔细的检查和实验，我们总能找到更好的解决方案来满足我们的需求。</p><p id="b6b5" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">但是，这篇文章只是我对 GraphQL 的看法。如果我犯了一些错误，请留下评论来纠正我。</p><p id="33ba" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">最后，我真诚地希望，通过这个项目和我的一些经验，我可以让您对 GraphQL 及其本质有一些深入的了解。</p><p id="554e" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">就是这样，编码快乐！</p><h1 id="9179" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">未来的工作</h1><ol class=""><li id="6cc3" class="lm ln in kk b kl km kp kq kt my kx mz lb na lf lr ls lt lu bi translated">支持查询的附加属性，如变量、分页和限制及其缓存。</li><li id="e78b" class="lm ln in kk b kl lv kp lw kt lx kx ly lb lz lf lr ls lt lu bi translated">为不同的查询添加自定义的 Redis 缓存过期时间。</li><li id="891b" class="lm ln in kk b kl lv kp lw kt lx kx ly lb lz lf lr ls lt lu bi translated">优化并简化解析 GraphQL 查询和键创建的过程。</li></ol><h1 id="230d" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">参考</h1><ol class=""><li id="f12e" class="lm ln in kk b kl km kp kq kt my kx mz lb na lf lr ls lt lu bi translated"><a class="ae lg" href="https://www.apollographql.com/docs/apollo-server/getting-started/" rel="noopener ugc nofollow" target="_blank">阿波罗服务器官方文档</a></li><li id="7e27" class="lm ln in kk b kl lv kp lw kt lx kx ly lb lz lf lr ls lt lu bi translated"><a class="ae lg" href="https://github.com/oslabs-beta/rediQLess" rel="noopener ugc nofollow" target="_blank">无信誉 GitHub </a></li><li id="cb8c" class="lm ln in kk b kl lv kp lw kt lx kx ly lb lz lf lr ls lt lu bi translated"><a class="ae lg" href="https://github.com/redis/node-redis" rel="noopener ugc nofollow" target="_blank"> node-redis </a></li><li id="160b" class="lm ln in kk b kl lv kp lw kt lx kx ly lb lz lf lr ls lt lu bi translated"><a class="ae lg" href="https://www.youtube.com/watch?v=sbOe6fU0SCI&amp;ab_channel=Contentful" rel="noopener ugc nofollow" target="_blank">图表 AST —模式的黎明</a></li></ol></div></div>    
</body>
</html>