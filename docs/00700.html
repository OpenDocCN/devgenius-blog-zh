<html>
<head>
<title>Getting Current Location In Android Using Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Kotlin 在 Android 中获取当前位置</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/getting-current-location-in-android-using-kotlin-2697e512cff8?source=collection_archive---------32-----------------------#2020-06-14">https://blog.devgenius.io/getting-current-location-in-android-using-kotlin-2697e512cff8?source=collection_archive---------32-----------------------#2020-06-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5fe1938464aa0887c2cccbb57e6da23f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Wus4ghVIom9Tidgt.png"/></div></div></figure><p id="a573" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以在本教程中，我们将学习使用 kotlin (纬度&amp;经度)<strong class="ka ir">获取用户在 Android 中的<strong class="ka ir">当前位置。</strong></strong></p><p id="9b1e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">我们将使用融合的位置提供商。</strong></p><p id="600a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">融合位置提供者检索设备的最后已知位置。融合的位置提供者是<a class="ae kw" href="https://developers.google.com/android/guides/overview" rel="noopener ugc nofollow" target="_blank"> Google Play 服务</a>中的位置 API 之一。</p><p id="d22b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它管理底层的定位技术，并提供一个简单的 API，以便您可以指定高层次的要求，如高精度或低功耗。</p><p id="e59e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">第一步</strong></p><p id="555a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在应用程序的 build.gradle 文件中添加依赖项。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="baec" class="lg lh iq lc b gy li lj l lk ll">dependencies { implementation fileTree(dir: 'libs', include: ['*.jar']) //..... //..... implementation 'com.google.android.gms:play-services-location:17.4.3' }</span></pre><p id="a32c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">第二步</strong></p><p id="497c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">向用户请求位置许可。由于位置对于 android 来说是一个危险的权限，所以我们需要请求用户授予它权限。</p><p id="ea7b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Android 提供两种位置权限:</p><p id="aef9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您选择的权限决定了 API 返回的位置的准确性。</p><p id="f1cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在您清单文件中添加这两个权限。</p><p id="62ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">第三步</strong></p><p id="f375" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能知道，从<strong class="ka ir"> Android 6.0(棉花糖)</strong>你必须请求运行时重要访问的权限。因为这是一个安全问题，在安装应用程序时，用户可能不清楚他们设备的重要权限。</p><p id="0075" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我们需要用户的位置信息，所以我们也需要在运行时实现权限请求。</p><p id="e9c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">阅读更多:</strong> <a class="ae kw" href="https://www.androidhire.com/retrofit-tutorial-in-kotlin/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">如何在 Kotlin </strong> </a>中使用改型教程<strong class="ka ir">这些将在进一步的步骤</strong><strong class="ka ir">PART—1</strong><strong class="ka ir">check permissions()</strong></p><p id="21c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个方法将告诉我们用户是否允许我们访问 ACCESS_COARSE_LOCATION 和 ACCESS_FINE_LOCATION。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="952e" class="lg lh iq lc b gy li lj l lk ll">private fun checkPermissions(): Boolean { if ( ActivityCompat.checkSelfPermission(this,Manifest.permission.ACCESS_COARSE_LOCATION) == PackageManager.PERMISSION_GRANTED &amp;&amp; ActivityCompat.checkSelfPermission (this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED){ return true } return false }</span></pre><p id="d592" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">PART—2</strong><strong class="ka ir">onRequestPermissionsResult()</strong></p><p id="ad6a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当用户允许或拒绝我们请求的权限时，将调用此方法。因此，如果获得许可，这将有助于我们向前迈进。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="9089" class="lg lh iq lc b gy li lj l lk ll">override fun onRequestPermissionsResult(requestCode: Int, permissions: Array&lt;String&gt;, grantResults: IntArray) { if (requestCode == PERMISSION_ID) { if ((grantResults.isNotEmpty() &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED)) { // Granted. Start getting the location information } } }</span></pre><p id="3ac3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">PART—3</strong>T34】is locationenabled()</p><p id="f48a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将检查用户是否从设置中打开了位置，因为用户可能会将应用程序授予用户位置，但如果位置设置是关闭的，那么它将没有用。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="ff48" class="lg lh iq lc b gy li lj l lk ll">private fun isLocationEnabled(): Boolean { var locationManager: LocationManager = getSystemService(Context.LOCATION_SERVICE) as LocationManager return locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER) || locationManager.isProviderEnabled( LocationManager.NETWORK_PROVIDER ) }</span></pre><p id="95fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可能会注意到，在请求权限时以及在获得权限结果后，我们使用了<strong class="ka ir"> PERMISSION_ID </strong>，它是一个整数值，帮助我们识别用户对哪个权限请求的操作。您可以在此提供任何独特的值。</p><p id="e640" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">第四步</strong></p><p id="36f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在是时候编写 MainActivity.kt 了</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="b174" class="lg lh iq lc b gy li lj l lk ll">package com.jayant.mylocation import android.Manifest import android.content.Context import android.content.pm.PackageManager import android.location.LocationManager import androidx.appcompat.app.AppCompatActivity import android.os.Bundle import androidx.core.app.ActivityCompat class MainActivity : AppCompatActivity() { val PERMISSION_ID = 42 override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) } private fun isLocationEnabled(): Boolean { var locationManager: LocationManager = getSystemService(Context.LOCATION_SERVICE) as LocationManager return locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER) || locationManager.isProviderEnabled( LocationManager.NETWORK_PROVIDER ) } private fun checkPermissions(): Boolean { if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION) == PackageManager.PERMISSION_GRANTED &amp;&amp; ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED){ return true } return false } private fun requestPermissions() { ActivityCompat.requestPermissions( this, arrayOf(Manifest.permission.ACCESS_COARSE_LOCATION, Manifest.permission.ACCESS_FINE_LOCATION), PERMISSION_ID ) } override fun onRequestPermissionsResult(requestCode: Int, permissions: Array&lt;String&gt;, grantResults: IntArray) { if (requestCode == PERMISSION_ID) { if ((grantResults.isNotEmpty() &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED)) { // Granted. Start getting the location information } } } }</span></pre><p id="854e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">第六步</strong></p><p id="f705" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们将使用实际的融合位置提供者 API 来获取用户的当前位置。为此，您应该首先使用 mFusedLocationClient:FusedLocationClient 声明一个变量 lateint var</p><p id="83e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们将创建一个名为 getLastLocation()的方法，该方法将使用 API 并返回设备的最后一个记录器位置信息。此外，该方法将首先检查我们的许可是否被授予，以及位置设置是否打开。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="054e" class="lg lh iq lc b gy li lj l lk ll">@SuppressLint("MissingPermission") private fun getLastLocation() { if (checkPermissions()) { if (isLocationEnabled()) { mFusedLocationClient.lastLocation.addOnCompleteListener(this) { task -&gt; var location: Location? = task.result if (location == null) { requestNewLocationData() } else { findViewById&lt;TextView&gt;(R.id.latTextView).text = location.latitude.toString() findViewById&lt;TextView&gt;(R.id.lonTextView).text = location.longitude.toString() } } } else { Toast.makeText(this, "Turn on location", Toast.LENGTH_LONG).show() val intent = Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS) startActivity(intent) } } else { requestPermissions() } }</span></pre><p id="317e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，首先它将使用我们创建的方法 checkPermission()检查我们是否授予了权限，如果没有，它将请求位置权限。然后它会检查位置设置是打开还是关闭。如果关闭，将使用打开它的意图打开位置设置。</p><p id="1614" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果每个要求都是好的，那么它将寻找最后记录的位置信息，并把纬度和经度值放入我们的文本视图</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="80fa" class="lg lh iq lc b gy li lj l lk ll">latTextView.text = location.latitude.toString() lonTextView.text =location.longitude.toString()</span></pre><p id="84dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">第七步</strong></p><p id="84a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最终活动 _main.xml</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="59f9" class="lg lh iq lc b gy li lj l lk ll">&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:gravity="center" android:orientation="vertical"&gt; &lt;TextView android:id="@+id/latTextView" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Latitude: "/&gt; &lt;TextView android:id="@+id/lonTextView" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Longitude: "/&gt; &lt;/LinearLayout&gt;</span></pre><p id="244e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">第 8 步(可选)</strong></p><p id="3d18" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是有一件事你必须知道，在一些罕见的情况下，位置可以是空的，比如:</p><ul class=""><li id="85ba" class="lm ln iq ka b kb kc kf kg kj lo kn lp kr lq kv lr ls lt lu bi translated">在某些设备中，如果您关闭位置并再次打开，以前记录的位置信息将被清除。</li><li id="f354" class="lm ln iq ka b kb lv kf lw kj lx kn ly kr lz kv lr ls lt lu bi translated">可能用户在使用您的应用程序之前从未打开过定位，这一次以前的位置信息也将为空。</li></ul><p id="8c16" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了避免在 location == null 时出现这些罕见的情况，我们调用了一个新方法 requestNewLocation()，它将在运行时记录位置信息。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="d3a3" class="lg lh iq lc b gy li lj l lk ll">@SuppressLint("MissingPermission") private fun requestNewLocationData() { var mLocationRequest = LocationRequest() mLocationRequest.priority = LocationRequest.PRIORITY_HIGH_ACCURACY mLocationRequest.interval = 0 mLocationRequest.fastestInterval = 0 mLocationRequest.numUpdates = 1 mFusedLocationClient = LocationServices.getFusedLocationProviderClient(this) mFusedLocationClient!!.requestLocationUpdates( mLocationRequest, mLocationCallback, Looper.myLooper() ) }</span></pre><p id="f1d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种方法将以最高的精度进行新的定位请求。</p><p id="8c9e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当更新收到时，它将调用一个名为<strong class="ka ir"> mLocationCallback </strong>的回调方法。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="a49c" class="lg lh iq lc b gy li lj l lk ll">private val mLocationCallback = object : LocationCallback() { override fun onLocationResult(locationResult: LocationResult) { var mLastLocation: Location = locationResult.lastLocation findViewById&lt;TextView&gt;(R.id.latTextView).text = mLastLocation.latitude.toString() findViewById&lt;TextView&gt;(R.id.lonTextView).text = mLastLocation.longitude.toString() } }</span></pre><p id="917c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，当我们获得位置更新时，我们在 TextViews 中设置纬度和经度值。</p><p id="4b73" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，最后我们将在 onCreate()方法中调用 getLastLocation()方法，并且在用户授予权限请求时调用。</p><p id="7a28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">最终 MainActivity.kt </strong></p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="63f9" class="lg lh iq lc b gy li lj l lk ll">package com.jayant.mylocation import android.Manifest import android.annotation.SuppressLint import android.content.Context import android.content.Intent import android.content.pm.PackageManager import android.location.Location import android.location.LocationManager import androidx.appcompat.app.AppCompatActivity import android.os.Bundle import android.os.Looper import android.provider.Settings import android.widget.TextView import android.widget.Toast import androidx.core.app.ActivityCompat import com.google.android.gms.location.* class MainActivity : AppCompatActivity() { val PERMISSION_ID = 42 lateinit var mFusedLocationClient: FusedLocationProviderClient override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) mFusedLocationClient = LocationServices.getFusedLocationProviderClient(this) getLastLocation() } @SuppressLint("MissingPermission") private fun getLastLocation() { if (checkPermissions()) { if (isLocationEnabled()) { mFusedLocationClient.lastLocation.addOnCompleteListener(this) { task -&gt; var location: Location? = task.result if (location == null) { requestNewLocationData() } else { findViewById&lt;TextView&gt;(R.id.latTextView).text = location.latitude.toString() findViewById&lt;TextView&gt;(R.id.lonTextView).text = location.longitude.toString() } } } else { Toast.makeText(this, "Turn on location", Toast.LENGTH_LONG).show() val intent = Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS) startActivity(intent) } } else { requestPermissions() } } @SuppressLint("MissingPermission") private fun requestNewLocationData() { var mLocationRequest = LocationRequest() mLocationRequest.priority = LocationRequest.PRIORITY_HIGH_ACCURACY mLocationRequest.interval = 0 mLocationRequest.fastestInterval = 0 mLocationRequest.numUpdates = 1 mFusedLocationClient = LocationServices.getFusedLocationProviderClient(this) mFusedLocationClient!!.requestLocationUpdates( mLocationRequest, mLocationCallback, Looper.myLooper() ) } private val mLocationCallback = object : LocationCallback() { override fun onLocationResult(locationResult: LocationResult) { var mLastLocation: Location = locationResult.lastLocation findViewById&lt;TextView&gt;(R.id.latTextView).text = mLastLocation.latitude.toString() findViewById&lt;TextView&gt;(R.id.lonTextView).text = mLastLocation.longitude.toString() } } private fun isLocationEnabled(): Boolean { var locationManager: LocationManager = getSystemService(Context.LOCATION_SERVICE) as LocationManager return locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER) || locationManager.isProviderEnabled( LocationManager.NETWORK_PROVIDER ) } private fun checkPermissions(): Boolean { if (ActivityCompat.checkSelfPermission( this, Manifest.permission.ACCESS_COARSE_LOCATION ) == PackageManager.PERMISSION_GRANTED &amp;&amp; ActivityCompat.checkSelfPermission( this, Manifest.permission.ACCESS_FINE_LOCATION ) == PackageManager.PERMISSION_GRANTED ) { return true } return false } private fun requestPermissions() { ActivityCompat.requestPermissions( this, arrayOf(Manifest.permission.ACCESS_COARSE_LOCATION, Manifest.permission.ACCESS_FINE_LOCATION), PERMISSION_ID ) } override fun onRequestPermissionsResult(requestCode: Int, permissions: Array&lt;String&gt;, grantResults: IntArray) { if (requestCode == PERMISSION_ID) { if ((grantResults.isNotEmpty() &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED)) { getLastLocation() } } } }</span></pre><p id="72d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是所有的人！</p></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><p id="278d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mh">原载于 2020 年 6 月 14 日 https://www.androidhire.com</em><a class="ae kw" href="https://www.androidhire.com/current-location-in-android-using-kotlin/" rel="noopener ugc nofollow" target="_blank"><em class="mh"/></a><em class="mh">。</em></p></div></div>    
</body>
</html>