<html>
<head>
<title>15 tips to improve as a Javascript developer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高 Javascript 开发人员素质的 15 个技巧</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/15-tips-to-improve-as-a-javascript-developer-e364597edc6f?source=collection_archive---------2-----------------------#2022-08-29">https://blog.devgenius.io/15-tips-to-improve-as-a-javascript-developer-e364597edc6f?source=collection_archive---------2-----------------------#2022-08-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="579f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文中，我将向您展示掌握 JavaScript 语言的 15 个绝佳技巧。我们将学习编码快捷方式、很少有人知道的特性和一些对 JS 程序员非常有用的“技巧”。</p><blockquote class="ki kj kk"><p id="b98b" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated"><strong class="jm io">警告:</strong>不是所有的提示都会取悦所有人。目的是展示有趣的可能性，但是知道什么时候是使用它们的最佳时机取决于程序员(例如，考虑代码的可读性)。</p></blockquote><p id="6524" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">今天的提示难度增加了，所以如果你觉得有些提示太简单，继续读下去，它会变得更难(或者，你可能已经掌握了我今天要教的内容😅).</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/c2a083710c44dedfb4a89dcf61ca936e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*d-63qTsL8Ng4OMNo"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">由<a class="ae lf" href="https://unsplash.com/@art_maltsev?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Artem Maltsev </a>在<a class="ae lf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="6351" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">1.无效和未定义的评估</h1><p id="c4c2" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">在 JavaScript 中，我们很快了解到的一件事是，并不是所有的事情都像它看起来的那样，在像这样的动态语言中，变量会以多种方式给你带来问题。一个非常常见的测试是检查变量是否为空或未定义，甚至是“空”，如下例所示:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="9596" class="mo lh in mk b gy mp mq l mr ms">let username;<br/>if (name !== null || name !== undefined || name !== '') {<br/>   userName = name;<br/>} else {<br/>   userName = "";<br/></span></pre><p id="b5c7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">进行相同评估的一个更简单的方法是:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="547f" class="mo lh in mk b gy mp mq l mr ms">let userName = name || "";</span></pre><p id="504b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你不相信，请测试一下！</p><h1 id="a84c" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">2.数组定义</h1><p id="c5bb" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">所以你必须创建一个数组对象，然后用它的元素填充它，对吗？您的代码可能看起来像这样:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="69a4" class="mo lh in mk b gy mp mq l mr ms">let a = new Array(); <br/>a[0] = "s1"; <br/>a[1] = "s2"; <br/>a[2] = "s3";</span></pre><p id="4159" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">用一行代码做同样的事情怎么样？</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="cd2d" class="mo lh in mk b gy mp mq l mr ms">let a = ["s1", "s2", "s3"]</span></pre><p id="7c44" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">很不错，是吧！</p><blockquote class="ki kj kk"><p id="1fee" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated">警告:我知道这个技巧比较简单，但是对我来说很简单，它可能会帮助一些从其他编程语言开始的人</p></blockquote><h1 id="89ee" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">3.三元运算符</h1><p id="3e81" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">著名的“一行 if/else”，三元运算符已经是 Java 和 C#等类似 C 语言的许多程序员的老熟人了。它也存在于 JS 中，可以像这样轻松地转换代码块:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="69cd" class="mo lh in mk b gy mp mq l mr ms">let big;<br/>if (x &gt; 10) {<br/>    big = true;<br/>}<br/>else {<br/>    big = false;<br/>}</span></pre><p id="3f01" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在此:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="eb20" class="mo lh in mk b gy mp mq l mr ms">let big = x &gt; 10 ? true : false;</span></pre><p id="2689" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">或者更简单:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="5bd9" class="mo lh in mk b gy mp mq l mr ms">let big = x &gt; 10;</span></pre><p id="0b9e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是它也适用于函数调用吗？如果我有两个不同的函数，我想在 If 为真的情况下调用一个，在 if 为假的情况下调用另一个，通常你会这样做:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="fcee" class="mo lh in mk b gy mp mq l mr ms">function x() { console.log('x') };<br/>function y() { console.log('y') };<br/><br/>let z = 3;<br/>if (z == 3) {<br/>    x();<br/>} else {<br/>    y();<br/>}</span></pre><p id="1187" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是，抓紧你的椅子…你可以用三元函数做同样的函数调用:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="73a5" class="mo lh in mk b gy mp mq l mr ms">function x() { console.log('x') };<br/>function y() { console.log('y') };<br/><br/>let z = 3;<br/>(z==3 ? x : y)(); // Shortcut</span></pre><p id="5a61" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">同样值得一提的是测试变量是否为真的 ifs，有些程序员仍然这样做:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="f34b" class="mo lh in mk b gy mp mq l mr ms">if (likeJs === true)</span></pre><p id="fa02" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当他们可以这样做的时候:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="43b3" class="mo lh in mk b gy mp mq l mr ms">if (likeJs)</span></pre><h1 id="c42b" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">4.声明变量</h1><p id="b2c5" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">是的，即使是变量的声明也有它的怪癖。尽管这并不完全是一个秘密，但您仍然会看到许多程序员做出这样的声明:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="9986" class="mo lh in mk b gy mp mq l mr ms">let x;<br/>let y;<br/>let z = 3;</span></pre><p id="2203" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当他们可以这样做的时候:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="eaea" class="mo lh in mk b gy mp mq l mr ms">let x, y, z = 3;</span></pre><h1 id="6110" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">5.使用正则表达式</h1><p id="3022" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">当涉及到文本分析和验证，以及某些类型的网络爬虫的数据提取时，正则表达式是创建优雅而强大的代码的伟大工具。</p><p id="c2cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以在以下链接中了解有关如何使用正则表达式的更多信息:</p><ul class=""><li id="aa53" class="mt mu in jm b jn jo jr js jv mv jz mw kd mx kh my mz na nb bi translated"><a class="ae lf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Guide/Regular _ Expressions</a></li><li id="3795" class="mt mu in jm b jn nc jr nd jv ne jz nf kd ng kh my mz na nb bi translated">https://regexr.com/<a class="ae lf" href="https://regexr.com/" rel="noopener ugc nofollow" target="_blank"/></li><li id="e919" class="mt mu in jm b jn nc jr nd jv ne jz nf kd ng kh my mz na nb bi translated">【https://regex101.com/ T4】</li></ul><h1 id="f8ab" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">6.charAt()快捷方式</h1><p id="b4da" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">所以你想从字符串中选择一个特定位置的字符，对吗？我敢打赌，您想到的第一件事就是使用 charAt 函数，如下所示:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="f479" class="mo lh in mk b gy mp mq l mr ms">"string".charAt(0);</span></pre><p id="e309" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是记住这个，你会得到同样的结果，记住字符串是一个字符数组的类比:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="beee" class="mo lh in mk b gy mp mq l mr ms">"string"[0]; // Returns 's'</span></pre><h1 id="d816" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">7.基数为 10 的幂</h1><p id="6bfd" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">这只是以 10 为基数的指数或者著名的充满零的<strong class="jm io">数的一种更精简的表示法。对于那些接近数学的人来说，看到其中的一个不会太惊讶，但一个数字 10000 在 JS 中可以很容易地被 1e4 取代，即 1 后面跟着 4 个 0，如下所示:</strong></p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="5390" class="mo lh in mk b gy mp mq l mr ms">for (let i = 0; i &lt; 1e4; i++) {</span></pre><h1 id="b4d4" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">8.模板文字</h1><p id="9394" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">这个语义特性是 ECMAScript 版本 6 或更高版本所独有的，它极大地简化了读取变量集中的字符串连接。例如，下面的串联:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="dd01" class="mo lh in mk b gy mp mq l mr ms">const question = “My number is “ + number + “, ok?”</span></pre><p id="0167" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个很简单，你可能做过更糟糕的连接。从 ES6 开始，我们可以使用模板文字进行这种连接:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="c760" class="mo lh in mk b gy mp mq l mr ms">const question = `My number is ${number}, ok?`</span></pre><h1 id="1e4c" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">9.箭头功能</h1><p id="1e03" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">箭头函数是声明函数的简称。是的，自从 JavaScript 的第一个版本以来，有了更多的方法来做同样的事情。例如，下面是一个求和函数:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="b8cc" class="mo lh in mk b gy mp mq l mr ms">function sum(n1,n2){<br/>   return n1 + n2;<br/>}</span></pre><p id="8131" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们也可以这样声明这个函数:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="51ee" class="mo lh in mk b gy mp mq l mr ms">const sum = function(n1,n2){<br/>   return n1+n2;<br/>}</span></pre><p id="6ed9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是使用箭头函数:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="597b" class="mo lh in mk b gy mp mq l mr ms">const sum = (n1,n2) =&gt; n1 + n2;</span></pre><h1 id="fe0b" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">10.变元解构</h1><p id="7cdc" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">这个技巧是针对那些有很多参数的函数，并且你决定用一个对象来替换它们。或者那些真正需要配置对象作为参数的函数。</p><p id="f2db" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">到目前为止没问题，毕竟谁没经历过这个？问题是必须不断地访问对象，这个对象是由参数传递的，后面跟着我们想读取的每个属性，对吗？像这样:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="79ea" class="mo lh in mk b gy mp mq l mr ms">function init(config){<br/>   const s = config.s;<br/>   const t = config.t;<br/>   return s + t;// or config.s + config.t<br/>}<br/><br/>init({s: "1", t: "2"});</span></pre><p id="deda" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">参数析构功能正好可以简化这一点，同时通过用下面的语句替换前面的语句来提高代码的可读性:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="2683" class="mo lh in mk b gy mp mq l mr ms">function init({s, t}){<br/>   return s + t;<br/>}<br/><br/>init({s: 1, t: 2});</span></pre><p id="ab41" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最重要的是，我们仍然可以在参数对象的属性中添加默认值:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="3fe2" class="mo lh in mk b gy mp mq l mr ms">function init({s = 10, t = 20}){<br/>   return s + t;<br/>}<br/><br/>init({s: 1});</span></pre><p id="83af" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这样，s 的值将为 1，但 t 的值将默认为该属性，即 20。</p><h1 id="a7e7" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">11.键值名称</h1><p id="562d" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">一个非常令人上瘾的特性是给对象分配属性的简化方式。假设您有一个 person 对象，它有一个 name 属性，该属性将通过 name 变量进行赋值。它看起来像这样:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="bc1e" class="mo lh in mk b gy mp mq l mr ms">const name = "Joseph"<br/>const person = { name: name }</span><span id="234f" class="mo lh in mk b gy nh mq l mr ms">// { name: "Joseph" }</span></pre><p id="fcb6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">虽然你可以这样做:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="0fa0" class="mo lh in mk b gy mp mq l mr ms">const name = "Joseph"<br/>const person = { name }</span><span id="cc8e" class="mo lh in mk b gy nh mq l mr ms">// { name: "Joseph" }</span></pre><p id="7035" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">也就是说，如果你的变量和属性同名，你不需要调用它，只需要传递变量。对于多个属性也是如此:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="d890" class="mo lh in mk b gy mp mq l mr ms">const name = "Joseph"<br/>const canCode = true<br/>const person = { name, canCode }<br/>// { name: "Joseph", canCode: true }</span></pre><h1 id="a213" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">12.地图</h1><p id="ade5" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">考虑以下对象数组:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="20d1" class="mo lh in mk b gy mp mq l mr ms">const animals = [<br/>    {<br/>        "name": "cat",<br/>        "size": "small",<br/>        "weight": 5<br/>    },<br/>    {<br/>        "name": "dog",<br/>        "size": "small",<br/>        "weight": 10<br/>    },<br/>    {<br/>        "name": "lion",<br/>        "size": "medium",<br/>        "weight": 150<br/>    },<br/>    {<br/>        "name": "elefante",<br/>        "size": "large",<br/>        "weight": 5000<br/>    }<br/>]</span></pre><p id="29bc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在想象一下，我们只想将动物的名字添加到另一个数组中。通常我们会这样做:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="658b" class="mo lh in mk b gy mp mq l mr ms">let animalNames = [];<br/><br/>for (let i = 0; i &lt; animals.length; i++) {<br/>    animalNames.push(animals[i].name);<br/>}</span></pre><p id="4dd0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是有了地图，我们可以这样做:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="6a5a" class="mo lh in mk b gy mp mq l mr ms">let animalNames = animais.map((animal) =&gt; {<br/>    return animal.nome;<br/>})</span></pre><p id="8807" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请注意，map 需要一个最多带有三个参数的函数:</p><ul class=""><li id="f69b" class="mt mu in jm b jn jo jr js jv mv jz mw kd mx kh my mz na nb bi translated">第一个是<strong class="jm io">当前对象</strong>(如在 foreach 中)</li><li id="0737" class="mt mu in jm b jn nc jr nd jv ne jz nf kd ng kh my mz na nb bi translated">第二个是当前迭代的<strong class="jm io">索引</strong></li><li id="def0" class="mt mu in jm b jn nc jr nd jv ne jz nf kd ng kh my mz na nb bi translated">第三个是<strong class="jm io">全阵</strong></li></ul><p id="3787" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">显然，这个函数将为动物数组中的每个对象调用一次。</p><h1 id="3a0e" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">13.过滤器</h1><p id="cbb0" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">如果我们想像上一篇技巧文章一样遍历动物对象的同一数组，但这次只返回那些大小“小”的对象，那该怎么办？</p><p id="6cb5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于普通的 JS 我们该如何做呢？</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="b734" class="mo lh in mk b gy mp mq l mr ms">let smallAnimals = [];<br/><br/>for (let i = 0; i &lt; animals.length; i ++) {<br/>    if (animals[i].size === "small") {<br/>       smallAnimals.push(animals[i])<br/>    }<br/>}</span></pre><p id="a63c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，使用<strong class="jm io"> filter </strong>操作符，我们可以以一种更简洁、更清晰的方式来完成这项工作:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="0098" class="mo lh in mk b gy mp mq l mr ms">let smallAnimals = animais.filter((animal) =&gt; {<br/>    return animal.size === "small"<br/>})</span></pre><p id="4c9e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Filter 需要一个带有参数的函数，该参数是当前迭代的对象(如在 foreach 中)，并且它应该返回一个布尔值，指示该对象是否将成为返回数组的一部分(true 表示它通过了测试，并将成为它的一部分)。</p><h1 id="7c39" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">14.减少</h1><p id="08c7" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">Javascript 的另一个重要特性是<strong class="jm io"> reduce </strong>。它允许我们以一种非常简单和强大的方式对集合进行分组和计算。例如，如果我们想把动物对象数组中所有动物的重量加起来，我们该怎么做呢？</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="fc1d" class="mo lh in mk b gy mp mq l mr ms">let totalWeight = 0;<br/><br/>for (let i = 0; i &lt; animals.length; i++) {<br/>    totalWeight += animals[i].weight;<br/>}</span></pre><p id="3e4f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是使用 reduce，我们可以这样做:</p><pre class="kq kr ks kt gt mj mk ml mm aw mn bi"><span id="5a55" class="mo lh in mk b gy mp mq l mr ms">let totalWeight = animals.reduce((total, animal) =&gt; {<br/>    return total += animal.weight;<br/>}, 0)</span></pre><p id="b48a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Reduce 需要一个带以下参数的函数:</p><ul class=""><li id="f4de" class="mt mu in jm b jn jo jr js jv mv jz mw kd mx kh my mz na nb bi translated">第一个是<strong class="jm io">累加器</strong>变量的当前值(在所有迭代结束时，它将包含最终值)</li><li id="edbe" class="mt mu in jm b jn nc jr nd jv ne jz nf kd ng kh my mz na nb bi translated">第二个参数是当前迭代的<strong class="jm io">对象</strong></li><li id="b0a9" class="mt mu in jm b jn nc jr nd jv ne jz nf kd ng kh my mz na nb bi translated">第三个参数是当前迭代的<strong class="jm io">索引</strong></li><li id="10af" class="mt mu in jm b jn nc jr nd jv ne jz nf kd ng kh my mz na nb bi translated">第四个参数是包含所有将被迭代的对象的<strong class="jm io">数组</strong></li></ul><p id="9b49" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该函数将对数组中的每个对象执行一次，在执行结束时返回聚合值。</p><h1 id="886a" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">结论</h1><p id="6b02" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">你呢？你还有其他建议要添加到列表中吗？留在评论里吧！</p><p id="0e74" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢阅读！在本平台关注我，阅读更多开发内容。祝您愉快，再见！👋</p></div></div>    
</body>
</html>