<html>
<head>
<title>ShardingSphere 5.2.0: Audit for sharding intercepts unreasonable requests in multi-shards scenarios</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ShardingSphere 5.2.0:对分片的审计在多分片场景中拦截不合理的请求</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/shardingsphere-5-2-0-audit-for-sharding-intercepts-unreasonable-requests-in-multi-shards-scenarios-9a113312062b?source=collection_archive---------9-----------------------#2022-10-14">https://blog.devgenius.io/shardingsphere-5-2-0-audit-for-sharding-intercepts-unreasonable-requests-in-multi-shards-scenarios-9a113312062b?source=collection_archive---------9-----------------------#2022-10-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/8591b3d6539bad11f829a690fb0f6a80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35pq3Pil7I17rdcexdPOuw.png"/></div></div></figure><h2 id="d7fa" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">1.背景</h2><p id="c83c" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">感谢我们对<a class="ae lm" href="https://shardingsphere.apache.org" rel="noopener ugc nofollow" target="_blank">分片领域的</a>社区反馈的持续审查，我们使用这些反馈来开发数据分片和读/写拆分等功能，我们发现一些用户在使用数据分片功能时会创建大量的分片。</p><p id="78e2" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">在这种情况下，可能有 1，000 个物理表对应于一个分片逻辑表，这极大地干扰了用户。</p><p id="d1b7" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">例如，<code class="fe ls lt lu lv b">SELECT * FROM t_order</code>语句将导致全路由，这显然不是<a class="ae lm" href="https://shardingsphere.apache.org/blog/en/material/2022_04_26_how_to_use_shardingsphere-proxy_in_real_production_scenarios_your_quick_start_guide/" rel="noopener ugc nofollow" target="_blank"> OLTP </a>的情况。这个 SQL 可以放在另一个代理中，以避免阻塞其他请求。</p><p id="0a6d" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">但是，如果用户不熟悉代理，或者编写了一个<code class="fe ls lt lu lv b">where</code>条件并且不知道在这个条件下不支持分片，那么仍然需要一个完整的路由。</p><p id="7da6" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">完整的路由会降低代理的性能，甚至导致合理的请求失败。想象一下，在一个物理数据库中有 1000 个碎片，如果并行执行，需要 1000 个连接——如果是串行的，请求可能会导致超时。对此，社区用户要求是否可以直接拦截不合理请求。</p><p id="fd22" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">我们已经考虑这个问题有一段时间了。如果我们简单地阻塞全路由操作，我们只需要在代码中检查它，并在配置文件中添加一个开关。另一方面，如果用户后来需要将一个表设置为只读，或者需要更新操作携带一个<code class="fe ls lt lu lv b">limit</code>，这是否意味着我们需要再次更改代码和配置？这显然违背了代理的可插拔逻辑。</p><p id="3f9c" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">针对以上问题，<a class="ae lm" href="https://faun.pub/apache-shardingsphere-5-2-0-is-released-bringing-new-cloud-native-possibilities-8d674d964a93?source=your_stories_page-------------------------------------" rel="noopener ugc nofollow" target="_blank">最近发布的 Apache ShardingSphere 5.2.0 </a>为用户提供了针对分片功能的 SQL 审计。审计可以是截取操作，也可以是统计操作。与分片和唯一密钥生成算法类似，审计算法也是面向插件的、用户定义的和可配置的。</p><p id="bf9c" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">接下来，我们将通过具体的 SQL 示例详细说明数据分片审计的实现逻辑。</p><h2 id="096a" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak"> 2。分片接口审计</strong></h2><p id="3e0c" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">Apache ShardingSphere 的审计入口在<code class="fe ls lt lu lv b">org.apache.shardingsphere.infra.executor.check.SQLCheckEngine</code>类中，该类将调用<code class="fe ls lt lu lv b">SQLChecker</code>接口的<code class="fe ls lt lu lv b">check</code>方法。目前，ShardingSphere audit 包含权限审计(验证用户名和密码)和分片审计。</p><p id="1b90" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">在这里，我们重点关注在 audit for sharding 的<code class="fe ls lt lu lv b">ShardingAuditChecker</code>中实现的父接口。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lw"><img src="../Images/823ab9d9b4c5988da93af4bb88c0ff6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5hqnRAICqGMQAzFD"/></div></div></figure><p id="12bc" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">通过查看<code class="fe ls lt lu lv b">org.apache.shardingsphere.sharding.checker.audit.ShardingAuditChecker</code>的<code class="fe ls lt lu lv b">check</code>代码，可以快速了解其工作原理。</p><pre class="lx ly lz ma gt mb lv mc md aw me bi"><span id="bd08" class="jv jw in lv b gy mf mg l mh mi">public interface ShardingAuditAlgorithm extends ShardingSphereAlgorithm {<br/>    <br/>    <em class="mj">/**</em><br/><em class="mj">     * Sharding audit algorithm SQL check.</em><br/><em class="mj">     *</em><br/><em class="mj">     * @param sqlStatementContext SQL statement context</em><br/><em class="mj">     * @param parameters SQL parameters</em><br/><em class="mj">     * @param grantee grantee</em><br/><em class="mj">     * @param database database</em><br/><em class="mj">     * @return SQL check result</em><br/><em class="mj">     */</em><br/>    SQLCheckResult check(SQLStatementContext&lt;?&gt; sqlStatementContext, List&lt;Object&gt; parameters, Grantee grantee, ShardingSphereDatabase database);<br/>}</span></pre><p id="a33c" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">该方法获取所有相关分片表的审计策略，并调用每个分片表审计策略中配置的审计算法。如果审计算法未能通过，将向用户显示异常。</p><p id="3cc4" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">一些用户可能想知道<code class="fe ls lt lu lv b">disableAuditNames</code>在这里做什么。对分片的审计也允许用户跳过这个过程。在某些情况下，用户可能需要执行审计应该阻止的 SQL，并且他们知道该 SQL 的影响。</p><p id="8544" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">出于这个原因，我们提供了<code class="fe ls lt lu lv b">Hint: disableAuditNames</code>来跳过审计拦截，这将在后面用实际的例子来描述。代理管理员可以配置<code class="fe ls lt lu lv b">allowHintDisable</code>来控制是否允许用户跳过这个过程。默认值为<code class="fe ls lt lu lv b">true</code>，表示允许基于提示的跳过。</p><h2 id="a873" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak"> 3。分片算法审计</strong></h2><p id="3679" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">分片算法接口<code class="fe ls lt lu lv b">org.apache.shardingsphere.sharding.spi.ShardingAuditAlgorithm</code>的审计继承自 SPI 类<code class="fe ls lt lu lv b">ShardingSphereAlgorithm</code>。它继承了<code class="fe ls lt lu lv b">type</code>和<code class="fe ls lt lu lv b">props</code>属性，并定义了自己的<code class="fe ls lt lu lv b">check</code>方法。如果您想定制自己的审计算法，只需实现接口并将其添加到<code class="fe ls lt lu lv b">INF.services</code>中。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/918b3abb0f6a6affd992105dad37af4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/0*93GhyzCcB_uPxFcZ"/></div></figure><pre class="lx ly lz ma gt mb lv mc md aw me bi"><span id="8f83" class="jv jw in lv b gy mf mg l mh mi">public interface ShardingAuditAlgorithm extends ShardingSphereAlgorithm {<br/>    <br/>    <em class="mj">/**</em><br/><em class="mj">     * Sharding audit algorithm SQL check.</em><br/><em class="mj">     *</em><br/><em class="mj">     * @param sqlStatementContext SQL statement context</em><br/><em class="mj">     * @param parameters SQL parameters</em><br/><em class="mj">     * @param grantee grantee</em><br/><em class="mj">     * @param database database</em><br/><em class="mj">     * @return SQL check result</em><br/><em class="mj">     */</em><br/>    SQLCheckResult check(SQLStatementContext&lt;?&gt; sqlStatementContext, List&lt;Object&gt; parameters, Grantee grantee, ShardingSphereDatabase database);<br/>}</span></pre><p id="5607" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">Apache ShardingSphere 实现了对分片算法<code class="fe ls lt lu lv b">org.apache.shardingsphere.sharding.algorithm.audit.DMLShardingConditionsShardingAuditAlgorithm</code>的通用审计，也就是上面提到的截取完整路由的 SQL 语句。</p><p id="e99c" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">该算法通过确定分片条件是否为<code class="fe ls lt lu lv b">null</code>来做出决定。当然，它不会拦截广播表和非分片表。</p><pre class="lx ly lz ma gt mb lv mc md aw me bi"><span id="ec54" class="jv jw in lv b gy mf mg l mh mi">public final class DMLShardingConditionsShardingAuditAlgorithm implements ShardingAuditAlgorithm {<br/>    <br/>    @Getter<br/>    private Properties props;<br/>    <br/>    @Override<br/>    public void init(final Properties props) {<br/>        this.props = props;<br/>    }<br/>    <br/>    @SuppressWarnings({"rawtypes", "unchecked"})<br/>    @Override<br/>    public SQLCheckResult check(final SQLStatementContext&lt;?&gt; sqlStatementContext, final List&lt;Object&gt; parameters, final Grantee grantee, final ShardingSphereDatabase database) {<br/>        if (sqlStatementContext.getSqlStatement() instanceof DMLStatement) {<br/>            ShardingRule rule = database.getRuleMetaData().getSingleRule(ShardingRule.class);<br/>            if (rule.isAllBroadcastTables(sqlStatementContext.getTablesContext().getTableNames())<br/>                    || sqlStatementContext.getTablesContext().getTableNames().stream().noneMatch(rule::isShardingTable)) {<br/>                return new SQLCheckResult(true, "");<br/>            }<br/>            ShardingConditionEngine shardingConditionEngine = ShardingConditionEngineFactory.createShardingConditionEngine(sqlStatementContext, database, rule);<br/>            if (shardingConditionEngine.createShardingConditions(sqlStatementContext, parameters).isEmpty()) {<br/>                return new SQLCheckResult(false, "Not allow DML operation without sharding conditions");<br/>            }<br/>        }<br/>        return new SQLCheckResult(true, "");<br/>    }<br/>    <br/>    @Override<br/>    public String getType() {<br/>        return "DML_SHARDING_CONDITIONS";<br/>    }<br/>}</span></pre><p id="1c49" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">这里我们要介绍另一种针对分片算法的审计:<code class="fe ls lt lu lv b">LimitRequiredShardingAuditAlgorithm</code>。该算法可以在<code class="fe ls lt lu lv b">update</code>和<code class="fe ls lt lu lv b">delete</code>操作中不携带<code class="fe ls lt lu lv b">limit</code>的情况下拦截 SQL。</p><p id="2a7b" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">由于这个算法不太通用，所以它目前没有集成到 Apache ShardingSphere 中。正如您所看到的，实现定制算法非常容易，这就是为什么我们需要为分片框架设计审计。由于其面向插件的架构，ShardingSphere 拥有巨大的可伸缩性。</p><pre class="lx ly lz ma gt mb lv mc md aw me bi"><span id="15aa" class="jv jw in lv b gy mf mg l mh mi">public final class LimitRequiredShardingAuditAlgorithm implements ShardingAuditAlgorithm {<br/>    <br/>    @Getter<br/>    private Properties props;<br/>    <br/>    @Override<br/>    public void init(final Properties props) {<br/>        this.props = props;<br/>    }<br/>    <br/>    @SuppressWarnings({"rawtypes", "unchecked"})<br/>    @Override<br/>    public SQLCheckResult check(final SQLStatementContext&lt;?&gt; sqlStatementContext, final List&lt;Object&gt; parameters, final Grantee grantee, final ShardingSphereDatabase database) {<br/>        if (sqlStatementContext instanceof UpdateStatementContext &amp;&amp; !((MySQLUpdateStatement) sqlStatementContext.getSqlStatement()).getLimit().isPresent()) {<br/>            return new SQLCheckResult(false, "Not allow update without limit");<br/>        }<br/>        if (sqlStatementContext instanceof DeleteStatementContext &amp;&amp; !((MySQLDeleteStatement) sqlStatementContext.getSqlStatement()).getLimit().isPresent()) {<br/>            return new SQLCheckResult(false, "Not allow delete without limit");<br/>        }<br/>        return new SQLCheckResult(true, "");<br/>    }<br/>    <br/>    @Override<br/>    public String getType() {<br/>        return "LIMIT_REQUIRED";<br/>    }<br/>}</span></pre><h2 id="20e7" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak"> 4。使用审计进行分片</strong></h2><p id="77ee" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">分片审计要求您为逻辑表配置审计策略。为了帮助您快速入门，它的配置与分片算法和分片键值生成器的配置相同。</p><p id="d796" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">有算法定义和策略定义，也支持默认审计策略。如果审计策略是在逻辑表中配置的，那么它只对逻辑表有效。</p><p id="765b" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">如果在逻辑表中配置了<code class="fe ls lt lu lv b">defaultAuditStrategy</code>,那么它对分片规则下的所有逻辑表都有效。<code class="fe ls lt lu lv b">Auditors</code>类似于<code class="fe ls lt lu lv b">ShardingAlgorithms</code>、<code class="fe ls lt lu lv b">auditStrategy</code>至<code class="fe ls lt lu lv b">databaseStrategy</code>、<code class="fe ls lt lu lv b">defaultAuditStrategy</code>至<code class="fe ls lt lu lv b">defaultDatabaseStrategy</code>或<code class="fe ls lt lu lv b">defaultTableStrategy</code>。</p><p id="1370" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">请参考以下配置。仅显示用于分片的审计配置。需要自己配置分片算法和数据源。</p><pre class="lx ly lz ma gt mb lv mc md aw me bi"><span id="060a" class="jv jw in lv b gy mf mg l mh mi">rules:<br/>  - !SHARDING<br/>    tables:<br/>      t_order:<br/>        actualDataNodes: ds_${0..1}.t_order_${0..1}<br/>        auditStrategy:<br/>          auditorNames:<br/>            - sharding_key_required_auditor<br/>          allowHintDisable: true</span><span id="f2f9" class="jv jw in lv b gy ml mg l mh mi">    defaultAuditStrategy:<br/>      auditorNames:<br/>        - sharding_key_required_auditor<br/>      allowHintDisable: true</span><span id="425b" class="jv jw in lv b gy ml mg l mh mi">    auditors:<br/>      sharding_key_required_auditor:<br/>        type: DML_SHARDING_CONDITIONS</span></pre><p id="cf85" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated"><strong class="kt io">第一步:</strong>执行一个查询操作。在配置用于拦截完整数据库路由的审核策略时，会显示一个错误。</p><pre class="lx ly lz ma gt mb lv mc md aw me bi"><span id="24db" class="jv jw in lv b gy mf mg l mh mi">mysql&gt; select * from t_order;<br/>ERROR 13000 (44000): SQL check failed, error message: Not allow DML operation without sharding conditions</span></pre><p id="65b9" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated"><strong class="kt io">第二步:</strong>添加<code class="fe ls lt lu lv b">HINT.</code><code class="fe ls lt lu lv b">HINT</code>的名称是<code class="fe ls lt lu lv b">/* ShardingSphere hint: disableAuditNames */</code>，<code class="fe ls lt lu lv b">disableAuditNames</code>后面是前面命令中配置的<code class="fe ls lt lu lv b">auditorsNames</code>。</p><p id="f3b5" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">如果有多个名称，请用空格分隔，如<code class="fe ls lt lu lv b">/* ShardingSphere hint: disableAuditNames=auditName1 auditName2*/</code>。使用<code class="fe ls lt lu lv b">HINT</code>后，我们可以看到 SQL 操作成功执行。</p><pre class="lx ly lz ma gt mb lv mc md aw me bi"><span id="477b" class="jv jw in lv b gy mf mg l mh mi">mysql&gt; <em class="mj">/* ShardingSphere hint: disableAuditNames=sharding_key_required_auditor */</em> select * from t_order;<br/>+<em class="mj">----------+---------+------------+--------+</em><br/>| order_id | user_id | address_id | status |<br/>+<em class="mj">----------+---------+------------+--------+</em><br/>|       30 |      20 |         10 | 20     |<br/>|       32 |      22 |         10 | 20     |<br/>+<em class="mj">----------+---------+------------+--------+</em><br/>2 rows in set (0.01 sec)</span></pre><p id="862d" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated"><strong class="kt io">注意:</strong> <code class="fe ls lt lu lv b">HINT</code>需要您修改代理的<code class="fe ls lt lu lv b">server.yaml</code>配置。另外，如果你使用 MySQL 终端直接连接代理，你需要添加<code class="fe ls lt lu lv b">-c</code>属性——否则，<code class="fe ls lt lu lv b">HINT </code>评论将从 MySQL 终端过滤掉，不会被后端的代理解析。</p><pre class="lx ly lz ma gt mb lv mc md aw me bi"><span id="e423" class="jv jw in lv b gy mf mg l mh mi">rules:<br/>  - !SQL_PARSER<br/>    sqlCommentParseEnabled: true<br/>    sqlStatementCache:<br/>      initialCapacity: 2000<br/>      maximumSize: 65535<br/>    parseTreeCache:<br/>      initialCapacity: 128<br/>      maximumSize: 1024<br/>props:<br/>  proxy-hint-enabled: true</span><span id="386e" class="jv jw in lv b gy ml mg l mh mi">mysql -uroot -proot -h127.0.0.1 -P3307  -c</span></pre><h2 id="ed8b" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak"> 5。带分片审计的 DistSQL】</strong></h2><p id="4bf8" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">目前，正如你从<a class="ae lm" href="https://github.com/apache/shardingsphere/releases/tag/5.2.0" rel="noopener ugc nofollow" target="_blank">发行说明</a>中看到的，Apache ShardingSphere 5.2.0 支持以下<a class="ae lm" href="https://shardingsphere.apache.org/document/5.1.0/en/concepts/distsql/" rel="noopener ugc nofollow" target="_blank"> DistSQL </a>的分片审计功能。</p><pre class="lx ly lz ma gt mb lv mc md aw me bi"><span id="9660" class="jv jw in lv b gy mf mg l mh mi">CREATE SHARDING AUDITOR<br/>ALTER SHARDING AUDITOR<br/>SHOW SHARDING AUDIT ALGORITHMS</span></pre><p id="3127" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">未来版本将支持以下 DistSQL:</p><pre class="lx ly lz ma gt mb lv mc md aw me bi"><span id="45d3" class="jv jw in lv b gy mf mg l mh mi">DROP SHARDING AUDITOR<br/>SHOW UNUSED SHARDING AUDIT ALGORITHMS<br/>CREATE SHARDING TABLE RULE <em class="mj"># including AUDIT_STRATEGY</em></span></pre><p id="b34d" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">这篇文章通过具体的例子介绍了分片审计是如何工作的。相信你已经对这个函数有了基本的了解，无论何时需要或者使用自定义算法都可以使用。</p><p id="6a1f" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">也欢迎大家向社区提交通用算法。如果你有任何想法想要贡献，或者你在你的 ShardingSphere 中遇到任何问题，请随时在<a class="ae lm" href="https://github.com/apache/shardingsphere" rel="noopener ugc nofollow" target="_blank"> Github </a>上发表。</p><h1 id="34dc" class="mm jw in bd jx mn mo mp ka mq mr ms kd mt mu mv kh mw mx my kl mz na nb kp nc bi translated">作者</h1><p id="b9c8" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">黄婷，<a class="ae lm" href="https://www.tencent.com/en-us/" rel="noopener ugc nofollow" target="_blank">腾讯</a>金融科技&amp;<a class="ae lm" href="https://shardingsphere.apache.org/community/en/team/" rel="noopener ugc nofollow" target="_blank">sharding sphere Committer</a>技术工程师。</p><p id="b45f" class="pw-post-body-paragraph kr ks in kt b ku ln kw kx ky lo la lb ke lp ld le ki lq lg lh km lr lj lk ll ig bi translated">他主要负责针对分片和交易功能的代理相关审计的 R&amp;D。</p></div></div>    
</body>
</html>