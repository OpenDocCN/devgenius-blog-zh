<html>
<head>
<title>The Software Testing Spectrum</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">软件测试谱</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/the-software-testing-spectrum-d5268b3513cc?source=collection_archive---------4-----------------------#2021-07-11">https://blog.devgenius.io/the-software-testing-spectrum-d5268b3513cc?source=collection_archive---------4-----------------------#2021-07-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="01d8" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">选择软件测试策略的更好指南</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/f650afd7fc36bf2b9fd7562dd8f45d1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZaCbi3iy9TQJDG7T"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">Jorge Salvador 在<a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="be7f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我反对的软件工程实践之一是<strong class="kv io">软件测试金字塔</strong>。建议遵循“多做隔离测试，少做集成测试”的思路:</p><blockquote class="lp lq lr"><p id="bf66" class="kt ku ls kv b kw kx jo ky kz la jr lb lt ld le lf lu lh li lj lv ll lm ln lo ig bi translated">编写大量小而快速的单元测试。编写一些更粗粒度的测试和很少的高级测试来对你的应用程序进行端到端的测试。<br/> — <a class="ae ks" href="https://martinfowler.com/articles/practical-test-pyramid.html" rel="noopener ugc nofollow" target="_blank">实战测试金字塔</a> (2018)</p><p id="acd1" class="kt ku ls kv b kw kx jo ky kz la jr lb lt ld le lf lu lh li lj lv ll lm ln lo ig bi translated">它(测试金字塔)的要点是，通过GUI运行的低级单元测试应该比高级单元测试<a class="ae ks" href="https://martinfowler.com/bliki/BroadStackTest.html" rel="noopener ugc nofollow" target="_blank">多得多。<br/> — </a><a class="ae ks" href="https://martinfowler.com/bliki/TestPyramid.html" rel="noopener ugc nofollow" target="_blank">测试金字塔</a> (2012年)</p></blockquote><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/3aa49e89d7fc336195a58b34d3495dcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*ackCJ5NnWTUtai_h.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">来自<a class="ae ks" href="https://leaddev.com/agile-other-ways-working/demystifying-software-engineering-test-pyramid" rel="noopener ugc nofollow" target="_blank">leaddev.com</a>的软件工程测试金字塔</figcaption></figure><p id="e02a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这样的建议不应该在任何情况下都盲目适用。和其他事情一样，答案应该是“看情况”。在这篇文章中，我想阐明“视情况而定”的部分。</p><h1 id="7099" class="lx ly in bd lz ma mb mc md me mf mg mh jt mi ju mj jw mk jx ml jz mm ka mn mo bi translated">光谱</h1><p id="589f" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">根据你看到的测试金字塔图，你会发现多种类型的测试:单元、集成、UI、端到端、手工、验收等等。它们很容易混淆，有时还会重叠(例如，UI和端到端测试是一样的吗？).</p><p id="21b6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">我发现更有助于思考测试的是将它们放在一个包含多少组件的光谱中</strong>，其中组件被定义为最小的可测试单元(即功能)。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mu"><img src="../Images/ccf49e14a84f2e6b94cfd42825379519.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vNvCtjcYvsVkgWvqs9356Q.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">光谱</figcaption></figure><p id="e09e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在最左边，测试中只涉及到一个组件。我们只是孤立地测试一个功能。这对应于测试金字塔的底部。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mv"><img src="../Images/829f6135a88151e1164a72b2021e1e1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8JuCaxlTTYaImkn70pmv5g.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">软件测试光谱——最左边</figcaption></figure><p id="be32" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在最右边，被测系统中的所有组件都包含在内。在这里，我们正在对系统进行端到端的测试，即使已经为测试设置了第三方系统。这对应于测试金字塔的顶部。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mv"><img src="../Images/d042560936537f6cd7838230e248fc3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PvFwTNWSFaWh8Kxyi5GVRw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">软件测试光谱——最右边</figcaption></figure><p id="c1fc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在中间，我们测试系统的一个子集，它涉及到不止一个组件。这类测试的一个例子是API驱动的测试。这对应于测试金字塔的中间部分。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mv"><img src="../Images/d59fe69ed96fe4049e7af44c941fe55f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wY9l3tgQWUw-Ffhy1uiAww.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">软件测试谱——中间</figcaption></figure><h1 id="f854" class="lx ly in bd lz ma mb mc md me mf mg mh jt mi ju mj jw mk jx ml jz mm ka mn mo bi translated">尺寸</h1><p id="900b" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">沿着同一轴，我们可以添加更多描述测试特征趋势的维度:</p><ul class=""><li id="120b" class="mw mx in kv b kw kx kz la lc my lg mz lk na lo nb nc nd ne bi translated"><strong class="kv io">信心</strong>:测试的通过如何确保特性“工作”。涉及的组件越多，我们对测试就越有信心，反之亦然。(<a class="ae ks" href="https://gfycat.com/thoseunsungbeetle" rel="noopener ugc nofollow" target="_blank">必修单元vs综合测试笑话</a>)</li><li id="0f25" class="mw mx in kv b kw nf kz ng lc nh lg ni lk nj lo nb nc nd ne bi translated"><strong class="kv io">测试流失</strong>:当现有代码被修改时，现有测试被修改的可能性有多大。涉及的组件越多，就越不需要修改现有的测试。这是因为你将倾向于测试更高层次的流程。实现细节的改变无关紧要。相反，如果您为每个函数编写测试，您可能需要为每个重构修改现有的测试。</li><li id="fbc8" class="mw mx in kv b kw nf kz ng lc nh lg ni lk nj lo nb nc nd ne bi translated"><strong class="kv io">运行成本</strong>:运行测试所花费的成本。这里的成本可能是系统资源、时间，甚至是金钱。当涉及更多组件时，由于测试启动时间更长，需要分配更多CPU/RAM/磁盘，成本往往会更高。</li><li id="0c22" class="mw mx in kv b kw nf kz ng lc nh lg ni lk nj lo nb nc nd ne bi translated"><strong class="kv io">案例变化设置</strong>:设置覆盖所有不同案例的测试有多难。涉及的组件越少，建立各种案例就越容易(例如，使用模拟)。另一方面，涉及的组件越多，各种案例就越难成立。例如，如果测试用例是“当组件A抛出一个错误时应该返回X”，那么可能很难重现组件A抛出一个错误的环境。</li><li id="831f" class="mw mx in kv b kw nf kz ng lc nh lg ni lk nj lo nb nc nd ne bi translated"><strong class="kv io">查明问题</strong>:查明导致测试失败的错误有多难。涉及的组件越多，就越难找到哪个组件(可能不止一个！)都是bug。如果您只测试一个组件，那么您可以很容易地确定bug在哪里。</li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nk"><img src="../Images/3f7a8c0732619d0a14eda23b2e6e8de9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*241Id5soxp7yR5Mde0NNyQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">软件测试范围和维度</figcaption></figure><p id="dce1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">软件测试金字塔建议你应该有更多的测试落在光谱的左边而不是右边。然而，在软件测试谱中，你的测试落在谱中的哪个位置就不那么重要了。</p><p id="c145" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">重要的是找到一种测试策略，使<strong class="kv io">最大化测试可信度，同时最小化测试流失、运行成本、建立各种案例的难度以及查明问题的难度</strong>。</p><h1 id="274f" class="lx ly in bd lz ma mb mc md me mf mg mh jt mi ju mj jw mk jx ml jz mm ka mn mo bi translated">例子</h1><p id="8b7a" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">假设我们有一个电子商务应用程序。从架构上讲，客户机是一个SPA，它通过API与后端对话。在它的众多特性中，让我们挑选两个，并决定哪种测试策略最适合它们。这两个功能是<strong class="kv io">用户注册</strong>和<strong class="kv io">购物车定价</strong>。</p><h2 id="8b60" class="nl ly in bd lz nm nn dn md no np dp mh lc nq nr mj lg ns nt ml lk nu nv mn nw bi translated">用户注册</h2><p id="96fc" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">用户注册功能通常很简单。用户用电子邮件和密码注册。如果电子邮件已被占用，我们拒绝注册。我们还进行输入验证，比如确保密码超过8个字符。否则，我们在系统中注册用户。</p><p id="b0be" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">假设我们编写类级测试，即落在光谱左侧的测试。然后，让我们尝试为每个维度赋值。请注意，没有精确的科学来指定这些值。这取决于你的估计。就我而言，以下是我的估计:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nx"><img src="../Images/acad1a5d1d43cdf75d734e07f596afc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KBRELz3NIe07OIbeuUtXbw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">用户注册测试策略:专门基于类的测试</figcaption></figure><p id="def2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们有中等程度的信心，因为当我们孤立地测试每个类时，我们不会测试所有这些类之间的“管道”是否设置正确。由于类级测试很容易被重构破坏，所以测试变动很大。然而，其他维度是它们最理想的值。</p><p id="68d7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们能做得更好吗？如果我们改为进行API驱动的测试，维度会是什么样子？</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nx"><img src="../Images/a2451024439d9ca3e8a00d132ddda1da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zc304EZaEkuAtIBFzVDh1g.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">用户注册测试策略:专门的API驱动测试</figcaption></figure><p id="6e2e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">信心和测试流失率都明显向理想位置移动，而其他维度只是稍微差一点。例如，运行成本现在大约需要5秒，而不是1.5秒。考虑到特性的简单性，确定问题和设置各种测试用例也并不困难。</p><p id="2cae" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这种情况下，我会跳过类级测试，只采用API驱动的测试。</p><h2 id="c0e0" class="nl ly in bd lz nm nn dn md no np dp mh lc nq nr mj lg ns nt ml lk nu nv mn nw bi translated">购物车定价</h2><p id="a6b5" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">与用户注册相比，购物车定价要复杂得多。许多业务关键案例需要测试。例如，促销计算、优惠券、商品可用性等。就实现而言，单个购物车定价函数可以由多个足够复杂的函数组成。</p><p id="1441" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我们选择与用户注册特性相同的测试方法，维度将如下所示:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ny"><img src="../Images/0089a7239d022a9a35505bd01163f914.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JgvdLuDpbbPm-DDigbB62g.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">Cart定价测试策略:专门的API驱动测试</figcaption></figure><p id="84e6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">虽然置信度和测试流失率维度很好，但是测试用例设置和问题定位维度最差。例如，如果测试失败是因为最终定价低了0.2美元，那么您知道错误在哪里有多容易呢？</p><p id="4c65" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">更好的方法是将较低层次的测试和较高层次的测试结合起来。较低层次的测试测试所有不同的测试用例，因为在这个层次上设置它们更容易。此外，这将大大降低查明问题的难度。相比之下，更高级别的测试只使用很少的测试用例。这增强了该特性工作正常的信心，至少对于我们设置的几个测试用例来说是这样。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ny"><img src="../Images/8388d34ef2e010fb002067441442e224.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gFqkfsVlYR27JTl1kQY0oQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">Cart定价测试策略:基于类的测试和API驱动的测试相结合</figcaption></figure><p id="4b72" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后，<strong class="kv io">这看起来和软件测试金字塔推荐的</strong>一模一样:更多的隔离测试，更少的集成测试。</p><p id="02fe" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然而，我想强调的是，这样的建议并不总是在每种情况下都最适用。这对于这个特性是有意义的，但是对于用户注册特性就不那么有意义了。</p><h1 id="6ac1" class="lx ly in bd lz ma mb mc md me mf mg mh jt mi ju mj jw mk jx ml jz mm ka mn mo bi translated">结论</h1><p id="baed" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">本文介绍了<strong class="kv io">软件测试谱</strong>，作为<strong class="kv io">软件测试金字塔</strong>的替代指南，用于选择正确的软件测试策略。虽然软件测试金字塔建议进行更多的隔离测试和更少的集成测试，但软件测试谱建议根据具体情况选择测试策略，考虑其对各个方面的影响。</p></div></div>    
</body>
</html>