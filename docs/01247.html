<html>
<head>
<title>Customized Calendar in Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Flutter定制日历</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/customized-calendar-in-flutter-8ba20e3caf82?source=collection_archive---------9-----------------------#2020-06-28">https://blog.devgenius.io/customized-calendar-in-flutter-8ba20e3caf82?source=collection_archive---------9-----------------------#2020-06-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2f551dd5b320585cb71f3da247c55448.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DFFdGZCtcwOZ-euW"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@maddibazzocco?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Maddi Bazzocco </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="48a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嘿，你曾经想要一个日期选择器在你的应用程序中，而不是在对话框中吗？您尝试了所有的dart包，但是无法按照您的要求更改它们的用户界面？我也碰到过这些问题！并提出了一个解决方案来构建一个自定义日历，并希望与大家分享:-)</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/0bbe806e9baac6f0b6797a0fde75457f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-elYO7gL2nALaG5m-Q3Xyw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">我用这种定制方法构建的东西</figcaption></figure><p id="fb75" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么，让我们开始我们的旅程吧！首先，创建一个新的flutter项目或者使用一个现有的项目。</p><blockquote class="lg lh li"><p id="2e54" class="kd ke lj kf b kg kh ki kj kk kl km kn lk kp kq kr ll kt ku kv lm kx ky kz la ij bi translated">好的，首先我们来搞清楚需要哪些数据？所以，日历都是关于日期的，对吗？我们必须计算一年中一个月的<strong class="kf ir">日</strong>以及它们发生在哪个工作日。这差不多是我们需要的所有计算。除此之外，我们可能希望在日历的月初和月末分别显示上个月和下个月的未满工作日。</p></blockquote><h2 id="4ce2" class="ln lo iq bd lp lq lr dn ls lt lu dp lv ko lw lx ly ks lz ma mb kw mc md me mf bi translated">在这里，我为每天创建了一个模型类来包含所有这些信息。</h2><pre class="lc ld le lf gt mg mh mi mj aw mk bi"><span id="7a52" class="ln lo iq mh b gy ml mm l mn mo">class Calendar{<br/>  final DateTime date;<br/>  final bool thisMonth;<br/>  final bool prevMonth;<br/>  final bool nextMonth;</span><span id="b4d5" class="ln lo iq mh b gy mp mm l mn mo">Calendar({<br/>    this.date,<br/>    this.thisMonth = false,<br/>    this.prevMonth = false,<br/>    this.nextMonth = false<br/>  });<br/>}</span></pre><h2 id="4214" class="ln lo iq bd lp lq lr dn ls lt lu dp lv ko lw lx ly ks lz ma mb kw mc md me mf bi translated">创建一个类，所有与日历相关的方法都将驻留在这个类中。</h2><pre class="lc ld le lf gt mg mh mi mj aw mk bi"><span id="63c7" class="ln lo iq mh b gy ml mm l mn mo">class CustomCalendar{</span><span id="2e09" class="ln lo iq mh b gy mp mm l mn mo">// number of days in month <br/>  //[JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC]<br/>  final List&lt;int&gt; _monthDays = <br/>    [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];</span><span id="33ce" class="ln lo iq mh b gy mp mm l mn mo">// check for leap year<br/>  bool _isLeapYear(int year){<br/>    if(year % 4 == 0){<br/>      if(year % 100 == 0){<br/>        if(year % 400 == 0) return true;<br/>        return false;<br/>      }<br/>      return true;<br/>    }<br/>    return false;<br/>  }<br/>}</span></pre><p id="78f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个类包含了一个按顺序排列的每个月的日期列表。我已经为二月使用了28天，但是不要担心它会在后期处理。此外，它还包含一个检查一年是否是闰年的方法，这是一个通用的已知检查公式:-)</p><blockquote class="lg lh li"><p id="7a67" class="kd ke lj kf b kg kh ki kj kk kl km kn lk kp kq kr ll kt ku kv lm kx ky kz la ij bi translated">对一些人来说，几周可能从周日开始，对另一些人来说从周一开始。</p></blockquote><p id="034a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">考虑到这两者，我为它们创建了一个枚举。</p><pre class="lc ld le lf gt mg mh mi mj aw mk bi"><span id="27bf" class="ln lo iq mh b gy ml mm l mn mo">enum StartWeekDay {sunday, monday}</span></pre><blockquote class="lg lh li"><p id="0fc2" class="kd ke lj kf b kg kh ki kj kk kl km kn lk kp kq kr ll kt ku kv lm kx ky kz la ij bi translated">现在复杂的计算开始了！复杂与否你可以在最后决定:-)</p></blockquote><p id="d234" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是一个方法，它将计算一年中一个月的所有日子在工作日中的出现时间，将它们按顺序排列以显示在该月的日历中，并返回顺序列表。</p><pre class="lc ld le lf gt mg mh mi mj aw mk bi"><span id="5d98" class="ln lo iq mh b gy ml mm l mn mo"><em class="lj">/// get the month calendar<br/>/// month is between from 1-12 (1 for January and 12 for December)<br/></em><strong class="mh ir">List&lt;Calendar&gt; getMonthCalendar(int month, int year, <br/>  {StartWeekDay startWeekDay = StartWeekDay.sunday}){</strong></span><span id="6605" class="ln lo iq mh b gy mp mm l mn mo"><em class="lj">  // validate</em><br/>  <strong class="mh ir">if(year == null || month == null || month &lt; 1 || month &gt; 12)<br/>    throw ArgumentError('Invalid year or month');</strong></span><span id="a232" class="ln lo iq mh b gy mp mm l mn mo"><strong class="mh ir">  List&lt;Calendar&gt; calendar = List&lt;Calendar&gt;();</strong></span><span id="d1b4" class="ln lo iq mh b gy mp mm l mn mo"><em class="lj">  // get no. of days in the month<br/>  // month-1 because _monthDays starts from index 0 <br/>  // and month starts from 1</em><br/>  <strong class="mh ir">int totalDays = _monthDays[month - 1];</strong></span><span id="e962" class="ln lo iq mh b gy mp mm l mn mo">  // if this is a leap year and the month is february, <br/>  // increment the total days by 1<br/>  <strong class="mh ir">if(_isLeapYear(year) &amp;&amp; month == DateTime.february) totalDays++;</strong></span><span id="ea47" class="ln lo iq mh b gy mp mm l mn mo">  // get days for this month<br/>  <strong class="mh ir">for(int i=0; i&lt;totalDays; i++){<br/>    calendar.add(<br/>      Calendar(</strong><br/>        // i+1 because day starts from 1 in DateTime class<br/>        <strong class="mh ir">date: DateTime(year, month, i+1),<br/>        thisMonth: true,<br/>      ),<br/>    );<br/>  }<br/>}</strong></span></pre><p id="1c8a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个类中，有一个名为calendar的列表，它将按顺序返回一个月中的所有日子，它的类型是Calendar，这是我们作为第一步创建的一个模型类。</p><blockquote class="lg lh li"><p id="baea" class="kd ke lj kf b kg kh ki kj kk kl km kn lk kp kq kr ll kt ku kv lm kx ky kz la ij bi translated">嗯，就这样吧！我们把所有的日子都按顺序排好。现在我们完成了，对吗？是的，但是每个月不会从星期一或星期天开始，到星期天或星期六结束。<strong class="kf ir">绝不！</strong>我们需要分别用前一个月和下一个月的天数来填充开始和结束时那些缺失的点。</p></blockquote><p id="f72f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是用前一个月的天数来填充开始时缺失的点的计算。<em class="lj">将这几行代码放在</em><strong class="kf ir"><em class="lj">getMonthCalendar</em></strong><em class="lj">方法结束之前。</em></p><pre class="lc ld le lf gt mg mh mi mj aw mk bi"><span id="eb01" class="ln lo iq mh b gy ml mm l mn mo">// used for previous and next month's calendar days<br/><strong class="mh ir">int otherYear;<br/>int otherMonth;<br/>int leftDays;</strong></span><span id="d383" class="ln lo iq mh b gy mp mm l mn mo">// fill the unfilled starting weekdays of this month <br/>// with the previous month days<br/><strong class="mh ir">if(<br/> (startWeekDay == StartWeekDay.sunday &amp;&amp; <br/>   calendar.first.date.weekday != DateTime.sunday) ||<br/> (startWeekDay == StartWeekDay.monday &amp;&amp;  <br/>   calendar.first.date.weekday != DateTime.monday)<br/> ){</strong><br/>   // if this month is january, <br/>   // then previous month would be decemeber of previous year<br/>   <strong class="mh ir">if(month == DateTime.january){<br/>     otherMonth = DateTime.december;<br/>     otherYear = year-1;</strong><br/>   <strong class="mh ir">}<br/>   else{<br/>    otherMonth = month - 1;<br/>    otherYear = year;<br/>   }</strong><br/>   // month-1 because _monthDays starts from index 0 <br/>   // and month starts from 1<br/>   <strong class="mh ir">totalDays = _monthDays[otherMonth - 1];</strong><br/>   <strong class="mh ir">if(_isLeapYear(otherYear) &amp;&amp; otherMonth == DateTime.february)<br/>      totalDays++;</strong></span><span id="6d35" class="ln lo iq mh b gy mp mm l mn mo"><strong class="mh ir">   leftDays = totalDays - calendar.first.date.weekday + <br/>     ((startWeekDay == StartWeekDay.sunday) ? 0 : 1);</strong><br/>      <br/>   <strong class="mh ir">for(int i=totalDays; i&gt;leftDays; i--){</strong><br/>     // add days to the start of the list to maintain the sequence<strong class="mh ir"><br/>     calendar.insert(0,<br/>       Calendar(<br/>         date: DateTime(otherYear, otherMonth, i),<br/>         prevMonth: true,<br/>        ),<br/>     );<br/>   }</strong><br/><strong class="mh ir">}</strong></span></pre><p id="83ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">太多的条件和计算了。但是我尽了最大努力给代码添加注释，使其易于理解。你可能想知道<strong class="kf ir">剩余天数</strong>是如何计算的，但老实说，我用笔复制了一份，得到了正确的模式，现在对此没有解释。但我向你保证，这很简单，每个人都可以很容易地找出这种模式<em class="lj">(甚至比它更好)</em>、<strong class="kf ir">只要试一试！</strong></p><p id="9731" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在转到计算的另一部分，也是最后一部分，用下个月的天数来填充末尾缺少的点。<em class="lj">将这几行代码放在</em><strong class="kf ir"><em class="lj">getMonthCalendar</em></strong><em class="lj">方法结束之前。</em></p><pre class="lc ld le lf gt mg mh mi mj aw mk bi"><span id="d4f5" class="ln lo iq mh b gy ml mm l mn mo">// fill the unfilled ending weekdays of this month <br/>// with the next month days<br/><strong class="mh ir">if(<br/>  (startWeekDay == StartWeekDay.sunday &amp;&amp; <br/>    calendar.last.date.weekday != DateTime.saturday) ||<br/>  (startWeekDay == StartWeekDay.monday &amp;&amp; <br/>    calendar.last.date.weekday != DateTime.sunday)<br/>){</strong><br/>  // if this month is december, <br/>  // then next month would be january of next year<br/>  <strong class="mh ir">if(month == DateTime.december){<br/>    otherMonth = DateTime.january;<br/>    otherYear = year+1;<br/>  }<br/>  else{<br/>    otherMonth = month+1;<br/>    otherYear = year;<br/>  }</strong><br/>  // month-1 because _monthDays starts from index 0 <br/>  // and month starts from 1<br/>  <strong class="mh ir">totalDays = _monthDays[otherMonth-1];<br/>  if(_isLeapYear(otherYear) &amp;&amp; otherMonth == DateTime.february)  <br/>    totalDays++;</strong></span><span id="8c04" class="ln lo iq mh b gy mp mm l mn mo"><strong class="mh ir">  leftDays = 7 - calendar.last.date.weekday - <br/>    ((startWeekDay == StartWeekDay.sunday) ? 1 : 0);</strong><br/>  <strong class="mh ir">if(leftDays == -1) leftDays = 6;</strong></span><span id="ad0d" class="ln lo iq mh b gy mp mm l mn mo"><strong class="mh ir">  for(int i=0; i&lt;leftDays; i++){<br/>    calendar.add(<br/>      Calendar(<br/>        date: DateTime(otherYear, otherMonth, i+1),<br/>        nextMonth: true,<br/>      ),<br/>    );<br/>  }<br/>}</strong></span></pre><p id="25cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在把我们的日程表还回来，否则我们所有的努力都将付之东流。<em class="lj">将这几行代码放在</em><strong class="kf ir"><em class="lj">getMonthCalendar</em></strong><em class="lj">方法结束之前。</em></p><pre class="lc ld le lf gt mg mh mi mj aw mk bi"><span id="ac77" class="ln lo iq mh b gy ml mm l mn mo">return calendar;</span></pre><blockquote class="lg lh li"><p id="b833" class="kd ke lj kf b kg kh ki kj kk kl km kn lk kp kq kr ll kt ku kv lm kx ky kz la ij bi translated">那是我们所有的计算部分！现在让我们做一些用户界面的东西:-)</p></blockquote><p id="d1cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">设置变量并做一些初始化工作。</p><pre class="lc ld le lf gt mg mh mi mj aw mk bi"><span id="e69d" class="ln lo iq mh b gy ml mm l mn mo">class MyApp extends StatefulWidget {<br/>  @override<br/>  _MyAppState createState() =&gt; _MyAppState();<br/>}</span><span id="489d" class="ln lo iq mh b gy mp mm l mn mo">class _MyAppState extends State&lt;MyApp&gt; {</span><span id="8010" class="ln lo iq mh b gy mp mm l mn mo">  DateTime _currentDateTime;<br/>  DateTime _selectedDateTime;<br/>  List&lt;Calendar&gt; _sequentialDates;<br/>  int midYear;<br/>  final List&lt;String&gt; _weekDays = <br/>    ['MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT', 'SUN'];<br/>  final List&lt;String&gt; _monthNames = <br/>    ['January', 'February', 'March', 'April', 'May', 'June', 'July',  <br/>     'August', 'September', 'October', 'November', 'December'];</span><span id="3412" class="ln lo iq mh b gy mp mm l mn mo">  @override<br/>  void initState() {<br/>    super.initState();<br/>    final date = DateTime.now();<br/>    _currentDateTime = DateTime(date.year, date.month);<br/>    _selectedDateTime = DateTime(date.year, date.month, date.day);<br/>    WidgetsBinding.instance.addPostFrameCallback((timeStamp) {<br/>     setState(() =&gt; _getCalendar());<br/>    });<br/>  }</span><span id="a27a" class="ln lo iq mh b gy mp mm l mn mo"><strong class="mh ir">  // get calendar for current month</strong><br/>  void _getCalendar(){<br/>    _sequentialDates = <br/>      CustomCalendar().getMonthCalendar(_currentDateTime.month,   <br/>        _currentDateTime.year, startWeekDay: StartWeekDay.monday);<br/>  }</span><span id="952f" class="ln lo iq mh b gy mp mm l mn mo">  @verride<br/>  Widget build(BuildContext context) {<br/>    return Scaffold(<br/>      body: Center(<br/>        child: Container(<br/>          margin: EdgeInsets.all(16),<br/>          padding: EdgeInsets.all(16),<br/>          height: MediaQuery.of(context).size.height * 0.6,<br/>          decoration: BoxDecoration(<br/>            color: Colors.black,<br/>            borderRadius: BorderRadius.circular(20),<br/>          ),<br/>          child: _datesView() <strong class="mh ir">// to be added in next step</strong><br/>        ),<br/>      ),<br/>    );<br/>  }<br/>}</span></pre><p id="0787" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">添加日历正文以显示当月的日期，并切换按钮以移动到下个月和上个月。</p><pre class="lc ld le lf gt mg mh mi mj aw mk bi"><span id="c755" class="ln lo iq mh b gy ml mm l mn mo"><strong class="mh ir">// dates view</strong><br/>Widget _datesView(){<br/>  return Column(<br/>    mainAxisSize: MainAxisSize.min,<br/>      children: &lt;Widget&gt;[<br/>        <strong class="mh ir">// header</strong><br/>        Row(<br/>          children: &lt;Widget&gt;[<br/>            <strong class="mh ir">// prev month button</strong><br/>            _toggleBtn(false),<br/>            <strong class="mh ir">// month and year</strong><br/>            Expanded(<br/>              child: InkWell(<br/>                onTap: (){<br/>                  setState((){<br/>                    <strong class="mh ir">// explained in later stages</strong><br/>                    _currentView = CalendarViews.months<br/>                  });<br/>                },<br/>                child: Center(<br/>                  child: Text(<br/>                    '${_monthNames[_currentDateTime.month-1]} <br/>                     ${_currentDateTime.year}',<br/>                     style: TextStyle(<br/>                       color: Colors.white, <br/>                       fontSize: 18, <br/>                       fontWeight: FontWeight.w700<br/>                     ),<br/>                   ),<br/>                 ),<br/>               ),<br/>             ),<br/>             <strong class="mh ir">// next month button</strong><br/>             _toggleBtn(true),<br/>           ],<br/>         ),<br/>         SizedBox(height: 20,),<br/>         Divider(color: Colors.white,),<br/>         SizedBox(height: 20,),<br/>         Flexible(child: _calendarBody()),<br/>      ],<br/>   );<br/>}</span><span id="5970" class="ln lo iq mh b gy mp mm l mn mo"><strong class="mh ir">// next / prev month buttons</strong><br/>Widget _toggleBtn(bool next) {<br/>  return InkWell(<br/>    <strong class="mh ir">// explained in later stages</strong><br/>    onTap: (){<br/>      if(_currentView == CalendarViews.dates){<br/>        setState(() =&gt; (next) ? _getNextMonth() : _getPrevMonth());<br/>      }<br/>      else if(_currentView == CalendarViews.year){<br/>        if(next){<br/>          midYear = (midYear == null) <br/>            ? _currentDateTime.year + 9 : midYear + 9;<br/>        }<br/>        else{<br/>          midYear = (midYear == null) <br/>            ? _currentDateTime.year - 9 : midYear - 9;<br/>        }<br/>        setState(() {});<br/>      }<br/>    },<br/>    child: Container(<br/>      width: 50,<br/>      height: 50,<br/>      decoration: BoxDecoration(<br/>      borderRadius: BorderRadius.circular(25),<br/>      border: Border.all(color: Colors.white),<br/>      boxShadow: [<br/>        BoxShadow(<br/>          color: Colors.white.withOpacity(0.5),<br/>          offset: Offset(3, 3),<br/>          blurRadius: 3,<br/>          spreadRadius: 0,<br/>        ),<br/>      ],<br/>      gradient: LinearGradient(<br/>        colors: [Colors.black, Colors.black.withOpacity(0.1)],<br/>        stops: [0.5, 1],<br/>        begin: Alignment.bottomRight,<br/>        end: Alignment.topLeft,<br/>      )<br/>    ),<br/>    child: Icon((next) <br/>      ? Icons.arrow_forward_ios : Icons.arrow_back_ios, <br/>      color: Colors.white,),<br/>    ),<br/>  );<br/>}</span><span id="2044" class="ln lo iq mh b gy mp mm l mn mo"><strong class="mh ir">// calendar body</strong><br/>Widget _calendarBody() {<br/>  if(_sequentialDates == null) return Container();<br/>  return GridView.builder(<br/>    shrinkWrap: true,<br/>    padding: EdgeInsets.zero,<br/>    itemCount: _sequentialDates.length + 7,<br/>    gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(<br/>      mainAxisSpacing: 20,<br/>      crossAxisCount: 7,<br/>      crossAxisSpacing: 20,<br/>    ), <br/>    itemBuilder: (context, index){<br/>      if(index &lt; 7) return _weekDayTitle(index);<br/>      if(_sequentialDates[index - 7].date == _selectedDateTime) <br/>        return _selector(_sequentialDates[index - 7]);<br/>      return _calendarDates(_sequentialDates[index - 7]);<br/>    },<br/>  );<br/>}</span><span id="f9f2" class="ln lo iq mh b gy mp mm l mn mo"><strong class="mh ir">// calendar header</strong><br/>Widget _weekDayTitle(int index){<br/>  return Text(_weekDays[index], <br/>    style: TextStyle(color: Colors.yellow, fontSize: 12),);<br/>}</span><span id="e1c8" class="ln lo iq mh b gy mp mm l mn mo"><strong class="mh ir">// calendar element</strong><br/>Widget _calendarDates(Calendar calendarDate){<br/>  return InkWell(<br/>    onTap: (){<br/>      if(_selectedDateTime != calendarDate.date){<br/>        if(calendarDate.nextMonth){<br/>          _getNextMonth();<br/>        }<br/>        else if(calendarDate.prevMonth){<br/>          _getPrevMonth();<br/>        }<br/>        setState(() =&gt; _selectedDateTime = calendarDate.date);<br/>     } <br/>   },<br/>   child: Center(<br/>   child: Text(<br/>     '${calendarDate.date.day}', <br/>     style: TextStyle(<br/>       color: (calendarDate.thisMonth) <br/>         ? (calendarDate.date.weekday == DateTime.sunday) <br/>         ? Colors.yellow : Colors.white <br/>         : (calendarDate.date.weekday == DateTime.sunday) <br/>         ? Colors.yellow.withOpacity(0.5) <br/>         : Colors.white.withOpacity(0.5),<br/>       ),<br/>     )<br/>   ),<br/> );<br/>}</span><span id="a649" class="ln lo iq mh b gy mp mm l mn mo"><strong class="mh ir">// date selector</strong><br/>Widget _selector(Calendar calendarDate) {<br/>  return Container(<br/>    width: 30,<br/>    height: 30,<br/>    decoration: BoxDecoration(<br/>      color: Colors.white,<br/>      borderRadius: BorderRadius.circular(50),<br/>      border: Border.all(color: Colors.white, width: 4),<br/>      gradient: LinearGradient(<br/>        colors: [Colors.black.withOpacity(0.1), Colors.white],<br/>        stops: [0.1, 1],<br/>        begin: Alignment.topLeft,<br/>        end: Alignment.bottomRight,<br/>      ),<br/>    ),<br/>    child: Container(<br/>      decoration: BoxDecoration(<br/>        color: Colors.white.withOpacity(0.9),<br/>        borderRadius: BorderRadius.circular(50),<br/>      ),<br/>      child: Center(<br/>        child: Text(<br/>          '${calendarDate.date.day}',<br/>          style: TextStyle(<br/>            color: Colors.black,<br/>            fontWeight: FontWeight.w700<br/>          ),<br/>        ),<br/>      ),<br/>    ),<br/>  );<br/>}</span></pre><p id="14b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">添加在导航到下个月或上个月时更改当前日期时间的方法。</p><pre class="lc ld le lf gt mg mh mi mj aw mk bi"><span id="1b02" class="ln lo iq mh b gy ml mm l mn mo"><strong class="mh ir">// get next month</strong> <strong class="mh ir">calendar</strong><br/>void _getNextMonth(){<br/>  if(_currentDateTime.month == 12) {<br/>      _currentDateTime = DateTime(_currentDateTime.year+1, 1);<br/>  }<br/>  else{<br/>      _currentDateTime = DateTime(_currentDateTime.year, <br/>           _currentDateTime.month+1);<br/>  }<br/>  _getCalendar();<br/>}</span><span id="c185" class="ln lo iq mh b gy mp mm l mn mo"><strong class="mh ir">// get previous month calendar</strong><br/>void _getPrevMonth(){<br/>  if(_currentDateTime.month == 1){<br/>      _currentDateTime = DateTime(_currentDateTime.year-1, 12);<br/>  }<br/>  else{<br/>      _currentDateTime = DateTime(_currentDateTime.year,  <br/>          _currentDateTime.month-1);<br/>  }<br/>  _getCalendar();<br/>}</span></pre><blockquote class="lg lh li"><p id="a7ce" class="kd ke lj kf b kg kh ki kj kk kl km kn lk kp kq kr ll kt ku kv lm kx ky kz la ij bi translated">如果我们想跳过几个月或几年，使用按钮浏览下个月或上个月可能会很累。</p></blockquote><p id="2c3b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要选择月份和年份的2个视图。现在，我们的日历将有3个视图日期视图，月视图，年视图。为同一创建枚举。</p><pre class="lc ld le lf gt mg mh mi mj aw mk bi"><span id="83f3" class="ln lo iq mh b gy ml mm l mn mo">enum CalendarViews{ dates, months, year }</span></pre><p id="f606" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们需要存储要显示的当前视图，每当用户选择不同的视图时，它都会发生变化。因此，在<strong class="kf ir"> _MyAppState类</strong>中创建一个类变量，默认视图为日期视图。</p><pre class="lc ld le lf gt mg mh mi mj aw mk bi"><span id="de15" class="ln lo iq mh b gy ml mm l mn mo">CalendarViews _currentView = CalendarViews.dates;</span></pre><p id="fdcb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将通过单击日期视图的标题从日期视图切换到月份视图。上面已经配置了日期视图标题的onTap功能。</p><pre class="lc ld le lf gt mg mh mi mj aw mk bi"><span id="16e4" class="ln lo iq mh b gy ml mm l mn mo">onTap: () =&gt; setState(() =&gt; _currentView = CalendarViews.months),</span></pre><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/06a8ad1eefa178ba981bae2dadf9ccd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rY17STuG6N6KiQygP2TaHQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">月视图</figcaption></figure><p id="54cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建一个小部件来显示月份列表。用户可以从这些月份中进行选择。</p><pre class="lc ld le lf gt mg mh mi mj aw mk bi"><span id="59bf" class="ln lo iq mh b gy ml mm l mn mo"><strong class="mh ir">// show months list</strong><br/>Widget _showMonthsList(){<br/>  return Column(<br/>    children: &lt;Widget&gt;[<br/>      InkWell(<br/>        onTap: (){<br/>          setState((){<br/>            <strong class="mh ir">//switch to years views</strong><br/>            _currentView = CalendarViews.year;<br/>          });<br/>        },<br/>        child: Padding(<br/>          padding: const EdgeInsets.all(20.0),<br/>          child: Text('${_currentDateTime.year}', <br/>            style: TextStyle(fontSize: 18, <br/>              fontWeight: FontWeight.w700, color: Colors.white),<br/>          ),<br/>        ),<br/>      ),<br/>      Divider(color: Colors.white,),<br/>      Expanded(<br/>        child: ListView.builder(<br/>          padding: EdgeInsets.zero,<br/>          itemCount: _monthNames.length,<br/>          itemBuilder: (context, index) =&gt; ListTile(<br/>          onTap: (){<br/>            <strong class="mh ir">// change month of currentDateTime </strong><br/>            _currentDateTime = <br/>              DateTime(_currentDateTime.year, index+1);<br/>            _getCalendar();<br/>            <strong class="mh ir">// switch back to dates view</strong><br/>            setState(() =&gt; _currentView = CalendarViews.dates);<br/>          },<br/>          title: Center(<br/>            child: Text(<br/>              _monthNames[index], <br/>              style: TextStyle(fontSize: 18, <br/>                color: (index == _currentDateTime.month-1) <br/>                  ? Colors.yellow : Colors.white),<br/>            ),<br/>          ),<br/>        ),<br/>      ),<br/>    ),<br/>   ],<br/> );<br/>}</span></pre><p id="dc60" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用户可以通过点击月份视图的标题来浏览年份。上面已经配置了onTap月视图页眉功能。</p><p id="f15e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建年视图小部件。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/36dd642f2ab769ee98581c025eb377d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j7BNVwckc-6wRcV2AbRRYQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">年视图</figcaption></figure><pre class="lc ld le lf gt mg mh mi mj aw mk bi"><span id="1cec" class="ln lo iq mh b gy ml mm l mn mo"><strong class="mh ir">// years list views</strong><br/>Widget _yearsView(int midYear){<br/>  return Column(<br/>    children: &lt;Widget&gt;[<br/>      Row(<br/>        children: &lt;Widget&gt;[<br/>          _toggleBtn(false),<br/>          Spacer(),<br/>          _toggleBtn(true),<br/>         ],<br/>       ),<br/>       Expanded(<br/>         child: GridView.builder(<br/>           shrinkWrap: true,<br/>           itemCount: 9,<br/>           physics: NeverScrollableScrollPhysics(),<br/>           gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(<br/>             crossAxisCount: 3,<br/>           ), <br/>           itemBuilder: (context, index){<br/>             int thisYear;<br/>             if(index &lt; 4){<br/>               thisYear = midYear - (4 - index);<br/>             }<br/>             else if(index &gt; 4){<br/>               thisYear = midYear + (index - 4);<br/>             }<br/>             else{<br/>               thisYear = midYear;<br/>             }<br/>             return ListTile(<br/>               onTap: (){<br/>                 <strong class="mh ir">// change year of currentDateTime</strong><br/>                 _currentDateTime = <br/>                   DateTime(thisYear, _currentDateTime.month);<br/>                 _getCalendar();<br/>                 <strong class="mh ir">// switch back to months view </strong><br/>                 setState(() =&gt; <br/>                   _currentView = CalendarViews.months);<br/>               },<br/>               title: Text(<br/>                 '$thisYear', <br/>                 style: TextStyle(fontSize: 18, <br/>                   color: (thisYear == _currentDateTime.year) <br/>                     ? Colors.yellow : Colors.white),<br/>               ),<br/>             );<br/>           }<br/>         ),<br/>       ),<br/>     ],<br/>   );<br/>}</span></pre><blockquote class="lg lh li"><p id="4434" class="kd ke lj kf b kg kh ki kj kk kl km kn lk kp kq kr ll kt ku kv lm kx ky kz la ij bi translated">切换按钮有两组功能。</p><p id="42b4" class="kd ke lj kf b kg kh ki kj kk kl km kn lk kp kq kr ll kt ku kv lm kx ky kz la ij bi translated">I .在日期视图中切换到下个月或上个月</p><p id="dade" class="kd ke lj kf b kg kh ki kj kk kl km kn lk kp kq kr ll kt ku kv lm kx ky kz la ij bi translated">二。在年份视图中显示上一组或下一组年份。</p><p id="7e37" class="kd ke lj kf b kg kh ki kj kk kl km kn lk kp kq kr ll kt ku kv lm kx ky kz la ij bi translated">上述切换按钮的onTap功能中已经配置了这些功能。</p></blockquote><p id="5ab4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们必须根据当前视图的值来设置显示视图的条件。这将在我们简单地将<strong class="kf ir"> _datesView </strong>作为构建方法中容器的子容器的地方完成。</p><blockquote class="lg lh li"><p id="08dd" class="kd ke lj kf b kg kh ki kj kk kl km kn lk kp kq kr ll kt ku kv lm kx ky kz la ij bi translated">更新了构建方法。</p></blockquote><pre class="lc ld le lf gt mg mh mi mj aw mk bi"><span id="ab70" class="ln lo iq mh b gy ml mm l mn mo">@override<br/>Widget build(BuildContext context) {<br/>  return Scaffold(<br/>    body: Center(<br/>      child: Container(<br/>        margin: EdgeInsets.all(16),<br/>        padding: EdgeInsets.all(16),<br/>        height: MediaQuery.of(context).size.height * 0.6,<br/>        decoration: BoxDecoration(<br/>        color: Colors.black,<br/>        borderRadius: BorderRadius.circular(20),<br/>      ),<br/>      child: (_currentView == CalendarViews.dates) ? _datesView() <br/>        : (_currentView == CalendarViews.months) ? _showMonthsList() <br/>        : _yearsView(midYear ?? _currentDateTime.year)<br/>      ),<br/>    ),<br/>  );<br/>}</span></pre><p id="992c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">仅此而已！现在你有了一个定制的日历，可以根据你的需求任意定制:-)</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><p id="479e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从这个<a class="ae kc" href="https://github.com/Hitesh822/flutter_custom_calendar" rel="noopener ugc nofollow" target="_blank">链接</a>获得完整的源代码。</p></div></div>    
</body>
</html>