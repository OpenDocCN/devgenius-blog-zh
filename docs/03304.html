<html>
<head>
<title>Best of Modern JavaScript — Super Calls and Private Variables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代JavaScript的精华——超级调用和私有变量</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/best-of-modern-javascript-super-calls-and-private-variables-c7eacd8fc806?source=collection_archive---------3-----------------------#2020-10-21">https://blog.devgenius.io/best-of-modern-javascript-super-calls-and-private-variables-c7eacd8fc806?source=collection_archive---------3-----------------------#2020-10-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/10ead5811689cb9a0b0d9ed347d650fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IWLkOGSxdnZPP6cW"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@caiohenriquesilva?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卡伊奥·席尔瓦</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="a83e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自2015年以来，JavaScript有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看如何用JavaScript定义类。</p><h1 id="f710" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">超级构造函数调用</h1><p id="d36f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在调用任何其他东西之前，我们必须调用<code class="fe me mf mg mh b">super</code>。</p><p id="44c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们不能写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b6d9" class="mq lc iq mh b gy mr ms l mt mu">class Foo {}</span><span id="3a8b" class="mq lc iq mh b gy mv ms l mt mu">class Bar extends Foo {<br/>  constructor(foo) {<br/>    this.foo = foo;<br/>    super();<br/>    this.bar = bar;<br/>  }<br/>}</span></pre><p id="2b7b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一行必须是<code class="fe me mf mg mh b">super</code>调用。</p><p id="0aa7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="fd13" class="mq lc iq mh b gy mr ms l mt mu">class Foo {}</span><span id="8ed2" class="mq lc iq mh b gy mv ms l mt mu">class Bar extends Foo {<br/>  constructor(foo) {    <br/>    super();<br/>    this.foo = foo;<br/>    this.bar = bar;<br/>  }<br/>}</span></pre><p id="ead4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">删除<code class="fe me mf mg mh b">super</code>调用也会给我们一个错误。所以我们不能写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3cbc" class="mq lc iq mh b gy mr ms l mt mu">class Foo {}</span><span id="bad5" class="mq lc iq mh b gy mv ms l mt mu">class Bar extends Foo {<br/>  constructor() {}<br/>}</span></pre><h1 id="98cd" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">重写构造函数的结果</h1><p id="b0d8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过在<code class="fe me mf mg mh b">constructor</code>中返回我们想要的东西来覆盖构造函数的结果。</p><p id="6cfa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c186" class="mq lc iq mh b gy mr ms l mt mu">class Foo {<br/>  constructor() {<br/>    return {};<br/>  }<br/>}</span></pre><p id="5014" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后当我们记录时:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7bcb" class="mq lc iq mh b gy mr ms l mt mu">console.log(new Foo() instanceof Foo);</span></pre><p id="f53d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们让<code class="fe me mf mg mh b">false</code>回来了。</p><p id="a206" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不管<code class="fe me mf mg mh b">this</code>是否被初始化，因为我们正在返回一个对象，而不是在我们的构造函数中隐式返回<code class="fe me mf mg mh b">this</code>。</p><p id="b68f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们像示例中那样覆盖结果，我们不必在子构造函数中调用<code class="fe me mf mg mh b">super</code>。</p><h1 id="2b9b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">类的默认构造函数</h1><p id="b451" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们不放任何东西进去，我们不需要指定一个空的构造函数。</p><p id="f4d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f18a" class="mq lc iq mh b gy mr ms l mt mu">constructor()<!-- --> <!-- -->{}</span></pre><p id="bc8c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以移除它。</p><p id="2e31" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于派生类，我们不需要仅仅为了调用超级构造函数而添加一个构造函数。</p><p id="b1dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们不必写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e430" class="mq lc iq mh b gy mr ms l mt mu">constructor(...args) {<br/>  super(...args);<br/>}</span></pre><p id="fe54" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的代码中。</p><h1 id="5685" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">子类化内置构造函数</h1><p id="d0f8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以创建内置构造函数的子类。</p><p id="ced9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9851" class="mq lc iq mh b gy mr ms l mt mu">class SomeError extends Error {}<br/>throw new SomeError('error');</span></pre><p id="fd61" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用关键字<code class="fe me mf mg mh b">extends</code>创建了一个<code class="fe me mf mg mh b">Error</code>的子类。</p><p id="5a15" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以像任何其他的<code class="fe me mf mg mh b">Error</code>实例一样抛出它。</p><p id="696a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以创建<code class="fe me mf mg mh b">Array</code>构造函数的子类。</p><p id="a51b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3bd3" class="mq lc iq mh b gy mr ms l mt mu">class Stack extends Array {<br/>  get first() {<br/>    return this[0];<br/>  }<br/>}</span></pre><p id="1d52" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以创建一个新的<code class="fe me mf mg mh b">Stack</code>实例，并使用可用的<code class="fe me mf mg mh b">Array</code>属性:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3f08" class="mq lc iq mh b gy mr ms l mt mu">class Stack extends Array {<br/>  get first() {<br/>    return this[0];<br/>  }<br/>}</span><span id="68cb" class="mq lc iq mh b gy mv ms l mt mu">const stack = new Stack();<br/>stack.push('foo');<br/>stack.push('bar');<br/>console.log(stack.first);<br/>console.log(stack.length);</span></pre><p id="ddb3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe me mf mg mh b">pusg</code>将条目推送到我们的<code class="fe me mf mg mh b">Stack</code>实例。</p><p id="1daf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到<code class="fe me mf mg mh b">first</code>和<code class="fe me mf mg mh b">length</code>属性。</p><p id="340e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">first</code>是我们定义的getter。</p><p id="8a3e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而<code class="fe me mf mg mh b">length</code>是继承自<code class="fe me mf mg mh b">Array</code>。</p><h1 id="2548" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">类的私有数据</h1><p id="0a13" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">JavaScript类没有私有成员。</p><p id="4a07" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想要私人数据，那么我们必须把它们藏在别的地方。</p><p id="3667" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者我们可以创建带有特殊命名方案的公共成员来表明它们是私有的。</p><p id="77de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在属性前加一个下划线来表示它们是私有的。</p><p id="282a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">比如，我们可以写；</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="edbc" class="mq lc iq mh b gy mr ms l mt mu">class Foo {<br/>  constructor() {<br/>    this._count = 0;<br/>  }<br/>}</span></pre><p id="879b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们添加了<code class="fe me mf mg mh b">this._count</code>实例属性来表明<code class="fe me mf mg mh b">count</code>是私有的。</p><p id="51a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以用弱地图和符号存储私有属性。</p><p id="a7ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2507" class="mq lc iq mh b gy mr ms l mt mu">const _count = new WeakMap();</span><span id="799e" class="mq lc iq mh b gy mv ms l mt mu">class Counter {<br/>  constructor(count) {<br/>    _count.set(this, count);<br/>  }</span><span id="275d" class="mq lc iq mh b gy mv ms l mt mu">  increment() {<br/>    let count = _count.get(this);<br/>    count++;<br/>    _count.set(this, count);<br/>  }<br/>}</span></pre><p id="a90f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建了两个弱贴图，并使用<code class="fe me mf mg mh b">this</code>作为这两个弱贴图的键。</p><p id="3346" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些值被设置为我们传递给构造函数的值。</p><p id="88e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以用弱贴图的<code class="fe me mf mg mh b">get</code>方法得到值。</p><p id="bd70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并用<code class="fe me mf mg mh b">set</code>方法设置该值。</p><p id="b990" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">弱映射很有用，因为我们可以用<code class="fe me mf mg mh b">this</code>访问值，防止里面的项目被其他方式访问。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/13d5ea2c73c08495afea80ee47570ad3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ADq2F8cVTT3bWt6e"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@dtopkin1?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">戴恩·托普金</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="340b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="eee4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当我们调用<code class="fe me mf mg mh b">super</code>时，有几件事我们必须考虑。</p><p id="f501" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，没有简单的方法来保持变量私有。</p></div></div>    
</body>
</html>