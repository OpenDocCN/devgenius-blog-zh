<html>
<head>
<title>Udacity C++ Developer nanodegree (Foundation-lesson4-partC : Maps , OOP)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Udacity C++开发人员 nanodegree(基础-第 4 课-partC : Maps，OOP)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/udacity-c-developer-nanodegree-foundation-lesson4-partc-maps-oop-e6d0bca4c74d?source=collection_archive---------8-----------------------#2022-10-01">https://blog.devgenius.io/udacity-c-developer-nanodegree-foundation-lesson4-partc-maps-oop-e6d0bca4c74d?source=collection_archive---------8-----------------------#2022-10-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/a0a954ab923c949f868f35e09c2fb9ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cGeyciHN6ZZn30pI"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">照片由<a class="ae jz" href="https://unsplash.com/@maximalfocus?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">最大聚焦</a>在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">未飞溅</a>上拍摄</figcaption></figure><p id="a285" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">课程大纲</strong></p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div class="gh gi ky"><img src="../Images/8a61a011afeef009b16e8e5358a339a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*a_lMfR9jIhaY6lVi4LTY-A.png"/></div></figure><p id="2517" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">地图</strong></p><p id="a7d3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">到目前为止，在本课程中，我们已经看到了容器数据结构，如<code class="fe ld le lf lg b">vector</code>和<code class="fe ld le lf lg b">array</code>。容器数据结构非常适合存储有序数据，类对于将相关数据和函数组合在一起非常有用，但是这两种数据结构都不适合存储相关数据。</p><p id="593d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">映射(或者是<a class="ae jz" href="https://en.wikipedia.org/wiki/Hash_table" rel="noopener ugc nofollow" target="_blank">哈希表</a>、哈希映射或字典)是一种数据结构，它使用<em class="lh">键/值</em>对来存储数据，并提供高效的数据查找和插入。<code class="fe ld le lf lg b">unordered_map</code>是映射的 C++标准库实现(也存在其他实现)。</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div class="gh gi li"><img src="../Images/2468f0a32cd6a01a1a37700470a12628.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*SUxjRQ_yZOeGEUNUT_8n7w.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">使用地图示例</figcaption></figure><p id="4ca9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">类和 OOP </strong></p><p id="6575" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你正在学习这门课程，你可能以前在另一种语言中使用过面向对象编程(OOP)。如果你使用 OOP 已经有一段时间了，OOP 是一种编码风格，它将相关数据(对象<em class="lh">属性</em>和函数(对象<em class="lh">方法</em>)收集在一起，形成一个单一的数据结构，称为<em class="lh">对象</em>。这允许属性和方法的集合在您的程序中重复使用，而没有代码重复。</p><p id="619f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在 C++中，组成对象的属性和方法在代码<em class="lh">类</em>中指定，程序中的每个对象都是该类的一个<em class="lh">实例</em>。</p><p id="b2db" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">考虑一个具有属性的“Car”类；距离、颜色、数量和功能；incrementDistance()，printCarData()。</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div class="gh gi lj"><img src="../Images/4f0ed73ddd276a49e61e4765b26dc15f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*0xNm7s68fRpfo-CqCosUNQ.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">汽车类别定义</figcaption></figure><p id="372c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们计划构建一个更大的程序，此时最好将类定义和函数声明放在一个单独的文件中。正如我们之前讨论头文件时一样，将类定义放在单独的头文件中有助于组织代码，并防止在定义类之前试图使用类对象时出现问题。</p><p id="2288" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">改进建议:</strong></p><ol class=""><li id="f4da" class="lk ll in kc b kd ke kh ki kl lm kp ln kt lo kx lp lq lr ls bi translated">当类方法在类之外定义时，必须使用<em class="lh">范围解析操作符</em> <code class="fe ld le lf lg b">::</code>来指示该方法属于哪个类。例如，在<code class="fe ld le lf lg b">PrintCarData</code>方法的定义中你看到:</li></ol><ul class=""><li id="98a0" class="lk ll in kc b kd ke kh ki kl lm kp ln kt lo kx lt lq lr ls bi translated"><code class="fe ld le lf lg b">void Car::PrintCarData()</code></li></ul><p id="8359" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果有两个类的方法同名，这可以防止任何编译器问题。</p><p id="ea41" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2.我们可以改变构造函数初始化变量的方式。代替前面的构造函数:</p><ul class=""><li id="7af8" class="lk ll in kc b kd ke kh ki kl lm kp ln kt lo kx lt lq lr ls bi translated"><code class="fe ld le lf lg b">Car(string c, int n) { color = c; number = n; }</code></li></ul><p id="6345" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">构造函数现在使用一个<a class="ae jz" href="https://en.cppreference.com/w/cpp/language/initializer_list" rel="noopener ugc nofollow" target="_blank"> <em class="lh">初始化列表</em> </a>:</p><ul class=""><li id="e528" class="lk ll in kc b kd ke kh ki kl lm kp ln kt lo kx lt lq lr ls bi translated"><code class="fe ld le lf lg b">Car(string c, int n) : color(c), number(n) {}</code></li></ul><p id="c535" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里，类成员在构造函数体(现在是空的)之前被初始化。初始化列表是在构造函数中初始化许多类属性的快速方法。此外，编译器处理在列表中初始化的属性与在构造函数体中初始化的属性略有不同。由于超出本课程范围的原因，如果一个类属性是一个引用，它必须使用初始化列表进行初始化。</p><p id="95ab" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">3.不需要在类外可见的变量被设置为<code class="fe ld le lf lg b">private</code>。这意味着它们不能在类外被访问，这<a class="ae jz" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rc-private" rel="noopener ugc nofollow" target="_blank">防止它们被意外更改</a>。</p><p id="2bfe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">4.箭头操作符<code class="fe ld le lf lg b">-&gt;</code>可用于同时</p><ul class=""><li id="1d13" class="lk ll in kc b kd ke kh ki kl lm kp ln kt lo kx lt lq lr ls bi translated">解引用一个指向对象的指针</li><li id="51b7" class="lk ll in kc b kd lu kh lv kl lw kp lx kt ly kx lt lq lr ls bi translated">访问属性或方法。</li></ul><p id="93b9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，在下面的代码中，<code class="fe ld le lf lg b">cp</code>是一个指向汽车对象的指针，下面两个是等价的:</p><pre class="kz la lb lc gt lz lg ma mb aw mc bi"><span id="e5e0" class="md me in lg b gy mf mg l mh mi">// Simultaneously dereference the pointer and <br/>// access IncrementDistance().<br/>cp-&gt;IncrementDistance();</span><span id="9406" class="md me in lg b gy mj mg l mh mi">// Dereference the pointer using *, then <br/>// access IncrementDistance() with traditional <br/>// dot notation.<br/>(*cp).IncrementDistance();</span></pre><p id="f201" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">这个指针</strong></p><p id="0abf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当使用类时，能够引用当前的类实例或对象通常是有帮助的。例如，给定前面课程中的下面的<code class="fe ld le lf lg b">Car</code>类，<code class="fe ld le lf lg b">IncrementDistance()</code>方法隐式引用当前<code class="fe ld le lf lg b">Car</code>实例的<code class="fe ld le lf lg b">distance</code>属性:</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mk"><img src="../Images/1866dab74befc316cb0432a7ef227bb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_2q1dob0grcc1vAnMswqkA.png"/></div></div></figure><p id="5c46" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">继承</strong></p><p id="46d7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一个类可以通过类继承使用另一个类的方法和属性。例如，如果您想创建一个带有泛型<code class="fe ld le lf lg b">Car</code>类中没有的附加属性或方法的<code class="fe ld le lf lg b">Sedan</code>类，您可以使用冒号创建一个从<code class="fe ld le lf lg b">Car</code>继承而来的<code class="fe ld le lf lg b">Sedan</code>类:</p><pre class="kz la lb lc gt lz lg ma mb aw mc bi"><span id="220b" class="md me in lg b gy mf mg l mh mi">class Sedan : public Car {<br/>    // Sedan class declarations/definitions here.<br/>};</span></pre><p id="408c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通过这样做，每个<code class="fe ld le lf lg b">Sedan</code>类实例将可以访问<code class="fe ld le lf lg b">Car</code>的任何<em class="lh">公共</em>方法和属性。在上面的代码中，它们是<code class="fe ld le lf lg b">IncrementDistance()</code>和<code class="fe ld le lf lg b">PrintCarData()</code>。你也可以给<code class="fe ld le lf lg b">Sedan</code>类添加额外的特性。在上面的例子中，<code class="fe ld le lf lg b">Car</code>通常被称为<em class="lh">父类</em>，而<code class="fe ld le lf lg b">Sedan</code>被称为<em class="lh">子类</em>或<em class="lh">派生的</em>类。</p></div></div>    
</body>
</html>