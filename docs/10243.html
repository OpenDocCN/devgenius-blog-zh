<html>
<head>
<title>All You Need to Know about Debugging Kubernetes Cronjob</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于调试 Kubernetes Cronjob，您需要知道的全部内容</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/all-you-need-to-know-about-debugging-kubernetes-cronjob-61989a998513?source=collection_archive---------2-----------------------#2022-10-18">https://blog.devgenius.io/all-you-need-to-know-about-debugging-kubernetes-cronjob-61989a998513?source=collection_archive---------2-----------------------#2022-10-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d9e3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Kubernetes cron job/部署调试中使用的演练工具、配置和知识</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ce8ffa8c34748f8ecd572693963013c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_PbQ3DsQ937yyvm8"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">来自 Unsplash，<a class="ae kv" href="https://unsplash.com/photos/wf4nPeExY_k" rel="noopener ugc nofollow" target="_blank"> @marcuslofvenberg </a></figcaption></figure><p id="313a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着 Kubernetes 成为部署应用程序的事实上的标准，使用 CLI 进行部署和调试无疑已经成为开发人员的必备技能，尽管它过去只是 DevOps 的一项技能。</p><p id="0afa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我今年早些时候通过的<a class="ae kv" href="https://medium.com/codex/ready-to-win-the-cka-certificate-4f77960c5878?source=your_stories_page-------------------------------------" rel="noopener">认证 Kubernetes 管理员</a> (CKA)中的故障排除任务已经提示了还有哪些技能需要学习。</p><blockquote class="ls lt lu"><p id="e095" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">cka 拥有履行 Kubernetes 管理员职责的技能、知识和能力。</p></blockquote><p id="1f87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，调试在生产中要复杂得多，涉及各种工具和主题。在本文中，我们将经历一次成功的 cronjob 部署和调试，涉及 cronjob 测试、Git、环境变量、RBAC、Pod 资源配置、日志记录等。，看看我们能从这种做法中学到什么。</p><h1 id="4401" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">创建 Cronjob</h1><p id="8368" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">这是我们创建的一个 cronjob，用来替代一个 Gitops 工具的部分功能，这个工具有一个短期内无法恢复的问题。cronjob 包含一个 bash 脚本，需要它来完成以下任务。</p><ul class=""><li id="1bf4" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated">每 10-15 分钟跑一次</li><li id="d223" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">在 Git repo 中下载 YAML 文件</li><li id="7f98" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">用<code class="fe nk nl nm nn b">kustomize</code>构建下载的文件</li><li id="1b41" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">使用内部工具改变和验证 YAML</li><li id="83f1" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated"><code class="fe nk nl nm nn b">kubectl apply</code>文件到集群</li></ul><p id="10a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个版本已经完成:<code class="fe nk nl nm nn b">job</code>基于内部公司<code class="fe nk nl nm nn b">cloud-sdk</code>创建一个包映像，然后执行一些 bash 命令的容器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><h1 id="fec1" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">应用 Cronjob</h1><p id="d995" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><code class="fe nk nl nm nn b">kubectl apply</code>把文件送到集群。cronjob 配置为每 15 分钟运行一次，即每小时的第 0 分钟、第 15 分钟、第 30 分钟和第 45 分钟。如果我们在<code class="fe nk nl nm nn b">kubectl apply</code>时错过了这些时间点，我们最多需要等待 15 分钟让它自动执行。</p><p id="3b37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">cronjob 表达式配置可以在这里测试<a class="ae kv" href="https://crontab.guru/#0/15_*_*_*_*" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="3af8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每次 cronjob 执行都会创建一个相应的<code class="fe nk nl nm nn b">job</code>，然后它会启动一个 pod 执行。</p><p id="be1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是时候看看我们应用的 cronjob 的结果了。</p><p id="08b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">所有 pod 执行失败！</strong></p><p id="82fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行<code class="fe nk nl nm nn b">kubectl get events -n test</code>进行调试！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/2328356a37f2d8d73bd0a2ebc1256c75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QCzkmzy_UB_xIh1rvfyEbQ.png"/></div></div></figure><p id="0f94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们得到一个典型的 Kubernetes pod 启动错误，<code class="fe nk nl nm nn b"><strong class="ky ir">ImagePullBackOff</strong></code>、<strong class="ky ir">、</strong>两个最常见的 pod 启动错误之一，<code class="fe nk nl nm nn b">ImagePullBackOff</code>和<code class="fe nk nl nm nn b">ErrImagePull</code>，它们是由以下原因触发的</p><ul class=""><li id="0c6d" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated">错误的图像地址</li><li id="34c4" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">错误的标签或没有默认标签，导致不存在链接的图像</li><li id="bb91" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">不可访问的图像或不允许访问者</li></ul><p id="0bb4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于 pod 无法启动并且没有可用的日志，我们可以运行<code class="fe nk nl nm nn b">kubectl describe</code>或<code class="fe nk nl nm nn b">kubectl events</code>来获取更多信息。它返回<code class="fe nk nl nm nn b">does not exist or no pull access</code>，但是 URL 被确认是正确的。因此，我们只需要找到执行 cronjob 创建的服务帐户，并授予它权限。(关于 Google 容器注册表映像的权限，请参考文档<a class="ae kv" href="https://cloud.google.com/container-registry/docs/access-control" rel="noopener ugc nofollow" target="_blank">访问控制和 IAM </a>)。</p><p id="6be0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们可以了解到，GKE 集群有一个默认的 IAM 服务帐户<code class="fe nk nl nm nn b"><strong class="ky ir">cluster@&lt;project-id&gt;.iam.gserviceaccount.com</strong></code> <strong class="ky ir">，它是在创建集群</strong>时同时创建的，因此，一旦我们的 IAM 服务帐户从映像所有者那里获得了<code class="fe nk nl nm nn b">storage.get</code>权限，我们就可以让 cronjob 成功运行。</p><p id="fa08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着权限的到位和 cronjob 的运行，pod 将在☕️.咖啡上完成</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/0c4fc74c00373e58294519afdeac352d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6XA79adqf0K_7bPs"/></div></div></figure><h1 id="d243" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">容器中的日志记录和调试</h1><p id="3c80" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">pod 启动后执行是否正确？</p><p id="40eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于 bash 脚本，我们可以直接检查日志进行验证，包括 pod 日志和作业日志。</p><pre class="kg kh ki kj gt ns nn nt nu aw nv bi"><span id="155e" class="nw ma iq nn b gy nx ny l nz oa">kubectl log cj-27714930 -n test</span></pre><p id="5ecf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后显示几十行错误日志。让我们看看他们的一部分。</p><pre class="kg kh ki kj gt ns nn nt nu aw nv bi"><span id="4959" class="nw ma iq nn b gy nx ny l nz oa">gzip: stdin: not in gzip format<br/>tar: Child returned status 1<br/>tar: Error is not recoverable: exiting now<br/>Error from server (Forbidden): namespaces is forbidden: User "system:serviceaccount:test:default" cannot list resource "namespaces" in API group "" at the cluster scope<br/>error: no objects passed to apply</span></pre><p id="3066" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有点麻烦。我该如何处理这些错误呢？</p><p id="d489" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，通过直接删除当前 cronjob 或使用以下命令挂起它来挂起它。</p><pre class="kg kh ki kj gt ns nn nt nu aw nv bi"><span id="ac4f" class="nw ma iq nn b gy nx ny l nz oa">kubectl patch cronjobs cj -p '{"spec" : {"suspend" : true }}' -n test</span></pre><p id="d74f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">GIT 下载成功了吗？<strong class="ky ir">踏入容器</strong>。有两种方法可以做到。</p><ul class=""><li id="2369" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated">使用<code class="fe nk nl nm nn b">kubectl exec -it</code>启动 bash 并访问 pod 容器。</li><li id="b089" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">使用<code class="fe nk nl nm nn b">kubectl debug</code>创建一个临时容器来调试。</li></ul><pre class="kg kh ki kj gt ns nn nt nu aw nv bi"><span id="9df8" class="nw ma iq nn b gy nx ny l nz oa">kubectl debug --image=busybox --target=cj -ntest -it cj-27714960-gfvqc</span><span id="eae8" class="nw ma iq nn b gy ob ny l nz oa">Defaulting debug container name to debugger-fps7r.</span><span id="645b" class="nw ma iq nn b gy ob ny l nz oa">error: ephemeral containers are disabled for this cluster (error from server: "the server could not find the requested resource").</span></pre><p id="5fbe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，我当前的集群不支持在 Kubernetes 1.22 中发布的<a class="ae kv" href="https://kubernetes.io/docs/concepts/workloads/pods/ephemeral-containers/" rel="noopener ugc nofollow" target="_blank">短暂容器</a>，直到 1.25 才变得稳定。所以在尝试之前，记得用<code class="fe nk nl nm nn b">kubectl version</code>检查您当前的集群和 kubectl 版本。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/4cdbb592e35811f051831c48f1bf50d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Oq3PgqkeYceuYsX5"/></div></div></figure><p id="c5f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们进行唯一的选择之前，问问我们自己是否有办法避免每隔 15 分钟就测试 cronjob？</p><p id="9f60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">答案是肯定的。<strong class="ky ir">我们可以基于 cronjob 创建一个</strong> <code class="fe nk nl nm nn b"><strong class="ky ir">job</strong></code> <strong class="ky ir">，让一个 pod 立即启动运行程序</strong>。我们可以通过在脚本中添加<code class="fe nk nl nm nn b">sleep 1h</code>来延长容器的存在，避免调试因容器操作的停止而中断。</p><pre class="kg kh ki kj gt ns nn nt nu aw nv bi"><span id="38b5" class="nw ma iq nn b gy nx ny l nz oa"># create test job<br/>k create job test-job --from=cronjob/cj -n test</span><span id="80d5" class="nw ma iq nn b gy ob ny l nz oa"># step into the test container<br/>k exec -it job/test-job  -ntest -- /bin/bash</span></pre><p id="0685" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们可以访问容器并运行 bash 命令。跑<code class="fe nk nl nm nn b">kubectl exec -it job/test-job -ntest — /bin/bash</code></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/d413ef9d03d910898fe31d44a6a6bf08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RVDabtOhTtKVHLSl"/></div></div></figure><p id="3356" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以发现下载的 git 包<code class="fe nk nl nm nn b">master.tar.gz</code>已经在那里了，但是直接运行<code class="fe nk nl nm nn b">tar</code>命令就会出现上面的错误。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/31eecff2e213ea136375c8a587994453.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qAdgwb_jKbGoQVHe"/></div></div></figure><p id="93af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">退出容器，在本地重试测试，发现下载的包大小不同。仔细检查我的命令，我们可以看到有一个<code class="fe nk nl nm nn b">GITHUB_AUTH_TOKEN</code>变量，它是 GitHub 身份验证的 Github 开发者令牌。</p><p id="0801" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在容器中，<code class="fe nk nl nm nn b">echo $GITHUB_AUTH_TOKEN</code>发现不存在变量，这是 pod 中常见的错误:<strong class="ky ir">环境变量没有映射到容器。</strong></p><p id="962c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有三种方法可以解决这个问题。</p><ul class=""><li id="8b95" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated">将明文直接粘贴到 bash 脚本中。</li><li id="af06" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">创建一个<code class="fe nk nl nm nn b">ConfigMap</code>来保存令牌，并将其作为环境变量映射到容器。</li><li id="a949" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">创建一个<code class="fe nk nl nm nn b">Secret</code>来保存令牌，并将其作为环境变量映射到容器。</li></ul><p id="f37a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">显然，第一种和第二种方法是不安全的，而第三种方法是最好的，尽管仍然需要限制当前名称空间中对<code class="fe nk nl nm nn b">Secret </code>的访问权限，以确保只有少数管理员可以访问它。</p><p id="ea87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建了<code class="fe nk nl nm nn b">secret</code>之后，我们现在只需要向 cronjob 添加以下环境变量引用。</p><pre class="kg kh ki kj gt ns nn nt nu aw nv bi"><span id="3b4a" class="nw ma iq nn b gy nx ny l nz oa">env:<br/>  - name: GITHUB_AUTH_TOKEN<br/>valueFrom:<br/>secretKeyRef:<br/>name: githubtoken<br/>key: GITHUB_AUTH_TOKEN<br/>optional: false</span></pre><p id="ee73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">重新应用 cronjob 并测试。解压成功！</p><h1 id="dea7" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">没有权限</h1><p id="d439" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">不幸的是，另一个错误发生了。</p><pre class="kg kh ki kj gt ns nn nt nu aw nv bi"><span id="ac5b" class="nw ma iq nn b gy nx ny l nz oa">Error from server (Forbidden): namespaces is forbidden: User "system:serviceaccount:test:default" cannot list resource "namespaces" in API group "" at the cluster scope</span></pre><p id="2cd4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nk nl nm nn b">ServiceAccount</code>在运行时没有足够的权限，这是另一个典型的 Kubernetes pod 错误。</p><p id="e3c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在配置 cronjob 容器时，没有设置<code class="fe nk nl nm nn b">serviceAccountName</code>字段，将使用默认的 SA 来运行这个 pod。并且该 SA 没有授予任何额外的 RBAC 权限，因此在执行<code class="fe nk nl nm nn b">kubectl apply namespace &lt;namespace&gt;</code>时会报告一个错误。</p><p id="3e1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，解决方案很简单:<strong class="ky ir">授予 SA 一个适当的角色</strong>。</p><pre class="kg kh ki kj gt ns nn nt nu aw nv bi"><span id="c494" class="nw ma iq nn b gy nx ny l nz oa">apiVersion: rbac.authorization.k8s.io/v1<br/>kind: RoleBinding<br/>metadata:<br/>name: test-default<br/>namespace: test<br/>roleRef:<br/>apiGroup: rbac.authorization.k8s.io<br/>kind: ClusterRole<br/>name: admin<br/>subjects:<br/>  - kind: ServiceAccount<br/>name: default<br/>namespace: test</span></pre><p id="1dc6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，我们可以通过给予 SA“非常”大的权限来实现，比如这里的<code class="fe nk nl nm nn b">admin</code>。但是我们应该始终采取最佳实践，这是 3 个步骤。</p><ul class=""><li id="9729" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated">为运行当前作业定义独占服务协议</li><li id="aa16" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">定义一个只包含当前作业所需权限的角色或<code class="fe nk nl nm nn b">clusterrole</code></li><li id="54b5" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">绑定服务协议和角色</li></ul><p id="211b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们配置一个更好的 RBAC。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="b975" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">应用<code class="fe nk nl nm nn b">rbac.yaml</code>，更新 cronjob 中的<code class="fe nk nl nm nn b">serviceAccountName</code>。</p><h1 id="00c8" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">查看作业日志</h1><p id="7f2e" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">现在，我们可以通过不断打印日志来监视整个作业的执行。</p><p id="fb1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nk nl nm nn b">kubectl log</code>在工作上比荚更有效率。如果我们通过 pod 查看日志，您需要事先获得带有<code class="fe nk nl nm nn b">kubect get pods</code>的名称，因为 pod 名称每次都会改变。而<code class="fe nk nl nm nn b">kubectl logs job/test-job</code>可以让我们通过命令历史节省精力。</p><pre class="kg kh ki kj gt ns nn nt nu aw nv bi"><span id="408f" class="nw ma iq nn b gy nx ny l nz oa">kubectl logs job/test-job -n test</span></pre><p id="47d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nk nl nm nn b">kubectl log</code>命令还提供了各种标志来帮助我们读取日志。</p><ul class=""><li id="c1b8" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated"><code class="fe nk nl nm nn b">-f/–follow</code>实时观察日志的标志。</li><li id="62ec" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated"><code class="fe nk nl nm nn b">--tail=10</code>仅查看最近 10 条日志，关注最新日志。</li><li id="70e7" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated"><code class="fe nk nl nm nn b">--container</code>如果有多个容器，让我们只关注我们需要的容器。</li></ul><p id="862a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在调试中使用的最有效的日志命令是</p><pre class="kg kh ki kj gt ns nn nt nu aw nv bi"><span id="b872" class="nw ma iq nn b gy nx ny l nz oa">kubectl logs job/test-job -ntest -f –tail=10</span></pre><h1 id="eb46" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">OOMKilled</h1><p id="5711" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">几分钟后，pod 突然出现故障，现在处于<code class="fe nk nl nm nn b">OOMKilled</code>状态。</p><p id="6b2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们找出这个经典 pod 问题的原因和解决方案。</p><p id="5800" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果没有设置所需的资源使用，新创建的 pod 将被随机分配给某个节点。如果该节点没有执行所需的内存，就会出现<code class="fe nk nl nm nn b">OOMKilled</code>。运行<code class="fe nk nl nm nn b">kubectl get node -owide -n test</code>找出节点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/170ad541c69748d1b121441f2b8669e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*z8J442wpGNN4c7eH"/></div></div></figure><p id="dc73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以通过添加下面的请求配置，将 pod 分配给具有足够资源的节点，从而轻松解决这个问题。</p><pre class="kg kh ki kj gt ns nn nt nu aw nv bi"><span id="6ded" class="nw ma iq nn b gy nx ny l nz oa">resources:<br/>  requests:<br/>    memory: 1Gi<br/>    cpu: 500m</span></pre><p id="7c05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">重新涂抹，观察一段时间。现在是庆祝成功的时候了！</p><h1 id="6a07" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="d707" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Kubernetes 调试是令人疲惫的，但可以从这些常见问题中总结出很多，如 ImagePullOff、GKE 权限、GIT 包解压缩、RBAC 和 OOMKilled。随着不断的学习，我们最终可以写出自己的“手册”，这将使我们在未来的 Kubernetes 调试中更加自信。</p><p id="1cad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！</p><h1 id="9ebf" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">参考</h1><p id="a3c1" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><a class="ae kv" href="https://kubernetes.io/docs/tasks/debug/debug-application/debug-running-pod/#ephemeral-container" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/tasks/debug/debug-application/debug-running-pod/# periodic-container</a></p><p id="55d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://blog.alexellis.io/troubleshooting-on-kubernetes/" rel="noopener ugc nofollow" target="_blank">如何对 Kubernetes (alexellis.io)上的应用程序进行故障排除</a></p></div></div>    
</body>
</html>