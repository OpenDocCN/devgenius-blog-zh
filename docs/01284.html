<html>
<head>
<title>Microservices— Direct model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务—直接模式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/microservices-api-tutorial-80d7011c56f1?source=collection_archive---------11-----------------------#2020-06-29">https://blog.devgenius.io/microservices-api-tutorial-80d7011c56f1?source=collection_archive---------11-----------------------#2020-06-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d5125407ec73d2a7e7be1cc12c66765c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eAD9Ud-El8ExF0jT"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">由<a class="ae jz" href="https://unsplash.com/@marvelous?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Marvin Meyer </a>在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="1122" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最近热门的新架构模型。它非常适合 dockerization、Kubernetess 和无服务器基础设施。太棒了。如果实施得当的话。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="ca61" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">什么是微服务？</h1><p id="4b85" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">微服务软件架构模式全是潜水逻辑；业务逻辑、应用程序逻辑分成更小的、可重用的部分。</p><p id="3ca5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于每个服务都可以是独立的应用程序，因此 ops 可以更轻松、更精确地进行扩展。组件 A 需要那么多实例，那么多 CPU 和 RAM。然而，组件 B 使用较少，它只需要基本资源就能正常工作。</p><p id="7fa4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">安全性是另一个方面:并不是所有的微服务都需要对公众可见，更重要的是，在将微服务 API 连接到前端时，还有几种模式。</p><p id="c9e7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">“微”并不意味着服务本身必须有 X 行代码，或者很小。我们也不应该把我们的代码分成太多的服务，这就像干法则，但是要考虑一些未来的自我。</p><p id="6c19" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，让我们说，我们有整体电子商务商店。它是一个整体，有一些模块/逻辑分离类，如:<code class="fe mi mj mk ml b">user management</code>、<code class="fe mi mj mk ml b">permission account control list (acl)</code>和一些其他业务逻辑，如<code class="fe mi mj mk ml b">calculate income</code>、<code class="fe mi mj mk ml b">shopping cart</code>或<code class="fe mi mj mk ml b">search</code>。</p><p id="7cc9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为什么在一个地方有这么多？嗯，你可以说，开发肯定更容易，但是团队成员有限。同样，出于可伸缩的目的，每个模块可以有自己的团队，或者团队 A 可以处理 X、Y、Z 模块，而团队 B 处理 V、U、M</p><h2 id="b75b" class="mm lg in bd lh mn mo dn ll mp mq dp lp kl mr ms lt kp mt mu lx kt mv mw mb mx bi translated">好吧，这是代码分离，但是数据呢？</h2><p id="2458" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">由于编码逻辑可以分离，数据库结构也可以分离。如果需要数据库，最好使用<code class="fe mi mj mk ml b">Database per Service</code>！</p><p id="f9f5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">经常发生的情况是，一些模块只是做计算，从其他模块获取数据并返回结果，所以总的来说，它不需要数据库。</p><p id="6531" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另一个好处是，我们可以有几种数据库类型，最适合特定的服务。例如，对于服务 A，它可以是一个<code class="fe mi mj mk ml b">Non-SQL</code>，而另一个是<code class="fe mi mj mk ml b">PostgreSQL</code>。</p><h1 id="2b81" class="lf lg in bd lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly nc ma mb mc bi translated">给我看看密码，伙计</h1><p id="999f" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">哈哈，当然。这是一个简单的组件示例，它创建用户，更新用户的权限，并动态地协同工作。<br/>这意味着可以动态删除或添加每个服务的实例，以便应用程序正常工作。</p><h2 id="8ee8" class="mm lg in bd lh mn mo dn ll mp mq dp lp kl mr ms lt kp mt mu lx kt mv mw mb mx bi translated">服务发现</h2><p id="8383" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">为了实现这一点，我们需要使用<code class="fe mi mj mk ml b">Service Discovery</code>模式的服务。在云中，通常是<code class="fe mi mj mk ml b">Load-Balancer</code>可以自己发现实例(在 AWS 中，是<code class="fe mi mj mk ml b">Target Group</code>可以连接到<code class="fe mi mj mk ml b">ALB </code>并发现新创建的<code class="fe mi mj mk ml b">ECS Tasks</code>)。</p><p id="5a5b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于我们的示例，假设我们没有将它存储在云中，并且希望全部手工完成，因此 API 的模式应该是:</p><figure class="ne nf ng nh gt jo gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/8dd696806caba3fc6175165c5b111075.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*AwCHInsYg1Jm84KwXq_GMg.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">微服务服务发现</figcaption></figure><p id="37b1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如您所见，没有必要让<code class="fe mi mj mk ml b">Service Discovery</code>从互联网可达，因为它只是与内部资源对话。</p><p id="61d8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这个<code class="fe mi mj mk ml b">direct pattern</code>中，所有微服务 API 都可以从互联网和前端看到。后者还决定向哪个微服务发出整合数据的请求。</p><p id="1c90" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们回到<code class="fe mi mj mk ml b">Service Discovery</code>。它是如何工作的？<br/>我想到了这样的东西:</p><figure class="ne nf ng nh gt jo gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/888f947e0f5738534b6e5b4461de5d4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*t-UhLf0svG2LW5_8ktUe7g.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">服务发现图</figcaption></figure><p id="68f8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，它有内存注册表变量。它是一个列表，将<code class="fe mi mj mk ml b">{URL, PORT}</code>存储在<code class="fe mi mj mk ml b">service name as a KEY</code>下。</p><p id="d322" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要注册新变量只需运行<code class="fe mi mj mk ml b">POST /register {name, port, host}</code>端点。</p><p id="61ed" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是如何防止<code class="fe mi mj mk ml b">unactive</code>服务不显示在<code class="fe mi mj mk ml b">registry</code>中呢？<br/>一种方法是在发送<code class="fe mi mj mk ml b">SIGTERM</code>时创建<code class="fe mi mj mk ml b">/unregister</code>端点。<br/>其他方法通过<code class="fe mi mj mk ml b">healthcheck</code>；这就是为什么除了 Flask 之外我们还有第二个线程。它每 15 秒检查一次服务中的<code class="fe mi mj mk ml b">/health</code>端点是否在工作。如果它不能连接到它，则从集合中移除服务。</p><p id="aef8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">简单的实现:</p><figure class="ne nf ng nh gt jo"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">服务发现 python 实现</figcaption></figure><p id="4602" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如你所见，简单的豌豆柠檬汁。它正在工作，但为了向您展示如何获取，让我们实现另一个微服务。</p><h2 id="344f" class="mm lg in bd lh mn mo dn ll mp mq dp lp kl mr ms lt kp mt mu lx kt mv mw mb mx bi translated">2.用户服务程序</h2><p id="afc6" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">我实现的另一个服务是用户服务。它基本上是将内容保存到文件存储的 CRUD，但是它必须连接到服务发现，以便其他服务知道它的存在。</p><figure class="ne nf ng nh gt jo gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/8ebac9b4b633504654ca752707d4c6d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*DoLsFSqHUuCiNHysKWDoeg.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">用户服务图</figcaption></figure><p id="905a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">和一个代码:</p><figure class="ne nf ng nh gt jo"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">用户服务实现</figcaption></figure><p id="f16d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以没有什么奇特的，简单的，基本的 CRUD:更新文件，通过请求删除文件:</p><pre class="ne nf ng nh gt nm ml nn no aw np bi"><span id="8d9a" class="mm lg in ml b gy nq nr l ns nt"># CREATE<br/>curl -d '{"age":"25","name":"George","permission_level":"1"}' -X POST  -H "Content-Type: application/json" <a class="ae jz" href="http://127.0.0.1:3000/user/george" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:3000/user/george</a></span><span id="ac7f" class="mm lg in ml b gy nu nr l ns nt"># RETRIEVE<br/>curl -X GET <a class="ae jz" href="http://127.0.0.1:3000/user/george" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:3000/user/george</a></span><span id="ccdd" class="mm lg in ml b gy nu nr l ns nt"># UPDATE<br/>curl -d '{"age":"26"}' -X PUT  -H "Content-Type: application/json" <a class="ae jz" href="http://127.0.0.1:3000/user/george" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:3000/user/george</a></span><span id="420e" class="mm lg in ml b gy nu nr l ns nt"># DELETE<br/>curl -X DELETE <a class="ae jz" href="http://127.0.0.1:3000/user/george" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:3000/user/george</a></span></pre><h2 id="85c1" class="mm lg in bd lh mn mo dn ll mp mq dp lp kl mr ms lt kp mt mu lx kt mv mw mb mx bi translated">测试服务和发现</h2><p id="9e68" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">首先，我们应该看看微服务是否通过我们的服务得到了正确的发现。</p><figure class="ne nf ng nh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nv"><img src="../Images/f471198204a07737ce79f1082a5c7536.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a0FCGC6YlHEp-Gdc2uVrxQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">具有服务发现的微服务</figcaption></figure><p id="9673" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">到目前为止还不错；<code class="fe mi mj mk ml b">service_discovery</code>得到了调用的<code class="fe mi mj mk ml b">/register</code>端点，<code class="fe mi mj mk ml b">user_service</code>得到了<code class="fe mi mj mk ml b">/health</code>端点。让我们看看<code class="fe mi mj mk ml b">service_discovery</code>看到了什么:</p><figure class="ne nf ng nh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nw"><img src="../Images/5e2b29c0fd8dc700a20a64d48d79c0d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aptfBuFvSFCQacPnhO4o1A.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">服务发现注册表检索</figcaption></figure><p id="b373" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">厉害！让我们测试 CRUD 请求:</p><div class="ne nf ng nh gt ab cb"><figure class="nx jo ny nz oa ob oc paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><img src="../Images/4da66d4c4d4778c3bf90d91b29a60d18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*ZdNYj4MAeharrwZzs6WyhQ.png"/></div></figure><figure class="nx jo od nz oa ob oc paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><img src="../Images/6e05c1fb62632460bd910a6c05b7aa33.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/format:webp/1*XhCNM8nbj8-PInf5tdN4Gw.png"/></div></figure></div><p id="b0e2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如您所见，CRUD 请求正在工作，除了来自<code class="fe mi mj mk ml b">discovery_service</code>的几个<code class="fe mi mj mk ml b">/health</code>端点请求之外，它还正确地获得了其他查询，这些查询创建并更新了用户 George。</p><p id="3895" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在让我们添加另一个微服务，权限。</p><h2 id="0106" class="mm lg in bd lh mn mo dn ll mp mq dp lp kl mr ms lt kp mt mu lx kt mv mw mb mx bi translated">许可服务</h2><p id="148f" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">这个有点复杂。它不仅连接到服务发现，还连接到<code class="fe mi mj mk ml b">user_service</code>。</p><figure class="ne nf ng nh gt jo gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/046ebd6841ccab71ed0e1573388545a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*IK6Ku7ILAc36MYsM5IMIMA.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">权限微服务示例</figcaption></figure><p id="76b5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它只有一个端点(如果您愿意，可以自由扩展)用于更改用户权限级别和一些数据验证，同样是非常简单的服务:</p><figure class="ne nf ng nh gt jo"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="83da" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看看它是否连接到服务发现。剧透:的确如此:)</p><figure class="ne nf ng nh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi of"><img src="../Images/e25383c389c0269a7071816c70d12165.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HkqaPmhozY7Eo8nMv7mfUg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">上层:用户服务，中层:发现服务，下层:许可服务</figcaption></figure><p id="0a7b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们的<code class="fe mi mj mk ml b">discovery_service</code>长这样:</p><pre class="ne nf ng nh gt nm ml nn no aw np bi"><span id="af67" class="mm lg in ml b gy nq nr l ns nt">&gt;&gt;&gt; curl localhost:2999/registry<br/>&lt;&lt;&lt;<br/>{"message":{<br/>     "permissions_service":["127.0.0.1","3001"],<br/>     "user_service":["127.0.0.1","3000"]<br/>},"status":"OK"}</span></pre><p id="5823" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我知道可以做得更好，也应该这样做。真正的发现应该能够有多个给定 id 的服务实例，并使用像<code class="fe mi mj mk ml b">round-robin </code>这样的<code class="fe mi mj mk ml b">load-balancing</code>算法，并返回最少使用的服务实例。<br/>不过，这只是一个例子。:)</p><p id="0e6e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下一步是看<code class="fe mi mj mk ml b">permission_service</code>是否可以通过<code class="fe mi mj mk ml b">discovery_service </code>连接到<code class="fe mi mj mk ml b">user_service</code>来更新数据。</p><p id="8390" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那么，我们来做:<code class="fe mi mj mk ml b">curl -d ‘{“permission_level”: “3”}’ -X PUT -H “Content-Type: application/json” <a class="ae jz" href="http://127.0.0.1:3001/set_permission/george" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:3001/set_permission/george</a></code></p><figure class="ne nf ng nh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi og"><img src="../Images/a9e6b451e147dd97ebef76c7d5fedbe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tl3Trj5W2B3_yjhlU8E8rw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">微服务模式连接</figcaption></figure><p id="ed07" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以发生了几件事。<br/>首先我们对<code class="fe mi mj mk ml b">permission_service</code>做了一个 PUT 请求。<br/>然后<code class="fe mi mj mk ml b">permission_service</code>问<code class="fe mi mj mk ml b">discovery_service</code>“嘿，我能在哪里找到<code class="fe mi mj mk ml b">user_service</code>以便我能问他一件小事？”<br/>最后，在<code class="fe mi mj mk ml b">discovery_service</code>响应之后，我们最初的服务运行请求并更新用户 George:</p><figure class="ne nf ng nh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oh"><img src="../Images/ffbb641f9d808b6188c686045c51801e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iNWsFUzIq-lVesQtvo2xqA.png"/></div></div></figure><p id="2cd3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如您所见，George 的 permission_level 从 1 提高到了 3。</p><h2 id="c9da" class="mm lg in bd lh mn mo dn ll mp mq dp lp kl mr ms lt kp mt mu lx kt mv mw mb mx bi translated">当一个服务离线时会发生什么？</h2><p id="2371" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">好吧，这取决于你。我已经决定在<code class="fe mi mj mk ml b">permission_service</code>中省略这个验证检查，但是您可以添加简单的<code class="fe mi mj mk ml b">try:...except:...</code>来捕捉失败的请求并通过它来处理它。</p><p id="d39a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">关于<code class="fe mi mj mk ml b">discover_service</code>当 healthcheck 停止时，它从注册表中删除服务，并在搜索给定的微服务时返回 404。</p><p id="7fb7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在下面的 GIF 中，您可以看到，在给定的时间缺乏健康，它从注册表中删除，然后动态地将其添加到注册表中:</p><h1 id="84ba" class="lf lg in bd lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly nc ma mb mc bi translated">摘要</h1><p id="d2f8" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">这是一个如何使用微服务构建 API 的简单例子。正如我之前说过的，如果你在云中工作，那么适当地设置基础设施就可以做到。<br/>在下一篇文章中，我将尝试向您解释微服务 API 到前端的连接模式。</p><p id="d290" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们保持联系。</p></div></div>    
</body>
</html>