<html>
<head>
<title>Implementing Go stream API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实现Go流API</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/implementing-go-stream-api-a74a6156ac35?source=collection_archive---------3-----------------------#2022-01-03">https://blog.devgenius.io/implementing-go-stream-api-a74a6156ac35?source=collection_archive---------3-----------------------#2022-01-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/dff5e7d2f49fe2a8a1d038bcb8fe55da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nALkEejEC3qHLBurHfAB4A.png"/></div></div></figure><h1 id="3a22" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">什么是流处理</h1><p id="e355" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">Java开发人员应该非常熟悉Java中的Stream API，它大大提高了处理数据集合的能力。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="440d" class="ma jw in lw b gy mb mc l md me"><strong class="lw io">int</strong> sum = widgets.stream()<br/>              .filter(w -&gt; w.getColor() == RED)<br/>              .mapToInt(w -&gt; w.getWeight())<br/>              .sum();</span></pre><p id="5334" class="pw-post-body-paragraph kt ku in kv b kw mf ky kz la mg lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">Stream的思想是将数据处理抽象成数据流，并在每次处理后返回一个新的流供使用。</p><h1 id="cde4" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">流函数定义</h1><p id="f023" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">最重要的一步是在编写代码之前仔细考虑需求，所以让我们试着站在作者的角度考虑组件的流程。首先，我们先把底层的实现逻辑放在一边，试着从头开始定义流函数。</p><p id="1e61" class="pw-post-body-paragraph kt ku in kv b kw mf ky kz la mg lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">Stream的工作流程实际上是生产-消费模型的一部分，整个过程与工厂中的生产过程非常相似。</p><ol class=""><li id="8737" class="mk ml in kv b kw mf la mg le mm li mn lm mo lq mp mq mr ms bi translated">创建阶段/数据采集(原材料)</li><li id="d282" class="mk ml in kv b kw mt la mu le mv li mw lm mx lq mp mq mr ms bi translated">处理阶段/中间处理(流水线处理)</li><li id="826d" class="mk ml in kv b kw mt la mu le mv li mw lm mx lq mp mq mr ms bi translated">聚集阶段/最终操作(最终产品)</li></ol><p id="2889" class="pw-post-body-paragraph kt ku in kv b kw mf ky kz la mg lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">API是围绕一个流的三个生命周期定义的。</p><h2 id="5ef2" class="ma jw in bd jx my mz dn kb na nb dp kf le nc nd kj li ne nf kn lm ng nh kr ni bi translated">创建阶段</h2><p id="a612" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">为了创建抽象对象流，可以理解为构造函数。</p><p id="a681" class="pw-post-body-paragraph kt ku in kv b kw mf ky kz la mg lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">我们支持三种构造流的方式:切片转换、通道转换和函数转换。</p><p id="5a19" class="pw-post-body-paragraph kt ku in kv b kw mf ky kz la mg lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">注意，这个阶段的方法是普通的公共方法，没有绑定到流对象。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="9cbb" class="ma jw in lw b gy mb mc l md me">// Create stream by variable parameter pattern<br/><strong class="lw io">func</strong> <strong class="lw io">Just</strong>(items ... .<strong class="lw io">interface</strong>{}) <strong class="lw io">Stream</strong></span><span id="e112" class="ma jw in lw b gy nj mc l md me">// Create a stream via channel<br/><strong class="lw io">func</strong> <strong class="lw io">Range</strong>(source &lt;-<strong class="lw io">chan</strong> <strong class="lw io">interface</strong>{}) <strong class="lw io">Stream</strong></span><span id="0a47" class="ma jw in lw b gy nj mc l md me">// Create stream by function<br/><strong class="lw io">func</strong> <strong class="lw io">From</strong>(generate GenerateFunc) <strong class="lw io">Stream</strong></span><span id="724d" class="ma jw in lw b gy nj mc l md me">// Concatenate a stream<br/><strong class="lw io">func</strong> <strong class="lw io">Concat</strong>(s Stream, others . . Stream) <strong class="lw io">Stream</strong></span></pre><h2 id="0997" class="ma jw in bd jx my mz dn kb na nb dp kf le nc nd kj li ne nf kn lm ng nh kr ni bi translated">处理阶段</h2><p id="4898" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">处理阶段所需的操作通常与我们的业务逻辑相对应，例如转换、过滤、去重、排序等等。</p><p id="4835" class="pw-post-body-paragraph kt ku in kv b kw mf ky kz la mg lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">这个阶段的API是一个需要绑定到流对象的方法。</p><p id="cd4a" class="pw-post-body-paragraph kt ku in kv b kw mf ky kz la mg lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">下面的定义结合了常见的业务场景。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="3807" class="ma jw in lw b gy mb mc l md me">// Remove duplicate items<br/>Distinct(keyFunc KeyFunc) Stream<br/>// Filter item by condition<br/>Filter(filterFunc FilterFunc, opts ... . Option) Stream<br/>// Grouping<br/>Group(fn KeyFunc) Stream<br/>// Return the first n elements<br/>Head(n <strong class="lw io">int64</strong>) Stream<br/>// Returns the last n elements<br/>Tail(n <strong class="lw io">int64</strong>) Stream<br/>// Convert objects<br/>Map(fn MapFunc, opts . . Option) Stream<br/>// Merge items into slice to create a new stream<br/>Merge() Stream<br/>// Reverse<br/>Reverse() Stream<br/>// Sort<br/>Sort(fn LessFunc) Stream<br/>// Works on each item<br/>Walk(fn WalkFunc, opts ... . Option) Stream<br/>// Aggregate other Streams<br/>Concat(streams ... . Stream) Stream</span></pre><p id="bd3b" class="pw-post-body-paragraph kt ku in kv b kw mf ky kz la mg lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">处理阶段的处理逻辑返回一个新的流对象，这里有一个基本的实现范式。</p><figure class="lr ls lt lu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/63bbd1b3cc8f5b84fc791eddfbe4c12b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SqIhIftN6iTaqEYr.png"/></div></div></figure><h2 id="3157" class="ma jw in bd jx my mz dn kb na nb dp kf le nc nd kj li ne nf kn lm ng nh kr ni bi translated">聚集阶段</h2><p id="7266" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">聚合阶段实际上是我们想要的处理结果，例如，它是否匹配、计数、遍历等等。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="0fcf" class="ma jw in lw b gy mb mc l md me">// Check for all matches<br/>AllMatch(fn PredicateFunc) <strong class="lw io">bool</strong><br/>// Check if at least one match exists<br/>AnyMatch(fn PredicateFunc) <strong class="lw io">bool</strong><br/>// Check for all mismatches<br/>NoneMatch(fn PredicateFunc) <strong class="lw io">bool</strong><br/>// Count the number of matches<br/>Count() <strong class="lw io">int</strong><br/>// Clear the stream<br/>Done()<br/>// Perform an operation on all elements<br/>ForAll(fn ForAllFunc)<br/>// Perform an operation on each element<br/>ForEach(fn ForEachFunc)</span></pre><p id="4937" class="pw-post-body-paragraph kt ku in kv b kw mf ky kz la mg lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">在理清了组件的需求边界之后，我们对我们要用Stream实现什么有了一个更清晰的想法。在我的感知中，一个真正的架构师对需求及其后续演化的把握可以非常精准，而这只有通过对需求的深入思考，穿透需求背后的本质才能实现。通过代替作者的视角来模拟整个项目构建过程，学习作者的思维方法论是我们学习开源项目的最大价值。</p><p id="b89b" class="pw-post-body-paragraph kt ku in kv b kw mf ky kz la mg lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">好了，让我们试着定义完整的流接口和函数。</p><blockquote class="nl nm nn"><p id="8ab5" class="kt ku no kv b kw mf ky kz la mg lc ld np mh lg lh nq mi lk ll nr mj lo lp lq ig bi translated"><em class="in">界面的作用不仅仅是一个模板，还要利用它的抽象能力来构建项目的整体框架而不要一开始就陷入细节，通过界面简洁地快速表达我们的思维过程，要学会养成自上而下的思维方式从全局的角度来观察整个系统，一开始就很容易陷入细节。</em></p></blockquote><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="4210" class="ma jw in lw b gy mb mc l md me">rxOptions <strong class="lw io">struct</strong> {<br/>  unlimitedWorkers <strong class="lw io">bool</strong><br/>  workers <strong class="lw io">int</strong><br/>}<br/>Option <strong class="lw io">func</strong>(opts *rxOptions)<br/>// key generator<br/>// item - the element in the stream<br/>KeyFunc <strong class="lw io">func</strong>(item <strong class="lw io">interface</strong>{}) <strong class="lw io">interface</strong>{}<br/>// filter function<br/>FilterFunc <strong class="lw io">func</strong>(item <strong class="lw io">interface</strong>{}) <strong class="lw io">bool</strong><br/>// object conversion function<br/>MapFunc <strong class="lw io">func</strong>(intem <strong class="lw io">interface</strong>{}) <strong class="lw io">interface</strong>{}<br/>// object comparison<br/>LessFunc <strong class="lw io">func</strong>(a, b <strong class="lw io">interface</strong>{}) <strong class="lw io">bool</strong><br/>// traversal function<br/>WalkFunc <strong class="lw io">func</strong>(item <strong class="lw io">interface</strong>{}, pip <strong class="lw io">chan</strong>&lt;- <strong class="lw io">interface</strong>{})<br/>// match function<br/>PredicateFunc <strong class="lw io">func</strong>(item <strong class="lw io">interface</strong>{}) <strong class="lw io">bool</strong><br/>// perform an operation on all elements<br/>ForAllFunc <strong class="lw io">func</strong>(pip &lt;-<strong class="lw io">chan</strong> <strong class="lw io">interface</strong>{})<br/>// performs an operation on each item<br/>ForEachFunc <strong class="lw io">func</strong>(item <strong class="lw io">interface</strong>{})<br/>// execute operations on each element concurrently<br/>ParallelFunc <strong class="lw io">func</strong>(item <strong class="lw io">interface</strong>{})<br/>// execute the aggregation operation on all elements<br/>ReduceFunc <strong class="lw io">func</strong>(pip &lt;-<strong class="lw io">chan</strong> <strong class="lw io">interface</strong>{}) (<strong class="lw io">interface</strong>{}, error)<br/>// item generation function<br/>GenerateFunc <strong class="lw io">func</strong>(source &lt;-<strong class="lw io">chan</strong> <strong class="lw io">interface</strong>{})</span><span id="9d6a" class="ma jw in lw b gy nj mc l md me">Stream <strong class="lw io">interface</strong> {<br/>  // Remove duplicate items<br/>  Distinct(keyFunc KeyFunc) Stream<br/>  // Filter item by condition<br/>  Filter(filterFunc FilterFunc, opts . . Option) Stream<br/>  // Grouping<br/>  Group(fn KeyFunc) Stream<br/>  // Return the first n elements<br/>  Head(n <strong class="lw io">int64</strong>) Stream<br/>  // Returns the last n elements<br/>  Tail(n <strong class="lw io">int64</strong>) Stream<br/>  // Get the first element<br/>  First() <strong class="lw io">interface</strong>{}<br/>  // Get the last element<br/>  Last() <strong class="lw io">interface</strong>{}<br/>  // Convert the object<br/>  Map(fn MapFunc, opts . . Option) Stream<br/>  // Merge items into slice to create a new stream<br/>  Merge() Stream<br/>  // Reverse<br/>  Reverse() Stream<br/>  // Sort<br/>  Sort(fn LessFunc) Stream<br/>  // Works on each item<br/>  Walk(fn WalkFunc, opts ... . Option) Stream<br/>  // Aggregate other Streams<br/>  Concat(streams ... . Stream) Stream<br/>  // Check for all matches<br/>  AllMatch(fn PredicateFunc) <strong class="lw io">bool</strong><br/>  // Check if there is at least one match<br/>  AnyMatch(fn PredicateFunc) <strong class="lw io">bool</strong><br/>  // Check for all mismatches<br/>  NoneMatch(fn PredicateFunc) <strong class="lw io">bool</strong><br/>  // Count the number of matches<br/>  Count() <strong class="lw io">int</strong><br/>  // Clear the stream<br/>  Done()<br/>  // Perform an operation on all elements<br/>  ForAll(fn ForAllFunc)<br/>  // Perform an operation on each element<br/>  ForEach(fn ForEachFunc)<br/>}</span></pre><p id="5535" class="pw-post-body-paragraph kt ku in kv b kw mf ky kz la mg lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">channel()方法用于获取流管道属性，因为我们在实现中处理接口对象，所以我们公开一个私有方法来读取。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="2707" class="ma jw in lw b gy mb mc l md me">// Get the internal data container channel, internal method<br/>channel() <strong class="lw io">chan</strong> <strong class="lw io">interface</strong>{}</span></pre><h1 id="0509" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">实施思路</h1><p id="6298" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">整理好功能定义后，接下来考虑几个工程实现。</p><h1 id="fc79" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">如何实现链式调用</h1><p id="74e4" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">链式调用，构建器模式用来创建对象可以达到链式调用的效果。事实上，Stream根据相同的原理实现了类似的连锁效应，在每次调用中创建一个新的流来返回。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="db95" class="ma jw in lw b gy mb mc l md me">// Remove duplicate items<br/>Distinct(keyFunc KeyFunc) Stream<br/>// Filter item by condition<br/>Filter(filterFunc FilterFunc, opts . . Option) Stream</span></pre><h1 id="3b2a" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">如何达到流水线处理的效果</h1><p id="35cf" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">管道可以理解为流中数据的存储容器。在go中我们可以使用channel作为数据的管道，在流链调用执行多个操作时达到<strong class="kv io">异步无阻塞</strong>的效果。</p><h1 id="0b3e" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">如何支持并行处理</h1><p id="29ef" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">数据处理本质上是处理通道中的数据，所以实现并行处理就是简单地并行消耗通道，使用goroutine和WaitGroup可以非常方便地实现并行处理。</p><h1 id="9a9e" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">归零实现</h1><p id="d652" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated"><code class="fe ns nt nu lw b">core/fx/stream.go</code></p><p id="eabc" class="pw-post-body-paragraph kt ku in kv b kw mf ky kz la mg lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">go-zero中Stream的实现没有定义接口，但是在底层实现时逻辑是一样的。</p><p id="8fc2" class="pw-post-body-paragraph kt ku in kv b kw mf ky kz la mg lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">为了实现流接口，我们定义了一个内部实现类，其中源是channel类型，以模拟管道功能。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="f414" class="ma jw in lw b gy mb mc l md me">Stream <strong class="lw io">struct</strong> {<br/>  source &lt;-<strong class="lw io">chan</strong> <strong class="lw io">interface</strong>{}<br/>}</span></pre><h1 id="4088" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">创建API</h1><h2 id="e7e4" class="ma jw in bd jx my mz dn kb na nb dp kf le nc nd kj li ne nf kn lm ng nh kr ni bi translated">范围的通道创建</h2><p id="d4b9" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">通过频道创建流</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="3984" class="ma jw in lw b gy mb mc l md me"><strong class="lw io">func</strong> <strong class="lw io">Range</strong>(source &lt;-<strong class="lw io">chan</strong> <strong class="lw io">interface</strong>{}) <strong class="lw io">Stream</strong> {  <br/>  <strong class="lw io">return</strong> Stream{  <br/>    source: source,  <br/>  }  <br/>}</span></pre><h2 id="48ac" class="ma jw in bd jx my mz dn kb na nb dp kf le nc nd kj li ne nf kn lm ng nh kr ni bi translated">Just的可变参数模式创建</h2><p id="c79c" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">在可变参数模式下创建流，并在完成编写后关闭通道，这是一个好习惯。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="c77b" class="ma jw in lw b gy mb mc l md me"><strong class="lw io">func</strong> <strong class="lw io">Just</strong>(items ... .<strong class="lw io">interface</strong>{}) <strong class="lw io">Stream</strong> {<br/>  source := make(<strong class="lw io">chan</strong> <strong class="lw io">interface</strong>{}, len(items))<br/>  <strong class="lw io">for</strong> _, item := <strong class="lw io">range</strong> items {<br/>    source &lt;- item<br/>  }<br/>  close(source)<br/>  <strong class="lw io">return</strong> Range(source)<br/>}</span></pre><h2 id="5e48" class="ma jw in bd jx my mz dn kb na nb dp kf le nc nd kj li ne nf kn lm ng nh kr ni bi translated">要创建的函数</h2><p id="5e37" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">按功能创建流</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="418d" class="ma jw in lw b gy mb mc l md me"><strong class="lw io">func</strong> <strong class="lw io">From</strong>(generate GenerateFunc) <strong class="lw io">Stream</strong> {<br/>  source := make(<strong class="lw io">chan</strong> <strong class="lw io">interface</strong>{})<br/>  threading.GoSafe(<strong class="lw io">func</strong>() {<br/>    <strong class="lw io">defer</strong> close(source)<br/>    generate(source)<br/>  })<br/>  <strong class="lw io">return</strong> Range(source)<br/>}</span></pre><p id="34cb" class="pw-post-body-paragraph kt ku in kv b kw mf ky kz la mg lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">因为它涉及对函数参数的外部调用，所以执行过程是不可用的，所以您需要捕获运行时异常，以防止紧急错误被传递到上层并使应用程序崩溃。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="8e69" class="ma jw in lw b gy mb mc l md me"><strong class="lw io">func</strong> <strong class="lw io">Recover</strong>(cleanups ... . <strong class="lw io">func</strong>()) {<br/>  <strong class="lw io">for</strong> _, cleanup := <strong class="lw io">range</strong> cleanups {<br/>    cleanup()<br/>  }<br/>  <strong class="lw io">if</strong> r := recover(); r ! = <strong class="lw io">nil</strong> {<br/>    logx.ErrorStack(r)<br/>  }<br/>}</span><span id="8c6c" class="ma jw in lw b gy nj mc l md me"><strong class="lw io">func</strong> <strong class="lw io">RunSafe</strong>(fn <strong class="lw io">func</strong>()) {<br/>  <strong class="lw io">defer</strong> rescue.Recover()<br/>  fn()<br/>}</span><span id="50ea" class="ma jw in lw b gy nj mc l md me"><strong class="lw io">func</strong> <strong class="lw io">GoSafe</strong>(fn <strong class="lw io">func</strong>()) {<br/>  <strong class="lw io">go</strong> RunSafe(fn)<br/>}</span></pre><h2 id="71e0" class="ma jw in bd jx my mz dn kb na nb dp kf le nc nd kj li ne nf kn lm ng nh kr ni bi translated">拼接拼接</h2><p id="7958" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">拼接其他流创建一个新流，调用内部Concat方法方法，Concat的源代码实现将在后面分析。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="2367" class="ma jw in lw b gy mb mc l md me"><strong class="lw io">func</strong> <strong class="lw io">Concat</strong>(s Stream, others . . Stream) <strong class="lw io">Stream</strong> {<br/>  <strong class="lw io">return</strong> s.Concat(others...)<br/>}</span></pre><h1 id="9751" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">处理API</h1><h2 id="90c8" class="ma jw in bd jx my mz dn kb na nb dp kf le nc nd kj li ne nf kn lm ng nh kr ni bi translated">重复数据消除独特</h2><p id="1839" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">因为传入了函数参数<code class="fe ns nt nu lw b">KeyFunc func(item interface{}) interface{}</code>，这意味着它也支持根据业务场景进行自定义区分，本质上是利用KeyFunc返回的结果来实现基于一张地图的区分。</p><p id="cdba" class="pw-post-body-paragraph kt ku in kv b kw mf ky kz la mg lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">函数参数非常强大，并且提供了很大的灵活性。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="946b" class="ma jw in lw b gy mb mc l md me"><strong class="lw io">func</strong> (s Stream) <strong class="lw io">Distinct</strong>(keyFunc KeyFunc) <strong class="lw io">Stream</strong> {<br/>  source := make(<strong class="lw io">chan</strong> <strong class="lw io">interface</strong>{})<br/>  threading.GoSafe(<strong class="lw io">func</strong>() {<br/>    // It's a good habit for channels to remember to close<br/>    <strong class="lw io">defer</strong> close(source)<br/>    keys := make(<strong class="lw io">map</strong>[<strong class="lw io">interface</strong>{}]lang.PlaceholderType)<br/>    <strong class="lw io">for</strong> item := <strong class="lw io">range</strong> s.source {<br/>      // Custom de-duplication logic<br/>      key := keyFunc(item)<br/>      // If the key does not exist, write the data to a new channel<br/>      <strong class="lw io">if</strong> _, ok := keys[key]; !ok {<br/>        source &lt;- item<br/>        keys[key] = lang.<br/>      Placeholder }<br/>    }<br/>  })<br/>  <strong class="lw io">return</strong> Range(source)<br/>}</span></pre><p id="f05f" class="pw-post-body-paragraph kt ku in kv b kw mf ky kz la mg lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">用例。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="5c71" class="ma jw in lw b gy mb mc l md me">// 1 2 3 4 5<br/>Just(1, 2, 3, 3, 4, 5, 5).Distinct(<strong class="lw io">func</strong>(item <strong class="lw io">interface</strong>{}) <strong class="lw io">interface</strong>{} {<br/>  <strong class="lw io">return</strong> item<br/>}).ForEach(<strong class="lw io">func</strong>(item <strong class="lw io">interface</strong>{}) {<br/>  t.Log(item)<br/>})</span><span id="d5df" class="ma jw in lw b gy nj mc l md me">// 1 2 3 4<br/>Just(1, 2, 3, 3, 4, 5, 5).Distinct(<strong class="lw io">func</strong>(item <strong class="lw io">interface</strong>{}) <strong class="lw io">interface</strong>{} {<br/>  uid := item.(<strong class="lw io">int</strong>)<br/>  // Special de-duplication logic for items greater than 4, so that only one item &gt; 3 is retained<br/>  <strong class="lw io">if</strong> uid &gt; 3 {<br/>    <strong class="lw io">return</strong> 4<br/>  }<br/>  <strong class="lw io">return</strong> item<br/>}).ForEach(<strong class="lw io">func</strong>(item <strong class="lw io">interface</strong>{}) {<br/>  t.Log(item)<br/>})</span></pre><h2 id="c31f" class="ma jw in bd jx my mz dn kb na nb dp kf le nc nd kj li ne nf kn lm ng nh kr ni bi translated">过滤器过滤器</h2><p id="c0bc" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">通过将过滤逻辑抽象为FilterFunc，然后单独对项目进行操作，以根据FilterFunc返回的布尔值决定是否写回新通道，从而将实际的过滤逻辑委托给Walk方法。</p><p id="a566" class="pw-post-body-paragraph kt ku in kv b kw mf ky kz la mg lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">Option参数包含两个选项。</p><ol class=""><li id="633b" class="mk ml in kv b kw mf la mg le mm li mn lm mo lq mp mq mr ms bi translated">无限制的工作人员对并发进程的数量没有限制</li><li id="d9f0" class="mk ml in kv b kw mt la mu le mv li mw lm mx lq mp mq mr ms bi translated">工人限制并发进程的数量</li></ol><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="bd64" class="ma jw in lw b gy mb mc l md me">FilterFunc <strong class="lw io">func</strong>(item <strong class="lw io">interface</strong>{}) <strong class="lw io">bool</strong></span><span id="7355" class="ma jw in lw b gy nj mc l md me"><strong class="lw io">func</strong> (s Stream) <strong class="lw io">Filter</strong>(filterFunc FilterFunc, opts . . Option) <strong class="lw io">Stream</strong> {<br/>  <strong class="lw io">return</strong> s.Walk(<strong class="lw io">func</strong>(item <strong class="lw io">interface</strong>{}, pip <strong class="lw io">chan</strong>&lt;- <strong class="lw io">interface</strong>{}) {<br/>    <strong class="lw io">if</strong> filterFunc(item) {<br/>      pip &lt;- item<br/>    }<br/>  }, opts...)<br/>}</span></pre><p id="f798" class="pw-post-body-paragraph kt ku in kv b kw mf ky kz la mg lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">用法示例。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="7dce" class="ma jw in lw b gy mb mc l md me"><strong class="lw io">func</strong> <strong class="lw io">TestInternalStream_Filter</strong>(t *testing.T) {<br/>  // keep even numbers 2,4<br/>  channel := Just(1, 2, 3, 4, 5).Filter(<strong class="lw io">func</strong>(item <strong class="lw io">interface</strong>{}) <strong class="lw io">bool</strong> {<br/>    <strong class="lw io">return</strong> item.(<strong class="lw io">int</strong>)%2 == 0<br/>  }).channel()<br/>  <strong class="lw io">for</strong> item := <strong class="lw io">range</strong> channel {<br/>    t.Log(item)<br/>  }<br/>}</span></pre><h2 id="50fd" class="ma jw in bd jx my mz dn kb na nb dp kf le nc nd kj li ne nf kn lm ng nh kr ni bi translated">遍历整个过程</h2><p id="d981" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">walk的意思是走，这里是指对每一项执行WalkFunc操作，并将结果写入一个新的流。</p><p id="9efa" class="pw-post-body-paragraph kt ku in kv b kw mf ky kz la mg lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">请注意，新流的通道中的数据顺序是随机的，因为内部并发机制用于异步读写数据。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="4123" class="ma jw in lw b gy mb mc l md me">// item element in item-stream<br/>// The pipe-item is written to the pipe if it matches the condition<br/>WalkFunc <strong class="lw io">func</strong>(item <strong class="lw io">interface</strong>{}, pipe <strong class="lw io">chan</strong>&lt;- <strong class="lw io">interface</strong>{})</span><span id="3745" class="ma jw in lw b gy nj mc l md me"><strong class="lw io">func</strong> (s Stream) <strong class="lw io">Walk</strong>(fn WalkFunc, opts . .Option) <strong class="lw io">Stream</strong> {<br/>  option := buildOptions(opts...)<br/>  <strong class="lw io">if</strong> option.unlimitedWorkers {<br/>    <strong class="lw io">return</strong> s.walkUnLimited(fn, option)<br/>  }<br/>  <strong class="lw io">return</strong> s.walkLimited(fn, option)<br/>}</span><span id="9fe5" class="ma jw in lw b gy nj mc l md me"><strong class="lw io">func</strong> (s Stream) <strong class="lw io">walkUnLimited</strong>(fn WalkFunc, option *rxOptions) <strong class="lw io">Stream</strong> {<br/>  // Create a channel with a buffer<br/>  // default is 16, channel with more than 16 elements will be blocked<br/>  pipe := make(<strong class="lw io">chan</strong> <strong class="lw io">interface</strong>{}, defaultWorkers)<br/>  <strong class="lw io">go</strong> <strong class="lw io">func</strong>() {<br/>    <strong class="lw io">var</strong> wg sync.WaitGroup</span><span id="0a57" class="ma jw in lw b gy nj mc l md me">    <strong class="lw io">for</strong> item := <strong class="lw io">range</strong> s.source {<br/>      // All elements of s.source need to be read<br/>      // This also explains why the channel is written last and remembered to finish<br/>      // If it is not closed, it may lead to leaks and blocking<br/>      // Important, not assigning a value to val is a classic concurrency trap, and is used later in another goroutine<br/>      val := item<br/>      wg.Add(1)<br/>      // Execute the function in safe mode<br/>      threading.GoSafe(<strong class="lw io">func</strong>() {<br/>        <strong class="lw io">defer</strong> wg.Done()<br/>        fn(item, pipe)<br/>      })<br/>    }<br/>    wg.Wait()<br/>    close(pipe)<br/>  }()</span><span id="faf1" class="ma jw in lw b gy nj mc l md me">  // return a new Stream<br/>  <strong class="lw io">return</strong> Range(pipe)<br/>}</span><span id="769c" class="ma jw in lw b gy nj mc l md me"><strong class="lw io">func</strong> (s Stream) <strong class="lw io">walkLimited</strong>(fn WalkFunc, option *rxOptions) <strong class="lw io">Stream</strong> {<br/>  pipe := make(<strong class="lw io">chan</strong> <strong class="lw io">interface</strong>{}, option.workers)<br/>  <strong class="lw io">go</strong> <strong class="lw io">func</strong>() {<br/>    <strong class="lw io">var</strong> wg sync.WaitGroup<br/>    // Control the number of concurrent processes<br/>    pool := make(<strong class="lw io">chan</strong> lang.PlaceholderType, option.workers)</span><span id="417b" class="ma jw in lw b gy nj mc l md me">    <strong class="lw io">for</strong> item := <strong class="lw io">range</strong> s.source {<br/>      // Important, not assigning a value to val is a classic concurrency trap, used later in another goroutine<br/>      val := item<br/>      // will block if the concurrency limit is exceeded<br/>      pool &lt;- lang.<br/>      // This also explains why the channel is written last and remembered to finish<br/>      // If you don't close it, it may cause the concurrent thread to keep blocking and lead to leaks<br/>      wg.Add(1)</span><span id="c622" class="ma jw in lw b gy nj mc l md me">      // Execute the function in safe mode<br/>      threading.GoSafe(<strong class="lw io">func</strong>() {<br/>        <strong class="lw io">defer</strong> <strong class="lw io">func</strong>() {<br/>          wg.Done()<br/>          // Read the pool once to release a concurrent location after execution is complete<br/>          &lt;-pool<br/>        }()<br/>        fn(item, pipe)<br/>      })<br/>    }<br/>    wg.Wait()<br/>    close(pipe)<br/>  }()<br/>  <strong class="lw io">return</strong> Range(pipe)<br/>}</span></pre><p id="0f0f" class="pw-post-body-paragraph kt ku in kv b kw mf ky kz la mg lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">用例。</p><p id="5510" class="pw-post-body-paragraph kt ku in kv b kw mf ky kz la mg lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">返回的顺序是随机的。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="d749" class="ma jw in lw b gy mb mc l md me"><strong class="lw io">func</strong> <strong class="lw io">Test_Stream_Walk</strong>(t *testing.T) {<br/>  // return 300,100,200<br/>  Just(1, 2, 3).Walk(<strong class="lw io">func</strong>(item <strong class="lw io">interface</strong>{}, pip <strong class="lw io">chan</strong>&lt;- <strong class="lw io">interface</strong>{}) {<br/>    pip &lt;- item.(<strong class="lw io">int</strong>) * 100<br/>  }, WithWorkers(3)).ForEach(<strong class="lw io">func</strong>(item <strong class="lw io">interface</strong>{}) {<br/>    t.Log(item)<br/>  })<br/>}</span></pre><h2 id="72a3" class="ma jw in bd jx my mz dn kb na nb dp kf le nc nd kj li ne nf kn lm ng nh kr ni bi translated">分组组</h2><p id="2067" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">通过匹配项目放入地图。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="de6a" class="ma jw in lw b gy mb mc l md me">KeyFunc <strong class="lw io">func</strong>(item <strong class="lw io">interface</strong>{}) <strong class="lw io">interface</strong>{}</span><span id="c1dc" class="ma jw in lw b gy nj mc l md me"><strong class="lw io">func</strong> (s Stream) <strong class="lw io">Group</strong>(fn KeyFunc) <strong class="lw io">Stream</strong> {<br/>  groups := make(<strong class="lw io">map</strong>[<strong class="lw io">interface</strong>{}][]<strong class="lw io">interface</strong>{})<br/>  <strong class="lw io">for</strong> item := <strong class="lw io">range</strong> s.source {<br/>    key := fn(item)<br/>    groups[key] = append(groups[key], item)<br/>  }<br/>  source := make(<strong class="lw io">chan</strong> <strong class="lw io">interface</strong>{})<br/>  <strong class="lw io">go</strong> <strong class="lw io">func</strong>() {<br/>    <strong class="lw io">for</strong> _, group := <strong class="lw io">range</strong> groups {<br/>      source &lt;- group<br/>    }<br/>    close(source)<br/>  }()<br/>  <strong class="lw io">return</strong> Range(source)<br/>}</span></pre><h2 id="58cc" class="ma jw in bd jx my mz dn kb na nb dp kf le nc nd kj li ne nf kn lm ng nh kr ni bi translated">获取Head的前n个元素</h2><p id="f38f" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">n大于实际数据集长度，将返回所有元素</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="57e7" class="ma jw in lw b gy mb mc l md me"><strong class="lw io">func</strong> (s Stream) <strong class="lw io">Head</strong>(n <strong class="lw io">int64</strong>) <strong class="lw io">Stream</strong> {<br/>  <strong class="lw io">if</strong> n &lt; 1 {<br/>    panic("n must be greather than 1")<br/>  }<br/>  source := make(<strong class="lw io">chan</strong> <strong class="lw io">interface</strong>{})<br/>  <strong class="lw io">go</strong> <strong class="lw io">func</strong>() {<br/>    <strong class="lw io">for</strong> item := <strong class="lw io">range</strong> s.source {<br/>      n--<br/>      // The value of n may be greater than the length of s.source, you need to determine if it is &gt;= 0<br/>      <strong class="lw io">if</strong> n &gt;= 0 {<br/>        source &lt;- item<br/>      }<br/>      // let successive method go ASAP even we have more items to skip<br/>      // why we don't just break the loop, because if break,<br/>      // this former goroutine will block forever, which will cause goroutine leak.<br/>      // n==0 means that source is full and can be closed<br/>      // Since source has met the condition, why not just break and jump out of the loop?<br/>      // The author mentions preventing goroutine leaks<br/>      // Because each operation will eventually create a new Stream, and the old one will never be called<br/>      <strong class="lw io">if</strong> n == 0 {<br/>        close(source)<br/>        <strong class="lw io">break</strong><br/>      }<br/>    }<br/>    // The above loop jumped out of the loop, which means n is greater than the actual length of s.source<br/>    // still need to show the new source closed<br/>    <strong class="lw io">if</strong> n &gt; 0 {<br/>      close(source)<br/>    }<br/>  }()<br/>  <strong class="lw io">return</strong> Range(source)<br/>}</span></pre><p id="699e" class="pw-post-body-paragraph kt ku in kv b kw mf ky kz la mg lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">用法示例。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="e2a1" class="ma jw in lw b gy mb mc l md me">// return 1,2<br/><strong class="lw io">func</strong> <strong class="lw io">TestInternalStream_Head</strong>(t *testing.T) {<br/>  channel := Just(1, 2, 3, 4, 5).Head(2).channel()<br/>  <strong class="lw io">for</strong> item := <strong class="lw io">range</strong> channel {<br/>    t.Log(item)<br/>  }<br/>}</span></pre><h2 id="a2b9" class="ma jw in bd jx my mz dn kb na nb dp kf le nc nd kj li ne nf kn lm ng nh kr ni bi translated">获取Tail的最后n个元素</h2><p id="0424" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">为了确保使用环数据结构获得最后n个元素，理解环的实现是有趣的。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="70fd" class="ma jw in lw b gy mb mc l md me">// ring slicing<br/><strong class="lw io">type</strong> Ring <strong class="lw io">struct</strong> {<br/>  elements []<strong class="lw io">interface</strong>{}<br/>  index <strong class="lw io">int</strong><br/>  lock sync.Mutex<br/>}</span><span id="c1af" class="ma jw in lw b gy nj mc l md me"><strong class="lw io">func</strong> <strong class="lw io">NewRing</strong>(n <strong class="lw io">int</strong>) *<strong class="lw io">Ring</strong> {<br/>  <strong class="lw io">if</strong> n &lt; 1 {<br/>    panic("n should be greather than 0")<br/>  }<br/>  <strong class="lw io">return</strong> &amp;Ring{<br/>    elements: make([]<strong class="lw io">interface</strong>{}, n),<br/>  }<br/>}</span><span id="ed4b" class="ma jw in lw b gy nj mc l md me">// Add elements<br/><strong class="lw io">func</strong> (r *Ring) <strong class="lw io">Add</strong>(v <strong class="lw io">interface</strong>{}) {<br/>  r.lock.Lock()<br/>  <strong class="lw io">defer</strong> r.lock.Unlock()<br/>  // Write the element to the slice at the specified location<br/>  // The remainder here achieves a circular writing effect<br/>  r.elements[r.index%len(r.elements)] = v<br/>  // Update the next write position<br/>  r.index++<br/>}</span><span id="b1fd" class="ma jw in lw b gy nj mc l md me">// Get all elements<br/>// Keep the read order the same as the write order<br/><strong class="lw io">func</strong> (r *Ring) <strong class="lw io">Take</strong>() []<strong class="lw io">interface</strong>{} {<br/>  r.lock.Lock()<br/>  <strong class="lw io">defer</strong> r.lock.Unlock()</span><span id="2d57" class="ma jw in lw b gy nj mc l md me">  <strong class="lw io">var</strong> size <strong class="lw io">int</strong><br/>  <strong class="lw io">var</strong> start <strong class="lw io">int</strong><br/>  // When there is a circular write situation<br/>  // The start read position needs to be decimalized, because we want the read order to be the same as the write order<br/>  <strong class="lw io">if</strong> r.index &gt; len(r.elements) {<br/>    size = len(r.elements)<br/>    // Because of the cyclic write situation, the current write position index starts with the oldest data<br/>    start = r.index % len(r.elements)<br/>  } <strong class="lw io">else</strong> {<br/>    size = r.index<br/>  }<br/>  elements := make([]<strong class="lw io">interface</strong>{}, size)<br/>  <strong class="lw io">for</strong> i := 0; i &lt; size; i++ {<br/>    // Read the remainder in a circular fashion, keeping the read order the same as the write order<br/>    elements[i] = r.elements[(start+i)%len(r.elements)]<br/>  }</span><span id="f186" class="ma jw in lw b gy nj mc l md me">  <strong class="lw io">return</strong> elements<br/>}</span></pre><p id="732a" class="pw-post-body-paragraph kt ku in kv b kw mf ky kz la mg lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">总结环形切片的优点。</p><ul class=""><li id="10e0" class="mk ml in kv b kw mf la mg le mm li mn lm mo lq nv mq mr ms bi translated">支持自动滚动更新</li><li id="d939" class="mk ml in kv b kw mt la mu le mv li mw lm mx lq nv mq mr ms bi translated">内存节省</li></ul><p id="172c" class="pw-post-body-paragraph kt ku in kv b kw mf ky kz la mg lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">当固定容量已满时，环形切片使旧数据能够被新数据覆盖，并且由于这一特性，可用于读取通道之后的n个元素。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="0cf1" class="ma jw in lw b gy mb mc l md me"><strong class="lw io">func</strong> (s Stream) <strong class="lw io">Tail</strong>(n <strong class="lw io">int64</strong>) <strong class="lw io">Stream</strong> {<br/>  <strong class="lw io">if</strong> n &lt; 1 {<br/>    panic("n must be greather than 1")<br/>  }<br/>  source := make(<strong class="lw io">chan</strong> <strong class="lw io">interface</strong>{})<br/>  <strong class="lw io">go</strong> <strong class="lw io">func</strong>() {<br/>    ring := collection.NewRing(<strong class="lw io">int</strong>(n))<br/>    // Read all elements, if the number &gt; n ring slices can achieve new data over old data<br/>    // ensure that the last n elements are obtained<br/>    <strong class="lw io">for</strong> item := <strong class="lw io">range</strong> s.source {<br/>      ring.Add(item)<br/>    }<br/>    <strong class="lw io">for</strong> _, item := <strong class="lw io">range</strong> ring.Take() {<br/>      source &lt;- item<br/>    }<br/>    close(source)<br/>  }()<br/>  <strong class="lw io">return</strong> Range(source)<br/>}</span></pre><p id="385a" class="pw-post-body-paragraph kt ku in kv b kw mf ky kz la mg lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">那么为什么不直接使用透镜(源)长度切片呢？</p><p id="311f" class="pw-post-body-paragraph kt ku in kv b kw mf ky kz la mg lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">答案是节省内存。任何包含环类型的数据结构都具有节省内存和按需分配资源的优点。</p><p id="1b59" class="pw-post-body-paragraph kt ku in kv b kw mf ky kz la mg lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">用法示例。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="9d9b" class="ma jw in lw b gy mb mc l md me"><strong class="lw io">func</strong> <strong class="lw io">TestInternalStream_Tail</strong>(t *testing.T) {<br/>  // 4,5<br/>  channel := Just(1, 2, 3, 4, 5).Tail(2).channel()<br/>  <strong class="lw io">for</strong> item := <strong class="lw io">range</strong> channel {<br/>    t.Log(item)<br/>  }<br/>  // 1,2,3,4,5<br/>  channel2 := Just(1, 2, 3, 4, 5).Tail(6).channel()<br/>  <strong class="lw io">for</strong> item := <strong class="lw io">range</strong> channel2 {<br/>    t.Log(item)<br/>  }<br/>}</span></pre><h2 id="4cb2" class="ma jw in bd jx my mz dn kb na nb dp kf le nc nd kj li ne nf kn lm ng nh kr ni bi translated">元素转换图</h2><p id="3bcd" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">元素转换，由完成转换操作的并发进程在内部完成，请注意，输出通道不保证按原始顺序输出。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="25c8" class="ma jw in lw b gy mb mc l md me">MapFunc <strong class="lw io">func</strong>(intem <strong class="lw io">interface</strong>{}) <strong class="lw io">interface</strong>{}<br/><strong class="lw io">func</strong> (s Stream) <strong class="lw io">Map</strong>(fn MapFunc, opts . . Option) <strong class="lw io">Stream</strong> {<br/>  <strong class="lw io">return</strong> s.Walk(<strong class="lw io">func</strong>(item <strong class="lw io">interface</strong>{}, pip <strong class="lw io">chan</strong>&lt;- <strong class="lw io">interface</strong>{}) {<br/>    pip &lt;- fn(item)<br/>  }, opts...)<br/>}</span></pre><p id="d8d8" class="pw-post-body-paragraph kt ku in kv b kw mf ky kz la mg lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">用法示例。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="10bc" class="ma jw in lw b gy mb mc l md me"><strong class="lw io">func</strong> <strong class="lw io">TestInternalStream_Map</strong>(t *testing.T) {<br/>  channel := Just(1, 2, 3, 4, 5, 2, 2, 2, 2, 2, 2, 2).Map(<strong class="lw io">func</strong>(item <strong class="lw io">interface</strong>{}) <strong class="lw io">interface</strong>{} {<br/>    <strong class="lw io">return</strong> item.(<strong class="lw io">int</strong>) * 10<br/>  }).channel()<br/>  <strong class="lw io">for</strong> item := <strong class="lw io">range</strong> channel {<br/>    t.Log(item)<br/>  }<br/>}</span></pre><h2 id="6958" class="ma jw in bd jx my mz dn kb na nb dp kf le nc nd kj li ne nf kn lm ng nh kr ni bi translated">合并合并</h2><p id="3757" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">实现相对简单，并且我已经仔细考虑了适合这种方法的场景。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="5217" class="ma jw in lw b gy mb mc l md me"><strong class="lw io">func</strong> (s Stream) <strong class="lw io">Merge</strong>() <strong class="lw io">Stream</strong> {<br/>  <strong class="lw io">var</strong> items []<strong class="lw io">interface</strong>{}<br/>  <strong class="lw io">for</strong> item := <strong class="lw io">range</strong> s.source {<br/>    items = append(items, item)<br/>  }<br/>  source := make(<strong class="lw io">chan</strong> <strong class="lw io">interface</strong>{}, 1)<br/>  source &lt;- items<br/>  <strong class="lw io">return</strong> Range(source)<br/>}</span></pre><h2 id="7ccd" class="ma jw in bd jx my mz dn kb na nb dp kf le nc nd kj li ne nf kn lm ng nh kr ni bi translated">反面的</h2><p id="ca84" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">反转通道的元素。反转算法的流程是</p><ul class=""><li id="e472" class="mk ml in kv b kw mf la mg le mm li mn lm mo lq nv mq mr ms bi translated">找到中间节点</li><li id="6275" class="mk ml in kv b kw mt la mu le mv li mw lm mx lq nv mq mr ms bi translated">节点的两端开始两两交换</li></ul><p id="2a6e" class="pw-post-body-paragraph kt ku in kv b kw mf ky kz la mg lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">请注意为什么在获取s.source时使用片来接收它？切片自动展开，用数组不是更好吗？</p><p id="56b5" class="pw-post-body-paragraph kt ku in kv b kw mf ky kz la mg lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">其实这里不能用数组，因为你不知道流写source往往是在一个并发进程中异步完成的，每个流中的通道可能是动态变化的。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="7f13" class="ma jw in lw b gy mb mc l md me"><strong class="lw io">func</strong> (s Stream) <strong class="lw io">Reverse</strong>() <strong class="lw io">Stream</strong> {<br/>  <strong class="lw io">var</strong> items []<strong class="lw io">interface</strong>{}<br/>  <strong class="lw io">for</strong> item := <strong class="lw io">range</strong> s.source {<br/>    items = append(items, item)<br/>  }<br/>  <strong class="lw io">for</strong> i := len(items)/2 - 1; i &gt;= 0; i-- {<br/>    opp := len(items) - 1 - i<br/>    items[i], items[opp] = items[opp], items[i]<br/>  }<br/>  <strong class="lw io">return</strong> Just(items...)<br/>}</span></pre><p id="a6e5" class="pw-post-body-paragraph kt ku in kv b kw mf ky kz la mg lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">用法示例。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="75b3" class="ma jw in lw b gy mb mc l md me"><strong class="lw io">func</strong> <strong class="lw io">TestInternalStream_Reverse</strong>(t *testing.T) {<br/>  channel := Just(1, 2, 3, 4, 5).Reverse().channel()<br/>  <strong class="lw io">for</strong> item := <strong class="lw io">range</strong> channel {<br/>    t.Log(item)<br/>  }<br/>}</span></pre><h2 id="940d" class="ma jw in bd jx my mz dn kb na nb dp kf le nc nd kj li ne nf kn lm ng nh kr ni bi translated">分类</h2><p id="6776" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">内网调用官方切片包排序方案，只需传入比较函数实现比较逻辑即可。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="34ae" class="ma jw in lw b gy mb mc l md me"><strong class="lw io">func</strong> (s Stream) <strong class="lw io">Sort</strong>(fn LessFunc) <strong class="lw io">Stream</strong> {<br/>  <strong class="lw io">var</strong> items []<strong class="lw io">interface</strong>{}<br/>  <strong class="lw io">for</strong> item := <strong class="lw io">range</strong> s.source {<br/>    items = append(items, item)<br/>  }</span><span id="778b" class="ma jw in lw b gy nj mc l md me">  sort.Slice(items, <strong class="lw io">func</strong>(i, j <strong class="lw io">int</strong>) <strong class="lw io">bool</strong> {<br/>    <strong class="lw io">return</strong> fn(i, j)<br/>  })<br/>  <strong class="lw io">return</strong> Just(items...)<br/>}</span></pre><p id="1f79" class="pw-post-body-paragraph kt ku in kv b kw mf ky kz la mg lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">用法示例。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="1cb5" class="ma jw in lw b gy mb mc l md me">// 5,4,3,2,1<br/><strong class="lw io">func</strong> <strong class="lw io">TestInternalStream_Sort</strong>(t *testing.T) {<br/>  channel := Just(1, 2, 3, 4, 5).Sort(<strong class="lw io">func</strong>(a, b <strong class="lw io">interface</strong>{}) <strong class="lw io">bool</strong> {<br/>    <strong class="lw io">return</strong> a.(<strong class="lw io">int</strong>) &gt; b.(<strong class="lw io">int</strong>)<br/>  }).channel()<br/>  <strong class="lw io">for</strong> item := <strong class="lw io">range</strong> channel {<br/>    t.Log(item)<br/>  }<br/>}</span></pre><h2 id="ba77" class="ma jw in bd jx my mz dn kb na nb dp kf le nc nd kj li ne nf kn lm ng nh kr ni bi translated">拼接拼接</h2><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="78ea" class="ma jw in lw b gy mb mc l md me"><strong class="lw io">func</strong> (s Stream) <strong class="lw io">Concat</strong>(steams . .Stream) <strong class="lw io">Stream</strong> {<br/>  // Create a new unbuffered channel<br/>  source := make(<strong class="lw io">chan</strong> <strong class="lw io">interface</strong>{})<br/>  <strong class="lw io">go</strong> <strong class="lw io">func</strong>() {<br/>    // Create a waiGroup object<br/>    NewRoutineGroup()<br/>    // Asynchronously read data from the original channel<br/>    group.Run(<strong class="lw io">func</strong>() {<br/>      <strong class="lw io">for</strong> item := <strong class="lw io">range</strong> s.source {<br/>        source &lt;- item<br/>      }<br/>    })<br/>    // Asynchronously read the channel data of the Stream to be stitched<br/>    <strong class="lw io">for</strong> _, stream := <strong class="lw io">range</strong> steams {<br/>      // open a concurrent process for each Stream<br/>      group.Run(<strong class="lw io">func</strong>() {<br/>        <strong class="lw io">for</strong> item := <strong class="lw io">range</strong> stream.channel() {<br/>          source &lt;- item<br/>        }<br/>      })<br/>    }<br/>    // Block and wait for the read to complete<br/>    group.Wait()<br/>    close(source)<br/>  }()<br/>  // return a new Stream<br/>  <strong class="lw io">return</strong> Range(source)<br/>}</span></pre><h1 id="f0d5" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">聚合API</h1><h2 id="923e" class="ma jw in bd jx my mz dn kb na nb dp kf le nc nd kj li ne nf kn lm ng nh kr ni bi translated">匹配所有AllMatch</h2><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="c073" class="ma jw in lw b gy mb mc l md me"><strong class="lw io">func</strong> (s Stream) <strong class="lw io">AllMatch</strong>(fn PredicateFunc) <strong class="lw io">bool</strong> {<br/>  <strong class="lw io">for</strong> item := <strong class="lw io">range</strong> s.source {<br/>    <strong class="lw io">if</strong> !fn(item) {<br/>      // need to drain s.source, otherwise the previous goroutine may block<br/>      <strong class="lw io">go</strong> drain(s.source)<br/>      <strong class="lw io">return</strong> <strong class="lw io">false</strong><br/>    }<br/>  }</span><span id="6f3f" class="ma jw in lw b gy nj mc l md me">  <strong class="lw io">return</strong> <strong class="lw io">true</strong><br/>}</span></pre><h2 id="2418" class="ma jw in bd jx my mz dn kb na nb dp kf le nc nd kj li ne nf kn lm ng nh kr ni bi translated">任意匹配</h2><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="65b5" class="ma jw in lw b gy mb mc l md me"><strong class="lw io">func</strong> (s Stream) <strong class="lw io">AnyMatch</strong>(fn PredicateFunc) <strong class="lw io">bool</strong> {<br/>  <strong class="lw io">for</strong> item := <strong class="lw io">range</strong> s.source {<br/>    <strong class="lw io">if</strong> fn(item) {<br/>      // need to drain s.source, otherwise the previous goroutine may block<br/>      <strong class="lw io">go</strong> drain(s.source)<br/>      <strong class="lw io">return</strong> <strong class="lw io">true</strong><br/>    }<br/>  }</span><span id="f932" class="ma jw in lw b gy nj mc l md me">  <strong class="lw io">return</strong> <strong class="lw io">false</strong><br/>}</span></pre><h2 id="faea" class="ma jw in bd jx my mz dn kb na nb dp kf le nc nd kj li ne nf kn lm ng nh kr ni bi translated">不匹配</h2><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="0e0e" class="ma jw in lw b gy mb mc l md me"><strong class="lw io">func</strong> (s Stream) <strong class="lw io">NoneMatch</strong>(fn <strong class="lw io">func</strong>(item <strong class="lw io">interface</strong>{}) <strong class="lw io">bool</strong>) <strong class="lw io">bool</strong> {<br/>  <strong class="lw io">for</strong> item := <strong class="lw io">range</strong> s.source {<br/>    <strong class="lw io">if</strong> fn(item) {<br/>      // need to drain s.source, otherwise the previous goroutine may block<br/>      <strong class="lw io">go</strong> drain(s.source)<br/>      <strong class="lw io">return</strong> <strong class="lw io">false</strong><br/>    }<br/>  }</span><span id="3336" class="ma jw in lw b gy nj mc l md me">  <strong class="lw io">return</strong> <strong class="lw io">true</strong><br/>}</span></pre><h2 id="20a6" class="ma jw in bd jx my mz dn kb na nb dp kf le nc nd kj li ne nf kn lm ng nh kr ni bi translated">数量盘点计数</h2><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="836d" class="ma jw in lw b gy mb mc l md me"><strong class="lw io">func</strong> (s Stream) <strong class="lw io">Count</strong>() <strong class="lw io">int</strong> {<br/>  <strong class="lw io">var</strong> count <strong class="lw io">int</strong><br/>  <strong class="lw io">for</strong> <strong class="lw io">range</strong> s.source {<br/>    count++<br/>  }<br/>  <strong class="lw io">return</strong> count<br/>}</span></pre><h2 id="c702" class="ma jw in bd jx my mz dn kb na nb dp kf le nc nd kj li ne nf kn lm ng nh kr ni bi translated">清除完成</h2><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="62b3" class="ma jw in lw b gy mb mc l md me"><strong class="lw io">func</strong> (s Stream) <strong class="lw io">Done</strong>() {<br/>  // Drain the channel to prevent goroutine blocking leaks<br/>  drain(s.source)<br/>}</span></pre><h2 id="edb5" class="ma jw in bd jx my mz dn kb na nb dp kf le nc nd kj li ne nf kn lm ng nh kr ni bi translated">迭代所有元素</h2><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="8eb6" class="ma jw in lw b gy mb mc l md me"><strong class="lw io">func</strong> (s Stream) <strong class="lw io">ForAll</strong>(fn ForAllFunc) {<br/>  fn(s.source)<br/>}</span></pre><h2 id="8161" class="ma jw in bd jx my mz dn kb na nb dp kf le nc nd kj li ne nf kn lm ng nh kr ni bi translated">迭代每个元素</h2><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="b7b1" class="ma jw in lw b gy mb mc l md me"><strong class="lw io">func</strong> (s Stream) <strong class="lw io">ForAll</strong>(fn ForAllFunc) {<br/>  fn(s.source)<br/>}</span></pre><h1 id="c384" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">摘要</h1><p id="372e" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">核心逻辑是将通道作为管道，将数据作为流，使用并发进程不断地向通道接收/写入数据，达到异步无阻塞的效果。</p><p id="4b44" class="pw-post-body-paragraph kt ku in kv b kw mf ky kz la mg lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">回到开头提到的问题，事前实现一个流似乎非常困难，很难想象go中300+行代码就能实现如此强大的组件。</p><p id="84db" class="pw-post-body-paragraph kt ku in kv b kw mf ky kz la mg lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">这种效率的基础来自三个语言特性。</p><ul class=""><li id="7a0d" class="mk ml in kv b kw mf la mg le mm li mn lm mo lq nv mq mr ms bi translated">频道</li><li id="8631" class="mk ml in kv b kw mt la mu le mv li mw lm mx lq nv mq mr ms bi translated">并发</li><li id="d577" class="mk ml in kv b kw mt la mu le mv li mw lm mx lq nv mq mr ms bi translated">函数式编程</li></ul><h1 id="b8e7" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">参考</h1><p id="d6d9" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated"><a class="ae nw" href="https://go.dev/blog/pipelines" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io">管道格局</strong> </a></p><p id="10c2" class="pw-post-body-paragraph kt ku in kv b kw mf ky kz la mg lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated"><a class="ae nw" href="https://github.com/golang/go/wiki/SliceTricks#reversing" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io">切片反转算法</strong> </a></p><h1 id="cbfc" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">项目地址</h1><p id="7334" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated"><a class="ae nw" href="https://github.com/zeromicro/go-zero" rel="noopener ugc nofollow" target="_blank"><strong class="kv io">https://github.com/zeromicro/go-zero</strong></a></p><p id="750a" class="pw-post-body-paragraph kt ku in kv b kw mf ky kz la mg lc ld le mh lg lh li mi lk ll lm mj lo lp lq ig bi translated">欢迎用<code class="fe ns nt nu lw b">go-zero</code>和<strong class="kv io">明星</strong>来支持我们！</p></div></div>    
</body>
</html>