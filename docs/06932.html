<html>
<head>
<title>JS Series#8: Arrays in JS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JS 系列# 8:JS 中的数组</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/js-series-8-arrays-in-js-41fc9f443cf7?source=collection_archive---------11-----------------------#2022-02-12">https://blog.devgenius.io/js-series-8-arrays-in-js-41fc9f443cf7?source=collection_archive---------11-----------------------#2022-02-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="29af" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">数据收集</h2></div><p id="393e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">到目前为止，大多数人都很熟悉简单的类型，如数字、字符串、用于处理单个值的布尔值。但是在实型应用程序中，我们必须处理更复杂的数据组织。使用数组来组织多个数据元素。</p><blockquote class="ky kz la"><p id="96ea" class="kc kd lb ke b kf kg jo kh ki kj jr kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">数组是值的有序集合… <br/> 1。购物车中的产品列表<br/> 2。播放列表中的歌曲</p></blockquote><p id="86b3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要理解这些数组，请参见下面的药丸容器，其中包含从一周的第一天(星期日)到一周的最后一天(星期六)每天的药丸。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/a90810262c0b66c70d833ab5ec9f3ef5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C7TXqfDkKTGf8ZCjaPARdQ.jpeg"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">数组中的数据组织</figcaption></figure><h2 id="167f" class="lv lw in bd lx ly lz dn ma mb mc dp md kl me mf mg kp mh mi mj kt mk ml mm mn bi translated">创建数组</h2><pre class="lg lh li lj gt mo mp mq mr aw ms bi"><span id="8f05" class="lv lw in mp b gy mt mu l mv mw">// To make an empty array<br/>let employees = [];</span><span id="ac94" class="lv lw in mp b gy mx mu l mv mw">// Array of strings<br/>let cars = ['BMW','VW','OODI'];</span><span id="772b" class="lv lw in mp b gy mx mu l mv mw">// Array of numbers<br/>let numbers = [95,88,30,99,65];</span><span id="c5e1" class="lv lw in mp b gy mx mu l mv mw">// Mixed array<br/>let employeeInfo = ['Alex',10000,'HR'];</span></pre></div><div class="ab cl my mz hr na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ig ih ii ij ik"><h1 id="06cb" class="nf lw in bd lx ng nh ni ma nj nk nl md jt nm ju mg jw nn jx mj jz no ka mm np bi translated">数组被索引</h1><p id="f001" class="pw-post-body-paragraph kc kd in ke b kf nq jo kh ki nr jr kk kl ns kn ko kp nt kr ks kt nu kv kw kx ig bi translated">每个数组项都有一个从 0 开始的相关位置索引。这意味着第一个元素的索引为 0，第二个元素的索引为 1，依此类推，这表明数组是有序集合。</p><pre class="lg lh li lj gt mo mp mq mr aw ms bi"><span id="4ba5" class="lv lw in mp b gy mt mu l mv mw">let colors = ['Red', 'Green', 'Blue', 'Yellow', 'Pink', 'Black'];</span><span id="1ae9" class="lv lw in mp b gy mx mu l mv mw">console.log(colors.length) // 6</span><span id="9030" class="lv lw in mp b gy mx mu l mv mw">console.log(colors[0]) // Red</span><span id="758a" class="lv lw in mp b gy mx mu l mv mw">console.log(colors[1]) // Green</span><span id="0989" class="lv lw in mp b gy mx mu l mv mw">console.log(colors[5]) // Black</span><span id="b00c" class="lv lw in mp b gy mx mu l mv mw">console.log(colors[6]) // undefined</span><span id="221a" class="lv lw in mp b gy mx mu l mv mw">console.log(colors[100]) // undefined</span></pre><h2 id="5235" class="lv lw in bd lx ly lz dn ma mb mc dp md kl me mf mg kp mh mi mj kt mk ml mm mn bi translated">访问最后一个元素</h2><pre class="lg lh li lj gt mo mp mq mr aw ms bi"><span id="2e1c" class="lv lw in mp b gy mt mu l mv mw">let colors = ['Red', 'Green', 'Blue', 'Yellow', 'Pink', 'Black'];</span><span id="6aee" class="lv lw in mp b gy mx mu l mv mw"><strong class="mp io">Step-1: </strong>Get the array length<br/>   <strong class="mp io">colors.length</strong> // 6 - Returns the array size</span><span id="fd56" class="lv lw in mp b gy mx mu l mv mw"><strong class="mp io">Step-2:</strong> Convert length to the last index as index start with 0.<br/>   <strong class="mp io">colors.length - 1</strong> // 5, Last index of array</span><span id="d8e9" class="lv lw in mp b gy mx mu l mv mw"><strong class="mp io">Step-3: </strong>Get the last element from the array<br/>    <strong class="mp io">colors[ colors.length - 1] </strong>// Black</span></pre><h2 id="6861" class="lv lw in bd lx ly lz dn ma mb mc dp md kl me mf mg kp mh mi mj kt mk ml mm mn bi translated">修改数组</h2><pre class="lg lh li lj gt mo mp mq mr aw ms bi"><span id="c46e" class="lv lw in mp b gy mt mu l mv mw">let colors = ['Red', 'Blue', 'Green']</span><span id="4fb2" class="lv lw in mp b gy mx mu l mv mw">colors[2] = 'Lime'</span><span id="b705" class="lv lw in mp b gy mx mu l mv mw">console.log(colors) // ['Red', 'Blue', 'Lime']</span><span id="4fef" class="lv lw in mp b gy mx mu l mv mw">console.log(colors[3]) // undefined</span><span id="3995" class="lv lw in mp b gy mx mu l mv mw">colors[3] = 'Black' // ['Red', 'Blue', 'Lime', 'Black']</span></pre><h2 id="7d9a" class="lv lw in bd lx ly lz dn ma mb mc dp md kl me mf mg kp mh mi mj kt mk ml mm mn bi translated">将元素添加到数组的末尾</h2><pre class="lg lh li lj gt mo mp mq mr aw ms bi"><span id="94db" class="lv lw in mp b gy mt mu l mv mw">let shoppingCart = [];</span><span id="749b" class="lv lw in mp b gy mx mu l mv mw">shoppingCart[0] = 'Mobile'<br/>shoppingCart[1] = 'Earpods'</span><span id="1b17" class="lv lw in mp b gy mx mu l mv mw">console.log(shoppingCart) // [Mobile, Earpods]</span><span id="ab3b" class="lv lw in mp b gy mx mu l mv mw"><strong class="mp io">// Adding element to the end of the array</strong></span><span id="97df" class="lv lw in mp b gy mx mu l mv mw">shoppingCart[shoppingCart.length] = 'Mobile Case'<br/>shoppingCart[shoppingCart.length] = 'Jeans'</span></pre><h1 id="8848" class="nf lw in bd lx ng nv ni ma nj nw nl md jt nx ju mg jw ny jx mj jz nz ka mm np bi translated">引用类型简介</h1><p id="26dc" class="pw-post-body-paragraph kc kd in ke b kf nq jo kh ki nr jr kk kl ns kn ko kp nt kr ks kt nu kv kw kx ig bi translated">我们都知道原始类型。每当我们创建一个原始变量时，都会在内存中创建一个空间来存储二进制等值。见下图…</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi oa"><img src="../Images/c2698ac2844a58b09ed1e390a98e3fb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vgdwU0_MstEV3mz0ZecL1w.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">内存中的原始变量</figcaption></figure><p id="f395" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对变量的任何更改都将被更新。先前保留的内存位置中的值意味着该值将在内存中被更新。</p><pre class="lg lh li lj gt mo mp mq mr aw ms bi"><span id="6516" class="lv lw in mp b gy mt mu l mv mw">// Creates new variable in memory with label fruit<br/>let fruit = 'Orange'</span><span id="478e" class="lv lw in mp b gy mx mu l mv mw">// Create another variable color with same value of fruit<br/>let color = fruit</span><span id="0095" class="lv lw in mp b gy mx mu l mv mw">console.log(fruit + " - " + color) // Orange Orange</span><span id="a205" class="lv lw in mp b gy mx mu l mv mw">// Update value of color variable<br/>color = 'Red'</span><span id="8fc5" class="lv lw in mp b gy mx mu l mv mw">// Notice only color variable's value is changed<br/>console.log(fruit + " - " + color) // Orange Red</span></pre><p id="a714" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于<code class="fe ob oc od mp b">primitive</code>变量直接将值存储在内存中，所以它们被称为<code class="fe ob oc od mp b">Value Type Variable</code>。</p><p id="8d5d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ob oc od mp b">primitive</code>值总是按照<code class="fe ob oc od mp b">LIFO</code>(后进先出)的顺序存储在内存的<code class="fe ob oc od mp b">Stack</code>中。</p><p id="f2cf" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是如果我们将<code class="fe ob oc od mp b">array</code>和<code class="fe ob oc od mp b">object</code>作为类型来讨论，它们与<code class="fe ob oc od mp b">primitive</code>类型不同，因为它们不直接在内存中存储值。</p><p id="4025" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">创建数组时，数组内存不包含数组值。数组值存储在内存中的其他地方，数组变量包含数组值的引用(地址),如下图所示。</p><pre class="lg lh li lj gt mo mp mq mr aw ms bi"><span id="1635" class="lv lw in mp b gy mt mu l mv mw">let nums = [1,2,3,4,5] /* Creates an array and save the reference(address) of array into a variable called nums.*/</span></pre><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi oe"><img src="../Images/3c4cfcd0a1621145fc562a5bb921f3a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9sHCsKc_NsqTHcZFUDzXzg.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">内存中的数组存储</figcaption></figure><p id="cef5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当一个数组被复制到另一个变量中时，只复制数组引用，而不是复制所有的数组值。</p><pre class="lg lh li lj gt mo mp mq mr aw ms bi"><span id="6300" class="lv lw in mp b gy mt mu l mv mw">let otherNums = nums // copy array into another array</span></pre><p id="6e71" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于只复制数组的引用，所以通过任何引用变量对数组值的任何更改都可以被两个数组变量看到。</p><p id="b1ce" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">看看下面的例子，如果我们改变<code class="fe ob oc od mp b">otherNums </code>数组，它也会影响<code class="fe ob oc od mp b">nums</code>数组，因为两者都引用相同的数组值。</p><pre class="lg lh li lj gt mo mp mq mr aw ms bi"><span id="128f" class="lv lw in mp b gy mt mu l mv mw">otherNums[3] = 11 // update the 4th value of array</span><span id="333e" class="lv lw in mp b gy mx mu l mv mw">console.log(nums) // [1,2,3,11,5]</span><span id="6c0c" class="lv lw in mp b gy mx mu l mv mw">console.log(otherNums) // [1,2,3,11,5]</span></pre><p id="d8f0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以数组和对象被称为<code class="fe ob oc od mp b">Reference Types</code>。</p><p id="6ff6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">看下面完整的例子…</p><pre class="lg lh li lj gt mo mp mq mr aw ms bi"><span id="7e09" class="lv lw in mp b gy mt mu l mv mw">let nums = [1,2,3,4,5]</span><span id="6d6f" class="lv lw in mp b gy mx mu l mv mw">let otherNums = nums // Copy reference of array</span><span id="9471" class="lv lw in mp b gy mx mu l mv mw">console.log(nums) // [1,2,3,4,5]<br/>console.log(otherNums) // [1,2,3,4,5]</span><span id="7caf" class="lv lw in mp b gy mx mu l mv mw">otherNums[3] = 11 // Update values</span><span id="fd1b" class="lv lw in mp b gy mx mu l mv mw">console.log(nums) // [1,2,3,11,5]<br/>console.log(otherNums) // [1,2,3,11,5]</span></pre><p id="dc5a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ob oc od mp b">Reference types</code>仅在创建数组或对象的克隆时起作用。具有相同值的数组不会创建引用副本。看下面的例子…</p><pre class="lg lh li lj gt mo mp mq mr aw ms bi"><span id="5714" class="lv lw in mp b gy mt mu l mv mw">let arr1 = [1,2,3,4,5]</span><span id="7a8c" class="lv lw in mp b gy mx mu l mv mw">let arr2 = [1,2,3,4,5]</span><span id="3fe5" class="lv lw in mp b gy mx mu l mv mw">console.log(arr1) // [1,2,3,4,5]<br/>console.log(arr2) // [1,2,3,4,5]</span><span id="ef33" class="lv lw in mp b gy mx mu l mv mw">arr1[2] = 0<br/>console.log(arr1) // [1,2,0,4,5]<br/>console.log(arr2) // [1,2,3,4,5]</span></pre><p id="19f3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如上例所示，<code class="fe ob oc od mp b">arr1</code>的变化不会影响<code class="fe ob oc od mp b">arr2</code>，因为两者都存储在不同的内存位置。</p></div><div class="ab cl my mz hr na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ig ih ii ij ik"><h1 id="d520" class="nf lw in bd lx ng nh ni ma nj nk nl md jt nm ju mg jw nn jx mj jz no ka mm np bi translated">对数组使用常量</h1><p id="7a24" class="pw-post-body-paragraph kc kd in ke b kf nq jo kh ki nr jr kk kl ns kn ko kp nt kr ks kt nu kv kw kx ig bi translated">正如我们所知，数组不存储值，它只存储数组引用。</p><pre class="lg lh li lj gt mo mp mq mr aw ms bi"><span id="ccbd" class="lv lw in mp b gy mt mu l mv mw">let fruits = ['Apple','Grapes','Banana']</span><span id="664d" class="lv lw in mp b gy mx mu l mv mw">console.log(fruits) // [Apple, Grapes, Banana]</span></pre><p id="a762" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的例子中，创建了一个<code class="fe ob oc od mp b">fruits</code>变量，它包含了对<code class="fe ob oc od mp b">['Apple','Grapes','Banana']</code>数组值的引用。</p><p id="2d94" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，在数组操作过程中，我们通常会更改数组值，如下所示…</p><pre class="lg lh li lj gt mo mp mq mr aw ms bi"><span id="eb65" class="lv lw in mp b gy mt mu l mv mw">fruits.push('papaya') // Adding new item in fruits</span><span id="069e" class="lv lw in mp b gy mx mu l mv mw">console.log(fruits) // [Apple,Grapes,Banana,papaya]</span></pre><p id="82bb" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是由于我们已经用<code class="fe ob oc od mp b">let</code>关键字定义了<code class="fe ob oc od mp b">fruits</code>数组，所以允许改变引用，并且<code class="fe ob oc od mp b">fruits</code>变量可以被赋予另一个数组引用，如下例所示…</p><pre class="lg lh li lj gt mo mp mq mr aw ms bi"><span id="6f4f" class="lv lw in mp b gy mt mu l mv mw">fruits = ['BMW','VW','Maruti','Toyoto']</span><span id="9a42" class="lv lw in mp b gy mx mu l mv mw">console.log(fruits) // [BMW,VW,Maruti,Toyoto]</span></pre><p id="df7b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以在上面的例子中，<code class="fe ob oc od mp b">fruits</code>被赋予了包含汽车的新数组值，这在概念上是错误的。</p><p id="77dd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以通过用<code class="fe ob oc od mp b">const</code>关键字创建一个变量来防止这种行为，因为 const 不允许变量一旦创建就改变。</p><pre class="lg lh li lj gt mo mp mq mr aw ms bi"><span id="c746" class="lv lw in mp b gy mt mu l mv mw">const fruits = ['Apple','Banana','Grapes']</span><span id="121b" class="lv lw in mp b gy mx mu l mv mw">console.log(fruits) // [Apple, Banana, Grapes]</span><span id="233a" class="lv lw in mp b gy mx mu l mv mw">fruits.push('Orange') </span><span id="4ebb" class="lv lw in mp b gy mx mu l mv mw">console.log(fruits) // [Apple, Banana, Grapes, Orange]</span><span id="7aa0" class="lv lw in mp b gy mx mu l mv mw">fruits = ['BMW','VW','Maruti'] /* Error, as array is const and reference can't be changed. */</span></pre></div><div class="ab cl my mz hr na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ig ih ii ij ik"><p id="afad" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你喜欢这篇文章，请关注我:</p><p id="2968" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">中:</strong><a class="ae of" href="https://medium.com/@maheshshittlani" rel="noopener">https://medium.com/@maheshshittlani</a><br/><strong class="ke io">Github:</strong><a class="ae of" href="https://github.com/maheshshittlani" rel="noopener ugc nofollow" target="_blank">https://github.com/maheshshittlani</a><br/><strong class="ke io">LinkedIn:</strong><a class="ae of" href="https://in.linkedin.com/in/mahesh-shittlani-638b7429" rel="noopener ugc nofollow" target="_blank">https://in.linkedin.com/in/mahesh-shittlani-638b7429</a></p></div></div>    
</body>
</html>