<html>
<head>
<title>Dependency Inversion Principle in C++ | SOLID as a Rock</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++ |固体如岩石中的从属反演原理</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/dependency-inversion-principle-in-c-solid-as-a-rock-79c3d86b9adc?source=collection_archive---------39-----------------------#2020-06-08">https://blog.devgenius.io/dependency-inversion-principle-in-c-solid-as-a-rock-79c3d86b9adc?source=collection_archive---------39-----------------------#2020-06-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/9423a8e58090bd6ccb10a858c9c8d763.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*aNoOf-0EkjFUUEKto8mpWA.jpeg"/></div></figure><p id="0541" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">D</strong>dependency<strong class="jt io">I</strong>inversion<strong class="jt io">P</strong>principle(在 C++中)是 SOLID as a Rock 设计原则系列的第五个&amp;最后一个设计原则。坚实的设计原则集中于开发易于维护、可重用和可扩展的软件。在本文中，我们将看到一个带有流程&amp;的示例代码，它在 DIP 的帮助下得到纠正。我们还将在文章的结尾看到指南&amp;DIP 的好处。</p><blockquote class="kp kq kr"><p id="88b9" class="jr js ks jt b ju jv jw jx jy jz ka kb kt kd ke kf ku kh ki kj kv kl km kn ko ig bi translated"><em class="in"> /！\:原载@</em><a class="ae kw" href="http://www.vishalchovatiya.com/category/design-patterns/" rel="noopener ugc nofollow" target="_blank"><em class="in"/></a><em class="in">。</em></p></blockquote><p id="667f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">顺便说一句，如果你还没有浏览过我以前关于设计原则的文章，下面是快速链接:</p><ol class=""><li id="322e" class="kx ky in jt b ju jv jy jz kc kz kg la kk lb ko lc ld le lf bi translated"><a class="ae kw" href="http://www.vishalchovatiya.com/single-responsibility-principle-in-cpp-solid-as-a-rock/" rel="noopener ugc nofollow" target="_blank"> <strong class="jt io"> S </strong> RP —单一责任原则</a></li><li id="d7e0" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lc ld le lf bi translated"><a class="ae kw" href="http://www.vishalchovatiya.com/open-closed-principle-in-cpp-solid-as-a-rock/" rel="noopener ugc nofollow" target="_blank"> <strong class="jt io"> O </strong> CP —开启/关闭原理</a></li><li id="83df" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lc ld le lf bi translated"><a class="ae kw" href="http://www.vishalchovatiya.com/liskovs-substitution-principle-in-cpp-solid-as-a-rock/" rel="noopener ugc nofollow" target="_blank">T23】LSP—利斯科夫替代原理</a></li><li id="b0cd" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lc ld le lf bi translated"><a class="ae kw" href="http://www.vishalchovatiya.com/interface-segregation-principle-in-cpp-solid-as-a-rock/" rel="noopener ugc nofollow" target="_blank"> <strong class="jt io"> I </strong> SP —界面偏析原理</a></li><li id="3ecf" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lc ld le lf bi translated"><a class="ae kw" href="http://www.vishalchovatiya.com/dependency-inversion-principle-in-cpp-solid-as-a-rock/" rel="noopener ugc nofollow" target="_blank"> <strong class="jt io"> D </strong> IP —依赖反转原理</a></li></ol><p id="8899" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">您在这一系列文章中看到的代码片段是简化的，而不是复杂的。所以你经常看到我不使用像<code class="fe ll lm ln lo b">override</code>、<code class="fe ll lm ln lo b">final</code>、<code class="fe ll lm ln lo b">public</code>(同时继承)这样的关键字，只是为了让代码紧凑&amp;可消耗(大部分时间)在单一标准屏幕尺寸。我也更喜欢<code class="fe ll lm ln lo b">struct</code>而不是<code class="fe ll lm ln lo b">class</code>，只是为了节省代码行，有时不写<code class="fe ll lm ln lo b">public:</code>，还会故意忽略<a class="ae kw" href="http://www.vishalchovatiya.com/part-3-all-about-virtual-keyword-in-c-how-virtual-destructor-works/" rel="noopener ugc nofollow" target="_blank">虚拟析构函数</a>，构造函数<a class="ae kw" href="http://www.vishalchovatiya.com/all-about-copy-constructor-in-cpp-with-example/" rel="noopener ugc nofollow" target="_blank">，复制构造函数</a>，前缀<code class="fe ll lm ln lo b">std::</code>，删除动态内存。我也认为自己是一个务实的人，希望用尽可能简单的方式，而不是标准的方式或使用术语来传达一个想法。</p><p id="1ac8" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io"> <em class="ks">注:</em> </strong></p><ul class=""><li id="4358" class="kx ky in jt b ju jv jy jz kc kz kg la kk lb ko lp ld le lf bi translated">如果你是在这里被直接绊倒的，那么我建议你浏览一下<a class="ae kw" href="http://www.vishalchovatiya.com/what-is-design-pattern/" rel="noopener ugc nofollow" target="_blank">什么是设计模式？</a>一、哪怕是鸡毛蒜皮的小事。相信会鼓励你对这个话题进行更多的探索。</li><li id="d9fa" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lp ld le lf bi translated">您在本系列文章中遇到的所有这些代码都是使用 C++20 编译的(尽管我在大多数情况下使用了 C++17 之前的现代 C++特性)。因此，如果你无法获得最新的编译器，你可以使用已经预装了 boost 库的<a class="ae kw" href="https://wandbox.org/" rel="noopener ugc nofollow" target="_blank">https://wandbox.org/</a>。</li></ul><h1 id="391b" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">目的</h1><blockquote class="kp kq kr"><p id="e795" class="jr js ks jt b ju jv jw jx jy jz ka kb kt kd ke kf ku kh ki kj kv kl km kn ko ig bi translated"><em class="in"> = &gt;高层模块不应该依赖低层模块。两者都应该依赖于抽象。抽象不应该依赖于细节。细节应该依赖于抽象。</em></p></blockquote><ul class=""><li id="3e48" class="kx ky in jt b ju jv jy jz kc kz kg la kk lb ko lp ld le lf bi translated">上面的线一开始可能看起来很神秘，但是不要停留在这里，继续前进。你会通过例子得到它。</li></ul><p id="09b2" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">高层&amp;低层模块有哪些？</strong></p><p id="de82" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io"> <em class="ks"> = &gt; </em> </strong> <strong class="jt io">高层模块</strong> : <em class="ks">描述操作</em>本质上更抽象&amp;包含更复杂的逻辑。这些模块在我们的应用程序中编排低级模块。<br/><strong class="jt io"><em class="ks">=&gt;</em></strong><strong class="jt io">低层模块</strong> : <em class="ks">描述实现</em>更具体的&amp;个别到组件关注细节&amp;应用的更小部分。这些模块在高级模块中使用。</p><h1 id="4ffa" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">违反依赖倒置原则</h1><pre class="mo mp mq mr gt ms lo mt mu aw mv bi"><span id="04de" class="mw lr in lo b gy mx my l mz na">enum class Relationship { parent, child, sibling };</span><span id="885f" class="mw lr in lo b gy nb my l mz na">struct Person {<br/>    string      m_name;<br/>};</span><span id="c2ed" class="mw lr in lo b gy nb my l mz na">struct Relationships {      // Low-level &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;-------------------------<br/>    vector&lt;tuple&lt;Person, Relationship, Person&gt;&gt;     m_relations;</span><span id="3276" class="mw lr in lo b gy nb my l mz na">    void add_parent_and_child(const Person &amp;parent, const Person &amp;child) {<br/>        m_relations.push_back({parent, Relationship::parent, child});<br/>        m_relations.push_back({child, Relationship::child, parent});<br/>    }<br/>};</span><span id="0f5d" class="mw lr in lo b gy nb my l mz na">struct Research {           // High-level  &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;------------------------<br/>    Research(const Relationships &amp;relationships) {<br/>        for (auto &amp;&amp;[first, rel, second] : relationships.m_relations) {// Need C++17 here<br/>            if (first.m_name == "John" &amp;&amp; rel == Relationship::parent)<br/>                cout &lt;&lt; "John has a child called " &lt;&lt; second.m_name &lt;&lt; endl;<br/>        }<br/>    }<br/>};</span><span id="524f" class="mw lr in lo b gy nb my l mz na">int main() {<br/>    Person parent{"John"};<br/>    Person child1{"Chris"};<br/>    Person child2{"Matt"};</span><span id="fd56" class="mw lr in lo b gy nb my l mz na">    Relationships relationships;<br/>    relationships.add_parent_and_child(parent, child1);<br/>    relationships.add_parent_and_child(parent, child2);</span><span id="4e97" class="mw lr in lo b gy nb my l mz na">    Research _(relationships);</span><span id="f5ca" class="mw lr in lo b gy nb my l mz na">    return EXIT_SUCCESS;<br/>}</span></pre><ul class=""><li id="0c89" class="kx ky in jt b ju jv jy jz kc kz kg la kk lb ko lp ld le lf bi translated">当后来<code class="fe ll lm ln lo b">Relationships</code>的容器从<code class="fe ll lm ln lo b">vector</code>变成<code class="fe ll lm ln lo b">set</code>或任何其他容器时，你需要在许多地方改变，这不是一个很好的设计。即使仅仅是数据成员的名字，例如<code class="fe ll lm ln lo b">Relationships::m_relations</code>发生了变化，您也会发现自己破坏了代码的其他部分。</li><li id="a691" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lp ld le lf bi translated">如您所见，低级模块(即<code class="fe ll lm ln lo b">Relationships</code>)直接依赖于高级模块(即<code class="fe ll lm ln lo b">Research</code>)，这实质上违反了 DIP。</li></ul><h1 id="9c32" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">依赖性倒置原则示例</h1><ul class=""><li id="f2b8" class="kx ky in jt b ju nc jy nd kc ne kg nf kk ng ko lp ld le lf bi translated">相反，我们应该创建一个抽象，并将低级和高级模块绑定到这个抽象上。考虑以下修复:</li></ul><pre class="mo mp mq mr gt ms lo mt mu aw mv bi"><span id="a6c2" class="mw lr in lo b gy mx my l mz na">struct RelationshipBrowser {<br/>    virtual vector&lt;Person&gt; find_all_children_of(const string &amp;name) = 0;<br/>};</span><span id="d988" class="mw lr in lo b gy nb my l mz na">struct Relationships : RelationshipBrowser {     // Low-level &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;------------------------<br/>    vector&lt;tuple&lt;Person, Relationship, Person&gt;&gt;     m_relations;</span><span id="a95e" class="mw lr in lo b gy nb my l mz na">    void add_parent_and_child(const Person &amp;parent, const Person &amp;child) {<br/>        m_relations.push_back({parent, Relationship::parent, child});<br/>        m_relations.push_back({child, Relationship::child, parent});<br/>    }</span><span id="7dc8" class="mw lr in lo b gy nb my l mz na">    vector&lt;Person&gt; find_all_children_of(const string &amp;name) {<br/>        vector&lt;Person&gt; result;<br/>        for (auto &amp;&amp;[first, rel, second] : m_relations) {<br/>            if (first.name == name &amp;&amp; rel == Relationship::parent) {<br/>                result.push_back(second);<br/>            }<br/>        }<br/>        return result;<br/>    }<br/>};</span><span id="4a40" class="mw lr in lo b gy nb my l mz na">struct Research {                                // High-level &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;----------------------<br/>    Research(RelationshipBrowser &amp;browser) {<br/>        for (auto &amp;child : browser.find_all_children_of("John")) {<br/>            cout &lt;&lt; "John has a child called " &lt;&lt; child.name &lt;&lt; endl;<br/>        }<br/>    }<br/>    //  Research(const Relationships&amp; relationships)<br/>    //  {<br/>    //    auto&amp; relations = relationships.relations;<br/>    //    for (auto&amp;&amp; [first, rel, second] : relations)<br/>    //    {<br/>    //      if (first.name == "John" &amp;&amp; rel == Relationship::parent)<br/>    //      {<br/>    //        cout &lt;&lt; "John has a child called " &lt;&lt; second.name &lt;&lt; endl;<br/>    //      }<br/>    //    }<br/>    //  }<br/>};</span></pre><ul class=""><li id="027c" class="kx ky in jt b ju jv jy jz kc kz kg la kk lb ko lp ld le lf bi translated">现在不管容器的名称或容器本身在低级模块、高级模块或 DIP 之后的代码的其他部分中发生变化，都将保持不变。</li><li id="2c4f" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lp ld le lf bi translated">依赖倒置原则(DIP)表明，最灵活的系统是那些源代码依赖仅指抽象而非具体的系统。</li><li id="a430" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lp ld le lf bi translated">这就是为什么大多数有经验的开发人员使用 STL 或库函数以及通用容器的原因。甚至在适当的地方使用<code class="fe ll lm ln lo b">auto</code>关键字可能有助于用不太脆弱的代码创建通用行为。</li><li id="835c" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lp ld le lf bi translated">有许多方法可以实现 DIP，只要 C++关注大多数人使用静态多态性(即<a class="ae kw" href="http://www.vishalchovatiya.com/7-advanced-cpp-concepts-idiom-examples-you-should-know/#CRTP" rel="noopener ugc nofollow" target="_blank"> CRTP </a>除非他们需要动态的一个)，模板特殊化，<a class="ae kw" href="http://www.vishalchovatiya.com/adapter-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank">适配器设计模式</a>，<a class="ae kw" href="http://www.vishalchovatiya.com/7-advanced-cpp-concepts-idiom-examples-you-should-know/#Type-Eraser" rel="noopener ugc nofollow" target="_blank">类型擦除</a>等等。</li></ul><h1 id="99a0" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">制作依赖倒置原则(DIP)友好软件的标准</h1><ul class=""><li id="3923" class="kx ky in jt b ju nc jy nd kc ne kg nf kk ng ko lp ld le lf bi translated">如果你发现实施 DIP 很困难，那么就先设计抽象&amp;在抽象的基础上实现你的高级模块。而无需了解低级模块或其实现。因为这种流程的 DIP 也被称为<strong class="jt io"> <em class="ks">编码到</em> </strong>接口。</li><li id="0c0d" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lp ld le lf bi translated">请记住，所有低级模块/ <a class="ae kw" href="http://www.vishalchovatiya.com/memory-layout-of-cpp-object/" rel="noopener ugc nofollow" target="_blank">子类</a>都遵循<a class="ae kw" href="http://www.vishalchovatiya.com/liskovs-substitution-principle-in-cpp-solid-as-a-rock/" rel="noopener ugc nofollow" target="_blank">利斯科夫替换原则</a>。这是因为低级模块/ <a class="ae kw" href="http://www.vishalchovatiya.com/inside-the-cpp-object-model/" rel="noopener ugc nofollow" target="_blank">子类</a>将通过抽象接口使用，而不是具体的类接口。</li></ul><h1 id="8bfb" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">利益</h1><h1 id="08bd" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">= &gt;可重用性</h1><ul class=""><li id="2c4a" class="kx ky in jt b ju nc jy nd kc ne kg nf kk ng ko lp ld le lf bi translated">实际上，DIP 减少了不同代码之间的耦合。因此我们得到了可重用的代码。</li></ul><h1 id="3b16" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">= &gt;可维护性</h1><ul class=""><li id="f6d8" class="kx ky in jt b ju nc jy nd kc ne kg nf kk ng ko lp ld le lf bi translated">同样重要的是要提到改变已经实现的模块是有风险的。通过依赖抽象&amp;而不是具体的实现，我们可以通过不改变项目中的高层模块来降低风险。</li><li id="3638" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lp ld le lf bi translated">最后，当正确应用时，DIP 在我们的应用程序的整个架构级别上给我们带来了灵活性和稳定性。我们的应用程序将能够更安全地发展，变得稳定和健壮。</li></ul><h1 id="5394" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">结论</h1><p id="fc28" class="pw-post-body-paragraph jr js in jt b ju nc jw jx jy nd ka kb kc nh ke kf kg ni ki kj kk nj km kn ko ig bi translated">如你所见，我们举了一个基本的代码例子&amp;把它转换成一段可重用的、灵活的、模块化的代码。如果我必须用简单而简短的句子来总结 DIP，那么应该是这样的:</p><blockquote class="kp kq kr"><p id="bace" class="jr js ks jt b ju jv jw jx jy jz ka kb kt kd ke kf ku kh ki kj kv kl km kn ko ig bi translated"><em class="in">除非有充分的理由，否则不要直接使用具体对象。用抽象代替。</em></p></blockquote><p id="1b2b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">DIP 训练我们从行为的角度考虑类，而不是从构造或实现的角度。</p><p id="f500" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><a class="ae kw" href="http://www.vishalchovatiya.com/contact-2/" rel="noopener ugc nofollow" target="_blank">有什么建议，查询或者想说</a> <code class="fe ll lm ln lo b"><a class="ae kw" href="http://www.vishalchovatiya.com/contact-2/" rel="noopener ugc nofollow" target="_blank">Hi</a></code> <a class="ae kw" href="http://www.vishalchovatiya.com/contact-2/" rel="noopener ugc nofollow" target="_blank">？减轻压力，只需点击一下鼠标。</a> 🖱️</p></div></div>    
</body>
</html>