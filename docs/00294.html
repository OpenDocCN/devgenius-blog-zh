<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://blog.devgenius.io/a-brief-introduction-to-asynctask-in-android-with-visualize-examples-60a778de8a77?source=collection_archive---------4-----------------------#2020-05-30">https://blog.devgenius.io/a-brief-introduction-to-asynctask-in-android-with-visualize-examples-60a778de8a77?source=collection_archive---------4-----------------------#2020-05-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><p id="4d8c" class="pw-post-body-paragraph il im in io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj ig bi translated">在本文中，我将讨论线程和 AsyncTask。</p><p id="59e1" class="pw-post-body-paragraph il im in io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj ig bi translated">我假设您对线程和后台任务有基本的了解。</p><figure class="jl jm jn jo gt jp gh gi paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="gh gi jk"><img src="../Images/d5af01fdc15102ac2b118da801bcfd9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EWX3x7hQ6Xte2o8RbqysYA.jpeg"/></div></div></figure><h2 id="ef3e" class="jw jx in bd jy jz ka dn kb kc kd dp ke ix kf kg kh jb ki kj kk jf kl km kn ko bi translated">Android 中的 Thread 是什么？</h2><blockquote class="kp kq kr"><p id="2931" class="il im ks io b ip iq ir is it iu iv iw kt iy iz ja ku jc jd je kv jg jh ji jj ig bi translated"><strong class="io kw">根据文档:</strong>线程是程序中执行的线程。Java 虚拟机允许应用程序同时运行多个执行线程。</p></blockquote><figure class="jl jm jn jo gt jp gh gi paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="gh gi kx"><img src="../Images/7128d3e10768115d0fe30f5a08f40f43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KosiAesB859DvtSWdod4nA.png"/></div></div></figure><p id="6798" class="pw-post-body-paragraph il im in io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj ig bi translated"><em class="ks">一个</em> <a class="ae ky" href="https://developer.android.com/reference/java/lang/Thread" rel="noopener ugc nofollow" target="_blank"> <strong class="io kw"> <em class="ks">线程</em> </strong> </a>是一个运行程序中独立的执行路径。当一个应用程序启动时，主线程自己创建，也称为<a class="ae ky" href="https://medium.com/@devDeeJay/behind-android-ui-thread-d9701caa3319" rel="noopener"> <strong class="io kw"> <em class="ks"> UI 线程</em> </strong> </a> <em class="ks">。</em>这个 UI 线程负责你的应用程序性能，如果你用长时间运行的任务使它过载，那么它将不会响应用户输入或在屏幕上绘制，例如滚动。因此，我们需要在单独的线程上运行长时间运行的任务，我们可以创建多个线程。</p><blockquote class="kp kq kr"><p id="bfe6" class="il im ks io b ip iq ir is it iu iv iw kt iy iz ja ku jc jd je kv jg jh ji jj ig bi translated">为了保持应用程序的流畅和响应，我们必须避免使用主 UI 线程来执行任何长时间运行的任务。</p></blockquote><h2 id="ded3" class="jw jx in bd jy jz ka dn kb kc kd dp ke ix kf kg kh jb ki kj kk jf kl km kn ko bi translated">如何发现我的应用程序是否执行长时间运行的任务？</h2><p id="f158" class="pw-post-body-paragraph il im in io b ip kz ir is it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj ig bi translated">看，如果一个任务花费的时间超过<strong class="io kw"> 16 毫秒</strong>，那么它就是一个长时间运行的任务。下面列出了一些常见的长时间运行的操作</p><ol class=""><li id="c4eb" class="le lf in io b ip iq it iu ix lg jb lh jf li jj lj lk ll lm bi translated">网络运营</li><li id="554c" class="le lf in io b ip ln it lo ix lp jb lq jf lr jj lj lk ll lm bi translated">复杂而漫长的计算</li><li id="adfe" class="le lf in io b ip ln it lo ix lp jb lq jf lr jj lj lk ll lm bi translated">下载/上传文件</li><li id="32f7" class="le lf in io b ip ln it lo ix lp jb lq jf lr jj lj lk ll lm bi translated">处理数据</li><li id="1b15" class="le lf in io b ip ln it lo ix lp jb lq jf lr jj lj lk ll lm bi translated">数据库调用</li></ol><p id="6b48" class="pw-post-body-paragraph il im in io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj ig bi translated">如果我们在主 UI 线程中执行上述或任何其他长时间运行的操作，它们将在我们的应用程序中同步运行，这意味着我们的应用程序将保持无响应和挂起，换句话说，在操作完成之前，我们不能滚动或执行任何其他活动。因此，在单独的线程上调用这样的操作是非常必要的。在 Android 开发中，我们使用 AsyncTask 为这些长时间运行的操作创建单独的线程。<strong class="io kw">要了解更多关于线程的内容，请访问</strong> <a class="ae ky" href="https://developer.android.com/guide/components/processes-and-threads" rel="noopener ugc nofollow" target="_blank"> <strong class="io kw">流程和线程概述</strong> </a> <strong class="io kw">。</strong></p></div><div class="ab cl ls lt hr lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ig ih ii ij ik"><h1 id="5493" class="lz jx in bd jy ma mb mc kb md me mf ke mg mh mi kh mj mk ml kk mm mn mo kn mp bi translated"><strong class="ak">Android 中的 AsyncTask 是什么？</strong></h1><blockquote class="kp kq kr"><p id="3b81" class="il im ks io b ip iq ir is it iu iv iw kt iy iz ja ku jc jd je kv jg jh ji jj ig bi translated">根据文档:AsyncTask 旨在使用户界面线程的使用变得正确和容易。</p></blockquote><p id="e3e2" class="pw-post-body-paragraph il im in io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj ig bi translated">现在，我们对长时间运行的任务有了足够的了解。为了执行这些长时间运行的任务来保持我们的主 UI 响应，android 提供了一个名为<code class="fe mq mr ms mt b"><a class="ae ky" href="https://developer.android.com/reference/android/os/AsyncTask" rel="noopener ugc nofollow" target="_blank"><strong class="io kw">AsyncTask</strong></a></code>的类。如上所述，AsyncTask 将密集或耗时的处理从主 UI 中分离出来。</p><blockquote class="kp kq kr"><p id="e37c" class="il im ks io b ip iq ir is it iu iv iw kt iy iz ja ku jc jd je kv jg jh ji jj ig bi translated">注意:在我们的应用程序中，所有独立的线程都被称为异步的，这意味着所有独立的线程独立运行，而不是同步运行。</p></blockquote><p id="2a57" class="pw-post-body-paragraph il im in io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj ig bi translated">AsycTask 能够在运行或结束时在主 UI 线程中显示结果，这就是为什么我们使用 AsyncTask 而不是简单的线程类和<code class="fe mq mr ms mt b"><a class="ae ky" href="https://developer.android.com/reference/java/lang/Runnable" rel="noopener ugc nofollow" target="_blank"><strong class="io kw">runnable</strong></a><strong class="io kw">()</strong></code> <strong class="io kw">。</strong></p><h2 id="91ea" class="jw jx in bd jy jz ka dn kb kc kd dp ke ix kf kg kh jb ki kj kk jf kl km kn ko bi translated"><strong class="ak">创建 AsyncTask 子类:</strong></h2><p id="517c" class="pw-post-body-paragraph il im in io b ip kz ir is it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj ig bi translated">AsyncTask 是一个抽象类，这意味着您必须将其子类化才能使用它。在 Android 中，我们不能直接从后台更新主 UI，如 TextView，但<strong class="io kw"> AsyncTask </strong>有一个非常方便的方法在后台线程和<strong class="io kw">主线程</strong>之间进行通信。</p><p id="b4d2" class="pw-post-body-paragraph il im in io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj ig bi translated">AsyncTask 有 4 个方法来更新 UI 和执行后台操作。</p><ul class=""><li id="fea9" class="le lf in io b ip iq it iu ix lg jb lh jf li jj mu lk ll lm bi translated"><code class="fe mq mr ms mt b">onPreExecute()</code></li><li id="5114" class="le lf in io b ip ln it lo ix lp jb lq jf lr jj mu lk ll lm bi translated"><code class="fe mq mr ms mt b">doInBackground(parms)</code></li><li id="66e3" class="le lf in io b ip ln it lo ix lp jb lq jf lr jj mu lk ll lm bi translated"><code class="fe mq mr ms mt b">onProgressUpdate(progress)</code></li><li id="1f24" class="le lf in io b ip ln it lo ix lp jb lq jf lr jj mu lk ll lm bi translated"><code class="fe mq mr ms mt b">onPostExecute(result)</code></li></ul><p id="8ed2" class="pw-post-body-paragraph il im in io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj ig bi translated">AsycTask 方法的生命周期:</p><figure class="jl jm jn jo gt jp gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/8150187c3cb6465d2db4f10c6b645823.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*27M1aTM17XkllLJrl63NEA.png"/></div></figure><blockquote class="kp kq kr"><p id="502b" class="il im ks io b ip iq ir is it iu iv iw kt iy iz ja ku jc jd je kv jg jh ji jj ig bi translated">除了 doInBackground()其他三个方法都在主 UI 线程上。</p></blockquote><figure class="jl jm jn jo gt jp gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/44b967abc24a673e4d6d98c40718d409.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*VtzAvH3ycq-4wTc_1mr29A.png"/></div></figure><h1 id="6a99" class="lz jx in bd jy ma mx mc kb md my mf ke mg mz mi kh mj na ml kk mm nb mo kn mp bi translated"><strong class="ak">让我们简单讨论一下异步任务的方法:</strong></h1><p id="6044" class="pw-post-body-paragraph il im in io b ip kz ir is it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj ig bi translated"><strong class="io kw">考虑下面的场景</strong>:当你有长时间运行的操作，比如在应用程序中点击一个按钮来上传或下载。单击该按钮，将向服务器发出请求，然后等待响应，现在由于是单线程，直到等待响应时，您的 UI 屏幕挂起，或者换句话说，它没有响应。我们可以通过在单线程 AsyncTask 上执行它来克服这个问题，以便 UI 保持响应。</p><blockquote class="kp kq kr"><p id="0c31" class="il im ks io b ip iq ir is it iu iv iw kt iy iz ja ku jc jd je kv jg jh ji jj ig bi translated">我的重点将是阐述 AsyncTask 中使用的方法的工作原理。AsyncTask 中的参数将在本文后面讨论。</p></blockquote><ul class=""><li id="5588" class="le lf in io b ip iq it iu ix lg jb lh jf li jj mu lk ll lm bi translated"><strong class="io kw"> onPreExecute() — </strong>这个方法运行在主 UI 线程上，用于在执行后台操作之前做一些事情，比如显示任何与后台线程相关的东西。但是在我们下载文件的场景中，在开始下载之前，它会向用户显示一个空的下载文件的进度条<a class="ae ky" href="https://developer.android.com/reference/android/widget/ProgressBar" rel="noopener ugc nofollow" target="_blank">。</a></li></ul><figure class="jl jm jn jo gt jp gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/99c4b4c940d9dd93f0b8703fdc890889.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*GKctPQ0mpK-Pj-LatFHukQ.png"/></div></figure><ul class=""><li id="a6e7" class="le lf in io b ip iq it iu ix lg jb lh jf li jj mu lk ll lm bi translated"><strong class="io kw">doInBackground(parms)</strong><strong class="io kw">—</strong>这个方法被称为<strong class="io kw"> AsyncTask 的核心，</strong>它运行在一个独立于主 UI 的线程上。这是我们实现代码以执行将在单独线程上执行的工作的地方。我们不能处理任何与主线程活动/片段相关的事情，例如更新任何<strong class="io kw">文本视图</strong>、<strong class="io kw">进度条、</strong>等。在我们的场景中，文件将以这种方式请求并获得下载文件的响应。</li><li id="a7a1" class="le lf in io b ip ln it lo ix lp jb lq jf lr jj mu lk ll lm bi translated"><strong class="io kw">onProgressUpdate(progress…)—</strong>与<code class="fe mq mr ms mt b">onPreExecute(), </code>一样，该方法也在主 UI 线程上调用，我们使用它来显示当前结果，如下载任何文件时进度条的填充，如下所示，UI 在每完成 1%后更新。</li></ul><figure class="jl jm jn jo gt jp gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/f46d64cc2998cae3a05c2dd87b605724.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/1*NB4_OXpq4zhdvUqyK-kK7g.gif"/></div></figure><ul class=""><li id="055a" class="le lf in io b ip iq it iu ix lg jb lh jf li jj mu lk ll lm bi translated"><strong class="io kw"> onPostExecute(result) — </strong>此方法在 UI 线程上调用，用于在 AsyncTask 完成后更新 UI，如显示成功下载或上传文件的消息。</li></ul><figure class="jl jm jn jo gt jp gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/595b92651d11db27a78784953fe10ded.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*9GPTTmBYbZggpPvbn3_KCQ.png"/></div></figure><blockquote class="kp kq kr"><p id="b445" class="il im ks io b ip iq ir is it iu iv iw kt iy iz ja ku jc jd je kv jg jh ji jj ig bi translated">这是对 AsyncTask 工作的概述，我在其中向你展示了文件是如何在后台下载的，现在我们将继续更深入地讨论它的工作</p></blockquote><h1 id="39e9" class="lz jx in bd jy ma mx mc kb md my mf ke mg mz mi kh mj na ml kk mm nb mo kn mp bi translated">异步任务的参数:</h1><p id="41d4" class="pw-post-body-paragraph il im in io b ip kz ir is it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj ig bi translated">让我们简单讨论一下 AsyncTask 的参数。这些参数是我们想要提供给 AsyncTask 的某种信息，关于它要执行的工作。在 A、B、C 下面是我们可以提供给 AsyncTask 的三个参数。</p><pre class="jl jm jn jo gt nf mt ng nh aw ni bi"><span id="5161" class="jw jx in mt b gy nj nk l nl nm">private class MyTask extends AsyncTask&lt;A, B, C&gt; { ... }</span></pre><blockquote class="kp kq kr"><p id="dd7b" class="il im ks io b ip iq ir is it iu iv iw kt iy iz ja ku jc jd je kv jg jh ji jj ig bi translated">在记忆 AsyncTask 的这些参数时，你可能会遇到问题。不要担心，我会向你展示一些形象化的表现，这将极大地帮助你。</p></blockquote><p id="636b" class="pw-post-body-paragraph il im in io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj ig bi translated"><strong class="io kw">简单点说吧</strong></p><p id="7bfa" class="pw-post-body-paragraph il im in io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj ig bi translated">我将给出上面讨论的下载文件场景的图形表示。一个<code class="fe mq mr ms mt b">AsyncTask</code>是在后台线程中运行的后台任务。它接受一个<strong class="io kw">输入</strong>，执行<strong class="io kw">进程</strong>，并给出<strong class="io kw">输出</strong>。</p><blockquote class="kp kq kr"><p id="134b" class="il im ks io b ip iq ir is it iu iv iw kt iy iz ja ku jc jd je kv jg jh ji jj ig bi translated">ie <code class="fe mq mr ms mt b">AsyncTask&lt;Input,Progress,Output&gt;</code></p></blockquote><p id="eca9" class="pw-post-body-paragraph il im in io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj ig bi translated">在我看来，当我们试图记住<code class="fe mq mr ms mt b">AsyncTask</code>中的参数时，主要的困惑就来了。<br/>关键是<strong class="io kw">不要背</strong>。<br/>如果你能想象出你的任务真正需要做什么，那么用正确的签名写下<code class="fe mq mr ms mt b">AsyncTask</code>将是小菜一碟。<br/>只要弄清楚你的<strong class="io kw">输入</strong>、<strong class="io kw">进度、</strong>和<strong class="io kw">输出</strong>是什么，你就万事大吉了。</p><p id="ced0" class="pw-post-body-paragraph il im in io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj ig bi translated">这是上面讨论的下载文件场景的视图。</p><figure class="jl jm jn jo gt jp gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/0d1357a367452e9c2459b1b3d55750d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*eDH1kWjYE4S0N0rh5V0Nlg.png"/></div><figcaption class="no np gj gh gi nq nr bd b be z dk translated">这是 doInbackgound()方法</figcaption></figure><p id="6ecd" class="pw-post-body-paragraph il im in io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj ig bi translated">在上面你可以看到我们提供了三种不同类型的参数，或者你可以简单地说一条信息。第一个参数是字符串类型，它是文件的 URL，第二个是整数，它是进程，第三个也是字符串，它是结果。</p><blockquote class="kp kq kr"><p id="693b" class="il im ks io b ip iq ir is it iu iv iw kt iy iz ja ku jc jd je kv jg jh ji jj ig bi translated">让我们看看这些参数之间的关系:</p></blockquote><figure class="jl jm jn jo gt jp gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/c475cc0f2f4d0237b73c7afb3dd6669b.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*yLuty3QVVv6FuIPwE9NZtw.png"/></div></figure><p id="5fdc" class="pw-post-body-paragraph il im in io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj ig bi translated"><code class="fe mq mr ms mt b">doInBackground()</code>和<code class="fe mq mr ms mt b">onPostExecute()</code>、<code class="fe mq mr ms mt b">onProgressUpdate()</code>也有如下关系</p><figure class="jl jm jn jo gt jp gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/f958dd5f2f8b744c6786f3a08fc37f58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*rbbGL41P-uNmXABYhCnsyQ.png"/></div></figure><p id="0181" class="pw-post-body-paragraph il im in io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj ig bi translated">下面是这个场景的简单代码:</p><pre class="jl jm jn jo gt nf mt ng nh aw ni bi"><span id="71b1" class="jw jx in mt b gy nj nk l nl nm">DownloadTask extends AsyncTask&lt;String,Integer,String&gt;{<br/><br/>      @Override<br/>      public void onPreExecute()<br/>      {}<br/><br/>      @Override<br/>      public String doInbackGround(String... params)<br/>      {<br/>               // Download code<br/>               int downloadPerc = // calculate that<br/>               publish(downloadPerc);<br/><br/>               return "Download Success";<br/>      }<br/><br/>      @Override<br/>      public void onPostExecute(String result)<br/>      {<br/>          super.onPostExecute(result);<br/>      }<br/><br/>      @Override<br/>      public void onProgressUpdate(Integer... params)<br/>      {<br/>             // show in spinner, access UI elements<br/>      }<br/><br/>}</span></pre><p id="26e2" class="pw-post-body-paragraph il im in io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj ig bi translated">关于 AsyncTask 中的后台任务，您只需要知道这些。但是如果您有任何困惑，请访问 AsyncTask 或 StackOverFlow 这个<a class="ae ky" href="https://stackoverflow.com/questions/6053602/what-arguments-are-passed-into-asynctaskarg1-arg2-arg3" rel="noopener ugc nofollow" target="_blank">问题</a>的官方文档。</p><p id="d3ea" class="pw-post-body-paragraph il im in io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj ig bi translated"><strong class="io kw">参考文献:</strong></p><p id="bcb7" class="pw-post-body-paragraph il im in io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj ig bi translated">你可以在 android 官方文档上找到更多信息。以上图片均无版权。</p><p id="3161" class="pw-post-body-paragraph il im in io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj ig bi translated">参见我在<a class="ae ky" href="https://stackoverflow.com/users/12228296/shoaib-k" rel="noopener ugc nofollow" target="_blank"> StackOverFlow </a>上的最新问答。</p><blockquote class="kp kq kr"><p id="43da" class="il im ks io b ip iq ir is it iu iv iw kt iy iz ja ku jc jd je kv jg jh ji jj ig bi translated">版权所有</p></blockquote></div></div>    
</body>
</html>