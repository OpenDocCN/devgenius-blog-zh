<html>
<head>
<title>How to Automate End-to-end Component Tests Using JUnit + Docker + WireMock</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用JUnit + Docker + WireMock自动化端到端组件测试</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-automate-end-to-end-component-tests-using-junit-docker-wiremock-8e831fb04585?source=collection_archive---------1-----------------------#2021-11-05">https://blog.devgenius.io/how-to-automate-end-to-end-component-tests-using-junit-docker-wiremock-8e831fb04585?source=collection_archive---------1-----------------------#2021-11-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9672" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一体化自动化测试—自动环境供应+组件测试执行</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7496ce7e1310ab1ccf1ce011d8791cae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HRx97iXOJAh3H_eU"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Oleksandr Kurchev 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="34d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现代系统通常依赖于一堆软件，如数据库、消息代理和外部服务API。开发人员需要在他们的机器上安装这些软件，以便启动并运行系统进行开发和测试。然而，开发的安装和环境设置是一项繁琐的工作。在开发之前，需要在环境设置上花费精力。由于对其他软件组件的依赖，测试不能完全自动化。</p><p id="196e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将向您展示如何使用Docker和Wiremock在环境设置中运行组件/集成测试。然后，您将看到如何自动化从环境供应到测试执行的整个测试过程。</p><p id="fdf7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设您的任务是为保险索赔处理系统构建新的特性。首先，您需要建立一个本地开发环境，系统可以在这个环境中启动和运行，以便您可以检查和测试系统行为。此外，本地开发环境允许您对应用程序进行调试和故障排除。</p><p id="7bd3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该系统依赖于RabbitMQ、MongoDB和一个外部客户API服务。下图说明了启动和运行系统所需的组件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/a4e7d8204408ccbf3e68d5f837a34f89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fWEQI8LfDpsNbP2Gi7Q5Rg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">示例应用程序组件</figcaption></figure><p id="5a81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也许，作为环境准备的一部分，您可以在本地机器上安装这些组件。是的，许多人在开始应用程序开发之前就花时间在软件安装和配置上。但是，安装的软件越多，准备时间越长，效率也不高。此外，如果软件组件出了问题，比如配置错误，这也是一个令人头疼的问题。</p><h2 id="78e5" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">使用Docker容器进行本地开发</h2><p id="7ac3" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">强烈建议在docker容器上运行所需的软件组件。由于docker技术的可移植性，像数据库这样的软件是一次性的，不需要安装或升级。这是因为您可以简单地在基于特定docker映像的容器中创建一个数据库实例。需要运行特定版本的数据库？很简单，只需在另一个映射到不同端口的容器中启动docker镜像。</p><p id="7411" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大多数软件组件都可以作为docker映像获得，包括公共docker映像库中的RabbitMQ和MongoDB。因此，使用一次性docker图像要方便得多。</p><p id="5298" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于对外部API服务的依赖性，使用诸如WireMock和Mock Server之类的API模拟工具允许在没有外部API服务的情况下进行测试。下图演示了使用docker和WireMock设置本地测试环境:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/c2ce6c79553ec6f4fd4910155428a57f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Afdt3XwamOFqJ90AK67bZg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">带有Docker和WireMock的组件</figcaption></figure><h1 id="8b8e" class="ms lu iq bd lv mt mu mv ly mw mx my mb jw mz jx me jz na ka mh kc nb kd mk nc bi translated">使用Docker容器运行RabbitMQ和MongoDB</h1><p id="72ad" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">Docker允许我们在yaml文件定义中定义一个叫做docker compose的软件栈。下面的docker compose定义(docker-compose.yml)显示了保险索赔处理服务的RabbitMQ和MongoDB的软件栈。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="e164" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在终端控制台中，将目录切换到docker-compose.yml的位置，然后运行此命令以打开软件堆栈</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="7a99" class="lt lu iq ng b gy nk nl l nm nn">docker compose up</span></pre><p id="c61d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，您应该能够使用默认凭证guest/guest访问RabbitMQ管理控制台<a class="ae kv" href="http://localhost:15672" rel="noopener ugc nofollow" target="_blank"> http://localhost:15672 </a>。</p><h1 id="b803" class="ms lu iq bd lv mt mu mv ly mw mx my mb jw mz jx me jz na ka mh kc nb kd mk nc bi translated">使用WireMock为客户服务API创建存根</h1><p id="abb5" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">在没有外部API服务的情况下进行测试时，WireMock是一个了不起的工具。它为模拟API的创建提供了一种灵活的方式。测试场景模拟了3个具有不同风险属性值的客户记录，如下所示:</p><p id="b5e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该命令将WireMock作为独立进程启动，并公开端口9999</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="0709" class="lt lu iq ng b gy nk nl l nm nn">Java -jar wiremock.jar — port 9999</span></pre><p id="9ca8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">访问<a class="ae kv" href="http://wiremock.org/docs/running-standalone/" rel="noopener ugc nofollow" target="_blank"> WireMock官方网站</a>，该网站提供WireMock jar文件下载链接。</p><p id="0e6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">模拟API只是将请求映射到预定义的响应数据。下面的示例JSON文件为3个不同的客户记录设置了模拟响应。例如，当WireMock收到对Url的GET请求时，它会返回具有高风险属性的客户记录</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="45c1" class="lt lu iq ng b gy nk nl l nm nn">GET /customers/C94C6168–6AED-46F9–9BA8-AA17793D41F9</span></pre><p id="9e1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将customer JSON文件放到启动WireMock服务的当前目录下的<strong class="ky ir"> mappings </strong>文件夹中。它将根据JSON文件自动创建模拟API响应。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h1 id="41aa" class="ms lu iq bd lv mt mu mv ly mw mx my mb jw mz jx me jz na ka mh kc nb kd mk nc bi translated">针对本地环境的Spring Boot配置</h1><p id="0b53" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">在您的本地机器上运行docker容器和WireMock，使用下面的配置将Spring Boot服务连接到组件。您可以看到配置将客户API服务、Rabbitmq和MongoDB的地址指定为localhost。</p><p id="8515" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是名为“local-test”的配置文件的新配置，配置文件是application-local-test.yml，它基于Spring boot配置文件的命名约定— application-{profile name}。yml</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h1 id="d9bd" class="ms lu iq bd lv mt mu mv ly mw mx my mb jw mz jx me jz na ka mh kc nb kd mk nc bi translated">测试用例设置</h1><p id="f1ce" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">一切都准备好了。测试用例的设置非常简单。目标是在您的本地机器上启动连接到Rabbitmq、MongoDB和模拟客户服务API的应用程序。使用注释<code class="fe no np nq ng b">@SpringBootTest </code>和<code class="fe no np nq ng b">@ActiveProfiles</code>运行测试用例，使用指定的配置文件“local-test”运行整个应用程序上下文</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="161b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您有兴趣了解更多关于如何构建自动化测试用例的信息，请参考这篇文章。</p><div class="nr ns gp gr nt nu"><a rel="noopener  ugc nofollow" target="_blank" href="/java-spring-the-best-practice-of-modern-software-quality-assurance-e5aa66466627"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd ir gy z fp nz fr fs oa fu fw ip bi translated">Java Spring——现代软件质量保证的最佳实践</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">确保软件质量的全面指南</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">blog.devgenius.io</p></div></div><div class="od l"><div class="oe l of og oh od oi kp nu"/></div></div></a></div></div><div class="ab cl oj ok hu ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="ij ik il im in"><h1 id="54bf" class="ms lu iq bd lv mt oq mv ly mw or my mb jw os jx me jz ot ka mh kc ou kd mk nc bi translated">自动化Docker容器和模拟API的创建</h1><p id="c524" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">到目前为止，测试执行依赖于手工过程来创建docker compose和API模拟服务器的软件栈。这意味着测试不是完全自动化的，因此测试不能在CI/CD管道中运行，在那里过程执行应该是无人操作的。</p><p id="1add" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了使过程自动化，程序代码应该有一个可编程的接口或命令行来运行这些步骤。不用担心，docker容器可以使用<strong class="ky ir"> testcointainers </strong>库来创建，该库为容器上的操作提供Java方法调用，而模拟API可以通过WireMock提供的方法调用来动态创建。与@SpringBootTest支持的定制初始化逻辑一起，高层组件图说明了测试用例初始化过程。</p><p id="3200" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Docker容器和WireMock API是在Spring Boot应用程序启动的早期创建和初始化的。容器现在是在测试开始时创建并在测试执行结束时丢弃的一次性资源。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/b5904ff570b38b88ff3acc54a979f0bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pBJcNzrTnO5SXWSopxnJKQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">自动化流程</figcaption></figure><p id="1b6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建整个应用程序上下文，然后启动一个定制的初始化器来创建容器和WireMock服务器。一旦RabbitMQ、MongoDB和WireMock服务器启动并运行，服务的主机名和端口将被注入到Spring Boot应用程序上下文中，这样应用程序将连接到组件。由于docker容器和WireMock服务器可以启动并绑定到一个可用的端口，因此初始化过程是完全自动化的，不会与机器上现有的服务发生冲突。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/4cba68d6b249eeb5b6d42af8e53613d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mn_yV7p6NYpl5dCaHBirYg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">自动化测试组件</figcaption></figure><h2 id="3e9e" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">Maven依赖性</h2><p id="a28b" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">您需要在maven pom.xml中添加测试容器库和wiremock的依赖关系。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="76d4" class="lt lu iq ng b gy nk nl l nm nn"><strong class="ng ir"><em class="ox">&lt;</em>dependency<em class="ox">&gt;<br/>  &lt;</em>groupId<em class="ox">&gt;</em></strong>org.testcontainers<strong class="ng ir"><em class="ox">&lt;/</em>groupId<em class="ox">&gt;<br/>  &lt;</em>artifactId<em class="ox">&gt;</em></strong>junit-jupiter<strong class="ng ir"><em class="ox">&lt;/</em>artifactId<em class="ox">&gt;<br/>  &lt;</em>scope<em class="ox">&gt;</em></strong>test<strong class="ng ir"><em class="ox">&lt;/</em>scope<em class="ox">&gt;<br/>&lt;/</em>dependency<em class="ox">&gt;</em></strong></span><span id="4539" class="lt lu iq ng b gy oy nl l nm nn"><strong class="ng ir"><em class="ox">&lt;</em>dependency<em class="ox">&gt;<br/>  &lt;</em>groupId<em class="ox">&gt;</em></strong>org.testcontainers<strong class="ng ir"><em class="ox">&lt;/</em>groupId<br/>  <em class="ox">&lt;</em>artifactId<em class="ox">&gt;</em></strong>mongodb<strong class="ng ir"><em class="ox">&lt;/</em>artifactId<em class="ox">&gt;<br/>  &lt;</em>scope<em class="ox">&gt;</em></strong>test<strong class="ng ir"><em class="ox">&lt;/</em>scope<em class="ox">&gt;<br/>&lt;/</em>dependency<em class="ox">&gt;</em></strong></span><span id="25a7" class="lt lu iq ng b gy oy nl l nm nn"><strong class="ng ir"><em class="ox">&lt;</em>dependency<em class="ox">&gt;<br/>  &lt;</em>groupId<em class="ox">&gt;</em></strong>org.testcontainers<strong class="ng ir"><em class="ox">&lt;/</em>groupId<br/>  <em class="ox">&lt;</em>artifactId<em class="ox">&gt;</em></strong>rabbitmq<strong class="ng ir"><em class="ox">&lt;/</em>artifactId<em class="ox">&gt;<br/>  &lt;</em>scope<em class="ox">&gt;</em></strong>test<strong class="ng ir"><em class="ox">&lt;/</em>scope<em class="ox">&gt;<br/>&lt;/</em>dependency<em class="ox">&gt;</em></strong></span><span id="6795" class="lt lu iq ng b gy oy nl l nm nn"><strong class="ng ir"><em class="ox">&lt;</em>dependency<em class="ox">&gt;<br/>  &lt;</em>groupId<em class="ox">&gt;</em></strong>com.github.tomakehurst<strong class="ng ir"><em class="ox">&lt;/</em>groupId<em class="ox">&gt;<br/>  &lt;</em>artifactId<em class="ox">&gt;</em></strong>wiremock-jre8<strong class="ng ir"><em class="ox">&lt;/</em>artifactId<em class="ox">&gt;<br/>  &lt;</em>scope<em class="ox">&gt;</em></strong>test<strong class="ng ir"><em class="ox">&lt;/</em>scope<em class="ox">&gt;<br/>&lt;/</em>dependency<em class="ox">&gt;</em></strong></span></pre><h2 id="ad21" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">组件测试基类</h2><p id="e88a" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">整个自动化逻辑被集中到一个抽象类中，这不仅简化了环境组件供应，而且使自动化逻辑可重用。任何需要设置整个应用程序堆栈的测试类都可以从抽象类扩展，然后基类在测试用例执行之前自动启动应用程序。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h2 id="e8a8" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">组件测试上下文初始化器</h2><p id="4b7c" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">正如你在上面的<code class="fe no np nq ng b">@SpringBootTest </code>中看到的，它指的是ComponentTestContextInitializer，它由初始化的主逻辑流组成。它将作业委托给TestContainerSetup和MockAPIServerSetup，分别用于Docker容器和WireMock的初始化。一旦环境组件准备就绪，该初始化器将连接性配置注入到应用程序系统属性中，使得应用程序能够连接到新创建的docker容器和模拟API服务器。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oz"><img src="../Images/0b6a512fb28599a7739f8c7fd47e89f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fUd9EK6F4pM9i-AEF3KWLA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">组件测试上下文初始化器</figcaption></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h2 id="6550" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">码头集装箱自动化</h2><p id="15f7" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">由于testcontainers库，测试代码可以与Docker容器无缝集成。下面的示例代码演示了如何为MongoDB创建和启动一个容器。简单易懂。对于对容器的访问，<code class="fe no np nq ng b">getReplicaSetUrl() </code>方法调用返回带有端口的url，该端口是映射到27017的可用端口。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="a8ce" class="lt lu iq ng b gy nk nl l nm nn">MongoDBContainer mongoDBContainer = <br/>                    new MongoDBContainer("mongo")<br/>                    .withExposedPorts(27017);</span><span id="3839" class="lt lu iq ng b gy oy nl l nm nn">mongoDBContainer.start()</span><span id="4f17" class="lt lu iq ng b gy oy nl l nm nn">String mongoDBUrl = mongoDBContainer.getReplicaSetUrl();<br/>// return mongoDBUrl: mongodb://localhost:55009/test</span></pre><p id="e663" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了更好地管理容器初始化，我们有一个名为<strong class="ky ir"> TestContainersSetup </strong>的实用程序类，负责创建容器。然后，应用程序上下文初始化器可以调用它的方法<code class="fe no np nq ng b">initTestContainers() </code>来启动RabbitMQ和MongoDB并检索连接信息。</p><p id="1d3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">拥有这个实用程序类的好处是它简化了容器组件的管理。它可以灵活地处理容器中的变化，比如图像名称或版本的更新，甚至添加新的组件，比如MySQL，而不会影响整个测试实现。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h2 id="a7d4" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">模拟API服务器设置</h2><p id="b176" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">类似地，我们有一个用于模拟API服务器配置和模拟响应设置的实用程序类。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h2 id="89d0" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">样本测试类</h2><p id="aee4" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">最后，通过更新测试类，使其从基类扩展，从而实现自动化。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2fc5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从这个<a class="ae kv" href="https://github.com/gavinklfong/spring-junit-test-container-demo" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中获取示例实现，并运行这个命令来运行示例测试，您将看到完全自动化的软件栈创建和测试执行在运行。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="8aae" class="lt lu iq ng b gy nk nl l nm nn">mvn -Dtest=ClaimProcessingAutoEnvTest clean test</span></pre></div><div class="ab cl oj ok hu ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="ij ik il im in"><h1 id="480d" class="ms lu iq bd lv mt oq mv ly mw or my mb jw os jx me jz ot ka mh kc ou kd mk nc bi translated">最后的想法</h1><p id="f757" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">在现代软件开发过程中，大多数测试活动都被认为是自动化的。不仅测试用例的执行，而且环境的设置都应该完全自动化，这样测试就可以在CI/CD管道中运行。自动化的实现并不困难，使用Docker容器、WireMock和JUnit就可以完成这项工作。通过引用<a class="ae kv" href="https://github.com/gavinklfong/spring-junit-test-container-demo" rel="noopener ugc nofollow" target="_blank"> GitHub仓库</a>中的样本代码，它给你灵感并加速你的自动化测试实现。</p><p id="6c28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在实现自动化测试的基础上，使用Cucumber特性文件添加测试大大增强了测试场景的可读性。本文将通过示例代码向您介绍如何使用Cucumber构建自动化测试。</p><div class="nr ns gp gr nt nu"><a href="https://medium.com/devtechtoday/how-to-build-a-fully-automated-integration-test-using-cucumber-testcontainers-bba8493495cb" rel="noopener follow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd ir gy z fp nz fr fs oa fu fw ip bi translated">如何使用Cucumber + Testcontainers构建一个完全自动化的集成测试</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">让我们为一个消息驱动的系统建立一个自动化集成测试</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">medium.com</p></div></div><div class="od l"><div class="pa l of og oh od oi kp nu"/></div></div></a></div></div></div>    
</body>
</html>