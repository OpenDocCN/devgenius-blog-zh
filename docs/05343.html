<html>
<head>
<title>Redis Data structures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redis数据结构</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/redis-data-structures-de5a2eb7211f?source=collection_archive---------5-----------------------#2021-07-22">https://blog.devgenius.io/redis-data-structures-de5a2eb7211f?source=collection_archive---------5-----------------------#2021-07-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/dce38991d2233b778022d620721ee84a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jed-UVwaIqf16oq5f8ATDQ.png"/></div></div></figure><p id="358e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本系列的最后一部分，我们稍微熟悉了一下Redis是什么。Redis为我们提供了五种不同的结构，我们将在这一部分逐一探讨它们。<br/>我们的Redis服务器已经启动并运行(参考之前关于如何设置服务器的帖子)，我们将使用Redis CLI进行实践，然后我们将转移到python客户端并构建一个小项目。<br/>在开始讨论数据结构之前，需要注意的重要一点是Redis数据库中的每个条目都是{key:value}形式，其中的值可以是我们将要讨论的五种数据结构中的任何一种。Key必须是字符串格式的，但是对于value，Redis给了我们一些自由，不像它的一些对等物，比如memcache，它把值限制为字符串类型。我们开始吧。</p><h1 id="54b9" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">用线串</h1><p id="79d9" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">字符串不需要介绍，如果您曾经使用过任何编程语言，那么字符串对您来说一定很常见，在Redis中，字符串也不例外。在进入redis-cli世界时，检查服务器是否启动并提供服务。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="1c14" class="mf ku in mb b gy mg mh l mi mj">guest-c41jf8@ubuntu:~$ redis-cli<br/>127.0.0.1:6379&gt;<br/>127.0.0.1:6379&gt; PING<br/>PONG</span></pre><p id="87d6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">看起来我们准备好了。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="c7d0" class="mf ku in mb b gy mg mh l mi mj">127.0.0.1:6379&gt; set hello world<br/>OK<br/>127.0.0.1:6379&gt; get hello<br/>“world”<br/>127.0.0.1:6379&gt; del hello<br/>(integer) 1<br/>127.0.0.1:6379&gt; get hello<br/>(nil)</span></pre><p id="5001" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们在上面的命令中做了什么？首先，我们创建了一个值为“world”的键“hello ”,返回一个OK输出来表示创建成功。在使用get函数查询键“hello”时，我们返回了相应键的值，最后我们删除了该键，在再次查询键“hello”时，我们可以看到这次返回了nil，表示不存在这样的键值对。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="d8c3" class="mf ku in mb b gy mg mh l mi mj">127.0.0.1:6379&gt; append hello is <br/>(integer) 7<br/>127.0.0.1:6379&gt; get hello<br/>“worldis”</span><span id="2c9a" class="mf ku in mb b gy mk mh l mi mj">127.0.0.1:6379&gt; set counter 1<br/>OK<br/>127.0.0.1:6379&gt; incr counter<br/>(integer) 2<br/>127.0.0.1:6379&gt; get counter<br/>“2”<br/>127.0.0.1:6379&gt; incr counter<br/>(integer) 3<br/>127.0.0.1:6379&gt; get counter<br/>“3”<br/>127.0.0.1:6379&gt; decr counter<br/>(integer) 2</span><span id="4bb2" class="mf ku in mb b gy mk mh l mi mj">127.0.0.1:6379&gt; incrby counter 10<br/>(integer) 12<br/>127.0.0.1:6379&gt; decrby counter 2<br/>(integer) 10<br/>127.0.0.1:6379&gt; incr hello<br/>(error) ERR value is not an integer or out of range</span></pre><p id="ba56" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过分解上面的命令，我们得到了一个append函数，在这个函数中，我们可以将一些字符串追加到一个键的现有值中。我将“is”追加到键的“world”值中；“你好”，给了我们一个结果“世界是”的后话。Redis还为我们提供了不同的方法来处理整数，在这里我们可以增加和减少单位数量或指定数量的值。(您注意到了吗，我们在调用这些函数时得到了输出结果？).正如所料，这些函数只有在值是整数类型时才起作用，否则我们将会受到一些错误的欢迎。我们已经探索了string的一些基本命令，这里提供了每个用例的完整列表。https://redis.io/commands/#string<a class="ae ml" href="https://redis.io/commands/#string" rel="noopener ugc nofollow" target="_blank"/></p><h1 id="3d2b" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">列表</h1><p id="bcd6" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">Aaa，好的老名单。让我们把手弄脏，好吗？</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="6f89" class="mf ku in mb b gy mg mh l mi mj">127.0.0.1:6379&gt; Lpush movies arrival<br/>(integer) 1<br/>127.0.0.1:6379&gt; rpush movies titanic<br/>(integer) 2<br/>127.0.0.1:6379&gt; lpush movies ironman<br/>(integer) 3<br/>127.0.0.1:6379&gt; lrange movies 0 -1<br/>1) “ironman”<br/>2) “arrival”<br/>3) “titanic”<br/>127.0.0.1:6379&gt; lindex movies 1<br/>“arrival”<br/>127.0.0.1:6379&gt; lpop movies<br/>“ironman”<br/>127.0.0.1:6379&gt; lrange movies 0 -1<br/>1) “arrival”<br/>2) “titanic”<br/>127.0.0.1:6379&gt; rpop movies<br/>“titanic”<br/>127.0.0.1:6379&gt; lrange movies 0 -1<br/>1) “arrival”</span></pre><p id="92c1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Redis中的列表实际上是一个双面列表，我们可以从右边和左边输入元素。这里，我们创建了一个“电影”列表，并输入了几个元素。使用“lrange”我们得到列表中的所有元素，其中末尾的索引表示开始和结束位置。与列表函数类似，我们可以使用lindex获取特定索引处的元素，并从两个元素中弹出元素。请注意，我们在执行这些命令时会得到不同的输出，因为它们会对我们的用例有所帮助。</p><h1 id="21e6" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">设置</h1><p id="6227" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">集合给了我们列表所不能给的东西，不像列表，集合中的所有元素都是唯一的，但是集合是无序的，因此我们不能像在列表中那样从两端推入和弹出，我们可以简单地添加和删除元素，并保证元素是唯一的。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="cb68" class="mf ku in mb b gy mg mh l mi mj">127.0.0.1:6379&gt; sadd fruits melon<br/>(integer) 1<br/>127.0.0.1:6379&gt; sadd fruits melon<br/>(integer) 0<br/>127.0.0.1:6379&gt; sadd fruits grape<br/>(integer) 1<br/>127.0.0.1:6379&gt; srem fruits grape<br/>(integer) 1<br/>127.0.0.1:6379&gt; srem fruits grape<br/>(integer) 0<br/>127.0.0.1:6379&gt; smembers fruits<br/>1) “melon”</span></pre><p id="0f67" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">和往常一样，要注意输出，如果我们添加或删除一个已经添加或不存在的元素，我们得到的输出为0，否则为1。我们提供了一些其他选项，如并集、交集等，来处理两个或多个集合。一定要自己动手在完整的命令列表中查看它们。</p><h1 id="6eec" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">混杂</h1><p id="e781" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">哈希类似于Python中的字典。您可以将值作为键/值对存储在键中。比方说，如果你想为一个产品存储数据，让我们拿一顶帽子，那么散列将是完美的选择。我们来补充一下帽子的产品特性，好吗？</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="ee77" class="mf ku in mb b gy mg mh l mi mj">127.0.0.1:6379&gt; hset hat:1 id 34234<br/>(integer) 1<br/>127.0.0.1:6379&gt; hset hat:1 color blue<br/>(integer) 1<br/>127.0.0.1:6379&gt; hset hat:1 quantity 100<br/>(integer) 1<br/>127.0.0.1:6379&gt; hgetall hat:1<br/>1) “id”<br/>2) “34234”<br/>3) “color”<br/>4) “blue”<br/>5) “quantity”<br/>6) “100”<br/>127.0.0.1:6379&gt; hdel hat:1 color<br/>(integer) 1<br/>127.0.0.1:6379&gt; hgetall hat:1<br/>1) “id”<br/>2) “34234”<br/>3) “quantity”<br/>4) “100”</span></pre><p id="46ca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以我们为hat 'hat:1 '创建了一个键，它最初有子项、id、quanity和color。我们可以用不同的钥匙创建多个帽子，并创建关于商店出售的不同类型帽子的信息。有意思吧！</p><h1 id="e5eb" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">ZSETS</h1><p id="0679" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">最后一个数据结构，也是一个新的数据结构，是Redis特有的。与哈希类似，zset由键/值类型结构组成，但zset中的值通常被称为score，并且仅限于浮点类型。我们可以选择按排序顺序获取值。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="06aa" class="mf ku in mb b gy mg mh l mi mj">127.0.0.1:6379&gt; zadd hats 23 id<br/>(integer) 1<br/>127.0.0.1:6379&gt; zadd hats 234 id:2<br/>(integer) 1<br/>127.0.0.1:6379&gt; zrange hats 0 1<br/>1) “id”<br/>2) “1d:2”<br/>127.0.0.1:6379&gt; zrange hats 0 1 withscores<br/>1) “id”<br/>2) “23”<br/>3) “1d:2”<br/>4) “234”</span></pre><p id="957b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们创建了两个子键:id和id:2，分数分别为23和234。最后我们得到一个排序后的分数输出。如果我们试图添加一个重复的键或值，我们将不能。你自己试试。</p><p id="7f5f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我希望这让您对Redis提供的数据结构有所了解。在下一部分中，我们将从安装Redis的python客户端开始，并构建一个小项目。</p></div></div>    
</body>
</html>