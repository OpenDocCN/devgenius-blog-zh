<html>
<head>
<title>Code Golf: How (and Why) to Write “FizzBuzz” in 56 Bytes of JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Code Golf:如何(以及为什么)用 56 字节的 JavaScript 编写“FizzBuzz”</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/code-golf-how-and-why-to-write-fizzbuzz-in-56-bytes-of-javascript-17708d6ec447?source=collection_archive---------2-----------------------#2022-06-10">https://blog.devgenius.io/code-golf-how-and-why-to-write-fizzbuzz-in-56-bytes-of-javascript-17708d6ec447?source=collection_archive---------2-----------------------#2022-06-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/152bf3f383f464fc0470756e510d0b0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3gPp2xhGSSEUiKPs"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">考特尼·库克在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="d551" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://code.golf" rel="noopener ugc nofollow" target="_blank">代码高尔夫</a>是一种游戏，程序员们竞相用尽可能少的字符编写算法。参赛者可以从几十种不同的语言和许多不同的问题中进行选择，每个组合都有一个排行榜，用于将他们的结果与社区中的其他人进行比较。</p><p id="43ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将通过一个代码高尔夫游戏，用仅仅 56 个字符的用<strong class="kf ir"> JavaScript 编写<em class="lb"> FizzBuzz </em>。我们将从一个基本的、简单的解决方案开始，一步一步地努力达到 56 字节的顶级解决方案。当然有可能有一个更好的解决方案，但没有人发现，但有数百名球员在 56 分，这将是我们今天的目标。</strong></p><p id="9eef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">(以防你以前没有遇到过，<em class="lb"> FizzBuzz </em>是一个非常简单的算法，有时用于筛选面试——你可以在维基百科文章中阅读关于它的更多信息<a class="ae kc" href="https://en.wikipedia.org/wiki/Fizz_buzz" rel="noopener ugc nofollow" target="_blank">。)</a></p><h1 id="b677" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">…但首先，为什么？</h1><p id="9969" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">好吧，公平的问题——我们为什么要这么做？不用说，为 Code Golf 编写的代码不是高度可读、高质量或通用的代码——它被编写得很小，在某些情况下利用语言技巧和怪癖来实现尽可能简洁的解决方案。但是我们仍然有很多理由玩这个游戏。</p><p id="2a8d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们可能会学到一些我们已经知道的语言的新东西。例如，在这种情况下，我们将使用 JavaScript 的一些类型转换技巧来简化代码。在这样做的时候，我不得不多次查阅 JavaScript 规范和文档，以了解变化会如何表现。</p><p id="aa24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了是磨练你已经使用的语言技能的好方法外，<em class="lb"> Code Golf 还是学习一门新语言的速成班。</em>在解决 Code Golf 问题时，您可能会发现自己在查看一种语言的文档，以找出诸如“这种语言如何处理类型转换”、“支持哪种条件运算符”之类的问题。这是在浏览器中用语言解决简单问题的一种有趣的小方法。</p><p id="f9b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是除了教育方面，你应该打代码高尔夫，因为你认为它很有趣。即使从我的描述来看这听起来不好玩，我还是鼓励你试一试。一旦你进入其中，当你解决问题时，每一个小的单个字符的改进都会让你觉得很有价值。</p><h1 id="22ec" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">56 个角色的 FizzBuzz 之路</h1><p id="41e0" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">好——让我们开始吧！我的出发点总是以最明显的方式编写代码。它不需要漂亮，不需要聪明，只需要管用。让我们快速写下一个简单的解决方案，让它发挥作用。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="a151" class="mo ld iq mk b gy mp mq l mr ms"><strong class="mk ir">// 147 characters</strong><br/>for(i=1;i&lt;101;i++) {<br/>  if(i%3==0 &amp;&amp; i%5==0) print("FizzBuzz")<br/>  else if(i%3 == 0) print("Fizz")<br/>  else if(i%5 == 0) print("Buzz")<br/>  else print(i)<br/>}</span></pre><p id="7f0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了我们最初的工作解决方案，我注意到的第一件事就是所有的空白。让我们删除一部分内容，<em class="lb">但是我会在适当的位置留下足够多的空白来保留一些可读性</em>——我们将在稍后接近解决方案时删除其余的内容:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="8e2f" class="mo ld iq mk b gy mp mq l mr ms"><strong class="mk ir">// 133 characters</strong><br/>for(i=1;i&lt;101;i++){<br/> if(i%3==0&amp;&amp;i%5==0)print("FizzBuzz")<br/> else if(i%3==0)print("Fizz")<br/> else if(i%5==0)print("Buzz")<br/> else print(i)<br/>}</span></pre><p id="8a66" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一般的代码高尔夫策略之一，尤其是在问题的早期，是寻找明显的重复:在这里，我看到一些明显的重复在重复使用“打印”。让我们看看是否可以将我们打印的内容分解到一个变量中，以消除这种情况:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="8ef7" class="mo ld iq mk b gy mp mq l mr ms"><strong class="mk ir">// 122 characters</strong><br/>for(i=1;i&lt;101;i++){<br/> let j=i<br/> if(i%3==0&amp;&amp;i%5==0)j="FizzBuzz"<br/> else if(i%3==0)j="Fizz"<br/> else if(i%5==0)j="Buzz"<br/> <strong class="mk ir">print(j)</strong><br/>}</span></pre><p id="68e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我注意到的下一件事是我们逻辑流的文本量，所有的“如果”和“其他”。我认为如果我们使用 JavaScript 的三元运算符，我们可以做得更好。让我们从一个简单的用法开始，看看它看起来像什么，看看它是否有帮助:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="298f" class="mo ld iq mk b gy mp mq l mr ms"><strong class="mk ir">// 119 characters</strong><br/>for(i=1;i&lt;101;i++){<br/> let j<br/> if(i%3==0&amp;&amp;i%5==0)j="FizzBuzz"<br/> else if(i%3==0)j="Fizz"<br/> else <strong class="mk ir">j=i%5==0?"Buzz":i</strong><br/> print(j)<br/>}</span></pre><p id="6767" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是啊！Ternaries 肯定有帮助。现在，如果我们将 ternaries 嵌套在一起，并将其直接放入打印语句中，我们的得分将得到迄今为止最大的提升。下面的代码看起来很不一样，但是逻辑是一样的:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="1cbf" class="mo ld iq mk b gy mp mq l mr ms"><strong class="mk ir">// 85 characters</strong><br/>for(i=1;i&lt;101;i++){<br/> print(i%3==0&amp;&amp;i%5==0?"FizzBuzz":i%3==0?"Fizz":i%5==0?"Buzz":i)<br/>}</span></pre><p id="5659" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到目前为止，我们的逻辑实际上与我们开始时的简单 if/else 解决方案是一样的。我们只是简化和压缩了。下一步，我们将对逻辑本身进行第一次真正的更新:让我们看看是否可以减少“嘶嘶”和“嗡嗡”的重复。这将需要我们改变 4 个不同案例的流程。</p><p id="3ad6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过使用字符串连接并提取“Fizz”逻辑来实现这种重构:始终打印“Fizz”if<code class="fe mt mu mv mk b">i%3==0</code>，连接“Buzz”或数字或空字符串。我们可以在下面的伪代码中看到这个想法。我去掉了实际的条件句，只是为了了解这个想法:</p><p id="33b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mk b">print ("Fizz" or-maybe "") + ("Buzz" or-maybe i or-maybe "")</code></p><p id="df2f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种方法需要空白字符串，因为我们使用的是字符串连接。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="3d84" class="mo ld iq mk b gy mp mq l mr ms"><strong class="mk ir">// 76 characters<br/></strong>for(i=1;i&lt;101;i++){<br/> print(<strong class="mk ir">(i%3==0?"Fizz":"")+</strong>(i%5==0?"Buzz":i%3!=0?i:""))<br/>}</span></pre><p id="f779" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好吧，接下来只是一个小改进，但从一开始就一直困扰着我——<code class="fe mt mu mv mk b">i%n==0</code>可以少写一个字，我们做了几次。你明白了吗？因为我们使用了模数，我们知道结果将是正的，所以我们真的可以进行检查<code class="fe mt mu mv mk b">i%n&gt;0</code>或<code class="fe mt mu mv mk b">i%n&lt;0</code>:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="e5b5" class="mo ld iq mk b gy mp mq l mr ms"><strong class="mk ir">// 73 characters<br/></strong>for(i=1;i&lt;101;i++){<br/> print((<strong class="mk ir">i%3&lt;1</strong>?"Fizz":"")+(i%5&lt;1?"Buzz":<strong class="mk ir">i%3&gt;0</strong>?i:""))<br/>}</span></pre><p id="4f69" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里仍然有一些重复。我们看到我们做了两次<code class="fe mt mu mv mk b">i%3</code>，一次检查大于 0，一次检查小于 1。如果我们对第二个比较重新排序，我们可以将它们提取到一个变量捕获<code class="fe mt mu mv mk b">i%3&lt;1</code>！轻松取胜，对吗？</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="9cc3" class="mo ld iq mk b gy mp mq l mr ms"><strong class="mk ir">// 74 characters<br/></strong>for(let i=1;i&lt;101;i++){<br/> <strong class="mk ir">j=i%3&lt;1</strong><br/> print((j?"Fizz":"")+(i%5&lt;1?"Buzz":j?"":i))<br/>}</span></pre><p id="64a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">哎呀！我们无意中添加了一个角色！有时你看到一个重构的好主意，但结果比原来的更差。</p><p id="a920" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管如此，有时尝试这些想法是值得的，因为它们通常会带来新的视角和其他探索途径。在这种情况下，是的——它确实引出了另一条思路。让我们进一步提取，将我们的“Fizz”字符串加入到<code class="fe mt mu mv mk b">j</code>表达式中。为什么？因为这将让我们去掉上面多余的括号:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="8995" class="mo ld iq mk b gy mp mq l mr ms"><strong class="mk ir">// 73 characters</strong><br/>for(i=1;i&lt;101;i++){<br/> <strong class="mk ir">j=i%3&lt;1?"Fizz":""</strong><br/> print(i%5&lt;1?j+”Buzz”:j==''?i:j)<br/>}</span></pre><p id="6223" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们回到了之前的 73，但新的结构会让我们有更多的改进。现在<code class="fe mt mu mv mk b">j</code>要么是“Fizz ”,要么是一个空字符串:我们可以直接将它添加到我们的“Buzz”中，作为逻辑的一部分。</p><p id="05bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的下一个变化是这些 JavaScript 小惊喜之一。看到表情<code class="fe mt mu mv mk b">j==''?i:j</code>了吗？令人惊讶的是，我们可以简化这一点，这一切都与 JavaScript 如何将字符串转换为布尔值有关。你能找到它吗？</p><p id="d7ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">在 JavaScript 中，逻辑表达式中的空字符串被转换为 false，而非空字符串被转换为 true。</em>利用这个技巧，我们可以把<code class="fe mt mu mv mk b">j==''?i:j</code> (9 个字符)改写成<code class="fe mt mu mv mk b">j||i</code> (4 个字符):</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="b921" class="mo ld iq mk b gy mp mq l mr ms"><strong class="mk ir">// 68 characters</strong><br/>for(i=1;i&lt;101;i++){<br/> j=i%3&lt;1?"Fizz":""<br/> print(i%5&lt;1?j+"Buzz":<strong class="mk ir">j||i</strong>)<br/>}</span></pre><p id="724d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">精彩！既然我们已经了解了这一点，我们可以在三元运算符中利用另一种布尔转换。试着找到它。这与数字 0 如何被解释为布尔值有关:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="fbb5" class="mo ld iq mk b gy mp mq l mr ms"><strong class="mk ir">// 64 characters<br/></strong>for(i=1;i&lt;101;i++){<br/> j=i%3?"":"Fizz"<br/> print(<strong class="mk ir">i%5?j||i:j+"Buzz"</strong>)<br/>}</span></pre><p id="c4ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好的，我们越来越接近了，我们仍然有之前留下的空白。现在我们越来越接近了，让我们把它剥离出来，看看我们在哪里:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="5683" class="mo ld iq mk b gy mp mq l mr ms"><strong class="mk ir">// 60 characters</strong><br/>for(i=1;i&lt;101;i++){j=i%3?"":"Fizz";print(i%5?j||i:j+"Buzz")}</span></pre><p id="48ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只差 4 个字符就解决了！</p><p id="96ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看起来不错，但你知道我在烦什么吗？那些花括号<code class="fe mt mu mv mk b">{}</code>！我们能摆脱这些吗？如果我们能以某种方式将两行合并成一条语句，我们就可以去掉大括号…</p><p id="9699" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">事实证明我们可以——利用您在简化的 JavaScript 代码中经常看到的技巧:<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator" rel="noopener ugc nofollow" target="_blank">JavaScript 逗号运算符</a>允许您将多个表达式组合成一个表达式:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="3b70" class="mo ld iq mk b gy mp mq l mr ms"><strong class="mk ir">// 58 characters</strong><br/>for(i=1;i&lt;101;i++)j=i%3?"":"Fizz",print(i%5?j||i:j+"Buzz")</span></pre><p id="3e60" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们如此接近，现在我们可以品尝它！我们需要做的最后一个优化是一个棘手的优化，但是这里有一个提示:一个典型的 JavaScript for-loop 可以写成<code class="fe mt mu mv mk b">for(i=0;i&lt;100;i++) ...</code>，但是没有理由它必须遵循这种格式。for 循环真正的意思是<code class="fe mt mu mv mk b">for(initializer; condition; increment) ...</code>，这里的三个表达式实际上可以是<em class="lb">任何东西。</em></p><p id="401c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没有什么强迫我们在我们的<code class="fe mt mu mv mk b">increment</code>表达式中遵循<code class="fe mt mu mv mk b">i++</code>的格式，即使这是最常见的事情。没有理由我们不能在其他地方执行我们的增量:我们可以把我们的<code class="fe mt mu mv mk b">++</code>放在其他的<code class="fe mt mu mv mk b">i</code>上。通过这样做，我们 1)为<code class="fe mt mu mv mk b">I</code>本身去掉了一个字符，2)可以将我们的一个语句移到循环内部，并去掉逗号！</p><p id="04d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们开始吧:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="474e" class="mo ld iq mk b gy mp mq l mr ms"><strong class="mk ir">// 56 characters - but oops!  Doesn't work!<br/></strong>for(i=1;i++&lt;101;j=i%3?"":"Fizz")print(i%5?j||i:j+"Buzz")</span><span id="f91a" class="mo ld iq mk b gy mw mq l mr ms"><strong class="mk ir"><em class="lb">unnamed:1: ReferenceError: j is not defined</em></strong><em class="lb"><br/>for(i=1;i++&lt;101;j=i%3?"":"Fizz")print(i%5?j||i:j+"Buzz")<br/>                                          ^</em></span></pre><p id="e438" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我首先尝试的——将<code class="fe mt mu mv mk b">j</code>初始化移到迭代器中，但是它给出了一个错误！这是因为迭代器在每个循环的之后运行<em class="lb">，所以尽管这是违反直觉的，我们还是需要将<em class="lb">打印语句</em>放在迭代器中，然后进行<code class="fe mt mu mv mk b">j</code>初始化！</em></p><p id="4489" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在移动了我们的代码之后，还有一个调整(从 0 开始计数，而不是从 1 到 100，因为我们现在是预递增的):</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="4a28" class="mo ld iq mk b gy mp mq l mr ms"><strong class="mk ir">// 56 characters - the solution!</strong><br/>for(i=0;i++&lt;100;print(i%5?j||i:j+"Buzz"))j=i%3?"":"Fizz"</span></pre><p id="8bfd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，一步一步来，我们找到了解决方案。在这个过程中，我们利用了一些 JavaScript 的怪癖，甚至浏览了几次文档来学习新的东西。</p><h1 id="e7b9" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">试试看！</h1><p id="4ecb" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">如果你觉得这个演练很有娱乐性或教育性，我鼓励你亲自尝试一下<a class="ae kc" href="https://code.golf" rel="noopener ugc nofollow" target="_blank"> Code Golf </a>。有如此多的语言和问题组合可供选择，很容易找到合适的挑战水平。我用你最喜欢的语言推荐<a class="ae kc" href="https://code.golf/rankings/holes/99-bottles-of-beer/all/bytes" rel="noopener ugc nofollow" target="_blank"> 99 瓶啤酒</a>，或者尝试用另一种语言的<a class="ae kc" href="https://code.golf/rankings/holes/fizz-buzz/all/bytes" rel="noopener ugc nofollow" target="_blank"> FizzBuzz </a>，并使用本文中的一些技巧和技术来完成它。</p><p id="27d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb"> Jonathan 在大大小小的创业公司中拥有超过 20 年的工程领导经验。</em></p></div></div>    
</body>
</html>