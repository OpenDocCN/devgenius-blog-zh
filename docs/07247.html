<html>
<head>
<title>Self-Join and Cross Join in Pandas DataFrame</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Pandas 数据框架中的自连接和交叉连接</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/self-join-and-cross-join-in-pandas-dataframe-b30bfbc0e52a?source=collection_archive---------1-----------------------#2022-03-09">https://blog.devgenius.io/self-join-and-cross-join-in-pandas-dataframe-b30bfbc0e52a?source=collection_archive---------1-----------------------#2022-03-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/df93a67750b88d17813fed477d50cc88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AdYGuflhLEHaDQzDZgXe8w.jpeg"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">照片由<a class="ae ja" href="https://unsplash.com/s/photos/anastasia-zhenin" rel="noopener ugc nofollow" target="_blank"> Anastasia Zhenin </a>在<a class="ae ja" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><div class=""/><p id="6d71" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">继上一篇关于使用<a class="ae ja" href="https://medium.com/dev-genius/pandas-dataframe-combine-function-b0278f8f9d7" rel="noopener">合并函数</a>合并数据帧的教程之后，我们将着眼于鲜为人知的连接形式。</p><p id="ed72" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">SQL 中最流行的一个<code class="fe ky kz la lb b">JOIN</code>，用于根据相关的列或索引组合两个或更多表中的行/列。然而，有不同种类的连接，pandas 提供了各种轻松组合系列或数据帧的方法。以下是连接的类型:</p><ul class=""><li id="1e33" class="lc ld jd kc b kd ke kh ki kl le kp lf kt lg kx lh li lj lk bi translated">内部连接</li><li id="28a2" class="lc ld jd kc b kd ll kh lm kl ln kp lo kt lp kx lh li lj lk bi translated">完全连接</li><li id="4afa" class="lc ld jd kc b kd ll kh lm kl ln kp lo kt lp kx lh li lj lk bi translated">左连接</li><li id="2822" class="lc ld jd kc b kd ll kh lm kl ln kp lo kt lp kx lh li lj lk bi translated">右连接</li><li id="6aac" class="lc ld jd kc b kd ll kh lm kl ln kp lo kt lp kx lh li lj lk bi translated">自连接</li><li id="2600" class="lc ld jd kc b kd ll kh lm kl ln kp lo kt lp kx lh li lj lk bi translated">交叉连接</li></ul><p id="acf2" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如前所述，本教程将关注<strong class="kc je">自连接</strong>和<strong class="kc je">交叉连接</strong>以及它们在 Pandas DataFrame 中的执行。</p><p id="cc86" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对用于连接的各种 Pandas 函数的语法和参数描述的细节。熊猫。数据帧合并、连接、连接和比较广泛涵盖了 Pandas 中的大部分功能。</p></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><h1 id="08ae" class="lx ly jd bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">自连接</h1><p id="7064" class="pw-post-body-paragraph ka kb jd kc b kd mv kf kg kh mw kj kk kl mx kn ko kp my kr ks kt mz kv kw kx ig bi translated">自联接是将数据帧联接到自身的常规联接。自联接通常用于查询分层数据集或比较同一数据帧中的行。</p><h2 id="6c11" class="na ly jd bd lz nb nc dn md nd ne dp mh kl nf ng ml kp nh ni mp kt nj nk mt nl bi translated">示例 1:查询分层数据框架</h2><p id="ab9c" class="pw-post-body-paragraph ka kb jd kc b kd mv kf kg kh mw kj kk kl mx kn ko kp my kr ks kt mz kv kw kx ig bi translated">假设我们有下表，它代表了一个公司的组织结构。<code class="fe ky kz la lb b">manager_id</code>列引用了<code class="fe ky kz la lb b">employee_id</code>列。这显示了谁对一个员工负责，或者一个员工向哪个经理报告。</p><figure class="nn no np nq gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nm"><img src="../Images/e0fb519d0c7fe5e16e083b0c6459c5fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xH9xzA38PaI_0CDgFVV6ug.png"/></div></div></figure><p id="d6a6" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了获得雇员向谁报告，我们可以使用<code class="fe ky kz la lb b">Self-join</code>来查询该表。</p><figure class="nn no np nq gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nr"><img src="../Images/773832b90720f8dd7591b50940f80e20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SadPawC8V-At87Yw6VPFYA.png"/></div></div></figure><p id="be7c" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们首先将新的数据帧命名为<code class="fe ky kz la lb b">df_managers</code>。然后，我们将<code class="fe ky kz la lb b">df_managers</code>数据帧连接到自身。第二次连接的<code class="fe ky kz la lb b">manager_id</code>被删除，以便使用<code class="fe ky kz la lb b">pandas.DataFrame.join()</code>功能。</p><p id="f045" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用<code class="fe ky kz la lb b">how='left'</code>来捕获最高层管理人员的详细信息。她的<code class="fe ky kz la lb b">manager_id</code>是个<code class="fe ky kz la lb b">NaN</code>。然而，如果我们想要一个不包括最顶层管理器的数据帧，我们可以将其更改为<code class="fe ky kz la lb b">how='inner'</code>。</p><p id="f52f" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最终输出如下所示。Regina Philangi 没有经理，也就是说，她不向任何人汇报。她是最高管理者。</p><figure class="nn no np nq gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi ns"><img src="../Images/817b3a32804854dec65916829f996480.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*no8KXvuluAi8WmCs0zqXxA.png"/></div></div></figure><p id="8f41" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">或者，可以使用<code class="fe ky kz la lb b">pandas.merge()</code>函数在 Pandas 中执行自加入，如下所示。<code class="fe ky kz la lb b">df_manager</code>的输出与<code class="fe ky kz la lb b">df_manager2</code>的输出相同。</p><figure class="nn no np nq gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nt"><img src="../Images/742e41eaff413ed654f17e666ba401ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*If4NaY0dscd3j9tObKCNOA.png"/></div></div></figure></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><h1 id="a6b0" class="lx ly jd bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">交叉连接</h1><p id="583c" class="pw-post-body-paragraph ka kb jd kc b kd mv kf kg kh mw kj kk kl mx kn ko kp my kr ks kt mz kv kw kx ig bi translated"><code class="fe ky kz la lb b">Cross Join</code>是一种连接类型，允许您在两个或多个表中生成行的笛卡尔乘积。换句话说，它将第一个表中的行与第二个表中的每一行组合起来。下表说明了当将表<strong class="kc je"> df1 </strong>连接到另一个表<strong class="kc je"> df2 </strong>时<code class="fe ky kz la lb b">Cross Join</code>的结果。</p><figure class="nn no np nq gt ip gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/a8ac3a2aceaa954df0a65080f65caca5.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*FVvdjznng9ASGz8tH-kqgA.png"/></div></figure><h2 id="9a52" class="na ly jd bd lz nb nc dn md nd ne dp mh kl nf ng ml kp nh ni mp kt nj nk mt nl bi translated">示例 2:创建独特产品的库存</h2><p id="3ace" class="pw-post-body-paragraph ka kb jd kc b kd mv kf kg kh mw kj kk kl mx kn ko kp my kr ks kt mz kv kw kx ig bi translated">这个例子的目标是为一个服装店创建一个库存，这个库存根据衣服的颜色正确地获取衣服。我们从建立数据集开始。</p><figure class="nn no np nq gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nv"><img src="../Images/ebdc9a7a38a8a33464447ae14299ace1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MiElcPXA8TyTonoOw_I0UA.png"/></div></div></figure><p id="60e8" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于我们的数据集，没有连接两个数据帧的索引。因此使用<code class="fe ky kz la lb b">pandas.merge()</code>功能很方便。这将在下面演示。</p><figure class="nn no np nq gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nw"><img src="../Images/037aabf5c85a3573c223ce24239b3241.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6abf2eSDrUNgxMQ6roJbbg.png"/></div></div></figure><p id="8f92" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们也可以使用<code class="fe ky kz la lb b">pandas.concat()</code>函数，如下所示。这给出了与<code class="fe ky kz la lb b">pandas.merge()</code>功能相同的结果。</p><figure class="nn no np nq gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nx"><img src="../Images/019bfa1461d08eeb2b473f1a19f83179.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7eZrdNjBybIsc6SYqUbeqA.png"/></div></div></figure><h1 id="c4de" class="lx ly jd bd lz ma ny mc md me nz mg mh mi oa mk ml mm ob mo mp mq oc ms mt mu bi translated">结论</h1><p id="3dad" class="pw-post-body-paragraph ka kb jd kc b kd mv kf kg kh mw kj kk kl mx kn ko kp my kr ks kt mz kv kw kx ig bi translated">在本教程中，我们学习了鲜为人知的连接，以及它们是如何在 Pandas DataFrame 中执行的。熊猫有各种功能可以达到同样的效果。</p></div></div>    
</body>
</html>