<html>
<head>
<title>JavaScript Data Structures — Queue</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript数据结构—队列</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/javascript-data-structures-queue-190e8788d1c2?source=collection_archive---------13-----------------------#2020-06-03">https://blog.devgenius.io/javascript-data-structures-queue-190e8788d1c2?source=collection_archive---------13-----------------------#2020-06-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="7d7a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我的上一篇文章中，我谈到了<a class="ae ki" href="https://medium.com/@utarit/javascript-data-structures-stack-e3a3977b92aa" rel="noopener">栈</a>。现在，我想谈谈排队的问题。当我们看定义的时候，</p><blockquote class="kj kk kl"><p id="f56c" class="jk jl km jm b jn jo jp jq jr js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kh ig bi translated">一个<strong class="jm io">队列</strong>是一个线性的<strong class="jm io">结构</strong>，它遵循操作执行的特定顺序。</p></blockquote><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi kq"><img src="../Images/399182513cd22cff6e24ed5c10fe0fa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qDZeVQ8DaB759P4y.png"/></div></div></figure><p id="543a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如你所见，队列也是一个线性结构(就像我们所说的数组)。不同的是<strong class="jm io">先进先出</strong>。这意味着<strong class="jm io">进入队列的第一个元素先出去</strong> <em class="km">(记住栈是后进先出的)</em>。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="6a34" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看看我们有哪些功能:</p><ul class=""><li id="58b5" class="le lf in jm b jn jo jr js jv lg jz lh kd li kh lj lk ll lm bi translated"><strong class="jm io"> Enqueue(el): </strong>将一个元素推到队列的后面。</li><li id="ea82" class="le lf in jm b jn ln jr lo jv lp jz lq kd lr kh lj lk ll lm bi translated"><strong class="jm io"> Dequeue(): </strong>从队列的前面弹出元素。(这是第一个被推动的元素)</li><li id="024d" class="le lf in jm b jn ln jr lo jv lp jz lq kd lr kh lj lk ll lm bi translated"><strong class="jm io"> front(): </strong>返回第一个未出列的推送元素。</li><li id="656f" class="le lf in jm b jn ln jr lo jv lp jz lq kd lr kh lj lk ll lm bi translated"><strong class="jm io"> rear(): </strong>(有人说back而不是rear)返回最后一个推送的元素。</li><li id="e648" class="le lf in jm b jn ln jr lo jv lp jz lq kd lr kh lj lk ll lm bi translated">如果队列已满，则返回</li></ul><p id="d37d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">其他函数是常用函数，我不想再重写它们。</p><p id="2910" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">队列在生产者-消费者问题、CPU、网络和异步问题中被大量使用。我建议深入队列，更有效地解决算法。此外，它还能很好地处理面试问题(尽管:D并不比链表好)。下一个建筑见。保持健康…</p></div></div>    
</body>
</html>