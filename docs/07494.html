<html>
<head>
<title>Advanced Docker — Docker storage drivers and file systems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级 Docker — Docker 存储驱动程序和文件系统</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/advanced-docker-docker-storage-drivers-and-file-systems-81a5340c0761?source=collection_archive---------6-----------------------#2022-03-30">https://blog.devgenius.io/advanced-docker-docker-storage-drivers-and-file-systems-81a5340c0761?source=collection_archive---------6-----------------------#2022-03-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/6f826f2233362bd12acc682c64683df0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DusyBrF_NnZybkCy-Z1NQg.jpeg"/></div></div></figure><p id="ec1d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本帖中，我们将讨论高级 docker 概念。我们将看到 docker 如何存储数据，以及它如何管理容器的文件系统。如果你还没有阅读，请在继续之前阅读绝对初学者的文章。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h2 id="1d53" class="lb lc in bd ld le lf dn lg lh li dp lj kg lk ll lm kk ln lo lp ko lq lr ls lt bi translated">文件系统</h2><p id="2551" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks ig bi translated">当你在一个系统上安装 docker 时，它会创建一个<strong class="jx io"> /var/lib/docker </strong>文件夹结构，默认情况下存储所有与 docker 主机上运行的映像和容器相关的数据。</p><p id="4c1d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那么，docker 到底是如何存储一个图像和一个容器的文件的呢？</p><p id="6bc3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要理解这一点，我们需要先了解 docker 容器的分层架构。</p><h2 id="9c57" class="lb lc in bd ld le lf dn lg lh li dp lj kg lk ll lm kk ln lo lp ko lq lr ls lt bi translated">分层架构</h2><p id="c243" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks ig bi translated">在<a class="ae kt" href="https://yonatan-merkebu.medium.com/docker-for-the-absolute-beginner-8c6dbcd71e4b" rel="noopener">之前的帖子</a>中，我们看到了如何建立一个码头工人的形象。当 docker 构建映像时，它构建在一个分层架构中。docker 文件中的每一行指令都会在 docker 映像中创建一个新层，仅包含前一层的更改。</p><p id="7260" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们以<a class="ae kt" href="https://yonatan-merkebu.medium.com/docker-for-the-absolute-beginner-8c6dbcd71e4b" rel="noopener">前一篇文章</a>中的 docker 文件为例。</p><figure class="ma mb mc md gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lz"><img src="../Images/7c91088037e3a33e68389ffba23df665.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C73l7UXb-8x4XgFgn-M4mw.png"/></div></div></figure><p id="398f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第一层是一个基本的 ubuntu 层，随后是第二条指令，它创建了第二层，第二层安装 apt 包，第五层更新入口点。</p><p id="2177" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于每个层仅存储前一层的更改，因此它也反映在大小上。</p><figure class="ma mb mc md gt jo gh gi paragraph-image"><div class="gh gi me"><img src="../Images/5f6e583e8f7532a91b0213f1bc83d200.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*BO3PkbmenqUp81p9Zx4ofQ.png"/></div></figure><p id="aa89" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了理解分层架构的优点，让我们考虑另一个应用程序。</p><p id="2831" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">新应用程序与之前的应用程序相同，只是源代码不同(app2.py)。</p><p id="eea1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当您运行<strong class="jx io"> docker build </strong>命令为这个应用程序构建一个映像时，因为应用程序的前三层是相同的，所以 docker 不会构建它们。它从缓存中重用它们。这种方式 docker 建立图像更快，更有效地节省磁盘空间。</p><figure class="ma mb mc md gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mf"><img src="../Images/749c25d113224ccdb3d04397fc6fc7bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*32VI9yIQ-2Jomf6_F0gA4A.png"/></div></div></figure><p id="64ce" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">图像图层是只读的。要编辑它们，您必须再次重建您的映像。</p><p id="200a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当您使用<strong class="jx io"> docker build </strong>命令基于您的图像创建容器时，docker 会在图像层之上创建一个新的可写层(容器层)。该层用于存储由容器创建的数据。</p><p id="bb86" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当容器被销毁时，层和存储在其中的所有文件也被销毁。</p><h2 id="c65b" class="lb lc in bd ld le lf dn lg lh li dp lj kg lk ll lm kk ln lo lp ko lq lr ls lt bi translated">卷</h2><p id="363d" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks ig bi translated">那么，如果您希望持久保存这些数据，该怎么办呢？例如，如果您正在处理一个数据库，并且您想要保留由容器创建的数据，您可以向容器添加一个持久的<strong class="jx io">卷</strong>。</p><p id="69cb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为此，首先使用命令创建一个卷</p><blockquote class="mg mh mi"><p id="5e59" class="jv jw mj jx b jy jz ka kb kc kd ke kf mk kh ki kj ml kl km kn mm kp kq kr ks ig bi translated">sudo docker 创建卷数据 _ 卷</p></blockquote><p id="6376" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将在<strong class="jx io"> /var/lib/docker/volumes </strong>目录下创建一个<strong class="jx io"> data_volumes </strong>文件夹。</p><figure class="ma mb mc md gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mn"><img src="../Images/36e9ed0f06c2c1e59ec41ae10498fdec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-OjegG7SeGSunZ1FR-zx9A.png"/></div></div></figure><p id="a9c1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，当您运行容器时，您可以使用下面两个命令中的任何一个将这个卷挂载到写入层中。建议使用 mount 命令，因为它更详细。在这里阅读更多<a class="ae kt" href="https://docs.docker.com/storage/volumes/#choose-the--v-or---mount-flag" rel="noopener ugc nofollow" target="_blank"/>。</p><blockquote class="mg mh mi"><p id="1391" class="jv jw mj jx b jy jz ka kb kc kd ke kf mk kh ki kj ml kl km kn mm kp kq kr ks ig bi translated">docker run-d-v data _ volume:/var/lib/MySQL</p><p id="8c34" class="jv jw mj jx b jy jz ka kb kc kd ke kf mk kh ki kj ml kl km kn mm kp kq kr ks ig bi translated">docker run -d —挂载类型=卷，源=数据 _ 卷，目标=/var/lib/mysql mysql</p></blockquote><p id="8837" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种方法叫做<strong class="jx io">卷装</strong>。</p><p id="1e01" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们的数据已经在另一个地方了，会怎么样？比如在<strong class="jx io"> /data/mysql </strong>？</p><p id="91ca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以像提供卷一样提供文件夹的完整路径。</p><blockquote class="mg mh mi"><p id="8739" class="jv jw mj jx b jy jz ka kb kc kd ke kf mk kh ki kj ml kl km kn mm kp kq kr ks ig bi translated">docker run-d-v/data/MySQL:/var/lib/MySQL MySQL</p><p id="d5c2" class="jv jw mj jx b jy jz ka kb kc kd ke kf mk kh ki kj ml kl km kn mm kp kq kr ks ig bi translated">docker run -d — mount type=bind，source= /data/mysql，target=/var/lib/mysql mysql</p></blockquote><p id="7ba1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种方法称为<strong class="jx io">捆绑安装</strong>。</p><h2 id="fe17" class="lb lc in bd ld le lf dn lg lh li dp lj kg lk ll lm kk ln lo lp ko lq lr ls lt bi translated">我们有两种坐骑:</h2><p id="1ead" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks ig bi translated"><strong class="jx io">卷挂载</strong>:从卷目录挂载一个卷。</p><p id="d95c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">绑定挂载</strong>:从 docker 主机上的任何位置挂载一个目录。</p><p id="1836" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您使用尚不存在的卷启动容器，Docker 会为您创建该卷。</p><h2 id="3edc" class="lb lc in bd ld le lf dn lg lh li dp lj kg lk ll lm kk ln lo lp ko lq lr ls lt bi translated">那么谁负责所有这些操作呢？</h2><p id="b13a" class="pw-post-body-paragraph jv jw in jx b jy lu ka kb kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks ig bi translated">维护分层架构、创建可写层、跨层移动文件等。由<strong class="jx io">存储驱动</strong>负责。</p><p id="e1e7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Docker 使用存储驱动程序来实现分层架构。一些常见的存储驱动程序有<strong class="jx io"> AUFS、ZFS、BTRFS、设备映射器、覆盖、覆盖 2 </strong>。</p><p id="4f53" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">存储驱动程序的选择取决于底层操作系统(OS)。例如，ubuntu 的默认存储驱动是 AUFS。Docker 将根据您的操作系统选择最佳的存储驱动程序。</p><p id="175e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">好了，暂时就这样了。我希望这有所帮助。更多关于 Docker、Docker compose、Docker swarm 的高级主题…即将推出！跟着我不要错过他们。</p></div></div>    
</body>
</html>