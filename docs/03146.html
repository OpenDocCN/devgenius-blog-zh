<html>
<head>
<title>Chain of Responsibility Design Pattern in Modern C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代 C++中的责任链设计模式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/chain-of-responsibility-design-pattern-in-modern-c-f318f48a4f45?source=collection_archive---------4-----------------------#2020-10-05">https://blog.devgenius.io/chain-of-responsibility-design-pattern-in-modern-c-f318f48a4f45?source=collection_archive---------4-----------------------#2020-10-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b2761fdc843c88808cabd2c729399a0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H3OKn8bkGZ6P-8me7fw91Q.png"/></div></div></figure><p id="2075" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">责任链是一种行为设计模式，<strong class="jx io"> <em class="kt">提供了向松散耦合对象链</em> </strong>传播事件/请求/命令/查询的工具。现代 C++中的责任链设计模式允许您沿着处理程序链传递请求&amp;在接收到请求时，每个处理程序决定是处理请求还是将其转发给链中的下一个处理程序。</p><blockquote class="ku kv kw"><p id="085c" class="jv jw kt jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated"><em class="in"> /！\:本文已原创发表于我的</em> <a class="ae la" href="http://www.vishalchovatiya.com/chain-of-responsibility-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <em class="in">博客</em> </a> <em class="in">。如果你有兴趣接收我的最新文章，</em> <a class="ae la" href="http://eepurl.com/gDNybv" rel="noopener ugc nofollow" target="_blank"> <em class="in">请报名参加我的简讯</em> </a> <em class="in">。</em></p></blockquote><p id="a395" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">顺便说一句，如果你还没有看过我的其他关于行为设计模式的文章，下面是列表:</p><ol class=""><li id="1733" class="lb lc in jx b jy jz kc kd kg ld kk le ko lf ks lg lh li lj bi translated"><a class="ae la" href="http://www.vishalchovatiya.com/chain-of-responsibility-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">责任链</strong> </a></li><li id="c3bd" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated"><a class="ae la" href="http://www.vishalchovatiya.com/command-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank">命令<strong class="jx io">命令</strong>命令</a></li><li id="d5c0" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated"><a class="ae la" href="http://www.vishalchovatiya.com/interpreter-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">解释器</strong> </a></li><li id="90e7" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated"><a class="ae la" href="http://www.vishalchovatiya.com/iterator-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">迭代器</strong> </a></li><li id="df6f" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated"><a class="ae la" href="http://www.vishalchovatiya.com/mediator-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">调解员</strong> </a></li><li id="4529" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated"><a class="ae la" href="http://www.vishalchovatiya.com/memento-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">纪念物</strong> </a></li><li id="fa90" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated"><a class="ae la" href="http://www.vishalchovatiya.com/observer-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">观察者</strong> </a></li><li id="82cb" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated"><a class="ae la" href="http://www.vishalchovatiya.com/state-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank">状态<strong class="jx io">状态</strong>状态</a></li><li id="be07" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated"><a class="ae la" href="http://www.vishalchovatiya.com/strategy-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">策略</strong> </a></li><li id="fcc0" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated"><a class="ae la" href="http://www.vishalchovatiya.com/template-method-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">模板方法</strong> </a></li><li id="9ee2" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated"><a class="ae la" href="http://www.vishalchovatiya.com/double-dispatch-visitor-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">来访者</strong> </a></li></ol><p id="8a15" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您在这一系列文章中看到的代码片段是简化的，而不是复杂的。所以你经常看到我不使用像<code class="fe lp lq lr ls b">override</code>、<code class="fe lp lq lr ls b">final</code>、<code class="fe lp lq lr ls b">public</code>(同时继承)这样的关键字，只是为了让代码紧凑&amp;可消耗(大多数时候)在单一标准屏幕尺寸。我也更喜欢<code class="fe lp lq lr ls b">struct</code>而不是<code class="fe lp lq lr ls b">class</code>，只是为了节省代码行，有时不写<code class="fe lp lq lr ls b">public:</code>，也故意忽略<a class="ae la" href="http://www.vishalchovatiya.com/part-3-all-about-virtual-keyword-in-c-how-virtual-destructor-works/" rel="noopener ugc nofollow" target="_blank">虚析构函数</a>，构造函数<a class="ae la" href="http://www.vishalchovatiya.com/all-about-copy-constructor-in-cpp-with-example/" rel="noopener ugc nofollow" target="_blank">，复制构造函数</a>，前缀<code class="fe lp lq lr ls b">std::</code>，删除动态内存。我也认为自己是一个务实的人，希望用尽可能简单的方式，而不是标准的方式或使用术语来传达一个想法。</p><p id="80fd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="kt">注:</em> </strong></p><ul class=""><li id="7972" class="lb lc in jx b jy jz kc kd kg ld kk le ko lf ks lt lh li lj bi translated">如果你是在这里被直接绊倒的，那么我建议你浏览一下<a class="ae la" href="http://www.vishalchovatiya.com/what-is-design-pattern/" rel="noopener ugc nofollow" target="_blank">什么是设计模式？</a>一、哪怕是鸡毛蒜皮的小事。相信会鼓励你对这个话题进行更多的探索。</li><li id="e596" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lt lh li lj bi translated">您在本系列文章中遇到的所有这些代码都是使用 C++20 编译的(尽管我在大多数情况下使用了 C++17 的<a class="ae la" href="http://www.vishalchovatiya.com/21-new-features-of-modern-cpp-to-use-in-your-project/" rel="noopener ugc nofollow" target="_blank">现代 C++ </a>特性)。因此，如果你无法获得最新的编译器，你可以使用<a class="ae la" href="https://wandbox.org/" rel="noopener ugc nofollow" target="_blank">https://wandbox.org/</a>，它也预装了 boost 库。</li></ul><h1 id="cf99" class="lu lv in bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">目的</h1><blockquote class="ku kv kw"><p id="775c" class="jv jw kt jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated"><strong class="jx io">提供由多个对象/组件处理请求的机会。</strong></p></blockquote><ul class=""><li id="1a0a" class="lb lc in jx b jy jz kc kd kg ld kk le ko lf ks lt lh li lj bi translated">责任链设计模式是一个松散耦合的对象链，所有对象都有机会处理命令/查询。并且它们可以具有某种默认处理实现和/或它们还可以终止处理链，从而防止事件传播到其余对象。</li><li id="9655" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lt lh li lj bi translated">换句话说，它的<strong class="jx io"> <em class="kt">处理流水线就在你刚刚启动并离开</em> </strong>的地方。</li></ul><h1 id="0ae5" class="lu lv in bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">C++中责任链设计模式的经典例子</h1><ul class=""><li id="b3c8" class="lb lc in jx b jy ms kc mt kg mu kk mv ko mw ks lt lh li lj bi translated">责任链的一个典型用例是登录过程。这需要一定数量的步骤才能成功完成，如用户名、密码、验证码等。搭配得当。考虑以下相同的传统示例:</li></ul><pre class="mx my mz na gt nb ls nc nd aw ne bi"><span id="8d4b" class="nf lv in ls b gy ng nh l ni nj">struct Authentication {<br/>    Authentication*     m_next{nullptr};</span><span id="6192" class="nf lv in ls b gy nk nh l ni nj">    virtual bool authenticate() = 0;<br/>    void next_authentication(Authentication *nextAuth) { m_next = nextAuth; }<br/>};</span><span id="47a2" class="nf lv in ls b gy nk nh l ni nj">struct UserName : Authentication {<br/>    string      m_name;</span><span id="5a6f" class="nf lv in ls b gy nk nh l ni nj">    UserName(string name) : m_name(name){}<br/>    bool is_valid_user_name() { return true; }<br/>    bool authenticate() {<br/>        if(!is_valid_user_name()) {<br/>            cout &lt;&lt; "Invalid user name" &lt;&lt; endl;<br/>            return false;<br/>        }<br/>        else if(m_next) return m_next-&gt;authenticate();<br/>        return true;<br/>    }<br/>};</span><span id="6c77" class="nf lv in ls b gy nk nh l ni nj">struct Password : Authentication {<br/>    string      m_password;</span><span id="b459" class="nf lv in ls b gy nk nh l ni nj">    Password(string password) : m_password(password){}<br/>    bool is_valid_password() { return true; }<br/>    bool authenticate() {<br/>        if(!is_valid_password()) {<br/>            cout &lt;&lt; "Invalid password" &lt;&lt; endl;<br/>            return false;<br/>        }<br/>        else if(m_next) return m_next-&gt;authenticate();<br/>        return true;<br/>    }<br/>};</span><span id="7392" class="nf lv in ls b gy nk nh l ni nj">int main() {<br/>    Authentication *login{new UserName("John")};<br/>    login-&gt;next_authentication(new Password("password"));<br/>    login-&gt;authenticate();<br/>    return EXIT_SUCCESS;<br/>}</span></pre><ul class=""><li id="0933" class="lb lc in jx b jy jz kc kd kg ld kk le ko lf ks lt lh li lj bi translated">我知道这不是一个很好的例子，但足以传达一个责任链的想法。正如您在上面看到的，登录是一个单一的过程，需要执行多个子过程，如用户名和密码验证。</li><li id="93e3" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lt lh li lj bi translated">所以在我们的例子中,<code class="fe lp lq lr ls b">login-&gt;authenticate();</code>触发了责任链来逐一验证登录所需的每个步骤。</li><li id="a33b" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lt lh li lj bi translated">您还可以在登录过程中添加更多步骤，例如，添加验证码，创建继承了<code class="fe lp lq lr ls b">Authentication</code> &amp;的验证码类，在登录的下一个认证链中添加该类对象指针，就像我们对<code class="fe lp lq lr ls b">UserName</code> &amp; <code class="fe lp lq lr ls b">Password</code>所做的那样。</li><li id="8503" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lt lh li lj bi translated">现在，在我们继续讨论更复杂的实现之前，我只想提一下这样一个事实，即责任链的这种特定实现看起来很不自然。因为本质上这里发生的是你在构建一个单链表，所以问题是为什么不直接使用<code class="fe lp lq lr ls b">std::list</code>或者<code class="fe lp lq lr ls b">std::vector</code>。这当然是一个非常合理的担忧。但是正如我前面提到的，这就是人们过去如何建立不负责任的链条。</li></ul><h1 id="9943" class="lu lv in bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">责任链设计模式的 Boost 示例</h1><ul class=""><li id="35f8" class="lb lc in jx b jy ms kc mt kg mu kk mv ko mw ks lt lh li lj bi translated">现在您将看到的是一种实现责任链设计模式的现代方法，称为<a class="ae la" href="https://en.wikipedia.org/wiki/Broker_pattern" rel="noopener ugc nofollow" target="_blank">事件代理</a>。这实际上是几个设计模式的组合，如<a class="ae la" href="http://www.vishalchovatiya.com/command-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank">命令</a>、<a class="ae la" href="http://www.vishalchovatiya.com/mediator-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank">中介</a>、&amp;、<a class="ae la" href="http://www.vishalchovatiya.com/observer-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank">观察者</a>。</li></ul><pre class="mx my mz na gt nb ls nc nd aw ne bi"><span id="333c" class="nf lv in ls b gy ng nh l ni nj">#include &lt;iostream&gt;<br/>#include &lt;string&gt;<br/>using namespace std;<br/>#include &lt;boost/signals2.hpp&gt;<br/>//using namespace boost::signals2;</span><span id="0be8" class="nf lv in ls b gy nk nh l ni nj">struct Query {                          // Command<br/>    int32_t     m_cnt{0};<br/>};</span><span id="cb23" class="nf lv in ls b gy nk nh l ni nj">struct EventObserver {                  // Observer<br/>    boost::signals2::signal&lt;void(Query &amp;)&gt;       m_handlers;<br/>};</span><span id="c30d" class="nf lv in ls b gy nk nh l ni nj">struct ExampleClass : EventObserver {   // Mediator<br/>    void generate_event() { <br/>        cout &lt;&lt; "Event generated" &lt;&lt; endl;<br/>        Query   q;<br/>        m_handlers(q); <br/>        cout &lt;&lt; endl;<br/>    }<br/>};</span><span id="1308" class="nf lv in ls b gy nk nh l ni nj">struct BaseHandler {<br/>    ExampleClass&amp;       m_example;<br/>};</span><span id="e68a" class="nf lv in ls b gy nk nh l ni nj">struct Handler_1 : BaseHandler {<br/>    boost::signals2::connection      m_conn;</span><span id="3f00" class="nf lv in ls b gy nk nh l ni nj">    Handler_1(ExampleClass &amp;example) : BaseHandler{example}<br/>    {<br/>        m_conn = m_example.m_handlers.connect([&amp;](Query &amp;q) {<br/>            cout &lt;&lt; "Serving by Handler_1 : count = " &lt;&lt; ++q.m_cnt &lt;&lt; endl;<br/>        });<br/>    }<br/>    ~Handler_1() { m_conn.disconnect(); }<br/>};</span><span id="2726" class="nf lv in ls b gy nk nh l ni nj">struct Handler_2 : BaseHandler {<br/>    boost::signals2::connection      m_conn;</span><span id="5fbb" class="nf lv in ls b gy nk nh l ni nj">    Handler_2(ExampleClass &amp;example) : BaseHandler{example}<br/>    {<br/>        m_conn = m_example.m_handlers.connect([&amp;](Query &amp;q) {<br/>            cout &lt;&lt; "Serving by Handler_2 : count = " &lt;&lt; ++q.m_cnt &lt;&lt; endl;<br/>        });<br/>    }<br/>    ~Handler_2() { m_conn.disconnect(); }<br/>};</span><span id="8862" class="nf lv in ls b gy nk nh l ni nj">int main() {<br/>    ExampleClass example;<br/>    Handler_1 applyThisHandlerOn{example};</span><span id="1122" class="nf lv in ls b gy nk nh l ni nj">    example.generate_event();       // Will be served by Handler_1</span><span id="e8ed" class="nf lv in ls b gy nk nh l ni nj">    { <br/>        Handler_2 TemporaryHandler{example};<br/>        example.generate_event();   // Will be served by Handler_1 &amp; Handler_2<br/>    }</span><span id="c140" class="nf lv in ls b gy nk nh l ni nj">    example.generate_event();       // Will be served by Handler_1<br/>    return EXIT_SUCCESS;<br/>}<br/>/*<br/>Event generated<br/>Serving by Handler_1 : count = 1</span><span id="6904" class="nf lv in ls b gy nk nh l ni nj">Event generated<br/>Serving by Handler_1 : count = 1<br/>Serving by Handler_2 : count = 2</span><span id="8813" class="nf lv in ls b gy nk nh l ni nj">Event generated<br/>Serving by Handler_1 : count = 1<br/>*/</span></pre><ul class=""><li id="cb3e" class="lb lc in jx b jy jz kc kd kg ld kk le ko lf ks lt lh li lj bi translated">如你所见，我们有<code class="fe lp lq lr ls b">ExampleClass</code>生成一个事件&amp;，事件<code class="fe lp lq lr ls b">boost::signal2</code>作为观察者。我们有<code class="fe lp lq lr ls b">Query</code>(即<a class="ae la" href="http://www.vishalchovatiya.com/command-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank">命令设计模式</a>)在所有寄存器处理器之间传递。</li><li id="e6ee" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lt lh li lj bi translated">然后我们有一个处理程序安排，它注册了<a class="ae la" href="http://www.vishalchovatiya.com/learn-lambda-function-in-cpp-with-example/" rel="noopener ugc nofollow" target="_blank"> lambda 函数</a>来处理构造函数&amp;中的事件，同样会在析构函数中取消注册。</li><li id="d5cf" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lt lh li lj bi translated">总的来说，我们只是通过声明处理在<code class="fe lp lq lr ls b">ExampleClass::generate_event()</code>中传递的<code class="fe lp lq lr ls b">Query</code>的对象来简化处理程序的特别注册。由于<a class="ae la" href="https://en.cppreference.com/w/cpp/language/raii" rel="noopener ugc nofollow" target="_blank"> RAII </a>，处理程序在超出范围时会自动注销。</li></ul><h1 id="611b" class="lu lv in bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">责任链设计模式的好处</h1><ol class=""><li id="4a0f" class="lb lc in jx b jy ms kc mt kg mu kk mv ko mw ks lg lh li lj bi translated">解耦发送者和接收者，正如我们看到的使用<a class="ae la" href="http://www.vishalchovatiya.com/mediator-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank">中介</a> &amp; <a class="ae la" href="http://www.vishalchovatiya.com/command-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank">命令设计模式</a>的更复杂的方法。</li><li id="d737" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated">简化代码，因为生成事件的对象不需要知道链结构&amp;命令/查询。</li><li id="be5b" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated">增强分配任务对象的灵活性。通过更改链中的成员或更改其顺序，允许动态添加或删除责任。</li><li id="2e20" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated">增加可扩展性，因为添加新的处理程序非常方便。</li></ol><h1 id="37bc" class="lu lv in bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">常见问题汇总</h1><p id="b1e7" class="pw-post-body-paragraph jv jw in jx b jy ms ka kb kc mt ke kf kg nl ki kj kk nm km kn ko nn kq kr ks ig bi translated"><strong class="jx io">我可以对装饰者使用(或区别)责任链设计模式吗？</strong></p><p id="ff25" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">—当你需要多个装饰者时。<br/> —当您想要动态添加新功能时。<br/> —当您想要更改可配置功能的顺序时。<br/> —例如，您创建了<code class="fe lp lq lr ls b">WalkingAnimal</code>&amp;<code class="fe lp lq lr ls b">BarkingAnimal</code><code class="fe lp lq lr ls b">Animal</code>的装饰器，现在您想在运行时将两者结合起来。在这种情况下，责任链将是正确的选择。</p><p id="08b3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">什么时候我应该使用责任链设计模式？</p><p id="5a66" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">—当有多个对象服务于一个请求时。<br/> —这些对象&amp;其顺序根据请求类型在运行时确定。<br/> —当你不想紧密绑定请求&amp;处理程序时。</p></div></div>    
</body>
</html>