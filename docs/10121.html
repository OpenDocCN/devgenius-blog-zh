<html>
<head>
<title>.NET Core and k8s Tip 2: How to find our Memory Leaks within a .NET Console application running in a Linux Docker Container in Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">。NET Core 和 k8s 技巧 2:如何在 Kubernetes 的 Linux Docker 容器中运行的. NET 控制台应用程序中发现内存泄漏</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/net-core-tip-2-how-to-troubleshoot-memory-leaks-within-a-net-a3a81c137b3c?source=collection_archive---------11-----------------------#2022-10-08">https://blog.devgenius.io/net-core-tip-2-how-to-troubleshoot-memory-leaks-within-a-net-a3a81c137b3c?source=collection_archive---------11-----------------------#2022-10-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><ol class=""><li id="6e69" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">介绍</li></ol><p id="45c4" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">我们经常认为，因为垃圾收集器自动管理内存使用，因为。NET Framework 1.0 发布，我们不需要担心。还有在。NET Core，脚本一定是一样的吧？</p><p id="d27e" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">错了。垃圾收集器，通常称为 GC，帮助我们回收不再被引用的对象。但是当对象仍然被引用但没有被使用时，GC 帮不了我们(它们是基本的“死”对象，我们可以将这种情况与不再被使用但仍然混乱我们的代码库的“死”代码进行一点比较)。</p><p id="9d8f" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">因此，如果我们不小心使用代码，我们可能会遇到两种情况:</p><ul class=""><li id="9b56" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx kr jz ka kb bi translated">大规模内存泄漏:内存泄漏很快，很容易被注意到，而且在大多数情况下更容易修复</li><li id="7276" class="jk jl in jm b jn ks jp kt jr ku jt kv jv kw jx kr jz ka kb bi translated">偷偷摸摸的内存泄漏:它更慢，更不明显，而且通常更难修复</li></ul><p id="6108" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">内存泄漏可能有成千上万种原因，但我们可以列出主要原因:</p><ul class=""><li id="d2ee" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx kr jz ka kb bi translated">一个<strong class="jm io">静态收藏</strong>变大</li><li id="226d" class="jk jl in jm b jn ks jp kt jr ku jt kv jv kw jx kr jz ka kb bi translated">一个<strong class="jm io">缓存</strong>，过一会儿不释放项目</li><li id="121b" class="jk jl in jm b jn ks jp kt jr ku jt kv jv kw jx kr jz ka kb bi translated">一个<strong class="jm io">长时间运行的线程</strong>带有一个引用一个大集合的局部变量</li><li id="1024" class="jk jl in jm b jn ks jp kt jr ku jt kv jv kw jx kr jz ka kb bi translated"><strong class="jm io">未按预期手动释放的非托管内存</strong>(。net core 经常在幕后使用非托管代码)</li><li id="63a4" class="jk jl in jm b jn ks jp kt jr ku jt kv jv kw jx kr jz ka kb bi translated"><strong class="jm io">捕获的变量</strong>获得更长的 TTL(生存时间)</li><li id="4342" class="jk jl in jm b jn ks jp kt jr ku jt kv jv kw jx kr jz ka kb bi translated">没有在需要时调用<strong class="jm io"> Dispose 方法</strong></li><li id="20c6" class="jk jl in jm b jn ks jp kt jr ku jt kv jv kw jx kr jz ka kb bi translated">非常复杂的<strong class="jm io">对象依赖关系</strong>会使移除对象更加困难</li><li id="2cd1" class="jk jl in jm b jn ks jp kt jr ku jt kv jv kw jx kr jz ka kb bi translated">错误使用<strong class="jm io">字符串操作</strong></li><li id="190b" class="jk jl in jm b jn ks jp kt jr ku jt kv jv kw jx kr jz ka kb bi translated">错误使用<strong class="jm io">终结器</strong></li><li id="7b9e" class="jk jl in jm b jn ks jp kt jr ku jt kv jv kw jx kr jz ka kb bi translated">错误使用<strong class="jm io">事件订阅</strong></li><li id="668a" class="jk jl in jm b jn ks jp kt jr ku jt kv jv kw jx kr jz ka kb bi translated">永远不会释放对象的死锁线程</li><li id="3549" class="jk jl in jm b jn ks jp kt jr ku jt kv jv kw jx kr jz ka kb bi translated">指针的错误使用(我知道它非常模糊，很难精确定位！)</li></ul><p id="ba37" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">这不是一个完整的列表，但它已经可以给我们很多线索了:)</p><p id="a68e" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">这里是上下文，我们在 QA 环境中没有看到任何内存泄漏，所以我们决定部署我们的。生产 Kubernetes 集群上的网络核心奇迹。</p><p id="6197" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">但是过了一段时间后，每当我们的内存达到极限时，豆荚就会重新启动。</p><p id="a8e5" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">当我们的应用程序在 Kubernetes 生产集群中的 docker 容器中运行时，我们就像“该死的”我们有内存泄漏，并且没有任何方法或工具来发现问题…</p><p id="8bab" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">还好这不是真的，我们有几种方法来解决我们的内存泄漏！微软放了很多工具，我们可以直接从运行我们的 docker 容器下载。NET 应用程序的内存泄漏问题！</p><p id="6d01" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">就是今天这篇文章要讲的:)</p><ol class=""><li id="76d3" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">语境</li></ol><p id="779d" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">首先，我们将使用 Linux 容器 docker 进行演示。而且，我们会使用<strong class="jm io"> Linux 发行版 Debian 和一个. net 核心应用</strong>。</p><p id="e0cb" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">对于这个演示，我将使用一个简单的案例:一个带有一个长期运行的任务<strong class="jm io">的<strong class="jm io">控制台应用程序</strong>，该任务将每秒钟向一个集合添加项目</strong>。</p><p id="8c40" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">为什么是控制台应用程序？因为这样我们就能找到问题的本质，内存泄漏。代码库将非常简单，但将揭示我们在处理复杂的现实生活情况时需要知道的一切！</p><ol class=""><li id="5390" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">工具</li></ol><p id="2066" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">我们将看到一些可以帮助我们的工具。</p><p id="6349" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">对于此演示，我们需要:</p><ul class=""><li id="0110" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx kr jz ka kb bi translated"><strong class="jm io"> Visual Studio 2022 </strong></li><li id="a015" class="jk jl in jm b jn ks jp kt jr ku jt kv jv kw jx kr jz ka kb bi translated"><strong class="jm io"> docker 桌面</strong>用于运行 Docker 容器运行时并构建我们的 Docker 映像</li><li id="cfbd" class="jk jl in jm b jn ks jp kt jr ku jt kv jv kw jx kr jz ka kb bi translated"><strong class="jm io"> minikube </strong>为我们的演示提供了一个带有单个节点的 kubernetes 集群</li><li id="4f71" class="jk jl in jm b jn ks jp kt jr ku jt kv jv kw jx kr jz ka kb bi translated"><strong class="jm io">点网转储</strong>工具，用于 x64 架构的<strong class="jm io">Linux</strong>从微软下载网站(<a class="ae kx" href="https://aka.ms/dotnet-dump/linux-x64" rel="noopener ugc nofollow" target="_blank">https://aka.ms/dotnet-dump/linux-x64</a>)直接下载。</li></ul><p id="1302" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">我们将从用。网芯。然后，我们将把我们的演示部署到我们的<strong class="jm io"> MiniKube Kubernetes 集群。</strong></p><p id="31ab" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">最后，我们将直接从运行 docker 容器的应用程序中安装以下工具:dotnet-dump。</p><ol class=""><li id="8934" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">演示应用程序</li></ol><p id="430c" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">让我们创建我们的演示:</p><p id="cd04" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">请在此处找到完整的代码库:</p><p id="447e" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated"><a class="ae kx" href="https://github.com/nicoclau/MemoryLeak" rel="noopener ugc nofollow" target="_blank">记忆缺失。NET Core 6.0 控制台应用程序演示</a></p><p id="f422" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">这里我将使用我们能找到的最简单的模板:控制台应用程序。</p><p id="067d" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">我们将创建一个非常简单的。NET 6.0 控制台应用程序(。NET 6.0 有长期支持(LTS))。</p><p id="51bb" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">我们这样做是为了知道我们需要添加什么，并避免大量的样板代码，这会使我们的教程不太清楚。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ky"><img src="../Images/779fa69938632812d243574cba248f4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*j5dDBe-DjrAmTinC"/></div></div></figure><p id="130e" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">我们将需要添加以下内容:</p><p id="4155" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi">``</p><p id="22a2" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">我们首先需要“微软。这将帮助我们使用依赖注入器(DI)容器。它将用于注入 2 个依赖项:</p><ul class=""><li id="398f" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx kr jz ka kb bi translated">记录器</li><li id="fe7d" class="jk jl in jm b jn ks jp kt jr ku jt kv jv kw jx kr jz ka kb bi translated">内存缓存(见下一个 NuGet 微软。扩展.缓存.内存)</li></ul><p id="6101" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">“微软。Extensions.Caching.Memory”将帮助我们在演示中使用内存中的缓存。</p><p id="b6ed" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">我们将向您展示当我们不恰当地使用缓存时，出现内存泄漏问题是多么容易。</p><p id="53f2" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">如果你是一个初学者，请阅读这个链接。网络核心:</p><p id="3030" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated"><a class="ae kx" href="https://learn.microsoft.com/en-us/dotnet/core/extensions/caching#in-memory-caching" rel="noopener ugc nofollow" target="_blank">内存缓存</a></p><blockquote class="lk ll lm"><p id="bab6" class="kc kd ln jm b jn jo ke kf jp jq kg kh lo ki kj kk lp kl km kn lq ko kp kq jx ig bi translated">IMemoryCache 的当前实现是 ConcurrentDictionary 的包装器，公开了一个功能丰富的 API。缓存中的条目由 ICacheEntry 表示，可以是任何对象。内存缓存解决方案非常适合在单个服务器上运行的应用程序，其中所有缓存的数据都在应用程序的进程中租用内存。</p></blockquote><p id="9aba" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">所以基本上它是一个著名的 ConcurrentDictionnary 的包装器，我们稍后会用到它的更多特性！</p><p id="73be" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">我们得到以下 csproj:</p><p id="9db0" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated"><a class="ae kx" href="https://gist.github.com/nicoclau/334b0c4371b18d9641a7982adc3d9f4b#file-memoryleak-csproj" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nicoclau/334 b0c 4371 b18d 9641 a 7982 ADC 3d 9 f4b # file-memory leak-csproj</a></p><p id="6c6e" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">最后是一个非常详细的最新文档的链接</p><p id="b7b5" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">【https://github.com/dotnet/AspNetCore. T2】docs/blob/main/aspnetcore/performance/caching/memory . MD</p><p id="99e2" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">现在让我们看看如何用程序. cs 运行我们的控制台应用程序</p><pre class="kz la lb lc gt lr ls lt lu aw lv bi"><span id="3403" class="lw lx in ls b gy ly lz l ma mb">using MemoryLeak; using Microsoft.Extensions.DependencyInjection; using Microsoft.Extensions.Hosting; IHost host = Host.CreateDefaultBuilder(args) .ConfigureServices( { services.AddMemoryCache(); services.AddHostedService&lt;MyWorker&gt;(); }) .Build(); await host.RunAsync();</span></pre><p id="99ac" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">我们首先使用<strong class="jm io">通用主机</strong>，它将为我们提供许多非常有用的特性。</p><blockquote class="lk ll lm"><p id="a250" class="kc kd ln jm b jn jo ke kf jp jq kg kh lo ki kj kk lp kl km kn lq ko kp kq jx ig bi translated"><em class="in">主机是封装了应用程序的资源和生命周期功能的对象，例如:</em></p></blockquote><ul class=""><li id="0585" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx kr jz ka kb bi translated">依赖注入</li><li id="32f0" class="jk jl in jm b jn ks jp kt jr ku jt kv jv kw jx kr jz ka kb bi translated">记录</li><li id="7862" class="jk jl in jm b jn ks jp kt jr ku jt kv jv kw jx kr jz ka kb bi translated">配置</li><li id="3987" class="jk jl in jm b jn ks jp kt jr ku jt kv jv kw jx kr jz ka kb bi translated">应用程序关闭</li><li id="14aa" class="jk jl in jm b jn ks jp kt jr ku jt kv jv kw jx kr jz ka kb bi translated">IHostedService 实现</li></ul><p id="3965" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">这里我们将使用 IHostedService、日志记录和依赖注入特性。</p><p id="0086" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">在我们的应用程序中，我们需要配置 DI 来添加两个服务:</p><ul class=""><li id="c853" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx kr jz ka kb bi translated">内存缓存服务(仅当我们不使用<a class="ae kx" href="http://ASP.NET" rel="noopener ugc nofollow" target="_blank">ASP.NET</a>核心与 AddMvc 为例。就像我们的控制台应用程序一样)</li><li id="957e" class="jk jl in jm b jn ks jp kt jr ku jt kv jv kw jx kr jz ka kb bi translated">托管服务(我们将详细说明为什么我们使用这种类型的服务)</li></ul><p id="cc91" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">当我们看扩展方法 AddMemory 时</p><p id="61fc" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">您可以在下面找到源代码:</p><p id="9088" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated"><a class="ae kx" href="https://github.com/dotnet/runtime/blob/main/src/libraries/Microsoft.Extensions.Caching.Memory/src/MemoryCacheServiceCollectionExtensions.cs" rel="noopener ugc nofollow" target="_blank">https://github . com/dot net/runtime/blob/main/src/libraries/Microsoft。extensions . caching . memory/src/memorycacheservicecollectionextensions . cs</a></p><p id="de1d" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">我们可以看到它将添加 IMemoryCache: MemoryCache 的静态实例，因为它使用了 Singleton 模式。</p><p id="c159" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">如果您没有记错的话，静态变量可能会导致内存泄漏。所以在这里要小心。</p><p id="f40e" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">我们现在将了解我们为什么使用托管服务。请记住，我们需要一个长期运行的控制台应用程序，它每秒钟都会添加一个缓存项。</p><p id="6496" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">我们需要将我们的控制台应用程序托管在一个可以一直运行的<strong class="jm io">服务中</strong>并且<strong class="jm io">可以从任何 env 优雅地关闭</strong>:服务器中的 dotnet 运行时、docker 容器或 Kubernetes。</p><p id="3548" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">为此，我们使用<strong class="jm io">通用主机</strong>的<strong class="jm io">托管服务特性</strong>。</p><p id="a501" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">请在下面找到更多细节的链接，这里我们将更多地关注我们的背景。</p><p id="1026" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated"><a class="ae kx" href="https://pgroene.wordpress.com/2018/08/02/hostbuilder-ihost-ihostedserice-console-application/" rel="noopener ugc nofollow" target="_blank">https://pgroene . WordPress . com/2018/08/02/host builder-ihost-ihostedserice-console-application/</a></p><p id="ff5e" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">我们将在通用主机中托管我们的应用程序。当这个主机启动时，它将为依赖容器中注册的每个 IHostedService 调用 StartAsync 方法。在我们的例子中，我们手动添加了一个名为 MyWorker 的托管服务。</p><p id="814b" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">让我们看看我们的托管服务 MyWorker 源代码:</p><p id="7293" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">这里我们使用了一个来自 BackgroundService 的派生类，它通过覆盖 StartAsync 和 StopAsync 方法来帮助我们正确地实现托管服务。</p><p id="ca80" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">我们需要做的就是为我们的 BackgroundService 实现编写抽象方法 ExecuteAsync。</p><pre class="kz la lb lc gt lr ls lt lu aw lv bi"><span id="c97d" class="lw lx in ls b gy ly lz l ma mb">protected override async Task ExecuteAsync(CancellationToken stoppingToken) { while (!stoppingToken.IsCancellationRequested) { _logger.LogInformation("Worker running at: {time}", DateTimeOffset.Now); await Task.Delay(1000, stoppingToken); var cacheEntryOptions = new MemoryCacheEntryOptions(); _memoryCache.Set(Guid.NewGuid(), new byte[10000], cacheEntryOptions); } }</span></pre><p id="506d" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">只要我们不要求用令牌取消，它就会循环运行。不要和 SigTerm 信号(ctrl+C)混淆，因为我们有几个不同级别的 CancellationTokens。</p><p id="7d5c" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">所以基本上这个为后台服务创建的令牌永远不会在我们的项目代码库中被取消。</p><p id="8359" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">现在我们可以看到，我们利用了与 DI 一起注入的日志记录器和由 DI 实例化的内存缓存。</p><p id="f2e1" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">我们记录日期，暂停 1000 毫秒并插入一个新项目。我们看到可以用 MemoryCacheEntryOption 配置条目插入。</p><p id="20d6" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">我们以后会明白为什么我们需要它。目前，它什么也没做。</p><p id="0441" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">现在我们有:</p><ul class=""><li id="90eb" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx kr jz ka kb bi translated">承载控制台应用程序的通用主机</li><li id="ee79" class="jk jl in jm b jn ks jp kt jr ku jt kv jv kw jx kr jz ka kb bi translated">作为后台服务实现的单个托管服务将由主机运行</li></ul><p id="46ac" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">这是一个非常简单的演示。现在让我们为我们的应用程序创建一个 docker 映像。</p><p id="2e89" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">使用 Visual Studio 2022，创建它非常简单。我们只需要向我们的项目添加一个 docker 文件:</p><p id="a156" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">我们用右键点击我们的项目存储器，选择“添加”，然后选择“Docker 支持…”菜单</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/199b7a5fcf769cc9cb22f9cefdf47dea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/0*rfo2tvlUhyIZWUZ1"/></div></figure><p id="02a7" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">Visual Studio 2022 将在项目根位置创建并添加以下 Dockerfile 文件:</p><p id="66f4" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">此外，Visual Studio 2022 将添加以下运行/调试选项:Docker</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi md"><img src="../Images/dcae3f7a7fd55dff129c08f6228cf671.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/0*edNaDFlvNoXvyUPw"/></div></figure><p id="43f4" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">我们可以通过以下链接了解这一点:</p><p id="8acf" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated"><a class="ae kx" href="https://learn.microsoft.com/en-us/visualstudio/containers/container-build?WT.mc_id=visualstudio_containers_aka_containerfastmode&amp;view=vs-2022" rel="noopener ugc nofollow" target="_blank">https://learn . Microsoft . com/en-us/visual studio/containers/container-build？wt . MC _ id = visual studio _ containers _ aka _ container fast mode&amp;view = vs-2022</a></p><p id="ea67" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">让我们运行“Docker”选项，我们看到:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi me"><img src="../Images/6c61ec64258a0b0f5f16415775375800.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*n7v4FvBOdL8XpNg9"/></div></div></figure><p id="2561" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">VS 2022 将第一次运行 docker(或者当我们更新我们的项目时),以构建一个特殊的 Docker 映像，我们可以在调试中使用它来连接 VS 2022。</p><p id="3631" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">我们将获得以下容器窗口，其中包含正在运行的容器、应用程序日志:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi mf"><img src="../Images/7d3292183b654269ff9d23bc8f2a0122.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FkxlkoPwzDoNhVWh"/></div></div></figure><p id="8470" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">所以现在我们确信我们的应用程序可以在 Kubernetes 上运行。让我们看看容器的内存使用情况:</p><pre class="kz la lb lc gt lr ls lt lu aw lv bi"><span id="108a" class="lw lx in ls b gy ly lz l ma mb">C:\Tutorial&gt;docker stats</span></pre><p id="eafa" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">我们得到:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi mg"><img src="../Images/8f1dec7f58debce72a3963621c5503e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AoW0dO6WgluMzMC-"/></div></div></figure><p id="b16d" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">61MB 在很短的时间内。</p><p id="c0ce" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">docker stats 实时更新指标</p><p id="a663" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">我们看到我们的记忆完成度上升:</p><p id="8bbb" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">它不是巨大的，但它将在一天结束的时候！它从来没有下降，所以我们肯定有一个内存泄漏。</p><p id="c8aa" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">现在让我们看看如何找到内存泄漏的原因。</p><p id="f699" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">首先，我们需要创建一个“真实的”码头工人形象。目前，我们只有一个“dev”docker 映像:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi mh"><img src="../Images/8463ae337678b61cf36c0ee9e8592c48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JMOIowQCfzE6EoPr"/></div></div></figure><p id="1561" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">当我们查看运行中的容器时:</p><p id="2bb9" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">容器 ID 图像命令创建状态</p><p id="b791" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">ca 2d fdf 7 fbbc memory leak:dev " tail-f/dev/null " 26 小时前启动</p><p id="db12" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">我们可以看到，我们没有像在 docker file<strong class="jm io">entry point[" dot net "，" MemoryLeak.dll"] </strong>中添加的那样运行应用程序的命令。我们看到的是一个虚假的命令“tail -f /dev/null ”,它只是让我们的容器保持活动状态，但不运行我们的应用程序。这将是 VS 2022 的工作，它的调试器将运行应用程序并将其自身附加到其上。</p><p id="cf75" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">让我们创建自己的 docker 图像:)</p><p id="b177" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">首先让我们停止我们的“dev”容器:</p><pre class="kz la lb lc gt lr ls lt lu aw lv bi"><span id="38a2" class="lw lx in ls b gy ly lz l ma mb">&gt; docker stop ca2dfdf7fbbc &gt; docker ps -a ca2dfdf7fbbc memoryleak:dev "tail -f /dev/null" 26 hours ago Exited (137) 10 seconds ago</span></pre><p id="c370" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">现在让我们转到 MemoryLeak.sln 位置</p><p id="ec7c" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">λ树。/f 卷 OS 卷序列号的文件夹路径列表是 yyyy C:\xxxx\MEMORYLEAK │。dockerignore │。gitattributes │。git ignore│memory leak . SLN│<a class="ae kx" href="http://README.md" rel="noopener ugc nofollow" target="_blank">readme . MD</a>│└───memoryleak</p><p id="ec97" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">然后运行以下命令 docker build，我们需要知道 Dockerfile 在哪里。我们需要从解决方案根目录运行命令。</p><pre class="kz la lb lc gt lr ls lt lu aw lv bi"><span id="f128" class="lw lx in ls b gy ly lz l ma mb">λ docker build -f MemoryLeak\Dockerfile -t memoryleak:1 .</span></pre><p id="4848" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">[+] Building 53.3s (18/18) FINISHED =&gt; [internal] load build definition from Dockerfile 0.1s =&gt; =&gt; transferring dockerfile: 733B 0.0s =&gt; [internal] load .dockerignore 0.1s =&gt; =&gt; transferring context: 382B 0.0s =&gt; [internal] load metadata for <a class="ae kx" href="http://mcr.microsoft.com/dotnet/sdk:6.0" rel="noopener ugc nofollow" target="_blank">mcr.microsoft.com/dotnet/sdk:6.0</a> 0.4s =&gt; [internal] load metadata for <a class="ae kx" href="http://mcr.microsoft.com/dotnet/runtime:6.0" rel="noopener ugc nofollow" target="_blank">mcr.microsoft.com/dotnet/runtime:6.0</a> 0.5s =&gt; [build 1/7] FROM <a class="ae kx" href="http://mcr.microsoft.com/dotnet/sdk:6.0@sha256:a788c58ec0604889912697286ce7d6a28a12ec28d375250a7cd547b619f19b37" rel="noopener ugc nofollow" target="_blank">mcr.microsoft.com/dotnet/sdk:6.0@sha256:a78..</a> 39.1s =&gt; =&gt; resolve <a class="ae kx" href="http://mcr.microsoft.com/dotnet/sdk:6.0@sha256:a788c58ec0604889912697286ce7d6a28a12ec28d375250a7cd547b619f19b37" rel="noopener ugc nofollow" target="_blank">mcr.microsoft.com/dotnet/sdk:6.0@sha256:a78..</a> 0.0s =&gt; =&gt; sha256:31b3f1ad4ce1f369084d0f959813c51df0ca17d9877d5ee88c2db6ff88341430 31.40MB / 31.40MB 8.1s =&gt; =&gt; sha256:7ed415b4bd19c2b83ef768757b22c5156111db042fd62be4263ba200b4c0c8d0 15.17MB / 15.17MB 4.9s =&gt; =&gt; sha256:357910a178d4d646acde36bf2c2a95fc59893a78c92a56a47ef8cc89627f850a 31.63MB / 31.63MB 8.2s =&gt; =&gt; sha256:a788c58ec0604889912697286ce7d6a28a12ec28d375250a7cd547b619f19b37 1.82kB / 1.82kB 0.0s =&gt; =&gt; sha256:3f5873abb5240a10f3abee05c6f89933d2da0b06037a0532aeb7ddd7959f8252 2.01kB / 2.01kB 0.0s =&gt; =&gt; sha256:05057078be7d5b0fdc8424f965a11d416639373f9388ecaeb4e2af2ce5bbc1c4 7.17kB / 7.17kB 0.0s =&gt; =&gt; sha256:7b9388913c3cc3dacffa41ae2bb30c18b54cc5f522fa6ef2faacf48b0dff6020 156B / 156B 5.0s =&gt; =&gt; sha256:871ef3419da3410a47aa97b7655d8543add053e27cac5c5922ff3ee1f75793cd 9.46MB / 9.46MB 8.1s =&gt; =&gt; sha256:c3514d10142f3a43d3037bc770248d6093c76d46a47ebe8ac4232c8b29d9eaab 25.37MB / 25.37MB 14.0s =&gt; =&gt; sha256:c65769fdd163d4fcba401982b5b50f0f78ec1970e68c45fb6671a8864c977683 148.14MB / 148.14MB 31.2s =&gt; =&gt; sha256:8b2829492cd27a90e4bde8169f4c4e3d2e6c17be2354f230684b05d40ea6df90 12.89MB / 12.89MB 12.6s =&gt; =&gt; extracting sha256:31b3f1ad4ce1f369084d0f959813c51df0ca17d9877d5ee88c2db6ff88341430 44.4s =&gt; =&gt; extracting sha256:7ed415b4bd19c2b83ef768757b22c5156111db042fd62be4263ba200b4c0c8d0 1.0s =&gt; =&gt; extracting sha256:357910a178d4d646acde36bf2c2a95fc59893a78c92a56a47ef8cc89627f850a 40.0s =&gt; =&gt; extracting sha256:7b9388913c3cc3dacffa41ae2bb30c18b54cc5f522fa6ef2faacf48b0dff6020 0.0s =&gt; =&gt; extracting sha256:871ef3419da3410a47aa97b7655d8543add053e27cac5c5922ff3ee1f75793cd 0.6s =&gt; =&gt; extracting sha256:c3514d10142f3a43d3037bc770248d6093c76d46a47ebe8ac4232c8b29d9eaab 2.5s =&gt; =&gt; extracting sha256:c65769fdd163d4fcba401982b5b50f0f78ec1970e68c45fb6671a8864c977683 6.6s =&gt; =&gt; extracting sha256:8b2829492cd27a90e4bde8169f4c4e3d2e6c17be2354f230684b05d40ea6df90 0.6s =&gt; [internal] load build context 0.1s =&gt; =&gt; transferring context: 6.34kB 0.0s =&gt; [base 1/2] FROM <a class="ae kx" href="http://mcr.microsoft.com/dotnet/runtime:6.0@sha256:dfa132a1bcb0339f54b2b518052c866986c0bb6fd77bdf692dbd3cea4c6111e6" rel="noopener ugc nofollow" target="_blank">mcr.microsoft.com/dotnet/runtime:6.0@sha256..</a> 15.7s =&gt; =&gt; resolve <a class="ae kx" href="http://mcr.microsoft.com/dotnet/runtime:6.0@sha256:dfa132a1bcb0339f54b2b518052c866986c0bb6fd77bdf692dbd3cea4c6111e6" rel="noopener ugc nofollow" target="_blank">mcr.microsoft.com/dotnet/runtime:6.0@sha256..</a> 0.0s =&gt; =&gt; sha256:357910a178d4d646acde36bf2c2a95fc59893a78c92a56a47ef8cc89627f850a 31.63MB / 31.63MB 8.2s =&gt; =&gt; sha256:dfa132a1bcb0339f54b2b518052c866986c0bb6fd77bdf692dbd3cea4c6111e6 1.82kB / 1.82kB 0.0s =&gt; =&gt; sha256:52b235bf8819546e70018d2c0612d06c28f4ac1675f54e596eda99eb3757d154 1.16kB / 1.16kB 0.0s =&gt; =&gt; sha256:66f36cf5dbe3c14bb49f5b84faba4c36ac65130f464446a00818b4d217ca6abd 2.80kB / 2.80kB 0.0s =&gt; =&gt; sha256:31b3f1ad4ce1f369084d0f959813c51df0ca17d9877d5ee88c2db6ff88341430 31.40MB / 31.40MB 8.1s =&gt; =&gt; sha256:7ed415b4bd19c2b83ef768757b22c5156111db042fd62be4263ba200b4c0c8d0 15.17MB / 15.17MB 4.9s =&gt; =&gt; sha256:7b9388913c3cc3dacffa41ae2bb30c18b54cc5f522fa6ef2faacf48b0dff6020 156B / 156B 5.0s =&gt; =&gt; extracting sha256:31b3f1ad4ce1f369084d0f959813c51df0ca17d9877d5ee88c2db6ff88341430 3.0s =&gt; =&gt; extracting sha256:7ed415b4bd19c2b83ef768757b22c5156111db042fd62be4263ba200b4c0c8d0 1.0s =&gt; =&gt; extracting sha256:357910a178d4d646acde36bf2c2a95fc59893a78c92a56a47ef8cc89627f850a 2.0s =&gt; =&gt; extracting sha256:7b9388913c3cc3dacffa41ae2bb30c18b54cc5f522fa6ef2faacf48b0dff6020 0.0s =&gt; [base 2/2] WORKDIR /app 0.9s =&gt; [final 1/2] WORKDIR /app 0.2s =&gt; [build 2/7] WORKDIR /src 1.3s =&gt; [build 3/7] COPY [MemoryLeak/MemoryLeak.csproj, MemoryLeak/] 0.1s =&gt; [build 4/7] RUN dotnet restore “MemoryLeak/MemoryLeak.csproj” 3.9s =&gt; [build 5/7] COPY . . 0.3s =&gt; [build 6/7] WORKDIR /src/MemoryLeak 0.1s =&gt; [build 7/7] RUN dotnet build “MemoryLeak.csproj” -c Release -o /app/build 4.4s =&gt; [publish 1/1] RUN dotnet publish “MemoryLeak.csproj” -c Release -o /app/publish /p:UseAppHost=false 3.1s =&gt; [final 2/2] COPY — from=publish /app/publish . 0.1s =&gt; exporting to image 0.1s =&gt; =&gt; exporting layers 0.1s =&gt; =&gt; writing image sha256:527b38b31f488ddefd8c3fe00bd47da30dbd88dfe36516c760866afb809c0a9f 0.0s =&gt; =&gt; naming to <a class="ae kx" href="http://docker.io/library/memorylceak:1" rel="noopener ugc nofollow" target="_blank">docker.io/library/memorylceak:1</a> 0.0s</p><p id="be18" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">使用“docker 扫描”对图像运行 Snyk 测试，以找到漏洞并了解如何修复它们</p><p id="c75c" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">第一次用了一会儿(只有 0.3 秒而不是 53.3 秒！)如果我们再做一次，速度会更快，因为 Docker 使用了缓存层:</p><p id="9328" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">现在让我们检查一下我们的 docker 图像:</p><pre class="kz la lb lc gt lr ls lt lu aw lv bi"><span id="a022" class="lw lx in ls b gy ly lz l ma mb">λ docker images REPOSITORY TAG IMAGE ID CREATED SIZE memoryleak 1 527b38b31f48 8 minutes ago 190MB</span></pre><p id="0e76" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">让我们通过运行一个容器来测试我们的 docker 映像:</p><pre class="kz la lb lc gt lr ls lt lu aw lv bi"><span id="227f" class="lw lx in ls b gy ly lz l ma mb">λ docker run memoryleak:1</span></pre><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/117d2c08050ead2672549ecb8e9705aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/0*IH9BlOHrApb3zldz"/></div></figure><p id="2ac8" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">我们现在准备在一个 kubernetes 集群中部署它。</p><p id="dd19" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">首先，我们需要轻松地创建这个集群。</p><p id="42f1" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">我们将使用<strong class="jm io"> Minikube </strong>，它非常简单且功能强大，足以满足我们的需求:我们在 kubernetes 集群中只需要一个节点。</p><p id="e15a" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">请访问以下链接:</p><p id="ac2e" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">https://minikube.sigs.k8s.io/docs/<a class="ae kx" href="https://minikube.sigs.k8s.io/docs/" rel="noopener ugc nofollow" target="_blank">欢迎页面</a></p><p id="f2a9" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">安装页面【https://minikube.sigs.k8s.io/docs/start/ T4】</p><p id="6738" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">这非常简单，它自动检测你的开发机器的正确安装程序！</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi mj"><img src="../Images/ddd38778bc8ce0911bd6ebba68b97847.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XHOXE4GPzsUMRbpv"/></div></div></figure><p id="8da3" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">我们需要跑</p><p id="0ec2" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated"><strong class="jm io">！！传递参数-extra-config = kube let . housing-interval 非常重要，否则我们将无法从 pod 中获取指标！！</strong></p><p id="f1ab" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">我们准备好使用我们的 kubernetes 集群了！</p><p id="1292" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">我们还需要启用两个附加组件:</p><ul class=""><li id="b5f4" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx kr jz ka kb bi translated">带有命令的仪表板:minikube 插件启用指标-服务器</li><li id="62bd" class="jk jl in jm b jn ks jp kt jr ku jt kv jv kw jx kr jz ka kb bi translated">metrics-server 命令:minikube addons 启用 metrics-server</li></ul><p id="0ecd" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">我们必须启用以下附加组件:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi mk"><img src="../Images/ff75506b5bef6a73f01dbeedaa7cb867.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*C5DGLW7WWiZhJYLh"/></div></div></figure><p id="4231" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">让我们打开仪表板:</p><pre class="kz la lb lc gt lr ls lt lu aw lv bi"><span id="90d8" class="lw lx in ls b gy ly lz l ma mb">λ minikube dashboard * Verifying dashboard health ... * Launching proxy ... * Verifying proxy health ... * Opening http:</span></pre><p id="da7a" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">浏览打开，我们看到:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ml"><img src="../Images/65bbe0655af3ae093202419fe40aea40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EyXWI1RLa1PXvHer"/></div></div></figure><p id="46be" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">让我们将内存泄漏 docker 映像添加到 minikube 使用的 VM 中:</p><pre class="kz la lb lc gt lr ls lt lu aw lv bi"><span id="1738" class="lw lx in ls b gy ly lz l ma mb">λ minikube image load memoryleak:1</span></pre><p id="fb23" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">过了一会儿，docker 映像在虚拟机中可用了。</p><p id="f900" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">让我们检查一下:</p><p id="c2ce" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">我们使用 SSH 访问虚拟机:</p><p id="5157" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">我们可以看到 memoryleak docker 图像。</p><p id="2654" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">我们现在可以部署它，并使用度量服务器查看内存度量！</p><p id="51cf" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">让我们打开部署表单页面:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ml"><img src="../Images/d8f715fbd110b8de350a359b725e9271.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9V4QKHgc59cJIhn-"/></div></div></figure><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/770b270116155d1d999f680fc4f841bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/0*QKBeRuhgpIz2RnYP"/></div></figure><p id="469f" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">我们单击部署</p><p id="5bd3" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">我们得到:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi mn"><img src="../Images/734e96dfcf31f2119f605eb8993351f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5TalHFoDiqlpdDRc"/></div></div></figure><p id="582a" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">我们成功地在 minikube 集群上部署了我们的应用，部署时只使用了一个 pod。</p><p id="2d4d" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">过一会儿，我们会看到显示的 CPU 和内存指标:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi mo"><img src="../Images/7f89b9a47b7eb5d6484888b0718a7c8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wd3xidfzHqkHBgha"/></div></div></figure><p id="4f37" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">几分钟后我们看到记忆的完善演变:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi mp"><img src="../Images/292834ac27b2c072342fe934f933974b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LpNjPcaj8l8BXwT1"/></div></div></figure><p id="e1af" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">我们可以看到内存使用缓慢上升，但没有停止。</p><p id="1909" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">我们可以看到日志</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi mq"><img src="../Images/7abf94f8015b3331de682a87e8f2e9b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*klADtQchrWy7t3S-"/></div></div></figure><p id="08a1" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">让我们详细看看内存使用情况</p><p id="8231" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">点击执行</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/7bc955cf95a55d69d7ca648f03d980f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:446/0*Sd_KQlo1F0d--iy4"/></div></figure><p id="9df8" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">让我们运行命令:</p><pre class="kz la lb lc gt lr ls lt lu aw lv bi"><span id="9040" class="lw lx in ls b gy ly lz l ma mb">root@memoryleakapp-69dc6dfc5f-knch2:/app# cat /sys/fs/cgroup/memory/memory.usage_in_bytes</span></pre><p id="7893" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">运行它很多次，我们可以看到内存使用量不断增加。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/0901c88f089a1540b584af481e3d682a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/0*HXkSUqW-ux1mreHq"/></div></figure><p id="5e0c" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">现在我们看到了内存泄漏，让我们通过使用我们需要安装在 pod 中的另一个工具来看看为什么会发生这种情况。</p><p id="766f" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">在 pod 内安装点网络转储</p><p id="c196" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated"><a class="ae kx" href="https://learn.microsoft.com/en-us/dotnet/core/diagnostics/dotnet-dump" rel="noopener ugc nofollow" target="_blank">https://learn . Microsoft . com/en-us/dot net/core/diagnostics/dot net-dump</a></p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/9c81cb3569008ab422a3a95e53397e24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/0*TMDJ79Vgq2qEh3L8"/></div></figure><p id="725e" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">我们需要更新我们容器的 Debian Linux repo 并安装 curl 工具:</p><p id="f802" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">我们使用命令:apt 安装 curl</p><p id="3dbd" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">现在，让我们从以下网址下载我们的工具:</p><p id="71b4" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated"><a class="ae kx" href="https://aka.ms/dotnet-dump/linux-x64" rel="noopener ugc nofollow" target="_blank">aka.ms/dotnet-dump/linux-x64</a></p><p id="ea07" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">我们在/tools 创建了一个目录，并在那里下载了我们的工具:</p><p id="00be" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">现在我们需要使 dotnet-dump 成为一个可执行文件:</p><pre class="kz la lb lc gt lr ls lt lu aw lv bi"><span id="3333" class="lw lx in ls b gy ly lz l ma mb">root@memoryleakapp-69dc6dfc5f-m28fv:/tools# chmod +x dotnet-dump root@memoryleakapp-69dc6dfc5f-m28fv:/tools# dotnet-dump --help bash: dotnet-dump: command not found root@memoryleakapp-69dc6dfc5f-m28fv:/tools# ./dotnet-dump --help Usage: dotnet-dump [options] [command] Options: --version Show version information -?, -h, --help Show help and usage information Commands: collect Capture dumps from a process analyze &lt;dump_path&gt; Starts an interactive shell with debugging commands to explore a dump ps Lists the dotnet processes that dumps can be collected from.</span></pre><p id="0804" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">现在我们可以看到这些过程:</p><pre class="kz la lb lc gt lr ls lt lu aw lv bi"><span id="811e" class="lw lx in ls b gy ly lz l ma mb">root@memoryleakapp-69dc6dfc5f-m28fv:/tools# ./dotnet-dump ps 1 dotnet /usr/share/dotnet/dotnet dotnet MemoryLeak.dll</span></pre><p id="cc23" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">现在，让我们从这个过程中收集两个转储文件，中间间隔几分钟，这样我们可以更清楚地看到其中的内存泄漏:</p><pre class="kz la lb lc gt lr ls lt lu aw lv bi"><span id="af2e" class="lw lx in ls b gy ly lz l ma mb">root@memoryleakapp-69dc6dfc5f-m28fv:/tools# ./dotnet-dump collect -p 1 Writing full to /tools/core_20221008_173927 Complete root@memoryleakap</span></pre><p id="226e" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">一旦我们运行了两次这个命令，我们就用下面的命令将这些转储文件从 pod 复制到我们的开发机器上的本地目录:</p><pre class="kz la lb lc gt lr ls lt lu aw lv bi"><span id="ed56" class="lw lx in ls b gy ly lz l ma mb">λ kubectl cp default/memoryleakapp-69dc6dfc5f-m28fv:/tools/core_20221008_172957 core_20221008_172957.dump</span></pre><p id="c49e" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">就是把文件从 pod 复制到我们的机器上。</p><p id="0899" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">首先在源代码中:我们在这里给定 pod 的名称空间 default，然后是 pod 名称，然后是分隔符':'，然后是文件名</p><p id="dcca" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">我们给了一个空间</p><p id="14c5" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">然后第二在目的地我们给你想要的路径和文件名。</p><p id="fee6" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">我们对第二个转储文件做同样的事情:</p><pre class="kz la lb lc gt lr ls lt lu aw lv bi"><span id="42b1" class="lw lx in ls b gy ly lz l ma mb">λ kubectl cp default/memoryleakapp-69dc6dfc5f-m28fv:/tools/core_20221008_173323 core_20221008_173323.dump</span></pre><p id="4c73" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">现在我们有了两个转储文件，我们可以使用它们来获得内存泄漏的来源。</p><p id="75ab" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">这将是我们下一篇文章的主题！</p><p id="8542" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">结论:</p><p id="8a9b" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated">我们学习了如何使用 microsoft 工具在任何 kubernetes 集群中运行的. Net 核心应用程序出现内存泄漏时获取转储。</p></div><div class="ab cl mu mv hr mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ig ih ii ij ik"><p id="e974" class="pw-post-body-paragraph kc kd in jm b jn jo ke kf jp jq kg kh jr ki kj kk jt kl km kn jv ko kp kq jx ig bi translated"><em class="ln">原载于</em><a class="ae kx" href="https://nicolasbarlatier.hashnode.dev/net-core-tip-2-how-to-troubleshoot-memory-leaks-within-a-net-console-application-running-in-a-linux-docker-container-in-kubernetes" rel="noopener ugc nofollow" target="_blank"><em class="ln">https://nicolasbarlatier . hash node . dev</em></a><em class="ln">。</em></p></div></div>    
</body>
</html>