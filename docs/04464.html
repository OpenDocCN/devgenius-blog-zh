<html>
<head>
<title>Key Intricacies Of Methods, Procedures, And Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">方法、程序和功能的关键复杂性</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/key-intricacies-every-good-developer-knows-about-methods-procedures-and-functions-e4311136d039?source=collection_archive---------9-----------------------#2021-03-19">https://blog.devgenius.io/key-intricacies-every-good-developer-knows-about-methods-procedures-and-functions-e4311136d039?source=collection_archive---------9-----------------------#2021-03-19</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="6c42" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">每个开发人员都使用但不太了解的东西</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/5754116e2116e3e5d4da7ada430132e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rcUAW6DV-sEur3Ew"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated">照片由<a class="ae kw" href="https://www.pexels.com/@lee-campbell-18167?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">李·坎贝尔</a>从<a class="ae kw" href="https://www.pexels.com/photo/imac-turend-on-89724/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>拍摄</figcaption></figure><p id="96f4" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">你使用方法。功能。程序。很多。</p><p id="7619" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">但是，你不知道区别。你想知道更多。</p><p id="b6ab" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">开发人员用 Java 调用方法。低级语言中的过程。脚本语言中的函数。</p><p id="b5de" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">编程语言不做区分。函数、过程和方法之间没有明确的界限。</p><p id="6cac" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我的想法会激发你的探索。追寻的追求。追求功能的差异和细微差别。</p></div><div class="ab cl lt lu hv lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ik il im in io"><h1 id="fe73" class="ma mb ir bd mc md me mf mg mh mi mj mk jx ml jy mm ka mn kb mo kd mp ke mq mr bi translated">功能</h1><p id="faae" class="pw-post-body-paragraph kx ky ir kz b la ms js lc ld mt jv lf lg mu li lj lk mv lm ln lo mw lq lr ls ik bi translated">函数是子程序。返回结果的子例程。</p><p id="b83c" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">优秀的开发人员编写纯函数，因为它们没有副作用。相同的输入永远得到相同的结果。这就是纯函数的定义。</p><p id="1606" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在 Java 中，有类方法和对象方法。用类方法我们模仿函数。他们没有收到<code class="fe mx my mz na b">this</code>，实例不存在，因此<code class="fe mx my mz na b">this</code>不可用。</p><p id="b21b" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">与实例分离，并对类进行操作。用<code class="fe mx my mz na b">static</code>关键字来声明类方法。我们不需要类实例。</p></div><div class="ab cl lt lu hv lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ik il im in io"><h2 id="7c13" class="nb mb ir bd mc nc nd dn mg ne nf dp mk lg ng nh mm lk ni nj mo lo nk nl mq nm bi translated">Javascript 函数</h2><p id="22ae" class="pw-post-body-paragraph kx ky ir kz b la ms js lc ld mt jv lf lg mu li lj lk mv lm ln lo mw lq lr ls ik bi translated">Javascript 函数则不同。很特别。那个<code class="fe mx my mz na b">new Function()</code>是怎么回事？</p><p id="a622" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我们在 Javascript 中有一个基于原型的继承。不要与其他形式的继承相混淆。这就是为什么调用<code class="fe mx my mz na b">new Function()</code>时会调用<code class="fe mx my mz na b">prototype</code>构造函数的原因。</p><p id="e073" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">原型继承如何工作的详细图表。忽略<code class="fe mx my mz na b">_proto_</code>它已被弃用。当我们调用<code class="fe mx my mz na b">new Foo</code>时，我们调用<code class="fe mx my mz na b">Foo.prototype</code>的构造函数。请访问图片下方的链接，了解有关此行为的更多详细信息。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj nn"><img src="../Images/8496d5a0dcaa464a7669b34d24a445fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kKbT-EfVQTPb9xR9.png"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated"><a class="ae kw" href="https://softwareengineering.stackexchange.com/questions/369631/unable-to-solve-mystery-of-functions-in-javascript" rel="noopener ugc nofollow" target="_blank">JS 函数之谜</a></figcaption></figure><p id="278a" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我在答案中举了一个具体的例子。</p><pre class="kh ki kj kk gu no na np nq aw nr bi"><span id="a9b7" class="nb mb ir na b gz ns nt l nu nv">function Car(){ }<br/>var honda = new Car();<br/>print(honda instanceof Car);<br/>print(honda.constructor == Car);</span></pre><p id="37f6" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">每张照片会印出什么？<code class="fe mx my mz na b">honda</code>是 Car 的一个实例，因为它的原型链上有<code class="fe mx my mz na b">Car.prototype</code>。本田的构造器是<code class="fe mx my mz na b">Car</code>，是<code class="fe mx my mz na b">Car.prototype</code>对象的构造器。</p><p id="2fd1" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我知道这是纠缠不清的，因此 JS 函数有单独的部分。他们很特别。不同的品种，没有人喜欢不同的。然而，正如我们所知，它们为整个 UI 空间提供了动力。</p></div><div class="ab cl lt lu hv lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ik il im in io"><h1 id="243d" class="ma mb ir bd mc md me mf mg mh mi mj mk jx ml jy mm ka mn kb mo kd mp ke mq mr bi translated">程序</h1><p id="e82b" class="pw-post-body-paragraph kx ky ir kz b la ms js lc ld mt jv lf lg mu li lj lk mv lm ln lo mw lq lr ls ik bi translated">过程是子程序，但有副作用。过程不返回任何值。</p><p id="ec49" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">参见 printf 的<a class="ae kw" href="https://linux.die.net/man/1/printf" rel="noopener ugc nofollow" target="_blank">手册。</a></p><p id="d812" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">什么是副作用？打印到屏幕上被认为是一种副作用。我们了解函数中的屏幕吗？不，这是副作用。</p><p id="bb5f" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">看着帕斯卡，有点。感谢上帝，没有商业用途。过程没有返回值，而函数有。</p><p id="c113" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在网上搜了一下，发现了这个评论。<em class="nw">在 Fortran 中，函数返回值，子程序返回多个值。</em>因此，这可能不是程序的正确定义。</p><p id="9226" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">即便如此，你也可以在编程行话中找到过程。了解一点他们也无妨。</p></div><div class="ab cl lt lu hv lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ik il im in io"><h1 id="eb07" class="ma mb ir bd mc md me mf mg mh mi mj mk jx ml jy mm ka mn kb mo kd mp ke mq mr bi translated">方法</h1><p id="f29b" class="pw-post-body-paragraph kx ky ir kz b la ms js lc ld mt jv lf lg mu li lj lk mv lm ln lo mw lq lr ls ik bi translated"><code class="fe mx my mz na b">foo.myFooMethod</code></p><p id="b332" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">对一个对象调用的函数(<code class="fe mx my mz na b">foo</code>)是一个方法(<code class="fe mx my mz na b">myFooMethod</code>)。<code class="fe mx my mz na b">this</code>被传递给函数，因为它是被调用的对象(<code class="fe mx my mz na b">foo</code>)。</p><p id="dd09" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">不要被误解为闭包。闭包考虑了词法环境。您可以引用不作为参数传递的变量。方法确实有<code class="fe mx my mz na b">this</code>作为参数。</p><p id="af64" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">重写方法是函数做不到的。您可以重写方法，并提供新的行为。</p><p id="c089" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这是一把双刃剑，也可能适得其反。这就是为什么我们有 OO 设计原则。</p><p id="b5dd" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">方法还能做什么？扩展类行为。看看 C#中的扩展方法。它们扩展了现有的类。</p><p id="8eaa" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">所以，你想要<code class="fe mx my mz na b">String</code>的新行为。你创建<code class="fe mx my mz na b">StringExtensions</code>和<a class="ae kw" href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods" rel="noopener ugc nofollow" target="_blank">添加新的方法</a>。</p></div><div class="ab cl lt lu hv lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ik il im in io"><h1 id="bfc0" class="ma mb ir bd mc md me mf mg mh mi mj mk jx ml jy mm ka mn kb mo kd mp ke mq mr bi translated">结论</h1><p id="e8e0" class="pw-post-body-paragraph kx ky ir kz b la ms js lc ld mt jv lf lg mu li lj lk mv lm ln lo mw lq lr ls ik bi translated">你知道的已经足够开始了。开始研究方法。研究程序或功能。我在文章中提到了闭包，也去查一下。</p><p id="ec31" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">同一件事有不同的细微差别。为计算机传递我们的想法。然而，我们对思想传递过程知之甚少。</p></div><div class="ab cl lt lu hv lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ik il im in io"><h1 id="eb29" class="ma mb ir bd mc md me mf mg mh mi mj mk jx ml jy mm ka mn kb mo kd mp ke mq mr bi translated">资源</h1><div class="nx ny gq gs nz oa"><a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fp"><div class="oc ab od cl cj oe"><h2 class="bd is gz z fq of fs ft og fv fx iq bi translated">扩展方法- C#编程指南</h2><div class="oh l"><h3 class="bd b gz z fq of fs ft og fv fx dk translated">扩展方法使您能够向现有类型“添加”方法，而无需创建新的派生类型、重新编译或…</h3></div><div class="oi l"><p class="bd b dl z fq of fs ft og fv fx dk translated">docs.microsoft.com</p></div></div><div class="oj l"><div class="ok l ol om on oj oo kq oa"/></div></div></a></div><div class="nx ny gq gs nz oa"><a href="https://softwareengineering.stackexchange.com/questions/222345/whats-the-difference-between-a-function-and-a-method" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fp"><div class="oc ab od cl cj oe"><h2 class="bd is gz z fq of fs ft og fv fx iq bi translated">函数和方法有什么区别？</h2><div class="oh l"><h3 class="bd b gz z fq of fs ft og fv fx dk translated">Java 本身没有函数。你有的只是方法。为了模仿函数，Java 一般使用静态…</h3></div><div class="oi l"><p class="bd b dl z fq of fs ft og fv fx dk translated">softwareengineering.stackexchange.com</p></div></div><div class="oj l"><div class="op l ol om on oj oo kq oa"/></div></div></a></div><div class="nx ny gq gs nz oa"><a href="https://softwareengineering.stackexchange.com/questions/20909/method-vs-function-vs-procedure" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fp"><div class="oc ab od cl cj oe"><h2 class="bd is gz z fq of fs ft og fv fx iq bi translated">方法 vs 函数 vs 过程</h2><div class="oh l"><h3 class="bd b gz z fq of fs ft og fv fx dk translated">软件工程栈交换是一个为专业人士，学者和学生工作的问答网站</h3></div><div class="oi l"><p class="bd b dl z fq of fs ft og fv fx dk translated">softwareengineering.stackexchange.com</p></div></div><div class="oj l"><div class="oq l ol om on oj oo kq oa"/></div></div></a></div><div class="nx ny gq gs nz oa"><a href="https://softwareengineering.stackexchange.com/questions/369631/unable-to-solve-mystery-of-functions-in-javascript" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fp"><div class="oc ab od cl cj oe"><h2 class="bd is gz z fq of fs ft og fv fx iq bi translated">无法解决 Javascript 中的函数之谜</h2><div class="oh l"><h3 class="bd b gz z fq of fs ft og fv fx dk translated">我试图理解 Javascript 的幕后场景，但却陷入了对创造的理解…</h3></div><div class="oi l"><p class="bd b dl z fq of fs ft og fv fx dk translated">softwareengineering.stackexchange.com</p></div></div><div class="oj l"><div class="or l ol om on oj oo kq oa"/></div></div></a></div></div></div>    
</body>
</html>