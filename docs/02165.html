<html>
<head>
<title>Ruby: Fake Operators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ruby:假运算符</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/ruby-fake-operators-721fdb6446c9?source=collection_archive---------11-----------------------#2020-07-21">https://blog.devgenius.io/ruby-fake-operators-721fdb6446c9?source=collection_archive---------11-----------------------#2020-07-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/cac5cb9b5d6dc0149275f9d28c5725b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*X2WZMQOxqBnchLxS"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">法比安·格罗斯在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="6f9e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我想讨论 ruby 编程语言的一个更有趣的方面，即 Ruby 中的大多数“操作符”实际上都是方法。这里列出了一些比较常见的假冒运营商。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="9421" class="lk ll iq lg b gy lm ln l lo lp">[], []=, &lt;, &gt;, ==, +, -, *, \,  %</span></pre><p id="92b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着什么，为什么重要？这意味着当你调用上面的一个操作符时，你实际上是在调用一个方法。这很重要，因为每个类都可以有自己的方法实现，这意味着同一个方法可能会根据它所调用的对象的类而有不同的行为。这就是下面的代码起作用的原因。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lq lr l"/></div></figure><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="4ce6" class="lk ll iq lg b gy lm ln l lo lp">Output: </span><span id="c0a4" class="lk ll iq lg b gy ls ln l lo lp">5</span><span id="808a" class="lk ll iq lg b gy ls ln l lo lp">ab</span></pre><p id="7fae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然这段代码看起来非常简单，但是确实发生了很多事情。在第一行，方法<a class="ae kc" href="https://docs.ruby-lang.org/en/2.6.0/Integer.html#method-i-2B" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> Integer#+ </strong> </a>在<strong class="kf ir"> 2 </strong>上被调用，参数为<strong class="kf ir"> 3 </strong>。这个方法的返回值<strong class="kf ir"> 5 </strong>通过赋值运算符(<strong class="kf ir"> = </strong>是实运算符而不是方法)保存到变量<strong class="kf ir"> x </strong>。这是预期的结果，因为我们把+和加法联系在一起。但是，<strong class="kf ir"> 'a' + 'b' </strong>呢？我们只得到<strong class="kf ir"> ab </strong>的结果，因为方法不同，<strong class="kf ir"> </strong> <a class="ae kc" href="https://docs.ruby-lang.org/en/2.6.0/String.html#method-i-2B" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">串# </strong> + </a>，被称为。这种方法不是将两个数字相加，而是将两个字符串连接在一起。看起来好像只要它按照我们期望的方式工作，它是方法还是操作符并不重要。在某些情况下这是真的，但是理解这种差异的主要原因是因为<em class="lt">方法可以被覆盖！这里有一个会让你立刻被解雇的例子。</em></p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lq lr l"/></div></figure><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="7187" class="lk ll iq lg b gy lm ln l lo lp">Output:</span><span id="272c" class="lk ll iq lg b gy ls ln l lo lp">No more addition for you!</span></pre><p id="8784" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果将这种变化添加到代码库中，上面的例子可能会使整个银行系统崩溃。那里发生了什么？方法<strong class="kf ir"> Integer#+ </strong>被重写为总是返回字符串，“没有更多的加法！”。当你重写一个方法或者添加一个新的方法到一个现有的类中时，这就是所谓的猴子补丁。这是一种危险的技术，应该谨慎使用，因为它可能会产生意想不到的结果。但是，当使用自定义类时，可以很好地使用重写方法。例如:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lq lr l"/></div></figure><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="f4e6" class="lk ll iq lg b gy lm ln l lo lp">Output: <br/>52<br/>#&lt;Person:0x00007f85f00de350&gt;<br/>#&lt;Person:0x00007f85f00de300&gt;</span></pre><p id="c3ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个例子中，方法<strong class="kf ir"> #+ </strong>被定义为将两个人的年龄相加，因此我们输出总数<strong class="kf ir"> 52 </strong>。这带来了许多可能性，因为您的自定义类的实例可以以您定义的任何方式相互交互以及与其他对象交互。然而，当我们<strong class="kf ir">将</strong>约翰和丽莎分开时，输出并不是很有描述性。由于这个原因，重写<strong class="kf ir"> #to_s </strong>方法是很常见的。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lq lr l"/></div></figure><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="258c" class="lk ll iq lg b gy lm ln l lo lp">Output:</span><span id="a77a" class="lk ll iq lg b gy ls ln l lo lp">John</span><span id="b71a" class="lk ll iq lg b gy ls ln l lo lp">Lisa</span></pre><p id="c17b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个例子中，方法<strong class="kf ir"> #to_s </strong>被覆盖以返回人名。<strong class="kf ir"> #puts </strong>在其参数上自动调用<strong class="kf ir"> #to_s </strong>，因此我们能够<strong class="kf ir">puts</strong>person 对象并在输出中看到他们的名字。假设我们也想根据人们的年龄来比较他们。我们可以包含<strong class="kf ir"> Comparable </strong>模块，定义自己的方法进行组合比较，<strong class="kf ir"> # &lt; = &gt; </strong>。组合比较运算符，或称为宇宙飞船运算符，是一种比较两个对象的方法。它通常被称为运算符，但它仍然是一种方法。例如:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="c66b" class="lk ll iq lg b gy lm ln l lo lp"><strong class="lg ir">a &lt;=&gt; b</strong></span><span id="bd56" class="lk ll iq lg b gy ls ln l lo lp">returns 1 if a &gt; b</span><span id="934b" class="lk ll iq lg b gy ls ln l lo lp">returns -1 if a &lt; b</span><span id="06e8" class="lk ll iq lg b gy ls ln l lo lp">returns 0 if a == b</span></pre><p id="5ae1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该方法是其他比较方法如<strong class="kf ir"> # &gt; </strong>、<strong class="kf ir"> #== </strong>的基础。排序方法和其他比较值的方法也使用它，如<a class="ae kc" href="https://docs.ruby-lang.org/en/2.6.0/Array.html#method-i-sort" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> Array#sort </strong> </a>和<a class="ae kc" href="https://docs.ruby-lang.org/en/2.6.0/Array.html#method-i-min" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> Array#min </strong> </a>。通过在自定义类中定义这个方法，我们可以访问许多新方法。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lq lr l"/></div></figure><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="c98b" class="lk ll iq lg b gy lm ln l lo lp">Output:</span><span id="1aa5" class="lk ll iq lg b gy ls ln l lo lp">false</span><span id="e24d" class="lk ll iq lg b gy ls ln l lo lp">true</span><span id="75e1" class="lk ll iq lg b gy ls ln l lo lp">true</span><span id="1f2d" class="lk ll iq lg b gy ls ln l lo lp">Tyler</span><span id="b860" class="lk ll iq lg b gy ls ln l lo lp">Lisa</span><span id="363e" class="lk ll iq lg b gy ls ln l lo lp">People in order of ages:</span><span id="6253" class="lk ll iq lg b gy ls ln l lo lp">Tyler</span><span id="22e5" class="lk ll iq lg b gy ls ln l lo lp">John</span><span id="8100" class="lk ll iq lg b gy ls ln l lo lp">Chloe</span><span id="d546" class="lk ll iq lg b gy ls ln l lo lp">Lisa</span></pre><p id="ea77" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这演示了如何定义你自己的<strong class="kf ir"> # &lt; = &gt; </strong>方法并包含<strong class="kf ir">可比较的</strong>允许你以任何对你的程序有意义的方式比较对象。它还提供了在实现中使用<strong class="kf ir"> # &lt; = &gt; </strong>的方法。</p><p id="4819" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总之，Ruby 中的许多操作符实际上都是方法。如果您不确定您使用的是操作符还是方法，您可以查看 Ruby 文档来找到答案。有了这些知识，您可以重写现有的方法，向现有的类添加新的方法，并向自定义的类添加看起来像操作符的方法。这是一个强大而危险的工具，必须小心使用，但如果使用正确，它可以使您的程序更具可读性，并为您的自定义类提供更多功能。编码快乐！</p></div></div>    
</body>
</html>