<html>
<head>
<title>Roll with the changes in Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">跟随库本内特斯的变化</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/hardening-your-kubernetes-stack-pt-3-b260d45fe6e?source=collection_archive---------5-----------------------#2020-08-05">https://blog.devgenius.io/hardening-your-kubernetes-stack-pt-3-b260d45fe6e?source=collection_archive---------5-----------------------#2020-08-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="37d6" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">滚动更新和探测</h2></div><p id="4494" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">变更是所有软件生命周期的一部分，但是我们如何确保在Kubernetes (k8s)中安全地进行变更呢？我们将通过分别利用k8s的滚动更新属性和Pod中断预算来应对应用程序、Pod和底层基础架构的变化。我们还将研究就绪性和活性探测。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ky"><img src="../Images/bcfc9c58c20597c98a5d1456f4f13dbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JnkYLz38hYIfed_b"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated">克里斯·劳顿在<a class="ae lo" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h2 id="affc" class="lp lq in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">滚动更新</h2><p id="f8a8" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated"><a class="ae lo" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" rel="noopener ugc nofollow" target="_blank">部署</a>提供了定义如何在pod上执行滚动更新的功能。使用RollingUpdate策略，可以定义两个属性:maxSurge和maxUnavailable。MaxSurge定义了在更新过程中可以超过当前pod计数的pod数量或百分比。这可以是您在部署中设置的数量，也可以是由水平pod自动缩放器(<a class="ae lo" href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/#autoscaling-during-rolling-update" rel="noopener ugc nofollow" target="_blank"> doc </a>)设置的当前数量。MaxUnavailable指定在更新过程中可以杀死的单元的数量或百分比。</p><p id="e373" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">示例:</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="c152" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们的第一次部署中(第10–14行)，我们将maxSurge和maxUnavailable都定义为1。这意味着在更新过程中，会创建1个新pod，并杀死1个旧pod，直到所有pod都被替换。由于副本是10，最多你会看到11个豆荚，至少你会看到9个豆荚。<br/>在我们的第二次部署中(第36–40行),我们定义了一个百分比。maxSurge和maxUnavailable的25%。假设当前的吊舱数量是10，这意味着4，10 x 25%，新吊舱将旋转起来，4个旧吊舱将被杀死，直到所有吊舱被替换。由于副本是10，最多你会看到14个豆荚，至少你会看到6个豆荚。</p><p id="f5c6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那么k8s什么时候知道什么时候转移到下一组pod进行更新呢？就绪和活性探测。</p><h2 id="dab2" class="lp lq in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">就绪性和活性探测</h2><p id="ddee" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">K8s，特别是<a class="ae lo" href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/" rel="noopener ugc nofollow" target="_blank"> kubelet </a>，使用就绪性和活性探测器来确定容器的当前状态。Kubelet存在于每个worker节点上，并根据您的就绪性或/和活性探测配置不断探测您的容器。就绪探针和活性探针之间的主要区别在于kubelet对失败探针的反应。</p><p id="c2b1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">活性探测器确定容器是否是“活性的”。如果探针失败，k8s将杀死容器并重新启动它，因为假定容器已经死亡。活性终点应该是亮的，并且应该反映容器是否是活性的。</p><p id="a021" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">准备就绪探测器确定集装箱是否准备好为运输服务。根据容器的不同，这可能意味着建立数据库连接、设置配置或将数据加载到内存中。这意味着容器上的就绪端点应该反映一个pod是否就绪，并确保在它返回健康状态之前设置好所有依赖项。当准备就绪探测失败时，k8s不会向pod发送流量，并将pod标记为<code class="fe mp mq mr ms b">Unready</code>。</p><p id="4c1d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">示例:</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="cb68" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有许多方法可以配置您的探测器，您可以发送一个HTTP请求(第3–6行)，发送一个TCP请求(第13–14行)，或者在容器上执行一个命令(第21–24行)。请注意，就绪性和活性探测都可以利用这些类型的探测。</p><p id="2055" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> HTTP probe </strong>(第3–6行)针对pod上的指定端口发送HTTP get请求。您可以通过<code class="fe mp mq mr ms b">scheme</code>在HTTP或HTTPS之间进行选择。Https探测器跳过证书验证。<code class="fe mp mq mr ms b">path</code>定义了容器服务器上的路径。<code class="fe mp mq mr ms b">httpHeaders</code>为您的HTTP请求探测器定义自定义头。最后，<code class="fe mp mq mr ms b">port</code>定义了容器的目标端口。<code class="fe mp mq mr ms b">http</code>端口翻译为端口80。大于200小于400的状态代码被认为是成功的。</p><p id="9218" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> TCP探针</strong>(第13–14行)试图打开指定端口上的容器的TCP套接字。如果它成功了，那么它被认为是健康的，否则它被认为是失败的。</p><p id="3d24" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">命令探测器</strong>(第21–24行)在容器上执行命令。如果命令返回0，则视为成功。否则就被视为失败。</p><p id="954e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所有探头都有一些可配置的属性:</p><p id="6aee" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mp mq mr ms b">periodSeconds</code>定义间隔，以秒为单位，k8s应该执行探测。</p><p id="7f7e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mp mq mr ms b">initialDelaySeconds</code>定义容器创建后，k8s在执行第一次探测前应等待多长时间。</p><p id="eb31" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mp mq mr ms b">successThreshold</code>和<code class="fe mp mq mr ms b">failureThreshold</code>定义了在探针被视为成功或失败之前连续成功或失败的次数。</p><p id="65fc" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mp mq mr ms b">timeoutSeconds</code>定义探头超时前k8s等待的时间，单位为秒。超时被视为失败。</p><h2 id="5abe" class="lp lq in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated"><strong class="ak"> Pod中断预算(PDB) </strong></h2><p id="086a" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">当您对k8s集群的底层基础设施进行更改时，您会希望确保您的pod保持一定程度的可用性。设置Pod中断预算是实现这一目标的一种方法。pod中断预算是k8s中的一项资源，用于定义k8s在中断pod之前应预算多少pod。PDB定义了可以跟随<code class="fe mp mq mr ms b">maxUnavailable</code>下降的豆荚数量或百分比，以及必须跟随<code class="fe mp mq mr ms b">minAvailable</code>上升的豆荚数量或百分比。PDB通过使用选择器来应用预算。PDB目前支持复制集、状态集和部署。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="0e84" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从上面的例子中，这个PDB适用于任何标签为<code class="fe mp mq mr ms b">app: test-app</code>的资源。在中断事件期间，k8s将在执行更新时保持至少1个pod处于活动状态。</p><h2 id="388d" class="lp lq in bd lr ls lt dn lu lv lw dp lx kl ly lz ma kp mb mc md kt me mf mg mh bi translated">PDB在行动</h2><p id="4556" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">假设我们从4个节点和2个豆荚开始，PDF的最小可用空间为1。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/4b1dd4b9302ad8a5730b1e6416debff9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*ePTjB4K0U3JDcQ_XZaAVYg.png"/></div></figure><p id="ad21" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将使用<code class="fe mp mq mr ms b">kubectl drain</code>排空节点1和2，以确保节点上的豆荚被逐出，同时尊重PDB。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/d95f9a5ba140d976882cba6295177f8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*4aunh4b3f7fKPRFVOCWqzQ.png"/></div></figure><p id="98ef" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦pod A从节点1被杀死，k8s将在节点3(或节点4)上调度pod A，因为当<code class="fe mp mq mr ms b">kubectl drain</code>对节点1和节点2运行时，节点1和节点2将被污染为不可调度的。注意节点2上的吊舱A没有被杀死。这是因为PDB确保至少有一个吊舱是活着的。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/41a65c4751226e846ad3c1c3e9b5d8e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*w8qXDzQafopyMthPRKcnIg.png"/></div></figure><p id="f3c7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在荚果A也生活在节点3中，节点2上的荚果A将被杀死。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/492b041fdccae1188df77855a2739d9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*ONdrBZ32SfxMMveLi7oJTA.png"/></div></figure><p id="ceb2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">需要注意的是，只有当您进行k8s可以控制的更改时，才会考虑PDB。如果您直接删除一个节点，k8s将无法利用PDB，因为k8s不是节点销毁过程的一部分。然而，如果你先执行<code class="fe mp mq mr ms b">kubectl drain</code>然后杀死底层节点，那么PDB是受尊重的。</p><p id="eab3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，您需要确定需要支撑多少吊舱，这样您就不会因为吊舱下降而停机，新的吊舱也不会立即出现。这取决于您的流量模式，因此对更新设置窗口并设置PDB以匹配该窗口期间需要的内容将有助于您安全地执行基础架构更新。</p><p id="219c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">附带说明:将“可用”设置为100%或与当前pod编号相同将意味着如果pod以此PDB为目标，k8s将无法耗尽节点。</p><p id="1c56" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae lo" href="https://kubernetes.io/docs/tasks/run-application/configure-pdb/" rel="noopener ugc nofollow" target="_blank">公文</a></p><p id="f0ca" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae lo" href="https://medium.com/dev-genius/hardening-your-kubernetes-stack-pt-1-29b7006b5085" rel="noopener">第1部分:资源请求和限制</a> <br/> <a class="ae lo" href="https://medium.com/dev-genius/hardening-your-kubernetes-stack-pt-2-2f2db4ff410d" rel="noopener">第2部分:Pod服务质量和优先级</a> <br/> <a class="ae lo" href="https://medium.com/dev-genius/hardening-your-kubernetes-stack-pt-4-cc72b09b4557" rel="noopener">第4部分:水平Pod自动缩放器和集群自动缩放器</a></p></div></div>    
</body>
</html>