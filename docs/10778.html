<html>
<head>
<title>Why you should write your own database — An insight from my Telegram users caching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么你应该写你自己的数据库——从我的电报用户缓存中得到的启示</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/why-you-should-write-your-own-database-an-insight-from-my-telegram-users-caching-d960ce67bd93?source=collection_archive---------8-----------------------#2022-11-28">https://blog.devgenius.io/why-you-should-write-your-own-database-an-insight-from-my-telegram-users-caching-d960ce67bd93?source=collection_archive---------8-----------------------#2022-11-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="f519" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我在构建一个涉及 Telegram bot 的授权流时，我在当前的项目中遇到了一个特定的问题:如何将用户昵称映射到聊天 id(因为这是与 bot 进行私人对话所必需的)？嗯，我可以简单地为它创建一个散列表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/c9b89480c02431cb51a32e150eae0812.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*rrQCJkbYCdQMaTQ0cdlJ0A.png"/></div></figure><p id="1b4f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">到目前为止还不错…但是…如果不是 100 个用户，而是 1000，10000 个呢？RAM 不是无限的。那么如何限制记录数呢？我想到的最佳解决方案是只存储有限的一组最近登录的用户。这就是 LRU 缓存政策开始发挥作用的地方</p><h1 id="5b9e" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated"><strong class="ak"> 1) LRU 缓存</strong></h1><p id="ced0" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">它的工作很简单:如果缓存已满，并且您要向其中插入一个条目，那么最早访问的条目将从缓存中删除。当我们访问缓存中的一些现有条目时(除了“删除”操作)，它成为缓存的最新条目:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lt"><img src="../Images/c19850086f1c850b4a45dc8c467ca43a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AiPTUXimMNpZ97iC9-POSg.png"/></div></div></figure><p id="0d47" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好的。我用有限的内存解决了这个问题。还有一个问题:永久存储持久性。如果某个老访问者想再次登录该服务怎么办？我可以以某种方式建议他/她/他们再次向电报机器人发送确认，但这有点让他/她/他们恼火。我和这位用户希望有更舒适的方式再次登录网站，即使我们很长时间没有登录。所以是时候更多地考虑缓存策略了…</p><h1 id="babc" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">2)我对缓存策略有什么期望？</h1><ul class=""><li id="c79c" class="ly lz in jm b jn lo jr lp jv ma jz mb kd mc kh md me mf mg bi translated">能够永久存储所有对“昵称:聊天 id”；</li><li id="3dfb" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated">对于最热的条目，具有与基于 RAM 的 LRU 高速缓存相同的性能；</li><li id="f30e" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated">如果高速缓存客户端查询高速缓存未命中条目，则它应该被传播到最热的条目；</li><li id="3610" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated">如果高速缓存客户端查询在时间上接近最近查询的条目的一些条目，则应该以接近热条目的性能来访问它；</li><li id="da33" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated">写不如读频繁；</li><li id="f810" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated">对热条目的写入应该具有非常接近原始 LRU 缓存的性能；</li></ul><p id="28d8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有了所有这些属性，我就有了这些缓存层:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/8a2b3a57ebca68cba0527f92b23ad556.png" data-original-src="https://miro.medium.com/v2/resize:fit:322/format:webp/1*pZmX5anxY7xohUFYjp3Jfw.png"/></div></figure><ul class=""><li id="6925" class="ly lz in jm b jn jo jr js jv mn jz mo kd mp kh md me mf mg bi translated">LRU —代表最热门的访问条目；</li><li id="6518" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated">保留页—代表按时间顺序接近某个最近访问的缓存未命中条目的条目。我期望访问它们的可能性比一些年代久远的项目更大；</li><li id="5455" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated">来自磁盘的页面——即使在按时间顺序最接近的集合中也没有条目时加载该页面；</li></ul><p id="d80a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，让我们在初始化代码中反映它们:</p><pre class="kj kk kl km gt mq mr ms bn mt mu bi"><span id="b40f" class="mv kr in mr b be mw mx l my mz">package microdb<br/><br/>import (<br/> "fmt"<br/> "gitlab.com/john-byte/jbyte-lru-cache-microdb-v1.1/types"<br/> errorsutils "gitlab.com/john-byte/jbyte-lru-cache-microdb-v1.1/utils/errors"<br/> fileutils "gitlab.com/john-byte/jbyte-lru-cache-microdb-v1.1/utils/file"<br/> lrucache "gitlab.com/john-byte/jbyte-lru-cache-microdb-v1.1/utils/lru_cache"<br/> orderedmap "gitlab.com/john-byte/jbyte-lru-cache-microdb-v1.1/utils/ordered_map"<br/> trie "gitlab.com/john-byte/jbyte-lru-cache-microdb-v1.1/utils/trie"<br/> "log"<br/> "path"<br/> "sync"<br/>)<br/><br/>type TMicroDb struct {<br/> index           *trie.Trie<br/> indexLock       *sync.Mutex<br/> hotCache        *lrucache.LruCache<br/> reservedPage    *orderedmap.OrderedMap<br/> writtenPageLock *sync.Mutex<br/> writtenPage     *orderedmap.OrderedMap<br/> writtenPageId   uint32<br/> pageCapacity    uint32<br/> rootPath        string<br/>}<br/><br/>func New(rootPath string, pageCapacity uint32) *TMicroDb {<br/> index := trie.New()<br/> hotCache := lrucache.New(uint64(pageCapacity))<br/> reservedPage := orderedmap.New()<br/> writtenPage := orderedmap.New()<br/> return &amp;TMicroDb{<br/>  index:           &amp;index,<br/>  indexLock:       &amp;sync.Mutex{},<br/>  hotCache:        hotCache,<br/>  reservedPage:    &amp;reservedPage,<br/>  writtenPageLock: &amp;sync.Mutex{},<br/>  writtenPage:     &amp;writtenPage,<br/>  writtenPageId:   0,<br/>  pageCapacity:    pageCapacity,<br/>  rootPath:        rootPath,<br/> }<br/>}<br/><br/>func readConfig(rootPath string) (*types.TDbConfig, error) {<br/> configPath := path.Join(rootPath, "index.json")<br/> configFile, err := fileutils.ReadFileWTimeout(<br/>  configPath,<br/>  6000,<br/> )<br/> if err != nil {<br/>  return nil, errorsutils.LogError(<br/>   "MicroDb",<br/>   "readConfig",<br/>   err,<br/>  )<br/> }<br/> parsedConfig, err := parseConfig(configFile)<br/> if err != nil {<br/>  return nil, errorsutils.LogError(<br/>   "MicroDb",<br/>   "readConfig",<br/>   err,<br/>  )<br/> }<br/><br/> return parsedConfig, nil<br/>}<br/><br/>func readPage(rootPath string, pageId uint32) (*orderedmap.OrderedMap, error) {<br/> pagePath := path.Join(<br/>  rootPath,<br/>  fmt.Sprintf("page-%v.dat", pageId),<br/> )<br/> pageFile, err := fileutils.ReadFileWTimeout(<br/>  pagePath,<br/>  6000,<br/> )<br/> if err != nil {<br/>  return nil, errorsutils.LogError(<br/>   "MicroDb",<br/>   "readHottestPage",<br/>   err,<br/>  )<br/> }<br/> parsedPage, err := parsePage(pageFile)<br/> if err != nil {<br/>  return nil, errorsutils.LogError(<br/>   "MicroDb",<br/>   "readHottestPage",<br/>   err,<br/>  )<br/> }<br/><br/> return parsedPage, nil<br/>}<br/><br/>func FromFile(rootPath string) (*TMicroDb, error) {<br/> config, err := readConfig(rootPath)<br/> if err != nil {<br/>  return nil, errorsutils.LogError(<br/>   "MicroDb",<br/>   "FromFile",<br/>   err,<br/>  )<br/> }<br/><br/> hottestPageId := 1<br/> if config.WrittenPageId &gt; 1 {<br/>  hottestPageId = int(config.WrittenPageId) - 1<br/> }<br/> hottestPage, err := readPage(rootPath, uint32(hottestPageId))<br/> if err != nil {<br/>  return nil, errorsutils.LogError(<br/>   "MicroDb",<br/>   "FromFile",<br/>   err,<br/>  )<br/> }<br/><br/> writtenPage, err := readPage(rootPath, uint32(config.WrittenPageId))<br/> if err != nil {<br/>  return nil, errorsutils.LogError(<br/>   "MicroDb",<br/>   "FromFile",<br/>   err,<br/>  )<br/> }<br/><br/> hotCache := lrucache.FromOrderedMap(<br/>  hottestPage,<br/>  uint64(config.PageCapacity),<br/> )<br/><br/> reservedPage := orderedmap.New()<br/><br/> return &amp;TMicroDb{<br/>  index:           config.Pages,<br/>  indexLock:       &amp;sync.Mutex{},<br/>  hotCache:        hotCache,<br/>  reservedPage:    &amp;reservedPage,<br/>  writtenPageLock: &amp;sync.Mutex{},<br/>  writtenPage:     writtenPage,<br/>  writtenPageId:   config.WrittenPageId,<br/>  pageCapacity:    config.PageCapacity,<br/>  rootPath:        rootPath,<br/> }, nil<br/>}</span></pre><p id="bfb0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">(如果你对索引和页面使用哪种格式感兴趣:你可以在我的 GitLab 资源库中看到源代码:<a class="ae na" href="https://gitlab.com/john-byte/jbyte-lru-cache-microdb-v1.1/-/blob/master/lib/microdb/utils.go" rel="noopener ugc nofollow" target="_blank">https://git lab . com/jbyte 777/jbyte-LRU-cache-microdb-v 1.1/-/blob/master/lib/microdb/utils . go</a>)</p><p id="01c7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可能会注意到一个“奇怪”的东西:“索引”。那么这个奇怪的实体是什么？这听起来并不像火箭科学:这是一个实体，仅仅服务于如何快速定位包含所请求的键的数据块(页面)。我使用了 trie 数据结构，因为电报昵称更容易被人阅读，而不是被机器以其他方式改变的东西。你可以在这里阅读更多关于这个数据结构是如何工作的:<a class="ae na" href="https://en.wikipedia.org/wiki/Trie" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Trie</a>；</p><p id="e647" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">初始化完成。让我们编写代码，使用定义的层从请求的键中读取值:</p><pre class="kj kk kl km gt mq mr ms bn mt mu bi"><span id="7d9a" class="mv kr in mr b be mw mx l my mz">func (self *TMicroDb) Get(key string) (string, error) {<br/> val, hasInHotCache := self.hotCache.Get(key)<br/> if hasInHotCache {<br/>  return val.(string), nil<br/> }<br/><br/> val, hasInReservedPage := self.reservedPage.Get(key)<br/> if hasInReservedPage {<br/>  self.putInHotCache(key, val.(string))<br/>  return val.(string), nil<br/> }<br/><br/> self.indexLock.Lock()<br/> rawPageId, hasPage := self.index.Get([]rune(key))<br/> self.indexLock.Unlock()<br/> if !hasPage {<br/>  return "", nil<br/> }<br/> pageFilePath := path.Join(<br/>  self.rootPath,<br/>  fmt.Sprintf("page-%v.dat", rawPageId.(uint32)),<br/> )<br/> pageFile, err := fileutils.ReadFileWTimeout(<br/>  pageFilePath,<br/>  6000,<br/> )<br/> if err != nil {<br/>  return "", errorsutils.LogError(<br/>   "MicroDb",<br/>   "Get",<br/>   err,<br/>  )<br/> }<br/> reservedPage, err := parsePage(pageFile)<br/> if err != nil {<br/>  return "", errorsutils.LogError(<br/>   "MicroDb",<br/>   "Get",<br/>   err,<br/>  )<br/> }<br/> self.reservedPage = reservedPage<br/> val, _ = self.reservedPage.Get(key)<br/> self.putInHotCache(key, val.(string))<br/><br/> return val.(string), nil<br/>}</span></pre><p id="b480" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe nb nc nd mr b">self.putInHotCache(key, val)</code>从保留页面查询后的语句服务于上述第三个属性:</p><p id="af9c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果缓存客户端查询缓存未命中的条目，则应该将其传播到最热的条目</p><p id="4f05" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个语句只是在每次写请求时调用(记住:“写不如读频繁”):</p><pre class="kj kk kl km gt mq mr ms bn mt mu bi"><span id="e070" class="mv kr in mr b be mw mx l my mz">func (self *TMicroDb) Put(key string, val string) {<br/> self.putInHotCache(key, val)<br/>}</span></pre><p id="26c5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们将它实现为我设计的缓存的第二个主要流程:</p><pre class="kj kk kl km gt mq mr ms bn mt mu bi"><span id="7d6a" class="mv kr in mr b be mw mx l my mz">func (self *TMicroDb) putInHotCache(key string, val string) {<br/> self.hotCache.Put(key, val)<br/><br/> self.indexLock.Lock()<br/> _, entryInIndex := self.index.Get([]rune(key))<br/> self.indexLock.Unlock()<br/> if !entryInIndex {<br/>  currPageId := self.writtenPageId<br/><br/>  self.writtenPageLock.Lock()<br/>  self.writtenPage.Put(key, val)<br/>  currPage := self.writtenPage<br/>  if currPage.Len() == uint64(self.pageCapacity) {<br/>   newPage := orderedmap.New()<br/>   self.writtenPage = &amp;newPage<br/>   self.writtenPageId++<br/>  }<br/>  self.writtenPageLock.Unlock()<br/>  self.flushWrittenPage(key, val, currPageId, currPage)<br/><br/>  self.indexLock.Lock()<br/>  self.index.Put([]rune(key), currPageId)<br/>  self.indexLock.Unlock()<br/>  self.flushIndex(key, currPageId)<br/> }<br/>}</span></pre><p id="1bad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有一点需要注意:“writtenPage”。它用于当前插入的、带有条目的未填充页面。index 知道插入的键是否是这种情况。如果当前写入的页面已满，将会写入新的页面；</p><p id="eaf2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以及如何“刷新”修改过的索引和修改过的页面？记住最后一个属性:</p><p id="33a1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">“写入热条目的性能应该非常接近原始 LRU 缓存”</p><p id="94ef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以刷新(写入磁盘)是在单独的 goroutines 上运行的。这就是为什么我在索引和当前编写的页面周围也有一堆锁。让我们把这些有用的例程写在最后:</p><pre class="kj kk kl km gt mq mr ms bn mt mu bi"><span id="bdad" class="mv kr in mr b be mw mx l my mz">func (self *TMicroDb) flushWrittenPage(<br/> key string,<br/> val string,<br/> currPageId uint32,<br/> currPage *orderedmap.OrderedMap,<br/>) {<br/> go func() {<br/>  self.writtenPageLock.Lock()<br/>  defer self.writtenPageLock.Unlock()<br/><br/>  pageFilePath := path.Join(<br/>   self.rootPath,<br/>   fmt.Sprintf("page-%v.dat", currPageId),<br/>  )<br/>  pageBytes := serializePage(currPage)<br/>  err := fileutils.WriteFileWTimeout(<br/>   pageFilePath,<br/>   pageBytes,<br/>   0666,<br/>   6000,<br/>  )<br/>  if err != nil {<br/>   formatedErr := errorsutils.LogError(<br/>    "MicroDb",<br/>    "flushWrittenPage",<br/>    err,<br/>   )<br/>   errStr := fmt.Sprintf(<br/>    "%v",<br/>    formatedErr.Error(),<br/>   )<br/>   log.Println(errStr)<br/>  }<br/> }()<br/>}<br/><br/>func (self *TMicroDb) flushIndex(key string, currPageId uint32) {<br/> go func() {<br/>  self.indexLock.Lock()<br/>  defer self.indexLock.Unlock()<br/><br/>  indexFilePath := path.Join(<br/>   self.rootPath,<br/>   "index.json",<br/>  )<br/>  indexBytes, err := serializeConfig(&amp;types.TDbConfig{<br/>   WrittenPageId: currPageId,<br/>   PageCapacity:  self.pageCapacity,<br/>   Pages:         self.index,<br/>  })<br/>  if err != nil {<br/>   goto errorPoint<br/>  }<br/><br/>  err = fileutils.WriteFileWTimeout(<br/>   indexFilePath,<br/>   indexBytes,<br/>   0666,<br/>   6000,<br/>  )<br/>  if err != nil {<br/>   goto errorPoint<br/>  } else {<br/>   return<br/>  }<br/><br/> errorPoint:<br/>  {<br/>   formatedErr := errorsutils.LogError(<br/>    "MicroDb",<br/>    "flushIndex",<br/>    err,<br/>   )<br/>   errStr := fmt.Sprintf(<br/>    "%v",<br/>    formatedErr.Error(),<br/>   )<br/>   log.Println(errStr)<br/>  }<br/> }()<br/>}</span></pre><p id="0105" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是微型数据库的主要功能。让我来回答文章最初的问题:“为什么您应该编写自己的数据库？”。嗯，有流行的通用解决方案，如 SQL 数据库、MongoDB、Redis 等。但是我的缓存数据:</p><ol class=""><li id="0cc5" class="ly lz in jm b jn jo jr js jv mn jz mo kd mp kh ne me mf mg bi translated">在 SQL 数据库为这种情况提供通用解决方案的情况下，不太依赖关系；</li><li id="2cb7" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh ne me mf mg bi translated">不是关于在 MongoDB/Redis 提供解决方案的情况下灵活地对象结构化文档流；</li><li id="ea59" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh ne me mf mg bi translated">已经基于 LRU 热缓存策略；</li><li id="2457" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh ne me mf mg bi translated">只是“key:val”字符串对的集合；</li></ol><p id="52ec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我主要是寻找解决方案。如果某样东西更适合高抽象层次，我很可能会使用它。</p><p id="c4db" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里是我开发的迷你数据库的源代码:<a class="ae na" href="https://gitlab.com/john-byte/jbyte-lru-cache-microdb-v1.1" rel="noopener ugc nofollow" target="_blank">https://gitlab.com/jbyte777/jbyte-lru-cache-microdb-v1.1</a></p><p id="b1f8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="nf">请随意留下您的经验建议等。我感谢任何有益的反馈；)</em></p><p id="36e3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="nf">我的 git lab:</em><a class="ae na" href="https://gitlab.com/john-byte" rel="noopener ugc nofollow" target="_blank"><em class="nf">https://gitlab.com/jbyte</em></a><em class="nf">777</em></p></div></div>    
</body>
</html>