<html>
<head>
<title>Build it; Clone it;— An Apollo Federated API — Pt. 2: The Comprehensive Apollo Subgraph Starter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">建造它；克隆它；—一个阿波罗联合 API — Pt。2:全面的阿波罗子图启动器</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/build-it-clone-it-an-apollo-federated-api-pt-2-the-comprehensive-apollo-subgraph-starter-365d1c542379?source=collection_archive---------4-----------------------#2022-02-24">https://blog.devgenius.io/build-it-clone-it-an-apollo-federated-api-pt-2-the-comprehensive-apollo-subgraph-starter-365d1c542379?source=collection_archive---------4-----------------------#2022-02-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="d526" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">大家好！感谢您的加入。</p><p id="8d9b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">欢迎来建；克隆它；—和我一起构建你自己的子图启动库，或者跳到底部克隆完成的项目—选择权在你！</p><p id="e5fe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">今天，我很乐意分享我的 starter repository，我用它在 Apollo 联合 API 中启动新的子图服务。它不仅仅是一个联邦 Apollo 服务器样板——它拥有真正的 API 所需要的特性！</p><p id="d9f1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以如果你想和我一起<strong class="jm io"> <em class="ki">建造它</em> </strong>那么继续阅读。</p><p id="2f05" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果丫只是需要<strong class="jm io"> <em class="ki">克隆它</em> </strong>，跳到最后！但也许可以直接阅读下面的功能。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/d4e7d2b8b63f9ba23541def5b5f9d3c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pblq3XImuq4Y1h5aEO0AJQ.jpeg"/></div></div></figure><h1 id="43d3" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">启动器功能</h1><p id="6417" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">如果它没有帮助我们编写特定于服务的代码的预构建功能，它就不是一个入门库，对吗？检查完成的存储库/我们的项目将具有的特性。</p><ol class=""><li id="0a28" class="ly lz in jm b jn jo jr js jv ma jz mb kd mc kh md me mf mg bi translated">Typescript —所有类型化和绝对导入</li><li id="a8c0" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated">联合子图/阿波罗服务器</li><li id="1f1e" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated">自动上下文生成、创建和定制</li><li id="199e" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated">CodeGen —生成类型和上下文</li><li id="780f" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated">mongose/Mongo DB 集成</li><li id="a65c" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated">预构建的标准化分页、过滤和查找方法</li><li id="5718" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated">文档化开发、准备和生产设置(在 repo！)</li></ol><h1 id="dd7c" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">项目设置</h1><h2 id="2bfc" class="mm kw in bd kx mn mo dn lb mp mq dp lf jv mr ms lj jz mt mu ln kd mv mw lr mx bi translated">初始化</h2><p id="6dc2" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">嘿，现在，让我们准备好。这里没什么特别的。创建一个项目目录，并用 NPM 初始化。</p><pre class="kk kl km kn gt my mz na nb aw nc bi"><span id="6eb1" class="mm kw in mz b gy nd ne l nf ng">mkdir -p apollo-subgraph-starter/src<br/>cd apollo-subgraph-starter<br/>npm init -y</span></pre><p id="e8ac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">俏皮的终端小把戏，用</em> <code class="fe nh ni nj mz b"><em class="ki">mkdir -p</em></code> <em class="ki">创建嵌套目录，即使根目录不存在。</em></p><h1 id="2075" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">安装程序类型脚本</h1><h2 id="8e14" class="mm kw in bd kx mn mo dn lb mp mq dp lf jv mr ms lj jz mt mu ln kd mv mw lr mx bi translated">安装一些软件包</h2><p id="1a40" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">首先，安装 typescript 并创建一个<code class="fe nh ni nj mz b">tsconfig.json</code>。</p><pre class="kk kl km kn gt my mz na nb aw nc bi"><span id="c83e" class="mm kw in mz b gy nd ne l nf ng">npm i typescript nodemon<br/>touch tsconfig.json<br/>mkdir types</span></pre><h2 id="0bb4" class="mm kw in bd kx mn mo dn lb mp mq dp lf jv mr ms lj jz mt mu ln kd mv mw lr mx bi translated">配置 Typescript</h2><p id="fb31" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">除了一些非常标准的打字稿配置—</p><ul class=""><li id="4cf4" class="ly lz in jm b jn jo jr js jv ma jz mb kd mc kh nk me mf mg bi translated">我们将包含<code class="fe nh ni nj mz b">types</code>文件夹中的所有文件。</li><li id="f7e3" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh nk me mf mg bi translated">我们也在做一些工作，以实现绝对进口</li><li id="30c3" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh nk me mf mg bi translated">我们定义输出目录，以便运行编译后的代码</li></ul><p id="4e6f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将以下内容添加到<code class="fe nh ni nj mz b">tsconfig.json</code>:</p><pre class="kk kl km kn gt my mz na nb aw nc bi"><span id="3e48" class="mm kw in mz b gy nd ne l nf ng">{<br/>  "compilerOptions": {<br/>    "module": "commonjs",<br/>    "target": "es2018",<br/>    "outDir": "./dist",<br/>    "strict": true,<br/>    "baseUrl": ".",<br/>    "esModuleInterop": true,<br/>    "skipLibCheck": true ,<br/>    "forceConsistentCasingInFileNames": true,<br/>    "paths": {<br/>      "<a class="ae nl" href="http://twitter.com/src" rel="noopener ugc nofollow" target="_blank">@src</a>/*": ["src/*"]<br/>    }<br/>  },<br/>  "include": [<br/>    "types/**/*",<br/>    "src"<br/>  ],<br/>  "exclude": ["node_modules"]<br/>}</span></pre><h2 id="b89e" class="mm kw in bd kx mn mo dn lb mp mq dp lf jv mr ms lj jz mt mu ln kd mv mw lr mx bi translated">改变入口点</h2><p id="f6c9" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">我更喜欢<code class="fe nh ni nj mz b">server.js</code>而不是<code class="fe nh ni nj mz b">index.js</code>——这似乎是一个更具描述性的名字。在<code class="fe nh ni nj mz b">package.json</code>内改变入口点。</p><pre class="kk kl km kn gt my mz na nb aw nc bi"><span id="9c1c" class="mm kw in mz b gy nd ne l nf ng">// package.json<br/>{<br/>  // ...other package.json properties<br/>  "main": "dist/server.js",<br/>}</span></pre><h2 id="7c46" class="mm kw in bd kx mn mo dn lb mp mq dp lf jv mr ms lj jz mt mu ln kd mv mw lr mx bi translated">修改启动脚本</h2><p id="531e" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">为了启动服务器，我们需要将源代码从<code class="fe nh ni nj mz b">src</code>编译到<code class="fe nh ni nj mz b">dist</code>文件夹中。编辑<code class="fe nh ni nj mz b">start</code>和<code class="fe nh ni nj mz b">dev</code>和<code class="fe nh ni nj mz b">scripts</code>来运行编译后的代码。</p><pre class="kk kl km kn gt my mz na nb aw nc bi"><span id="d852" class="mm kw in mz b gy nd ne l nf ng">// package.json</span><span id="0416" class="mm kw in mz b gy nm ne l nf ng">"scripts": {<br/>    "start": "node app/dist/server.js",<br/>    "dev": "tsc -w &amp; nodemon dist/server.js",<br/>    // For Docker<br/>    // "dev": "tsc; tsc -w &amp; nodemon dist/server.js",<br/>    "build": "tsc",<br/>    "generate": "graphql-codegen"<br/>  },</span></pre><p id="4e1f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">docker 注意:如果您使用 Docker 和挂载卷进行开发，请尝试上面的 docker <code class="fe nh ni nj mz b">dev</code>脚本。这将确保在启动容器中的服务器之前已经构建了 dist 文件。不过，更多的对话还是改天再说吧！</p><h2 id="7c16" class="mm kw in bd kx mn mo dn lb mp mq dp lf jv mr ms lj jz mt mu ln kd mv mw lr mx bi translated">绝对进口</h2><p id="3cda" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">首先安装几个软件包:</p><pre class="kk kl km kn gt my mz na nb aw nc bi"><span id="845a" class="mm kw in mz b gy nd ne l nf ng">npm i module-alias source-map-support</span></pre><p id="9810" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这两个包将有助于为任何模块创建自定义别名，并帮助编译后的代码找到正确的模块。</p><p id="fd4c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<code class="fe nh ni nj mz b">package.json</code>文件中，添加下面的模块别名，它将<code class="fe nh ni nj mz b">@src/*</code>输入映射到编译后的<code class="fe nh ni nj mz b">dist</code>文件。</p><pre class="kk kl km kn gt my mz na nb aw nc bi"><span id="40a7" class="mm kw in mz b gy nd ne l nf ng">"_moduleAliases": {<br/>    "<a class="ae nl" href="http://twitter.com/src" rel="noopener ugc nofollow" target="_blank">@src</a>": "dist/"<br/>  }</span></pre><p id="edc8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">还有一个步骤，但是我们需要首先创建服务器文件。</p><pre class="kk kl km kn gt my mz na nb aw nc bi"><span id="9b43" class="mm kw in mz b gy nd ne l nf ng">touch src/server.ts</span></pre><p id="2358" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好的，在服务器文件中，我们需要完成绝对导入设置。确保这是前两行，并且永远保持前两行，至少根据文档是这样的。</p><pre class="kk kl km kn gt my mz na nb aw nc bi"><span id="3eea" class="mm kw in mz b gy nd ne l nf ng">// src/server.ts<br/>import "module-alias/register";<br/>import "source-map-support/register";</span></pre><p id="8311" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们有绝对进口！</p><pre class="kk kl km kn gt my mz na nb aw nc bi"><span id="443d" class="mm kw in mz b gy nd ne l nf ng">// Example Only<br/>import { whateverYouWant } from "@src/where-ever-you-want";</span></pre><h1 id="aadf" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">创建阿波罗服务器</h1><h2 id="a80f" class="mm kw in bd kx mn mo dn lb mp mq dp lf jv mr ms lj jz mt mu ln kd mv mw lr mx bi translated">设置服务器</h2><p id="3bea" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">接下来，我们将创建 Apollo 服务器。这超级简单，但我们需要几个包。</p><pre class="kk kl km kn gt my mz na nb aw nc bi"><span id="3ccb" class="mm kw in mz b gy nd ne l nf ng">npm i apollo-server dotenv</span></pre><p id="9f1b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">导入<code class="fe nh ni nj mz b">ApolloServer</code>，然后定义并调用服务器。</p><pre class="kk kl km kn gt my mz na nb aw nc bi"><span id="b5f1" class="mm kw in mz b gy nd ne l nf ng">// src/server.ts<br/>// ...imports<br/>import { ApolloServer } from "apollo-server";<br/>import { schema } from "@src/graphql";<br/>import dotenv from "dotenv";<br/>dotenv.config();</span><span id="5e02" class="mm kw in mz b gy nm ne l nf ng">const apolloServer = new ApolloServer({<br/>  schema,<br/>});</span><span id="bdcc" class="mm kw in mz b gy nm ne l nf ng">const port = process.env.PORT || 5999;</span><span id="c1d1" class="mm kw in mz b gy nm ne l nf ng">apolloServer<br/>  .listen({ port })<br/>  .then(({ url }) =&gt; console.log(`Service ready at ${url}`));</span></pre><p id="0046" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们还导入并调用了<code class="fe nh ni nj mz b">dotenv</code>来访问环境变量，这有助于保存在 Mongo URIs 和服务器端口等产品之间变化的变量。</p><h2 id="1076" class="mm kw in bd kx mn mo dn lb mp mq dp lf jv mr ms lj jz mt mu ln kd mv mw lr mx bi translated">该模式</h2><p id="613f" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">我们还必须创建一个模式，因为<code class="fe nh ni nj mz b">server.ts</code>应该会抛出一个 typescript 错误。</p><p id="2872" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该模式将向服务器提供<code class="fe nh ni nj mz b">typeDefs</code>和<code class="fe nh ni nj mz b">resolvers</code>。为模式创建一个目录和文件。</p><pre class="kk kl km kn gt my mz na nb aw nc bi"><span id="92a3" class="mm kw in mz b gy nd ne l nf ng">mkdir src/graphql<br/>touch src/graphql/schema.ts graphql/index.ts</span></pre><p id="e471" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从<code class="fe nh ni nj mz b">index.ts</code>中导出模式，以便更清晰地导入。<em class="ki">从现在开始，我将在创建新目录时跳过这一步。我只是喜欢从索引文件中导出。</em></p><pre class="kk kl km kn gt my mz na nb aw nc bi"><span id="0b00" class="mm kw in mz b gy nd ne l nf ng">// src/graphql/index.ts<br/>export * from './schema';</span></pre><p id="4cfd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">并创建样板模式。我们很快会回到这个问题，但它至少会消除<code class="fe nh ni nj mz b">server.ts</code>文件中<code class="fe nh ni nj mz b">schema</code>的<code class="fe nh ni nj mz b">no exported member</code>错误。</p><pre class="kk kl km kn gt my mz na nb aw nc bi"><span id="6515" class="mm kw in mz b gy nd ne l nf ng">// src/graphql/schema.ts<br/>import { buildSubgraphSchema } from "<a class="ae nl" href="http://twitter.com/apollo/federation" rel="noopener ugc nofollow" target="_blank">@apollo/federation</a>";</span><span id="0a6d" class="mm kw in mz b gy nm ne l nf ng">export const schema = buildSubgraphSchema([]);</span></pre><h2 id="09ef" class="mm kw in bd kx mn mo dn lb mp mq dp lf jv mr ms lj jz mt mu ln kd mv mw lr mx bi translated">启用自动上下文生成</h2><p id="d147" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated"><strong class="jm io">什么是语境生成？</strong></p><p id="952e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上下文是在本地服务内部甚至在网络服务之间共享的数据。上下文可以来自服务本身的定制数据，或者更常见的来自传入的<strong class="jm io">请求头。</strong></p><p id="d7bb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是极其一般的低沉:</p><ol class=""><li id="a805" class="ly lz in jm b jn jo jr js jv ma jz mb kd mc kh md me mf mg bi translated">客户端向微服务请求<em class="ki">某样东西</em>。</li><li id="618e" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated">为了访问微服务，他们必须向网关发送请求。</li><li id="bea7" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated">网关完成它的工作并创建将在整个 API 中使用的<code class="fe nh ni nj mz b">Context</code>。如果您需要了解这方面的更多信息，请查看我的<a class="ae nl" rel="noopener ugc nofollow" target="_blank" href="/build-or-clone-a-federated-api-pt-1-the-gateway-ad75dad21459"> Gateway 文章！</a></li><li id="998f" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated">一旦在网关内创建了上下文，它就准备将请求发送到子图，以便解析来自客户端的请求。它将上下文作为头部附加到请求上，请求被发送到子图。</li><li id="708d" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated">子图接收带有标头的请求，可以从标头中提取信息，并将其作为上下文添加到服务中，然后可以从解析器访问该服务。</li></ol><p id="26fd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这意味着，在我们的子图中，我们应该期望在每个请求中出现某种类型的头。该标题将为我们提供在整个服务中用作上下文的信息。</p><p id="2b42" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了让这个超级简单，我们将使用<code class="fe nh ni nj mz b">@the-devoyage/micro-auth-helpers</code>包！</p><p id="8019" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">启用生成</strong></p><p id="2b96" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">安装并定义包的范围指向 GitHub 注册表并安装<code class="fe nh ni nj mz b">@the-devoyage/micro-auth-helpers</code>。</p><pre class="kk kl km kn gt my mz na nb aw nc bi"><span id="01eb" class="mm kw in mz b gy nd ne l nf ng">echo <a class="ae nl" href="http://twitter.com/the" rel="noopener ugc nofollow" target="_blank">@the</a>-devoyage:registry=<a class="ae nl" href="https://npm.pkg.github.com" rel="noopener ugc nofollow" target="_blank">https://npm.pkg.github.com</a> &gt;&gt; .npmrc<br/>npm i @the-devoyage/micro-auth-helpers</span></pre><p id="c175" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面这条线会让我们的生活变得更容易。将下面的<code class="fe nh ni nj mz b">context</code>属性添加到 Apollo 服务器的实例中。</p><pre class="kk kl km kn gt my mz na nb aw nc bi"><span id="3db6" class="mm kw in mz b gy nd ne l nf ng">// src/server.ts<br/>const apolloServer = new ApolloServer({<br/>  schema,<br/>  context: ({ req }) =&gt; Helpers.Subgraph.GenerateContext({ req }),<br/>});</span></pre><p id="ce41" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此助手检查每个传入请求中可用作上下文的标头；默认情况下，它期望接收<code class="fe nh ni nj mz b">req.headers.context</code>。</p><p id="aa00" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以通过在网关服务中使用相同的包来确保网关发送正确的<code class="fe nh ni nj mz b">context</code>头，因为它还提供了一个助手来生成适当的头。</p><p id="c192" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，如果您的网关也在使用<code class="fe nh ni nj mz b">@the-devoyage/micro-auth-helpers</code>包，那么您可以利用内置的<code class="fe nh ni nj mz b">auth</code>上下文，该上下文会对每个请求进行解析。这是整个上下文对象的样子！它在我们的解析器中应该非常有用。</p><pre class="kk kl km kn gt my mz na nb aw nc bi"><span id="763e" class="mm kw in mz b gy nd ne l nf ng">export interface Context extends Record&lt;string, any&gt; {<br/>  auth: AuthContext;<br/>  // ...other context sent from gateway<br/>}</span><span id="68a6" class="mm kw in mz b gy nm ne l nf ng">export interface AuthContext {<br/>  payload: Payload;<br/>  isAuth: boolean;<br/>  error?: string;<br/>}</span></pre><p id="c171" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">查看这里的包装！</p><div class="nn no gp gr np nq"><a href="https://github.com/The-Devoyage/micro-auth-helpers" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd io gy z fp nv fr fs nw fu fw im bi translated">GitHub-The-devo yage/micro-auth-helpers:帮助检查身份验证状态的函数集合…</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">一个功能集合，使处理认证、授权、上下文路由、文件…</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">github.com</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe kt nq"/></div></div></a></div><p id="e1c2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您感兴趣的话，这里还有一篇关于请求如何通过联邦 API 的文章！</p><div class="nn no gp gr np nq"><a rel="noopener  ugc nofollow" target="_blank" href="/apollo-federation-how-do-request-travel-through-a-federated-architecture-e4a4da54f46d"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd io gy z fp nv fr fs nw fu fw im bi translated">Apollo 联邦:请求如何通过联邦架构？</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">通过联合 Apollo 架构的网络请求之旅非常有趣——了解流程，同时…</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">blog.devgenius.io</p></div></div><div class="nz l"><div class="of l ob oc od nz oe kt nq"/></div></div></a></div><p id="5fc4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们回到正轨。</p><h1 id="68d5" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">Mongo +分页+高级客户端过滤</h1><p id="5c93" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">在联邦 API 中处理分页、过滤和查找可能会很棘手，因为您希望标准化整个微服务中的请求方式。这可能意味着您可能正在管理重复的代码…这可不好玩。我们将通过几个快速步骤来避免这种情况。</p><h2 id="a6c3" class="mm kw in bd kx mn mo dn lb mp mq dp lf jv mr ms lj jz mt mu ln kd mv mw lr mx bi translated">连接 Mongo 和 Mongoose</h2><p id="f62d" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">你知道的，这是标准的猫鼬样本。</p><pre class="kk kl km kn gt my mz na nb aw nc bi"><span id="1b8a" class="mm kw in mz b gy nd ne l nf ng">npm i mongoose</span></pre><p id="c4c2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">并建立联系…</p><pre class="kk kl km kn gt my mz na nb aw nc bi"><span id="4d3c" class="mm kw in mz b gy nd ne l nf ng">// src/server.ts<br/>import mongoose from "mongoose";<br/>// ...imports</span><span id="a00e" class="mm kw in mz b gy nm ne l nf ng">let DB = process.env.MONGO_URI;</span><span id="eaa5" class="mm kw in mz b gy nm ne l nf ng">mongoose<br/>  .connect(DB, {<br/>    useUnifiedTopology: true,<br/>    useNewUrlParser: true,<br/>    useCreateIndex: true,<br/>    useFindAndModify: false,<br/>  })<br/>  .then(() =&gt; console.log("Mongo DB Connected..."))<br/>  .catch((err) =&gt; console.log(err));</span><span id="b9c1" class="mm kw in mz b gy nm ne l nf ng">// Start The Apollo Server Below</span></pre><h2 id="7abb" class="mm kw in bd kx mn mo dn lb mp mq dp lf jv mr ms lj jz mt mu ln kd mv mw lr mx bi translated">创建一个模型+实现查找过滤器和分页方法</h2><p id="3583" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">只是为了在将来更快地设置，让我们创建一个模型来演示标准化的查找、过滤和分页。我们将需要另一个包来帮助这一点。</p><pre class="kk kl km kn gt my mz na nb aw nc bi"><span id="70e9" class="mm kw in mz b gy nd ne l nf ng">npm i @the-devoyage/mongo-filter-generator<br/>mkdir src/models<br/>touch src/models/model-example.ts</span></pre><p id="eec0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe nh ni nj mz b">mongo-filter-generator</code>提供了一个 mongoose 插件，使得查找、过滤和分页在整个 API 中变得简单和标准化。在<code class="fe nh ni nj mz b">server.ts</code>文件中安装插件。务必在导入模式之前调用函数<strong class="jm io"> <em class="ki">！</em> </strong> <em class="ki">和其他任何猫鼬插件一样。</em></p><pre class="kk kl km kn gt my mz na nb aw nc bi"><span id="85e5" class="mm kw in mz b gy nd ne l nf ng">// src/server.ts<br/>import { findAndPaginatePlugin } from "<a class="ae nl" href="http://twitter.com/the" rel="noopener ugc nofollow" target="_blank">@the</a>-devoyage/mongo-filter-generator";<br/>import mongoose from "mongoose";<br/>mongoose.plugin(findAndPaginatePlugin);</span><span id="2a2e" class="mm kw in mz b gy nm ne l nf ng">// ...imports</span></pre><p id="ef29" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">关于这个包的一些额外阅读:</p><div class="nn no gp gr np nq"><a rel="noopener  ugc nofollow" target="_blank" href="/easy-filter-mongo-ose-documents-b1d1232eba31"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd io gy z fp nv fr fs nw fu fw im bi translated">轻松过滤蒙古文(ose)文档</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">MFG 包为您的 mongo 启用的 API 添加了即时过滤功能和最少的代码</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">blog.devgenius.io</p></div></div><div class="nz l"><div class="og l ob oc od nz oe kt nq"/></div></div></a></div><div class="nn no gp gr np nq"><a href="https://thedevoyage.medium.com/instant-api-pagination-and-filtering-with-mongo-filter-generator-228a57182116" rel="noopener follow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd io gy z fp nv fr fs nw fu fw im bi translated">使用 Mongo-Filter-Generator 进行即时 API 分页和过滤</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">使用 mongo-filter-generator 包立即为您的 api 添加分页和过滤功能！</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">thedevoyage.medium.com</p></div></div><div class="nz l"><div class="oh l ob oc od nz oe kt nq"/></div></div></a></div><div class="nn no gp gr np nq"><a href="https://github.com/The-Devoyage/mongo-filter-generator/packages/1228449" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd io gy z fp nv fr fs nw fu fw im bi translated">软件包 mongo-filter-generator</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">用几行代码查找、过滤、分页 Mongo 过滤器生成器包允许客户端请求…</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">github.com</p></div></div><div class="nz l"><div class="oi l ob oc od nz oe kt nq"/></div></div></a></div><p id="cae3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们创建一个示例模型。</p><pre class="kk kl km kn gt my mz na nb aw nc bi"><span id="8004" class="mm kw in mz b gy nd ne l nf ng">// src/models/example-model.ts<br/>import { FindAndPaginateModel } from "<a class="ae nl" href="http://twitter.com/the" rel="noopener ugc nofollow" target="_blank">@the</a>-devoyage/mongo-filter-generator";<br/>import mongoose from "mongoose";</span><span id="d283" class="mm kw in mz b gy nm ne l nf ng">const Schema = mongoose.Schema;</span><span id="141b" class="mm kw in mz b gy nm ne l nf ng">const ModelSchema = new Schema&lt;any, FindAndPaginateModel&gt;({<br/>  name: { type: String, required: true },<br/>});</span><span id="da25" class="mm kw in mz b gy nm ne l nf ng">const Model = mongoose.model&lt;any, FindAndPaginateModel&gt;("Model", ModelSchema);</span><span id="8d36" class="mm kw in mz b gy nm ne l nf ng">export { Model };</span></pre><p id="91f8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由<code class="fe nh ni nj mz b">@the-devoyage/mongo-filter-generator</code>提供的<code class="fe nh ni nj mz b">FindAndPaginateModel</code>类型将为我们用上面的 mongoose 插件安装的新方法提供类型。这样，在使用这些新方法时，我们可以让 typescript 满意。</p><p id="23b2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后一步！我们需要为模式提供一些类型和解析器，以便在 graphQL 中使用<code class="fe nh ni nj mz b">mongo-filter-generator</code>。</p><pre class="kk kl km kn gt my mz na nb aw nc bi"><span id="96e2" class="mm kw in mz b gy nd ne l nf ng">// src/graphql/schema.ts</span><span id="475e" class="mm kw in mz b gy nm ne l nf ng">import { buildSubgraphSchema } from "<a class="ae nl" href="http://twitter.com/apollo/federation" rel="noopener ugc nofollow" target="_blank">@apollo/federation</a>";<br/>import { GraphQL } from "<a class="ae nl" href="http://twitter.com/the" rel="noopener ugc nofollow" target="_blank">@the</a>-devoyage/mongo-filter-generator";</span><span id="8fb8" class="mm kw in mz b gy nm ne l nf ng">export const schema = buildSubgraphSchema([<br/>  { typeDefs: GraphQL.typeDefs, resolvers: GraphQL.resolvers },<br/>]);</span></pre><p id="5045" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="ki">最终结果！</em> </strong></p><p id="e8b0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们可以在解析器中使用自定义方法进行查找和分页，非常简单:</p><pre class="kk kl km kn gt my mz na nb aw nc bi"><span id="4c3a" class="mm kw in mz b gy nd ne l nf ng">const { filters, options } = GenerateMongo(request)<br/>const data = await model.findAndPaginate(filters, options);</span></pre><p id="e01b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我会给你看更多。</p><h1 id="a939" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">创建类型定义</h1><p id="ea53" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">组织类型定义和解析器绝对是你要考虑的事情。我试图保持每个子图看起来有组织和干净。这样，当在开发过程中切换子图时，我可以找到我需要的文件。</p><p id="3a6e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是我如何设置我的类型定义和子图文件结构。继续在您的项目中创建这些文件。</p><pre class="kk kl km kn gt my mz na nb aw nc bi"><span id="114e" class="mm kw in mz b gy nd ne l nf ng">src/graphql<br/>├── index.ts<br/>├── resolvers<br/>│   ├── index.ts<br/>│   ├── mutation<br/>│   │   ├── index.ts<br/>│   │   └── mutation.ts<br/>│   ├── query<br/>│   │   ├── index.ts<br/>│   │   └── query.ts<br/>│   └── resolvers.ts<br/>├── schema.ts<br/>└── typeDefs<br/>    ├── index.ts<br/>    ├── example-model<br/>    │   ├── index.ts<br/>    │   └── example-model.ts<br/>    ├── mutation<br/>    │   ├── index.ts<br/>    │   └── mutation.ts<br/>    ├── query<br/>    │   ├── index.ts<br/>    │   └── query.ts<br/>    └── typeDefs.ts</span></pre><p id="462a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们从文件结构的深层开始，逐步解决这个问题。</p><h2 id="273e" class="mm kw in bd kx mn mo dn lb mp mq dp lf jv mr ms lj jz mt mu ln kd mv mw lr mx bi translated">类型定义</h2><p id="de17" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated"><strong class="jm io">型号定义</strong></p><p id="fe8f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">按类型排序似乎是我最喜欢的组织类型定义的方式。首先，定义我们创建的示例模型。</p><pre class="kk kl km kn gt my mz na nb aw nc bi"><span id="e9f1" class="mm kw in mz b gy nd ne l nf ng">// src/graphql/typeDefs/example-model/example-model.ts<br/>import { gql } from "apollo-server";</span><span id="78dc" class="mm kw in mz b gy nm ne l nf ng">export const ExampleModel = gql`<br/>  type ExampleModel {<br/>    _id: ObjectID!<br/>    createdAt: DateTime!<br/>    updatedAt: DateTime!<br/>    name: String!<br/>  }<br/>`;</span></pre><p id="9219" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我通常为每个为数据库创建的模型创建一个新的 defs 文件夹和文件。</p><p id="713c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">查询定义</strong></p><p id="ab99" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">检查查询类型 Defs！<em class="ki">注意这里，这是轻松分页和过滤魔法的开始。</em></p><pre class="kk kl km kn gt my mz na nb aw nc bi"><span id="a6ba" class="mm kw in mz b gy nd ne l nf ng">// src/typeDefs/query/query.ts<br/>import { gql } from "apollo-server-express";</span><span id="1492" class="mm kw in mz b gy nm ne l nf ng">export const Query = gql`<br/>  type GetModelsResponse {<br/>    data: [ExampleModel]<br/>    stats: Stats<br/>  }</span><span id="1ff1" class="mm kw in mz b gy nm ne l nf ng">input GetModelsInput {<br/>    _id: StringFieldFilter<br/>    createdAt: StringFieldFilter<br/>    updatedAt: StringFieldFilter<br/>    name: StringFieldFilter<br/>  }</span><span id="a2f6" class="mm kw in mz b gy nm ne l nf ng">extend type Query {<br/>    getModels(getModelsInput: GetModelsInput!): GetModelsResponse!<br/>  }<br/>`;</span></pre><p id="cb03" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe nh ni nj mz b">@the-devoyage/mongo-filter-generator</code>包提供了多种 graphql 类型来帮助过滤和分页。上面，我们定义了一个与<code class="fe nh ni nj mz b">ExampleModel</code>的形状相匹配的输入，只有一点不同，我们指定了过滤器类型来定义如何查询每个属性。</p><p id="8c3a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe nh ni nj mz b">filter</code>类型由<code class="fe nh ni nj mz b">mongo-filter-package</code>提供。它们允许客户端通过各种方法过滤所有文档。有许多滤波器选项可以满足大多数需求。<a class="ae nl" href="https://github.com/The-Devoyage/mongo-filter-generator/packages/1228449" rel="noopener ugc nofollow" target="_blank">查看文档</a>。</p><p id="dc1a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个包还提供了一个<code class="fe nh ni nj mz b">Stats</code>对象，可以向客户端共享分页信息…还剩多少文档，文档的页数…</p><p id="1f7a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">突变定义</strong></p><pre class="kk kl km kn gt my mz na nb aw nc bi"><span id="0ca3" class="mm kw in mz b gy nd ne l nf ng">// src/graphql/mutation/mutation.ts</span><span id="efd1" class="mm kw in mz b gy nm ne l nf ng">import { gql } from "apollo-server-express";</span><span id="42d8" class="mm kw in mz b gy nm ne l nf ng">export const Mutation = gql`<br/>  input CreateModelInput {<br/>    name: String!<br/>  }</span><span id="cd10" class="mm kw in mz b gy nm ne l nf ng">input UpdateModelInput {<br/>    _id: ObjectID!<br/>    name: String<br/>  }</span><span id="08e1" class="mm kw in mz b gy nm ne l nf ng">input DeleteModelInput {<br/>    _id: ObjectID!<br/>  }</span><span id="c4f7" class="mm kw in mz b gy nm ne l nf ng">extend type Mutation {<br/>    createModel(createModelInput: CreateModelInput!): ExampleModel!<br/>    updateModel(updateModelInput: UpdateModelInput!): ExampleModel!<br/>    deleteModel(deleteModelInput: DeleteModelInput!): ExampleModel!<br/>  }<br/>`;</span></pre><p id="a11e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将所有这些放在 typeDefs 文件本身中。</p><pre class="kk kl km kn gt my mz na nb aw nc bi"><span id="5db6" class="mm kw in mz b gy nd ne l nf ng">// src/graphql/typeDefs/typeDefs.ts</span><span id="d237" class="mm kw in mz b gy nm ne l nf ng">import { ExampleModel } from "./example-model";<br/>import { Query } from "./query";<br/>import { Mutation } from "./mutation";</span><span id="9325" class="mm kw in mz b gy nm ne l nf ng">export const typeDefs = {<br/>  ExampleModel,<br/>  Mutation,<br/>  Query,<br/>};</span></pre><p id="f2b0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，将<code class="fe nh ni nj mz b">typeDefs</code>导入<code class="fe nh ni nj mz b">schema</code>中。</p><pre class="kk kl km kn gt my mz na nb aw nc bi"><span id="1d06" class="mm kw in mz b gy nd ne l nf ng">// src/graphql/schema.ts<br/>import { buildSubgraphSchema } from "<a class="ae nl" href="http://twitter.com/apollo/federation" rel="noopener ugc nofollow" target="_blank">@apollo/federation</a>";<br/>import { typeDefs } from "<a class="ae nl" href="http://twitter.com/src/graphql" rel="noopener ugc nofollow" target="_blank">@src/graphql</a>/typeDefs";<br/>import { GraphQL } from "<a class="ae nl" href="http://twitter.com/the" rel="noopener ugc nofollow" target="_blank">@the</a>-devoyage/mongo-filter-generator";</span><span id="8b3a" class="mm kw in mz b gy nm ne l nf ng">export const schema = buildSubgraphSchema([<br/>  { typeDefs: typeDefs.ExampleModel },<br/>  { typeDefs: typeDefs.Query },<br/>  { typeDefs: typeDefs.Mutation },<br/>  { typeDefs: GraphQL.typeDefs, resolvers: GraphQL.resolvers },<br/>]);</span></pre><h1 id="133e" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">生成类型</h1><p id="ee85" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">我知道这可能看起来有点混乱…但是我们现在可以启动服务器并生成类型了。这样，我们可以在进行过程中键入解析器。</p><h2 id="03bb" class="mm kw in bd kx mn mo dn lb mp mq dp lf jv mr ms lj jz mt mu ln kd mv mw lr mx bi translated">启动服务器</h2><p id="2452" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">服务器需要运行才能生成类型。现在还不要担心 Mongo 连接，因为缺少与数据库的连接不会导致服务器崩溃。</p><pre class="kk kl km kn gt my mz na nb aw nc bi"><span id="af95" class="mm kw in mz b gy nd ne l nf ng">npm run dev</span></pre><h2 id="c784" class="mm kw in bd kx mn mo dn lb mp mq dp lf jv mr ms lj jz mt mu ln kd mv mw lr mx bi translated">生成类型</h2><p id="b160" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">为了生成类型，我们将使用<code class="fe nh ni nj mz b">graphql-codegen</code>包。</p><pre class="kk kl km kn gt my mz na nb aw nc bi"><span id="e1cc" class="mm kw in mz b gy nd ne l nf ng">npm i -D <a class="ae nl" href="http://twitter.com/graphql" rel="noopener ugc nofollow" target="_blank">@graphql</a>-codegen/cli <a class="ae nl" href="http://twitter.com/graphql" rel="noopener ugc nofollow" target="_blank">@graphql</a>-codegen/typescript <a class="ae nl" href="http://twitter.com/graphql" rel="noopener ugc nofollow" target="_blank">@graphql</a>-codegen/typescript-resolvers</span><span id="280e" class="mm kw in mz b gy nm ne l nf ng">touch codegen.yaml</span></pre><p id="445a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">创建一个文件来键入此服务的上下文。</p><pre class="kk kl km kn gt my mz na nb aw nc bi"><span id="82c6" class="mm kw in mz b gy nd ne l nf ng">mkdir types/context<br/>touch types/context/index.d.ts</span></pre><p id="ddad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因为我们使用<code class="fe nh ni nj mz b">@the-devoyage/micro-auth-helpers</code>包来生成上下文，所以我们可以扩展它提供的上下文类型，以包含我们自己的定制值(如果适用的话)。如果没有，只需创建一个名为<code class="fe nh ni nj mz b">Context</code>的接口来定义您的自定义上下文。</p><pre class="kk kl km kn gt my mz na nb aw nc bi"><span id="2ff8" class="mm kw in mz b gy nd ne l nf ng">// types/context.index.d.ts<br/>import { Context as IContext } from "<a class="ae nl" href="http://twitter.com/the" rel="noopener ugc nofollow" target="_blank">@the</a>-devoyage/micro-auth-helpers";</span><span id="d7dd" class="mm kw in mz b gy nm ne l nf ng">export interface Context extends IContext {<br/>  //Add custom context types<br/>}</span></pre><p id="c3da" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">设置 codegen 配置。</p><pre class="kk kl km kn gt my mz na nb aw nc bi"><span id="72fc" class="mm kw in mz b gy nd ne l nf ng">## codegen.yaml<br/>schema: <a class="ae nl" href="http://localhost:5002/graphql" rel="noopener ugc nofollow" target="_blank">http://localhost:5999/graphql</a><br/>generates:<br/>  ./types/generated/index.d.ts:<br/>    config:<br/>      useIndexSignature: true<br/>      federation: true<br/>      contextType: types/context#Context<br/>    plugins:<br/>      - typescript<br/>      - typescript-resolvers</span></pre><p id="3855" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">向 package.json 添加一个快速的<code class="fe nh ni nj mz b">generate</code>脚本。</p><pre class="kk kl km kn gt my mz na nb aw nc bi"><span id="6aee" class="mm kw in mz b gy nd ne l nf ng">"generate": "graphql-codegen"</span></pre><p id="8322" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">运行脚本！</p><pre class="kk kl km kn gt my mz na nb aw nc bi"><span id="f15d" class="mm kw in mz b gy nd ne l nf ng">npm run generate</span></pre><p id="dc53" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在您应该在<code class="fe nh ni nj mz b">types/generated</code>中有了一个新文件，它包含了从 graphql 子图中生成的所有类型脚本类型。</p><p id="6bf5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将使我们能够在整个服务中使用新生成的类型。</p><h1 id="382f" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated"><strong class="ak">创建解析器</strong></h1><p id="668c" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">是时候创建解析器并实现查找、过滤和分页功能了。</p><h2 id="2f8d" class="mm kw in bd kx mn mo dn lb mp mq dp lf jv mr ms lj jz mt mu ln kd mv mw lr mx bi translated">查询解析器</h2><p id="9d32" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">查询解析器将解析需要信息的请求，比如 restful API 中的<code class="fe nh ni nj mz b">GET</code>请求。</p><pre class="kk kl km kn gt my mz na nb aw nc bi"><span id="67ba" class="mm kw in mz b gy nd ne l nf ng">// src/graphql/resolvers/query/query.ts<br/>import { GenerateMongo } from "<a class="ae nl" href="http://twitter.com/the" rel="noopener ugc nofollow" target="_blank">@the</a>-devoyage/mongo-filter-generator";<br/>import { QueryResolvers, Model as IModel } from "types/generated";<br/>import { Model } from "<a class="ae nl" href="http://twitter.com/src/models" rel="noopener ugc nofollow" target="_blank">@src/models</a>";</span><span id="5159" class="mm kw in mz b gy nm ne l nf ng">export const Query: QueryResolvers = {<br/>  getModels: async (_model, args, _context) =&gt; {<br/>    try {<br/>      const { filters, options } = GenerateMongo({<br/>        fieldFilters: args.getModelsInput,<br/>        config: args.getModelsInput.config,<br/>      });</span><span id="9700" class="mm kw in mz b gy nm ne l nf ng">      const models = await Model.findAndPaginate&lt;IModel&gt;(filters, options);</span><span id="32cc" class="mm kw in mz b gy nm ne l nf ng">      return models;<br/>    } catch (error) {<br/>      console.log(error);<br/>      throw error;<br/>    }<br/>  },<br/>};</span></pre><p id="a3f6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就这样——我们实现了查找、过滤和分页！让我解释一下…</p><ul class=""><li id="ba7f" class="ly lz in jm b jn jo jr js jv ma jz mb kd mc kh nk me mf mg bi translated">请求到达解析器。</li><li id="7254" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh nk me mf mg bi translated"><code class="fe nh ni nj mz b">GenerateMongo</code>函数将 args(我们上面应用的过滤器)转换为输入类型 defs！)转化为<code class="fe nh ni nj mz b">filters</code>，可应用于<code class="fe nh ni nj mz b">model.find()</code>或<code class="fe nh ni nj mz b">model.findAndPaingate()</code>方法。</li><li id="1934" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh nk me mf mg bi translated">可以简单地将<code class="fe nh ni nj mz b">filters</code>和<code class="fe nh ni nj mz b">options</code>传递给 mongoose，用<code class="fe nh ni nj mz b">findAndPaginate()</code>方法查找过滤器和分页。</li></ul><p id="997d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过几行代码，我们现在已经在<code class="fe nh ni nj mz b">query</code>解析器中实现了<code class="fe nh ni nj mz b">finding</code>、<code class="fe nh ni nj mz b">filtering</code>和<code class="fe nh ni nj mz b">paginating</code>。</p><h2 id="f1b7" class="mm kw in bd kx mn mo dn lb mp mq dp lf jv mr ms lj jz mt mu ln kd mv mw lr mx bi translated">变异分解器</h2><p id="32cf" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">对于解析器，我们将设置一些标准解析器，这些解析器实现了我们已经安装的<code class="fe nh ni nj mz b">@the-devoyage/micro-auth-helpers</code>包中的一些<code class="fe nh ni nj mz b">auth</code>特性。</p><pre class="kk kl km kn gt my mz na nb aw nc bi"><span id="4990" class="mm kw in mz b gy nd ne l nf ng">// src/graphql/resolvers/mutation/mutation.ts</span><span id="c46e" class="mm kw in mz b gy nm ne l nf ng">import { Helpers } from "<a class="ae nl" href="http://twitter.com/the" rel="noopener ugc nofollow" target="_blank">@the</a>-devoyage/micro-auth-helpers";<br/>import { MutationResolvers } from "types/generated";<br/>import { Model } from "<a class="ae nl" href="http://twitter.com/src/models" rel="noopener ugc nofollow" target="_blank">@src/models</a>";</span><span id="d677" class="mm kw in mz b gy nm ne l nf ng">export const Mutation: MutationResolvers = {<br/>  createModel: async (_, args, context) =&gt; {<br/>    try {<br/>      Helpers.Resolver.CheckAuth({ context, requireUser: true });</span><span id="7b5a" class="mm kw in mz b gy nm ne l nf ng">      const model = new Model({<br/>        ...args.createModelInput,<br/>        created_by: context.auth.payload.user._id,<br/>      });</span><span id="025e" class="mm kw in mz b gy nm ne l nf ng">      await model.save();</span><span id="a9ee" class="mm kw in mz b gy nm ne l nf ng">      return model;<br/>    } catch (error) {<br/>      console.log(error);<br/>      throw error;<br/>    }<br/>  },</span><span id="8889" class="mm kw in mz b gy nm ne l nf ng">updateModel: async (_, args, context) =&gt; {<br/>    try {<br/>      Helpers.Resolver.CheckAuth({ context, requireUser: true });</span><span id="4da5" class="mm kw in mz b gy nm ne l nf ng">      const model = await Model.findOne(<br/>        { _id: args.updateModelInput?._id },<br/>        args.updateModelInput<br/>      );</span><span id="94ea" class="mm kw in mz b gy nm ne l nf ng">      if (!model) {<br/>        return Error("Does not exist.");<br/>      }</span><span id="74a3" class="mm kw in mz b gy nm ne l nf ng">      if (context.auth.payload.user._id !== model.created_by) {<br/>        Helpers.Resolver.LimitRole({<br/>          userRole: context.auth.payload.user.role,<br/>          roleLimit: 1,<br/>          errorMessage:<br/>            "Only admin may edit models that are created by other users.",<br/>        });<br/>      }</span><span id="628f" class="mm kw in mz b gy nm ne l nf ng">      const updated = await Model.findOneAndUpdate(<br/>        { _id: model._id },<br/>        { ...args.updateModelInput },<br/>        { new: true }<br/>      );</span><span id="82e9" class="mm kw in mz b gy nm ne l nf ng">     return updated;<br/>    } catch (error) {<br/>      console.log(error);<br/>      throw error;<br/>    }<br/>  },</span><span id="6195" class="mm kw in mz b gy nm ne l nf ng">deleteModel: async (_, args, context) =&gt; {<br/>    try {<br/>      Helpers.Resolver.CheckAuth({ context, requireUser: true });</span><span id="549e" class="mm kw in mz b gy nm ne l nf ng">      const model = await Model.findOne(<br/>        { _id: args.deleteModelInput?._id },<br/>        args.deleteModelInput<br/>      );</span><span id="8c87" class="mm kw in mz b gy nm ne l nf ng">      if (!model) {<br/>        return Error("Does not exist.");<br/>      }</span><span id="cabd" class="mm kw in mz b gy nm ne l nf ng">      if (context.auth.payload.user._id !== model.created_by) {<br/>        Helpers.Resolver.LimitRole({<br/>          userRole: context.auth.payload.user.role,<br/>          roleLimit: 1,<br/>          errorMessage:<br/>            "Only admin may delete models that are created by other users.",<br/>        });<br/>      }</span><span id="b858" class="mm kw in mz b gy nm ne l nf ng">      await Model.deleteOne({ _id: model._id });</span><span id="b5cb" class="mm kw in mz b gy nm ne l nf ng">      return model;<br/>    } catch (error) {<br/>      console.log(error);<br/>      throw error;<br/>    }<br/>  },<br/>};</span></pre><p id="0217" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe nh ni nj mz b">micro-auth-helpers</code>中的<code class="fe nh ni nj mz b">CheckAuth</code>函数将使用网关提供的上下文来检查网关是否验证了用户是授权的，从而允许代码继续执行。[记住:我希望使用的网关也是使用<code class="fe nh ni nj mz b">@the-devoyage/micro-auth-helpers</code>包构建的，所以它会向我们发送<code class="fe nh ni nj mz b">auth</code>上下文！]</p><p id="dbc9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外,<code class="fe nh ni nj mz b">LimitRole</code>特性非常自描述，也有助于使用上下文来限制每个请求中的角色。</p><p id="fca6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，把它们放在一起。</p><pre class="kk kl km kn gt my mz na nb aw nc bi"><span id="ca93" class="mm kw in mz b gy nd ne l nf ng">// src/graphql/resolvers/resolvers.ts<br/>import { Resolvers } from "types/generated/index";<br/>import { Query } from "./query";<br/>import { Mutation } from "./mutation";</span><span id="f07f" class="mm kw in mz b gy nm ne l nf ng">export const resolvers: Resolvers = {<br/>  Query: {<br/>    Query,<br/>  },<br/>  Mutation: { Mutation },<br/>};</span></pre><p id="b424" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就是这样！我们完了！我们坚持到了最后！现在是时候祈祷我们实现的逻辑能够正常工作了！</p><pre class="kk kl km kn gt my mz na nb aw nc bi"><span id="07cf" class="mm kw in mz b gy nd ne l nf ng">npm run dev</span></pre><h1 id="f23b" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">仓库</h1><p id="e49b" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">哇！我们坚持到了最后！</p><p id="998c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们刚刚构建了一个子图启动器，它为 API 做好了 80%的准备——允许您更快地对实际项目进行编码。</p><h2 id="fb3e" class="mm kw in bd kx mn mo dn lb mp mq dp lf jv mr ms lj jz mt mu ln kd mv mw lr mx bi translated">克隆它</h2><p id="6050" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">要克隆，非常简单——我已经在存储库前面建立了一个简单的付费墙。您的购买授权您访问协作和克隆它永远与所有的更新，铃声和哨声来了！在此获取访问权限=&gt; <a class="ae nl" href="https://basetools.io/checkout/cgfbWjXq" rel="noopener ugc nofollow" target="_blank"> CloneTheRepo() </a></p><p id="0828" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢您的支持！</p></div><div class="ab cl oj ok hr ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="ig ih ii ij ik"><p id="269a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">嘿你们！</p><p id="754a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上周五手术进行得很顺利——如果你是新手，我必须修复我的前交叉韧带和半月板。好了，差不多 2 周了，我又能走路了，比计划的早了 4.5 周——当然！</p><p id="06f2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">虽然我只有两个星期的时间，但我错过了一些非常重要的事情。你有没有意识到散步对于解决关键问题有多重要？我想我可能最怀念这个了。一次愉快的散步能如此之快地激发你用代码解决一个问题，这太疯狂了。</p><p id="68fa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我有四个新的 starter 服务教程准备用于这个 API——全部构建在您刚刚构建或从本文克隆的子图 starter 之上！接下来将是帐户服务与认证和更多！请继续关注，以便我们可以构建或克隆它。</p><p id="6429" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢您查看这篇文章，并伸出援手——这意义重大！</p><p id="943c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">尼克·M</p></div></div>    
</body>
</html>