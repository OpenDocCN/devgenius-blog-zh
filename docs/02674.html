<html>
<head>
<title>Node.js Tips — Unzipping Files, Storing Passwords, and REPLs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js 提示—解压缩文件、存储密码和回复</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/node-js-tips-unzipping-files-storing-passwords-and-repls-85f2f10054a0?source=collection_archive---------12-----------------------#2020-08-19">https://blog.devgenius.io/node-js-tips-unzipping-files-storing-passwords-and-repls-85f2f10054a0?source=collection_archive---------12-----------------------#2020-08-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b10bf14af044f49469481aa1fb8e6c3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2kK0b1-d6F1cdyS-"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">里卡多·莫拉在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="612c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，当我们编写节点应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些编写节点应用程序时常见问题的解决方案。</p><h1 id="ef5f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用 Node.js 和 MongoDB 存储密码</h1><p id="f5dd" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">bcrypt</code>库将密码存储在 MongoDB 文档中。</p><p id="92df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">比如说。我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0fab" class="mq lc iq mh b gy mr ms l mt mu">const mongoose = require('mongoose');<br/>const Schema = mongoose.Schema;<br/>const bcrypt = require('bcrypt');<br/>const SALT_WORK_FACTOR = 10;<br/><br/>const UserSchema = new Schema({<br/>  username: { <br/>    type: String, <br/>    required: true, <br/>    index: { <br/>      unique: true <br/>    } <br/>  },<br/>  password: { type: String, required: true }<br/>});<br/><br/>module.exports = mongoose.model('User', UserSchema);</span></pre><p id="b478" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe me mf mg mh b">Schema</code>构造函数创建了<code class="fe me mf mg mh b">UserSchema</code>。</p><p id="dbfe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它有<code class="fe me mf mg mh b">username</code>和<code class="fe me mf mg mh b">password</code>字符串字段。</p><p id="43ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以使用<code class="fe me mf mg mh b">pre</code>方法在保存密码之前对其进行哈希和加盐处理。</p><p id="9f34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="37c1" class="mq lc iq mh b gy mr ms l mt mu">UserSchema.pre('save', function(next) {<br/>  const user = this;<br/>  if (!user.isModified('password')){<br/>    return next();<br/>  }<br/>  <br/>  bcrypt.genSalt(SALT_WORK_FACTOR, (err, salt) =&gt; {<br/>    if (err) {<br/>       return next(err);<br/>    }<br/>    <br/>    bcrypt.hash(user.password, salt, (err, hash) =&gt; {<br/>      if (err) {<br/>        return next(err);<br/>      }<br/>      user.password = hash;<br/>      next();<br/>    });<br/>  });<br/>});</span></pre><p id="da7b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用散列和加盐密码覆盖纯文本密码/</p><p id="0ff1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们使用了<code class="fe me mf mg mh b">genSalt</code>方法来创建盐。</p><p id="01cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们根据密码创建散列。</p><p id="f4af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将生成的<code class="fe me mf mg mh b">salt</code>传递给了<code class="fe me mf mg mh b">hashmethod.</code></p><p id="ae8a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们将<code class="fe me mf mg mh b">password</code>属性设置为<code class="fe me mf mg mh b">hash</code>。</p><p id="0bec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们调用<code class="fe me mf mg mh b">next</code>继续保存用户数据。</p><h1 id="78ea" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不支持修复协议“https:”。预期的“http:”错误</h1><p id="d1ac" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以修复这个错误，它发生在我们试图用<code class="fe me mf mg mh b">http</code>发出 HTTPS 请求的时候。</p><p id="b4d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们必须使用<code class="fe me mf mg mh b">https.get</code>而不是<code class="fe me mf mg mh b">http.get</code>来请求一个以<code class="fe me mf mg mh b">https</code>开头的 URL。</p><h1 id="d021" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Mongoose 连接错误回调</h1><p id="74d5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以在传递给<code class="fe me mf mg mh b">connect</code>的回调中发现错误。</p><p id="273d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="fd52" class="mq lc iq mh b gy mr ms l mt mu">mongoose.connect('mongodb://localhost/db', (err) =&gt; {<br/>  if (err) throw err;<br/>});</span></pre><p id="bb3b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">err</code>有错误时设置的错误对象。</p><h1 id="aaa1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">运行一些代码，然后进入节点 REPL</h1><p id="8b28" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">repl</code>模块来启动 REPL。</p><p id="5492" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="eeb9" class="mq lc iq mh b gy mr ms l mt mu">const repl = require("repl");<br/>const r = repl.start("node&gt; ");</span></pre><p id="ac2a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用自己选择的命令提示符调用<code class="fe me mf mg mh b">start</code>REPL。</p><h1 id="539e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在运行时获取 Node.js 版本</h1><p id="86a4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以在运行时用<code class="fe me mf mg mh b">process.version</code>属性获得节点版本。</p><p id="bb63" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要获得更多的版本信息，我们可以使用<code class="fe me mf mg mh b">process.versions</code>属性。</p><p id="55b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们会得到这样的结果:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="32c1" class="mq lc iq mh b gy mr ms l mt mu">{<br/>  node: '12.16.3',<br/>  v8: '7.8.279.23-node.35',<br/>  uv: '1.34.2',<br/>  zlib: '1.2.11',<br/>  brotli: '1.0.7',<br/>  ares: '1.16.0',<br/>  modules: '72',<br/>  nghttp2: '1.40.0',<br/>  napi: '5',<br/>  llhttp: '2.0.4',<br/>  http_parser: '2.9.3',<br/>  openssl: '1.1.1g',<br/>  cldr: '36.0',<br/>  icu: '65.1',<br/>  tz: '2019c',<br/>  unicode: '12.1'<br/>}</span></pre><h1 id="df1d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">解压缩 NodeJS 请求的模块 gzip 响应体</h1><p id="3443" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过使用<code class="fe me mf mg mh b">zlib</code>库来解压缩 gzipped 文件。</p><p id="fdf8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5eb0" class="mq lc iq mh b gy mr ms l mt mu">const http = require("http"),<br/>const zlib = require("zlib");</span><span id="7006" class="mq lc iq mh b gy mv ms l mt mu">const getGzipped = (url, callback) =&gt; {<br/>  const buffer = [];<br/>  http.get(url, (res) =&gt; {<br/>    const gunzip = zlib.createGunzip();            <br/>    res.pipe(gunzip);<br/>    <br/>    gunzip.on('data', (data) =&gt; {<br/>      buffer.push(data.toString())<br/>    })<br/>    .on("end", () =&gt; {<br/>      callback(null, buffer.join(""));<br/>    })<br/>    .on("error", (e) =&gt; {<br/>      callback(e);<br/>    })<br/>  })<br/>  .on('error', (e) =&gt; {<br/>    callback(e);<br/>  });<br/>}</span><span id="4e31" class="mq lc iq mh b gy mv ms l mt mu">getGzipped(url, (err, data) =&gt; {<br/>   console.log(data);<br/>});</span></pre><p id="f3f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通过使用<code class="fe me mf mg mh b">http.get</code>方法发出获取压缩文件的 GET 请求来创建<code class="fe me mf mg mh b">getGzipped</code>函数。</p><p id="177e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后调用<code class="fe me mf mg mh b">createGunzip</code>来创建<code class="fe me mf mg mh b">gunzip</code>对象，我们可以通过管道将<code class="fe me mf mg mh b">res</code>流对象传递给它。</p><p id="a410" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以监听<code class="fe me mf mg mh b">data</code>事件来获取数据。</p><p id="29fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在<code class="fe me mf mg mh b">buffer</code>对象上调用<code class="fe me mf mg mh b">push</code>来收集数据。</p><p id="5985" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后当发出<code class="fe me mf mg mh b">end</code>事件时，我们调用<code class="fe me mf mg mh b">callback</code>将数据发送给回调。</p><p id="cf7b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当<code class="fe me mf mg mh b">error</code>事件从<code class="fe me mf mg mh b">gunzip</code>或<code class="fe me mf mg mh b">http.get</code>方法发出时，我们将调用<code class="fe me mf mg mh b">callback</code>来发送错误。</p><p id="24b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以使用该函数来获取错误或解压缩文件的数据。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/027960b3223cff3df86f96e659d804a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fkJQ5uOG972v3d3y"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@toimetaja?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Toimetaja tülkebüroo</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="e26c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="daa3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以得到带有<code class="fe me mf mg mh b">process</code>对象的版本。</p><p id="18e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了解压从<code class="fe me mf mg mh b">http.get</code>方法获得的文件，我们可以用<code class="fe me mf mg mh b">zlib</code>解压。</p><p id="456d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想安全地存储密码，我们必须手动散列和加盐。</p><p id="38db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">repl</code>模块访问 REPL。</p></div></div>    
</body>
</html>