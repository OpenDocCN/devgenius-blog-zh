# 动态规划是一种有效的方法😎

> 原文：<https://blog.devgenius.io/dynamic-programming-dp-an-efficient-way-3ad561f27f22?source=collection_archive---------1----------------------->

举例说明。只要看一看，让我知道你的想法！

# 概观

D 动态编程和**记忆**协同工作。**动态编程**和**分治**的主要区别在于，在后者的情况下，子问题**是独立的**，而在 DP 中，子问题可以有**重叠。**

![](img/29756fae00a5ddb5334e31fb2a72c722.png)

来自 unDraw

> 通过使用**记忆**【维护已经解决的子问题**的表】，动态编程将**指数复杂度降低到多项式**复杂度(O(n 2)，O(n 3)等)。)对于很多问题。**

# 动态编程的组件

一般来说，动态编程有两个组成部分:

```
 Dynamic Programming = Recursion + Memoization
```

# 动态规划策略的性质

可以判断它是否能解决给定问题的两个动态规划特性是:

*   **最优子结构:**一个问题的最优解包含子问题的最优解。
*   **重叠子问题:**递归解决方案包含少量重复多次的不同子问题。

> L 像贪婪和分而治之的技术一样，DP 不能解决每一个问题。有些问题是任何算法技术(贪婪、分治和动态规划)都无法解决的。

动态编程和直接递归的区别在于递归调用的记忆化。如果子问题是独立的，并且没有重复，那么记忆没有帮助，所以动态规划不是所有问题的解决方案。

# 动态规划方法

基本上有两种解决动态规划问题的方法

*   自底向上动态规划(迭代)
*   自顶向下动态编程(递归)

**自上而下:**把给定的问题分解，开始解决。如果你看到问题已经解决了，那么只需返回保存的答案。如果还没解决，那就解决，保存答案。这通常很容易想到，也很直观。这被称为 ***记忆化*** 。

**自下而上** **:** 分析问题，看子问题解决的顺序，从琐碎的子问题开始解决，向上朝着给定的问题解决。在这个过程中，保证在解决问题之前先解决子问题。这被称为 ***动态编程*** 。

# 动态编程算法的例子

*   许多字符串算法，包括最长公共子序列，最长增长子序列，最长公共子串，编辑距离。
*   图上的算法可以高效求解:求图中最短距离的 Bellman-Ford 算法，Floyd 的全对最短路径算法等。
*   链式矩阵乘法
*   子集和
*   0/1 背包
*   旅行推销员问题，等等

# 使用动态规划创建斐波那契数列

如果我们用 nonDP 写一个斐波那契数列，我们会得到一些指数复杂度。

自下而上的方法:

```
def Fibo(n): 
    fibTable = [0, 1] 
    for i in range(2,n+ 1 ): 
        fibTable.append(fibTable[i-1] + fibTable[i-2]) 
    return fibTable[n]print(Fibo(10})
```

自上而下的方法:

```
fibTable = {1: 1, 2:1}
def Fibo(n):
    if <= 2 :
        return 1 
    if n in fibTable:
        return fibTable[n]
    else:
        fibTable[n] = Fibo(n-1) + Fibo(n-2)
        return fibTable[n]print(Fibo(10))
```

**注:** *斐波那契数列实现的两个版本都明显将问题复杂度降低到 O(n)。这是因为如果已经计算了一个值，那么我们就不再调用子问题了。相反，我们直接从表* **中取其值。**

时间复杂度:O(n)。空间复杂度:O(n)，对于表。

> 因为我们只需要最后两个值的和，我们 DONT 需要存储所有的 PRIVIOS 值。我们可以这样改进它:

```
def Fibo(n): 
    a, b = 0, 1 
    for i in range(n): 
        a, b = b, a+ b 
    return a print(Fibo(1O))
```

时间复杂度:O(n)。空间复杂度:O(1)。

# 要记住的一点

在使用 DP 解决问题时，尝试找出以下几点:

*   看看这些问题是如何根据子问题递归定义的。
*   看看我们能否使用一些表格[记忆]来避免重复计算。

# 从这里去哪里

> *我的 GitHub:*[https://github.com/myawesomehub](https://github.com/myawesomehub)

**我的写作:** [**链接**](https://docs.google.com/spreadsheets/d/15HwwuNHLgtw0W3TnllkAuWt0LN5ozsWfV5snf0Ky6ho/edit?usp=sharing)

继续关注，获取更多有用的文章👍
谢谢！