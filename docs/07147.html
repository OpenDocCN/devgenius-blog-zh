<html>
<head>
<title>External Merge Sort using Priority Queue</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用优先级队列的外部合并排序</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/external-merge-sorting-dcf5dc6f93cb?source=collection_archive---------11-----------------------#2022-03-01">https://blog.devgenius.io/external-merge-sorting-dcf5dc6f93cb?source=collection_archive---------11-----------------------#2022-03-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/6e42348708c5815b7f299e8b94da005a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SxT_NO0JJlyoDHWDS3UpEA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">外部分拣—龙猫</figcaption></figure><p id="e8fc" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">外部排序</strong>是一类可以处理海量数据的排序算法。当被排序的数据不适合计算设备的主存储器(RAM)时，需要外部排序。相反，它们必须驻留在较慢的外部存储器(磁盘)中。</p><p id="8501" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为了解释使用优先级队列的外部合并排序的工作原理，考虑输入数组:<code class="fe kx ky kz la b">[5, 8, 6, 3, 7, 1, 4, 9, 10, 2]</code></p><h1 id="a1e2" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">概述:</h1><ol class=""><li id="64ec" class="lz ma in kb b kc mb kg mc kk md ko me ks mf kw mg mh mi mj bi translated">在分割阶段，大的输入文件被分割成可以放入内存的较小的块。</li><li id="e86a" class="lz ma in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">在合并阶段，逐个对每个较小的块文件执行 K 向合并，并将输出写入文件。</li></ol><h1 id="f3ed" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">分相:</h1><ul class=""><li id="6726" class="lz ma in kb b kc mb kg mc kk md ko me ks mf kw mp mh mi mj bi translated">将输入分成几块(5 块)。</li><li id="3bd0" class="lz ma in kb b kc mk kg ml kk mm ko mn ks mo kw mp mh mi mj bi translated">然后，对每个单独的块进行排序。</li><li id="2522" class="lz ma in kb b kc mk kg ml kk mm ko mn ks mo kw mp mh mi mj bi translated">最后，将排序后的块存储在文件中(5 个临时文件)。</li></ul><p id="27eb" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为此，我们有 5 个文件:</p><ul class=""><li id="ca04" class="lz ma in kb b kc kd kg kh kk mq ko mr ks ms kw mp mh mi mj bi translated">组块 1: <code class="fe kx ky kz la b">[5, 8]</code></li><li id="85ca" class="lz ma in kb b kc mk kg ml kk mm ko mn ks mo kw mp mh mi mj bi translated">第二块:<code class="fe kx ky kz la b">[3, 6]</code></li><li id="66fa" class="lz ma in kb b kc mk kg ml kk mm ko mn ks mo kw mp mh mi mj bi translated">组块 3: <code class="fe kx ky kz la b">[1, 7]</code></li><li id="e1ec" class="lz ma in kb b kc mk kg ml kk mm ko mn ks mo kw mp mh mi mj bi translated">第四块:<code class="fe kx ky kz la b">[4, 9]</code></li><li id="e625" class="lz ma in kb b kc mk kg ml kk mm ko mn ks mo kw mp mh mi mj bi translated">组块 5: <code class="fe kx ky kz la b">[2, 10]</code></li></ul><h1 id="f3d3" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">合并阶段:</h1><ul class=""><li id="5811" class="lz ma in kb b kc mb kg mc kk md ko me ks mf kw mp mh mi mj bi translated">创建数量为<code class="fe kx ky kz la b">HeapNode</code>的<code class="fe kx ky kz la b">m</code>，其中<code class="fe kx ky kz la b">HeapNode</code>的值是块的最低元素，并存储对临时块文件的引用。示例:</li></ul><pre class="mt mu mv mw gt mx la my mz aw na bi"><span id="3f87" class="nb lc in la b gy nc nd l ne nf">{<br/>	"element": 5,<br/>	"file": &lt;chunk-file&gt;<br/>}<!-- --> </span></pre><ul class=""><li id="709e" class="lz ma in kb b kc kd kg kh kk mq ko mr ks ms kw mp mh mi mj bi translated">现在，将所有的<code class="fe kx ky kz la b">m</code> <code class="fe kx ky kz la b">HeapNode</code> (s)存储在一个 Min 堆中，其中顶部节点总是堆中的最小元素:</li></ul><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ng"><img src="../Images/b7b684270e032ef096a8f004ab29f7b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*29RnXM2Ql0TPNx226CpbaA.png"/></div></div></figure><ul class=""><li id="dc25" class="lz ma in kb b kc kd kg kh kk mq ko mr ks ms kw mp mh mi mj bi translated">执行<code class="fe kx ky kz la b">heapify</code>操作→将元素存储在输出文件中→用拥有 min 元素的卡盘文件中的下一个元素替换 min 元素</li><li id="dafa" class="lz ma in kb b kc mk kg ml kk mm ko mn ks mo kw mp mh mi mj bi translated">在最小堆<code class="fe kx ky kz la b">1</code>中选择最小元素，并将其写入输出文件<code class="fe kx ky kz la b">1</code></li><li id="cce2" class="lz ma in kb b kc mk kg ml kk mm ko mn ks mo kw mp mh mi mj bi translated">在块文件中找到下一个元素，它拥有 min 元素<code class="fe kx ky kz la b">1</code></li><li id="374a" class="lz ma in kb b kc mk kg ml kk mm ko mn ks mo kw mp mh mi mj bi translated">从<code class="fe kx ky kz la b">Chunk 3</code>开始编号<code class="fe kx ky kz la b">7</code>；将其移动到堆中并执行<code class="fe kx ky kz la b">heapify</code></li></ul><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nh"><img src="../Images/2c9e36ce798f7eef3ddd9d218d219091.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ArdiHzOa6PTBQA2ltqw79Q.png"/></div></div></figure><ul class=""><li id="a4c0" class="lz ma in kb b kc kd kg kh kk mq ko mr ks ms kw mp mh mi mj bi translated">选择最小元素<code class="fe kx ky kz la b">2</code>并将其附加到输出文件<code class="fe kx ky kz la b">1, 2</code></li><li id="fd4f" class="lz ma in kb b kc mk kg ml kk mm ko mn ks mo kw mp mh mi mj bi translated">找到块文件中的下一个元素，它拥有 min 元素<code class="fe kx ky kz la b">2</code></li><li id="b1ee" class="lz ma in kb b kc mk kg ml kk mm ko mn ks mo kw mp mh mi mj bi translated">编号<code class="fe kx ky kz la b">10</code>来自<code class="fe kx ky kz la b">Chunk 5</code>；将其移动到堆中并执行<code class="fe kx ky kz la b">heapify</code></li></ul><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/a51d31c0e34441449705532677775c5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aSwBphy2N82j2ARVCjWUDA.png"/></div></div></figure><ul class=""><li id="9474" class="lz ma in kb b kc kd kg kh kk mq ko mr ks ms kw mp mh mi mj bi translated">选择最小元素<code class="fe kx ky kz la b">3</code>并将其附加到输出文件<code class="fe kx ky kz la b">1, 2, 3</code></li><li id="28b8" class="lz ma in kb b kc mk kg ml kk mm ko mn ks mo kw mp mh mi mj bi translated">找到块文件中的下一个元素，它拥有 min 元素<code class="fe kx ky kz la b">3</code></li><li id="0497" class="lz ma in kb b kc mk kg ml kk mm ko mn ks mo kw mp mh mi mj bi translated">从<code class="fe kx ky kz la b">Chunk 2</code>开始编号<code class="fe kx ky kz la b">6</code>；将它移到堆中并执行<code class="fe kx ky kz la b">heapify</code></li></ul><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nj"><img src="../Images/64e0aae13b1ea9e56bd82670edc83863.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v8T471ZqxFUGJfeX0Ojkmw.png"/></div></div></figure><ul class=""><li id="e0c5" class="lz ma in kb b kc kd kg kh kk mq ko mr ks ms kw mp mh mi mj bi translated">选择最小元素<code class="fe kx ky kz la b">4</code>并将其添加到输出文件<code class="fe kx ky kz la b">1, 2, 3, 4</code></li><li id="b930" class="lz ma in kb b kc mk kg ml kk mm ko mn ks mo kw mp mh mi mj bi translated">找到块文件中的下一个元素，它拥有 min 元素<code class="fe kx ky kz la b">4</code></li><li id="bea7" class="lz ma in kb b kc mk kg ml kk mm ko mn ks mo kw mp mh mi mj bi translated">从<code class="fe kx ky kz la b">Chunk 4</code>开始编号<code class="fe kx ky kz la b">9</code>；将其移动到堆中并执行<code class="fe kx ky kz la b">heapify</code></li></ul><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/3dddbc9ef949075e72e597941c80b09a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fWw1Jp23bMcI-iR_MWPj3g.png"/></div></div></figure><ul class=""><li id="0d48" class="lz ma in kb b kc kd kg kh kk mq ko mr ks ms kw mp mh mi mj bi translated">选择最小元素<code class="fe kx ky kz la b">5</code>并将其附加到输出文件<code class="fe kx ky kz la b">1, 2, 3, 4, 5</code></li><li id="8a62" class="lz ma in kb b kc mk kg ml kk mm ko mn ks mo kw mp mh mi mj bi translated">找到块文件中的下一个元素，它拥有 min 元素<code class="fe kx ky kz la b">5</code></li><li id="a3aa" class="lz ma in kb b kc mk kg ml kk mm ko mn ks mo kw mp mh mi mj bi translated">从<code class="fe kx ky kz la b">Chunk 1</code>开始编号<code class="fe kx ky kz la b">8</code>；将其移动到堆中并执行<code class="fe kx ky kz la b">heapify</code></li></ul><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ng"><img src="../Images/e14c737947d219cb57017786d60db2c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xxUVcAoN89mmt1d5p1oLrg.png"/></div></div></figure><ul class=""><li id="c00c" class="lz ma in kb b kc kd kg kh kk mq ko mr ks ms kw mp mh mi mj bi translated">如果块文件中的下一个元素小于当前的 min 元素，则替换<code class="fe kx ky kz la b">MAX_INTEGER</code>中的 min 元素，并重复该过程，直到堆中的所有元素都是<code class="fe kx ky kz la b">MAX_INTEGER</code></li><li id="eddc" class="lz ma in kb b kc mk kg ml kk mm ko mn ks mo kw mp mh mi mj bi translated">选择最小元素<code class="fe kx ky kz la b">6</code>并将其附加到输出文件<code class="fe kx ky kz la b">1, 2, 3, 4, 5, 6</code></li><li id="9ae7" class="lz ma in kb b kc mk kg ml kk mm ko mn ks mo kw mp mh mi mj bi translated">找到块文件中的下一个元素，它拥有 min 元素<code class="fe kx ky kz la b">6</code></li><li id="8226" class="lz ma in kb b kc mk kg ml kk mm ko mn ks mo kw mp mh mi mj bi translated">看到<code class="fe kx ky kz la b">EOF (End of Line)</code>就换成<code class="fe kx ky kz la b">MAX_INTEGER</code></li></ul><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nl"><img src="../Images/4b980848b515a52bb553dbb70074cc75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jXvjg_Gua_p5bJjWLXmJzQ.png"/></div></div></figure><ul class=""><li id="f5e0" class="lz ma in kb b kc kd kg kh kk mq ko mr ks ms kw mp mh mi mj bi translated">继续操作，直到堆看起来像这样:</li></ul><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nm"><img src="../Images/0330227d83aca6122c84087473eb0b5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J41fWa1fpIQF5yhf2uyYMw.png"/></div></div></figure><p id="bf1d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">最终输出:<code class="fe kx ky kz la b">1, 2, 3, 4, 5, 6, 7, 8, 9, 10</code>😎</p><p id="d971" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">既然你已经来了，结帐吧🚀:<a class="ae nn" href="https://github.com/addu390/sorting-algorithms" rel="noopener ugc nofollow" target="_blank">https://github.com/addu390/sorting-algorithms</a>比较排序算法；下面是外部排序和内存合并排序的比较。</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi no"><img src="../Images/3234d9b87966088f0071bcf9d5b69f68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vaoyQkf_nQCoPBa_.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">对于 2 的幂</figcaption></figure><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi no"><img src="../Images/fdc1835e07a4f82e566ca142a40154ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*p_zLQrM_YlGJYKHV.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">对于 10 的幂</figcaption></figure></div></div>    
</body>
</html>