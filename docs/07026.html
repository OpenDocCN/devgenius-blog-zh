<html>
<head>
<title>Stockpile — Store Request and Response</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">库存——商店请求和响应</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/stockpile-store-request-and-response-8075a3e02515?source=collection_archive---------18-----------------------#2022-02-19">https://blog.devgenius.io/stockpile-store-request-and-response-8075a3e02515?source=collection_archive---------18-----------------------#2022-02-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/775eafadf422866fa43783fc3357dea0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_iigHJkapI6rx5TXz9-Mrw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">一件——什么？你不用股票堆？</figcaption></figure><p id="3e7a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">对于大多数应用程序来说，存储 API 的请求和响应非常重要，尤其是在与外部服务提供者集成时。<br/>记录这些信息可以解决大多数用例，但是当请求/响应包含敏感信息时可能就不行了。</p><p id="fd07" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在这种情况下，一种方法是加密并存储请求和响应；这正是我们在这篇文章中要做的。</p><p id="7146" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">概述:<br/> 1。其请求和响应将被存储的方法/命令被标注为<code class="fe kx ky kz la b">@StockPile</code> <br/> 2。要存储的方法的参数用<code class="fe kx ky kz la b">@Item</code>标注。<br/> 3。方法拦截器来加密和存储这些方法的请求、响应/异常。</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="5421" class="lj lk in la b gy ll lm l ln lo">@Retention(RetentionPolicy.RUNTIME)<br/>@Target({METHOD})<br/>@BindingAnnotation<br/>public @interface StockPile {<br/>}</span></pre><p id="90b0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe kx ky kz la b">@StockPile</code>注释仅针对方法，<code class="fe kx ky kz la b">@Target</code> —方法</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="9aaa" class="lj lk in la b gy ll lm l ln lo">@Retention(RetentionPolicy.RUNTIME)<br/>@Target({FIELD, PARAMETER})<br/>@BindingAnnotation<br/>public @interface Item {<br/>}</span></pre><p id="e5f0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe kx ky kz la b">@Item</code>表示方法的参数，<code class="fe kx ky kz la b">@Target</code> —参数</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="b387" class="lj lk in la b gy ll lm l ln lo">@Slf4j<br/>public class StockPileModule extends AbstractModule {</span><span id="3888" class="lj lk in la b gy lp lm l ln lo">    @Override<br/>    protected void configure() {<br/>        final StockPileInterceptor stockPileInterceptor = new StockPileInterceptor();<br/>        requestInjection(stockPileInterceptor);<br/>        bindInterceptor(Matchers.any(), Matchers.annotatedWith(StockPile.class), stockPileInterceptor);<br/>    }</span><span id="75a8" class="lj lk in la b gy lp lm l ln lo">    @VisibleForTesting<br/>    public static class StockPileInterceptor implements MethodInterceptor {</span><span id="80b8" class="lj lk in la b gy lp lm l ln lo">        @VisibleForTesting<br/>        @Inject<br/>        protected YourEncryptionService encryptionService;</span><span id="798d" class="lj lk in la b gy lp lm l ln lo">        @VisibleForTesting<br/>        @Inject<br/>        protected YourStorageService storageDao;</span><span id="ddd2" class="lj lk in la b gy lp lm l ln lo">        @VisibleForTesting<br/>        @Inject<br/>        protected ObjectMapper objectMapper;</span><span id="74b8" class="lj lk in la b gy lp lm l ln lo">        @Override<br/>        public Object invoke(MethodInvocation invocation) throws Throwable {<br/>            final Optional&lt;Annotation&gt; optionalAnnotation = Stream.of(invocation.getMethod().getDeclaredAnnotations())<br/>                    .filter(annotation -&gt; annotation instanceof StockPile)<br/>                    .findFirst();</span><span id="b10d" class="lj lk in la b gy lp lm l ln lo">            if (optionalAnnotation.isPresent()) {<br/>                List&lt;Object&gt; requests = new ArrayList&lt;&gt;();<br/>                final String methodName = invocation.getMethod().getName();<br/>                final Annotation[][] parameterAnnotations = invocation.getMethod().getParameterAnnotations();</span><span id="972b" class="lj lk in la b gy lp lm l ln lo">                for (int index = 0; index &lt; parameterAnnotations.length; ++index) {<br/>                    for (final Annotation annotation : parameterAnnotations[index]) {<br/>                        if (annotation instanceof Item) {<br/>                            requests.add(invocation.getArguments()[index]);<br/>                        }<br/>                    }<br/>                }<br/>                final Object response;<br/>                try {<br/>                    response = invocation.proceed();<br/>                    storageDao.save(requests, response, methodName);<br/>                } catch (Exception e) {<br/>                    storageDao.save(requests, e, methodName);<br/>                    throw e;<br/>                }<br/>                return response;<br/>            }<br/>            return invocation.proceed();<br/>        }<br/>    }   <br/>}</span></pre><p id="cff9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这篇文章的范围是概括请求和响应的存储。由开发人员决定存储这些 blobs 的加密和数据存储类型(NoSQL，如 AeroSpike 是一个不错的选择)。</p><p id="b619" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">正如在上面的方法拦截器中看到的，我们首先验证方法是否用<code class="fe kx ky kz la b">@StockPile</code>注释，然后所有用<code class="fe kx ky kz la b">@Item</code>注释的参数被添加到<code class="fe kx ky kz la b">List&lt;Object&gt;</code></p><p id="f48a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> storageDao.save </strong>带三个参数:<br/> 1。请求(<code class="fe kx ky kz la b">Object</code> ) <br/> 2。响应或异常(<code class="fe kx ky kz la b">Object</code> ) <br/> 3。方法名称(<code class="fe kx ky kz la b">String</code>)</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="1d75" class="lj lk in la b gy ll lm l ln lo">private void save(Object request, Object response, String commandName) {<br/>    try {<br/>        final String userId = MDC.get(RequestContext.REQUEST_USER_ID);<br/>        final String requestId = MDC.get(RequestContext.REQUEST_ID);<br/>        <br/>        final String workflowId = Objects.nonNull(REQUEST_USER_ID) ? userId.concat("_").concat(requestId) : userId;<br/>        final Date currentDate = new Date();</span><span id="07b4" class="lj lk in la b gy lp lm l ln lo">        Optional&lt;RequestResponseBlob&gt; requestResponseBlob = storageDao<br/>                .get(workflowId, commandName);</span><span id="48c8" class="lj lk in la b gy lp lm l ln lo">        final byte[] encryptedRequest = objectMapper.writeValueAsBytes(encryptionService.encrypt(request));<br/>        final byte[] encryptedResponse = objectMapper.writeValueAsBytes(encryptionService.encrypt(response));</span><span id="ceb0" class="lj lk in la b gy lp lm l ln lo">        if (storedOutboundMessage.isPresent()) {<br/>            RequestResponseBlob presentRequestResponse = requestResponseBlob.get();<br/>            presentRequestResponse.setRequest(encryptedRequest);<br/>            presentRequestResponse.setResponse(encryptedResponse);<br/>            presentRequestResponse.setUpdated(currentDate);<br/>            storageDao.update(presentRequestResponse);<br/>        } else {<br/>            storageDao.save(RequestResponseBlob.builder()<br/>                    .commandType(commandName)<br/>                    .workflowId(workflowId)<br/>                    .requestId(requestId)<br/>                    .request(encryptedRequest)<br/>                    .response(encryptedResponse)<br/>                    .created(currentDate)<br/>                    .updated(currentDate)<br/>                    .build());<br/>        }<br/>    } catch (Exception e) {<br/>        log.error("[STOCKPILE] Error while storing");<br/>    }<br/>}</span></pre><p id="9d7c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在<strong class="kb io"> MDC </strong>中存放<code class="fe kx ky kz la b">userId</code>和<code class="fe kx ky kz la b">requestId</code>参见<a class="ae lq" href="https://pyblog.medium.com/mdc-improving-debugging-logging-bb421a62a195" rel="noopener">前一岗位</a>。<br/>为了便于查询，使用<code class="fe kx ky kz la b">userId</code>、<code class="fe kx ky kz la b">requestId</code>和<strong class="kb io">方法名</strong>会比较理想，如上图所示。</p><p id="c800" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">用法:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="b7b9" class="lj lk in la b gy ll lm l ln lo">@StockPile<br/>public Response externalServiceCommandOne(@Item final SensitiveInformationRequest request, final String token) {<br/>  Response response;<br/>  // Stuff here<br/>  return response<br/>}</span></pre><p id="f397" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">就是这样！完成的🚀</p></div></div>    
</body>
</html>