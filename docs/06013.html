<html>
<head>
<title>Logging in Spring Boot Microservices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Boot 微服务中的测井</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/logging-in-spring-boot-microservices-bc4635fabe35?source=collection_archive---------0-----------------------#2021-12-05">https://blog.devgenius.io/logging-in-spring-boot-microservices-bc4635fabe35?source=collection_archive---------0-----------------------#2021-12-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="e5b3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">日志记录是企业应用程序的关键部分。日志记录不仅有助于调查问题，还有助于构建相关的指标。从业务角度来看，这些指标非常重要。事实上，企业使用这些标准来编写服务水平协议(SLA)。在本帖中，我们将讨论基于 Spring Boot 的微服务中的日志记录。</p><p id="6291" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你是 Spring Boot 和微服务的新手，我会推荐你阅读关于<a class="ae ki" href="https://betterjavacode.com/core-java/spring-boot-and-microservices" rel="noopener ugc nofollow" target="_blank"> Spring Boot 和微服务</a>。</p><h1 id="f4e4" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">我们为什么要记录，记录什么？</h1><p id="6f8d" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">生产级应用程序可能会因为各种原因而随时失败。对于开发人员来说，及时调查此类问题，让日志可用变得至关重要。日志是应用程序恢复的关键。</p><p id="e050" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">问题来了，我们记录什么？开发人员、软件架构师投入足够的时间来决定记录什么。不记录大量信息同样重要。你不想丢失关键信息。显然，人们不应该记录任何 PII(个人身份信息)。开发人员可以使用的范例是“如果应用程序失败，什么将帮助我调查代码中的问题？”。特别是，如果一个关键的业务决策需要在代码中进行注释，那么记录该决策也是一个同样可行的选择。</p><p id="e575" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">同时，可以使用日志中随机生成的跟踪 id 来跟踪请求-响应。更难的部分是在应用程序的整个生命周期中保持这种想法。</p><h1 id="7f07" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">记录和可观察性</h1><p id="c80b" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">微服务与外部 API、其他微服务进行通信。从今以后，记录这种交流的细节是很重要的。在<a class="ae ki" href="https://betterjavacode.com/programming/microservices-event-driven-architecture" rel="noopener ugc nofollow" target="_blank">事件驱动的微服务</a>中，人们可以记录事件的细节。借助云基础设施，记录微服务的详细信息变得更加容易。像 AWS 这样的云基础设施提供<a class="ae ki" href="https://aws.amazon.com/cloudwatch/" rel="noopener ugc nofollow" target="_blank"> CloudWatch </a>来收集这些日志，然后使用 ELK 栈来监控日志。然而，像 New Relic、Sumo Logic 这样的可观察性工具与不同的云基础设施相连接。它们收集日志，并提供显示、查询和基于日志构建指标的灵活性。</p><p id="bd06" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，开发人员有足够的工具来记录来自应用程序的数据，以提高可跟踪性和调试。</p><h1 id="69bd" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">基于 Spring Boot 微服务的日志记录</h1><p id="8f3b" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">让我们来看看 Spring Boot 微服务的日志记录。我们将创建一个简单的微服务，并展示我们可以使用哪种日志记录配置。</p><p id="0ea3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的主类如下所示:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="7f4f" class="lv kk in lr b gy lw lx l ly lz">package com.betterjavacode.loggingdemo;<br/><br/>import org.springframework.boot.SpringApplication;<br/>import org.springframework.boot.autoconfigure.SpringBootApplication;<br/><br/>@SpringBootApplication<br/>public class LoggingdemoApplication {<br/><br/>  public static void main(String[] args) {<br/>    SpringApplication.run(LoggingdemoApplication.class, args);<br/>  }<br/><br/>}</span></pre><p id="7f01" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">基本上微服务目前什么都没有。不管怎样，我们有一个主类，我们将看到日志是如何进入画面的。</p><p id="d019" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">作为应用程序的一部分，我包含了一个单独的依赖项</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="c3e9" class="lv kk in lr b gy lw lx l ly lz">implementation 'org.springframework.boot:spring-boot-starter-web'</span></pre><p id="4f44" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个依赖还包括<code class="fe ma mb mc lr b">spring-boot-starter-logging</code>。<code class="fe ma mb mc lr b">spring-boot-starter-logging</code>是 Spring Boot 提供的默认日志配置。我们会调查更多的细节。</p><h1 id="a991" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">默认日志记录配置</h1><p id="8a2c" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated"><code class="fe ma mb mc lr b">spring-boot-stater-logging</code>依赖包括<code class="fe ma mb mc lr b">slf4j</code>作为日志门面，<code class="fe ma mb mc lr b">logback</code>作为日志框架。</p><p id="d40c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ma mb mc lr b">SLF4J</code>是许多框架支持的日志门面。使用这个外观的好处是我们可以很容易地从一个框架切换到另一个框架。Logback 是任何 spring boot 应用程序中的默认框架，但是我们可以很容易地切换到 Log4j、Log4J2 或 Java Util 日志。</p><p id="9e25" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ma mb mc lr b">spring-boot-starter-logging</code>包括所需的桥，这些桥从其他依赖项获取日志并将它们委托给日志框架。</p><figure class="lm ln lo lp gt me gh gi paragraph-image"><div class="gh gi md"><img src="../Images/52cd566158d3c1229b85d60c01e61fe6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/0*NyPDbXT3FRwAkXdv"/></div></figure><h1 id="eaa4" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">回溯日志记录配置</h1><p id="8ca5" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">类似于我们添加的微服务和默认日志记录，我们将了解如何使用回退日志记录配置。如果我们不提供任何配置，spring boot 将使用<code class="fe ma mb mc lr b">logback</code>的默认配置。它会将日志附加到控制台，日志级别为<code class="fe ma mb mc lr b">info</code>。日志框架帮助我们将日志传播到不同的目标，如控制台、文件、数据库，甚至是<a class="ae ki" href="https://betterjavacode.com/kafka/using-apache-kafka-with-spring-boot" rel="noopener ugc nofollow" target="_blank"> Kafka </a>。</p><p id="a3e3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过配置文件(<code class="fe ma mb mc lr b">logback-spring.xml</code>)，我们还可以设置消息的模式。如果你想用<code class="fe ma mb mc lr b">log4j2</code>代替 logback，你可以阅读这篇关于<a class="ae ki" href="https://betterjavacode.com/java/error-handling-and-logging-in-spring-boot-rest-api-part-iii" rel="noopener ugc nofollow" target="_blank">日志和错误处理</a>的帖子。</p><p id="4b8b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以下配置文件显示了我们将如何记录日志:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="913d" class="lv kk in lr b gy lw lx l ly lz">&lt;configuration&gt;<br/>    &lt;property name="LOGDIRECTORY" value="./logs" /&gt;<br/>    &lt;appender name="Console" class="ch.qos.logback.core.ConsoleAppender"&gt;<br/>        &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt;<br/>            &lt;Pattern&gt;<br/>                %black(%d{ISO8601}) %highlight(%-5level) [%blue(%t)] %yellow(%C{1.}): %msg%n%throwable<br/>            &lt;/Pattern&gt;<br/>        &lt;/layout&gt;<br/>    &lt;/appender&gt;<br/>    &lt;appender name="RollingFile" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt;<br/>        &lt;file&gt;${LOGDIRECTORY}/microservice.log&lt;/file&gt;<br/>        &lt;encoder<br/>                class="ch.qos.logback.classic.encoder.PatternLayoutEncoder"&gt;<br/>            &lt;Pattern&gt;%d %p %C{1.} [%t] %m%n&lt;/Pattern&gt;<br/>        &lt;/encoder&gt;<br/><br/>        &lt;rollingPolicy<br/>                class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt;<br/>            &lt;fileNamePattern&gt;${LOGDIRECTORY}/archived/microservice-%d{yyyy-MM-dd}.%i.log<br/>            &lt;/fileNamePattern&gt;<br/>            &lt;timeBasedFileNamingAndTriggeringPolicy<br/>                    class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"&gt;<br/>                &lt;maxFileSize&gt;5MB&lt;/maxFileSize&gt;<br/>            &lt;/timeBasedFileNamingAndTriggeringPolicy&gt;<br/>        &lt;/rollingPolicy&gt;<br/>    &lt;/appender&gt;<br/>    &lt;root level="info"&gt;<br/>        &lt;appender-ref ref="RollingFile" /&gt;<br/>        &lt;appender-ref ref="Console" /&gt;<br/>    &lt;/root&gt;<br/><br/>    &lt;logger name="com.betterjavacode" level="debug" additivity="false"&gt;<br/>        &lt;appender-ref ref="RollingFile" /&gt;<br/>        &lt;appender-ref ref="Console" /&gt;<br/>    &lt;/logger&gt;<br/>&lt;/configuration&gt;</span></pre><p id="6a40" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将分析这个文件，以了解配置中的每一行是做什么的。</p><p id="7fd6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我们配置了一个属性<code class="fe ma mb mc lr b">LOGDIRECTORY</code>,指向机器上保存日志文件的物理目录。我们在<code class="fe ma mb mc lr b">appender</code>和<code class="fe ma mb mc lr b">rollingPolicy</code>中使用这个属性。</p><h1 id="1779" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">不同的日志选项</h1><p id="a43f" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">随后，我们使用 Logback 配置中的<code class="fe ma mb mc lr b">appender</code>来配置我们想要添加日志的位置。在这种情况下，我们已经为<code class="fe ma mb mc lr b">Console</code>和<code class="fe ma mb mc lr b">File</code>进行了配置。</p><p id="fb4c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于<code class="fe ma mb mc lr b">ConsoleAppnder</code>，我们使用的消息模式包括黑色的日期和时间，蓝色的日志级别，黄色的包。日志消息将采用默认颜色。</p><p id="bc60" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于<code class="fe ma mb mc lr b">RollingFileAppender</code>，我们有一行指示文件名和存储位置。在这种情况下，我们在<code class="fe ma mb mc lr b">LOGDIRECTORY</code>登录<code class="fe ma mb mc lr b">microservice.log</code>。下一行表示日志消息的模式。</p><p id="ceda" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此后，我们定义<code class="fe ma mb mc lr b">RollingPolicy</code>。我们希望确保不要将信息记录在单个文件中，这样文件的大小会不断增加。当日志文件达到 5 MB 时，我们触发转出日志文件，并将旧文件保存在归档目录中，文件名为<code class="fe ma mb mc lr b">microservice-date-number.log</code>。</p><p id="c990" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，我们将在下一节讨论日志级别。</p><h1 id="1e39" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">配置日志级别</h1><p id="91da" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">配置文件的最后一部分表示日志级别。在根级别，我们在<code class="fe ma mb mc lr b">INFO</code>级别记录一切。基本上，我们的应用程序将记录代码中使用<code class="fe ma mb mc lr b">INFO</code>日志级别编写的所有消息。</p><p id="cd3f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是下一个配置允许我们在包中设置日志级别。在从<code class="fe ma mb mc lr b">com.betterjavacode</code>开始的包中，记录所有在<code class="fe ma mb mc lr b">DEBUG</code>级别的消息。</p><h1 id="502b" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">执行 Spring Boot 应用程序</h1><p id="0172" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">现在，我们将看看这在我们的演示微服务中是如何实现的。</p><p id="0969" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我的应用程序中有一个简单的<code class="fe ma mb mc lr b">RestController</code>，它检索如下的<code class="fe ma mb mc lr b">company</code>信息:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="1bf0" class="lv kk in lr b gy lw lx l ly lz">package com.betterjavacode.loggingdemo.controller;<br/><br/>import org.slf4j.Logger;<br/>import org.slf4j.LoggerFactory;<br/>import org.springframework.web.bind.annotation.GetMapping;<br/>import org.springframework.web.bind.annotation.RequestMapping;<br/>import org.springframework.web.bind.annotation.RestController;<br/><br/>import java.util.ArrayList;<br/>import java.util.List;<br/><br/>@RestController<br/>@RequestMapping("/v1/companies")<br/>public class CompanyController<br/>{<br/>    private static final Logger LOGGER = LoggerFactory.getLogger(CompanyController.class);<br/>    @GetMapping<br/>    public List getAllCompanies()<br/>    {<br/>        LOGGER.debug("Getting all companies");<br/><br/>        List result = new ArrayList&lt;&gt;();<br/><br/>        result.add("Google");<br/>        result.add("Alphabet");<br/>        result.add("SpaceX");<br/><br/>        LOGGER.debug("Got all companies - ", result);<br/><br/>        return result;<br/>    }<br/>}</span></pre><p id="25fd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，如果执行我们的应用程序并访问 API <code class="fe ma mb mc lr b">http://localhost:8080/v1/companies/</code>，我们将获得公司列表，而且我们将能够在控制台上查看日志，如下所示:</p><figure class="lm ln lo lp gt me gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/c279d4818be216b874e366d58e67f773.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*Qdf9XScW32kxTQwr"/></div></figure><p id="75ef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">日志文件将如下所示:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="ea09" class="lv kk in lr b gy lw lx l ly lz">2021-12-04 18:20:32,221 INFO org.springframework.boot.StartupInfoLogger [main] Starting LoggingdemoApplication using Java 1.8.0_212 on YMALI2019 with PID 3560<br/>2021-12-04 18:20:32,223 DEBUG org.springframework.boot.StartupInfoLogger [main] Running with Spring Boot v2.6.0, Spring v5.3.13<br/>2021-12-04 18:20:32,224 INFO org.springframework.boot.SpringApplication [main] No active profile set, falling back to default profiles: default<br/>2021-12-04 18:20:33,789 INFO org.springframework.boot.web.embedded.tomcat.TomcatWebServer [main] Tomcat initialized with port(s): 8080 (http)<br/>2021-12-04 18:20:33,798 INFO org.apache.juli.logging.DirectJDKLog [main] Initializing ProtocolHandler ["http-nio-8080"]<br/>2021-12-04 18:20:33,799 INFO org.apache.juli.logging.DirectJDKLog [main] Starting service [Tomcat]<br/>2021-12-04 18:20:33,799 INFO org.apache.juli.logging.DirectJDKLog [main] Starting Servlet engine: [Apache Tomcat/9.0.55]<br/>2021-12-04 18:20:33,875 INFO org.apache.juli.logging.DirectJDKLog [main] Initializing Spring embedded WebApplicationContext<br/>2021-12-04 18:20:33,875 INFO org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext [main] Root WebApplicationContext: initialization completed in 1580 ms<br/>2021-12-04 18:20:34,212 INFO org.apache.juli.logging.DirectJDKLog [main] Starting ProtocolHandler ["http-nio-8080"]<br/>2021-12-04 18:20:34,230 INFO org.springframework.boot.web.embedded.tomcat.TomcatWebServer [main] Tomcat started on port(s): 8080 (http) with context path ''<br/>2021-12-04 18:20:34,239 INFO org.springframework.boot.StartupInfoLogger [main] Started LoggingdemoApplication in 2.564 seconds (JVM running for 3.039)<br/>2021-12-04 18:20:34,242 INFO com.betterjavacode.loggingdemo.LoggingdemoApplication [main] After starting the application.........<br/>2021-12-04 18:20:39,526 INFO org.apache.juli.logging.DirectJDKLog [http-nio-8080-exec-1] Initializing Spring DispatcherServlet 'dispatcherServlet'<br/>2021-12-04 18:20:39,526 INFO org.springframework.web.servlet.FrameworkServlet [http-nio-8080-exec-1] Initializing Servlet 'dispatcherServlet'<br/>2021-12-04 18:20:39,527 INFO org.springframework.web.servlet.FrameworkServlet [http-nio-8080-exec-1] Completed initialization in 0 ms<br/>2021-12-04 18:20:39,551 DEBUG com.betterjavacode.loggingdemo.controller.CompanyController [http-nio-8080-exec-1] Getting all companies<br/>2021-12-04 18:20:39,551 DEBUG com.betterjavacode.loggingdemo.controller.CompanyController [http-nio-8080-exec-1] Got all companies - [Google, Alphabet, SpaceX]</span></pre><h1 id="08a9" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">追踪请求</h1><p id="cfe8" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">之前，我说过我们为什么要记录。当有多个微服务并且每个微服务都与其他和外部 API 通信时，有一种方法来跟踪请求是很重要的。方法之一是在<code class="fe ma mb mc lr b">logback-spring.xml</code>中配置一个图案。</p><p id="8161" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一种选择是使用<code class="fe ma mb mc lr b">Filter</code>和<a class="ae ki" href="https://logback.qos.ch/manual/mdc.html" rel="noopener ugc nofollow" target="_blank"> MDC(映射诊断上下文)</a>。基本上，每个传入 API 的请求都会被过滤器拦截。在 Filter 中，您可以向 MDC 映射添加一个惟一的 id。使用使用 MDC 映射中的键的日志记录模式。这样，您的请求将有跟踪信息。需要记住的一点是，一旦 API 响应了客户端，就要从 MDC 中清除上下文。</p><h1 id="43f5" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">配置用于监控的日志</h1><p id="bf14" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">在企业中，配置日志的一种方式是将日志存储在文件中，并将这些文件存放在云服务器上的一个中心位置。AWS 提供了更简单的灵活性，可以从存储 S3 的云观察中提取这些信息，然后用户可以使用 Kibana 和 Elastic search 等工具来监控日志和指标。</p><h1 id="53e7" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">结论</h1><p id="c1fe" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">在这篇文章中，我们详细介绍了如何在基于 spring boot 的微服务中使用日志记录。我们还讨论了在 Spring Boot 应用程序中使用 Logback 框架时可以使用的<code class="fe ma mb mc lr b">Logback</code>配置。</p><p id="262d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这些实践中的大多数都是标准的，如果遵循得当，可以确保在生产环境中对应用程序进行故障排除和监控。</p></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><p id="7fd2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mp">原载于 2021 年 12 月 5 日【https://betterjavacode.com】<a class="ae ki" href="https://betterjavacode.com/programming/logging-in-spring-boot-microservices" rel="noopener ugc nofollow" target="_blank"><em class="mp"/></a><em class="mp">。</em></em></p></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><p id="d84c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mp">更多内容尽在</em><a class="ae ki" href="http://blog.devgenius.io" rel="noopener ugc nofollow" target="_blank"><em class="mp">blog . dev genius . io</em></a><em class="mp">。</em></p></div></div>    
</body>
</html>