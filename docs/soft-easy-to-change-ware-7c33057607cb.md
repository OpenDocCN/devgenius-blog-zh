# 软件(易于更换)

> 原文：<https://blog.devgenius.io/soft-easy-to-change-ware-7c33057607cb?source=collection_archive---------6----------------------->

软件相对于硬件的一个更重要的特征是想法很容易改变。为什么我们会忘记这一点？

![](img/d86816ffd77eaeba32ce4fa26f2c057e.png)

> 在计算机科学中，一台**通用图灵机** ( **UTM** )就是一台[图灵机](https://en.wikipedia.org/wiki/Turing_machine)，在任意输入上模拟一台任意图灵机。通用机器基本上通过读取待模拟机器的描述以及从其自身的磁带到该机器的输入来实现这一点。艾伦·图灵在 1936-1937 年提出了这种机器的想法。这个原理被认为是 1946 年约翰·冯·诺依曼用于“电子计算仪器”的存储程序计算机的想法的起源，该“电子计算仪器”现在以冯·诺依曼的名字命名:冯·诺依曼架构。
> [https://en.wikipedia.org/wiki/Universal_Turing_machine](https://en.wikipedia.org/wiki/Universal_Turing_machine)

事实上，今天的任何一台计算机都是通用的图灵机。这意味着我们可以创建任何图灵机，并在我们的计算机内运行它。
[图灵完备性](https://en.wikipedia.org/wiki/Turing_completeness)是指令系统模拟图灵机的能力。图灵完备的编程语言理论上能够表达所有计算机可以完成的任务；如果忽略有限内存的限制，几乎所有的编程语言都是图灵完全的。

但是，为什么我们要在创建运行在计算机内部的软件和创建一个只解决一次问题的物理产品之间做出选择呢？

## 计算器示例

每个人都有一个物理计算器，它们只是解决算术问题的机器。电脑和手机里都有计算器，但实际上还是有用的，它们简单又便宜。

因此，拥有一台可以运行任何图灵机的机器并不足以决定创建软件来解决一个问题。在决定创建软件产品时，需要考虑更多的属性。

其中一个特性是软件给了我们一种非凡的力量。使用相同的硬件，我们可以为我们的产品增加更多的功能。我们可以通过修改代码来改变我们的产品。
但这需要是一种经济上的进步，软件的改变需要比硬件的创造更容易、更便宜。这给我带来了一个问题，如果我们的软件很难改变，我们真的需要软件吗？。

## “容易改变”是什么意思？

当我们谈论容易改变时，有不同的层次，在我看来第一个是关于代码，一些问题:

*   我们能理解代码吗？
*   我们能快速地给代码添加功能吗？
*   我们能保留以前的功能吗？

[交付时间和变更失败率](https://www.thoughtworks.com/en-es/radar/techniques/four-key-metrics)可以帮助我们衡量我们在编码水平上有多好。
事实上，与我们的代码相关的大多数问题都是关于我们记住它所具有的问题的局限性。
想象一个布满地雷的战场，当你只有一个人，并且只有一个地雷时，你能记住它。但是当战场上有成千上万的地雷时，即使你把地雷放在那里，你也不会记得地雷在哪里。因此，如果你试图在某个时候放置更多的地雷，你会迈出第一步。
我们考虑多个方面的能力有限，我们的认知负荷有限。这是一个很好的[资源](https://github.com/TeamTopologies/Team-Cognitive-Load-Assessment)来衡量来自 **Matthew Skelton** ( [团队拓扑](https://teamtopologies.com/) ) **的团队。**

因此，我们最好的选择是减少代码中的认知负荷(减少意外的复杂性)，一些原则会有所帮助:

*   小通常比大更简单。拥有小的方法/函数/类/模块会使它们更容易理解。要记住的东西更少。
*   低耦合——我们系统的一个单元与我们系统的其他单元的关联程度。例如，如果一个类使用另一个类，那么这个类就是与另一个类耦合的。两个耦合度很高的类往往会一起更改，这使得更改我们的代码变得更加困难。
*   高内聚——一个单元、模块或类与正在使用的数据的相关程度。例如，在一个有三个属性的类中，如果大多数方法只使用两个属性，并且只有一个方法使用另一个属性，那么这个信息和这个方法可能与这个类无关，这就是一个低内聚的例子。低内聚通常与高耦合有关我们的类包含一些与其无关的职责，我们需要记住这个类。
*   测试将帮助我们确定我们保留了以前的功能。但是测试就像胶水一样，他们强迫被测试的单元维护他们的 API。你的[测试](/unit-tests-c70618dc1e25?sk=de16c7a7bec6fa068728441e55365c97)需要给开发者重构的自由，否则我们的测试将限制我们重构(改变)的能力。
    [如何编写测试？。](/how-do-i-write-tests-17640185171c?sk=ce13d0bcefc8fc6d34a97acadb4b308a)
*   重构:在计算机编程和软件设计中，**代码重构**是在不改变其外部行为的情况下，重构现有计算机代码——改变*因子*的过程。
*   很多设计原则，其中一些在另一篇[文章](/software-design-principles-ccc3913bfd56?sk=072f3a4d996bfd3106e1583f8f667fa8)中。

但正如我们之前所说，软件需要快速更新，所以我们也需要在其他层面衡量其他东西。

## 团队级别

除了小型创业公司，人们倾向于在某种共享的开发者社区中从事软件工作。我们通常将这些社区组织成小规模的团队。我们通常这样做，因为团队[比个人单独完成更多的事情。](/software-teams-karate-421ff1ce5425?sk=35ae3ddbd707d5d86d681e1d8a08524b)

在某种意义上，将新代码投入生产的难易程度取决于我们在团队中开发的过程和实践。
为什么我们每 6 个月部署一次生产，这是因为我们试图解决的问题太难了，在那段时间里什么也看不出来，还是因为我们在流程中增加了太多的意外复杂性[以至于不可能更快。](https://medium.com/@markharun/no-silver-bullet-essence-and-accident-in-software-engineering-fred-brooks-1986-41172655e62c)

测量[部署频率](https://www.thoughtworks.com/en-es/radar/techniques/four-key-metrics)在这里也可以帮助我们，但是向我们的客户端部署垃圾是没有价值的。我们需要很好地意识到我们在系统中引入了一个 bug，这样我们就可以尽快解决它，[时间将系统恢复到](https://www.thoughtworks.com/en-es/radar/techniques/four-key-metrics)以前的工作状态是关键。
这两个指标与团队组织我们工作的能力以及部署到 prod 的难易程度有关。

[DevOps](https://en.wikipedia.org/wiki/DevOps) (DevOps 本身不是一个团队)是简化生产的路径，消除瓶颈，专注于开发团队中有价值的东西的想法。浪费时间通常是团队或组织内部各自为政的结果。
以我的经验来看，召开会议讨论并改进我们的生产方式是关键:

> 一条**生产路径映射了软件请求/变更到达生产的步骤、人员、工具、任务和输出**。https://www.caroli.org/en/path-to-production/
> T3

## 组织层面

让团队致力于改善/简化他们的生产路径的想法有很大的含义([你建立它，你运行它](https://techbeacon.com/enterprise-it/how-embrace-you-build-it-you-run-it)):

*   团队需要自主权
*   团队需要责任
    如何创造可观察的产品？
    观察什么？当问题出现时，如何工作？

这些需求有自己的权衡，我们需要理解和处理。自治是重量级治理的对立面，所以我们需要找到轻量级的治理模型。责任是团队需要学习的东西，你不能把责任推给一个独立的团队。拥有一个独立的 QA 部门，或者一个负责质量或部署的 DevOps 团队似乎不是一个好主意。

总的来说，让我们的软件(我们的产品)变得容易是一个有意识的决定，因为系统的[熵总是随着时间的推移而增加](/evolutionary-design-cfb1795e8f81)所以自然会发生混乱。我们需要在我们的组织中工作，牢记我们的产品是软件产品，需要易于更改。