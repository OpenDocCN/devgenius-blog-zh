# 单例模式变得简单

> 原文：<https://blog.devgenius.io/singleton-pattern-made-easy-ab47115570f3?source=collection_archive---------22----------------------->

![](img/fecd5598e520d78c6d2a08c364abb6b2.png)

上图中，只有一个发光的灯泡，如果有人想要一些光，他们会一直用同一个灯泡，就是发光的。

*但是为什么每个人都选择同样的灯泡呢？*

**因为这是获得发光灯泡最快的方法。毕竟对于其他灯泡，我们需要先照亮它。因此，选择发光灯泡是最有效的方法。**

**从上图可以推断出一个更重要的观察结果:** *当我说每个人都会选择相同的发光灯泡时，我是在考虑他们只有上图所示的选项。表示在给定的范围内，一个发光的灯泡是* ***中的一个。***

上面的解释可能已经给出了 Singleton 的一般概念。

**根据定义，** *Singleton 的意思是* ***在给定的范围内同类中的一个。***

在看任何实际的代码之前，让我们试着看更多的例子来更好地理解 Singleton。

# 更多的例子

*   你不会每次想看《网飞》的时候都买新电视。你可以用你客厅里已经有的那个。
*   你不会每天晚上从办公室回来就买或租一个新家。你将去一个你已经拥有或租用的地方。
*   你不会每次想去某个地方的时候都买新车。

# 技术实现

在知道如何实施之前，我们应该知道什么时候实施，为什么实施。

## 什么时候？

如果您的场景需要某个对象的单个实例，那么您可以选择单例模式。

*   *测井*
*   *数据库*
*   *缓存*

## 为什么？

*   因为在 JVM (Java 虚拟机)中只有一个对象的实例，所以它提供了对内存的有效使用。
*   它提供了对对象的快速访问，因为你不会在每次需要的时候构造一个新的对象。

## 怎么会？

1.  创建私有构造函数— *这避免了类的实例化。*
2.  创建同一个类的私有静态变量— *这确保了只有一个实例可用。*
3.  创建一个全局访问点— *以允许访问上面提到的私有静态变量。*

## 示例代码

## 骗局

*   单元测试很难— *单例类与客户端类紧密耦合，所以我们不可避免地要测试单例类以及客户端类。*
*   在多线程环境中需要额外的实现— *不同的线程可能有相同单例类的不同实例，这将导致不一致。一些额外的努力可以避免这个 con.* ***(通过使用 synchronized 关键字，或者通过 Bill Pugh Singleton 实现)***

*   紧密耦合— *因为不能创建新的实例，我们不能在客户端类中注入它。*
*   反射攻击— *私有构造函数确保单个实例，但是使用反射技术，访问修饰符可以从私有更新为公共。这个骗局可以通过一些额外的努力来避免。这个问题的解决方案将在以后的博客中讨论。*

如果这篇博客有助于你理解单体设计模式，请给我一个掌声。🙂

关注我获取更多此类内容。

非常感谢任何评论和反馈。

编码快乐！！。🙂