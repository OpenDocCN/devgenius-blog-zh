<html>
<head>
<title>String Matching — KMP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">字符串匹配— KMP</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/string-matching-kmp-ccad1ffbeb11?source=collection_archive---------11-----------------------#2022-06-26">https://blog.devgenius.io/string-matching-kmp-ccad1ffbeb11?source=collection_archive---------11-----------------------#2022-06-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/25816a2c6adfb5143597e5cc09df4ffe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eKSgXCeDjIGpkacGFfGzqw.jpeg"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated"><a class="ae ja" href="https://unsplash.com/@kieran_wood?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">基兰伍德</a>在<a class="ae ja" href="https://unsplash.com/s/photos/puzzle?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><div class=""/><p id="813f" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Knuth Morris &amp; Pratt 算法。</p><p id="5ff0" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在一种简单的字符串匹配方法中，每当我们遇到模式和目标字符串之间的不匹配时，我们只在目标中向前移动一步，并从头开始匹配整个模式。部分匹配会导致额外的计算时间。通过使用 LPS 表可以跳过那些部分匹配，从而避免在寻找部分匹配时不必要的旧比较，这是该算法的主要思想。在了解 LPS 表之前，让我们先了解一些术语。</p><p id="67db" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc je">前缀</strong>:一个字符串中的所有字符，以一个或多个结尾截断。<code class="fe ky kz la lb b">a, ab, abc, abcd</code>是<code class="fe ky kz la lb b">abcdabd</code>的前缀。</p><p id="5f25" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc je">后缀</strong>:一个字符串中的所有字符，有一个或多个，在开头截断。<code class="fe ky kz la lb b">dabd, abd, bd</code>是<code class="fe ky kz la lb b">abcdabd</code>的后缀。</p><figure class="ld le lf lg gt ip gh gi paragraph-image"><div class="gh gi lc"><img src="../Images/f1bdb69ad80c58723eb74a793b616913.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*ON8-gCT-arjebC4gf7tLTg.png"/></div></figure><h2 id="a457" class="lh li jd bd lj lk ll dn lm ln lo dp lp kl lq lr ls kp lt lu lv kt lw lx ly lz bi translated">LPS 表</h2><p id="cfef" class="pw-post-body-paragraph ka kb jd kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">在 KMP 算法中，我们准备了一个表，叫做 LPS 表。在<strong class="kc je"> LPS 表</strong>中，我们将模式的每个字符映射到一个值。映射到每个字符的值，即 LPS[i]代表最长固有前缀的长度，该前缀也是第一个<code class="fe ky kz la lb b">i</code>字符中的后缀，其中<code class="fe ky kz la lb b">0&lt;i&lt;len(pattern)-1</code>。</p><ul class=""><li id="682d" class="mf mg jd kc b kd ke kh ki kl mh kp mi kt mj kx mk ml mm mn bi translated"><strong class="kc je">步骤 1 — </strong>定义一个大小等于模式长度的列表。</li><li id="725c" class="mf mg jd kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated"><strong class="kc je">第二步— </strong>定义变量<strong class="kc je"> i &amp; j </strong>。设置 i = 0，j = 1，LPS[0] = 0。</li><li id="5c06" class="mf mg jd kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated"><strong class="kc je">步骤 3 — </strong>比较<strong class="kc je">图案【I】</strong>和<strong class="kc je">图案【j】处的字符。</strong></li><li id="d517" class="mf mg jd kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated"><strong class="kc je">步骤 4 — </strong>如果两者匹配，则设置<code class="fe ky kz la lb b">LPS[j] = i+1</code>并将两个 i &amp; j 值增加 1。转到步骤 3。</li><li id="73ad" class="mf mg jd kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated"><strong class="kc je">步骤 5 — </strong>如果两者都不匹配，则检查变量<code class="fe ky kz la lb b">i</code>的值。如果是<code class="fe ky kz la lb b">0</code>，则设置<strong class="kc je"> LPS[j] = 0 </strong>，并将<code class="fe ky kz la lb b">j</code>值增加 1，如果不是<code class="fe ky kz la lb b">0</code>，则设置<strong class="kc je"> i = LPS[i-1] </strong>。</li><li id="f5bf" class="mf mg jd kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated"><strong class="kc je">步骤 6- </strong>重复上述步骤，直到 LPS[]的所有值都被填充。</li></ul><figure class="ld le lf lg gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mt"><img src="../Images/1117957b94ed4baa2513620784893a2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t59TpOvbLNajgjQueQN5UA.png"/></div></div></figure><pre class="ld le lf lg gt mu lb mv mw aw mx bi"><span id="eb10" class="lh li jd lb b gy my mz l na nb">def compute_lps(pattern):<br/>    lps = [0] * len(pattern)<br/>    prefix = 0<br/>    for i in range(1, len(pattern)):<br/>        while prefix and pattern[i] != pattern[prefix]:<br/>            prefix = lps[prefix - 1]<br/>        if pattern[prefix] == pattern[i]:<br/>            prefix += 1<br/>            lps[i] = prefix<br/>    return lps</span><span id="245c" class="lh li jd lb b gy nc mz l na nb">pattern = 'abcdabd'    <br/>print(compute_lps(pattern))</span></pre><figure class="ld le lf lg gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nd"><img src="../Images/a86b5bb6525db8af86651fa52534f8d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SWjSfa1ybNQ0ntKZitQiDg.png"/></div></div></figure><h2 id="237b" class="lh li jd bd lj lk ll dn lm ln lo dp lp kl lq lr ls kp lt lu lv kt lw lx ly lz bi translated">LPS 表的搜索/使用</h2><p id="7176" class="pw-post-body-paragraph ka kb jd kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">在 KMP，当我们遇到不匹配时，KMP 不是在目标文本中向前移动一个符号并从模式字符串的最开始处开始，而是使用 LPS 从发生不匹配的完全相同的地方继续。</p><p id="64a3" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当出现不匹配时，我们使用 LPS 表来决定跳过多少字符进行比较。<br/>当出现不匹配时，检查模式中不匹配字符的前一个字符的 LPS 值。如果是<code class="fe ky kz la lb b">0</code>，那么开始比较模式的第一个字符和文本中不匹配字符的下一个字符。如果不是<code class="fe ky kz la lb b">0</code>，则开始将索引值等于前一个字符的 LPS 值的字符与模式中的不匹配字符和文本中的不匹配字符进行比较。</p><pre class="ld le lf lg gt mu lb mv mw aw mx bi"><span id="8c6e" class="lh li jd lb b gy my mz l na nb">def kmp(pattern, text):<br/>    match_indices = []<br/>    pattern_lps = compute_lps(pattern)<br/>    <br/>    patterni = 0<br/>    for i, ch in enumerate(text):<br/>        <br/>        while patterni and pattern[patterni] != ch:<br/>            patterni = pattern_lps[patterni - 1]<br/>        <br/>        if pattern[patterni] == ch:<br/>            if patterni == len(pattern) - 1:<br/>                match_indices.append(i - patterni)<br/>                patterni = pattern_lps[patterni]<br/>            else:<br/>                patterni += 1</span><span id="6eed" class="lh li jd lb b gy nc mz l na nb">    return match_indices</span></pre><figure class="ld le lf lg gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi ne"><img src="../Images/f05d0b599d1c99f635f83131b6ccdafb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3rpko-PgGZXqOOcp-UZ8mQ.png"/></div></div></figure><p id="f50e" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">KMP 算法的时间复杂度是 O(m+n)。空间复杂度为 O(m)。</p></div></div>    
</body>
</html>