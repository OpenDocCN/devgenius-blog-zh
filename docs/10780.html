<html>
<head>
<title>KCL — Make Kubernetes Resource Management Easier</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">KCL —使 Kubernetes 资源管理更容易</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/kcl-make-kubernetes-resource-management-easier-f03ee820c7a4?source=collection_archive---------10-----------------------#2022-11-28">https://blog.devgenius.io/kcl-make-kubernetes-resource-management-easier-f03ee820c7a4?source=collection_archive---------10-----------------------#2022-11-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="e411" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">什么是 KCL</p><p id="3549" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ki" href="https://github.com/KusionStack/KCLVM" rel="noopener ugc nofollow" target="_blank"> KCL (Kusion 配置语言)</a>是一种开源的基于约束的记录和函数语言。KCL 通过成熟的编程语言技术和实践，改进大量复杂配置的编写，致力于围绕配置构建更好的模块化、可扩展性和稳定性，逻辑编写更简单，自动化速度快，生态扩展性好。</p><p id="fcb4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们部署软件系统时，我们不认为它们是固定的。不断发展的业务需求、基础设施需求和其他因素意味着系统在不断变化。当我们需要快速改变系统行为，并且改变过程需要昂贵且冗长的重构和重新部署过程时，业务代码的改变往往是不够的。配置可以为我们提供一种低开销的方式来改变系统功能。例如，我们经常为我们的系统配置编写如下所示的 JSON 或 YAML 文件。</p><ul class=""><li id="482c" class="kj kk in jm b jn jo jr js jv kl jz km kd kn kh ko kp kq kr bi translated">JSON 配置</li></ul><pre class="ks kt ku kv gt kw kx ky bn kz la bi"><span id="e6ae" class="lb lc in kx b be ld le l lf lg">{<br/>    "server": {<br/>        "addr": "127.0.0.1",<br/>        "listen": 4545<br/>    },<br/>    "database": {<br/>        "enabled": true,<br/>        "ports": [<br/>            8000,<br/>            8001,<br/>            8002<br/>        ],<br/>    }<br/>}</span></pre><ul class=""><li id="0dc0" class="kj kk in jm b jn jo jr js jv kl jz km kd kn kh ko kp kq kr bi translated">YAML 构型</li></ul><pre class="ks kt ku kv gt kw kx ky bn kz la bi"><span id="14e0" class="lb lc in kx b be ld le l lf lg">server:<br/>  addr: 127.0.0.1<br/>  listen: 4545<br/>database:<br/>  enabled: true<br/>  ports:<br/>  - 8000<br/>  - 8001<br/>  - 8002</span></pre><p id="d311" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以根据需要选择将静态配置存储在 JSON 和 YAML 文件中。此外，配置还可以用高级语言存储，这允许更灵活的配置，可以对其进行编码、呈现和静态配置。KCL 就是这样一种配置语言。我们可以编写 KCL 代码来生成 JSON/YAML 和其他配置。在本文中，我们将重点介绍如何使用 KCL 来生成和管理 Kubernetes 资源，并通过一些简单的示例让您快速入门。我们将在接下来的文章中进一步展开。</p><p id="ae59" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为什么使用 KCL</p><p id="de36" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们管理 Kubernetes 资源时，我们经常手动维护它，或者使用 Helm 和 Kustomize 工具来维护我们的 YAML 配置或配置模板，然后通过 kubectl 工具将资源应用到集群。但是，作为一名“YAML 工程师”，每天维护 YAML 配置无疑是琐碎枯燥的，而且容易出错。例如如下:</p><pre class="ks kt ku kv gt kw kx ky bn kz la bi"><span id="c2d7" class="lb lc in kx b be ld le l lf lg">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata: ... # Omit<br/>spec:<br/>  selector:<br/>    matchlabels:<br/>      cell: RZ00A<br/>  replicas: 2<br/>  template:<br/>    metadata: ... # Omit<br/>    spec:<br/>      tolerations:<br/>      - effect: NoSchedules<br/>        key: is-over-quota<br/>        operator: Equal<br/>        value: 'true'<br/>      containers:<br/>      - name: test-app<br/>          image: images.example/app:v1 # Wrong ident<br/>        resources:<br/>          limits:<br/>            cpu: 2 # Wrong type. The type of cpu should be str<br/>            memory: 4Gi<br/>            # Field missing: ephemeral-storage<br/>      affinity:<br/>        nodeAffinity:<br/>          requiredDuringSchedulingIgnoredDuringExecution:<br/>            nodeSelectorTerms:<br/>            - matchExpressions:<br/>              - key: is-over-quota<br/>                operator: In<br/>                values:<br/>                - 'true'</span></pre><ul class=""><li id="cb25" class="kj kk in jm b jn jo jr js jv kl jz km kd kn kh ko kp kq kr bi translated">YAML 中的结构化数据是非类型化的，并且缺乏验证方法，因此无法立即检查所有数据的有效性。</li><li id="c5cb" class="kj kk in jm b jn lh jr li jv lj jz lk kd ll kh ko kp kq kr bi translated">YAML 的编程能力很差。很容易写出不正确的缩进，也没有逻辑判断等常用的代码组织方法。容易写大量重复配置，维护困难。</li><li id="cbd9" class="kj kk in jm b jn lh jr li jv lj jz lk kd ll kh ko kp kq kr bi translated">Kubernetes 的设计比较复杂，用户很难理解所有的细节，比如上面配置中的<code class="fe lm ln lo kx b">toleration</code>和<code class="fe lm ln lo kx b">affinity</code>字段。如果用户不理解调度逻辑，可能会错误地省略或添加多余的内容。</li></ul><p id="84a4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，KCL 希望在 Kubernetes YAML 资源管理中解决以下问题:</p><ul class=""><li id="32ca" class="kj kk in jm b jn jo jr js jv kl jz km kd kn kh ko kp kq kr bi translated">使用<strong class="jm io">生产级高性能编程语言</strong>到<strong class="jm io">编写代码</strong>提高配置的灵活性，如条件语句、循环、函数、包管理等特性提高配置复用能力。</li><li id="be7b" class="kj kk in jm b jn lh jr li jv lj jz lk kd ll kh ko kp kq kr bi translated">提高<strong class="jm io">配置语义验证</strong>在代码层面的能力，如可选/必填字段、类型、范围等配置检查。</li><li id="475e" class="kj kk in jm b jn lh jr li jv lj jz lk kd ll kh ko kp kq kr bi translated">提供<strong class="jm io">编写、组合和抽象配置块</strong>的能力，如结构定义、结构继承、约束定义等。</li></ul><p id="f5fd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如何使用 KCL 生成和管理 Kubernetes 资源</p><p id="fc6b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">先决条件</p><p id="586a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先可以访问<a class="ae ki" href="https://github.com/KusionStack/KCLVM" rel="noopener ugc nofollow" target="_blank"> KCL 项目主页</a>按照说明下载安装 KCL，然后准备一个<a class="ae ki" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>环境。</p><p id="8d8f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">生成 Kubernetes 清单</p><p id="e762" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以写下面的 KCL 代码，命名为<code class="fe lm ln lo kx b">main k</code>。KCL 的灵感来源于 Python。它的基本语法非常接近 Python，简单易学。配置模式很简单，<code class="fe lm ln lo kx b">k [: T] = v</code>，其中<code class="fe lm ln lo kx b">k</code>表示配置的属性名，<code class="fe lm ln lo kx b">v</code>表示配置的属性值，<code class="fe lm ln lo kx b">: T</code>表示可选的类型注释。</p><pre class="ks kt ku kv gt kw kx ky bn kz la bi"><span id="b9b4" class="lb lc in kx b be ld le l lf lg">apiVersion = "apps/v1"<br/>kind = "Deployment"<br/>metadata = {<br/>    name = "nginx"<br/>    labels.app = "nginx"<br/>}<br/>spec = {<br/>    replicas = 3<br/>    selector.matchLabels = metadata.labels<br/>    template.metadata.labels = metadata.labels<br/>    template.spec.containers = [<br/>        {<br/>            name = metadata.name<br/>            image = "${metadata.name}:1.14.2"<br/>            ports = [{ containerPort = 80 }]<br/>        }<br/>    ]<br/>}</span></pre><p id="d48b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的 KCL 代码中，我们声明了一个 Kubernetes <code class="fe lm ln lo kx b">Deployment</code>资源的<code class="fe lm ln lo kx b">apiVersion</code>、<code class="fe lm ln lo kx b">kind</code>、<code class="fe lm ln lo kx b">metadata</code>、<code class="fe lm ln lo kx b">spec</code>等变量，并分别赋予相应的内容。特别是，我们将分配在<code class="fe lm ln lo kx b">spec.selector.matchLabels</code>和<code class="fe lm ln lo kx b">spec.template.metadata.labels</code>字段中被重用的<code class="fe lm ln lo kx b">metadata.labels</code>字段。可以看出，与 YAML 相比，KCL 定义的数据结构更加紧凑，通过定义局部变量可以实现配置重用。</p><p id="2378" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以通过执行下面的命令行来获得一个 Kubernetes YAML 文件</p><pre class="ks kt ku kv gt kw kx ky bn kz la bi"><span id="09d2" class="lb lc in kx b be ld le l lf lg">kcl main.k</span></pre><p id="057e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">输出是</p><pre class="ks kt ku kv gt kw kx ky bn kz la bi"><span id="0a9d" class="lb lc in kx b be ld le l lf lg">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: nginx-deployment<br/>  labels:<br/>    app: nginx<br/>spec:<br/>  replicas: 3<br/>  selector:<br/>    matchLabels:<br/>      app: nginx<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: nginx<br/>    spec:<br/>      containers:<br/>      - name: nginx<br/>        image: nginx:1.14.2<br/>        ports:<br/>        - containerPort: 80</span></pre><p id="2b63" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当然，我们可以将 KCL 与 kubectl 和其他工具一起使用。让我们执行以下命令并查看结果:</p><pre class="ks kt ku kv gt kw kx ky bn kz la bi"><span id="a01a" class="lb lc in kx b be ld le l lf lg">$ kcl main.k | kubectl apply -f -<br/><br/>deployment.apps/nginx-deployment configured</span></pre><p id="204c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从命令行可以看出，与直接使用 YAML 配置和 kubectl 应用的部署体验完全一致。</p><p id="0eef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过 kubectl 检查部署状态</p><pre class="ks kt ku kv gt kw kx ky bn kz la bi"><span id="d95a" class="lb lc in kx b be ld le l lf lg">$ kubectl get deploy<br/><br/>NAME               READY   UP-TO-DATE   AVAILABLE   AGE<br/>nginx-deployment   3/3     3            3           15s</span></pre><p id="d45d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">编写代码来管理 Kubernetes 资源</p><p id="5b12" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在发布 Kubernetes 资源时，我们经常会遇到需要动态指定配置参数的场景。比如不同的环境需要设置不同的<code class="fe lm ln lo kx b">image</code>字段值来生成不同环境下的资源。对于这个场景，我们可以通过 KCL 条件语句和<code class="fe lm ln lo kx b">option</code>函数动态接收外部参数。基于上面的例子，我们可以根据不同的环境调整配置参数。例如，对于下面的代码，我们编写了一个条件语句，并输入了一个名为<code class="fe lm ln lo kx b">env</code>的动态参数。</p><pre class="ks kt ku kv gt kw kx ky bn kz la bi"><span id="6d6d" class="lb lc in kx b be ld le l lf lg">apiVersion = "apps/v1"<br/>kind = "Deployment"<br/>metadata = {<br/>    name = "nginx"<br/>    labels.app = "nginx"<br/>}<br/>spec = {<br/>    replicas = 3<br/>    selector.matchLabels = metadata.labels<br/>    template.metadata.labels = metadata.labels<br/>    template.spec.containers = [<br/>        {<br/>            name = metadata.name<br/>            image = "${metadata.name}:1.14.2" if option("env") == "prod" else "${metadata.name}:latest"<br/>            ports = [{ containerPort = 80 }]<br/>        }<br/>    ]<br/>}</span></pre><p id="3930" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用 KCL 命令行<code class="fe lm ln lo kx b">-D</code>标志接收外部动态参数:</p><pre class="ks kt ku kv gt kw kx ky bn kz la bi"><span id="1323" class="lb lc in kx b be ld le l lf lg">kcl main.k -D env=prod</span></pre><p id="e683" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">输出是</p><pre class="ks kt ku kv gt kw kx ky bn kz la bi"><span id="5441" class="lb lc in kx b be ld le l lf lg">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: nginx-deployment<br/>  labels:<br/>    app: nginx<br/>spec:<br/>  replicas: 3<br/>  selector:<br/>    matchLabels:<br/>      app: nginx<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: nginx<br/>    spec:<br/>      containers:<br/>      - name: nginx<br/>        image: nginx:1.14.2<br/>        ports:<br/>        - containerPort: 80</span></pre><p id="521f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面代码片段中的<code class="fe lm ln lo kx b">image=metadata.name+": 1.14.2" if option ("env")=="prod" else metadata.name + ": latest"</code>是指当动态参数<code class="fe lm ln lo kx b">env</code>的值设置为<code class="fe lm ln lo kx b">prod</code>时，图像字段的值为<code class="fe lm ln lo kx b">nginx: 1.14.2</code>；否则就是‘nginx:latest’。因此，我们可以根据需要将 env 设置为不同的值，以获得不同内容的 Kubernetes 资源。</p><p id="5065" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">KCL 还支持在配置文件中维护 option 函数的动态参数，比如写<code class="fe lm ln lo kx b">kcl.yaml</code>文件。</p><pre class="ks kt ku kv gt kw kx ky bn kz la bi"><span id="ed3c" class="lb lc in kx b be ld le l lf lg">kcl_options:<br/>  - key: env<br/>    value: prod</span></pre><p id="75ac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用下面的命令行简化 KCL 动态参数的输入过程，可以获得相同的 YAML 输出。</p><pre class="ks kt ku kv gt kw kx ky bn kz la bi"><span id="d69a" class="lb lc in kx b be ld le l lf lg">kcl main.k -Y kcl.yaml</span></pre><p id="4173" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">输出是:</p><pre class="ks kt ku kv gt kw kx ky bn kz la bi"><span id="47c6" class="lb lc in kx b be ld le l lf lg">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: nginx-deployment<br/>  labels:<br/>    app: nginx<br/>spec:<br/>  replicas: 3<br/>  selector:<br/>    matchLabels:<br/>      app: nginx<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: nginx<br/>    spec:<br/>      containers:<br/>      - name: nginx<br/>        image: nginx:1.14.2<br/>        ports:<br/>        - containerPort: 80</span></pre><p id="2286" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后</p><p id="76b2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本文简要介绍了使用 KCL 编写配置的快速入门，以及使用 KCL 来定义和管理 Kubernetes 资源。</p><p id="c462" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个阶段，Kustomize 和 Helm 已经逐渐发展成为 Kubernetes 配置定义和管理领域事实上的标准。熟悉 Kubernetes 的小伙伴可能更喜欢写显式配置。Kustomize 和 Helm 在使用 KCL 编写和渲染配置文件方面有什么异同？考虑到很多合作伙伴已经在使用 Helm 和 Kustomize 这样的工具，我将在下一篇文章中介绍 KCL 方法来编写相应的配置代码。</p><p id="c58b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">更多精彩内容，请访问:</p><ul class=""><li id="0f62" class="kj kk in jm b jn jo jr js jv kl jz km kd kn kh ko kp kq kr bi translated">KCL:<a class="ae ki" href="https://github.com/KusionStack/KCLVM" rel="noopener ugc nofollow" target="_blank">https://github.com/KusionStack/KCLVM</a></li><li id="5005" class="kj kk in jm b jn lh jr li jv lj jz lk kd ll kh ko kp kq kr bi translated">库辛:<a class="ae ki" href="https://github.com/KusionStack/kusion" rel="noopener ugc nofollow" target="_blank">https://github.com/KusionStack/kusion</a></li><li id="f806" class="kj kk in jm b jn lh jr li jv lj jz lk kd ll kh ko kp kq kr bi translated">konfig:<a class="ae ki" href="https://github.com/KusionStack/Konfig" rel="noopener ugc nofollow" target="_blank">https://github.com/KusionStack/Konfig</a></li></ul><p id="6deb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">欢迎加入我们的交流社区:</p><ul class=""><li id="6221" class="kj kk in jm b jn jo jr js jv kl jz km kd kn kh ko kp kq kr bi translated"><a class="ae ki" href="https://github.com/KusionStack/community" rel="noopener ugc nofollow" target="_blank">https://github.com/KusionStack/community</a></li></ul></div></div>    
</body>
</html>