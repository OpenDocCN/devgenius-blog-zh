<html>
<head>
<title>React Patterns — Composition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应模式—合成</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/react-patterns-composition-29e4f04a23df?source=collection_archive---------14-----------------------#2020-06-23">https://blog.devgenius.io/react-patterns-composition-29e4f04a23df?source=collection_archive---------14-----------------------#2020-06-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1fda8ef09cd11f758ceecd6fed512f9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*A7g6Esf2AUHrKJvw"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Jacques Bopp 在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="82ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React是一个用于创建web应用程序和移动应用程序的流行库。</p><p id="f2a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究如何组合React组件。</p><h1 id="c212" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">组件之间的通信</h1><p id="5d5d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">重用功能始终是开发人员努力追求的目标。</p><p id="bbee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React使可重用组件变得容易。</p><p id="e22f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">具有清晰界面的小组件可以很容易地组合在一起，以创建强大且可维护的复杂应用程序。</p><p id="cc17" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以通过编写以下代码来创建组件:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b378" class="mn lc iq mj b gy mo mp l mq mr">const Item = ({ name }) =&gt; &lt;p&gt;{name}&lt;/p&gt;;</span></pre><p id="2c40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个简单的组件，它只接受<code class="fe ms mt mu mj b">name</code>道具并显示它。</p><p id="7c6a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我们可以努力创造的理想组件。</p><p id="9211" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">name</code>是道具。它是一个从父组件到子组件的值。</p><p id="83fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当一个组件把一些道具传递给另一个组件时，就叫做拥有者。</p><h1 id="b3b5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">儿童</h1><p id="f4e1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">有一个特殊的道具可以从所有者传递给被称为子组件的组件。</p><p id="1ba2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">孩子们的财产并不能说明它的价值。</p><p id="30bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它包含标签之间的组件。</p><p id="427f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="fdc3" class="mn lc iq mj b gy mo mp l mq mr">&lt;button&gt;click me&lt;/button&gt;</span></pre><p id="9c24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe ms mt mu mj b">click me</code>就是<code class="fe ms mt mu mj b">children</code>的值。</p><p id="8dcb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了让我们自己的按钮做同样的事情，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="fc54" class="mn lc iq mj b gy mo mp l mq mr">const Button = ({ children }) =&gt; &lt;button&gt;{children}&lt;/button&gt;;</span></pre><p id="9693" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一个带着T5道具的T4。</p><p id="300a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以用它来写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="91d7" class="mn lc iq mj b gy mo mp l mq mr">import React from "react";</span><span id="5cb1" class="mn lc iq mj b gy mv mp l mq mr">const Button = ({ children }) =&gt; &lt;button&gt;{children}&lt;/button&gt;;</span><span id="eeb4" class="mn lc iq mj b gy mv mp l mq mr">export default function App() {<br/>  return &lt;Button&gt;click me&lt;/Button&gt;;<br/>}</span></pre><p id="9cfc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好的一面是我们可以在组件标签之间传递任何东西。</p><p id="f13a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="cabd" class="mn lc iq mj b gy mo mp l mq mr">import React from "react";</span><span id="b3fc" class="mn lc iq mj b gy mv mp l mq mr">const Button = ({ children }) =&gt; &lt;button&gt;{children}&lt;/button&gt;;</span><span id="aa03" class="mn lc iq mj b gy mv mp l mq mr">export default function App() {<br/>  return (<br/>    &lt;Button&gt;<br/>      &lt;b&gt;click me&lt;/b&gt;<br/>    &lt;/Button&gt;<br/>  );<br/>}</span></pre><p id="0179" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到一个粗体文本的按钮。</p><p id="dba0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过编写以下代码来验证子道具类型:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="bf9c" class="mn lc iq mj b gy mo mp l mq mr">Button.propTypes = {<br/>  children: PropTypes.oneOfType([PropTypes.array, PropTypes.element])<br/>};</span></pre><p id="8c39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们不会在将道具传入<code class="fe ms mt mu mj b">Button</code>组件时犯任何错误。</p><h1 id="718c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">容器和表示模式</h1><p id="3f40" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">React组件通常将逻辑与表示混合在一起。</p><p id="4fda" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">逻辑是任何与UI无关的东西，比如API调用、数据操作等等。</p><p id="ed7f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">表示是我们在创建组件来创建UI时返回的东西。</p><p id="62a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使我们的代码简洁，我们应该将逻辑和表示分开。</p><p id="3f23" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">分离逻辑和表示使它们更加可重用。</p><p id="5ec6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以将逻辑从演示中分离出来，写为:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7135" class="mn lc iq mj b gy mo mp l mq mr">import React, { useState, useEffect } from "react";</span><span id="35fd" class="mn lc iq mj b gy mv mp l mq mr">const fetchPerson = async name =&gt; {<br/>  const res = await fetch(`https://api.agify.io/?name=${name}`);<br/>  return await res.json();<br/>};</span><span id="095e" class="mn lc iq mj b gy mv mp l mq mr">export default function App() {<br/>  const [data, setData] = useState({});</span><span id="1eae" class="mn lc iq mj b gy mv mp l mq mr">  const onLoad = async name =&gt; {<br/>    const personData = await fetchPerson(name);<br/>    setData(personData);<br/>  };</span><span id="af19" class="mn lc iq mj b gy mv mp l mq mr">  useEffect(() =&gt; {<br/>    onLoad("michael");<br/>  }, []);<br/>  return &lt;p&gt;{data.name}&lt;/p&gt;;<br/>}</span></pre><p id="32cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">fetchPerson</code>有逻辑。它用于从API获取数据。</p><p id="a97a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">App</code>已经演示完毕。</p><p id="5178" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通过调用<code class="fe ms mt mu mj b">fetchPerson</code>获取数据，并调用<code class="fe ms mt mu mj b">setData</code>更新数据，以便可以显示。</p><p id="88b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">责任是明确的。它们轮廓分明，每个部分都很小。</p><p id="9b55" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">表示组件可以有状态。我们只有显示数据所需的状态。</p><p id="55b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过将表示代码移动到更小的组件中来进一步分离它。</p><p id="1122" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以创建一个哑组件:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6362" class="mn lc iq mj b gy mo mp l mq mr">import React, { useState, useEffect } from "react";<br/>const fetchPerson = async name =&gt; {<br/>  const res = await fetch(`https://api.agify.io/?name=${name}`);<br/>  return await res.json();<br/>};</span><span id="edad" class="mn lc iq mj b gy mv mp l mq mr">const Person = ({ data: { name } }) =&gt; &lt;p&gt;{name}&lt;/p&gt;;</span><span id="038e" class="mn lc iq mj b gy mv mp l mq mr">export default function App() {<br/>  const [data, setData] = useState({});<br/>  const onLoad = async name =&gt; {<br/>    const personData = await fetchPerson(name);<br/>    setData(personData);<br/>  };<br/>  useEffect(() =&gt; {<br/>    onLoad("michael");<br/>  }, []);</span><span id="4715" class="mn lc iq mj b gy mv mp l mq mr">  return &lt;Person data={data} /&gt;;<br/>}</span></pre><p id="8c5b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将p元素移动到它自己的组件中，这样在<code class="fe ms mt mu mj b">App</code>组件中就没有任何逻辑了。</p><p id="5f97" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">App</code>只是充当连接表示和逻辑的容器。</p><p id="e806" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">组件越小，越多的人可以在代码的同一部分工作。</p><p id="f3ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为如果他们很小，那么多人改变同一个组件的可能性就很小。</p><p id="0ae5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们使用迭代过程来构建应用程序，那么这将使应用程序的构建过程更快。</p><p id="a2b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，它确实涉及到创建更多的文件和组件。</p><p id="95b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们不应该总是应用这个。当这种模式有意义时，我们应该采用它。</p><p id="fe72" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们需要再利用的时候，我们就分开。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/45ef4130a3a90aa5688086a013f1d324.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Quios69kz8zvBYAT"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@webaliser?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">ярославалексеенко</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><h1 id="6952" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="0e74" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用不同的组件轻松地创建可重用的组件。</p><p id="64ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很容易做到这一点，通过将逻辑分成函数，将表示代码分成组件。</p></div></div>    
</body>
</html>