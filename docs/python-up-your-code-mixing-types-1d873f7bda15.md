# Python 编写代码:混合类型

> 原文：<https://blog.devgenius.io/python-up-your-code-mixing-types-1d873f7bda15?source=collection_archive---------23----------------------->

## 对不同类型的操作数执行操作

![](img/acce95d200094f7ee734fd06a660ea85.png)

[布鲁诺在](https://unsplash.com/@bruthethe?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)[unplash](https://unsplash.com/s/photos/neon?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)上拍摄的照片

这可能只是我前一段时间写的[运算符](https://medium.com/@deck451/python-up-your-code-operators-455164611481)文章的一部分，因为它非常接近 Python 运算符主题，但是我认为它应该有一篇自己的文章，因为我觉得这个主题非常重要，所以把这条信息作为其他主题的一部分放在其他文章中，不管这些信息有多遥远，都有可能忽视我认为关于 Python 以及它在处理不同类型的操作数时是如何工作的一件非常基本但又必不可少的事情。

在 Python 中，当一个表达式包含两个或多个不同类型的操作数时，类型混合就会出现。不知何故，这个表达需要被评估，为此，必须建立共同点。让我们考虑最简单的情况，其中涉及一些算术运算和几类操作数:

```
*# define an integer*
a = 3*# define a float number* b = 1.5*# add the two and store it in another variable* c = a + b**print**(f"{**type**(a)}: {a}")
**print**(f"{**type**(b)}: {b}")
**print**(f"{**type**(c)}: {c}")Output:
<class 'int'>: 3
<class 'float'>: 1.5
<class 'float'>: 4.5
```

刚刚发生了什么？嗯，当我们把两个数字相加时，整数被内部转换成`float`，然后相加是在两个浮点数之间进行的。直接结果是`float`型。

现在，这可能是也可能不是演示类型混合的最佳案例，因为有人可能会说加法的结果不能存储在任何东西中**而是**一个浮点变量，所以让我们考虑下一个:

```
*# define an integer* a = 4*# define a float number* b = 1.5*# multiply the two and store it in another variable* c = a * b**print**(f"{**type**(a)}: {a}")
**print**(f"{**type**(b)}: {b}")
**print**(f"{**type**(c)}: {c}")Output:
<class 'int'>: 4
<class 'float'>: 1.5
<class 'float'>: 6.0
```

这一次，规则非常明确。整数被转换成浮点数，然后进行乘法运算。结果的类型是浮点型，尽管这一次它很可能适合一个整数变量。有一条规则变得非常明确:结果类型与最复杂的运算符类型相同。在这种情况下，最复杂的运算符是`float`类型，因此结果也将共享该类型。

考虑到上面的两个例子，我们现在可以得出结论，为了让 Python 成功地评估一个包含多种类型操作数的表达式，它首先将所有操作数转换为最复杂的操作数类型，然后根据这种类型操作数的规则执行所需的操作。

正如我上面提到的，转换是对表达式中最复杂类型的操作数进行的，原因很明显，就是为了避免数据丢失。想象一下，如果我们必须将一个整数加到一个浮点数上:

```
a = 2
b = 3.7**print**(**float**(a))
**print**(**int**(b))Output:
2.0
3
```

在这种情况下，添加`a + b`将产生`5.7`，并且结果将是`float`类型，因为 Python 将整数`a`转换为浮点数，这使得加法操作更容易，因为两个操作数相互兼容，并且不会发生数据丢失。但是想象一下，如果 Python 不是将所有操作数转换成最复杂的操作数，而是转换成最简单的操作数类型——在我们的例子中是整数。`a + b`会给我们`5`的结果。但是由于浮点到整数的转换，我们会丢失`0.7`。

当然，我们有办法可以忽略这种行为。Python 提供了一些方便的类型转换函数，比如`int()`、`float()`或者`complex()`。它们分别用于将变量转换(或创建)成**整数**、**浮点数**和**复数**。

考虑下面的例子:

```
a = 2
b = 3.7
c = 4.4d = a + b + c
e = a + **int**(b) + **int**(c)
f = **int**(a + b + c)**print**(f"{**type**(d)}: {d}")
**print**(f"{**type**(e)}: {e}")
**print**(f"{**type**(f)}: {f}")Output:
<class 'float'>: 10.100000000000001
<class 'int'>: 9
<class 'int'>: 10
```

首先，我们定义了 3 个数字变量:一个整数`a`和 2 个浮点数`b`和`c`。

然后，我们简单地将它们相加，并将结果存储在`d`中，正如我们已经看到的，它的类型是`float`，它的值是`10.1`。这是因为，在幕后，Python 将`a`转换为`float`，然后执行`2.0 + 3.7 + 4.4`并产生了`10.1`。

我们做的第二个测试是通过显式地将`b`和`c`转换为`int`来覆盖`a`到`float`的隐式转换。注意将`float`转换为`int`是如何有效地丢弃小数点右边的所有内容的？这就是为什么当我们把它们加起来的时候，我们只能得到`9`。`2 + 3 + 4`是截断变量的总和。

最后，第三个测试是根据当前内置的类型转换规则将它们加起来，然后将其显式转换为一个`int`。结果是一个意料之中的`10`。这三个变量都是类型对齐的，这意味着`a`被隐式转换为`float`，然后，正如在第一次测试中看到的，求和发生了:`2.0 + 3.7 + 4.4`，它产生了`10.1`的值，通过`int()`显式转换函数变成了`10`。

另一个你会发现显式转换的流行名称是**类型转换**。所以，不管名字如何，这是一回事:我们，编码者，正在使用像`int()`、`float()`或`complex()`到**这样的函数，显式地**将一些值从一种类型转换成另一种类型。换句话说，**类型转换**是由开发人员完成的，在代码中也是可见的。换句话说，每当我们**类型转换**时，这种类型转换过程可能导致的任何数据丢失的责任都落在我们的肩上。

另一方面，我们有隐式转换，Python 在幕后执行，以防止数据丢失，并能够正确计算包含多种类型操作数的表达式。这些没有明确地写在我们的代码中，但是正在发生，除非我们用一些**类型转换**来对抗。

不得不说，Python 中并不是所有的运算符都允许类型混合。允许这样做的运营商数量有限。它们分为两类:

*   算术运算符:`+`、`-`、`*`、`/`、`//`、`%`、`**`；
*   比较运算符:`<`、`>`、`<=`、`>=`、`==`、`!=`。

我将留给您一个涉及比较运算符的简单类型混合示例:

```
**print**(2.0 == 2)Output:
True
```

该机制开始工作，一如既往地将整数值转换为浮点值，然后在两个兼容值之间进行比较，给出结果`True`。

简而言之，这就是我不得不分享的关于 Python 中类型混合的话题。希望你们有一个好的阅读，直到[下一个](https://medium.com/@deck451/python-up-your-code-pickle-serialization-802312b0382c)时间！保持安全和快乐的编码！

*Deck 是软件工程师、导师、作家，有时甚至是老师。他拥有 12 年以上的软件工程经验，现在是 Python 编程语言的真正倡导者，同时他的热情是帮助人们提高他们的 Python(以及一般的编程)技能。你可以在* [*【领英】*](https://www.linkedin.com/in/deck451/)*[*【脸书】*](https://www.facebook.com/deck451/)*[*推特*](https://twitter.com/Deck45100)*[*不和*](https://discord.com) *: Deck451#6188，以及跟随他写在这里的* [*中*](https://medium.com/@deck451)***