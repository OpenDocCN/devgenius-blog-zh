<html>
<head>
<title>Parallax Scrolling using LazyColumn</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 LazyColumn 的视差滚动</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/parallax-scrolling-using-lazycolumn-8df1d416888d?source=collection_archive---------10-----------------------#2022-08-15">https://blog.devgenius.io/parallax-scrolling-using-lazycolumn-8df1d416888d?source=collection_archive---------10-----------------------#2022-08-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/6df5c3b0391985fa6c9b0265e0397258.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TopIQYVirYKr4ttN"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><a class="ae jz" href="https://unsplash.com/es/@jeremythomasphoto?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杰瑞米·托马斯</a>在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="4a3c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">视差滚动效果看起来总是很好，并且能吸引用户的注意力。使用 Jetpack Compose 可以相当容易地实现这个效果。</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div class="gh gi ky"><img src="../Images/75b70ba31252c0668876606259349295.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/0*Dz1pPEOFyopy8EVm.gif"/></div></figure><h1 id="61bf" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">只是另一个项目</h1><p id="b565" class="pw-post-body-paragraph ka kb in kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx ig bi translated">在这个例子中，我们在带有文本项的列表顶部有一个图像。这可能意味着我们有一个图像，后面跟着一个<strong class="kc io"> LazyColumn </strong>，但是在查看 API <strong class="kc io"> LazyColumn </strong>时，我们不仅可以调用<strong class="kc io"> items </strong>方法，并给它一个列表，其中包含创建项目所需的数据。</p><pre class="kz la lb lc gt mg mh mi mj aw mk bi"><span id="957a" class="ml le in mh b gy mm mn l mo mp">val list = (0..1_000).map{ "Item $it" }.toList()</span><span id="636b" class="ml le in mh b gy mq mn l mo mp">LazyColumn {<br/>    items(list) { item -&gt;<br/>        Text(text = item)<br/>    }<br/>}</span></pre><p id="daa3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们还可以在一个<strong class="kc io"> LazyColumn </strong>的范围内调用多个<strong class="kc io"> item </strong>和<strong class="kc io">item</strong>方法。不仅限于让它调用<strong class="kc io">项</strong>函数。<br/>对于这种方式，我们可以用<strong class="kc io">项</strong>显示图像，然后用<strong class="kc io">项</strong>创建列表。</p><pre class="kz la lb lc gt mg mh mi mj aw mk bi"><span id="d9be" class="ml le in mh b gy mm mn l mo mp">val list = (0..1_000).map{ "Item $it" }.toList()</span><span id="8d15" class="ml le in mh b gy mq mn l mo mp">LazyColumn {</span><span id="0dfb" class="ml le in mh b gy mq mn l mo mp">    item {<br/>        Image(<br/>            painter = resourcePainter(id = R.drawable.image),<br/>            contentDescription = "Top image"),<br/>            contentScale = ContentScale.Crop,<br/>            modifier = Modifier.fillParentMaxWidth()<br/>    }</span><span id="bf23" class="ml le in mh b gy mq mn l mo mp">    items(list) { item -&gt;<br/>        Text(text = item)<br/>    }<br/>}</span></pre><p id="5a77" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们已经有了一个包含两种类型条目的列表，当然现在它们以同样的速度滚动。</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div class="gh gi ky"><img src="../Images/d5d55ab3157a01648659b52e9af201c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/0*0AgeIIk-MbztngTe.gif"/></div></figure><h1 id="5e1b" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">没那么快</h1><p id="d8dc" class="pw-post-body-paragraph ka kb in kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx ig bi translated">为了实现视差效果，我们需要降低图像的滚动速度，同时保持其他项目的滚动速度不变。</p><p id="8d47" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">来影响我们需要的滚动</p><ol class=""><li id="bee7" class="mr ms in kc b kd ke kh ki kl mt kp mu kt mv kx mw mx my mz bi translated">一种滚动信息的方法</li><li id="3321" class="mr ms in kc b kd na kh nb kl nc kp nd kt ne kx mw mx my mz bi translated">一种操纵图像滚动行为的方法。</li></ol><p id="506d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于滚动信息，我们可以利用<strong class="kc io"> LazyColumns </strong>参数<strong class="kc io"> LazyListState </strong>，它包含了我们需要的信息。为了得到它，我们创建自己的并传入它，而不是保留默认值。</p><pre class="kz la lb lc gt mg mh mi mj aw mk bi"><span id="4701" class="ml le in mh b gy mm mn l mo mp">val lazyListState = rememberLazyListState()</span><span id="7f0d" class="ml le in mh b gy mq mn l mo mp">LazyColumn(state = lazyListState){<br/>    ...<br/>}</span></pre><p id="2c91" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从<strong class="kc io"> LazyListState </strong>中我们可以计算出，与其他项目相比，我们的图像沿 y 轴的平移速度较慢。</p><pre class="kz la lb lc gt mg mh mi mj aw mk bi"><span id="5e33" class="ml le in mh b gy mm mn l mo mp">val firstItemTranslationY by remember {<br/>        derivedStateOf {<br/>            when {<br/>                lazyListState.layoutInfo.visibleItemsInfo.isNotEmpty() &amp;&amp; lazyListState.firstVisibleItemIndex == 0 -&gt; lazyListState.firstVisibleItemScrollOffset * .6f<br/>                else                                                                                               -&gt; 0f<br/>            }<br/>        }<br/>    }</span></pre><p id="d046" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们检查图像在屏幕上是否可见，如果不可见，我们什么都不想做，只说行为正常，通过返回 0 的翻译。只要图像是可见的，我们就用当前的滚动偏移量乘以 1 到 0 之间的一个数。数字越接近 1，图像滚动的速度越慢。对于视差滚动效果，我们希望图像在屏幕上保持更长的时间，就像它正常情况下一样。</p><p id="3a65" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可以随意调整该值来调整速度。对于这个例子，让我们把它保持在 0.6 的中间。</p><p id="fdb9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们有了调整图像滚动的值。但是应该在哪里应用它呢？因为 Compose 提供了一个非常方便的修饰符供我们使用。<strong class="kc io">修改器. graphicsLayer </strong>为我们提供了操作缩放、旋转、阿尔法、平移和更多应用它的可组合元素的可能性。</p><p id="1564" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">翻译听起来是个不错的选择。让我们将<strong class="kc io">修改器. graphicsLayer </strong>应用于我们的图像，并将垂直平移设置为我们刚刚计算的值。</p><pre class="kz la lb lc gt mg mh mi mj aw mk bi"><span id="603f" class="ml le in mh b gy mm mn l mo mp">...<br/>item {<br/>    Image(<br/>        painter = painterResource(id = R.drawable.image),<br/>        contentDescription = "Top image",<br/>        contentScale = ContentScale.Crop,<br/>        modifier = Modifier<br/>            .fillParentMaxWidth()<br/>            .graphicsLayer {<br/>                translationY = firstItemTranslationY<br/>            }<br/>    )<br/>}<br/>...</span></pre><figure class="kz la lb lc gt jo gh gi paragraph-image"><div class="gh gi ky"><img src="../Images/441da7409e878e2103d41d20489d3efb.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/0*Ar8ZGst2OiKuGQqH.gif"/></div></figure><p id="b432" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">只是为了玩多一点，让我们也慢慢淡出图像，而它是滚动的。</p><pre class="kz la lb lc gt mg mh mi mj aw mk bi"><span id="f8fa" class="ml le in mh b gy mm mn l mo mp">val visibility by remember {<br/>        derivedStateOf {<br/>            when {<br/>                lazyListState.layoutInfo.visibleItemsInfo.isNotEmpty() &amp;&amp; lazyListState.firstVisibleItemIndex == 0 -&gt; {<br/>                    val imageSize = lazyListState.layoutInfo.visibleItemsInfo[0].size<br/>                    val scrollOffset = lazyListState.firstVisibleItemScrollOffset</span><span id="861c" class="ml le in mh b gy mq mn l mo mp">                    scrollOffset / imageSize.toFloat()<br/>                }<br/>                else                                                                                               -&gt; 1f<br/>            }<br/>        }<br/>    }</span></pre><p id="9772" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个过程基本上和以前一样，不同的是我们不是获取第一个项目的偏移量，而是获取它的大小和滚动偏移量，并计算 alpha 值。</p><p id="28bc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们应用它时，我们从 1 中减去我们计算的可见度，当它离开屏幕时，图像将是完全透明的。</p><pre class="kz la lb lc gt mg mh mi mj aw mk bi"><span id="6157" class="ml le in mh b gy mm mn l mo mp">.graphicsLayer {<br/>    alpha = 1f - visibility<br/>    translationY = firstItemTranslationY<br/>}</span></pre><figure class="kz la lb lc gt jo gh gi paragraph-image"><div class="gh gi ky"><img src="../Images/ac22e5a73e724f4104c6667b8f672a2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/0*-ibyffG_eX4IrMSU.gif"/></div></figure><h1 id="c530" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">结论</h1><p id="1022" class="pw-post-body-paragraph ka kb in kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx ig bi translated">使用 Jetpack Composes LazyColumn 和<strong class="kc io"> Modifier.graphicsLayer </strong>创建视差滚动效果非常简单。计算从<strong class="kc io"> LazyListState </strong>导出的平移，并将其应用于<strong class="kc io">修改器</strong>。</p><p id="44d3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这方面的完整代码可以在<a class="ae jz" href="https://github.com/a-frank/parallax-scrolling-compose" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><p id="dfee" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我还在这个例子中添加了一个淡入淡出的 TopBar。我想让返回箭头总是可见，因此最终创建了我自己的顶栏。如果你有任何关于如何让它与标准的撰写顶部栏一起工作的想法，请留下评论或直接给我写信。我想听听这件事:-)。</p><p id="b8e0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">希望你喜欢这个视差滚动的小例子。<br/>下一集见👋。</p></div></div>    
</body>
</html>