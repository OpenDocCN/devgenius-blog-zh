<html>
<head>
<title>Functional JavaScript — Closures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">函数式JavaScript——闭包</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/functional-javascript-closures-ffa520f13f6f?source=collection_archive---------6-----------------------#2020-11-14">https://blog.devgenius.io/functional-javascript-closures-ffa520f13f6f?source=collection_archive---------6-----------------------#2020-11-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/87275c03f1c62b48fa9e0e8803bd4842.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ROXG5dWFsqfV-YbJ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@framemily?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">画框哈里拉克</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="7166" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript部分是一种函数式语言。</p><p id="7b04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要学习JavaScript，我们必须学习JavaScript的功能部分。</p><p id="6eb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看如何使用闭包。</p><h1 id="17e7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">关闭</h1><p id="c405" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">闭包是内部函数。</p><p id="bdf0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">内部函数是函数中的函数。</p><p id="d6a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，它是这样的:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="fd29" class="mn lc iq mj b gy mo mp l mq mr">function outer() {<br/>  function inner() {}<br/>}</span></pre><p id="12ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">闭包可以访问3个作用域。</p><p id="d44f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们包括在自己的声明中声明的变量。</p><p id="f647" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，他们还可以访问全局变量。</p><p id="d786" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们可以访问外部函数的变量。</p><p id="1492" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9cee" class="mn lc iq mj b gy mo mp l mq mr">function outer() {<br/>  function inner() {<br/>    let x = 1;<br/>    console.log(x);<br/>  }<br/>  inner();<br/>}</span></pre><p id="5918" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后控制台日志记录1，因为我们在<code class="fe ms mt mu mj b">inner</code>函数中有<code class="fe ms mt mu mj b">x</code>，并且我们在控制台日志的同一个函数中访问它。</p><p id="1c65" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe ms mt mu mj b">outer</code>功能之外<code class="fe ms mt mu mj b">inner</code>功能将不可见。</p><p id="d3d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以在<code class="fe ms mt mu mj b">inner</code>函数中访问全局变量。</p><p id="00eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="573a" class="mn lc iq mj b gy mo mp l mq mr">let global = "foo";</span><span id="1000" class="mn lc iq mj b gy mv mp l mq mr">function outer() {<br/>  function inner() {<br/>    let a = 5;<br/>    console.log(global)<br/>  }<br/>  inner()<br/>}</span></pre><p id="29b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后<code class="fe ms mt mu mj b">'foo'</code>被记录，因为<code class="fe ms mt mu mj b">inner</code>可以访问<code class="fe ms mt mu mj b">global</code>变量。</p><p id="ff31" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">inner</code>可以访问的另一个作用域是<code class="fe ms mt mu mj b">outer</code>函数的作用域。</p><p id="5e13" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a426" class="mn lc iq mj b gy mo mp l mq mr">function outer() {<br/>  let outer = "outer"</span><span id="20b6" class="mn lc iq mj b gy mv mp l mq mr">  function inner() {<br/>    let a = 5;<br/>    console.log(outer);<br/>  }<br/>  inner()<br/>}</span></pre><p id="46aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有<code class="fe ms mt mu mj b">outer</code>变量，我们在<code class="fe ms mt mu mj b">inner</code>函数中访问它。</p><h1 id="be68" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结束记得它的上下文</h1><p id="5c9d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">闭包会记住它的上下文。</p><p id="eff3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以如果我们在任何地方使用它，函数中的变量就是它们在原始上下文中的样子。</p><p id="5fec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1c47" class="mn lc iq mj b gy mo mp l mq mr">const fn = (arg) =&gt; {<br/>  let outer = "outer"<br/>  let innerFn = () =&gt; {<br/>    console.log(outer)<br/>    console.log(arg)<br/>  }<br/>  return innerFn;<br/>}</span></pre><p id="553a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe ms mt mu mj b">outer</code>和<code class="fe ms mt mu mj b">arg</code>变量值将是相同的，不管它在哪里被调用。</p><p id="29ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">outer</code>是<code class="fe ms mt mu mj b">'outer'</code>，<code class="fe ms mt mu mj b">arg</code>是我们传入的任何东西。</p><p id="d7b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于我们用<code class="fe ms mt mu mj b">fn</code>返回了<code class="fe ms mt mu mj b">innerFn</code>，我们可以调用<code class="fe ms mt mu mj b">fn</code>并将返回的函数赋给一个变量并调用它:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="81b3" class="mn lc iq mj b gy mo mp l mq mr">const foo = fn('foo');<br/>foo()</span></pre><p id="9c30" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将<code class="fe ms mt mu mj b">'foo'</code>作为<code class="fe ms mt mu mj b">arg</code>的值传入。</p><p id="ed14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们得到:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f5c6" class="mn lc iq mj b gy mo mp l mq mr">outer<br/>foo</span></pre><p id="57f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从控制台日志中。</p><p id="5611" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到，即使我们在<code class="fe ms mt mu mj b">fn</code>函数之外调用它，值也是一样的。</p><h1 id="28a8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">真实世界的例子</h1><p id="4153" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以创建自己的<code class="fe ms mt mu mj b">tap</code>函数来记录调试值。</p><p id="7814" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ed3c" class="mn lc iq mj b gy mo mp l mq mr">const tap = (value) =&gt;<br/>  (fn) =&gt; {<br/>    typeof(fn) === 'function' &amp;&amp; fn(value);<br/>    console.log(value);<br/>  }</span><span id="fed0" class="mn lc iq mj b gy mv mp l mq mr">tap("foo")((it) =&gt; console.log('value:', it))</span></pre><p id="693a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建我们的<code class="fe ms mt mu mj b">tap</code>函数并调用它。</p><p id="a5c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一个函数，它接受一个<code class="fe ms mt mu mj b">value</code>，然后返回一个接受函数<code class="fe ms mt mu mj b">fn</code>的函数，并与控制台日志一起运行。</p><p id="3f07" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们可以传入一个值和一个函数。</p><p id="290b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="507b" class="mn lc iq mj b gy mo mp l mq mr">value: foo<br/>foo</span></pre><p id="490f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">记录在案。</p><p id="e34c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个来自我们传入的回调。</p><p id="803e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个来自我们用<code class="fe ms mt mu mj b">tap</code>返回的函数。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/01d307e2bd018607f243dc02c8cf1779.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7PGp03gERUBeRj_e"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@ninjason?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">梁杰森</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><h1 id="06a5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="950f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">闭包是内部函数。</p><p id="ae79" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们可以访问外部函数的作用域、全局变量以及他们自己的作用域。</p><p id="d870" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用它或各种应用程序。</p></div></div>    
</body>
</html>