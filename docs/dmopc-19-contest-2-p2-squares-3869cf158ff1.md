# DM OPC’19 竞赛 2 P2 —广场

> 原文：<https://blog.devgenius.io/dmopc-19-contest-2-p2-squares-3869cf158ff1?source=collection_archive---------7----------------------->

今天早上早些时候，我遇到了这个问题。问题陈述如下:

```
You are given an N×M grid of squares. Each square contains a number ai, 1≤i≤N×M, the cost to travel through that square. You are starting at the most top-left square. At each turn you may choose to move down or right but not both. Find the minimum cost it would take you to travel to the most bottom-right square.
```

这是示例输入:

```
3 4
3 1 2 4
9 8 7 6
2 8 9 2
```

以及相应的输出:

```
18
```

要获得相应的输出，您将遵循路径 3->1->2->4->6->2。

让我们运用一些解决问题的技巧。让我们看看是否有一个更简单的问题来尝试和解决，看看我们是否能回到原点。一个更简单的问题是问自己“在一个网格中有多少条从(0，0)到(n，m)的路径。我们将首先回答/编写那个问题的解决方案，然后我们将尝试解决这个问题。假设给你一个未加权的 n*m 矩阵，你需要找出从(0，0)到(n，m)的路径数。这是一个琐碎的动态编程问题。如果你学过数据管理，你就会知道如何解决这样的问题。无论如何，我会经历解决它的过程。在尝试解决这个问题时，你可以问自己一些好问题:

1.  在 1*x 网格中，从(0，0)到(n，m)有多少种方法？ie 1*1，1*5，1*10？
2.  在一个 x*1 的网格中，从(0，0)到(n，m)有多少种方法？ie 1*1，5*1，10*1？

3.在一个 2*3 的网格中，从(0，0)到(n，m)有多少种方法？好吧，我在下面概述了一下。

```
1 2 3 
4 5 6
```

1->2->3->6

1->2->5->6

1->4->5->6

有三种这样的方法。那么如何解决这个问题呢？到达位置 P sub i，j 的方法数是 P sub i-1，j 和 P sub i，j-1 的和。因此，在上面的矩阵中，它看起来像这样:

```
1 1 1
1 2 3
```

那么答案在 P sub n，m 处，正如你看到的位置(2，2)是位置(1，0)和(0，1)的和。位置(2，3)也是如此。下面是用 C++解决这类问题的代码。

既然我们已经解决了较简单的问题，我们应该着手解决难题了。回想一下，这次我们有一个加权图，这意味着每个位置都有一个相关的“成本”,我们希望最小化所述成本。这是给定的样本输入:

```
3 4
3 1 2 4
9 8 7 6
2 8 9 2
```

现在，我们如何将之前使用的算法转换成这个问题呢？好吧，因为我们试图最小化位置(N，M)的最终价格，我们应该在这个过程中做一些最小化。然而，在这个算法中我们不能贪婪，因为在高基础成本之后，可能有更好的路径未被探索。我们应该做的是，不要盲目地把 P sub i-1，j 和 P sub i，j-1 相加，我们应该把其中的最小值相加，因为这将给出最小成本路径。以给定样本输入中的(2，2)为例。去那里最便宜的方法是什么？是 3->1->8 还是 3->9->8？使用上面给出的直觉，位置(1，2)的数字变成 4，同样位置(2，1)的数字变成 12。那么，得到(2，2)的最小成本就是(2，2)的成本，以及(2，1)和(1，2)的最小成本。让我们稍微修改一下代码，让它工作起来。回想一下这个例子，我们也不能盲目地初始化矩阵，我们必须接收它作为输入。

如果这有助于您理解 DP 问题的这一分支，请留下赞，如果您希望我解释/解决任何编码问题，请留下评论。