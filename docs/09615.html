<html>
<head>
<title>Dependency injection — Swinject</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">依赖注入— Swinject</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/dependency-injection-swinject-5d8345331502?source=collection_archive---------3-----------------------#2022-09-01">https://blog.devgenius.io/dependency-injection-swinject-5d8345331502?source=collection_archive---------3-----------------------#2022-09-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/8f8ee34e0290ed091590fa833381c3a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*lI9F1cJnn9de_FiGwreGrA.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">图片由<a class="ae jy" href="https://pixabay.com/users/openclipart-vectors-30363/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=1297102" rel="noopener ugc nofollow" target="_blank">openclipbart-Vectors</a>来自<a class="ae jy" href="https://pixabay.com//?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=1297102" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></figcaption></figure><p id="56ca" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">在这篇文章中，我想表达我使用 Swinject 库的经历，它解决了我项目中的依赖关系。但是首先让我们看看什么是依赖注入，根据定义:</p><blockquote class="kx ky kz"><p id="25ae" class="jz ka la kb b kc kd ke kf kg kh ki kj lb kl km kn lc kp kq kr ld kt ku kv kw ij bi translated">在软件工程中，<strong class="kb ir">依赖注入</strong>是一种设计模式，其中一个对象或函数接收它所依赖的其他对象或函数。作为控制反转的一种形式，依赖注入旨在分离构造对象和使用对象的关注点，从而产生松散耦合的程序。该模式确保想要使用给定服务的对象或函数不必知道如何构造这些服务。</p></blockquote><p id="1f99" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">该定义清楚地表明，依赖注入是一种有助于分离关注点的模式，这导致了解耦和不太脆弱的代码。</p><p id="583c" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">现在让我们回到 iOS，有几个第三方可以帮助你构建这个系统，在这篇文章中，我将谈论<a class="ae jy" href="https://github.com/Swinject/Swinject" rel="noopener ugc nofollow" target="_blank"> Swinject </a>，它为你提供了一个处理依赖关系的简单接口。</p><h1 id="778c" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">它是如何工作的</h1><p id="2f01" class="pw-post-body-paragraph jz ka iq kb b kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw ij bi translated">就使用而言，Swinject 非常简单。首先，您必须注册您的依赖项，然后您只需调用 resolve 来访问它们。</p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="1f5c" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">在上面的例子中，你可以看到<code class="fe mn mo mp mq b">pet</code>是如何被注入到<code class="fe mn mo mp mq b">PetOwner</code>中的，这与 pet 属性是如何构造的没有任何关系。还有一个重要的注意事项，首先你需要注册依赖项，通常建议在<code class="fe mn mo mp mq b">appDidFinishLaunching</code>中完成，以确保在使用之前所有的依赖项都被正确设置。</p><h1 id="f38c" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">单元测试是如何改进的</h1><p id="2f6c" class="pw-post-body-paragraph jz ka iq kb b kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw ij bi translated">既然我们已经看到了如何使用依赖注入，那么另一个重要的话题就是我们如何在单元测试中获益。幸运的是，事情非常简单，因为注入的依赖项被设置为属性，我们只需要在单元测试中给它们分配模拟。</p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h1 id="2e3d" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">注射时移动单件</h1><p id="a13b" class="pw-post-body-paragraph jz ka iq kb b kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw ij bi translated">如果你试图在一个现有的项目中添加依赖注入，你可能会面临下一个挑战。首先，是如何解析一个共享实例引用，在上面的例子中，每次我们解析一个对象，就会得到一个新的实例。为了解决这个问题，SwInject 提供了一种方法来指定依赖关系的范围是永久的，例如:</p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="c457" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">上面的实现解决了实例共享，但是单例问题实际上已经解决了一半。的确，在单元测试中，你现在可以很容易地模仿单例实例，但是在实际应用中，共享实例仍然存在，它只是改变了你访问它的方式。解决第二部分问题更复杂，可能需要改变应用程序架构。您可以采取的第一步是将保持状态的代码分离到不同的依赖项中，以便尽可能地隔离单例代码。这里有一个例子:</p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h1 id="4183" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">卸载 appDidFinishLaunching</h1><p id="6043" class="pw-post-body-paragraph jz ka iq kb b kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw ij bi translated">如果您开始进行依赖注入，您可能会很快发现，在一个大项目中，您必须处理数百个依赖项。此外，如果你有很多在任何地方都被过度使用的单例类，这个过程会变得更加复杂。根据 Swinject 的建议，依赖性注册应该尽早在<code class="fe mn mo mp mq b">appDidFinishLaunching</code>中进行。这个建议很好，因为依赖关系是在解析时初始化的。但是，因为不是每件事都是完美的，在一个非常耦合的项目中，你可能会在应用程序完成启动调用时结束大量的依赖，这可能真的会减慢你的启动时间。以下是卸载启动应用程序的一些技巧:</p><ul class=""><li id="55bb" class="mr ms iq kb b kc kd kg kh kk mt ko mu ks mv kw mw mx my mz bi translated">将您的依赖项设置为 lazy，以确保它在被使用时而不是在初始化时被初始化:</li></ul><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="ml mm l"/></div></figure><ul class=""><li id="f180" class="mr ms iq kb b kc kd kg kh kk mt ko mu ks mv kw mw mx my mz bi translated">如果可能的话，尝试识别哪些模块降低了启动时间，并尝试卸载它们的 init</li><li id="de89" class="mr ms iq kb b kc na kg nb kk nc ko nd ks ne kw mw mx my mz bi translated">将依赖项注册拆分到多个块中，这些块在不同的运行时间得到调用。小心这一点，因为从长远来看它可能会产生问题，因为你可能会遇到这样的情况，当你试图在它注册之前获取一个依赖关系引用。</li></ul><h1 id="4ba0" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="f69f" class="pw-post-body-paragraph jz ka iq kb b kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw ij bi translated">Swinject 是构建依赖关系的一个很好的工具，它有一个简单的界面，使用起来非常简单和直观。最后，这个工具可以很棒，但不是凭空变魔术。您仍然需要考虑一个与您的依赖系统密切相关的良好架构，否则，您将获得孤立的好处。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="a581" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">我希望你喜欢这篇文章，并发现它的信息。如果你有任何问题或改进，我很高兴听到他们。</p></div></div>    
</body>
</html>