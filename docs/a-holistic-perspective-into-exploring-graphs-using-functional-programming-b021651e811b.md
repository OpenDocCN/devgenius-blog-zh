# 使用函数式编程探索图形的整体视角

> 原文：<https://blog.devgenius.io/a-holistic-perspective-into-exploring-graphs-using-functional-programming-b021651e811b?source=collection_archive---------20----------------------->

在我们开始之前，让我问你一个问题——当你遇到一个复杂的问题时，从基本的构建模块开始，然后逐步构建解决方案，这难道不是一种诱惑吗？嗯，可以说我不会怪你。

对于花了大量时间学习和使用命令式编程语言编程的人来说，这似乎是一种“自然”的策略。不幸的是，根据问题的复杂性，这可能不是最佳策略。如果你已经感到失落，想着我在唠叨些什么，请至少容忍我一会儿。让我们深入图表的世界，这是阐明我的观点的最佳选择。

图形无处不在。你很少会发现一个领域没有他们的存在。图由一组节点(顶点)和这些节点之间的边(G=(V，E))表示。这些边可以是有向的，也可以是无向的。我在下面展示了一个有向图的例子，我将用它来演示。

![](img/cb8f0c7db6d488448fa072eb75c7c2cf.png)

我们将使用一个名为 **edge** 的查询函数，它将告诉我们两个节点是否连接。

edge::Char-> Char-> Bool
edge ' A ' ' B ' = True
edge ' B ' ' C ' = True
edge ' C ' ' A ' = True
edge ' A ' ' D ' = True
edge ' D ' ' E ' = True
edge ' D ' ' F ' = True
edge ' F ' ' E ' = True
edge ' E ' ' B ' = True
edge _ _ = False

给定一个有向图，如果有一条路连接两个顶点，人们可以很容易地判断它们是否连接。现在，等一下。你一定在想“路径”是什么意思。

嗯，路径就是它的意思。两个顶点之间的路径是一系列相连的边，链中的每条边都通过边与其相邻边相连。例如，A 和 C 之间的路径是 *[(A，B)，(B，C)]* 。请注意，连接两个顶点的路径可能不止一条。路径的长度是端点之间的中间边数或*中间顶点数+ 1。*

归纳起来，如果存在某个中间顶点 y，则称任意两个顶点 x 和 z 是连接的，使得在 x 和 y 之间存在长度为 k 的路径，并且存在连接 y 和 z 的直接边。这意味着存在连接 x 和 z 的长度为 *(k+1)* 的路径

在 Haskell 中，我们可以通过类型 ***路径*** 来定义这种抽象

*类型路径= [Char]*

为了发现路径，我们将使用函数 *extendPath。*

*extend Path::Path→[Path]
extend Path[]=[[c]| c←[' A '..f ']]
extend path p =[p++[c]| c←[' A '..F']，edge (last p) c]*

该函数将通过添加从终端顶点到另一个顶点的边(如果有边连接它们)来扩展长度为 k 到(k+1)的路径。

为了将长度为 k 的所有路径扩展 1，我们可以定义一个名为 *extendAllPath —* 的函数

*extendAllPath::[Path]→[Path]
extendAllPath[]=[[c]| c←[' A '..f ']]
extendAllPath l =****concat map*******extend path****l**

**concatMap* 函数将 map ( *map :: (a → b) → a → b))* 和 concat ([c | p ← l，c ← p])组合在一起。*

*现在，发现所有可能长度的所有路径怎么样？在像 Haskell 这样的函数式语言中，我们可以通过重复映射 **extendAllPath** 到一个空的列表列表来实现它。*

**迭代::(a → a) → a → a
迭代 f x = > [x，f x，f (f x)，f(f x))……]**

***all paths = iterate extendAllPath[[]]***

*忽略长度为 0 和 1 的退化路径，我们可以利用 Haskell 提供的惰性评估，它可以有效地计算所有路径(包括带有循环的路径)。*

***丢弃 2(取(n+1)条路径)***

*显而易见，我们可以清楚明确地定义图上的不同操作，而不用担心管理状态变量和与管理它们相关的额外工作。*

*总之，我认为真正的区别是当你开始用 Haskell 编写时，你会接触到一个全新的范例。我从 Python 开始，然后学习 C++。我对使用 Python 中的 list comprehensions、lambdas、map、reduce、filter 和 C++ STL 提供的一些功能性的东西感到非常兴奋。然而，Haskell 是完全不同的野兽。它彻底改变了你的想法。相比之下显得那么优雅。我注意到的主要区别是不可变的“变量”和它的数学感觉。我希望在任何编程语言之间都能找到其他更类似于语法差异的差异。
是“更好”吗？我保留对此的判断，但我相信你会发现哈斯克尔在某些情况下有优势，如果不是很多的话。*