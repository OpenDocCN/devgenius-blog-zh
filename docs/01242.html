<html>
<head>
<title>IOS Development: Important Concepts &amp; Interview Questions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">IOS开发:重要概念和面试问题</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/ios-development-important-concepts-ios-interview-questions-8c429d520bc2?source=collection_archive---------4-----------------------#2020-06-28">https://blog.devgenius.io/ios-development-important-concepts-ios-interview-questions-8c429d520bc2?source=collection_archive---------4-----------------------#2020-06-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/06bda3ee3c44909897401c9d84978354.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8AE7QsUjaog7rQEd1s5JAg.jpeg"/></div></div></figure><div class=""/><p id="8866" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每个IOS开发人员都应该了解IOS基础知识，以理解整体应用程序行为。下面是我做的一些笔记，帮助IOS开发者(当然还有我自己！)对重要概念和概念感到自如包括<strong class="jx iz"> <em class="kt">“面试问题</em></strong><em class="kt"/>。我收集并审查了针对IOS开发人员的Swift和Objective C概念的最佳解释:)</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="ed41" class="lb lc iy bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">原子和非原子性质</h1><p id="d6ec" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">首先，原子和非原子属性在Objective-C中使用，在Swift中没有用武之地(他们说！).默认情况下，Swift将属性定义为非原子的，但是对于Objective-C，默认情况下它是原子的</p><p id="eaa1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">被指定为<strong class="jx iz">原子</strong>的属性保证总是返回一个完全初始化的对象。这也是合成属性的默认状态。虽然指定原子属性以消除混淆的可能性是一个好的做法，但是如果我们不这样做，属性仍然是原子的。</p><p id="bfee" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种原子属性的保证是以牺牲性能为代价的。但是，如果我们有一个属性，我们知道检索未初始化的值没有风险(例如，如果对该属性的所有访问已经通过其他方式同步)，那么将其设置为非原子可以提高性能。</p><p id="3a56" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">“原子的和非原子的”是指属性的setter/getter是否会原子地读写属性的值。</em>”</p><p id="6c1a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">原子属性在getter/setter中是线程安全的。<br/>非原子属性返回自己的属性。它们不是线程安全的，因此会受到其他线程的影响。这对于批判性应用来说是有风险的。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="6133" class="lb lc iy bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">核心数据</h1><blockquote class="me mf mg"><p id="4820" class="jv jw kt jx b jy jz ka kb kc kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ks ig bi translated">核心数据是一个框架，用于管理应用程序中的模型层对象。它为与对象生命周期和对象图管理(包括持久性)相关的常见任务提供了通用和自动化的解决方案。<em class="iy">(developer.apple.com文档)</em></p></blockquote><p id="942c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">警告:核心数据不是数据库。它使用SQLite并存储数据，但是框架本身不是数据库。核心数据包括比数据库更多的功能，如管理对象图、跟踪数据变化等。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="869d" class="lb lc iy bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Let与Var</h1><blockquote class="me mf mg"><p id="bafd" class="jv jw kt jx b jy jz ka kb kc kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ks ig bi translated">Let是一个不可变的变量，意味着它不能被改变。<br/> Var是可变变量，意思是可以改变。</p></blockquote></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="31c3" class="lb lc iy bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">农业研究委员会</h1><p id="a48a" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">ARC(自动引用计数):负责在其引用计数为零后从内存中删除对象。</p><p id="2b1e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">ARC是Swift语言的跟踪内存管理系统。</p><p id="45ca" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我想我不能用一个比Paul Hudson更好的例子来解释ARC:)</p><blockquote class="me mf mg"><p id="7700" class="jv jw kt jx b jy jz ka kb kc kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ks ig bi translated">当您从一个类中创建一个对象时，Swift会记住该实例仅被引用一次。如果您将另一个变量指向该对象，Swift会将引用计数增加到2，因为两个变量指向同一个对象。如果现在销毁第一个变量(可能它在函数内部，函数结束了)，Swift会将引用计数降回1。所有这些都很重要，因为只要引用计数大于1，对象就保持活动状态。但是当引用该对象的最后一个变量消失时，Swift会将引用计数减少到零。因为没有现有变量指向该对象，所以可以释放它的内存。因此，ARC是一种有效跟踪对象生命周期的方式，在大多数情况下，您甚至不会注意到它的发生——Swift为您完成了所有工作。(保罗·哈德森)</p></blockquote><p id="a910" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那么ARC的作用是什么呢？</p><blockquote class="me mf mg"><p id="f582" class="jv jw kt jx b jy jz ka kb kc kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ks ig bi translated">每当init()创建一个新的类实例时，ARC都会分配一块内存来存储信息。关于实例类型及其值的信息存储在内存中。<br/>当不再需要类实例时，它会通过deinit()自动释放内存空间，以便进一步存储和检索类实例。<br/> ARC跟踪当前引用的类实例属性、常量和变量，以便只将deinit()应用于那些未使用的实例。<br/> ARC维护对那些类实例属性、常量和变量的“强引用”,以在类实例当前正在使用时限制解除分配。(教程观点)</p></blockquote></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="7426" class="lb lc iy bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">强引用类型</h1><p id="418a" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">Swift默认使用<strong class="jx iz">强</strong>引用类型。<br/> <strong class="jx iz"> <em class="kt">强引用类型保护被引用对象不被ARC </em> </strong>释放。在强引用中，如果引用的对象计数不为0，它将继续被分配。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="d9ad" class="mt lc iy mp b gy mu mv l mw mx"><strong class="mp iz">class</strong> IOSDeveloper {<br/><strong class="mp iz">let</strong> burcu = Developer() <em class="kt">//strong reference to child.<br/></em>}</span><span id="7791" class="mt lc iy mp b gy my mv l mw mx"><strong class="mp iz">class</strong> Developer {}</span></pre></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="6f26" class="lb lc iy bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">弱引用类型</h1><p id="22a2" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">弱引用只是一个指向对象的指针。它不保护对象，它可以被ARC释放！</p><p id="5d1d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">强引用将对象的保留计数增加1，而弱引用不会！</p><p id="a92d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当对象被释放时，弱引用将指向该对象的指针清零。这确保了当您访问弱引用时，它要么是有效对象，要么为零。这里有很大的危险，所以你可以使用弱引用，在它生命周期的某个时刻，引用有可能变为零。你应该使用一个<strong class="jx iz">无主的</strong>引用，因为在自身对象存在之前<strong class="jx iz">没有</strong>任何时候引用变为零的可能性。</p><p id="10f3" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">加成:</strong> <br/> <em class="kt">在Swift中，所有弱引用都是非恒定的</em> <code class="fe mz na nb mp b"><em class="kt">Optionals</em></code> <em class="kt">(想想</em> <code class="fe mz na nb mp b"><em class="kt">var</em></code> <em class="kt"> vs. </em> <code class="fe mz na nb mp b"><em class="kt">let</em></code> <em class="kt">)因为引用</em> <strong class="jx iz"> <em class="kt">可以</em></strong><em class="kt"/><strong class="jx iz"><em class="kt">当不再有任何东西持有对它的强引用时</em> </strong> <em class="kt">会突变为零。</em> <strong class="jx iz"> <em class="kt">免得忘了:</em>结构和枚举不能赋给弱变量。</strong></p><figure class="mk ml mm mn gt ip gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/e19ad6c7b29fde56338faeff7fabf604.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*AynMREUhS9xPfqbQiwTEDg.png"/></div></figure></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="a820" class="lb lc iy bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">内存泄漏和保留周期</h1><p id="331a" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">内存泄漏是程序不再引用的已分配内存块。</p><p id="62e4" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">内存空间由不可访问数据的页面填充，当发生泄漏时会导致额外的分页活动。</p><p id="1fd8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">泄漏的内存最终会迫使系统为应用程序分配额外的虚拟内存页面，这种分配本来可以通过回收泄漏的内存来避免。(<em class="kt">developer.apple.com文档</em>)</p><p id="ac81" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<a class="ae nd" href="https://medium.com/@vinodhswamy/strong-cycle-retain-cycle-in-swift-f452f07518b2" rel="noopener">https://medium . com/@ vinodhswamy/strong-Cycle-Retain-Cycle-in-swift-f452f 07518 b 2</a>有关于ARC、内存泄漏和保持周期的精彩讲解</p><p id="5ac0" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">更多信息:<a class="ae nd" href="https://krakendev.io/blog/weak-and-unowned-references-in-swift" rel="noopener ugc nofollow" target="_blank">https://krakendev . io/blog/weak-and-unowned-references-in-swift</a></p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="ddbb" class="lb lc iy bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">IOS应用生命周期和应用状态</h1><p id="2515" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">首先，让我们理解跳板。跳板安排应用程序图标，壁纸，应用程序，如果它们启动或不启动，IPhone的一些设置，所以它是管理IOS设备上主屏幕的应用程序。使用SpringBoard，可以组织主屏幕上的图标，更改背景壁纸，以及启动应用程序。iPhone在启动时的一些设置也是由跳板设置的。别忘了:跳板可以在越狱时修改。</p><figure class="mk ml mm mn gt ip gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/efd2f4faa19b3d7f628f5423c0efc3ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*zBkR1a-r5IepH4Peu-qVzg.jpeg"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">图片来源于hackernoon</figcaption></figure><p id="8abb" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不同的iOS应用程序状态包括:</p><ul class=""><li id="c658" class="nj nk iy jx b jy jz kc kd kg nl kk nm ko nn ks no np nq nr bi translated"><strong class="jx iz">未运行</strong>状态:app尚未启动或正在运行，但被系统终止。</li><li id="c2b9" class="nj nk iy jx b jy ns kc nt kg nu kk nv ko nw ks no np nq nr bi translated"><strong class="jx iz"> Inactive </strong>状态:当app在前台运行，但当前没有接收事件时。当应用程序转换到另一种状态时，它会暂时停留在这种状态。它保持不活动的唯一时间是当用户锁定屏幕或系统提示用户响应一些事件，如电话或短信。</li><li id="2fa2" class="nj nk iy jx b jy ns kc nt kg nu kk nv ko nw ks no np nq nr bi translated"><strong class="jx iz">活动</strong>状态:当app在前台运行，正在接收事件时。这是前台应用程序的正常模式。</li><li id="fdcb" class="nj nk iy jx b jy ns kc nt kg nu kk nv ko nw ks no np nq nr bi translated"><strong class="jx iz">后台</strong>状态:app在后台执行代码时。大多数应用程序在被挂起的过程中都会短暂地进入这种状态。但是，请求额外执行时间的应用程序可以保持这种状态一段时间。此外，直接在后台启动的应用程序会进入这种状态，而不是非活动状态。</li><li id="a4f7" class="nj nk iy jx b jy ns kc nt kg nu kk nv ko nw ks no np nq nr bi translated"><strong class="jx iz">挂起</strong>状态:一个挂起的应用留在内存中，但不执行任何代码。当出现内存不足的情况时，系统可能会在没有通知的情况下清除暂停的应用程序，以便为前台应用程序腾出更多空间。</li></ul><p id="0525" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">什么时候你会说一个应用没有处于运行状态？</strong></p><p id="7317" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在以下情况下，应用程序被称为处于“未运行”状态:<br/>–当它未启动时。<br/>–在运行过程中被系统终止。</p><p id="f43e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">什么时候一个app被说成是处于活跃状态？<br/> </strong>当一个应用程序在前台运行并接收事件时，它被认为处于活动状态。</p><p id="87c4" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">app启动时的状态转换有哪些？<br/> </strong>一个app在上线前，据说处于未运行状态。<br/>在短暂转换非活动状态后，它在启动时会进入活动或后台状态。</p><p id="2532" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">应用程序在被暂停之前会短暂进入哪种状态？</strong>一个应用程序在被挂起的途中短暂进入后台状态。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="1ea1" class="lb lc iy bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">响应应用程序上的状态转换</h1><p id="2a81" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">通过调用应用程序的委托对象上的相应方法，可以以适当的方式响应状态转换。</p><p id="8f90" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如:</p><ul class=""><li id="b797" class="nj nk iy jx b jy jz kc kd kg nl kk nm ko nn ks no np nq nr bi translated">applicationDidBecomeActive()方法:准备作为前台应用程序运行</li><li id="4ca9" class="nj nk iy jx b jy ns kc nt kg nu kk nv ko nw ks no np nq nr bi translated">applicationDidEnterBackground()方法:当应用程序在后台运行时，执行一些可能随时暂停的代码</li><li id="29b3" class="nj nk iy jx b jy ns kc nt kg nu kk nv ko nw ks no np nq nr bi translated">applicationWillEnterForeground()方法:当应用程序移出后台时执行一些代码</li><li id="316c" class="nj nk iy jx b jy ns kc nt kg nu kk nv ko nw ks no np nq nr bi translated">applicationWillTerminate()方法:当应用程序被终止时调用</li></ul></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="0959" class="lb lc iy bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">可可vs可可触感</h1><figure class="mk ml mm mn gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nx"><img src="../Images/6ff707ea36fcc3b51c6602f03103b9a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R-X4kOg_13FtLTonhEi-Iw.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated"><a class="ae nd" href="https://www.edureka.co/blog/interview-questions/ios-interview-questions/" rel="noopener ugc nofollow" target="_blank">https://www . edu reka . co/blog/interview-questions/IOs-interview-questions/</a></figcaption></figure></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="c122" class="lb lc iy bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">IOS的JSON支持</h1><ul class=""><li id="169d" class="nj nk iy jx b jy lz kc ma kg ny kk nz ko oa ks no np nq nr bi translated">IOS支持SBJson框架。SBJson是Objective-C的Json解析器和生成器。它提供了灵活的API和额外的控制，使JSON处理更容易。</li><li id="a65e" class="nj nk iy jx b jy ns kc nt kg nu kk nv ko nw ks no np nq nr bi translated">对于IOS开发者来说，很容易使用Foundation framework的<a class="ae nd" href="https://developer.apple.com/reference/foundation/nsjsonserialization" rel="noopener ugc nofollow" target="_blank"> JSONSerialization </a>类将JSON转换成Dictionary、Array、String、Number、Bool等Swift数据类型。然而，因为您不能确定应用程序接收的JSON的结构或值，所以正确地反序列化模型对象是一个挑战。对于干净的代码，你可以使用<strong class="jx iz">编码</strong>协议:)</li></ul><p id="2ff3" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">从JSON中提取值:</strong>JSON serialization类方法jsonObject(with:options:)返回Any类型的值，如果数据无法解析，则抛出错误。</p><p id="e18b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">更多信息请访问<a class="ae nd" href="https://developer.apple.com/swift/blog/?id=37" rel="noopener ugc nofollow" target="_blank">苹果开发者</a>:)</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="3c83" class="lb lc iy bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">管理对象上下文及其功能</h1><p id="d8c2" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">托管对象上下文(由NSManagedObjectContext的实例表示)是应用程序中一个临时的“便笺式存储器”，用于(大概)相关的对象集合。这些对象共同表示一个或多个持久性存储的内部一致视图。</p><p id="0992" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">单个受管对象实例存在于且仅存在于一个上下文中，但是一个对象的多个副本可以存在于不同的上下文中。</p><p id="6011" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">受管对象上下文的主要功能包括:</p><ul class=""><li id="c1a6" class="nj nk iy jx b jy jz kc kd kg nl kk nm ko nn ks no np nq nr bi translated">生命周期管理:在这里，上下文提供验证、反向关系处理和撤销/重做。</li><li id="0fb2" class="nj nk iy jx b jy ns kc nt kg nu kk nv ko nw ks no np nq nr bi translated">通知:它指的是上下文帖子在不同点的通知，可以在应用程序中的其他地方有选择地进行监控。</li><li id="75c1" class="nj nk iy jx b jy ns kc nt kg nu kk nv ko nw ks no np nq nr bi translated">并发性:在这里，核心数据使用线程(或序列化队列)限制来保护托管对象和托管对象上下文。</li></ul></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="8046" class="lb lc iy bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">与GCD和运营的并发性</h1><p id="e9b5" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated"><strong class="jx iz">并发</strong>是“同时运行多个任务”。iOS设备上经常使用并发，因此您可以在后台运行任务(如下载或处理数据)，同时保持用户界面的响应性。</p><p id="3708" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">iOS中实现并发的三种方式:</strong> <br/>线程、调度队列、操作队列</p><p id="0e76" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">线程的缺点是它们将创建可伸缩解决方案的负担交给了开发人员。您必须决定创建多少个线程，并根据情况的变化动态调整这个数字。此外，应用程序承担了与创建和维护它所使用的线程相关的大部分成本。</p><p id="7c43" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，OS X和iOS更喜欢采用异步设计方法来解决并发问题，而不是依赖线程。</p><p id="929f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">异步启动任务的技术之一是Grand Central<strong class="jx iz">Dispatch(GCD)</strong>，它将线程管理下放到系统级。开发人员所要做的就是定义要执行的任务，并将它们添加到适当的<em class="kt">调度队列</em>。GCD负责创建所需的线程，并调度任务在这些线程上运行。</p><p id="afd5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所有的<strong class="jx iz">调度队列</strong>都是先进先出(FIFO)的数据结构，所以任务总是按照它们被添加的顺序开始。</p><p id="57ed" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一个<strong class="jx iz">操作队列</strong>是一个<em class="kt">并发分派队列</em>的Cocoa等价物，由<code class="fe mz na nb mp b"><a class="ae nd" href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSOperation_class/index.html" rel="noopener ugc nofollow" target="_blank">NSOperationQueue</a></code>类实现。与调度队列不同，操作队列不限于以FIFO顺序执行任务，还支持为您的任务创建复杂的执行顺序图。</p><p id="d609" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz"> GCD </strong>(或Grand Central Dispatch)和<strong class="jx iz"> Operations </strong>(以前称为NSOperation)是你在iOS中用来管理并发任务的API(与直接处理线程相对)。异步启动任务的技术之一是<a class="ae nd" href="https://developer.apple.com/library/prerelease/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html" rel="noopener ugc nofollow" target="_blank">中央调度(GCD) </a>，它将线程管理下放到系统级。开发人员所要做的就是定义要执行的任务，并将它们添加到适当的<em class="kt">调度队列</em>。GCD负责创建所需的线程，并调度任务在这些线程上运行。</p><p id="7163" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，OS X和iOS更喜欢采用异步设计方法来解决并发问题，而不是依赖线程。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="9ebf" class="lb lc iy bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">什么是自动释放池？</h1><p id="1106" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">自动释放池是一种便利，它允许您将发送-释放推迟到“以后”。这种“稍后”可能发生在几个地方，但在Cocoa GUI应用程序中最常见的是在当前运行循环周期的末尾。</p><p id="42ff" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果没有自动释放池，我们将无法验证弱引用最终是否会被释放。自动释放池关闭中的所有引用都应在排空时释放。这只有在不存在强引用的情况下才会发生。</p><p id="88aa" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">简而言之，<code class="fe mz na nb mp b">autoreleasepool</code>在iOS/Swift开发中仍然有用，因为UIKit和Foundation中仍然有调用<code class="fe mz na nb mp b">autorelease</code>的遗留Obj-C类，但由于ARC的优化，在处理Swift类时，您可能不需要担心它。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="06c6" class="lb lc iy bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">“分配”和“保留”的区别</h1><p id="245c" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated"><strong class="jx iz"> Assign </strong>创建一个从一个对象到另一个对象的引用，而不增加源的保留计数。</p><p id="b949" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz"> Retain </strong>创建一个从一个对象到另一个对象的引用，并增加源对象的保留计数。</p><p id="0d39" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe mz na nb mp b">retain</code>和<code class="fe mz na nb mp b">assign</code>是内存限定符的类型，但是不影响底层对象是什么。它将对象的保留计数增加1，并获得对象的所有权。</p><p id="3a0f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe mz na nb mp b">assign</code>是用于原语的关键字。这很容易理解:如果没有对象，就不能使用<code class="fe mz na nb mp b">strong</code>，因为strong告诉编译器如何处理指针。但是如果你有一个原语(例如，int，float，bool，或者类型后面没有小星号的东西)，那么你使用<code class="fe mz na nb mp b">assign</code>，这使得它可以处理原语。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="9a15" class="lb lc iy bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">什么是层对象？</h1><p id="2946" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">图层对象是数据对象。它们代表视觉内容。视图使用它们来呈现内容。您可以在界面中添加和实现自定义层，并将其用于复杂动画和任何其他视觉效果。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="8821" class="lb lc iy bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">AppID VS BundleID</h1><ul class=""><li id="f5db" class="nj nk iy jx b jy lz kc ma kg ny kk nz ko oa ks no np nq nr bi translated">一个应用ID是由两部分组成的字符串，用于标识一个开发团队中的一个或多个应用。该字符串由一个团队ID和一个捆绑包ID搜索字符串组成，带有一个句点(。)将两者分开。</li><li id="3ace" class="nj nk iy jx b jy ns kc nt kg nu kk nv ko nw ks no np nq nr bi translated">团队ID由Apple提供，对于特定的开发团队是唯一的，而捆绑ID由开发者提供，用于匹配单个应用程序的捆绑ID或一组应用程序的一组捆绑ID。</li></ul><p id="5bc6" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于大多数用户认为应用程序ID是一个字符串，他们认为它可以与捆绑包ID互换。在会员中心创建应用ID后，我们只能使用与应用捆绑包的捆绑包ID相匹配的应用ID前缀。</p><p id="7c48" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">捆绑包ID唯一定义了每个应用程序。它在Xcode中指定。一个Xcode项目可以有多个目标，因此可以输出多个应用程序。一个常见的用例:一个应用程序同时拥有lite/free和pro/full两个版本或多个品牌。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="5b9e" class="lb lc iy bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">iVar和@property是什么关系？</h1><p id="9dd1" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">iVar是一个实例变量。除非我们创建由@property生成的访问器，否则不能访问它。iVar及其对应的@property可以有不同的名称。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="cc4d" class="mt lc iy mp b gy mu mv l mw mx">@interface Box : NSObject{<br/>    NSString *boxName;<br/>}<br/>@property (strong) NSString *boxDescription;//this will become another ivar<br/>-(void)aMethod;<br/>@end<br/>@implementation Box<br/>@synthesize boxDescription=boxName;//now boxDescription is accessor for name<br/>-(void)aMethod {<br/>    NSLog(@"name=%@", boxName);<br/>     NSLog(@"boxDescription=%@",self.boxDescription);<br/>    NSLog(@"boxDescription=%@",boxDescription); //throw an error<br/>}<br/>@end</span></pre></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="fb5d" class="lb lc iy bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">NSURLConnection和属性</h1><p id="a2d0" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">NSURLConnection对象允许您通过提供URL请求对象来加载URL的内容。NSURLConnection的接口很稀疏，只提供启动和取消URL请求的异步加载的控件。您在URL请求对象本身上执行大多数配置。</p><p id="d4ed" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">NSURLConnection类有两种使用方式:异步和同步。</em></p><p id="3933" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">异步连接</strong>将创建一个新线程，并在新线程上执行其下载过程。</p><p id="8ca6" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">同步连接</strong>将在下载内容和进行通信时阻塞调用线程。</p><p id="5a6a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">奖励:</strong>很多开发者认为同步连接只阻塞主线程，这是不正确的。同步连接将总是阻塞触发它的线程。如果我们从主线程触发一个同步连接，主线程将被阻塞。然而，如果我们从主线程之外的线程中触发同步连接，它将像异步连接一样，不会阻塞我们的主线程。</p><p id="0b00" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">事实上，同步连接和异步连接的唯一区别在于，在运行时，会为异步连接创建一个线程，而不会为同步连接创建线程。</em></p><p id="7430" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">例如，为了创建一个异步连接，我们需要:</em> <br/>将我们的URL放在NSString的一个实例中<br/>将我们的字符串转换为NSURLRequest的一个实例<br/>将我们的URL放在NSURLRequest类型的URL请求中，或者在可变URL的情况下，放在NSMutableURLRequest的一个实例中<br/>创建NSURLConnection的一个实例，并将URL请求传递给它</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="8297" class="lb lc iy bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">可可的抽象类是什么？</h1><p id="edcc" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">可可不提供任何所谓的抽象。它可以创建一个只在运行时检查的类抽象，而在编译时不检查它。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="e37a" class="mt lc iy mp b gy mu mv l mw mx">@interface AbstractClass : NSObject<br/>@end<br/>@implementation AbstractClass<br/>+ (id)alloc{<br/>    if (self == [AbstractClass class]) {<br/>        NSLog(@"Abstract Class can’t be used");<br/>    }<br/>    return [super alloc];<br/>@end</span></pre></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="cf80" class="lb lc iy bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">willFinishLaunchingWithOptions()和didFinishLaunchingWithOptions()</h1><p id="3f8d" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">这两种方法都存在于AppDelegate.swift文件中。它们用于在应用程序启动时向应用程序添加功能。</p><p id="1e8d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe mz na nb mp b">application:willFinishLaunchingWithOptions</code>—这个方法是你的应用在启动时第一次执行代码的机会。</p><p id="f748" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe mz na nb mp b">application:didFinishLaunchingWithOptions</code>—此方法允许您在向用户显示应用程序之前执行任何最终初始化。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="f1a6" class="lb lc iy bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Swift的优势和劣势</h1><p id="5b90" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">重要的Swift特性:静态类型、协议、引用类型、值类型、可选、泛型。</p><p id="3174" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">那么静态类型呢？</strong> <br/>它允许协议、泛型和可选性存在，并在编码时提供帮助(带提示)。<br/>在编译时和编译错误时显示警告。<br/>提供运行时安全性和确定性(可选、var/let、一般或具体类型等。)</p><p id="febd" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">同时，当你构建需要更多灵活性的东西时，比如构建一个库或者一个框架，静态类型可能限制太多。在这方面，Objective-C可能是更好的选择，因为它提供了比Swift更好的元编程能力。(尽管在这一点上Objective-C可能会过时，苹果平台的所有开发都应该在Swift中完成)</p><p id="2a93" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以Swift是一种强类型语言，这可能是它最大的特点，同时也是它的优势和劣势。这是该语言提供的最大优势之一。(<strong class="jx iz">类型安全！</strong></p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="d0d3" class="lb lc iy bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">JSONSerialization有哪些渲染选项？</h1><ol class=""><li id="6b48" class="nj nk iy jx b jy lz kc ma kg ny kk nz ko oa ks ob np nq nr bi translated">可变容器:数组和字典被创建为可变对象，而不是常量。</li><li id="9382" class="nj nk iy jx b jy ns kc nt kg nu kk nv ko nw ks ob np nq nr bi translated">可变叶:JSON对象图中的叶字符串是作为变量字符串的实例创建的。</li><li id="8421" class="nj nk iy jx b jy ns kc nt kg nu kk nv ko nw ks ob np nq nr bi translated">allowFragments:解析器应该允许不是数组或字典实例的顶级对象。</li></ol></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="abf4" class="lb lc iy bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">什么是iOS应用程序，你的代码适合它吗？</h1><p id="774d" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">典型的iOS应用程序只是代码块，当然还有一个巨大的运行循环。它等待用户输入，并被外部信号中断，如电话呼叫、推送通知、home手势/按钮按压和其他应用程序生命周期事件。唯一的区别是，它不是一个简单的主循环函数，每次用户点击你的应用程序图标时都会启动，而是具有更高的抽象级别，开发人员可以使用的<a class="ae nd" href="https://developer.apple.com/documentation/uikit/uiapplication" rel="noopener ugc nofollow" target="_blank"> UIApplication </a>、<a class="ae nd" href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate" rel="noopener ugc nofollow" target="_blank"> AppDelegate </a>和<a class="ae nd" href="https://developer.apple.com/documentation/uikit/uiscenedelegate" rel="noopener ugc nofollow" target="_blank"> SceneDelegate </a>。</p><p id="9f13" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">好处:</strong>您编写的实现应用程序业务逻辑的其余代码被放在“触发点”的某个地方，由主循环通过<code class="fe mz na nb mp b">AppDelegate</code>或<code class="fe mz na nb mp b">SceneDelegate</code>委托给我们的应用程序。在iOS 13之前，<code class="fe mz na nb mp b">AppDelegate</code>负责接收应用程序的所有外部事件并旋转UI，但从iOS 13开始，所有与UI相关的逻辑都被转移到了SceneDelegate。</p><p id="c086" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就是这样。简单。你为你的应用程序编写的代码可以像方法/函数调用一样简单，也可以像<strong class="jx iz"> VIPER </strong>架构一样复杂和伟大:)</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="5dc7" class="lb lc iy bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">什么是MVC？</h1><p id="8983" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">MVC代表模型视图控制器。这是一种软件设计模式，苹果公司选择它作为iOS应用开发的主要方法。<strong class="jx iz">模型</strong>代表应用数据；<strong class="jx iz">视图</strong>在屏幕上画东西；<strong class="jx iz">控制器</strong>管理模型和视图之间的数据流。模型和视图从不直接相互通信，而是依靠控制器来协调通信。</p><p id="e8f8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">导致“海量视图控制器”问题！！所以你应该寻找更多的建筑设计原则(MVVM、MVP、VIPER、VIP、CleanSwift等。)</strong></p><p id="28f6" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">iOS应用程序中每个Apple MVC层的典型代表是:</p><ul class=""><li id="20da" class="nj nk iy jx b jy jz kc kd kg nl kk nm ko nn ks no np nq nr bi translated"><a class="ae nd" href="https://developer.apple.com/documentation/uikit/uiview" rel="noopener ugc nofollow" target="_blank"> UIView </a>子类(Cocoa Touch或custom)是视图</li><li id="b17d" class="nj nk iy jx b jy ns kc nt kg nu kk nv ko nw ks no np nq nr bi translated"><a class="ae nd" href="https://developer.apple.com/documentation/uikit/uiviewcontroller" rel="noopener ugc nofollow" target="_blank"> UIViewControllers </a>及其子类是控制器</li><li id="573c" class="nj nk iy jx b jy ns kc nt kg nu kk nv ko nw ks no np nq nr bi translated">任何数据对象、<a class="ae nd" href="https://developer.apple.com/documentation/coredata/nsmanagedobject" rel="noopener ugc nofollow" target="_blank"> NSManagedObject </a>子类和类似的都是模型</li></ul></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="fddf" class="lb lc iy bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">单身族呢？</h1><p id="63c6" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">Singleton是一个类，无论你请求多少次，它都只返回一个相同的实例。</p><p id="7d6d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">单件有时被认为是一种反模式。使用单件有许多缺点。主要的是全局状态、对象生命周期和依赖注入。当你只有一个实例时，很容易直接引用和使用它，而不是把它注入到你的对象中。这会导致代码中不必要的具体实现耦合，而不是使用接口抽象。</p><p id="bd6d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">“方便的”单例的另一个恶意副作用是全局状态。通常，单例支持全局状态共享，并充当每个对象用来存储状态的“公共包”的角色。当这种不受控制的状态被某人覆盖或删除时，会导致不可预测的结果、错误或崩溃。</p><p id="c9a5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你使用过苹果的框架，那么你很可能已经使用过单例模式。他们可能看起来很眼熟。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="7fb5" class="mt lc iy mp b gy mu mv l mw mx"><strong class="mp iz">// Shared URL Session<br/>let sharedURLSession = URLSession.shared</strong></span><span id="1db7" class="mt lc iy mp b gy my mv l mw mx"><strong class="mp iz">// Default File Manager<br/>let defaultFileManager = FileManager.default</strong></span><span id="adf0" class="mt lc iy mp b gy my mv l mw mx"><strong class="mp iz">// Standard User Defaults<br/>let standardUserDefaults = UserDefaults.standard</strong></span><span id="4ef6" class="mt lc iy mp b gy my mv l mw mx"><strong class="mp iz">// Default Payment Queue<br/>let defaultPaymentQueue = SKPaymentQueue.default()</strong></span></pre><p id="c9d5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是单例模式有一个副作用，这通常是采用单例模式的真正原因，<strong class="jx iz">全局访问</strong>。但是对单例对象的全局访问只不过是单例模式的副作用。</p><p id="e0c4" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不幸的是，许多开发人员使用singleton模式从项目的任何地方轻松访问singleton对象。默认的支付队列可以通过<code class="fe mz na nb mp b">default()</code>类方法访问。这意味着项目中的任何对象都可以访问默认的付款队列。虽然这很方便，但这种方便是有代价的。</p><p id="b610" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">如果你想了解更多关于单例模式的问题，那么你应该阅读</strong> <a class="ae nd" href="https://cocoacasts.com/are-singletons-bad/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx iz">单例模式不好吗</strong> </a> <strong class="jx iz">。</strong></p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="c6a1" class="lb lc iy bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">代表和KVO呢？</h1><p id="0dd6" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">两者都是在对象之间建立关系的方式。</p><p id="e990" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae nd" href="https://developer.apple.com/library/archive/documentation/General/Conceptual/DevPedia-CocoaCore/Delegation.html" rel="noopener ugc nofollow" target="_blank">委托</a>是一对一的关系，一个对象实现一个委托协议；另一个使用协议定义的方法向它发送消息。</p><p id="101c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae nd" href="https://developer.apple.com/library/archive/documentation/General/Conceptual/DevPedia-CocoaCore/KVO.html" rel="noopener ugc nofollow" target="_blank"> KVO </a>是一个多对多的关系，其中一个对象广播一条消息，一个或多个其他对象监听这条消息并做出反应。KVO不依赖协议。(<code class="fe mz na nb mp b"><strong class="jx iz">NSNotification</strong></code> &amp; <code class="fe mz na nb mp b"><strong class="jx iz">NSNotificationCenter</strong></code>)</p><p id="2b5b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">键值观察是Swift将代码附加到变量上的能力，因此无论变量何时改变，代码都会运行。类似于属性观察者(<code class="fe mz na nb mp b"><strong class="jx iz">willSet</strong></code>和<code class="fe mz na nb mp b"><strong class="jx iz">didSet</strong></code>)，除了KVO是用来在类型定义的之外添加观察者<em class="kt">。</em></p><p id="46eb" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">KVO在纯Swift代码中并不是很好，因为它依赖于Objective-C运行时——你需要使用从<code class="fe mz na nb mp b"><strong class="jx iz">NSObject</strong></code>继承的<code class="fe mz na nb mp b"><strong class="jx iz">@objc</strong></code>类，然后用<code class="fe mz na nb mp b"><strong class="jx iz">@objc dynamic</strong></code>标记你的每个属性。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="b400" class="lb lc iy bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">坚实的原则呢？</h1><p id="3eb8" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated"><strong class="jx iz">固体</strong>代表<a class="ae nd" href="https://www.oodesign.com/single-responsibility-principle.html" rel="noopener ugc nofollow" target="_blank">单一责任原则</a>、<a class="ae nd" href="https://www.oodesign.com/open-close-principle.html" rel="noopener ugc nofollow" target="_blank">开/闭原则</a>、<a class="ae nd" href="https://www.oodesign.com/liskov-s-substitution-principle.html" rel="noopener ugc nofollow" target="_blank">利斯科夫替代原则</a>、<a class="ae nd" href="https://www.oodesign.com/interface-segregation-principle.html" rel="noopener ugc nofollow" target="_blank">接口分离原则</a>、<a class="ae nd" href="https://www.oodesign.com/dependency-inversion-principle.html" rel="noopener ugc nofollow" target="_blank">依赖倒置原则</a>。这些原则相互补充、相互支持，是您可以为代码采用的最佳通用设计方法之一。让我们逐一查看。</p><p id="14e1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">单一责任原则(SRP) </strong>是集团最重要的原则。它规定每个模块应该只有一个责任和理由去改变。SRP从具体的小例子开始，比如一个类和/或一个对象只有一个目的，并且只用于一件事。</p><p id="859a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">开放/封闭原则(OCP) </strong>声明你的模块应该对扩展开放，但对修改关闭。这是一件听起来很容易的事情，但是当你开始思考它的含义时，你就很难理解了。实际上，这意味着在编写代码时，您应该能够通过使用接口、抽象和依赖注入来实现对象，从而通过继承、多态和组合来扩展对象的行为。</p><p id="283d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">李斯科夫替换原则(LSP) </strong>声明程序中的对象应该可以用其子类型的实例替换，而不改变程序的正确性。这意味着，当你从一个类或抽象类继承或实现一个接口(协议)时，你的对象应该是可替换的和可注入的，无论你从哪个接口或类派生出子类。这一原则通常被称为契约式设计，或者最近在<strong class="jx iz"> Swift社区中被称为面向协议的编程。这个原则的主要信息是，你不应该违反你的接口从承诺到履行的契约，并且通过子类化，那些子类可以在超类以前被使用的任何地方被使用。</strong></p><p id="b4aa" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">接口隔离原则(ISP) </strong>认为许多特定于客户端的接口比一个通用接口要好。它还指出，不应该强迫任何客户端依赖和实现它不使用的方法。这意味着，当你创建你的类实现的接口(协议)时，你应该努力并依赖抽象而不是具体，但不要等到你必须实现一堆你的新类甚至没有使用的方法时，这就成了一种浪费。</p><p id="b898" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">依赖倒置原则(DIP) </strong>声明，“依赖抽象，而不是具体化。”展示这一原则的最好例子是依赖注入(DI)技术。使用依赖注入技术，当您创建一个对象时，您在初始化或配置时提供并注入它的所有依赖，而不是让对象为自己创建或获取/找到它的依赖。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="42fe" class="lb lc iy bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">在iOS上实现存储和持久化有哪些选择？</strong></h1><p id="9fea" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated"><strong class="jx iz">内存中的数组、字典、集合和其他数据结构</strong>非常适合于中间存储数据或者不需要持久存储的数据。</p><p id="21ff" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">NSUserDefaults/Keychain 是简单的键值存储。一个是不安全的，另一个是安全的。</p><p id="7933" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">文件/磁盘存储</strong>是一种使用<a class="ae nd" href="https://developer.apple.com/documentation/foundation/nsfilemanager" rel="noopener ugc nofollow" target="_blank"> NSFileManager </a>向/从磁盘写入数据(序列化或非序列化)的方式。</p><p id="482d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">核心数据和领域是简化数据库工作的框架。</p><p id="d99d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz"> SQLite </strong>是一个关系数据库，当您需要实现复杂的查询机制，而核心数据或领域无法满足您的需求时，它是一个不错的选择。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="0a7e" class="lb lc iy bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">iOS上有哪些联网和HTTP的选项？</h1><p id="eee1" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">在IOS中有几个选项来实现<a class="ae nd" href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol" rel="noopener ugc nofollow" target="_blank"> HTTP </a>联网。你可以继续使用好的旧的<a class="ae nd" href="https://developer.apple.com/documentation/foundation/urlsession" rel="noopener ugc nofollow" target="_blank">nsursession</a>，但是除非你把它抽象得足够好，否则它会让人望而生畏。另一种选择是在它周围使用一个包装库。iOS上最流行的解决方案是<a class="ae nd" href="https://github.com/Alamofire/Alamofire" rel="noopener ugc nofollow" target="_blank"> Alamofire </a>。</p><p id="9aa4" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如今，<strong class="jx iz"> NSURLSession </strong>和<strong class="jx iz"> Codable </strong>是iOS上用于联网的两种主要技术，但了解开源解决方案如<strong class="jx iz"> Alamofire </strong>也是有益的。</p><p id="7b8d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">更多信息:</p><ul class=""><li id="2fed" class="nj nk iy jx b jy jz kc kd kg nl kk nm ko nn ks no np nq nr bi translated"><a class="ae nd" href="https://developer.apple.com/documentation/foundation/nsurlsession" rel="noopener ugc nofollow" target="_blank">恩苏尔塞申(developer.apple.com)</a></li><li id="a1ae" class="nj nk iy jx b jy ns kc nt kg nu kk nv ko nw ks no np nq nr bi translated"><a class="ae nd" href="https://developer.apple.com/documentation/swift/codable" rel="noopener ugc nofollow" target="_blank">可编码的(developer.apple.com)</a></li><li id="446b" class="nj nk iy jx b jy ns kc nt kg nu kk nv ko nw ks no np nq nr bi translated"><a class="ae nd" href="https://github.com/Alamofire/Alamofire" rel="noopener ugc nofollow" target="_blank">阿拉莫费尔(github.com)</a></li><li id="0806" class="nj nk iy jx b jy ns kc nt kg nu kk nv ko nw ks no np nq nr bi translated"><a class="ae nd" href="https://en.wikipedia.org/wiki/Representational_state_transfer" rel="noopener ugc nofollow" target="_blank">具象状态转移(休息)</a></li></ul></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="ead2" class="lb lc iy bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">如何以及何时在iOS上序列化和映射数据？</h1><p id="d78e" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">在两种最常见的情况下，您需要在ios应用程序中序列化和映射数据:</p><p id="13d1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">在网络层接收或发送数据</strong>(如JSON或XML或其他)</p><p id="7e83" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">保存或检索存储层中的模型</strong> (NSData，NSManagedObject)。</p><p id="0f1f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每次从后端API收到JSON或XML或任何其他响应类型的响应时，您很可能会得到JSON或二进制或其他“不方便”的格式。</p><p id="dc74" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">首先:处理你收到的数据</strong>就是把它序列化成你的应用程序能理解的东西。在最简单和最基本的层次上，这将是一个字典或一个对象数组，其中包含来自该响应的其他字典、数组和原语。NSJSONSerialization会解决这个问题。</p><p id="fe4d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下一步是将数据映射到应用程序的域模型中。这些将是模型对象或结构，供应用程序的其余部分使用。你既可以手动完成，也可以使用苹果提供的<code class="fe mz na nb mp b">Codable</code>协议，或者使用Mantle或SwiftyJSON之类的库。数据和序列化/映射的流程是:<code class="fe mz na nb mp b">binary data</code>-&gt;-<code class="fe mz na nb mp b">json</code>-&gt;-<code class="fe mz na nb mp b">NSDictionary/NSArray</code>-&gt;-<code class="fe mz na nb mp b">your domain model objects</code>。<strong class="jx iz">加油，用Codable！</strong></p><p id="c953" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">类似地，在存储层，您需要将数据序列化并映射到您的自定义域模型对象，以及从您的自定义域模型对象映射到您的存储理解的格式。读取数据的“映射”链:<code class="fe mz na nb mp b">db</code>-&gt;-<code class="fe mz na nb mp b">raw data format</code>-&gt;-<code class="fe mz na nb mp b">custom domain models</code>；而对于写作:<code class="fe mz na nb mp b">custom domain models</code>-&gt;-<code class="fe mz na nb mp b">raw data format</code>-&gt;-<code class="fe mz na nb mp b">db</code>。您可以在这里使用NSManagedObject或NSCoding或Codable协议来实现这一点。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="0971" class="lb lc iy bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">优化动态调整表或集合视图的滚动性能</h1><p id="9d07" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">主要难点是细胞高度计算。当用户滚动时，每个下一个单元格都需要计算其内容和高度，然后才能显示。</p><p id="63f5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你做手动框架视图布局，那么它更有性能，但挑战是得到正确的高度和大小计算。如果您使用自动布局，那么挑战在于正确设置所有约束。但是，即使AutoLayout本身也可能需要一些时间来计算单元格高度，并且您的滚动性能会受到影响。</p><p id="1b24" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">滚动性能问题的潜在解决方案可能是:<br/>自己计算单元格高度<br/>保留一个用内容填充的原型单元格，并用它来计算单元格高度</p><blockquote class="me mf mg"><p id="6593" class="jv jw kt jx b jy jz ka kb kc kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ks ig bi translated">或者，你可以采取一个完全激进的方法，这是使用不同的技术，如ASDK(纹理)。ASDK(纹理)是专为具有动态内容大小的列表视图而设计的，并针对在后台线程中计算单元格高度进行了优化，这使得它具有超强的性能。</p></blockquote></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="29d3" class="lb lc iy bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">管理依赖关系</h1><p id="7549" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">您可以从CocoaPods、Carthage和Swift Package Manager中选择依赖项管理器。</p><p id="7bf6" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">更多信息:</p><ul class=""><li id="a8db" class="nj nk iy jx b jy jz kc kd kg nl kk nm ko nn ks no np nq nr bi translated"><a class="ae nd" href="https://cocoapods.org/" rel="noopener ugc nofollow" target="_blank">椰子恐龙(cocoapods.org)</a></li><li id="85ec" class="nj nk iy jx b jy ns kc nt kg nu kk nv ko nw ks no np nq nr bi translated">【github.com/Carthage T2】迦太基</li><li id="fc0d" class="nj nk iy jx b jy ns kc nt kg nu kk nv ko nw ks no np nq nr bi translated">【swift.org】Swift套餐经理<a class="ae nd" href="https://swift.org/package-manager/" rel="noopener ugc nofollow" target="_blank">s</a></li></ul></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="4306" class="lb lc iy bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">调试并分析XCode上的代码</h1><p id="76ce" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">iOS应用程序中总是有<code class="fe mz na nb mp b">NSLog</code>ing和<code class="fe mz na nb mp b">print</code> ing。您可以使用Xcode设置断点。对于个别代码的性能，您可以使用XCTest的measureBlock。太棒了:)请观看wwdc视频，了解XCode中<a class="ae nd" href="https://developer.apple.com/videos/play/wwdc2019/412/" rel="noopener ugc nofollow" target="_blank">调试的详细信息。</a></p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="5959" class="lb lc iy bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">plist呢？</h1><p id="e4ba" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">特性列表或plist是指使用几种对象类型将数据组织成命名值和值列表的列表。这些类型为我们提供了生成有意义的结构化、可传输、可存储和可访问的数据的方法，但仍然尽可能高效。在Mac OS X和iOS上运行的应用程序经常使用属性列表。【Cocoa和Core Foundation的属性列表编程接口允许我们将这些基本类型对象的分层结构组合转换成标准XML，或者从标准XML转换过来。我们可以将XML数据保存到磁盘上，然后用它来重建原始对象。</p><p id="bca9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们通过NSUserDefaults类以编程方式访问的用户默认系统使用属性列表来存储代表用户首选项的对象。这种限制似乎将许多类型的对象排除在用户默认系统之外，例如NSColor和NSFont对象。但是，如果对象符合NSCoding协议，则可以将它们归档到NSData对象，这是与特性列表兼容的对象。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="322a" class="lb lc iy bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">重用标识符的目的是什么？将其设置为非零值有什么好处？</h1><p id="0ae3" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">重用标识符用于将UITableView中的相似行组合在一起，即仅在内容上有所不同但布局相似的行。UITableView通常会分配足够的UITableViewCell对象来显示表中可见的内容。</p><p id="65bf" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">好处:</strong>如果reuseIdentifier设置为非零值，那么当表视图滚动时，UITableView将首先尝试重用已经分配的具有相同reuseIdentifier的UITableViewCell。如果未设置reuseIdentifier，则UITableView将被迫为滚动到视图中的每个新项目分配新的UITableViewCell对象，这可能会导致动画滞后。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="6ff2" class="lb lc iy bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">小问题:)</h1><p id="7619" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">哪个是用于构建iOS应用程序用户界面的框架？<br/>ui kit框架用于为iOS开发应用程序的用户界面。它提供了专门为触摸屏界面设计的事件处理、绘图模型、窗口、视图和控件。</p><p id="129f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">应该从哪个应用线程使用UIKit类？<br/> </strong> UIKit类只能在应用程序的主线程中使用。</p><p id="8b6b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你会使用哪种API来编写测试脚本来测试应用程序的UI元素？<br/>  UI自动化API用于自动化测试程序。写入UI自动化API的JavaScript测试脚本模拟用户与应用程序的交互，并将日志信息返回给主机。</p><p id="b23e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">什么是SpriteKit，什么是SceneKit？SpriteKit是一个用于轻松开发动画2D对象的框架。<br/> SceneKit是一个继承自OS X的框架，用于辅助3D图形渲染。预计SpriteKit、SceneKit和Metal将驱动新一代移动游戏，这些游戏将重新定义iOS设备强大的GPU所能提供的功能。</strong></p><p id="b866" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">什么是iBeacons？iBeacon.com将iBeacon定义为苹果的技术标准，它允许移动应用程序监听来自物理世界的信号并做出相应的反应。<br/> iBeacon技术允许移动应用程序在微观本地范围内了解自己的位置，并根据位置向用户提供超上下文内容。<br/>底层通信技术是蓝牙低能耗。</strong></p><p id="8f69" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">在NSObject之前，UIButton的层次结构是什么？<br/> </strong> UIButton继承自UIControl，UIControl继承自UIView，UIView继承自UIResponder，UIResponder继承自根类NSObject。</p><p id="b2a7" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">什么是swizzling方法？<br/> 方法重组是在运行时改变现有选择器的实现的过程。在运行时，<strong class="jx iz"> <em class="kt">可以改变</em> </strong> <em class="kt"> </em>方法的功能，但只能在objective-c中实现</p><p id="1b0f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">什么是未命名类别？由于@protocol已经扩展到支持@optional方法，一个未命名的类别已经失宠。</strong></p><p id="3e18" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Objective-C包含私有方法吗？</p><p id="575d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不，在Object-C编程中没有所谓的私有方法。如果方法是在。m only，那么它就变得受保护了；如果它是在。h，它是公共的。</p><p id="b479" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们真的想要一个私有方法，那么我们需要在类中添加一个本地类别/未命名类别/类扩展，并在类别中添加方法，并在class.m中定义它。</p></div></div>    
</body>
</html>