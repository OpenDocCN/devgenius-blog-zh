<html>
<head>
<title>JS Series #14: Advance JS Features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JS 系列#14:高级 JS 特性</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/js-series-14-advance-js-features-cd4eab15bbd?source=collection_archive---------14-----------------------#2022-03-08">https://blog.devgenius.io/js-series-14-advance-js-features-cd4eab15bbd?source=collection_archive---------14-----------------------#2022-03-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="46f8" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">默认参数，休息和传播和解构</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/c09757e03c66199b60728d55b8b53117.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aCwa06Yo3w6BFUJgFPrvww.png"/></div></div></figure><p id="50b0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在我们之前的文章中，我们已经介绍了很多新的 JavaScript 特性。现代 Js 引入了许多新功能，如下所列…</p><ol class=""><li id="e0b6" class="lk ll in kq b kr ks ku kv kx lm lb ln lf lo lj lp lq lr ls bi translated">箭头功能</li><li id="00aa" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">字符串模板文字</li><li id="3568" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">保持不变</li><li id="4e84" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">为了…在</li><li id="e95c" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">为了…的</li><li id="8dc2" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">指数算子</li><li id="7798" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">String.includes()</li><li id="6f2b" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">Array.includes()</li><li id="2d3e" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">Object.values()</li><li id="58f2" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">休息和伸展</li><li id="0c99" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">解构</li><li id="2446" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">默认参数函数</li><li id="fad8" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">对象增强</li><li id="d81f" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">班级</li><li id="d719" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">异步和等待</li></ol></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><p id="87e4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们在之前的文章中已经讨论了很多。在本文中，我们主要关注四个特性。</p><ol class=""><li id="0113" class="lk ll in kq b kr ks ku kv kx lm lb ln lf lo lj lp lq lr ls bi translated">默认参数函数</li><li id="dc66" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">传播</li><li id="2bca" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">休息参数</li><li id="d8fe" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">解构</li></ol></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><h1 id="a60f" class="mf mg in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">默认参数函数</h1><p id="6b47" class="pw-post-body-paragraph ko kp in kq b kr mx jo kt ku my jr kw kx mz kz la lb na ld le lf nb lh li lj ig bi translated"><code class="fe nc nd ne nf b">Default parameter function</code>是一种在<code class="fe nc nd ne nf b">function definition</code>中创建<code class="fe nc nd ne nf b">optional</code>参数的方法，可以在方法调用时跳过这些参数。</p><h2 id="40f5" class="ng mg in bd mh nh ni dn ml nj nk dp mp kx nl nm mr lb nn no mt lf np nq mv nr bi translated">示例— 1 |常规函数</h2><pre class="kd ke kf kg gt ns nf nt nu aw nv bi"><span id="f751" class="ng mg in nf b gy nw nx l ny nz">function multiply(x , y) {<br/>   return x * y;<br/>}</span><span id="65bd" class="ng mg in nf b gy oa nx l ny nz">multiply(3,5); // 15<br/>multiply(5); // NaN</span></pre><p id="8db8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">正如你在上面的例子中看到的，这个函数需要 2 个参数。当用两个参数调用<code class="fe nc nd ne nf b">multiply(3, 5)</code>时，它返回预期的输出。</p><p id="e81c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是当第二个参数被跳过时，第二个参数被当作<code class="fe nc nd ne nf b">undefined</code>处理，表达式变成<code class="fe nc nd ne nf b">x * undefined</code>导致<code class="fe nc nd ne nf b">NaN</code>值。</p><p id="64c1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，我们可以改进函数，以获得更好、更有意义的结果，如下所示…</p><pre class="kd ke kf kg gt ns nf nt nu aw nv bi"><span id="ccda" class="ng mg in nf b gy nw nx l ny nz"><strong class="nf io">Example-1:</strong><br/>function multiply(x , y) {<br/>   if(y === undefined) {<br/>       y = 1;<br/>   }</span><span id="b1f7" class="ng mg in nf b gy oa nx l ny nz">   return x * y;<br/>}</span><span id="7c0b" class="ng mg in nf b gy oa nx l ny nz"><strong class="nf io">Example-2:<br/></strong>function multiply(x , y) {   <br/>   y = y === undefined ? 1 : y;<br/>   return x * y;<br/>}</span><span id="d671" class="ng mg in nf b gy oa nx l ny nz">multiply(3,5); // 15<br/>multiply(5); // <!-- -->5</span></pre><p id="da1e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在上面的例子中，如果变量<code class="fe nc nd ne nf b">y</code>是<code class="fe nc nd ne nf b">undefined</code>，我们有意将<code class="fe nc nd ne nf b">1</code>赋给变量<code class="fe nc nd ne nf b">y</code>。</p><p id="df64" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">JS 中介绍的更好的方法是<code class="fe nc nd ne nf b">default argument parameter</code>。请参见下面的示例…</p><h2 id="292c" class="ng mg in bd mh nh ni dn ml nj nk dp mp kx nl nm mr lb nn no mt lf np nq mv nr bi translated">示例-默认参数函数</h2><pre class="kd ke kf kg gt ns nf nt nu aw nv bi"><span id="d5b0" class="ng mg in nf b gy nw nx l ny nz">function multiply(x , y = 1) {<br/>    return x * y;<br/>}</span><span id="26ba" class="ng mg in nf b gy oa nx l ny nz">multiply(9,10) // 90<br/>multiply(5) // 5</span></pre><p id="3379" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在上面的例子中，如果<code class="fe nc nd ne nf b">second parameter</code>通过，那么它覆盖<code class="fe nc nd ne nf b">default parameter</code>，否则使用<code class="fe nc nd ne nf b">default parameter</code>值。</p></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><h1 id="7217" class="mf mg in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">传播算子</h1><p id="8b5d" class="pw-post-body-paragraph ko kp in kq b kr mx jo kt ku my jr kw kx mz kz la lb na ld le lf nb lh li lj ig bi translated">根据 MDN，<strong class="kq io"> Spread 语法</strong> ( <code class="fe nc nd ne nf b">...</code>)允许在需要零个或多个参数<strong class="kq io">(对于函数调用)</strong>或元素<strong class="kq io">(对于数组文字)</strong>的地方扩展一个可迭代的表达式，比如一个<code class="fe nc nd ne nf b">array</code>表达式或字符串，或者在需要零个或多个键值对<strong class="kq io">(对于对象文字)</strong>的地方扩展一个对象表达式。</p><p id="22e1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如上面定义中所强调的，<code class="fe nc nd ne nf b">Spread</code>用于 3 种情况…</p><ol class=""><li id="9f47" class="lk ll in kq b kr ks ku kv kx lm lb ln lf lo lj lp lq lr ls bi translated">函数调用</li><li id="8964" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">数组文字</li><li id="3607" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated">对象文字</li></ol><p id="3e4a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们逐一讨论以上 3 个用例。</p><h2 id="9c8d" class="ng mg in bd mh nh ni dn ml nj nk dp mp kx nl nm mr lb nn no mt lf np nq mv nr bi translated">函数调用中的扩展运算符</h2><pre class="kd ke kf kg gt ns nf nt nu aw nv bi"><span id="26a0" class="ng mg in nf b gy nw nx l ny nz">function sum(a,b,c) {<br/>    return a + b + c;<br/>}</span><span id="c5b2" class="ng mg in nf b gy oa nx l ny nz">console.log(sum(1,2,3)); // 6<br/>console.log(sum([1,2,3])); // '1,2,3undefinedundefined'</span></pre><p id="f427" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">正如你在上面的例子中所看到的，<code class="fe nc nd ne nf b">sum()</code>函数接受 3 个数值，当它作为<code class="fe nc nd ne nf b">sum(1,2,3) </code>被调用时，它返回<code class="fe nc nd ne nf b">6</code>，但是当它被像<code class="fe nc nd ne nf b">sum([1,2,3])</code>一样的<code class="fe nc nd ne nf b">array</code>调用时，整个<code class="fe nc nd ne nf b">array</code>变成了<code class="fe nc nd ne nf b">first argument</code>，第二个和第三个参数保持不变<code class="fe nc nd ne nf b">undefined</code>导致所有 3 个值的连接。</p><p id="aadb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是使用<code class="fe nc nd ne nf b">spread</code>操作符，来自数组的所有 3 个值可以分别扩展成 3 个变量。</p><pre class="kd ke kf kg gt ns nf nt nu aw nv bi"><span id="193f" class="ng mg in nf b gy nw nx l ny nz">sum(...[1,2,3]); // 6</span></pre><p id="0027" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们再看一个使用<code class="fe nc nd ne nf b">Math.max()</code>函数找到最大值的例子。</p><pre class="kd ke kf kg gt ns nf nt nu aw nv bi"><span id="f702" class="ng mg in nf b gy nw nx l ny nz">console.log(Math.max(1,3,9,2,88,5)) // 88<br/>console.log(Math.max([1,5,2])) // NaN<br/>console.log(Math.max(...[1,5,2])) // 5</span></pre><p id="270b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">正如您已经知道的，<code class="fe nc nd ne nf b">Math.max()</code>函数接受 2 个或更多参数来查找<code class="fe nc nd ne nf b">max</code>值。</p><p id="1c93" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如上例所示，当您在<code class="fe nc nd ne nf b">max()</code>函数中传递一个<code class="fe nc nd ne nf b">array </code>时，它会返回<code class="fe nc nd ne nf b">NaN</code>。通过使用<code class="fe nc nd ne nf b">spread</code>操作符，我们可以解决这个问题，因为<code class="fe nc nd ne nf b">spread</code>操作符将扩展<code class="fe nc nd ne nf b">array</code>值。</p><h2 id="199c" class="ng mg in bd mh nh ni dn ml nj nk dp mp kx nl nm mr lb nn no mt lf np nq mv nr bi translated">在数组文字中展开</h2><p id="1621" class="pw-post-body-paragraph ko kp in kq b kr mx jo kt ku my jr kw kx mz kz la lb na ld le lf nb lh li lj ig bi translated"><code class="fe nc nd ne nf b">array</code>文字中的<code class="fe nc nd ne nf b">Spread</code>运算符使用现有数组创建一个新的<code class="fe nc nd ne nf b">array</code>。将一个<code class="fe nc nd ne nf b">array</code>中的元素分散到一个新的<code class="fe nc nd ne nf b">array</code>中。</p><pre class="kd ke kf kg gt ns nf nt nu aw nv bi"><span id="c431" class="ng mg in nf b gy nw nx l ny nz">const nums1 = [1,2,3];<br/>const nums2 = [4,5,6];</span><span id="acac" class="ng mg in nf b gy oa nx l ny nz">const nums = [...nums1,...nums2];<br/>console.log(nums); // [1, 2, 3, 4, 5, 6]</span><span id="21dc" class="ng mg in nf b gy oa nx l ny nz">console.log([...nums1,...nums2,7,8,9]); // [1, 2, 3, 4, 5, 6, 7, 8, 9]</span><span id="373c" class="ng mg in nf b gy oa nx l ny nz">console.log(['x','y',...nums1]); // ['x', 'y', 1, 2, 3]</span></pre><h2 id="1c9a" class="ng mg in bd mh nh ni dn ml nj nk dp mp kx nl nm mr lb nn no mt lf np nq mv nr bi translated">在对象文字中传播</h2><p id="ec27" class="pw-post-body-paragraph ko kp in kq b kr mx jo kt ku my jr kw kx mz kz la lb na ld le lf nb lh li lj ig bi translated"><code class="fe nc nd ne nf b">object</code>中的<code class="fe nc nd ne nf b">Spread</code>文字将属性从一个<code class="fe nc nd ne nf b">object</code>复制到另一个<code class="fe nc nd ne nf b">object</code>文字。</p><pre class="kd ke kf kg gt ns nf nt nu aw nv bi"><span id="fa64" class="ng mg in nf b gy nw nx l ny nz">const person = {name:'Alex', age:44 , salary: 100000};<br/>const student = {name:'Alia',age:22, marks: 85};</span><span id="3807" class="ng mg in nf b gy oa nx l ny nz">const studentInfo = {...student,fees:50000}<br/>console.log(studentInfo); // {name: 'Alia', age: 22, marks: 85, fees: 50000}</span><span id="65a2" class="ng mg in nf b gy oa nx l ny nz">const personInfo = {gender:'male',...person};<br/>console.log(personInfo); // {gender: 'male', name: 'Alex', age: 44, salary: 100000}</span><span id="fda8" class="ng mg in nf b gy oa nx l ny nz">const obj = {...student,...person}<br/>console.log(obj); // {name: 'Alex', age: 44, marks: 85, salary: 100000}</span></pre><p id="005c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果两个<code class="fe nc nd ne nf b">objects</code>相同，那么顺序中后面出现的<code class="fe nc nd ne nf b">object’s property</code>将覆盖前面的。</p></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><h1 id="d7f0" class="mf mg in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">休息参数</h1><p id="769d" class="pw-post-body-paragraph ko kp in kq b kr mx jo kt ku my jr kw kx mz kz la lb na ld le lf nb lh li lj ig bi translated"><code class="fe nc nd ne nf b">Rest parameter</code>是<code class="fe nc nd ne nf b">ES6</code>中引入的另一个令人兴奋的特性。它所代表的<code class="fe nc nd ne nf b">3 dots(…)</code>看起来与<code class="fe nc nd ne nf b">spread</code>相似但不是。其实和<code class="fe nc nd ne nf b">spread</code>运算符几乎相反。</p><p id="3078" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">与<code class="fe nc nd ne nf b">Spread operator</code>，<code class="fe nc nd ne nf b">Rest parameters</code>允许<code class="fe nc nd ne nf b">function</code>接受<code class="fe nc nd ne nf b">infinite</code>个参数作为<code class="fe nc nd ne nf b">array</code>。在其他一些编程语言中，如<code class="fe nc nd ne nf b">Java</code>，它也被称为<code class="fe nc nd ne nf b">varargs</code>。看看下面的例子就明白了<code class="fe nc nd ne nf b">Rest parameters</code>。</p><pre class="kd ke kf kg gt ns nf nt nu aw nv bi"><span id="7442" class="ng mg in nf b gy nw nx l ny nz">function sum(...args) {<br/>    let total = 0;<br/>    for(let i = 0; i &lt; args.length; i++) {<br/>        total += args[i];<br/>    }<br/>    return total;<br/>}</span><span id="edb6" class="ng mg in nf b gy oa nx l ny nz">sum(1,2,3) // 6<br/>sum(2,3,4,5) // 14</span></pre><p id="7acf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">上述示例可以通过<code class="fe nc nd ne nf b">reduce()</code>方法复制。</p><pre class="kd ke kf kg gt ns nf nt nu aw nv bi"><span id="5b7b" class="ng mg in nf b gy nw nx l ny nz">function sum(...args) {<br/>    return args.reduce((total,item) =&gt; {<br/>        return total + item;<br/>    });<br/>}</span></pre><p id="5a5e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在上面的例子中，您可以看到<code class="fe nc nd ne nf b">args</code>使用<code class="fe nc nd ne nf b">rest parameters</code>接收多个参数作为一个<code class="fe nc nd ne nf b">array</code>。</p><h2 id="ea3e" class="ng mg in bd mh nh ni dn ml nj nk dp mp kx nl nm mr lb nn no mt lf np nq mv nr bi translated">Rest 参数语法</h2><blockquote class="ob oc od"><p id="d1b4" class="ko kp oe kq b kr ks jo kt ku kv jr kw of ky kz la og lc ld le oh lg lh li lj ig bi translated"><code class="fe nc nd ne nf b">function f(a, b , …args)</code></p></blockquote><p id="ef16" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果你查看上面的<code class="fe nc nd ne nf b">rest parameter</code>的<code class="fe nc nd ne nf b">syntax</code>，你可以很容易地观察到<code class="fe nc nd ne nf b">Rest parameters</code>可以传递额外的参数，但是<code class="fe nc nd ne nf b">rest parameters</code>必须在最后被写入。</p><pre class="kd ke kf kg gt ns nf nt nu aw nv bi"><span id="abb8" class="ng mg in nf b gy nw nx l ny nz">function add(x,y,...args) {<br/>    let total = x + y;<br/>    for(let i = 0; i &lt; args.length; i++) {<br/>         total += args[i];<br/>    }<br/>    return total;<br/>}</span><span id="6a33" class="ng mg in nf b gy oa nx l ny nz">add(5,6,1,2,3,4) // 21</span></pre><p id="10d9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在上例中，前两个参数由<code class="fe nc nd ne nf b">a</code>和<code class="fe nc nd ne nf b">b</code>接收，其余参数由<code class="fe nc nd ne nf b">args</code>接收。</p><h2 id="41d9" class="ng mg in bd mh nh ni dn ml nj nk dp mp kx nl nm mr lb nn no mt lf np nq mv nr bi translated">关于 Rest 参数的要点</h2><ol class=""><li id="c59c" class="lk ll in kq b kr mx ku my kx oi lb oj lf ok lj lp lq lr ls bi translated">函数定义只能有一个 rest 参数，不允许有多个 rest 参数。</li></ol><pre class="kd ke kf kg gt ns nf nt nu aw nv bi"><span id="4e7f" class="ng mg in nf b gy nw nx l ny nz">foo(...x,...y,...z) // Invalid</span></pre><p id="2c44" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">2.rest 参数必须是函数定义中的最后一个参数。</p><pre class="kd ke kf kg gt ns nf nt nu aw nv bi"><span id="0d55" class="ng mg in nf b gy nw nx l ny nz">bar(...args, param1, param2) // Invalid</span></pre></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><h1 id="d0ab" class="mf mg in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">arguments 对象—实现 Rest 参数功能的旧方法</h1><p id="f26d" class="pw-post-body-paragraph ko kp in kq b kr mx jo kt ku my jr kw kx mz kz la lb na ld le lf nb lh li lj ig bi translated">正式的方式是，当<code class="fe nc nd ne nf b">JS</code>中没有引入<code class="fe nc nd ne nf b">Rest parameters(...args)</code>时，每个<code class="fe nc nd ne nf b">function</code>中的<code class="fe nc nd ne nf b">arguments</code>参数就是<code class="fe nc nd ne nf b">built-in</code>参数，可以接收任意数量的<code class="fe nc nd ne nf b">parameters</code>，你可以通过它<code class="fe nc nd ne nf b">iterate</code>来检索参数。</p><pre class="kd ke kf kg gt ns nf nt nu aw nv bi"><span id="fea8" class="ng mg in nf b gy nw nx l ny nz">function sum() {<br/>    let total = 0;<br/>    for(let i = 0; i &lt; arguments.length; i++) {<br/>        total += arguments[i];<br/>    }<br/>    return total;<br/>}</span><span id="be1b" class="ng mg in nf b gy oa nx l ny nz">sum(1,2,3) // 6</span></pre><p id="5618" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">每个功能都有一个名为<code class="fe nc nd ne nf b">arguments</code>的<code class="fe nc nd ne nf b">default parameter</code>来接收<code class="fe nc nd ne nf b">rest parameters</code>。其余参数是没有被任何定义的参数<code class="fe nc nd ne nf b">variables</code>接收的参数。</p></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><h1 id="007f" class="mf mg in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">Rest 参数 V/S 参数对象</h1><ol class=""><li id="a139" class="lk ll in kq b kr mx ku my kx oi lb oj lf ok lj lp lq lr ls bi translated">这个<code class="fe nc nd ne nf b">arguments</code>物体不是真正的<code class="fe nc nd ne nf b">array</code>。您不能对<code class="fe nc nd ne nf b">pop()</code>、<code class="fe nc nd ne nf b">sort()</code>、<code class="fe nc nd ne nf b">push()</code>、<code class="fe nc nd ne nf b">forEach()</code>等参数执行任何<code class="fe nc nd ne nf b">array</code>操作，而<code class="fe nc nd ne nf b">rest parameter(…args)</code>会创建一个<code class="fe nc nd ne nf b">array</code>实例，您可以使用<code class="fe nc nd ne nf b">rest parameters</code>执行上述所有<code class="fe nc nd ne nf b">array</code>操作。</li><li id="2cba" class="lk ll in kq b kr lt ku lu kx lv lb lw lf lx lj lp lq lr ls bi translated"><code class="fe nc nd ne nf b">arguments</code>对象不能使用<code class="fe nc nd ne nf b">arrow</code>功能，而<code class="fe nc nd ne nf b">rest parameters(…args)</code>可以使用<code class="fe nc nd ne nf b">arrow</code>功能。</li></ol></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><h1 id="bd0a" class="mf mg in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">解构</h1><p id="301d" class="pw-post-body-paragraph ko kp in kq b kr mx jo kt ku my jr kw kx mz kz la lb na ld le lf nb lh li lj ig bi translated"><code class="fe nc nd ne nf b">Destructuring</code>是一个<code class="fe nc nd ne nf b">short</code>或<code class="fe nc nd ne nf b">clean</code>语法，用于将<code class="fe nc nd ne nf b">Values from an array</code>、<code class="fe nc nd ne nf b">properties from an Object</code>解包到不同的变量中。</p><pre class="kd ke kf kg gt ns nf nt nu aw nv bi"><span id="9269" class="ng mg in nf b gy nw nx l ny nz">const cars = ['BMW','AUDI','VW','Maruti']<br/>const first = cars[0];<br/>const second = cars[1];</span><span id="67b3" class="ng mg in nf b gy oa nx l ny nz">console.log(first,second); // BMW AUDi</span></pre><p id="5bfb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在上面的例子中，我们已经使用<code class="fe nc nd ne nf b">index</code>从<code class="fe nc nd ne nf b">array</code>中获取了<code class="fe nc nd ne nf b">first</code>和<code class="fe nc nd ne nf b">second</code>元素。但是使用<code class="fe nc nd ne nf b">destructuring</code>可以有更干净的方法来做同样的事情，如下例所示…</p><pre class="kd ke kf kg gt ns nf nt nu aw nv bi"><span id="60f4" class="ng mg in nf b gy nw nx l ny nz">const cars = ['BMW','AUDI','VW','Maruti']<br/>const [first,second] = cars<br/>console.log(first,second) // BMW AUDI</span></pre><p id="1db4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在如果你在想，有没有办法将<code class="fe nc nd ne nf b">skip</code>元素与<code class="fe nc nd ne nf b">destructuring</code>元素结合起来？所以答案是<code class="fe nc nd ne nf b">Yes</code>。请参见下面的示例…</p><pre class="kd ke kf kg gt ns nf nt nu aw nv bi"><span id="be46" class="ng mg in nf b gy nw nx l ny nz">const cars = ['BMW','AUDI','VW','Maruti']<br/>const [first , , third] = cars<br/>console.log(first,second) // BMW VW</span></pre><p id="1550" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果您想在两个变量中收集<code class="fe nc nd ne nf b">first</code>和<code class="fe nc nd ne nf b">second</code>元素，并在一个<code class="fe nc nd ne nf b">array</code>中收集<code class="fe nc nd ne nf b">rest</code>元素，还有另一种方法，因此这可以通过组合<code class="fe nc nd ne nf b">destructuring</code>和<code class="fe nc nd ne nf b">rest parameters</code>来完成。</p><pre class="kd ke kf kg gt ns nf nt nu aw nv bi"><span id="acad" class="ng mg in nf b gy nw nx l ny nz">const cars = ['BMW','AUDI','VW','Maruti']<br/>const [first , second , ...others] = cars<br/>console.log(first,second, others) // BMW AUDI ['VW', 'Maruti']</span></pre><h2 id="0c31" class="ng mg in bd mh nh ni dn ml nj nk dp mp kx nl nm mr lb nn no mt lf np nq mv nr bi translated">析构对象属性</h2><p id="9abb" class="pw-post-body-paragraph ko kp in kq b kr mx jo kt ku my jr kw kx mz kz la lb na ld le lf nb lh li lj ig bi translated">如上例所示，你可以看到<code class="fe nc nd ne nf b">destructuring</code>通过<code class="fe nc nd ne nf b">position</code>解包<code class="fe nc nd ne nf b">array</code>元素，但是在<code class="fe nc nd ne nf b">objects</code>的情况下<code class="fe nc nd ne nf b">destructuring</code>使用<code class="fe nc nd ne nf b">property</code>名称。</p><pre class="kd ke kf kg gt ns nf nt nu aw nv bi"><span id="0c10" class="ng mg in nf b gy nw nx l ny nz">const person = {name:'Alex',age:'30',married: 'NO'}</span><span id="c755" class="ng mg in nf b gy oa nx l ny nz">const {name,age} = person;<br/>console.log(name,age) // Alex 30</span><span id="53d4" class="ng mg in nf b gy oa nx l ny nz">const {age,married} = person;<br/>console.log(age,married) // 30 NO</span></pre><p id="ae07" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">你可以在上面的例子中看到使用属性名从一个对象中获取属性。但是有没有可能<code class="fe nc nd ne nf b">property</code>名和<code class="fe nc nd ne nf b">resultant variable</code>名可以不一样？所以答案是<code class="fe nc nd ne nf b">Yes</code>。要实现这一点，您需要使用如下例所示的其他<code class="fe nc nd ne nf b">syntax</code>…</p><pre class="kd ke kf kg gt ns nf nt nu aw nv bi"><span id="3785" class="ng mg in nf b gy nw nx l ny nz">const person = {name:'Alex',age:'30',married: 'NO'}<br/>const {age,married:maritalStatus} = person;<br/>console.log(age,maritalStatus)// 30 NO</span></pre></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><p id="866d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果你喜欢这篇文章，请关注我:</p><p id="b438" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">【中:】<a class="ae ol" href="https://medium.com/@maheshshittlani" rel="noopener">https://medium.com/@maheshshittlani</a><br/><strong class="kq io">Github:</strong><a class="ae ol" href="https://github.com/maheshshittlani" rel="noopener ugc nofollow" target="_blank">https://github.com/maheshshittlani</a><br/><strong class="kq io">LinkedIn:</strong><a class="ae ol" href="https://in.linkedin.com/in/mahesh-shittlani-638b7429" rel="noopener ugc nofollow" target="_blank">https://in.linkedin.com/in/mahesh-shittlani-638b7429</a></p></div></div>    
</body>
</html>