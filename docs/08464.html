<html>
<head>
<title>Let’s Learn About Middleware In Express.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们了解一下 Express.js 中的中间件</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/lets-learn-about-middleware-in-express-js-174e839ffffa?source=collection_archive---------4-----------------------#2022-06-16">https://blog.devgenius.io/lets-learn-about-middleware-in-express-js-174e839ffffa?source=collection_archive---------4-----------------------#2022-06-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="51cc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对 Express.js 中中间件概念的简单而有趣的介绍</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/468855653dc956bd2c23cbec3252ca84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uXJLbWbWOtsMiAfK"/></div></div></figure><p id="15c5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你已经在 Node.js 附近呆了足够长的时间，你可能听说过中间件，我不想撒谎，当我第一次遇到这个词本身时，我感到很困惑😂更不用说中间件的实现了，但是你必须亲自动手去学习，所以请允许我温和地教你你需要知道的关于中间件的知识，✨，越简单越好，✨</p><p id="e61f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">建立我们的开发环境</strong></p><p id="84b4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你在 Linux 或 Mac 上打开你的终端，如果你在 Windows 上打开命令提示符</p><p id="fa8f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ku kv kw kx b">mkdir middleware &amp;&amp; cd middleware</code>创建一个新目录并导航至其中</p><p id="aafb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ku kv kw kx b">npm init --y</code>使用默认设置初始化一个新的 npm 项目(稍后您可以使用 package.json，我将向您展示)</p><p id="5fb3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ku kv kw kx b">npm i express &amp;&amp; npm i --save-dev nodemon</code>这将首先安装 express，因为我们需要它来构建我们的后端，然后我们将安装 nodemon 并将其保存为一个开发依赖项，因为我们在真实的生产环境中并不真正需要它</p><p id="55e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">添加脚本到</strong>T3】</p><p id="a027" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你打开你的<code class="fe ku kv kw kx b">package.json</code>文件，你会发现一个名为<code class="fe ku kv kw kx b">scripts</code>的部分，这个部分包含了在终端中运行命令的“快捷方式”,它非常有用，所以让我们添加一个小脚本来运行 nodemon，就像我们很酷一样😜</p><p id="11f0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ku kv kw kx b">"dev": "nodemon index.js"</code>将此添加到“测试”脚本之后</p><p id="ff32" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要触发这些脚本，我们只需键入终端<code class="fe ku kv kw kx b">npm run</code>，后跟在<code class="fe ku kv kw kx b">scripts</code>部分定义的脚本名称，因此在我们的例子中，我们键入<code class="fe ku kv kw kx b">npm run dev</code>，但我们稍后再使用:)</p><p id="6a5c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">到底什么是中间件</strong>🤔</p><p id="0157" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">中间件基本上是在路由处理器功能之前执行<strong class="jm io">的功能。这并不简单，所以让我们来看看一个非常基本的快速服务器😊</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="c1c3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好吧，所以没有什么太花哨的，对不对？我们有三条路线<code class="fe ku kv kw kx b">/</code>、<code class="fe ku kv kw kx b">/users</code>、<code class="fe ku kv kw kx b">/articles</code>，并且我们为这些路线中的每一条都有<em class="la">路线处理函数</em></p><p id="25f5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">运行<code class="fe ku kv kw kx b">npm run dev</code>,您应该会看到一条小消息，上面写着“启动并运行”</p><p id="39cb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的中间件将在对这些路由的每个请求之前执行，或者在我们可以选择指定的特定路由之前执行</p><p id="a2c5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">中间件基本上是一种访问请求和响应对象的功能，就像路由处理器一样，它可以用来记录对我们的服务器发出的每个请求，或者检查用户是否登录，验证和授权用户保护某些资源和许多其他目的</p><p id="a63f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">中间件与路由处理器</strong></p><p id="1f73" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">中间件和路由处理器<strong class="jm io">的最大区别是 next()函数</strong></p><p id="1946" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">函数是中间件的第三个参数，它基本上告诉后端“继续下一个中间件”,或者换句话说“给它开绿灯，继续下一个例程”,这样我们的页面就不会冻结，永远不会完成加载，所以如果我们忘记放入它，程序就不会继续，因为它卡在了中间件中</p><p id="92f6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">中间件的类型</strong></p><p id="cd62" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如上所述，我们有两种类型的中间件，一种运行在应用程序的顶层，因此它像中间件一样应用于所有的路由处理器，以检查用户是否登录，我们可以将其应用于我们正在编写的一些社交媒体应用程序的所有帖子路由</p><p id="4378" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">默认的<code class="fe ku kv kw kx b">express</code>中间件的一个例子是<code class="fe ku kv kw kx b">express.json()</code>中间件，我们一直在顶部使用它来接受和解析 json</p><p id="98f1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一种类型是在特定路由之前运行的中间件，可能你需要保护一些路由，这些路由可以访问只有管理员才能访问的文章或你的应用程序的一些 VIP 内容</p><p id="97f1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">编写我们的第一个中间件</strong></p><p id="7231" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">说得够多了，让我们来看看如何编写我们自己的中间件，它会给我们一个美味的饼干🍪</p><p id="5bed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们的导入之后添加以下代码片段</p><pre class="kj kk kl km gt lb kx lc ld aw le bi"><span id="19ed" class="lf lg in kx b gy lh li l lj lk">const say_hi = (req, res, next) =&gt; {<br/>  console.log("have a yummy cookie 🍪");<br/>  next();<br/>}</span></pre><p id="aa42" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了在应用程序级别“启用”中间件，我们使用了<code class="fe ku kv kw kx b">express.use(say_hi);</code>，注意我们没有添加括号，因为我们没有调用函数</p><p id="43c9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在前往任何路线，检查你的终端🍪</p><p id="e1e7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你的<code class="fe ku kv kw kx b">index.js</code>现在应该是这个样子</p><pre class="kj kk kl km gt lb kx lc ld aw le bi"><span id="aae7" class="lf lg in kx b gy lh li l lj lk">const express = require("express");                             const app = express(); <br/>const say_hi = (req, res, next) =&gt; {<br/>  console.log("have a yummy cookie 🍪");<br/>  next();<br/>};<br/>app.use(say_hi);                                                          app.get("", (req, res) =&gt; res.send("you've reached the home page"));                                                           app.get("/users", (req, res) =&gt; res.send("this is the users page"));                                                           app.get("/articles", (req, res) =&gt; res.send("this is the articles page"));                                                           app.get("*", (req, res) =&gt; res.status(404).send("Page not found"));                                                           app.listen(3000, () =&gt; console.log("up and running"));</span></pre><p id="9977" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">为特定路线编写中间件</strong></p><p id="17ef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">既然我们已经看到了如何编写一个运行在应用程序级别的中间件，也就是运行在每个路由之前，让我们再编写两个中间件，一个运行在用户路由之前，告诉我们“我爱我的用户💕还有一篇文章说“哇，看看这些文章😮“所以莱格 oooo</p><pre class="kj kk kl km gt lb kx lc ld aw le bi"><span id="f3c7" class="lf lg in kx b gy lh li l lj lk">const users_middleware = (req, res, next) =&gt; {<br/>  console.log("i love my users 💕");<br/>  next();<br/>};</span><span id="6d54" class="lf lg in kx b gy ll li l lj lk">const articles_middleware = (req, res, next) =&gt; {<br/>  console.log("wow look at all those articles 😮");<br/>};</span></pre><p id="9bb2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，为了让我们专门为我们的路由使用它们，我们需要分别将它们作为路由处理函数的参数进行传递，所以现在看起来像这样</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="f040" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">快速注释</strong></p><ul class=""><li id="6358" class="lm ln in jm b jn jo jr js jv lo jz lp kd lq kh lr ls lt lu bi translated">中间件只是一个在服务器收到请求之后、路由句柄响应请求之前执行的功能</li><li id="31d1" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh lr ls lt lu bi translated">他们可以访问三个参数，<code class="fe ku kv kw kx b">req</code> <code class="fe ku kv kw kx b">res</code>和第三个参数，该参数是一个方便地称为<code class="fe ku kv kw kx b">next()</code>的函数，允许下一个中间件运行</li><li id="ab5a" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh lr ls lt lu bi translated">它们可以位于应用程序级别，以便在每个端点的每个请求之前运行，也可以被指定到某个路由</li></ul><p id="4761" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">结论</strong></p><p id="e593" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于新手来说，中间件最初可能是一个复杂的概念，但一旦你发现了对它们的真正需求，它们就很容易实现，因为你理解了它们背后的基本思想，它们是调节你的服务器资源和访问控制以及许多其他需求的强大工具</p><p id="b3f3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">非常感谢你能坚持到现在，感谢你花时间关注我的博客，希望你能享受你的♥️日/夜</p></div></div>    
</body>
</html>