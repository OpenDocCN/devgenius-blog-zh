<html>
<head>
<title>Building an API with Golang in 2020 — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2020年用Golang构建API第1部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/building-an-api-with-golang-in-2020-part-1-bfe61ac8ae8?source=collection_archive---------5-----------------------#2020-06-30">https://blog.devgenius.io/building-an-api-with-golang-in-2020-part-1-bfe61ac8ae8?source=collection_archive---------5-----------------------#2020-06-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/36ef0b74f8057e324e497ca9b5147ca5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*noNAPXiTjNJRaB9BLPmzow.jpeg"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">照片由<a class="ae ja" href="https://unsplash.com/@emilep?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">埃米尔·佩龙</a>在<a class="ae ja" href="https://unsplash.com/s/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><div class=""/><p id="2c8d" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在今年开始在Mercado Livre的新工作之前，我已经爱上了Golang，在我以前的工作和一些辅助项目中制作了一个供内部使用的小API，但没有真正准备好生产。</p><p id="ba26" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在过去的三个月里，我沉浸其中，从所有同事和队友那里学到了很多东西，我想分享一下我的经验和通过使用我学到的良好实践来构建项目所学到的东西会很好。</p><p id="72dc" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这篇文章和我打算写的其他一些文章的想法是在我读了Diego Henrique Oliveira的这篇伟大的文章后产生的，我觉得这篇文章很棒，它激励我使用他的项目组织的想法来做一些事情。</p><p id="cd9f" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">主要想法是建立一个<strong class="kc je">投票API </strong>，在那里我们将有CRUD操作和API操作和验证，并应用一些概念，如<em class="la">干净的架构、包管理、域隔离、依赖注入</em>等等。我们还将使用一点Docker，并使用配置项部署我们的API。也就是说，让我们开始吧！</p><h1 id="cbb7" class="lb lc jd bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">开始一个项目</h1><p id="848c" class="pw-post-body-paragraph ka kb jd kc b kd lz kf kg kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx ig bi translated">我们将从初始化支持<strong class="kc je"> Go模块</strong>的项目开始，这是自Go 1.13以来默认的包管理器。要做到这一点，创建您的源文件夹，在我的例子中是<code class="fe me mf mg mh b">go-voting-api</code>无论您喜欢在哪里保存您的项目，在该文件夹中打开一个终端并运行:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9909" class="mq lc jd mh b gy mr ms l mt mu">$ go mod init github.com/$yourGithubName/go-voting-api<br/>$ git init</span></pre><p id="259e" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该命令将在您的根文件夹中创建两个文件，<code class="fe me mf mg mh b">go.mod</code>,这两个文件将跟踪您的依赖项及其版本。更多详情，<a class="ae ja" href="https://blog.golang.org/using-go-modules" rel="noopener ugc nofollow" target="_blank">这篇博文</a>很棒。</p><p id="f3c3" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Go已经提供了一个很棒的HTTP包，但是在这个例子中我们将使用<a class="ae ja" href="https://github.com/go-chi/chi" rel="noopener ugc nofollow" target="_blank"> Chi </a>，它是一个不可思议的HTTP路由器，具有中间件支持。此时，我们将使用如下所示的<code class="fe me mf mg mh b">go get</code>手动安装chi包。我们不需要使用<code class="fe me mf mg mh b">go get</code>安装每一个包，因为<code class="fe me mf mg mh b">go mod</code>已经识别出在构建时没有满足的导入，并安装它们。关于<code class="fe me mf mg mh b">go mod</code>的另一个重要信息是，由于它是自动导入的，有时它会跟踪一些我们不再使用的包，你可以运行<code class="fe me mf mg mh b">go mod tidy</code>来删除未使用的包。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ccdf" class="mq lc jd mh b gy mr ms l mt mu">go get github.com/go-chi/chi</span></pre><p id="a3e2" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc je">建设第一条路线</strong></p><p id="5e1f" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">安装好我们的主要依赖项后，我们将通过创建一个简单的<code class="fe me mf mg mh b">/health</code>端点来启动我们的应用程序，只是为了查看我们的服务器运行良好。为此，创建一个<code class="fe me mf mg mh b">main.go</code>文件，它将创建一个<code class="fe me mf mg mh b">router</code>并启动一个服务器，处理我们的健康路径。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6c47" class="mq lc jd mh b gy mr ms l mt mu"><strong class="mh je">package</strong> main<br/><br/><strong class="mh je">import</strong> (<br/>	"fmt"<br/>	"net/http"<br/><br/>	"github.com/go-chi/chi"<br/>)<br/><br/><strong class="mh je">func</strong> main() {<br/>	router := chi.NewRouter()<br/>	router.Get("/health", <strong class="mh je">func</strong>(w http.ResponseWriter, r *http.Request) {<br/>		fmt.Fprint(w, "healthy")<br/>	})<br/><br/>	fmt.Println("Starting server...")<br/>	err := http.ListenAndServe(":8080", router)<br/>	if err != nil {<br/>		fmt.Printf("Error starting server: %s", err)<br/>	}<br/>}</span></pre><p id="17d0" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们分成几个部分，让它更容易理解。在第一行，我们键入<code class="fe me mf mg mh b">package main</code>告诉go我们正在构建一个app，这是app的主包。之后，我们从Go标准库导入一些包，<code class="fe me mf mg mh b">fmt</code>来处理<code class="fe me mf mg mh b">logs</code>和字符串操作，比如将响应字符串写入响应流，<code class="fe me mf mg mh b">net/http</code>来处理我们的HTTP请求并启动服务器。最后一个导入是通过标准HTTP包导入Chi，这将是我们的路由器。</p><p id="7007" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">之后我们创建一个<code class="fe me mf mg mh b">main</code>函数告诉go，这是初始化我们的应用程序的函数，<code class="fe me mf mg mh b">main</code>包的<code class="fe me mf mg mh b">main</code>函数。在这个函数中，我们启动我们的Chi路由器，设置一个到<code class="fe me mf mg mh b">GET /health</code>的路由，并设置一个默认的<a class="ae ja" href="https://golang.org/pkg/net/http/#HandlerFunc" rel="noopener ugc nofollow" target="_blank"> HTTP处理函数</a>，来处理请求。</p><p id="32d2" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">之后，我们使用<code class="fe me mf mg mh b">http</code>包中的方法<code class="fe me mf mg mh b">ListenAndServe</code>启动一个服务器，在第一个参数中传递端口，在第二个参数中传递我们的路由器。</p><p id="1f7f" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在<code class="fe me mf mg mh b">ListenAndServe</code>之后的<code class="fe me mf mg mh b">if err != nil {</code>中，我们可以看到Golang是如何处理错误的。每个可能引发错误的函数都会返回一个<code class="fe me mf mg mh b">error</code>作为结果之一，然后我们需要检查这个错误是否为空来处理这个错误。</p><p id="98f3" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在你只需要运行你的终端<code class="fe me mf mg mh b">go run main.go</code>，你会看到我们的日志行，告诉你服务器正在启动，如果你访问<code class="fe me mf mg mh b">http://localhost:8080</code>，你会看到我们的<code class="fe me mf mg mh b">Healthy</code>响应。</p><h1 id="f54f" class="lb lc jd bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="1132" class="pw-post-body-paragraph ka kb jd kc b kd lz kf kg kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx ig bi translated">这篇文章的结尾比我预期的要大一点，但是我希望它能得到很好的解释，并能帮助你，欢迎任何反馈。您可以在<a class="ae ja" href="https://github.com/felipecaputo/go-voting-api" rel="noopener ugc nofollow" target="_blank">文章库</a>中看到我们构建的源代码，在下一篇文章中，我们将把数据库添加到我们的API中。</p><p id="8b3a" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">享受编码！</p></div></div>    
</body>
</html>