<html>
<head>
<title>WTH is Docker, and why do I need it?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">WTH 是码头工人，我为什么需要它？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/wth-is-docker-and-why-do-i-need-it-1f76deb827f9?source=collection_archive---------12-----------------------#2022-11-19">https://blog.devgenius.io/wth-is-docker-and-why-do-i-need-it-1f76deb827f9?source=collection_archive---------12-----------------------#2022-11-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="9fbb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你曾经在软件团队或任何应用程序开发项目中声称它在我的机器上绝对运行良好，我不明白为什么它在这里不工作，然后重新开始配置。</p><p id="5e6d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在许多情况下，这是一个主要的缺点，为了解决这个问题，<strong class="jm io">码头工人</strong>出现了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d925b72b4c335c19ef56762ed3a71532.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m2R89PJ8Lp63vkn59MMekw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://www.ondat.io/blog/persistent-storage-containers-stateful-apps-docker" rel="noopener ugc nofollow" target="_blank">提供<strong class="bd kz">ondat</strong>T7】</a></figcaption></figure><p id="d8c3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么，<strong class="jm io"> Docker </strong>到底是什么？它是一组平台即服务产品，使用<strong class="jm io">操作系统级虚拟化</strong>来交付称为容器的软件包中的软件。</p><p id="5fff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因为容器本身有所有需要的库和资源，只有<strong class="jm io">不需要其他配置</strong>，这使它成为一个巨大的入口，也是你需要它的原因<strong class="jm io"/>。</p><p id="0eca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文中，我们将讨论 docker 的 3 个组件— <strong class="jm io"> Dockerfile、docker image </strong>、<strong class="jm io">、以及<strong class="jm io">容器</strong>。</strong></p><p id="85d8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> Dockerfile </strong> —这是构建<strong class="jm io"> docker 形象</strong>的<strong class="jm io">蓝图</strong>。</p><p id="5c9f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> docker 镜像</strong> —它是运行 docker <strong class="jm io">容器</strong>的<strong class="jm io">模板</strong>。</p><p id="2382" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">容器</strong> —是<strong class="jm io"> docker-image 的一个运行进程。</strong></p><p id="4093" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，在这一点上，你可能需要更多关于码头工人<strong class="jm io">集装箱</strong>和码头工人<strong class="jm io">图像的<strong class="jm io">澄清</strong>。</strong></p><p id="c5ad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> Docker image </strong>是一个只读的惰性模板，附带了部署容器的说明。在 Docker 中，一切基本上都围绕着图像。一个映像由一组文件(或层)组成，这些文件将所有必需的东西打包在一起，例如建立一个完整的功能性容器环境所需的<strong class="jm io">依赖项、源代码、</strong>和<strong class="jm io">库</strong>。</p><p id="fd58" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一个<strong class="jm io"> Docker 容器</strong>是一个虚拟化的运行时环境，它提供<strong class="jm io">隔离功能</strong>，用于将应用程序的执行与基础系统分离开来。</p><h1 id="bddc" class="la lb in bd kz lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">Dockerfile 文件</h1><p id="e8c4" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">这是对提供蓝图的应用程序进行归档的起点，因此我将借助一个例子来讨论这个问题，在这个例子中，我将对一个 FastAPI 应用程序进行归档。</p><h2 id="d994" class="mc lb in bd kz md me dn lf mf mg dp lj jv mh mi ln jz mj mk lr kd ml mm lv mn bi translated"><strong class="ak">所用 Dockerfile 概述</strong></h2><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="6df2" class="mc lb in mp b gy mt mu l mv mw"><strong class="mp io">FROM</strong> python:<strong class="mp io">3.10</strong><br/><br/><strong class="mp io">WORKDIR</strong> /api<br/><br/><strong class="mp io">COPY</strong> requirements.txt <strong class="mp io">./</strong><br/><br/><strong class="mp io">RUN</strong> python3 -m pip install --upgrade <strong class="mp io">https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow_cpu-2.10.0-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl<br/></strong><br/><strong class="mp io">RUN</strong> pip install <strong class="mp io">-r</strong> requirements.txt<br/><br/>COPY <strong class="mp io">. .</strong><br/><br/><strong class="mp io">EXPOSE</strong> 8000<strong class="mp io">:</strong>8000<br/><br/><strong class="mp io">CMD </strong>["uvicorn", "<strong class="mp io">api:summary_api</strong>", "--host", "0.0.0.0", "--port", "8000"]</span></pre><p id="ad5f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们把它分成几部分，一个一个地看，</p><h2 id="8bfe" class="mc lb in bd kz md me dn lf mf mg dp lj jv mh mi ln jz mj mk lr kd ml mm lv mn bi translated">基础图像</h2><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="3bdf" class="mc lb in mp b gy mt mu l mv mw"><strong class="mp io">FROM </strong>python:<strong class="mp io">3</strong></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/d2fe29b72e9894ca366048c6ad6d60bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*2-2SQAxtJDOpxqULG3vh9Q.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<strong class="bd kz"> JetBrains PyCharm IDE </strong>提供的解释</figcaption></figure><p id="2f45" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它是构建图像的<strong class="jm io">基础图像</strong>，根据它将执行下一个<strong class="jm io">层</strong>(代码)。</p><p id="27a0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本例中是<strong class="jm io"> python </strong>。</p><h2 id="1eba" class="mc lb in bd kz md me dn lf mf mg dp lj jv mh mi ln jz mj mk lr kd ml mm lv mn bi translated">工作目录</h2><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="543c" class="mc lb in mp b gy mt mu l mv mw"><strong class="mp io">WORKDIR /</strong>api</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi my"><img src="../Images/7101ccc45473028a1e94abd66a35bb79.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*B6Fv13ENlvQ5cphTdUuiHA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<strong class="bd kz"> JetBrains PyCharm IDE </strong>提供的解释</figcaption></figure><p id="9fa7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是一个工作目录，所有的项目文件和说明，代码等。将被存储。</p><p id="fbfb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个例子中，它是<strong class="jm io"> api </strong>。</p><h2 id="24dd" class="mc lb in bd kz md me dn lf mf mg dp lj jv mh mi ln jz mj mk lr kd ml mm lv mn bi translated">将文件复制到工作目录</h2><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="e2a6" class="mc lb in mp b gy mt mu l mv mw"><strong class="mp io">COPY </strong>requirements.txt .<strong class="mp io">/</strong></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/df9bf6c03d3c0841d414ac0d5d3247fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JLmvt3upuMATmJL7vLJMbw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<strong class="bd kz"> JetBrains PyCharm IDE </strong>提供的解释</figcaption></figure><p id="0bec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它用于从项目目录中复制文件和文件夹；在这种情况下，<strong class="jm io"> FastAPI </strong>将被移动到<strong class="jm io">容器</strong>文件系统中；它首先获取<strong class="jm io">要移动的文件/目录路径</strong>，然后获取容器的<strong class="jm io">路径</strong>。</p><p id="1bce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本例中，<strong class="jm io"> requirements.txt </strong>文件被移动到<strong class="jm io"> api/ </strong>目录。</p><h2 id="4b26" class="mc lb in bd kz md me dn lf mf mg dp lj jv mh mi ln jz mj mk lr kd ml mm lv mn bi translated">运行命令</h2><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="66a5" class="mc lb in mp b gy mt mu l mv mw"><strong class="mp io">RUN</strong> pip install <strong class="mp io">-</strong>r requirements.txt</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/9f5f08c4fd6f7df8d065f450e19501f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V6bIKOILSK22TrOMeV_mjQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<strong class="bd kz"> JetBrains PyCharm IDE </strong>提供的解释</figcaption></figure><p id="beab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它用于在一个新层(每个代码行是一个层)上运行命令，这个新层是从基本映像获取的，并提交结果(不像很多人)。</p><p id="773c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个例子中，运行<strong class="jm io"> pip </strong> python 命令，其中<strong class="jm io">从 requirements.txt 中读取</strong>需求，然后<strong class="jm io">安装</strong>它们。</p><h2 id="100c" class="mc lb in bd kz md me dn lf mf mg dp lj jv mh mi ln jz mj mk lr kd ml mm lv mn bi translated">将文件复制到工作目录</h2><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="0aee" class="mc lb in mp b gy mt mu l mv mw"><strong class="mp io">COPY</strong> . .</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/95b6825b6f882069d7a930b26de85c20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*zjtgqjBRlKLmvYwS8duhEg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<strong class="bd kz"> JetBrains PyCharm IDE </strong>提供的解释</figcaption></figure><p id="6dfe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如前所述，它用于<strong class="jm io"> Docker 中的<strong class="jm io">复制</strong>命令。</strong></p><p id="a455" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个例子中，<strong class="jm io">所有</strong><strong class="jm io">新</strong>创建的文件和目录都被<strong class="jm io">复制</strong>到容器文件系统中。</p><h2 id="415e" class="mc lb in bd kz md me dn lf mf mg dp lj jv mh mi ln jz mj mk lr kd ml mm lv mn bi translated">暴露端口</h2><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="14d2" class="mc lb in mp b gy mt mu l mv mw"><strong class="mp io">EXPOSE</strong> 8000<strong class="mp io">:</strong>8000</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/f23c9c51b04b28689aecd9d7b0d4cb41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Of4hnh-YWjD67ysRRf8F3A.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<strong class="bd kz"> JetBrains PyCharm IDE </strong>提供的解释</figcaption></figure><p id="b560" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> EXPOSE </strong>命令在 Docker <strong class="jm io">容器内使用<strong class="jm io">指定的协议</strong>暴露一个<strong class="jm io">特定端口</strong>。</strong></p><p id="7531" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个例子中，容器被<strong class="jm io">暴露</strong>到容器连接的特定端口<strong class="jm io"> 8000 </strong>。</p><h2 id="2039" class="mc lb in bd kz md me dn lf mf mg dp lj jv mh mi ln jz mj mk lr kd ml mm lv mn bi translated">命令执行</h2><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="c80a" class="mc lb in mp b gy mt mu l mv mw"><strong class="mp io">CMD </strong>["uvicorn", "<strong class="mp io">api:summary_api</strong>", "--host", "0.0.0.0", "--port", "8000"]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/8ae142b70027cd006f9694cf87840d6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KB4lKUlajVJhNDwMJDH1Kw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<strong class="bd kz"> JetBrains PyCharm IDE </strong>提供的解释</figcaption></figure><p id="3eba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> CMD </strong>命令用于执行图像中的<strong class="jm io">命令</strong>。需要注意的是，在一个<strong class="jm io">卷宗</strong>中只能有<strong class="jm io">一个</strong>(由于新的人口法，中国的家庭也是如此)。</p><p id="352d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个例子中，<strong class="jm io">uvicon</strong>(ASGI<em class="ne">(异步服务器网关接口)兼容的 web 服务器。它处理来自浏览器或 API 客户端的 web 连接，然后允许 FastAPI 服务于实际的请求。运行</em>命令，启动端口<strong class="jm io"> 8000 上的<strong class="jm io">服务器</strong>。</strong></p><h1 id="0bbd" class="la lb in bd kz lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">使用 Dockerfile 构建 Docker 映像</h1><p id="35ef" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">现在蓝图来了，谁不喜欢蓝图？问问建筑师。</p><p id="9524" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但正如老师所说，这将在考试中出现，所以必须说明官方的定义。又来了，<strong class="jm io"> Docker image </strong>是一个只读模板，它包含一组用于创建可以在 Docker 平台上运行的<strong class="jm io">容器</strong>的指令。</p><p id="419c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它提供了一种方便的方式来打包应用程序和预配置的服务器环境，您可以将其用于您自己的私人用途或与其他 Docker 用户共享。</p><p id="365d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Docker 图片也是第一次使用 Docker 的人的起点。</p><p id="714e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在下面的例子中，使用<strong class="jm io"> build </strong>命令(参见我在那里所做的)和<strong class="jm io"> -t </strong> (tag)构建 docker 映像，该命令指定了映像的<strong class="jm io">标签</strong>和<strong class="jm io"> docker hub 的名称</strong> name(在<a class="ae ky" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank">https://hub.docker.com/</a>上注册)，后跟映像名称及其在<strong class="jm io">之后的标签:</strong>在本例中为<strong class="jm io"> 1.0 </strong>，并选择<strong class="jm io"/></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/4b741d3986785ea827068dd0a17578a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zhUQZ0kN9fgDe39JazmnFQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">建立码头形象</figcaption></figure><p id="15df" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，在映像构建完成后，应该是<strong class="jm io">运行</strong> ( duh)，我们使用<strong class="jm io">运行</strong>命令和<strong class="jm io"> -p </strong> ( port)来完成，它首先获取将运行<strong class="jm io">本地</strong>机器中指定端口的端口(本例中为 8000)和<strong class="jm io">容器</strong>端口(8000 ),之后是<strong class="jm io"> -i </strong> ( image ),它获取<strong class="jm io">映像名称<strong class="jm io"/></strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/8aefaede221b89842c4697c26bae8184.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-yxd5r7j6CmB39Vz_U_jig.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">运行 Docker 图像</figcaption></figure><p id="a7d6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我可以在互联网上的其他应用程序中需要这张图像，或者我需要检索它，所以我该怎么办呢我<strong class="jm io">拉</strong>，但首先我必须<strong class="jm io">推</strong>，就像投资一样首先你必须投资，然后只有你才能获得回报，因此使用<strong class="jm io">推</strong>命令，推 tripathiadityaprakash(我的 docker hub 名称)/financial-summary-API(图像名称):1.0(标签)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/ddaa18e3a56bed2a4a59585783bd1413.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i3uT4FSGAuIoT9ZTsK22AQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">将 Docker 图像推送到<strong class="bd kz"> DockerHub </strong></figcaption></figure><p id="c475" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在它被推送了，我可以随时使用跟在<strong class="jm io">映像名称</strong>后面的<strong class="jm io"> pull </strong>命令来拉它。</p><h1 id="2cdd" class="la lb in bd kz lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">Docker 容器(docker-compose)和共享卷</h1><p id="5c0f" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">使用 Docker <strong class="jm io">容器</strong>确保软件无论部署在哪里都以同样的方式<strong class="jm io">运行，因为它的运行时环境是<strong class="jm io">一致的</strong>。</strong></p><p id="749c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一般来说，Docker 容器是短暂的，只要容器中发出的命令完成，它就会运行。</p><p id="8b43" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，有时应用程序需要共享对数据的访问或在容器被删除后持久化数据，因此，为了这个目的，<strong class="jm io"> docker 卷</strong>被创建，其具有对数据的<strong class="jm io">持久化</strong>访问。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="aabf" class="mc lb in mp b gy mt mu l mv mw">docker <strong class="mp io">volume create</strong> --name DataVolume1</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/840168da133332ba1f099b3ca45d4b6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IvmufZ719WtyjPjc93Vjvg.png"/></div></div></figure><p id="d3b8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Volume 命令创建一个 docker <strong class="jm io">卷</strong>，其名称在此指定为<strong class="jm io"> DataVolume1 </strong>。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="34b6" class="mc lb in mp b gy mt mu l mv mw"><strong class="mp io">--rm</strong> (automatically delete it when we exit)<br/><strong class="mp io">-v</strong> (mount new volume, name of volume absolute path to where the  volume should appear inside the container, if it doesn't exist, they've created.)(/path:/path/in/container - mounts host dir /path at /path/in/container , path:/path/in/container - creates a volume named path with no relationship, to host)<br/><strong class="mp io">-t</strong> ( terminal)<br/><strong class="mp io">-i</strong> ( interact with it)<br/><strong class="mp io">--name</strong> (identify the container)</span></pre><p id="ae6f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在运行一个容器并将共享卷(DataVolume1)与 mongo (image)连接起来，并使用 bash 在 bash 命令行中运行。</p><p id="194a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> : </strong> /datavolume1(卷应该装入容器的路径)。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="dd3d" class="mc lb in mp b gy mt mu l mv mw">docker <strong class="mp io">run</strong> <strong class="mp io">-</strong>ti <strong class="mp io">--</strong>rm <strong class="mp io">-</strong>v DataVolume1<strong class="mp io">:</strong>/datavolume1 mongo <strong class="mp io">bash</strong></span></pre><p id="a4e2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在来看一下<strong class="jm io"> docker-compose，</strong>它是用于将多个容器作为单个服务运行的<strong class="jm io"> </strong>。</p><p id="a001" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将使用版本<strong class="jm io"> 3 </strong>的合成文件格式。(撰写本文时的最新消息)</p><p id="809e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">合成文件是一个定义了<strong class="jm io">服务</strong>、<strong class="jm io">网络</strong>和<strong class="jm io">卷的<strong class="jm io"> YAML </strong>文件。</strong></p><p id="73ba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每个服务定义都包含一个应用于该服务的每个容器的配置(就像 docker run 的命令行参数)。</p><h2 id="370a" class="mc lb in bd kz md me dn lf mf mg dp lj jv mh mi ln jz mj mk lr kd ml mm lv mn bi translated">使用的 docker-compose 文件概述</h2><pre class="kj kk kl km gt mo mp nj bn nk nl bi"><span id="99ea" class="nm lb in mp b be nn no l np mw">version: '3'<br/><br/>services:<br/>  web_app:<br/>    build:<br/>      context: .<br/>      dockerfile: Dockerfile<br/>    image: tripathiadityaprakash/financial-summary-api:1.0<br/>    env_file:<br/>      - .env<br/>    depends_on:<br/>      - db<br/>    ports:<br/>      - "8000:8000"<br/>  db:<br/>    image: mongo<br/>    env_file:<br/>      - .env</span></pre><p id="c56c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们把它分成几部分，一个一个地看，</p><h1 id="2c9a" class="la lb in bd kz lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">版本</h1><p id="9ec8" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">指定合成文件的版本。</p><p id="c3b9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本例中为<strong class="jm io"> 3 </strong>。</p><h1 id="746d" class="la lb in bd kz lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">服务</h1><p id="dc54" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">它指定了容器内部的各种服务。</p><p id="0933" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个例子中，我为<strong class="jm io"> MongoDB </strong>数据库准备了<strong class="jm io">两个</strong>服务数据库，为我的 web 应用程序准备了一个<strong class="jm io"> FastAPI </strong>。</p><h1 id="51a6" class="la lb in bd kz lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">建设</h1><p id="cac3" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">在生成时应用的配置选项。</p><p id="3b55" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">上下文</strong>:用于指定 Dockerfile 的路径或 git repo 的 URL。</p><p id="028a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> Dockerfile </strong>:这是一个备选的构建备选文件。</p><h1 id="47b4" class="la lb in bd kz lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">图像</h1><p id="75d1" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">指定启动容器的图像。</p><p id="9c1c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个例子中，<strong class="jm io">两个图像</strong>是它们来自<strong class="jm io"> MongoDB </strong>数据库服务的 mongo 和用于 web 应用服务的 tripathiadityaprakash/<strong class="jm io">financial-summary-API</strong>:1.0。</p><h1 id="33bc" class="la lb in bd kz lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">环境文件</h1><p id="2d2e" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">从文件中添加环境变量。</p><p id="0ad8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个例子中，像<strong class="jm io"> MONGO_HOST </strong>这样的环境变量是从<strong class="jm io">添加的。env </strong>文件。</p><h1 id="c77a" class="la lb in bd kz lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">依赖于</h1><p id="bd34" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">表达服务之间的依赖关系。服务按照<strong class="jm io">依赖</strong>的顺序启动，如 db 服务<strong class="jm io">在 web-app 服务</strong>之前启动，停止时<strong class="jm io">先停止</strong>。</p><p id="7882" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Docker 各种<strong class="jm io">命令</strong>的简明形式如下</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/372cd38095cf648215cd1530df2bd3db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ynIW4yS6y03UwV0MY6AsJg.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">cheat sheet Credit<a class="ae ky" href="https://phoenixnap.com/kb/list-of-docker-commands-cheat-sheet" rel="noopener ugc nofollow" target="_blank"><strong class="bd kz">phoenix nap</strong></a></figcaption></figure><blockquote class="nr ns nt"><p id="469b" class="jk jl ne jm b jn jo jp jq jr js jt ju nu jw jx jy nv ka kb kc nw ke kf kg kh ig bi translated"><strong class="jm io"> <em class="in">参考文献</em> </strong></p><p id="6e60" class="jk jl ne jm b jn jo jp jq jr js jt ju nu jw jx jy nv ka kb kc nw ke kf kg kh ig bi translated"><a class="ae ky" href="https://docs.docker.com/compose/compose-file/compose-file-v3/#depends_on" rel="noopener ugc nofollow" target="_blank">https://docs . docker . com/compose/compose-file/compose-file-v3/# depends _ on</a></p><p id="9aec" class="jk jl ne jm b jn jo jp jq jr js jt ju nu jw jx jy nv ka kb kc nw ke kf kg kh ig bi translated"><a class="ae ky" href="https://phoenixnap.com/kb/list-of-docker-commands-cheat-sheet" rel="noopener ugc nofollow" target="_blank">https://phoenix nap . com/kb/list-of-docker-commands-cheat-sheet</a></p></blockquote><p id="ffa0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你喜欢这篇文章，跟我来，你也可以做下面的事情。</p><p id="98f4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们连线上<strong class="jm io">LinkedIn</strong>:<a class="ae ky" href="https://www.linkedin.com/in/tripathiadityaprakash" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/tripathiadityaprakash</a></p><p id="9813" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">或者我的<strong class="jm io">网站</strong>:</p><p id="b7d7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ky" href="https://tripathiaditya.netlify.app/" rel="noopener ugc nofollow" target="_blank">https://tripathiaditya.netlify.app/</a></p></div></div>    
</body>
</html>