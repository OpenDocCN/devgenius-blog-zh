<html>
<head>
<title>How to Use the `keyof` Type Operator in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在 TypeScript 中使用“keyof”类型运算符</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-use-the-keyof-type-operator-in-typescript-6d5e0ea6740f?source=collection_archive---------0-----------------------#2021-10-06">https://blog.devgenius.io/how-to-use-the-keyof-type-operator-in-typescript-6d5e0ea6740f?source=collection_archive---------0-----------------------#2021-10-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a0bb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">探索“keyof”类型运算符及其在一般函数中的使用</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/90a324e8c0933a1e60929269c847f442.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zyqknW1Vlt6qmDAD"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@bergerteam?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">弗洛里安·伯格</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="88c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在 TypeScript 中，有许多方法可以从其他类型创建类型。其中一种方法是使用<code class="fe ls lt lu lv b">keyof</code>类型的操作符。</p><p id="c2ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将看看 TypeScript 中的<code class="fe ls lt lu lv b">keyof</code>类型操作符，并学习如何在一般函数中使用它。如果您还不熟悉通用函数，请先阅读下面的文章。</p><div class="lw lx gp gr ly lz"><a rel="noopener  ugc nofollow" target="_blank" href="/introduction-to-generics-in-typescript-e81ed146a330"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd ir gy z fp me fr fs mf fu fw ip bi translated">TypeScript 中的泛型介绍</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">什么是泛型，我们如何在 TypeScript 中使用它们？</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">blog.devgenius.io</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn kp lz"/></div></div></a></div><p id="7db9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您不熟悉 TypeScript，请阅读下面的文章，熟悉一些基本概念。</p><div class="lw lx gp gr ly lz"><a href="https://levelup.gitconnected.com/type-annotation-vs-type-inference-in-typescript-85ba2194ebe1" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd ir gy z fp me fr fs mf fu fw ip bi translated">TypeScript 中的类型注释与类型推理</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">如何在 TypeScript 中向变量添加类型</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="mi l"><div class="mo l mk ml mm mi mn kp lz"/></div></div></a></div></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="e27e" class="mw mx iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">什么是“keyof”类型的运算符？</h1><p id="db95" class="pw-post-body-paragraph kw kx iq ky b kz no jr lb lc np ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">在 TypeScript 2.1 中，他们引入了<code class="fe ls lt lu lv b">keyof</code>类型操作符。<code class="fe ls lt lu lv b">keyof</code>类型操作符接受一个对象类型并创建其键的联合类型。</p><p id="a931" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，假设我们创建了一个<code class="fe ls lt lu lv b">User</code>类型，名字为<code class="fe ls lt lu lv b">string</code>，年龄为<code class="fe ls lt lu lv b">number</code>。</p><pre class="kg kh ki kj gt nt lv nu nv aw nw bi"><span id="3a75" class="nx mx iq lv b gy ny nz l oa ob">type User = {<br/>  name: string;<br/>  age: number;<br/>};</span></pre><p id="f73e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用<code class="fe ls lt lu lv b">keyof</code>类型操作符创建一个<code class="fe ls lt lu lv b">User</code>类型键的联合类型。</p><pre class="kg kh ki kj gt nt lv nu nv aw nw bi"><span id="3a36" class="nx mx iq lv b gy ny nz l oa ob">type UserKey = keyof User;</span></pre><p id="fabc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，<code class="fe ls lt lu lv b">UserKey</code>类型会有一个<code class="fe ls lt lu lv b">"name" | "age"</code>类型。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/f505e05e837a1c456775a7f51e7def16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ms-bHBF9TvhII06a6fWASQ.png"/></div></div></figure><p id="5e29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，我们可以将<code class="fe ls lt lu lv b">UserKey</code>硬编码为<code class="fe ls lt lu lv b">"name" | "age"</code>的联合类型。然而，如果我们想在将来给<code class="fe ls lt lu lv b">User</code>类型添加更多的属性，我们也必须更新<code class="fe ls lt lu lv b">UserKey</code>类型。</p><p id="ae7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过使用<code class="fe ls lt lu lv b">keyof</code>，如果我们向<code class="fe ls lt lu lv b">User</code>添加一个新属性，那么<code class="fe ls lt lu lv b">UserKey</code>联合类型也将改变。</p><p id="3c59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，我在<code class="fe ls lt lu lv b">User</code>类型上添加了一个位置属性作为<code class="fe ls lt lu lv b">string</code>。现在<code class="fe ls lt lu lv b">UserKey</code>型变成了<code class="fe ls lt lu lv b">"name" | "age" | "location"</code>的联合型。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/c495e98e1a3225ea858f011705ceb748.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2bbDxqOhiqh1rJWMmm6kGA.png"/></div></div></figure><h1 id="7a47" class="mw mx iq bd my mz oe nb nc nd of nf ng jw og jx ni jz oh ka nk kc oi kd nm nn bi translated">在一般函数中使用“keyof”</h1><p id="37dc" class="pw-post-body-paragraph kw kx iq ky b kz no jr lb lc np ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">现在我们已经了解了<code class="fe ls lt lu lv b">keyof</code>类型操作符的作用，让我们看看如何在一个通用函数中使用它。</p><p id="6278" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这个例子，我将创建一个用户数组，每个用户都有一个<code class="fe ls lt lu lv b">User</code>类型。</p><pre class="kg kh ki kj gt nt lv nu nv aw nw bi"><span id="5f5e" class="nx mx iq lv b gy ny nz l oa ob">const users: User[] = [<br/>  {<br/>    name: "Chad",<br/>    age: 31,<br/>    location: "Japan"<br/>  },<br/>  {<br/>    name: "Bob",<br/>    age: 29,<br/>    location: "USA"<br/>  },<br/>  {<br/>    name: "Jane",<br/>    age: 30,<br/>    location: "France"<br/>  }<br/>];</span></pre><p id="536f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我将创建一个名为<code class="fe ls lt lu lv b">getData</code>的通用函数。</p><pre class="kg kh ki kj gt nt lv nu nv aw nw bi"><span id="d5ae" class="nx mx iq lv b gy ny nz l oa ob">function getData&lt;Type, KeyType extends keyof Type&gt;(<br/>  dataList: Type[],<br/>  dataType: KeyType<br/>): Type[KeyType][] {<br/>  return dataList.map((data) =&gt; data[dataType]);<br/>}</span></pre><p id="55cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这可能看起来比实际情况更复杂，所以让我仔细分析一下。</p><p id="17d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们将把两个类型变量传递给这个泛型函数:<code class="fe ls lt lu lv b">Type</code>和<code class="fe ls lt lu lv b">KeyType</code>。<code class="fe ls lt lu lv b">Type</code>将物品放入类型数组中。<code class="fe ls lt lu lv b">KeyType</code>将延伸<code class="fe ls lt lu lv b">keyof Type</code>。换句话说，它将是<code class="fe ls lt lu lv b">Type</code>的一把钥匙。</p><pre class="kg kh ki kj gt nt lv nu nv aw nw bi"><span id="7ddb" class="nx mx iq lv b gy ny nz l oa ob"><strong class="lv ir">function getData&lt;Type, KeyType extends keyof Type&gt;</strong></span></pre><p id="0a5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">函数本身将接受两个参数:</p><ul class=""><li id="642d" class="oj ok iq ky b kz la lc ld lf ol lj om ln on lr oo op oq or bi translated"><strong class="ky ir">数据列表</strong>——一系列的<code class="fe ls lt lu lv b">Type</code></li><li id="f79f" class="oj ok iq ky b kz os lc ot lf ou lj ov ln ow lr oo op oq or bi translated"><strong class="ky ir">数据类型</strong> —某个特定键的<code class="fe ls lt lu lv b">Type</code></li></ul><pre class="kg kh ki kj gt nt lv nu nv aw nw bi"><span id="f7f1" class="nx mx iq lv b gy ny nz l oa ob">function getData&lt;Type, KeyType extends keyof Type&gt;(<br/>  <strong class="lv ir">dataList: Type[],<br/>  dataType: KeyType</strong><br/>)</span></pre><p id="fcc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该功能的返回类型为<code class="fe ls lt lu lv b">Type[KeyType][]</code>。这意味着它将是每个项目的<code class="fe ls lt lu lv b">KeyType</code>属性的数组。</p><pre class="kg kh ki kj gt nt lv nu nv aw nw bi"><span id="f458" class="nx mx iq lv b gy ny nz l oa ob">function getData&lt;Type, KeyType extends keyof Type&gt;(<br/>  dataList: Type[],<br/>  dataType: KeyType<br/>): <strong class="lv ir">Type[KeyType][]</strong> </span></pre><p id="6554" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们将添加函数的逻辑。这个函数将简单地映射到数据列表数组，并返回我们指定的属性值。</p><pre class="kg kh ki kj gt nt lv nu nv aw nw bi"><span id="e096" class="nx mx iq lv b gy ny nz l oa ob">function getData&lt;Type, KeyType extends keyof Type&gt;(<br/>  dataList: Type[],<br/>  dataType: KeyType<br/>): Type[KeyType][] {<br/>  <strong class="lv ir">return dataList.map((data) =&gt; data[dataType]);</strong><br/>}</span></pre><p id="ea90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我调用该函数并传入<code class="fe ls lt lu lv b">users</code>数组作为第一个参数，您可以看到我的文本编辑器正在为第二个参数建议值。这是因为 TypeScript 知道第二个参数必须是<code class="fe ls lt lu lv b">User</code>类型的键。所以要么<code class="fe ls lt lu lv b">age</code>、<code class="fe ls lt lu lv b">location</code>或者<code class="fe ls lt lu lv b">name</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/9fd4e26e52df43af80195fb98667d455.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n-guQb1ktThn4OFnZv1VJQ.png"/></div></div></figure><p id="9e1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我使用<code class="fe ls lt lu lv b">name</code>作为第二个参数，它将向控制台提供一个名称数组。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/7a95959973418b97f1691a00dd1bf157.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*6sJLKvXeJysGuyrfpymjCA.png"/></div></figure><p id="c9ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们将它作为一个通用函数，所以我可以用不同类型的数据创建一个新的数组，并且仍然使用这个函数。这是泛型函数和使用<code class="fe ls lt lu lv b">keyof</code>类型运算符的力量的一个例子。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="aeac" class="mw mx iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">结论</h1><p id="b147" class="pw-post-body-paragraph kw kx iq ky b kz no jr lb lc np ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">谢谢你的阅读！希望本文能对您理解 TypeScript 中的<code class="fe ls lt lu lv b">keyof</code>类型运算符有所帮助。</p><p id="ad15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想继续了解有关 TypeScript 的更多信息，请查看下面的文章。</p><div class="lw lx gp gr ly lz"><a href="https://javascript.plainenglish.io/typescript-tip-convert-an-array-of-strings-into-a-string-literal-union-type-ee46c2c6e337" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd ir gy z fp me fr fs mf fu fw ip bi translated">类型脚本提示:将字符串数组转换为字符串文字联合类型</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">使用“const”断言和索引访问类型</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="mi l"><div class="oz l mk ml mm mi mn kp lz"/></div></div></a></div></div></div>    
</body>
</html>