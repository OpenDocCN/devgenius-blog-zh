<html>
<head>
<title>Implementing the autocomplete feature for a search engine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为搜索引擎实现自动完成功能</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/implementing-the-autocomplete-feature-for-a-search-engine-fe17cd4f9aa?source=collection_archive---------8-----------------------#2022-08-19">https://blog.devgenius.io/implementing-the-autocomplete-feature-for-a-search-engine-fe17cd4f9aa?source=collection_archive---------8-----------------------#2022-08-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="22d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第 2 部分:python 实现</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/27f16dbd714f2d5ab33509e8cc236a12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AD6zBUpnf2W221eut7Go4Q.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">来源:<a class="ae lb" href="https://unsplash.com/@markuswinkler" rel="noopener ugc nofollow" target="_blank">unsplash.com—@ markuswinkler</a></figcaption></figure><h1 id="812c" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">TLDR</h1><p id="a87f" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">这篇文章跟随<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/implementing-the-autocomplete-feature-for-a-search-engine-6327a562b1cd">之前关于 trie 结构如何工作以及如何应用它来构建实时自动完成功能的讨论</a>。第一篇文章致力于 trie 构造和信息检索背后的理论方面。这一个将更实际，因为我们将通过 python 实现。</p><h1 id="70ae" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">介绍</h1><p id="a1d4" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/implementing-the-autocomplete-feature-for-a-search-engine-6327a562b1cd">这篇文章的第一部分</a>，我们解释了我们日常使用的在线搜索查询的自动完成特性是如何工作的。我们看到这个特性依赖于一种叫做 trie 的数据结构，这种数据结构可以更快地找到共享相同前缀的查询。如果您错过了第一部分，我们强烈建议您点击<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/implementing-the-autocomplete-feature-for-a-search-engine-6327a562b1cd">此链接</a>详细了解数据如何存储在此结构中，以及搜索算法如何快速检索匹配的查询。</p><p id="4ced" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在今天的文章中，我们将把重点放在实践部分。首先，我们提出了 trie 和搜索算法的 python 实现。然后，我们构建一个 flask API 来公开它。</p><h1 id="bca3" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">实现 Trie 结构</strong></h1><p id="93d5" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">从视觉上看，我们想要构建的 trie 如下所示，每个节点存储一个字符，并且可以有多个子节点。此外，trie 中的每个节点都应该有一个标志来标记查询的结束。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/4dec4306f9391e7e0e208e9543e50c5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*_OmdKFGyXUcGCdBn70Z_rA.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">用六个查询填充的 trie 结构</figcaption></figure><p id="0c1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了实现这一点，我们从构建块开始:节点。我们建议下面的代码片段实现一个<strong class="jp ir"> Trie 节点对象</strong>，它可以存储<strong class="jp ir"/><strong class="jp ir">字符</strong>，<strong class="jp ir">子节点</strong>作为节点的字典，以及<strong class="jp ir">从-1 开始的计数</strong>。该计数将以频率更新，以标记查询的结束及其在历史查询数据中的出现。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="8ae6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦定义了节点对象，就该开始构建 trie 了。为此，我们必须逐个字符地循环历史查询，并将每个查询插入到正确的位置。这个逻辑是在插入函数中实现的。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="5ec5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个阶段，我们有了所需的函数来<strong class="jp ir">构建 trie 并将历史查询</strong>存储在其中。代码的下一部分将致力于<strong class="jp ir">查询检索</strong>。第一步是循环输入字符串(前缀)。然后，遍历树，在包含前缀最后一个字符的根上结束。我们知道，可以通过从<strong class="jp ir">选择的节点</strong>开始递归遍历特里树<strong class="jp ir">来检索解决方案。</strong></p><p id="361f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们考虑下图，将“h”作为输入字符串。我们首先定位前缀“h”，然后对 trie 执行深度优先遍历以收集(-elp，-ell，-ide，-i)，如橙色箭头所示。如果我们考虑前缀“he”，同样的事情也适用，输出将是(-lp，-ll)，如红色箭头所示。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/28b81d7e93243b4f1e58e687ca63a726.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*gb4-NrSwDpKiLXb5vPcizA.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">特里树的深度优先遍历</figcaption></figure><p id="2c3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这可以通过下面的代码来实现。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mg mh l"/></div></figure><h1 id="29d6" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">让我们试试代码！</h1><p id="24f5" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">为了模拟当我们开始输入查询时在搜索引擎上实时发生的情况，我们将在 Flask 上构建一个 API 端点。</p><p id="b2bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用真实的历史查询数据集。据我们所知，这是最大的在线开放数据集，有超过 4.48 亿个查询。可以在这里下载<a class="ae lb" href="https://www.kaggle.com/datasets/hofesiy/2019-search-engine-keywords" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="810e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，这里我们将只使用前 100 万行，因为如果不进行并行化，树的构建过程可能会很慢。因此，为了简单起见，我们在这里构建了一个一百万个查询的 trie。同样，在这个例子中，频率是随机产生的。</p><p id="418a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，如果任何人有兴趣处理这个项目并使用完整的数据集分析性能，他/她可以在 Github 上的<a class="ae lb" href="https://github.com/kaislar/autocomplete" rel="noopener ugc nofollow" target="_blank"> projet 资源库中做出贡献。</a></p><p id="a7f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在这里构建的 API 有一个端点<strong class="jp ir"> /autocomplete </strong>，它将一个字符串作为参数，返回匹配输入前缀的前 10 个历史查询。</p><p id="d501" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，在运行应用程序之前，<strong class="jp ir"> trie 只构建一次</strong>。一旦完成，api 就准备好<strong class="jp ir">接收请求</strong>。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="41b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以通过向 API 端点发送几个请求来测试实现。如下图所示，这里的响应时间是 3 毫秒，这对于实时应用程序来说是可以接受的<strong class="jp ir">(从 100 万个历史查询数据中选择的 10k 个随机查询的平均 10ms/查询)</strong>。显然，我们没有考虑 trie 构建时间，因为这是在启动 api 之前完成的。在这种情况下，trie 构建时间大约为 30 秒。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/bb593c115800aaa65c982dd9f3a549aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*an9tkE0cU61qK_UH6QBAQA.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">发送到 API 的请求示例</figcaption></figure><h1 id="5b1c" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="c734" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在本文中，我们看到了如何使用 Trie 结构实现自动完成功能。这种结构背后的关键是以智能的方式安排历史数据，使得共享相同前缀的查询位于 trie 中的相同节点下。</p><p id="4dfb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经证明了搜索算法的复杂性与历史数据的大小无关。这是至关重要的，因为我们需要自动完成是可伸缩的和实时响应的。</p></div></div>    
</body>
</html>