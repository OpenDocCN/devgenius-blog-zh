<html>
<head>
<title>Push notifications on android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">android 上的推送通知</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/push-notifications-on-android-bff3cbe095c7?source=collection_archive---------4-----------------------#2022-04-19">https://blog.devgenius.io/push-notifications-on-android-bff3cbe095c7?source=collection_archive---------4-----------------------#2022-04-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/7ba8275fff5c99df6587ffc91db64b97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pMvsLysYeUZLrLd6-KuAmQ.jpeg"/></div></div></figure></div><div class="ab cl jv jw hr jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ig ih ii ij ik"><p id="b7d1" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">推送通知有点难以理解，尤其是如果你是初学者的话。在本帖中，我们将通过每一个步骤来访问我们在应用程序中收到的通知，所以请继续关注我。</p><p id="cb1a" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">首先，你需要建立一个 firebase 项目。将生成的<strong class="ke io"> google_services.json </strong>文件复制到<strong class="ke io"> android/app </strong>目录下，就可以按照下面的步骤进行了。</p><p id="8d23" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated"><strong class="ke io"> main.dart </strong>小部件如下图所示。</p><p id="375b" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们将编写<strong class="ke io">回调(流)</strong>，这将使我们对 initState 中的通知有更多的控制。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="73eb" class="lj lk in lf b gy ll lm l ln lo">void main() async {<br/>  WidgetsFlutterBinding.ensureInitialized();<br/>  await Firebase.initializeApp();</span><span id="7ea5" class="lj lk in lf b gy lp lm l ln lo">runApp(const MyApp());<br/>}<br/><br/>class MyApp extends StatefulWidget {<br/>  const MyApp({Key? key}) : super(key: key);</span><span id="15ca" class="lj lk in lf b gy lp lm l ln lo"><a class="ae lq" href="http://twitter.com/override" rel="noopener ugc nofollow" target="_blank">@override</a><br/>  State&lt;MyApp&gt; createState() =&gt; _MyAppState();<br/>}</span><span id="bab0" class="lj lk in lf b gy lp lm l ln lo">class _MyAppState extends State&lt;MyApp&gt; {<br/>  <a class="ae lq" href="http://twitter.com/override" rel="noopener ugc nofollow" target="_blank">@override</a><br/>  void initState() {<br/>    super.initState();<br/>     /// the code goes here<br/>  }</span><span id="40e7" class="lj lk in lf b gy lp lm l ln lo"><a class="ae lq" href="http://twitter.com/override" rel="noopener ugc nofollow" target="_blank">@override</a><br/>  Widget build(BuildContext context) {<br/>    return MaterialApp(<br/>      title: 'Etta : Test your chance',<br/>      debugShowCheckedModeBanner: false,<br/>      theme: theme(),<br/>      initialRoute: SplashScreen.routeName,<br/>      routes: routes,<br/>    );<br/>  }<br/>}</span></pre></div><div class="ab cl jv jw hr jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ig ih ii ij ik"><p id="12a1" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们将要看到的第一个回调/流是<strong class="ke io"> onMessage </strong>流。</p><p id="d7c9" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated"><strong class="ke io"> onMessage </strong>流是<strong class="ke io"> RemoteMessage </strong>的流。基本上所有回调都是<strong class="ke io"> RemoteMessage </strong>的流。</p><p id="9504" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">RemoteMessage 是我们正在接收的全部消息。它可能包含其他数据或仅包含通知。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="b602" class="lj lk in lf b gy ll lm l ln lo">FirebaseMessaging.onMessage.listen((message) {<br/>      print(message.notification?.title);<br/>      print(message.notification?.body);<br/>});</span></pre><p id="b962" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">在这里，我们可以获得发送的消息。</p><p id="4063" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">当应用程序在前台时，<strong class="ke io"> onMessage </strong>流将<strong class="ke io">仅</strong>工作。</p><p id="27a8" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">在尝试从 firebase 发送消息之前，继续在 onMessage 回调之前添加这一行。我们稍后将回到这个问题。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="c6b2" class="lj lk in lf b gy ll lm l ln lo">FirebaseMessaging.instance.getInitialMessage();</span></pre><p id="f34d" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">重启应用程序，并从 firebase <strong class="ke io">云消息服务</strong>控制台发送通知，同时将应用程序保留在后台。</p><figure class="la lb lc ld gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lr"><img src="../Images/67838ab5a91993ca395bc59db648190c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TkjinCHAunhH59Hiq5Vc9w.png"/></div></div></figure><p id="8ee1" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">过了一会儿，我们收到通知，消息被打印出来。</p><figure class="la lb lc ld gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ls"><img src="../Images/50b0fdce1c61c925e3984d9bc23643f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bHY3qafrs1I81y74FP-ofw.png"/></div></div></figure><p id="d429" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">这里需要注意的一点是，firebase 在默认情况下从不显示通知。发送的消息既不会出现在系统托盘上，也不会显示为抬头通知。</p><p id="c786" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">平视通知是那些显示在屏幕上的通知。</p><figure class="la lb lc ld gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/989a2100b6802b999d430b1632ba0689.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8K42saEeoqll0BotEJTzPA.jpeg"/></div></div></figure><p id="91cf" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">重要的是我们在<strong class="ke io"> onMessage </strong>流中获取消息。我们稍后将解决这个问题。</p></div><div class="ab cl jv jw hr jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ig ih ii ij ik"><p id="a7c4" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">现在让我们看看 onMessageOpenedApp 流。</p><p id="efdf" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">当我们在系统托盘上点击通知，想要做一些事情时，就会用到这个流。</p><p id="8016" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">为了使这个回调起作用，应用程序必须处于暂停状态，或者换句话说，最小化。它不应该被终止！</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="8e8a" class="lj lk in lf b gy ll lm l ln lo">FirebaseMessaging.onMessageOpenedApp.listen((message) {<br/>      print(message.notification?.title);<br/>      print(message.notification?.body);<br/>});</span></pre><p id="4673" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">重新启动应用程序后，将其最小化，并从 firebase 发送通知。</p><figure class="la lb lc ld gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lt"><img src="../Images/9cbac155661921a274221be3b45d86d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wq-dej6OCzykfbsWYnvfXA.png"/></div></div></figure><p id="8122" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">通知出现在系统托盘上。</p><figure class="la lb lc ld gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lu"><img src="../Images/ded39cbe1640b8dbac330faebf8d3ecf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_CyJMDxSLLhvKIbZEzVrwQ.jpeg"/></div></div></figure><p id="7516" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">如果您单击通知，它将按预期打印到控制台。</p><figure class="la lb lc ld gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lv"><img src="../Images/0256102f000932ae304de0550d2be1e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SXuP9muhL0lRTBEL_WM5Jg.png"/></div></div></figure><p id="3bdc" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">需要记住的一点是调试控制台中的这个警告。我们稍后将回到这个问题。</p><figure class="la lb lc ld gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lw"><img src="../Images/b095764248afed8575026251c0919bb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xod9YX4V-1tSHTgkKD9Mcw.png"/></div></div></figure></div><div class="ab cl jv jw hr jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ig ih ii ij ik"><p id="0372" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">app 终止的时候呢？</p><p id="f7a1" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">对于这种情况，正如您所猜测的，我们有另一个流。</p><p id="7710" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们不是在 initState 中注册这个流，而是在最开始的时候注册。</p><p id="f5ff" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">回调需要一个返回类型为<strong class="ke io"> future &lt; void &gt; </strong>的处理程序，并将<strong class="ke io"> RemoteMessage </strong>作为参数。</p><p id="b9ca" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">还有一点，这个处理程序应该是一个顶级函数。这意味着函数不能在任何类中。应该在一切的范围之外。这是因为后台消息处理程序在它自己的隔离(线程)中工作。它在应用程序范围之外工作。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="d699" class="lj lk in lf b gy ll lm l ln lo">Future&lt;void&gt; backgroundMessageHandler(RemoteMessage message) async {<br/>  print(message.notification!.title);<br/>  print(message.notification!.body);<br/>}</span><span id="de6f" class="lj lk in lf b gy lp lm l ln lo">void main() async {<br/>  WidgetsFlutterBinding.ensureInitialized();<br/>  await Firebase.initializeApp();<br/>  FirebaseMessaging.onBackgroundMessage(backgroundMessageHandler);<br/>  runApp(const MyApp());<br/>}</span></pre><p id="a2f6" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">再次运行应用程序，使代码生效并终止它，然后从 firebase 发送通知。</p><figure class="la lb lc ld gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lx"><img src="../Images/b9147770d94a7676b1e642cc7ebbdfbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*crCenTpuuXvePcJ9RDCA5g.png"/></div></div></figure><figure class="la lb lc ld gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lu"><img src="../Images/c236c25f73987a14802701dd2296a564.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iTa-2ZgbXsKBTeyIiuwT-Q.jpeg"/></div></div></figure><p id="7fea" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">当然，我们在终端上看不到日志，因为应用程序被终止了。但是，举例来说，我们可以在消息中发送数据，当通知被点击时，让应用程序做许多事情作为响应。</p><p id="e7d6" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们有另一个回调只是为了那种情况。我们一开始写的那个。<strong class="ke io"> getInitialMessage </strong>回调。</p><p id="bc3f" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">这个回调给你用户点击的消息，它也从终止状态打开应用程序。当它返回一个非空的东西时，这意味着用户点击了一个通知，它从终止状态打开了应用程序。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="7bac" class="lj lk in lf b gy ll lm l ln lo">FirebaseMessaging.instance.getInitialMessage().then((message) {<br/>  if (message != null) {<br/>    // you have control over the message<br/>  }<br/>});</span></pre><p id="4013" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">如果应用程序在未终止时收到通知，它将调用<strong class="ke io"> getInitialMessage </strong>，但是消息为空，因此检查消息是否为空是有用的。</p><p id="5d7a" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">就是这样！我们已经讨论了 firebase 消息中的所有回调/流。但是我们仍然有两个问题(让我们称之为问题)。</p><ul class=""><li id="3878" class="ly lz in ke b kf kg kj kk kn ma kr mb kv mc kz md me mf mg bi translated">在后台时，通知仅显示在系统托盘上。我们没有收到任何提醒通知。我们可以通过 firebase 上的一些配置来解决这个问题。</li><li id="6c2b" class="ly lz in ke b kf mh kj mi kn mj kr mk kv ml kz md me mf mg bi translated">而在前景中，它甚至没有给我们任何东西。</li></ul><p id="f00a" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">第一个原因是因为我们没有设置默认的通知通道。如果你还记得，当我们在后台发送通知时，我们一直收到这个警告。</p><figure class="la lb lc ld gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lw"><img src="../Images/b095764248afed8575026251c0919bb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xod9YX4V-1tSHTgkKD9Mcw.png"/></div></div></figure><p id="1227" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">为了解决这个问题，我们首先需要将这一行添加到<strong class="ke io"> android/app/src/main </strong>目录中的<strong class="ke io"> AndroifManifest.xml </strong>文件中。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="058a" class="lj lk in lf b gy ll lm l ln lo">&lt;meta-data android:name="com.google.firebase.messaging.default_notification_channel_id" <br/>android:value="etta_channel"<br/>/&gt;</span></pre><p id="59a6" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">android 8 之后，指定频道 id 变得很有必要。因为它是你的应用程序通知的身份。</p><p id="f87a" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们还可以在发送通知时将通知通道作为目标。</p><figure class="la lb lc ld gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mm"><img src="../Images/3edd88ccad0a6285124c74724045d68d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zpQDEefzfYPLm-24taQKTQ.png"/></div></div></figure><p id="2bd1" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">如果您现在尝试发送通知，它仍不会显示为提醒通知。我们仍然需要创建我们在 AndroidManifest.xml 文件中指定的通道。</p><p id="0d9a" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">为了创建一个通知通道，我们将使用一个名为<a class="ae lq" href="https://pub.dev/packages/flutter_local_notifications" rel="noopener ugc nofollow" target="_blank">flutter _ local _ notifications</a>的包。</p><p id="8f44" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">创建一个名为 services 的文件夹，并在其中创建一个<strong class="ke io">local _ notification . dart</strong>文件，我们将在其中编写创建通知通道的代码。</p><p id="7cae" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">将下面的代码复制并粘贴到您的<strong class="ke io">local _ notification _ service</strong>文件中。</p><figure class="la lb lc ld gt jo"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="90b0" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">然后我们在<strong class="ke io">主</strong>函数中调用 initialize。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="cf6f" class="lj lk in lf b gy ll lm l ln lo">void main() async {<br/>  WidgetsFlutterBinding.ensureInitialized();<br/>  LocalNotificationService.initialize();<br/>  await Firebase.initializeApp();<br/>  FirebaseMessaging.onBackgroundMessage(backgroundMessageHandler);<br/>  runApp(const MyApp());<br/>}</span></pre><p id="5c3e" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">第二件要做的事情是，如果你想在前台显示一个通知。在<strong class="ke io"> onMessage </strong>回调中调用<strong class="ke io"> display </strong>方法。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="e34c" class="lj lk in lf b gy ll lm l ln lo">FirebaseMessaging.onMessage.listen((message) {<br/>  LocalNotificationService.displayNotification(message);<br/>});</span></pre><p id="8d1a" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">这将允许我们在应用程序处于前台时获得抬头通知。</p><figure class="la lb lc ld gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lu"><img src="../Images/8a40eea3bb6bf5513a95e4f3c03f6e6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y2PjGw6DZExgdH-Cb42Fuw.jpeg"/></div></div></figure><p id="35d8" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">你不需要设置另一个东西。因为显示方法会自动创建一个通知通道，所以我们现在也可以在应用程序处于后台时接收到抬头通知。就是这样。我们解决了这两个问题。</p><p id="0ce8" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">感谢您的阅读。喜欢并分享更多。</p></div></div>    
</body>
</html>