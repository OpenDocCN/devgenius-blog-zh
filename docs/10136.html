<html>
<head>
<title>Movie recommendation using Apache Spark &amp; Scala</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Apache Spark 和 Scala 的电影推荐</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/movie-recommendation-using-apache-spark-scala-ade33fe81a6c?source=collection_archive---------4-----------------------#2022-10-09">https://blog.devgenius.io/movie-recommendation-using-apache-spark-scala-ade33fe81a6c?source=collection_archive---------4-----------------------#2022-10-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="610b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Apache Spark 是一个用于大数据和机器学习工作负载的开源、多语言和分布式处理引擎。它使用优化的查询执行和内存缓存来实现快速查询。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/08bdf19aab7aa3fd51506a0c8de8bb10.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*5h9Vl3pCFhy6e0lvpAWVtw.png"/></div></figure><p id="b431" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如今，Spark 被世界上的顶级公司使用，如亚马逊、雅虎、易贝…</p><p id="5eec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">看电影很有趣，但是想出接下来看什么电影却是一个令人恼火的经历。像网飞这样的公司开发了一个引擎，为我们推荐一个基于特定类型或与已经看过的电影相关的电影列表。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi kq"><img src="../Images/63578e4cd47e59c683a4e5af8f29b53b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*0VUCY8EGq33-hiomHKd_Ig.jpeg"/></div></figure><p id="f91a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Spark 可以处理非常大的数据集。因此，在本文中，我们将构建一个 Spark-Scala 引擎，使用 100 万行的数据集，提出与所选电影相关的前 10 部类似电影。</p><p id="db07" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">开始吧！</p><h1 id="0738" class="kr ks in bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">1-导入数据集</h1><p id="62ee" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh ig bi translated">我们将在下面的链接中使用数据集:<a class="ae lu" href="https://grouplens.org/datasets/movielens/" rel="noopener ugc nofollow" target="_blank"><em class="lv"/></a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi lw"><img src="../Images/f5ed3e66f3a04763870ff8f8de9395c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LUqmNhwaHjjir4k-h-yZ1Q.png"/></div></div></figure><p id="f42d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如图所示，您可以下载 MovieLens 1M 数据集，该数据集提供了 100 万个评级。</p><p id="c341" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">“ml-1m”文件夹包含两个重要文件:<em class="lv"> movies.dat </em>和<em class="lv"> rating.dat </em></p><p id="5c28" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第一个文件包含电影的 Id，电影的标题和类型。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi mb"><img src="../Images/32f2b075c3d911522253707fb8db4064.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/format:webp/1*veIv8iihEOr-3DL9VvVGHA.png"/></div></div></figure><p id="a10f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第二个包含用户的 Id，电影的 Id，评级和时间戳。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/0685fd08a6836d9efb1c7fc10041822e.png" data-original-src="https://miro.medium.com/v2/resize:fit:446/format:webp/1*oW4SmL6Trzl4Deg5LLzNLw.png"/></div></figure><h1 id="c0a9" class="kr ks in bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">2 —启动火花代码</h1><p id="3ad1" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh ig bi translated">这个项目中要做的第一件事是导入依赖项:</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="28a3" class="mi ks in me b gy mj mk l ml mm">import org.apache.log4j._<br/>import org.apache.spark.sql.functions._<br/>import org.apache.spark.sql.types.{IntegerType, LongType, StringType, StructType}<br/>import org.apache.spark.sql.{Dataset, SparkSession}</span></pre><p id="3abc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在是时候创建我们的 Scala 类了:</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="875d" class="mi ks in me b gy mj mk l ml mm">object MoviesRecommendation{</span><span id="5d1b" class="mi ks in me b gy mn mk l ml mm">// To DO</span><span id="cc9b" class="mi ks in me b gy mn mk l ml mm">}</span></pre><p id="02df" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文中，我们将使用<strong class="jm io">数据集</strong>代替 Dataframe 或 RDD。因此，我们可以从创建一个<em class="lv">案例类</em>开始，以读取下载的数据文件:</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="fee8" class="mi ks in me b gy mj mk l ml mm">case class MoviesNames(movieID: Int, movieTitle String)<br/>case class Movies(userID: Int, movieID: Int, rating: Int, timestamp:   Long)<br/>case class MoviePairs(movie1ID: Int, movie2ID: Int, rating1: Int, rating2: Int)<br/>case class MoviePairsSimilar(movie1ID: Int, movie2ID: Int, score: Double, numPairs: Long)</span></pre><p id="2949" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">之后，我们创建一个 Spark 会话:</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="0430" class="mi ks in me b gy mj mk l ml mm">val spark = SparkSession<br/>  .<em class="lv">builder<br/>  </em>.master("local[*]")<br/>  .appName("MoviesRecommendation")<br/>  .getOrCreate()</span></pre><p id="0001" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">创建会话后，我们创建模式来读取数据:</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="3cad" class="mi ks in me b gy mj mk l ml mm">// Create schema for reading movies names file<br/>val moviesNamesSchema = new StructType()<br/>  .add("movieID", IntegerType, nullable = true)<br/>  .add("movieTitle", StringType, nullable = true)<br/><br/>// Create schema for reading movies information<br/>val moviesSchema = new StructType()<br/>  .add("userID", IntegerType, nullable = true)<br/>  .add("movieID", IntegerType, nullable = true)<br/>  .add("rating", IntegerType, nullable = true)<br/>  .add("timestamp", LongType, nullable = true)</span></pre><p id="c528" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们可以将数据集导入为 csv 文件:</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="f454" class="mi ks in me b gy mj mk l ml mm">// Read movies names file "movies.dat"<br/><em class="lv">println</em>("\nLoading movies names...\n")<br/>import spark.implicits._<br/>val moviesNames = spark.read<br/>  .option("sep", "::")<br/>  .option("charset", "ISO-8859-1")<br/>  .schema(moviesNamesSchema)<br/>  .csv("data/ml-1m/movies.dat")<br/>  .as[MoviesNames]<br/><br/>// Read movies information file "rating.dat"<br/><em class="lv">println</em>("\nLoading movies rating...\n")<br/>val movies = spark.read<br/>  .option("sep", "::")<br/>  .schema(moviesSchema)<br/>  .csv("data/ml-1m/ratings.dat")<br/>  .as[Movies]</span></pre><p id="b109" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们不需要数据集中的 timestamp 列，所以我们只选择需要的列:</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="3ff9" class="mi ks in me b gy mj mk l ml mm">val ratings = movies.select("userID", "movieID", "rating")</span></pre><p id="0429" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过一个简单的 show()，我们可以看到第一个结果:</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="435c" class="mi ks in me b gy mj mk l ml mm">ratings.show(5)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/b6b6a94363ae0dff233d29b8be5e3fa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/1*0SIglDQNKV4jsDDNtzhCNw.png"/></div></figure><p id="bb7b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们将自我加入数据集“rating ”,以获得同一用户观看的一对电影及其给出的评级:</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="db2a" class="mi ks in me b gy mj mk l ml mm">val moviePairs = ratings.as("ratings1")<br/>  .join(ratings.as("ratings2"), $"ratings1.userID" === $"ratings2.userID" &amp;&amp; $"ratings1.movieID" &lt; $"ratings2.movieID")<br/>  .select($"ratings1.movieID".alias("movie1ID"),<br/>    $"ratings2.movieID".alias("movie2ID"),<br/>    $"ratings1.rating".alias("rating1"),<br/>    $"ratings2.rating".alias("rating2"))<br/>  .repartition(100)<br/>  .as[MoviePairs]</span></pre><blockquote class="mp mq mr"><p id="3bf2" class="jk jl lv jm b jn jo jp jq jr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg kh ig bi translated">备注:我们使用一组 100 万行，这非常庞大，因此我们必须使用重新分区选项将数据分布到所有这 100 个分区中。</p></blockquote><p id="caf1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的数据现在准备好了，我们将创建一个函数来计算一对电影之间的相似性。我们将使用一种叫做余弦相似度的方法。它是两个数字序列之间相似性的<a class="ae lu" href="https://en.wikipedia.org/wiki/Measure_of_similarity" rel="noopener ugc nofollow" target="_blank">度量，遵循以下公式:</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/b01cdd120f53c15160389dda325981ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*TvJ6APyET_L14O3POr8ryA.png"/></div></figure><p id="df81" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 main 函数之外，我们创建了一个名为<em class="lv"> findSimilarity </em>的方法来根据电影的评级计算一对电影的评分:</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="39fb" class="mi ks in me b gy mj mk l ml mm">def findSimilarity(spark: SparkSession, data: Dataset[MoviePairs]): Dataset[MoviePairsSimilarity] = {<br/><br/>  val pairScores = data<br/>    .withColumn("xx", <em class="lv">col</em>("rating1") * <em class="lv">col</em>("rating1"))<br/>    .withColumn("yy", <em class="lv">col</em>("rating2") * <em class="lv">col</em>("rating2"))<br/>    .withColumn("xy", <em class="lv">col</em>("rating1") * <em class="lv">col</em>("rating2"))<br/><br/>  val calculSimilarity = pairScores<br/>    .groupBy("movie1ID", "movie2ID")<br/>    .agg(<br/>      <em class="lv">sum</em>(<em class="lv">col</em>("xy")).alias("numerator"),<br/>      (<em class="lv">sqrt</em>(<em class="lv">sum</em>(<em class="lv">col</em>("xx"))) * <em class="lv">sqrt</em>(<em class="lv">sum</em>(<em class="lv">col</em>("yy")))).alias("denominator"),<br/>      <em class="lv">count</em>(<em class="lv">col</em>("xy")).alias("numPairs")<br/>    )<br/><br/>  import spark.implicits._<br/>  val result = calculSimilarity<br/>    .withColumn("score",<br/>      <em class="lv">when</em>(<em class="lv">col</em>("denominator") =!= 0, <em class="lv">col</em>("numerator") / <em class="lv">col</em>("denominator"))<br/>        .otherwise(null))<br/>    .select("movie1ID", "movie2ID", "score", "numPairs")<br/>    .as[MoviePairsSimilar]<br/><br/>  result<br/>}</span></pre><p id="f09c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们可以用上面的方法找出相似的电影:</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="edc9" class="mi ks in me b gy mj mk l ml mm">val moviePairSimilarities = <em class="lv">findSimilarity</em>(spark, moviePairs).cache()</span></pre><blockquote class="mp mq mr"><p id="f6eb" class="jk jl lv jm b jn jo jp jq jr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg kh ig bi translated">备注:建议使用“cache()”方法。这是一种优化机制，用于存储 Spark <strong class="jm io">数据集</strong>的中间计算，以便它们可以在后续操作中重用。</p></blockquote><p id="1e3f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了测试我们的程序，我们甚至可以定义一个电影 Id 或者在参数:</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="10b8" class="mi ks in me b gy mj mk l ml mm">var movieID: Int = 260 //Star Wars, by default<br/><br/>if (args.length &gt; 0) {<br/>  movieID = args(0).toInt<br/>}</span></pre><p id="3a84" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了提高这个引擎的质量，我们可以添加一个准确性和分数阈值来选择最佳电影:</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="0e9c" class="mi ks in me b gy mj mk l ml mm">val scoreThreshold = 0.97<br/>val coOccurenceThreshold = 1000.0<br/><br/>// Filter for movies with this sim that are "good" as defined by<br/>// our quality thresholds above<br/>val filteredResults = moviePairSimilarities.filter(<br/>  (<em class="lv">col</em>("movie1ID") === movieID || <em class="lv">col</em>("movie2ID") === movieID) &amp;&amp;<br/>    <em class="lv">col</em>("score") &gt; scoreThreshold &amp;&amp; <em class="lv">col</em>("numPairs") &gt; coOccurenceThreshold)</span><span id="76ec" class="mi ks in me b gy mn mk l ml mm">val results = filteredResults.sort(<em class="lv">col</em>("score").desc).take(10)</span></pre><p id="5491" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所使用的数据集包含电影 Id，因此要显示带有标题的结果，我们必须添加一个方法来按 Id 搜索标题(我们可以为此使用一个连接，但这不是一个快速的解决方案，尤其是当我们处理一个巨大的数据集时):</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="cb4b" class="mi ks in me b gy mj mk l ml mm"><em class="lv">/** Get movie name by given movie id */<br/></em>def getMovieName(movieNames: Dataset[MoviesNames], movieId: Int): String = {<br/>  val result = movieNames.filter(<em class="lv">col</em>("movieID") === movieId)<br/>    .select("movieTitle").collect()(0)<br/><br/>  result(0).toString<br/>}</span></pre><p id="3945" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，我们可以显示如下结果:</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="213e" class="mi ks in me b gy mj mk l ml mm"><em class="lv">println</em>("\nTop 10 similar movies for " + <em class="lv">getMovieName</em>(moviesNames, movieID))<br/>for (result &lt;- results) {<br/>  // Display the similarity result that isn't the movie we're looking at<br/>  var similarMovieID = result.movie1ID<br/>  if (similarMovieID == movieID) {<br/>    similarMovieID = result.movie2ID<br/>  }<br/>  <em class="lv">println</em>(<em class="lv">getMovieName</em>(moviesNames, similarMovieID) + "\tscore: " + result.score + "\tstrength: " + result.numPairs)<br/>}</span></pre><p id="602c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最终结果会是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi mw"><img src="../Images/5e531312151b34b67a378b7a9e4515ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fSZ4ES501O626T8Peh0sBw.png"/></div></div></figure></div></div>    
</body>
</html>