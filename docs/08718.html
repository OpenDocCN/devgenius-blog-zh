<html>
<head>
<title>Linux — tcpdump Deep Dive</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Linux — tcpdump 深入探讨</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/linux-tcpdump-deep-dive-c916908eb687?source=collection_archive---------4-----------------------#2022-07-05">https://blog.devgenius.io/linux-tcpdump-deep-dive-c916908eb687?source=collection_archive---------4-----------------------#2022-07-05</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="0805" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">高级 tcpdump 技能</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj kg"><img src="../Images/cd64fb0f67c7d9d0e8a1ea10ad0ef295.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8tm9-iAZ-9gPtTP4.png"/></div></figure><p id="482b" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">在众多的故障排除技术中，包捕获分析可以说是“皇冠上的明珠”，也是包括我自己在内的很多人一直在努力的方向。</p><p id="1475" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">所以，这两个工具<code class="fe lk ll lm ln b">tcpdump</code>和<code class="fe lk ll lm ln b">Wireshark</code>在工程师心目中的重要性就不用我多提了。在今天的文章中，我将为<code class="fe lk ll lm ln b">tcpdump</code>讲述一些高级技巧。</p><h1 id="b3be" class="lo lp ir bd lq lr ls lt lu lv lw lx ly jx lz jy ma ka mb kb mc kd md ke me mf bi translated">tcpdump 的历史</h1><p id="a844" class="pw-post-body-paragraph ko kp ir kq b kr mg js kt ku mh jv kw kx mi kz la lb mj ld le lf mk lh li lj ik bi translated">1988 年，劳伦斯伯克利国家实验室的四名工程师编写了 hallmark 工具<code class="fe lk ll lm ln b">tcpdump</code>。这个实验室也值得我们尊敬。这里已经有 13 位诺贝尔奖获得者了。</p><p id="9638" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">这个地方能产生突破性的技术也就不足为奇了。<code class="fe lk ll lm ln b">tcpdump</code>可以在各种类 Unix 操作系统上工作，包括 Linux、FreeBSD、macOS、Solaris 等。，也是使用最广泛的数据包捕获工具之一。</p><p id="faa2" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">但是<code class="fe lk ll lm ln b">tcpdump</code>需要依靠一个底层的能力来过滤数据包:<code class="fe lk ll lm ln b">BPF</code>。BPF 的全称是 Berkeley Packet Filter(也叫 BSD Packet Filter)，是<code class="fe lk ll lm ln b">tcpdump</code>等数据包捕获工具的底层基础。</p><p id="9f03" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">BPF 实现了一个数据包捕获虚拟机，并使用<code class="fe lk ll lm ln b">libpcap</code>来实现用户空间程序的数据包捕获。因此，流程看起来像这样:</p><p id="fb00" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated"><code class="fe lk ll lm ln b">tcpdump</code>调用<code class="fe lk ll lm ln b">libpcap</code>接口，该接口调用 BPF 实现包过滤和捕获。</p><pre class="kh ki kj kk gu ml ln mm mn aw mo bi"><span id="8f03" class="mp lp ir ln b gz mq mr l ms mt">tcpdump -&gt; libpcap -&gt; BPF</span></pre><h1 id="3ff5" class="lo lp ir bd lq lr ls lt lu lv lw lx ly jx lz jy ma ka mb kb mc kd md ke me mf bi translated">数据包捕获文件类型</h1><p id="871e" class="pw-post-body-paragraph ko kp ir kq b kr mg js kt ku mh jv kw kx mi kz la lb mj ld le lf mk lh li lj ik bi translated">如果你注意抓取文件的后缀名称，你会发现有几个不同的后缀名称，如<code class="fe lk ll lm ln b">pcap</code>、<code class="fe lk ll lm ln b">cap</code>、<code class="fe lk ll lm ln b">pcapng</code>。你有没有想过为什么有不同的文件类型？</p><h2 id="224c" class="mp lp ir bd lq mu mv dn lu mw mx dp ly kx my mz ma lb na nb mc lf nc nd me ne bi translated">pcap</h2><p id="bdbe" class="pw-post-body-paragraph ko kp ir kq b kr mg js kt ku mh jv kw kx mi kz la lb mj ld le lf mk lh li lj ik bi translated">这是<code class="fe lk ll lm ln b">libpcap</code>的格式，也是<code class="fe lk ll lm ln b">tcpdump</code>、<code class="fe lk ll lm ln b">Wireshark</code>等工具支持的默认文件格式。除了包数据外，<code class="fe lk ll lm ln b">pcap</code>格式的文件还包含包捕获文件的元信息，如版本号、包捕获时间、捕获的每个包的最大长度等。</p><h2 id="85f4" class="mp lp ir bd lq mu mv dn lu mw mx dp ly kx my mz ma lb na nb mc lf nc nd me ne bi translated">帽子</h2><p id="b9ae" class="pw-post-body-paragraph ko kp ir kq b kr mg js kt ku mh jv kw kx mi kz la lb mj ld le lf mk lh li lj ik bi translated">cap 文件可能包含<code class="fe lk ll lm ln b">libpcap</code>标准以外的一些数据格式，这些数据格式是由<code class="fe lk ll lm ln b">tcpdump</code>以外的一些数据包捕获程序生成的。例如，在 Citrix 的 NetScaler 负载平衡器中，<code class="fe lk ll lm ln b">nstrace</code>命令生成的数据包捕获文件扩展名为<code class="fe lk ll lm ln b">.cap</code>。</p><p id="ef0b" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">除了<code class="fe lk ll lm ln b">pcap</code>标准定义的信息外，该文件还包含 LB 前端连接和后端连接之间的映射信息。只要版本正确，Wireshark 就可以读取这些<code class="fe lk ll lm ln b">.cap</code>文件。</p><h2 id="f8e3" class="mp lp ir bd lq mu mv dn lu mw mx dp ly kx my mz ma lb na nb mc lf nc nd me ne bi translated">pcapng</h2><p id="274c" class="pw-post-body-paragraph ko kp ir kq b kr mg js kt ku mh jv kw kx mi kz la lb mj ld le lf mk lh li lj ik bi translated">虽然<code class="fe lk ll lm ln b">pcap</code>格式满足了大部分需求，但也存在一些不足。例如，现在多个网络端口的情况越来越普遍，我们经常需要从多个网络接口捕获数据包，所以在数据包捕获文件中，有时需要包含网络端口信息。</p><p id="43d4" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">借助<code class="fe lk ll lm ln b">pcapng</code>，单个数据包捕获文件可以包含多个网络接口上捕获的数据包。例如:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gi gj nf"><img src="../Images/902b94c50cb12c3829d35e8d37391ffd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*d_-DVEAK0LNIO7bY"/></div></div></figure><p id="6691" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">当然，<code class="fe lk ll lm ln b">pcapng</code>还有许多其他特性，比如更细粒度的数据包时间戳，允许向数据包添加注释，更灵活的元数据等等。如果您使用较新版本的 Wireshark 和 tshark 来捕获数据包，默认的数据包捕获文件已经是<code class="fe lk ll lm ln b">pcapng</code>格式了。</p><h1 id="2fc1" class="lo lp ir bd lq lr ls lt lu lv lw lx ly jx lz jy ma ka mb kb mc kd md ke me mf bi translated">tcpdump 的基本用法</h1><p id="f2f0" class="pw-post-body-paragraph ko kp ir kq b kr mg js kt ku mh jv kw kx mi kz la lb mj ld le lf mk lh li lj ik bi translated">虽然 tcpdump 有完整的文档和命令手册，但是如果您不经常捕获数据包，您就不能很好地掌握它们。另外，数据包捕获技术课是实践课，不是理论课，你需要大量的实践来掌握它。</p><h2 id="63f8" class="mp lp ir bd lq mu mv dn lu mw mx dp ly kx my mz ma lb na nb mc lf nc nd me ne bi translated">数据包捕获</h2><p id="3321" class="pw-post-body-paragraph ko kp ir kq b kr mg js kt ku mh jv kw kx mi kz la lb mj ld le lf mk lh li lj ik bi translated">使用<code class="fe lk ll lm ln b">tcpdump</code>捕获数据包，最常见的场景是捕获去往或来自某个 ip 的流量。我们可以使用主机{对等 IP}作为数据包捕获过滤器条件，例如:</p><pre class="kh ki kj kk gu ml ln mm mn aw mo bi"><span id="524d" class="mp lp ir ln b gz mq mr l ms mt">$ tcpdump host 10.10.23.76</span></pre><p id="7b5b" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">另一个常见的场景是捕获某个端口的流量。例如，如果我们想捕获 Nginx 流量，我们可以这样做:</p><pre class="kh ki kj kk gu ml ln mm mn aw mo bi"><span id="522b" class="mp lp ir ln b gz mq mr l ms mt">$ tcpdump port 22</span></pre><p id="f2be" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">我们还经常使用许多参数，例如:</p><ul class=""><li id="5d20" class="nk nl ir kq b kr ks ku kv kx nm lb nn lf no lj np nq nr ns bi translated"><strong class="kq is"> -w </strong>文件名，可以将消息保存到一个文件中；</li><li id="b92b" class="nk nl ir kq b kr nt ku nu kx nv lb nw lf nx lj np nq nr ns bi translated"><strong class="kq is"> -c </strong>号，可以抓取固定数量的数据包，避免在流量较大时意外抓取过多的数据包；</li><li id="e2eb" class="nk nl ir kq b kr nt ku nu kx nv lb nw lf nx lj np nq nr ns bi translated"><strong class="kq is"> -s </strong>长度，每个消息只能抓取一定长度；</li><li id="5db9" class="nk nl ir kq b kr nt ku nu kx nv lb nw lf nx lj np nq nr ns bi translated"><strong class="kq is"> -n </strong>，不做地址转换(例如，IP 地址转换为主机名，端口 80 转换为 http)；</li><li id="682b" class="nk nl ir kq b kr nt ku nu kx nv lb nw lf nx lj np nq nr ns bi translated"><strong class="kq is"> -v/-vv/-vvv </strong>，可打印更详细的消息信息；</li><li id="4e7b" class="nk nl ir kq b kr nt ku nu kx nv lb nw lf nx lj np nq nr ns bi translated"><strong class="kq is"> -e </strong>，可以打印二层信息，尤其是 MAC 地址；</li><li id="afa8" class="nk nl ir kq b kr nt ku nu kx nv lb nw lf nx lj np nq nr ns bi translated"><strong class="kq is"> -p </strong>，关闭混杂模式。所谓混杂模式，也就是嗅探，就是捕获目的地址不是本地地址的网络数据包。</li></ul><h2 id="3fbe" class="mp lp ir bd lq mu mv dn lu mw mx dp ly kx my mz ma lb na nb mc lf nc nd me ne bi translated">分组过滤器</h2><p id="bf21" class="pw-post-body-paragraph ko kp ir kq b kr mg js kt ku mh jv kw kx mi kz la lb mj ld le lf mk lh li lj ik bi translated">假设我们需要统计一个 HTTPS VIP 的访问流量中 TLS 版本(目前主要是 TLS1.0、1.1、1.2、1.3)的分布情况。</p><p id="dd8b" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">为了控制数据包捕获文件的大小，我们不想捕获所有 TLS 数据包，而只想捕获 TLS 版本信息。如何做到这一点？要知道，对于这个需求，<code class="fe lk ll lm ln b">tcpdump</code>本身并没有现成的滤镜，我们需要使用 BPF。</p><p id="ff66" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">BPF 基于偏移量解析数据包，因此我们也可以在<code class="fe lk ll lm ln b">tcpdump</code>中使用这种偏移量技术来满足我们的需求。以下命令可以在 TLS 握手阶段捕获客户端 Hello 数据包:</p><pre class="kh ki kj kk gu ml ln mm mn aw mo bi"><span id="c30f" class="mp lp ir ln b gz mq mr l ms mt">$ tcpdump -w file.pcap 'dst port 443 &amp;&amp; tcp[20]==22 &amp;&amp; tcp[25]==1'</span></pre><p id="e95b" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">我来给你解释一下上面的三个过滤条件。</p><ul class=""><li id="089b" class="nk nl ir kq b kr ks ku kv kx nm lb nn lf no lj np nq nr ns bi translated"><strong class="kq is"> dst port 443 </strong>:这是最简单的，就是捕获客户端发来的访问 HTTPS 的数据包。</li><li id="ca20" class="nk nl ir kq b kr nt ku nu kx nv lb nw lf nx lj np nq nr ns bi translated"><strong class="kq is"> tcp[20]==22: </strong>这是提取的 tcp 的第 21 个字节(因为初始序列号是从 0 开始的)，由于 TCP 头占用了 20 个字节，而 TLS 是 TCP 的有效载荷，那么 TLS 1 字节的第一个字节就是 TCP 的第 21 个字节，就是 tcp[20]。如果这个位置的值是 22(十进制)，则表明这是一个 TLS 握手消息。</li><li id="0e84" class="nk nl ir kq b kr nt ku nu kx nv lb nw lf nx lj np nq nr ns bi translated"><strong class="kq is"> tcp[25]==1: </strong>同样，这是 tcp 头的第 26 个字节。如果等于 1，则表示这是一个客户端 Hello 类型的 TLS 握手消息。</li></ul><p id="f005" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">下面是它在捕获文件中的样子:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gi gj ny"><img src="../Images/d0ce721866e6a5069adfe7390cf44f48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1cP1YgGZa3M3zrsZ"/></div></div></figure><p id="8950" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">注意，<code class="fe lk ll lm ln b">16</code>的值是十六进制的，如果转换成十进制，就是 22。</p><h2 id="1155" class="mp lp ir bd lq mu mv dn lu mw mx dp ly kx my mz ma lb na nb mc lf nc nd me ne bi translated">显示数据包内容</h2><p id="edb4" class="pw-post-body-paragraph ko kp ir kq b kr mg js kt ku mh jv kw kx mi kz la lb mj ld le lf mk lh li lj ik bi translated">有时你想看到 TCP 包的具体内容，比如应用层数据，那么你可以使用-X 参数以 ASCII 码显示 TCP 中的数据:</p><pre class="kh ki kj kk gu ml ln mm mn aw mo bi"><span id="88a0" class="mp lp ir ln b gz mq mr l ms mt">$ sudo tcpdump port 80 -X<br/>......<br/>05:06:57.394573 IP _gateway.52317 &gt; victorebpf.http: Flags [P.], seq 1:17, ack 1, win 65535, length 16: HTTP: GET / HTTP/1.1<br/>  0x0000:  4500 0038 282d 0000 4006 3a83 0a00 0202  E..8(-..@.:.....<br/>  0x0010:  0a00 020f cc5d 0050 0502 3a02 3ed1 3771  .....].P..:.&gt;.7q<br/>  0x0020:  5018 ffff 4421 0000 4745 5420 2f20 4854  P...D!..GET./.HT<br/>  0x0030:  5450 2f31 2e31 0d0a                      TP/1.1..</span></pre><h2 id="60ee" class="mp lp ir bd lq mu mv dn lu mw mx dp ly kx my mz ma lb na nb mc lf nc nd me ne bi translated">读取数据包捕获文件</h2><p id="dafb" class="pw-post-body-paragraph ko kp ir kq b kr mg js kt ku mh jv kw kx mi kz la lb mj ld le lf mk lh li lj ik bi translated">这个比较简单，tcpdump 可以用-r 参数和文件名读取文件，还可以添加过滤条件。例如:</p><pre class="kh ki kj kk gu ml ln mm mn aw mo bi"><span id="32d6" class="mp lp ir ln b gz mq mr l ms mt">$ tcpdump -r file.pcap ‘tcp[tcpflags] &amp; (tcp-rst) != 0’</span></pre><h2 id="3f65" class="mp lp ir bd lq mu mv dn lu mw mx dp ly kx my mz ma lb na nb mc lf nc nd me ne bi translated">过滤后转储</h2><p id="7835" class="pw-post-body-paragraph ko kp ir kq b kr mg js kt ku mh jv kw kx mi kz la lb mj ld le lf mk lh li lj ik bi translated">有时，我们希望从数据包捕获文件中过滤出所需的数据包，并将它们传输到另一个文件中。例如，您想从数据包捕获文件中找到 TCP RST 数据包，并将这些 RST 数据包保存到新文件中。然后这样做:</p><pre class="kh ki kj kk gu ml ln mm mn aw mo bi"><span id="cf65" class="mp lp ir ln b gz mq mr l ms mt">$ tcpdump -r file.pcap 'tcp[tcpflags] &amp; (tcp-rst) != 0' -w rst.pcap</span></pre><h2 id="09b4" class="mp lp ir bd lq mu mv dn lu mw mx dp ly kx my mz ma lb na nb mc lf nc nd me ne bi translated">控制捕获大小</h2><p id="5129" class="pw-post-body-paragraph ko kp ir kq b kr mg js kt ku mh jv kw kx mi kz la lb mj ld le lf mk lh li lj ik bi translated">我前面提到过<code class="fe lk ll lm ln b">-s</code> length 参数，它的使用场景其实包括延长抓包时间。我们在 tcpdump 中添加了<code class="fe lk ll lm ln b">-s</code>参数来指定捕获的每个包的最大长度，节省了包捕获文件的大小，延长了包捕获时间。</p><p id="9968" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">一般来说，帧头是 14 字节，IP 头是 20 字节，TCP 头是 20~40 字节。如果你清楚的知道这次抓包的重点是传输层，那么理论上，对于每个包，你只需要抓包传输层头，也就是前 14+20+40 字节(也就是前 14+20+40 字节)。74 字节):</p><pre class="kh ki kj kk gu ml ln mm mn aw mo bi"><span id="cacc" class="mp lp ir ln b gz mq mr l ms mt">$ tcpdump -s 74 -w file.pcap</span></pre><p id="fae4" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">如果默认捕获是 1500 字节，生成的数据包捕获文件将比上述数据包捕获文件大 20 倍。反之，使用相同的磁盘空间，上述方法可以捕获比默认长 20 倍的数据包！</p><h1 id="ea5f" class="lo lp ir bd lq lr ls lt lu lv lw lx ly jx lz jy ma ka mb kb mc kd md ke me mf bi translated">tcptrace</h1><p id="c314" class="pw-post-body-paragraph ko kp ir kq b kr mg js kt ku mh jv kw kx mi kz la lb mj ld le lf mk lh li lj ik bi translated">有时如果你想做包分析，你可以用<code class="fe lk ll lm ln b">tcpdump -r</code>打开原始捕获文件:</p><pre class="kh ki kj kk gu ml ln mm mn aw mo bi"><span id="6dcf" class="mp lp ir ln b gz mq mr l ms mt">$ tcpdump -r test.pcap | head -10<br/>reading from file test.pcap, link-type EN10MB (Ethernet)<br/>03:55:10.769412 IP victorebpf.51952 &gt; 180.101.49.12.https: Flags [S], seq 3448043385, win 64240, options [mss 1460,sackOK,TS val 237167733 ecr 0,nop,wscale 7], length 0<br/>03:55:10.779061 IP 180.101.49.12.https &gt; victorebpf.51952: Flags [S.], seq 156800001, ack 3448043386, win 65535, options [mss 1460], length 0<br/>...<br/>03:55:10.795327 IP 180.101.49.12.https &gt; victorebpf.51952: Flags [P.], seq 1502:3881, ack 518, win 65535, length 2379<br/>03:55:10.795356 IP victorebpf.51952 &gt; 180.101.49.12.https: Flags [.], ack 3881, win 61060, length 0<br/>03:55:10.802868 IP 180.101.49.12.https &gt; victorebpf.51952: Flags [P.], seq 3881:4228, ack 518, win 65535, length 347</span></pre><p id="1de4" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">但是很难分析上面的输出，因为有太多的信息。其实还有一个工具可以帮忙，那就是<code class="fe lk ll lm ln b">tcptrace</code>。它不能用于捕获数据包，但可以用于分析。</p><p id="b513" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">例如如下，<code class="fe lk ll lm ln b">tcptrace</code>告诉我们，这个数据包捕获文件中有 2 个 TCP 连接，它们以 RST 结尾:</p><pre class="kh ki kj kk gu ml ln mm mn aw mo bi"><span id="2289" class="mp lp ir ln b gz mq mr l ms mt">$ tcptrace -b test.pcap<br/>1 arg remaining, starting with 'test.pcap'<br/>Ostermann's tcptrace -- version 6.6.7 -- Thu Nov  4, 2004</span><span id="2fb4" class="mp lp ir ln b gz nz mr l ms mt">145 packets seen, 145 TCP packets traced<br/>elapsed wallclock time: 0:00:00.028527, 5082 pkts/sec analyzed<br/>trace file elapsed time: 0:00:04.534695<br/>TCP connection info:<br/>  1: victorebpf:51952 - 180.101.49.12:443 (a2b)   15&gt;   15&lt;  (complete)  (reset)<br/>  2: victorebpf:56794 - 180.101.49.58:443 (c2d)   56&gt;   59&lt;  (complete)  (reset)</span></pre><h1 id="e578" class="lo lp ir bd lq lr ls lt lu lv lw lx ly jx lz jy ma ka mb kb mc kd md ke me mf bi translated">结论</h1><p id="7412" class="pw-post-body-paragraph ko kp ir kq b kr mg js kt ku mh jv kw kx mi kz la lb mj ld le lf mk lh li lj ik bi translated">在这篇文章中，我谈到了一些关于<code class="fe lk ll lm ln b">tcpdump</code>的高级用法，我也提到了<code class="fe lk ll lm ln b">tcpdump</code>使用的技术，比如 BPF、libpcap 和不同的文件格式。最后，我介绍一个叫做<code class="fe lk ll lm ln b">tcptrace</code>的工具，如果您方便的时候没有 Wireshark，它可以帮助您进行包分析。我希望你喜欢我的分享。</p></div></div>    
</body>
</html>