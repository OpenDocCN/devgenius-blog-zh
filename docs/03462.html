<html>
<head>
<title>Best of Modern JavaScript — Composing Promises</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代JavaScript的精华——写作承诺</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/best-of-modern-javascript-composing-promises-2aa9a16ee16b?source=collection_archive---------3-----------------------#2020-11-07">https://blog.devgenius.io/best-of-modern-javascript-composing-promises-2aa9a16ee16b?source=collection_archive---------3-----------------------#2020-11-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/03241f72146e585e98a4c47fcacf7869.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WzQNt4EDoZQmmoDl"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@adigold1?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Adi Goldstein </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="e49c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自2015年以来，JavaScript有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究如何处理JavaScript promise异常。</p><h1 id="e293" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在基于承诺的函数中处理异常</h1><p id="ada5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以在基于承诺的函数中处理异常。</p><p id="e33c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果在<code class="fe me mf mg mh b">then</code>和<code class="fe me mf mg mh b">catch</code>回调中抛出异常，那么方法会将它们转换成拒绝。</p><p id="1b7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，如果我们在promise代码之前运行同步代码，那么整个函数会抛出一个异常。</p><p id="0452" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这可能是我们想要解决的问题。</p><p id="d8bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解决这个问题的一个方法是用try-catch包围synchronous和promise代码。</p><p id="0601" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="88c6" class="mq lc iq mh b gy mr ms l mt mu">function foo() {<br/>  try {<br/>    syncFn();<br/>    return asyncFn()<br/>      .then(result =&gt; {<br/>        //...<br/>      });<br/>  } catch (err) {<br/>    return Promise.reject(err);<br/>  }<br/>}</span></pre><p id="d6ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一个带有try-catch块的<code class="fe me mf mg mh b">foo</code>函数，它首先运行<code class="fe me mf mg mh b">syncFn</code>，然后运行返回承诺的<code class="fe me mf mg mh b">asyncFn</code>。</p><p id="a939" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在try块中返回承诺链。</p><p id="711d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果运行了<code class="fe me mf mg mh b">catch</code>块，那么我们返回一个被拒绝的承诺。</p><p id="1950" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这让我们始终保持函数异步。</p><h1 id="3f5a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在回调中运行同步代码</h1><p id="b788" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们也可以在回调中运行同步代码。</p><p id="4b2b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3a7e" class="mq lc iq mh b gy mr ms l mt mu">function foo() {<br/>  return asyncFn()<br/>    .then(result =&gt; {<br/>      syncFn();<br/>      return asyncFn2();<br/>    })<br/>    .then(result =&gt; {<br/>      //...<br/>    });<br/>}</span></pre><p id="64ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果同步<code class="fe me mf mg mh b">syncFn</code>函数在<code class="fe me mf mg mh b">then</code>回调中运行并抛出异常，那么返回的承诺将被拒绝。</p><p id="30a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">承诺链的起点也可以在<code class="fe me mf mg mh b">Promise</code>构造函数中。</p><p id="c9c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ba74" class="mq lc iq mh b gy mr ms l mt mu">function foo() {<br/>  return new Promise((resolve, reject) =&gt; {<br/>      syncFn();<br/>      resolve(asyncFn());<br/>    })<br/>    .then(result =&gt; {<br/>      //...<br/>    });<br/>}</span></pre><p id="e468" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在<code class="fe me mf mg mh b">Promise</code>构造函数回调中运行<code class="fe me mf mg mh b">syncFn</code>，这样我们就可以运行回调，以便在<code class="fe me mf mg mh b">syncFn</code>抛出错误时传播异常。</p><h1 id="28b6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">许下承诺</h1><p id="4da4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用不同的方式实现多个承诺。</p><p id="bc80" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想并行运行多个不相关的承诺，我们可以使用<code class="fe me mf mg mh b">Promise.all</code>方法。</p><p id="778d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="11a1" class="mq lc iq mh b gy mr ms l mt mu">Promise.all([<br/>    asyncFn1(),<br/>    asyncFn2(),<br/>  ])<br/>  .then(([result1, result2]) =&gt; {<br/>    //...<br/>  })<br/>  .catch(err =&gt; {<br/>    //...<br/>  });</span></pre><p id="da3b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们传入一组承诺返回函数。</p><p id="7a48" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们在<code class="fe me mf mg mh b">Promise.all</code>中传递它。</p><p id="0341" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用一个回调函数调用<code class="fe me mf mg mh b">then</code>，这个回调函数包含两个值的解析值的数组。</p><p id="e272" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用<code class="fe me mf mg mh b">catch</code>来捕捉它们发生的错误。</p><p id="37e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用它们遍历已解决的项目。</p><p id="d6d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c2fa" class="mq lc iq mh b gy mr ms l mt mu">Promise.all([<br/>    asyncFn1(),<br/>    asyncFn2(),<br/>  ])<br/>  .then((results) =&gt; {<br/>    for (const result of results) {<br/>      console.log(result);<br/>    }<br/>  })<br/>  .catch(err =&gt; {<br/>    //...<br/>  });</span></pre><p id="7b73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们获取<code class="fe me mf mg mh b">results</code>数组，并用for-of循环遍历它。</p><h1 id="788b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe me mf mg mh b">Promise.race()</code></h1><p id="4737" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">Promise.race</code>是另一种连锁承诺的方法。</p><p id="3fde" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它接受一个承诺数组，并返回一个已解决的承诺，该承诺的值是先解决的承诺的值。</p><p id="1f7a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4c39" class="mq lc iq mh b gy mr ms l mt mu">Promise.race([<br/>    asyncFn(),<br/>    delay(3000).then(function() {<br/>      throw new Error('timed out')<br/>    })<br/>  ])<br/>  .then(function(text) {<br/>    //...<br/>  })<br/>  .catch(function(reason) {<br/>    //...<br/>  });</span></pre><p id="2ebc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一系列与<code class="fe me mf mg mh b">asyncFn</code>和<code class="fe me mf mg mh b">delay</code>的承诺，它们都返回承诺。</p><p id="84a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用回调函数调用<code class="fe me mf mg mh b">then</code>,从最早解决的承诺中获取已解决的值。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/8588d91382626816558aec5397974a7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7XHj5HFRKiJ9Yof6"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@delfidelarua7?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">德尔菲·德拉鲁阿</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="04ac" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="ffcb" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用几种方法处理基于承诺的函数的错误。</p><p id="5689" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以用许多不同的方式运行多个承诺。</p></div></div>    
</body>
</html>