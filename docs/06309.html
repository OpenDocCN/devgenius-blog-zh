<html>
<head>
<title>Covering unit-tests running in sub-processes/threads on GitHub Actions using coverage.py</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用coverage.py覆盖在GitHub动作的子进程/线程中运行的单元测试</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/covering-unit-tests-running-in-sub-processes-threads-on-github-actions-using-coverage-py-825c3c4e08c1?source=collection_archive---------5-----------------------#2021-12-29">https://blog.devgenius.io/covering-unit-tests-running-in-sub-processes-threads-on-github-actions-using-coverage-py-825c3c4e08c1?source=collection_archive---------5-----------------------#2021-12-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="4218" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">代码库的“代码覆盖率”值描述了运行的单元测试覆盖了多少生产/开发代码。在开源的世界里，所有的维护者都尽最大努力保持这个高百分比，这个过程通常是通过像GitHub Actions和Codecov这样的工具自动完成的。因此，代码覆盖率成为检查特定代码库是否经过良好测试和可靠的一个很好的度量(并不总是如此)。</p><p id="2410" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">单元测试通常在衍生的子进程或线程中运行。子进程或多线程允许它们并行运行。如果测试花费了太多时间，它们也使得中途停止测试变得更加容易(概率测试)。</p><p id="42a4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，在子流程中运行单元测试会在本地存储库中以及远程存储库中产生问题。正如<code class="fe ki kj kk kl b">coverage.py</code>的文档所说——“测量那些子流程中的覆盖率可能会很棘手，因为您必须修改生成流程的代码来调用coverage.py。”</p><p id="bb9d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在下面的博客中，我们将首先尝试在默认模式下使用<code class="fe ki kj kk kl b">coverage.py</code>来覆盖通过在子流程中运行的单元测试所测试的代码。在检查完结果之后，我们将构建一个解决方案来覆盖本地存储库中“未覆盖”的代码。最后一步，我们还将配置GitHub动作，在我们的远程存储库中执行这项任务。</p><h1 id="06e3" class="km kn in bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">创建虚拟项目</h1><p id="28dc" class="pw-post-body-paragraph jk jl in jm b jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd lo kf kg kh ig bi translated">让我们创建一个名为<code class="fe ki kj kk kl b">Calculator</code>的新文件夹和一个新的python文件<code class="fe ki kj kk kl b">calc.py</code>。我将在同一个文件中创建4个简单的函数，然后进行测试-</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">计算器. py</figcaption></figure><p id="5e64" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们在一个名为<code class="fe ki kj kk kl b">test_calc.py</code>的新文件中为用<code class="fe ki kj kk kl b">calc.py</code>编写的函数创建一些单元测试</p><ul class=""><li id="79e7" class="ma mb in jm b jn jo jr js jv mc jz md kd me kh mf mg mh mi bi translated">我们将使用<code class="fe ki kj kk kl b">unittest</code>库来编写测试。</li><li id="71d1" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">我们需要在一个类中有4个独立的测试方法来测试我们的代码。</li><li id="0836" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">我们会在测试的时候尽量照顾到边缘情况。</li><li id="19f5" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">在测试<code class="fe ki kj kk kl b">divide</code>功能时，我们需要测试<code class="fe ki kj kk kl b">ValueError</code>是否被正确升起。</li></ul><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><h1 id="3ef6" class="km kn in bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">使用coverage.py运行单元测试</h1><p id="8cd7" class="pw-post-body-paragraph jk jl in jm b jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd lo kf kg kh ig bi translated">我们现在可以使用命令运行我们的测试了(<code class="fe ki kj kk kl b">-v</code>是为了更好的输出)—</p><pre class="lp lq lr ls gt mo kl mp mq aw mr bi"><span id="1722" class="ms kn in kl b gy mt mu l mv mw">python -m unittest -v</span></pre><p id="5306" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">输出—</p><pre class="lp lq lr ls gt mo kl mp mq aw mr bi"><span id="aa70" class="ms kn in kl b gy mt mu l mv mw">test_add (test_calc.TestCalc) ... ok     <br/>test_divide (test_calc.TestCalc) ... ok  <br/>test_multiply (test_calc.TestCalc) ... ok<br/>test_subtract (test_calc.TestCalc) ... ok</span><span id="ed11" class="ms kn in kl b gy mx mu l mv mw">----------------------------------------------------------------------<br/>Ran 4 tests in 0.001s</span><span id="3ede" class="ms kn in kl b gy mx mu l mv mw">OK</span></pre><p id="8bce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">测试工作正常！现在我们已经准备好测量我们测试的覆盖率，但是首先，让我们创建一个<code class="fe ki kj kk kl b">.coveragerc</code>文件来从覆盖率报告中省略<code class="fe ki kj kk kl b">test_calc</code>文件中的代码。文件的内容应该是—</p><pre class="lp lq lr ls gt mo kl mp mq aw mr bi"><span id="e28d" class="ms kn in kl b gy mt mu l mv mw">[run]<br/>omit=*/test*</span></pre><p id="dbba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">根目录现在应该有3个文件— <code class="fe ki kj kk kl b">calc.py</code>、<code class="fe ki kj kk kl b">test_cal.py</code>和<code class="fe ki kj kk kl b">.coveragerc</code>文件。</p><p id="004a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">执行下面的命令应该会运行测试，并在您的根文件夹中创建一个新的<code class="fe ki kj kk kl b">.coverage</code>文件(<code class="fe ki kj kk kl b">-v</code>是为了更好的输出)—</p><pre class="lp lq lr ls gt mo kl mp mq aw mr bi"><span id="85a7" class="ms kn in kl b gy mt mu l mv mw">coverage run -m unittest -v</span></pre><p id="dddb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ki kj kk kl b">.coverage</code>文件可以用来检查我们的代码覆盖率，使用命令—</p><pre class="lp lq lr ls gt mo kl mp mq aw mr bi"><span id="5dd4" class="ms kn in kl b gy mt mu l mv mw">coverage report</span></pre><p id="7319" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">覆盖范围—</p><pre class="lp lq lr ls gt mo kl mp mq aw mr bi"><span id="25ae" class="ms kn in kl b gy mt mu l mv mw">Name      Stmts   Miss  Cover<br/>-----------------------------<br/>calc.py      10      0   100%<br/>-----------------------------<br/>TOTAL        10      0   100%</span></pre><p id="63b2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">万岁！代码覆盖率是100%的！</p><h1 id="9356" class="km kn in bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">使用coverage.py的默认设置在子流程中运行单元测试</h1><p id="f8c1" class="pw-post-body-paragraph jk jl in jm b jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd lo kf kg kh ig bi translated">我们真的不需要在子流程中运行这些测试，因为它们非常简单，但是为了本教程，让我们使用<code class="fe ki kj kk kl b">multiprocessing</code>在子流程中运行它们。首先，让我们编辑我们的函数来捕获队列中的返回值，而不是简单地返回它们—</p><ul class=""><li id="9f2d" class="ma mb in jm b jn jo jr js jv mc jz md kd me kh mf mg mh mi bi translated">我们不能简单地通过<code class="fe ki kj kk kl b">multiprocessing.Process()</code>调用返回值。</li><li id="816b" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">我们可以使用共享变量在进程间进行通信。</li><li id="e40c" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">这里我们使用一个<code class="fe ki kj kk kl b">Queue</code>来完成这个任务(好了，现在你知道如何在开发中使用数据结构了)。</li><li id="83df" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">另一个可以用来完成这个任务的数据结构是<code class="fe ki kj kk kl b">Dictionary</code>或<code class="fe ki kj kk kl b">multiprocessing.Manager().dict()</code>(好了，现在你知道如何在开发中使用2个数据结构了)。</li></ul><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="62ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了保持例子的简单，我将为每个函数只创建一个测试—</p><ul class=""><li id="e09f" class="ma mb in jm b jn jo jr js jv mc jz md kd me kh mf mg mh mi bi translated">我们创建一个新的<code class="fe ki kj kk kl b">Queue</code>并将其作为函数的参数传递，然后将其填充到函数中，并在测试中使用该值。</li></ul><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="8f22" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是一个很大的挑战，但是现在让我们启动我们的测试，看看<code class="fe ki kj kk kl b">multiprocessing</code>调用是否会给覆盖率带来任何变化——</p><pre class="lp lq lr ls gt mo kl mp mq aw mr bi"><span id="33f5" class="ms kn in kl b gy mt mu l mv mw">coverage run -m unittest -v</span></pre><p id="7c17" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">输出—</p><pre class="lp lq lr ls gt mo kl mp mq aw mr bi"><span id="0609" class="ms kn in kl b gy mt mu l mv mw">test_add (test_calc.TestCalc) ... ok<br/>test_divide (test_calc.TestCalc) ... ok<br/>test_multiply (test_calc.TestCalc) ... ok<br/>test_subtract (test_calc.TestCalc) ... ok</span><span id="7826" class="ms kn in kl b gy mx mu l mv mw">----------------------------------------------------------------------<br/>Ran 4 tests in 0.986s</span><span id="3455" class="ms kn in kl b gy mx mu l mv mw">OK</span></pre><p id="13c0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">测试仍然有效！现在是报道的时间了—</p><pre class="lp lq lr ls gt mo kl mp mq aw mr bi"><span id="89f5" class="ms kn in kl b gy mt mu l mv mw">coverage report</span></pre><p id="08ef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">输出—</p><pre class="lp lq lr ls gt mo kl mp mq aw mr bi"><span id="61cb" class="ms kn in kl b gy mt mu l mv mw">Name      Stmts   Miss  Cover<br/>-----------------------------<br/>calc.py      14      8    43%<br/>-----------------------------<br/>TOTAL        14      8    43%</span></pre><p id="f407" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如预期的那样，覆盖率下降了，即使使用测试覆盖了整个代码。以下命令将帮助我们更好地可视化覆盖范围-</p><pre class="lp lq lr ls gt mo kl mp mq aw mr bi"><span id="ea17" class="ms kn in kl b gy mt mu l mv mw">coverage html</span></pre><p id="8314" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个命令将在我们的根目录下创建一个名为<code class="fe ki kj kk kl b">htmlcov</code>的文件夹。这个目录中的HTML文件可以在我们常规的web浏览器中打开，正如所料，子进程中执行的代码行没有使用<code class="fe ki kj kk kl b">coverage.py</code> —</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi my"><img src="../Images/1d385f0e91c32b575581bc386b2d3022.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*fikHd4jdZCnvEitrg5SdBQ.png"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">代码覆盖率的可视化</figcaption></figure><h1 id="99f8" class="km kn in bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">使用coverage.py在子流程中运行单元测试(这次是正确的方式)</h1><p id="e3d2" class="pw-post-body-paragraph jk jl in jm b jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd lo kf kg kh ig bi translated">这一次，我们将明确地告诉<code class="fe ki kj kk kl b">coverage.py</code>我们正在子流程中运行测试。下面描述的步骤是用户在使用子进程或多线程时应该经历的一般步骤。然而，将<code class="fe ki kj kk kl b">coverage.py</code>与<code class="fe ki kj kk kl b">multiprocessing</code>一起使用有一个捷径，我们将在前面讨论。现在，可以在我们的<code class="fe ki kj kk kl b">.coveragerc</code>文件中指定在子流程中“激活”覆盖所需的命令。这些文件接受两个命令——<code class="fe ki kj kk kl b">concurrency</code>和<code class="fe ki kj kk kl b">parallel</code>——在<code class="fe ki kj kk kl b">[run]</code>参数下。根据文献记载—</p><ol class=""><li id="e688" class="ma mb in jm b jn jo jr js jv mc jz md kd me kh nb mg mh mi bi translated">并发</li></ol><blockquote class="nc nd ne"><p id="e2fc" class="jk jl nf jm b jn jo jp jq jr js jt ju ng jw jx jy nh ka kb kc ni ke kf kg kh ig bi translated">concurrency(多字符串，默认“线程”):产品代码使用的名称并发库。如果您的程序使用多处理、gevent、greenlet或eventlet，您必须在这个选项中命名该库，否则coverage.py将产生非常错误的结果。</p></blockquote><p id="65f3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.平行的</p><blockquote class="nc nd ne"><p id="df53" class="jk jl nf jm b jn jo jp jq jr js jt ju ng jw jx jy nh ka kb kc ni ke kf kg kh ig bi translated">parallel (boolean，默认为False):将机器名、进程id和随机数附加到数据文件名，以简化从多个进程收集数据的过程</p></blockquote><p id="f24b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以现在我们的<code class="fe ki kj kk kl b">.coveragerc</code>看起来会像这样-</p><pre class="lp lq lr ls gt mo kl mp mq aw mr bi"><span id="e64c" class="ms kn in kl b gy mt mu l mv mw">[run]<br/>concurrency=multiprocessing<br/>parallel=True<br/>omit=*/test*</span></pre><p id="233c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，我们还需要在根目录中添加一个<code class="fe ki kj kk kl b">sitecustomize.py</code>文件，代码如下</p><pre class="lp lq lr ls gt mo kl mp mq aw mr bi"><span id="4b08" class="ms kn in kl b gy mt mu l mv mw">import coverage<br/>coverage.process_startup()</span></pre><p id="a889" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后一步是设置一个环境变量—</p><pre class="lp lq lr ls gt mo kl mp mq aw mr bi"><span id="2526" class="ms kn in kl b gy mt mu l mv mw">export COVERAGE_PROCESS_START=$PWD/.coveragerc</span></pre><p id="a058" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是！由于我们使用的是<code class="fe ki kj kk kl b">multiprocessing</code>，我们不必指定所有这些，相反，我们可以在终端命令中直接传递<code class="fe ki kj kk kl b">concurrency</code>。我们仍将保留<code class="fe ki kj kk kl b">parallel</code>命令，以简化从许多进程中收集数据。</p><p id="c333" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们的<code class="fe ki kj kk kl b">.coveragerc</code>应该是这样的—</p><pre class="lp lq lr ls gt mo kl mp mq aw mr bi"><span id="a4ad" class="ms kn in kl b gy mt mu l mv mw">[run]<br/>parallel=True<br/>omit=*/test*</span></pre><p id="5d64" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以使用下面的命令来运行我们的测试，并向<code class="fe ki kj kk kl b">coverage.py</code>指定我们正在使用<code class="fe ki kj kk kl b">multiprocessing</code>在子流程中运行测试</p><pre class="lp lq lr ls gt mo kl mp mq aw mr bi"><span id="fc3c" class="ms kn in kl b gy mt mu l mv mw">coverage run --concurrency=multiprocessing -m unittest -v</span></pre><p id="1927" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦该命令被执行，<code class="fe ki kj kk kl b">coverage.py</code>将在我们的根目录中为每个子流程创建一个单独的覆盖文件。要合并文件，我们可以执行-</p><pre class="lp lq lr ls gt mo kl mp mq aw mr bi"><span id="61de" class="ms kn in kl b gy mt mu l mv mw">coverage combine</span></pre><p id="4c69" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，对于覆盖率报告，我们可以执行—</p><pre class="lp lq lr ls gt mo kl mp mq aw mr bi"><span id="a3ab" class="ms kn in kl b gy mt mu l mv mw">coverage report</span></pre><p id="e8c1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">输出—</p><pre class="lp lq lr ls gt mo kl mp mq aw mr bi"><span id="8b81" class="ms kn in kl b gy mt mu l mv mw">Name      Stmts   Miss  Cover<br/>-----------------------------<br/>calc.py      14      0   100%<br/>-----------------------------<br/>TOTAL        14      0   100%</span></pre><p id="dd02" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有用！！！！即使在子流程中运行测试之后，我们的覆盖率也回到了100%。</p><h1 id="d42b" class="km kn in bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">在GitHub Actions上使用coverage.py在子流程中运行单元测试</h1><figure class="lp lq lr ls gt lt gh gi paragraph-image"><a href="https://www.seifbassem.com/blogs/posts/bicep-and-github-actions/"><div class="gh gi nj"><img src="../Images/da8c33f3027eb5939c0cbe5274628d16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1tXo2MWkaZZF9m1L.jpg"/></div></a></figure><p id="6529" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，我们现在可以将代码推送到GitHub，并使用GitHub Actions、coverage.py和Codecov运行单元测试。</p><p id="cb2c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们首先在GitHub上创建一个新的存储库，并推送我们现有的代码(如果您没有Codecov帐户，请创建一个新的Codecov帐户)。接下来，我们导航到存储库中的<code class="fe ki kj kk kl b">Actions</code>选项卡，并为<code class="fe ki kj kk kl b">Python Application</code>创建一个新动作(我们也可以在本地完成)。<code class="fe ki kj kk kl b">yaml</code>代码应该是这样的</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="087b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦这个文件被提交，测试应该会自动运行，并且覆盖率应该可以在Codecov上获得。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nk"><img src="../Images/a881857a6c8095e200d5084556cb9db1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fKgbt1ErqMs2BAvO354JVw.png"/></div></div></figure><p id="e409" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">覆盖率100%！！</p><p id="c999" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">完整的代码可以在这里找到—<a class="ae np" href="https://github.com/Saransh-cpp/Covering-unit-tests-running-in-subprocesses" rel="noopener ugc nofollow" target="_blank">https://github . com/saran sh-CPP/Covering-unit-tests-running-in-subprocesses</a></p><p id="df8b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，您还可以使用<code class="fe ki kj kk kl b">README</code>徽章(可以从Codecov生成)来跟踪覆盖率</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nq"><img src="../Images/c1766ea964e01670a2a974e3fd22f47a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2D3e4yKCS_Y3bau1oamP5A.png"/></div></div></figure><p id="be14" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以迷因结束这篇博客(我喜欢迷因)—</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/8d853963d4802636e833dd8625f27ebe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/0*Mg3IK9mwghZDah9a.png"/></div></figure><p id="9767" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢阅读！</p></div></div>    
</body>
</html>