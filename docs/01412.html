<html>
<head>
<title>Dockerizing Your First Node Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将您的第一个节点应用程序归档</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/dockerizing-your-first-node-application-ea77b952a8d6?source=collection_archive---------31-----------------------#2020-07-02">https://blog.devgenius.io/dockerizing-your-first-node-application-ea77b952a8d6?source=collection_archive---------31-----------------------#2020-07-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3281836fafacfb3c7a2bf882cb2eb026.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JWHo_si5RZYYAy8y"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kc" href="https://unsplash.com/@justusmenke?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Justus Menke </a>拍摄</figcaption></figure><p id="c4df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Docker 对我来说一直是个谜。我一直都知道关于容器化和 Docker 的讨论，但是看配置文件和阅读关于它如何工作的文章总是让我抓狂。</p><p id="2ebe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最重要的是，我知道我可以做任何我想做的事情，而不用整理我的申请。是的，当在不同的计算机和环境中移动项目时，有时事情会变得有点棘手，但不知何故我总是设法让它工作。所以何必呢？那是直到现在。</p><p id="77f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最近，我在网上上了一门 Docker 课程，并将我的几个项目做了文档化。那时我才意识到 Docker <strong class="kf ir">真的有多棒，安装起来又有多简单。一些众所周知的好处是:</strong></p><ul class=""><li id="48f7" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">由于应用程序容器化大大降低了服务器成本，因此投资回报率很高</li><li id="57bf" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">使开发变得非常容易，并且跨机器保持一致(不再有“它只在我的机器上工作”的问题)</li><li id="b698" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">每个容器都是隔离的，所以您可以在同一台机器上运行多个容器，而不用担心资源污染</li></ul><p id="2e84" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我不会从理论上解释 Docker 为何如此优秀，而是将重点放在实践方面，向您展示如何将您现有的应用程序 Docker 化。我将对一个现有的节点 Web 应用程序进行 dockerize。让我们开始吧。</p><p id="bae7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一个非常简单的节点应用程序，带有一个列出我所有依赖项的<code class="fe lp lq lr ls b">package.json</code>和一个包含我的 express 应用程序的<code class="fe lp lq lr ls b">index.js</code>。下面是完整的应用程序代码:</p><figure class="lt lu lv lw gt jr"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="844c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如你所见，这是一个超级简单的应用程序。它只有一条航线，<code class="fe lp lq lr ls b">/</code>，在<code class="fe lp lq lr ls b">3000</code>港运行。每次点击端点时，它都会返回一个占位符文本。</p><p id="c97f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您要做的第一件事是添加一个<code class="fe lp lq lr ls b">Dockerfile</code>到您的根项目目录中。这个文件将定义如何构建你的 docker 应用程序的 docker 映像。它看起来是这样的:</p><figure class="lt lu lv lw gt jr"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="d46d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们一行一行地浏览这个文件，看看发生了什么。</p><p id="86a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">第 1 行</strong></p><p id="58be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该文件必须以关键字<code class="fe lp lq lr ls b">FROM</code>开头。这是您的图像所基于的基础图像。通常它很轻。你能想到的所有栈都有 docker 镜像:MySQL、Flask、Django、Redis、Node、React、Kafka、RabbitMQ 等等。因此，无论您的应用程序是什么，您都会找到某种基础映像来开始工作。</p><p id="ad08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的例子中，我们的图像基于任何节点应用程序都通用的<code class="fe lp lq lr ls b">node:latest</code></p><p id="246a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">第三行</strong></p><p id="fa98" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lp lq lr ls b">EXPOSE</code>关键字用于从容器中公开一个端口。默认情况下，所有的容器端口都是关闭的，所以一旦你的容器开始运行，你将无法在任何端口上访问它。因此，您希望通过关键字显式公开所需的端口。</p><p id="9373" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的例子中，我们从我们的<code class="fe lp lq lr ls b">index.js</code>得知我们的节点应用程序正在监听端口<code class="fe lp lq lr ls b">3000</code>。所以我们想公开那个集装箱港口。</p><p id="451e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">第 5 行</strong></p><p id="3ab6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lp lq lr ls b">RUN</code>关键字用于运行容器中的任何命令。任何你能想到的 Linux 命令，你都可以根据你的基本映像直接运行它，或者使用<code class="fe lp lq lr ls b">apt-get</code>或者类似的东西安装这个包。</p><p id="dca0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用关键字来创建一个新目录，我们将把应用程序源代码放在这个目录中。</p><p id="c01b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">第 7 行</strong></p><p id="8833" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lp lq lr ls b">WORKDIR</code>关键字基本上是一个<code class="fe lp lq lr ls b">cd</code>，用于移动到我们刚刚创建的目录中。</p><p id="81ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">第九行</strong></p><p id="2e17" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是事情变得有趣的地方。<code class="fe lp lq lr ls b">COPY</code>关键字用于将文件从本地机器复制到容器中。语法如下:</p><p id="ae44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lp lq lr ls b">COPY &lt;host_directory&gt; &lt;container_directory&gt;</code></p><p id="c54b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们将把包含所有应用程序依赖项的<code class="fe lp lq lr ls b">package.json</code>从本地机器复制到我们刚刚创建并移动到的容器目录中。</p><p id="00e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">第 11 行</strong></p><p id="ae35" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我们使用<code class="fe lp lq lr ls b">RUN</code>关键字来运行<code class="fe lp lq lr ls b">npm install</code>，它将安装我们的应用程序需要的所有包。如果我们只是克隆了一个存储库，并希望安装所有的依赖项，这与我们需要做的事情完全相同。</p><p id="c6c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行这个命令后，我们的容器将拥有运行我们的应用程序所需的所有包。</p><p id="58f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">第 13 行</strong></p><p id="7745" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我们只是使用<code class="fe lp lq lr ls b">RUN</code>关键字来清理 NPM 缓存。默认情况下，当我们安装软件包时，其中一些会被容器缓存。缓存增加了我们图像的大小，还会在以后引入版本问题。因此，删除缓存是一个很好的做法。</p><p id="e865" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">第 15 行</strong></p><p id="f9af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里使用相同的<code class="fe lp lq lr ls b">COPY</code>语法将本地机器当前目录中的所有内容复制到容器的当前目录中。这意味着我们只是将应用程序代码从我们的机器复制到容器中。</p><p id="5033" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">第 17 行</strong></p><p id="ec07" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，<code class="fe lp lq lr ls b">CMD</code>关键字用于定义启动容器时将运行的命令。在我们的例子中，当我们运行容器时，我们希望 Node Express 应用程序启动，所以我们只是使用稍微不同的语法来执行<code class="fe lp lq lr ls b">npm index.js</code>。</p><p id="fe64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是你创建 docker 形象所需要的全部。现在，您将能够创建一个 docker 映像来在任何机器上运行您的应用程序。</p><h1 id="0d9d" class="lz ma iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated"><strong class="ak">建筑&amp;运行集装箱进场 1 </strong></h1><p id="6b51" class="pw-post-body-paragraph kd ke iq kf b kg mx ki kj kk my km kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">自然，接下来要看的是如何实际创建图像，然后运行容器。这就像运行两个命令一样简单:</p><p id="7a02" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lp lq lr ls b">docker image build -t &lt;your_username&gt;:&lt;name_of_image&gt; .</code></p><p id="61d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将使用当前目录中的 docker 文件创建图像，并根据您在<code class="fe lp lq lr ls b">-t</code>标志后添加的内容对其进行命名。</p><p id="b634" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lp lq lr ls b">docker container run -p 80:3000 -d &lt;image_name&gt;</code></p><p id="868a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，您可以使用这个命令来实际运行容器。需要注意的一点是<code class="fe lp lq lr ls b">-p</code>标志:它将本地机器的端口 80 映射到容器的端口 3000。如果你回头看，我们从容器中暴露了端口 3000，因为我们的节点应用程序正在监听它。我们需要将它映射到本地机器上的一个端口，这样我们就可以通过它到达容器。语法是<code class="fe lp lq lr ls b">-p &lt;port_in_local_machine&gt;:&lt;port_in_container&gt;</code></p><h1 id="edea" class="lz ma iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated"><strong class="ak">建筑&amp;运行集装箱进场 2 </strong></h1><p id="73f1" class="pw-post-body-paragraph kd ke iq kf b kg mx ki kj kk my km kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">如果您不太熟悉 docker 命令，并且希望有一种更简单的方法来构建和运行容器(假设您已经努力编写了 docker 文件)，那么您可以使用另一个 CLI 工具和名为<code class="fe lp lq lr ls b">docker-compose</code>的配置文件。</p><p id="8dee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是 docker-compose 文件，用于自动构建映像并运行容器:</p><figure class="lt lu lv lw gt jr"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="d1d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">docker-compose 文件所做的就是使用我们之前定义的 Dockerfile 从当前上下文(目录)构建图像。此外，它还进行端口映射，就像我们用<code class="fe lp lq lr ls b">-p</code>标志做的那样。设置好之后，您就可以使用 CLI 并运行<code class="fe lp lq lr ls b">docker-compose up</code>来构建映像并启动容器。</p><p id="0066" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，您只需进入<code class="fe lp lq lr ls b">localhost:80</code>或<code class="fe lp lq lr ls b">localhost</code>就可以看到您的应用程序正在工作！！</p><p id="effc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无论何时你完成了开发或测试，你都可以通过运行<code class="fe lp lq lr ls b">docker-compose down</code>来关闭一切。</p><p id="0d9e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你在理解代码时遇到困难，我很抱歉，所以我在这里链接了完整的代码示例。</p><p id="0a6f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你有任何问题，请告诉我，我将非常乐意回答。</p></div></div>    
</body>
</html>