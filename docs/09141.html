<html>
<head>
<title>Evolutionary algorithms: theoretical aspects of evolution</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">进化算法:进化的理论方面</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/evolutionary-algorithms-theoretical-aspects-of-evolution-c7dd021d8bd3?source=collection_archive---------15-----------------------#2022-08-01">https://blog.devgenius.io/evolutionary-algorithms-theoretical-aspects-of-evolution-c7dd021d8bd3?source=collection_archive---------15-----------------------#2022-08-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/78afe814a7cc24d64e587a644f374c36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Xth0KDQFPG6UlX9C"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">安妮·尼加德在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="fe3d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们正在通过参观我一直最喜欢的:进化算法来开始我们对人工智能的入侵。上次我们谈了一点<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/entering-the-artificial-intelligence-maze-d58fb6eb5554">关于实现人工智能意味着什么。我们看到这不是关于游戏角色如何避开你的目标，也不是如何解决一个迷宫。使用确定性算法，这两件事都可以做得很好。根据计算机科学的定义，人工智能是指将生物特征和行为借用到程序中来解决给定的任务。</a></p><p id="1a4c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">进化算法试图通过直接执行生物有机体的进化过程来找到解决方案。也就是说，从一个随机的解决方案开始，用进化行为来改进它，直到这个解决方案能够解决我们的问题。当然，为了实现这一点，科学家们必须对进化进行分割和标记，并将其转化为一种算法，使其符合我们目前对世界如何运转的假设。结果呢？四个步骤。</p><h2 id="3f16" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">第一步:选择父母</h2><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lu"><img src="../Images/c5faac9c4222227b8b91586cf2fb7fa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Rrp2pcl3--DsTGCZ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@victoriano?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">维多利亚诺·伊斯基耶多</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="c39c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们都相信真正自发的爱，但在生物学中，这只是自然选择的副产品:从长远来看，倾向于更好的父母。更好是什么意思？这取决于需要解决的问题:也许是冰河时期，污染，人口过剩，每种情况都需要某些适应良好的父母，他们能够创造出适应更好的孩子。当然，这不会在一夜之间发生，而是跨越几代人，为我们称之为爱的随机产物留下空间。</p><p id="88b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想在代码中实现这一点，我们需要通过测量所有可用的解决方案，从一组解决方案中选择两个，并找到最好的两个。他们也不一定是两个。这是我们的算法，所以我们可以选择尽可能多的父母，但我们仍然必须实现一些倾向于选择更好的。这很简单。我将在这里使用一种随机的 javascript 语法来解释:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="5634" class="lb lc iq ma b gy me mf l mg mh">let population = [a, b, c, d, e];<br/>let parent1 = pickParent(population);<br/>let parent2 = pickParent(population);</span></pre><p id="834d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们有了一个给定问题的解决方案群体(我们一会儿会看到它们是什么样子的)，我们需要选择两个父母。我们可以随机挑选:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="d664" class="lb lc iq ma b gy me mf l mg mh">function pickParent(population) {<br/>  let populationSize = population.length();<br/>  let index = Math.random() * populationSize;</span><span id="d24b" class="lb lc iq ma b gy mi mf l mg mh">  return population[index];<br/>}</span></pre><p id="0729" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面将简单地从群体中选择一个随机的解决方案，通过使用<code class="fe mj mk ml ma b">Math.random()</code>，它给我们一个在 0 和 1 之间的随机数，并设置结果扩展到我们的群体大小。但这并不是对最好的父母的迫切要求，也没有增加任何生物智能。这只是一个随机选择器。要做到这一点，我们必须检查我们想要返回的解决方案，只有当它是更好的解决方案之一时才将其返回:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="70eb" class="lb lc iq ma b gy me mf l mg mh">function pickParent(population) {<br/>  let populationSize = population.length();<br/>  let index = Math.random() * populationSize;</span><span id="ede2" class="lb lc iq ma b gy mi mf l mg mh">  if (fitness(population[index]) &lt; 0.3) {<br/>    return population[index];<br/>  else {<br/>    return pickParent(population);<br/>  }<br/>}</span></pre><p id="ca84" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面我们正在使用一个我们马上会谈到的秘密函数，叫做<code class="fe mj mk ml ma b">fitness</code>。该函数将返回一个介于 0 和 1 之间的数字，表示我们的解决方案有多接近完美。零表示解决方案是完美的，一表示是最差的。上面的<code class="fe mj mk ml ma b">pickParent</code>函数将只返回接近完美的解(<code class="fe mj mk ml ma b">fitness &lt; 0.3</code>)。但这公平吗？一点也不，它没有实现爱情的随机侥幸。任何两个个体都应该至少有一次“谈恋爱”的机会。所以让我们稍微改变一下:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="b09a" class="lb lc iq ma b gy me mf l mg mh">function pickParent(population) {<br/>  let populationSize = population.length();<br/>  let index = Math.random() * populationSize;</span><span id="bfc6" class="lb lc iq ma b gy mi mf l mg mh">  if (fitness(population[index]) &lt; 0.3 || Math.random() &lt; 0.5) {<br/>    return population[index];<br/>  else {<br/>    return pickParent(population);<br/>  }<br/>}</span></pre><p id="dc7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那里。如果健身效果不好，我们将进行一次额外的掷硬币，几率为 50%。这样，即使适应度不会很好，被选中的个体仍然有随机的机会。当然，我们可以根据自己的意愿设定几率:<code class="fe mj mk ml ma b">Math.random() &lt; 0.3</code>将提供 30%的几率，这意味着更倾向于更好的解决方案。</p><h2 id="0a90" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">第二步:混合父母来生产孩子</h2><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mm"><img src="../Images/a535e41bd570d546bb8a93c6f08154af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TaBBK9wn9a2WxHvj"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@lightcircle?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Bilal O. </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="ead2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的两个父母是通过更好的适应性或机会选择的，这并不意味着最终会有太大的影响。我们仍然在谈论一个跨越几十万代人的过程。但是我们如何把生殖变成一个算法呢？再说一次，科学家们喜欢把一切简化到最核心的地方，所以这里出现了一个明显令人恼火的算法:取父母一方的一部分，取另一方的另一部分。</p><p id="bb0b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，在这一点上，我们并不关心父母在我们程序中的样子。我们只有这个指令:从<code class="fe mj mk ml ma b">parent1</code>拿一部分，从<code class="fe mj mk ml ma b">parent2</code>拿一部分组成<code class="fe mj mk ml ma b">child</code>。这是它在近似 javascript 中的样子:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="3d3f" class="lb lc iq ma b gy me mf l mg mh">let population = [a, b, c, d, e];<br/>let parent1 = pickParent(population);<br/>let parent2 = pickParent(population);<br/>let child = mix(parent1, parent2); </span></pre><p id="07b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以考虑想要多少个父母，但在我们的情况下，我们将坚持两个。那么让我们定义一下<code class="fe mj mk ml ma b">mix</code>函数:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="9162" class="lb lc iq ma b gy me mf l mg mh">function mix(parent1, parent2) {<br/>  let part1 = selectRandomPart(parent1);<br/>  let part2 = selectRandomPart(parent2);<br/>  <br/>  return combine(part1, part2);<br/>}</span></pre><p id="50a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如你所看到的，我们完全按照食谱所说的去做:从一个双亲中挑选一部分，从另一个中挑选一部分，然后将这些部分组合起来创造出孩子。我们将在下一篇文章中看到这在实际问题中的表现。作为一个偷窥，它可以意味着任何事情，但有一些形式和表现，使它更容易工作。现在我们坚持这个理论。</p><h2 id="456b" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">第三步:安排随机突变</h2><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mn"><img src="../Images/851f2bfa922baecbac51553c98e6fc7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sfaHTf2dCiVVER_5"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@sangharsh_l?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">桑哈什·洛哈卡</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="75e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">继续进化过程，不时会发生突变，所以我们需要适应我们的算法。突变可能发生在一个人生活的许多地方。例如，你在有生之年受到辐射，或者在出生前，在父母基因结合的过程中发生了一些事情。但结果总是一样的:有些事情发生了变化，而且与任何事情都无关，只是随机的。如果双亲的结合需要我们已知有效的已知和已证实的部分，那么突变就更加模糊了。它可能会更好地发挥作用，也可能会完全破坏基因的完美组合。所以让我们把它加入我们的算法:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="c592" class="lb lc iq ma b gy me mf l mg mh">let population = [a, b, c, d, e];<br/>let parent1 = pickParent(population);<br/>let parent2 = pickParent(population);<br/>let child = mix(parent1, parent2);<br/>let mutant = mutate(child);</span></pre><p id="7cbd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么 mutate 看起来如何呢:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="5fb4" class="lb lc iq ma b gy me mf l mg mh">function mutate(child) {<br/>  let doesMutationOccur = Math.random();<br/>  if (doesMutationOccur &lt; 0.5) return child;</span><span id="1c57" class="lb lc iq ma b gy mi mf l mg mh">  let childProperties = Object.keys(child);<br/>  let randomIndex = Math.random() * childProperties.length();<br/>  let randomProperty = childProperties[randomIndex];</span><span id="e8ad" class="lb lc iq ma b gy mi mf l mg mh">  child[randomValue] = getRandomValue(randomProperty);<br/>  return child;<br/>}</span></pre><p id="88c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，上述算法并不力求正确，它只是一个原型，所以我们明白什么是突变的意思。基本上，如果孩子是一个类似于<code class="fe mj mk ml ma b">dog</code>的对象，具有类似于<code class="fe mj mk ml ma b">dog.breed</code>和<code class="fe mj mk ml ma b">dog.age</code>的一些属性，那么突变意味着我们随机选择一个属性，例如<code class="fe mj mk ml ma b">age</code>，然后给它一个新的随机值。注意，随机值必须对给定的属性有意义，这就是为什么我们求助于一个接受属性作为参数的<code class="fe mj mk ml ma b">getRandomValue</code>函数。</p><p id="16d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基本上，如果随机属性是<code class="fe mj mk ml ma b">age</code>，那么<code class="fe mj mk ml ma b">getRandomValue(age)</code>的结果将类似于<code class="fe mj mk ml ma b">3</code>。如果属性是<code class="fe mj mk ml ma b">breed</code>，那么结果将是<code class="fe mj mk ml ma b">husky</code>。当然，在现实生活中，变异不会随机改变狗的品种，但这只是一个原型算法，所以我们知道变异是如何工作的。下次当我们谈到遗传算法时，我们会看到，培育一个新的孩子，并使其突变，会更好地与生物有机体相匹配。</p><h2 id="03d8" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">第四步:健身功能</h2><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/ec95c79a15c20fc90f3f80de88795e9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_BXt9j4X0y77N0Hx"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@victorfreitas?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">维克多·弗雷塔斯</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="b9ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在这里创建了一些函数，帮助我们以一种对计算机程序有意义的方式解释进化，但我们方便地忽略了最重要的部分，即每个解决方案的适应性。在这种情况下，适应性意味着它有多好，它有多好地匹配和解决了我们的问题。你看，我们的算法是基于适应度函数的。没有它，它就无法工作，它将永远创造孩子并使他们变异，但不会有任何力量推动更好的结果。让我们完成我们的算法:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="e412" class="lb lc iq ma b gy me mf l mg mh">let population = [a, b, c, d, e];<br/>let parent1 = pickParent(population);<br/>let parent2 = pickParent(population);<br/>let child = mix(parent1, parent2);<br/>let mutant = mutate(child);</span><span id="fa81" class="lb lc iq ma b gy mi mf l mg mh">if (fitness(mutant) &lt; fitness(child)) {<br/>  nextGeneration.push(mutant);<br/>} else {<br/>  nextGeneration.push(child);<br/>}</span></pre><p id="d427" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该算法应该接收一个群体，对其应用一些进化函数，并产生下一代。下一代会包含什么？父母肯定会死，尽管我们可以在一段时间内包括他们(同样，这是我们的<em class="mp">算法，我们做我们认为合适的事情)。但是在上面的例子中，我们只做一件事:在孩子和突变体之间选择。我们检查他们的健康状况，挑选最好的。那是下一代。我们可以对群体中的每一个个体都这样做，这样我们就有了新一代相同大小的个体:</em></p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="e2e8" class="lb lc iq ma b gy me mf l mg mh">function createNextGeneration(population) {<br/>  let result = [];</span><span id="6c78" class="lb lc iq ma b gy mi mf l mg mh">  for (let i = 0; i &lt; population.length(); i++) {<br/>    let parent1 = pickParent(population);<br/>    let parent2 = pickParent(population);<br/>    let child = mix(parent1, parent2);<br/>    let mutant = mutate(child);</span><span id="5695" class="lb lc iq ma b gy mi mf l mg mh">    if (fitness(mutant) &lt; fitness(child)) {<br/>      result.push(mutant);<br/>    } else {<br/>      result.push(child);<br/>    }  <br/>  }</span><span id="429e" class="lb lc iq ma b gy mi mf l mg mh">  return result;<br/>}</span></pre><p id="121c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的函数将随机抽取一个人口，并给我们相同大小的下一代。十个人进去，十个人出来。这使得我们可以永远重复这个过程。但是，健身功能是什么？</p><p id="268a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是诀窍:这取决于我们想要解决的问题。没有通用的健身功能。我们正在努力取得越来越好的结果，但不可能有一种通用的方法来解决所有问题。如果我们的计划是繁殖更好的狗，那么适应度函数可能是这样的:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="9439" class="lb lc iq ma b gy me mf l mg mh">function fitness(dog) {<br/>  let result = dog.age + dog.pastIllnesses.length() + dog.temper + dog.visionMeasurement + dog.speed;</span><span id="c964" class="lb lc iq ma b gy mi mf l mg mh">  return sigma(result);<br/>}</span></pre><p id="5a38" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上述函数将把一个<code class="fe mj mk ml ma b">dog</code>的所有特征加起来，并作为一个适应度值返回。请记住，适合度应该是一个介于 0 和 1 之间的数字，越低越好，因此我将结果传递给一个<code class="fe mj mk ml ma b">sigma</code>转换函数，该函数接受接收到的任何整数，并返回一个介于 0 和 1 之间的加权值。javascript 中没有这样的函数，所以我们需要自己编写。但是同样，这与<code class="fe mj mk ml ma b">dog</code>对象中的属性值密切相关，所以它不能是泛型的。这里有一个例子:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="8a87" class="lb lc iq ma b gy me mf l mg mh">function sigma(raw) {<br/>  return 1 / (1 + Math.exp(-1 * raw));<br/>}</span></pre><p id="9716" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的函数将任何整数映射到 0 到 1 之间的一个数。这取决于我们，以确保我们添加的数字是正确的，所以较低的适应度更好。</p><h2 id="fbad" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">把所有东西加起来</h2><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/574c3b4b94eee375872ca956b2f3bb73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ni55Mw6qYijLipbq"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@wyron?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">威龙 A </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="af0c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的节目准备好了。我们已经拥有了创建一个进化算法所需的所有构件，该算法每一代都会增加压力，以找到更好的结果。什么是更好的结果？正如我们所见，这完全取决于适应度函数:这是决定个体之间的函数。寻找完美的狗是一回事，但我们可能在寻找实际解决商业问题的东西，比如送货卡车的最佳路线。我们将在下一篇文章中看到进化算法的实际应用，但现在让我们结束我们的程序:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="f87a" class="lb lc iq ma b gy me mf l mg mh">var population = getRandomPopulation();</span><span id="cc29" class="lb lc iq ma b gy mi mf l mg mh">for (let i = 0; i &lt; 100; i++) {<br/>  population = createNextGeneration(population);<br/>}</span><span id="a9fc" class="lb lc iq ma b gy mi mf l mg mh">population = sortByFitness(population)<br/>console.log(population[0]);</span></pre><p id="e54f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们又错过了一些函数，但我不会在这里花时间写它们。下一篇文章将更加实用，因为我们将尝试创建一个有用的应用程序来解决实际问题。对于理论来说，以上就足够了。我们创建了一个随机群体:我们从什么开始并不重要，因为我们会对系统施加压力以改善它。然后 100 次，我们在上一代的基础上创造下一代。在 100 代之后，我们停下来，按照适应度对最终群体进行排序，并显示第一个群体，即适应度最接近于零的个体:最佳群体。</p><p id="dea2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不难看出，这个算法基本上可以永远运行下去。如果我们对结果不满意，我们可以再运行 100 代算法，以此类推。我们还可以注意到，该算法是<em class="mp">启发式</em>，这意味着对于给定的输入，我们不会得到相同的输出。基于我们为每个函数应用的许多随机方面，输出总是不同的。但有一点是不变的:每一代都会比上一代更好，我们有某些触发因素来控制一切收敛到最佳解决方案的速度，比如突变概率和从父母中选择的随机部分来组成孩子。</p><p id="1fe2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你认为以上所有的可能永远不会工作，进化算法背后有一个完整的统计理论，它深入到使其工作的所有方面。如果你仔细想想，这基本上是在一个巨大的解决方案空间中进行搜索。但是，即使它每次都从随机的点开始，它推动自己寻找更好的解决方案的方式也不是随机的。是的，要找到完美的答案需要很多代人，但这就是生物智能的工作方式。有什么问题吗？进化几百万年做的事，计算机几秒钟就能运行模拟。</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><p id="16da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">进化算法的理论部分到此结束。下一次我们将讨论一种叫做遗传算法的应用变体，它的解决方案是一组我们称之为基因的数字。遗传算法在工业水平上是有效的，并且用于解决极其困难的问题，这些问题要么没有直接的数学解决方案，要么现有的数学解决方案将需要不合理的时间量。</p><p id="eb7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，遗传算法解决了另一类问题:如果尝试直接的数学解决方案，这些问题通常会使任何计算机崩溃。我希望我引起了你的注意！下次见！</p></div></div>    
</body>
</html>