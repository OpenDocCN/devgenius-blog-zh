<html>
<head>
<title>Java 12 to 17 — All You Need To Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 12 到 17 —您需要知道的一切</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/java-12-to-17-all-you-need-to-know-7e1152f86829?source=collection_archive---------8-----------------------#2022-02-13">https://blog.devgenius.io/java-12-to-17-all-you-need-to-know-7e1152f86829?source=collection_archive---------8-----------------------#2022-02-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d09de2cff01c55e8df8dd9b908938037.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6BquGLuZuwViJdRLRWWPkg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">从博客<a class="ae jz" href="https://www.geeksforgeeks.org/jdk-17-new-features-in-java-17/" rel="noopener ugc nofollow" target="_blank"> GeeksForGeeks </a>下载的 Java 插图</figcaption></figure><p id="e5cb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你一直推迟使用 Java 17，我有一些好消息要告诉你。您将能够在一个地方了解从  <strong class="kc io"> <em class="ky"> Java 12 到 Java 17 </em> </strong>的最时尚的顶级特性<strong class="kc io"> <em class="ky">，并与我一起尝试编码。</em></strong></p><p id="b22d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，Java 17 将是一个<strong class="kc io"> <em class="ky">长期支持</em> </strong> (LTS)的版本，类似于 Java 11 和 Java 8。它于 2021 年 9 月引入 Java 社区，包括几个新特性和升级。你可以在这里  看到所有特性的列表<a class="ae jz" href="https://openjdk.java.net/projects/jdk/17/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="ky">，但是在本教程中，我将重点介绍几个我特别感兴趣的特性。</em></strong></a></p><p id="b52d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果有兴趣，可以访问我的<a class="ae jz" href="https://github.com/anitalakhadze/java17features" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="ky">GitHub repo</em></strong></a>查看这里给出的所有例子的源代码。</p><h2 id="c83b" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">密封类[Java 17]</h2><p id="2819" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated"><strong class="kc io"><em class="ky"/></strong>密封类是一种执行继承规则的新方法。它们允许开发人员<em class="ky">显式声明类型</em>允许的子类型，从而防止其他人无意中扩展或实现它。</p><p id="f1d7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当您将<code class="fe lx ly lz ma b"><strong class="kc io">sealed</strong></code> <strong class="kc io"> </strong>关键字添加到类或接口的声明中时，您也添加了一个可以<code class="fe lx ly lz ma b"><strong class="kc io">extend</strong></code> <strong class="kc io"> </strong>或<code class="fe lx ly lz ma b"><strong class="kc io">implement</strong></code> <strong class="kc io"> </strong>它的类列表。预定义批处理之外的任何内容都将无法编译。</p><p id="81b8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，假设您创建了一个类<code class="fe lx ly lz ma b"><strong class="kc io">Animal</strong></code> <strong class="kc io"> </strong>，并且您只想要类<code class="fe lx ly lz ma b"><strong class="kc io">Cat</strong></code> <strong class="kc io"> </strong>和<code class="fe lx ly lz ma b"><strong class="kc io">Dog</strong></code> <strong class="kc io"> </strong>来扩展它:</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="604b" class="kz la in ma b gy mj mk l ml mm">public abstract sealed class Animal permits <em class="ky">Cat</em>, <em class="ky">Dog </em>{<br/>}</span></pre><p id="f685" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">子类必须是<code class="fe lx ly lz ma b"><strong class="kc io">final</strong></code>、<code class="fe lx ly lz ma b"><strong class="kc io">sealed</strong></code>、<strong class="kc io">或<code class="fe lx ly lz ma b"><strong class="kc io">non-sealed</strong></code>:</strong></p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="d828" class="kz la in ma b gy mj mk l ml mm">public final class <em class="ky">Cat </em>extends Animal{<br/>}</span></pre><p id="b8ed" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">密封的类不仅<strong class="kc io"> <em class="ky">保护你的代码安全</em> </strong>不让外人看到，而且它们还<strong class="kc io"> <em class="ky">向你永远不会遇到的人表达你的目的</em> </strong>。当你密封一个类时，你表明只有某些类被允许扩展它。</p><h2 id="1244" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">记录类[Java 16]</h2><p id="3cd1" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated"><strong class="kc io"> <em class="ky">记录</em> </strong>是纯数据类，<em class="ky">负责 POJO</em>的所有样板代码。自动实现<code class="fe lx ly lz ma b"><strong class="kc io">equals()</strong></code>和<code class="fe lx ly lz ma b"><strong class="kc io">hashcode()</strong></code>方法，以及<code class="fe lx ly lz ma b"><strong class="kc io">toString()</strong></code>和<code class="fe lx ly lz ma b"><strong class="kc io">getter</strong></code> <strong class="kc io"> </strong>方法。</p><p id="03f8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可以通过以下方式<strong class="kc io"> <em class="ky">申报一条记录</em> </strong>:</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="d77c" class="kz la in ma b gy mj mk l ml mm">public record <em class="ky">PersonRecord</em>(<em class="ky">String </em>name, <em class="ky">Integer </em>age) {<br/>}</span></pre><p id="0d9b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">记录有<strong class="kc io"> <em class="ky">期末</em> </strong>和<strong class="kc io"> <em class="ky">不可变。</em> </strong>在一条记录中，你可以同时指定<strong class="kc io"><em class="ky"/></strong>和<strong class="kc io"><em class="ky"/></strong>两种静态方法:</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="0a1d" class="kz la in ma b gy mj mk l ml mm">public record <em class="ky">PersonRecord</em>(<em class="ky">String </em>name, <em class="ky">Integer </em>age) {<br/>    public boolean isOver18() {<br/>        return age() &gt; 18;<br/>    }</span><span id="2fe4" class="kz la in ma b gy mn mk l ml mm">    public static boolean isOver18(<em class="ky">PersonRecord personRecord</em>) {<br/>        return <em class="ky">personRecord</em>.age() &gt; 18;<br/>    }<br/>}</span></pre><p id="a0b3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">记录可以有<strong class="kc io"> <em class="ky">多个构造函数。</em> </strong>另外值得注意的是，如果你在记录内指定一个<strong class="kc io"> <em class="ky">自定义构造函数</em> </strong>，它必须调用默认构造函数。否则，记录将无法确定如何处理其值:</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="a55b" class="kz la in ma b gy mj mk l ml mm">public record <em class="ky">PersonRecord</em>(<em class="ky">String </em>name, <em class="ky">Integer </em>age) {    <br/>    public PersonRecord() {<br/>        this("Name", 18);<br/>    }<br/>}</span></pre><p id="c854" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您的构造函数与默认的相同，这是可以接受的，只要您还<em class="ky">初始化记录的所有字段</em>:</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="aeb4" class="kz la in ma b gy mj mk l ml mm">public record <em class="ky">PersonRecord</em>(<em class="ky">String </em>name, <em class="ky">Integer </em>age) {<br/>    <!-- -->// Will replace the default constructor<br/>    public PersonRecord(<em class="ky">String name</em>, <em class="ky">Integer age</em>) {<br/>        this.name = <em class="ky">name</em>;<br/>        this.age = <em class="ky">age</em>; <br/>    }<br/>}</span></pre><p id="d36f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">记录是一个巨大的变化，但在适当的情况下，它们可能非常有益。我没有涵盖所有内容，但是这应该会让您对它们的能力有一个很好的了解。</p><h2 id="f52e" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">模式匹配[Java 16]</h2><p id="830b" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated"><strong class="kc io"><em class="ky"/></strong>是一种手段，在一个<code class="fe lx ly lz ma b"><strong class="kc io">instanceof</strong></code> <strong class="kc io"> </strong>条件满足后<strong class="kc io"> <em class="ky">消除不必要的铸造</em> </strong>。</p><p id="e5fb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们都很熟悉这种情况:</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="7f55" class="kz la in ma b gy mj mk l ml mm">public class <em class="ky">PatternMatching </em>{<br/>    public static void main(<em class="ky">String</em>[] <em class="ky">args</em>) {<br/>        <em class="ky">Animal </em>animal = new Cat();<br/>        if (animal instanceof <em class="ky">Cat</em>) {<br/>            <em class="ky">System</em>.out.println(((<em class="ky">Cat) animal)</em>.meow());<br/>        }<br/>    }<br/>}</span></pre><p id="40a6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">话虽如此，毫无疑问，第二行的动物是一个<code class="fe lx ly lz ma b"><strong class="kc io">Cat</strong></code><strong class="kc io"/>—<strong class="kc io"/>已经证实了这一点。与<strong class="kc io"> <em class="ky">图案匹配</em> </strong>，稍加调整即可:</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="0905" class="kz la in ma b gy mj mk l ml mm">if (animal instanceof <em class="ky">Cat cat</em>) {<br/>    <em class="ky">System</em>.out.println(<em class="ky">cat</em>.meow());<br/>}</span></pre><p id="014d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">编译器现在<strong class="kc io">处理对象</strong>造型的所有细节。它可能看起来很少，但是它减少了许多样板代码。</p><p id="248b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当你输入一个<strong class="kc io"> <em class="ky">条件分支</em> </strong>时，对象的类型是显而易见的:</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="fa46" class="kz la in ma b gy mj mk l ml mm">if (!(animal instanceof <em class="ky">Cat cat</em>)) {<br/>    <em class="ky">System</em>.out.println("This isn't a cat!");<br/>} else {<br/>    <em class="ky">System</em>.out.println(<em class="ky">cat</em>.meow());<br/>}</span></pre><p id="7ca4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">模式匹配甚至可以在<code class="fe lx ly lz ma b"><strong class="kc io">instanceof</strong></code> <strong class="kc io"> </strong>本身所在的同一行上使用<em class="ky">:</em></p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="28a4" class="kz la in ma b gy mj mk l ml mm">public static boolean isCat(<em class="ky">Object animal</em>) {<br/>    return <em class="ky">animal </em>instanceof <em class="ky">Cat cat </em>&amp;&amp; <em class="ky">cat</em>.meow().equals("meow");<br/>}</span></pre><p id="76ad" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，模式匹配为常见的代码噪声问题提供了有效的解决方案。</p><h2 id="2ae1" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">切换表达式[Java 14]</h2><p id="417a" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">该语言特性增加了根据类型 切换<strong class="kc io"> <em class="ky">的能力，类似于<code class="fe lx ly lz ma b"><strong class="kc io">instanceof</strong></code>的模式匹配给出的语法。</em></strong></p><p id="a8a7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以前，如果您想根据对象的<em class="ky">动态类型</em>执行各种操作，您必须使用<code class="fe lx ly lz ma b"><strong class="kc io">instanceof</strong></code> <strong class="kc io"> </strong>检查创建一个<code class="fe lx ly lz ma b"><strong class="kc io">if — else if</strong></code>链，例如:</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="72a6" class="kz la in ma b gy mj mk l ml mm">public class <em class="ky">SwitchExpression </em>{<br/>    private static <em class="ky">String </em>ifElseIfSwitch(<em class="ky">Object o</em>) {<br/>        if (<em class="ky">o </em>instanceof <em class="ky">Cat</em>) {<br/>            return "This is a cat";<br/>        } else if (<em class="ky">o </em>instanceof <em class="ky">Dog</em>) {<br/>            return "This is a dog";<br/>        } else {<br/>            return "This is some other animal";<br/>        }<br/>    }<br/>}</span></pre><p id="f45c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">或者<code class="fe lx ly lz ma b"><strong class="kc io">switch</strong></code> <strong class="kc io"> </strong>例:</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="a4da" class="kz la in ma b gy mj mk l ml mm">private static <em class="ky">String </em>legacySwitch(<em class="ky">Object </em>o) {<br/>    switch (<em class="ky">o</em>) {<br/>        case <em class="ky">Cat</em>:<br/>            return "This is a cat";<br/>            break;<br/>        case <em class="ky">Dog</em>:<br/>            return "This is a dog";<br/>            break;<br/>        default:<br/>            return "This is some other animal";<br/>            break;<br/>    }<br/>}</span></pre><p id="7279" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">他们非常容易出现人为错误。Switch 表达式很好地解决了这个问题，它允许你用逗号分隔同一个块 中的所有值。</p><p id="1ea4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的例子可以将<em class="ky">简化为</em>如下:</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="e40f" class="kz la in ma b gy mj mk l ml mm">private static <em class="ky">String </em>modernSwitch(<em class="ky">Object </em>o) {<br/>    return switch (<em class="ky">o</em>) {<br/>        case <em class="ky">Cat cat </em>-&gt; "This is a cat";<br/>        case <em class="ky">Dog dog </em>-&gt; "This is a dog";<br/>        default -&gt; "This is some other animal";<br/>    };<br/>}</span></pre><p id="138b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如您可能已经观察到的，检查<strong class="kc io"> <em class="ky">还包括一个变量声明</em> </strong>，它与<code class="fe lx ly lz ma b"><strong class="kc io">instanceof</strong></code>的模式匹配一样，表明对象已经过<em class="ky">类型检查、</em>和<em class="ky">类型转换，现在可以从其作用域</em>内的变量<em class="ky">获得</em>。</p><p id="e7fd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">他们还增加了一个<strong class="kc io"><em class="ky">null</em></strong>的特例，这样你就不用再检查 null 了。</p><p id="41f6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">新增的<code class="fe lx ly lz ma b"><strong class="kc io">yield</strong></code> <strong class="kc io"> </strong>关键字也是一大特色。如果您的一个案例进入代码块，yield 将用作 switch 表达式的返回语句。例如，考虑上面的代码块，它已经被稍微修改了:</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="c31a" class="kz la in ma b gy mj mk l ml mm"><em class="ky">String </em>whichAnimal = switch (<em class="ky">o</em>) {<br/>    case <em class="ky">Cat cat </em>-&gt; "This is a cat";<br/>    case <em class="ky">Dog dog </em>-&gt; "This is a dog";<br/>    default -&gt; {<br/>        <em class="ky">System</em>.out.println("This is some other animal");<br/>        yield "Unknown animal";<br/>    }<br/>};</span></pre><p id="0196" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在默认情况下，将执行<code class="fe lx ly lz ma b"><strong class="kc io">System.out.println()</strong></code>方法，而<code class="fe lx ly lz ma b"><strong class="kc io">whichAnimal</strong></code>变量最终仍然是“<em class="ky">未知动物</em>”，因为 yield 表达式返回的就是这个。</p><p id="c7c1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一般来说，<strong class="kc io"> <em class="ky">的 Switch 语句更简洁，</em> </strong>的 switch 语句更简洁。但是，它们不能代替 switch 语句，两者仍然可以访问。</p><h2 id="4f8a" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">有用的空指针[Java 14]</h2><p id="3b0a" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated"><strong class="kc io"> <em class="ky">有用的空指针</em> </strong>当然是对语言的一个很好的补充。他们通过<em class="ky">发布抛出异常的调用</em>的名字，以及<em class="ky">空变量</em>的名字，使得空指针异常(<strong class="kc io"> <em class="ky"> NPEs </em> </strong>)更容易理解。</p><p id="4f3e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，如果您调用了<code class="fe lx ly lz ma b"><strong class="kc io">person.getAge()</strong></code>并且未定义<code class="fe lx ly lz ma b"><strong class="kc io">age</strong></code> <strong class="kc io"> </strong>参数:</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="2555" class="kz la in ma b gy mj mk l ml mm">public class <em class="ky">NullPointer </em>{<br/>    public static void main(<em class="ky">String</em>[] <em class="ky">args</em>) {<br/>        <em class="ky">Person </em>ani = new Person("Ani", "Talakhadze", null);<br/>        int i = ani.getAge().compareTo(23);<br/>        <em class="ky">System</em>.out.println(i);<br/>    }<br/>}</span></pre><p id="0f5c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">错误的堆栈跟踪将声明<code class="fe lx ly lz ma b"><strong class="kc io">getAge()</strong></code>失败，因为<code class="fe lx ly lz ma b"><strong class="kc io">age</strong></code> <strong class="kc io"> </strong>参数为空:</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="ba8f" class="kz la in ma b gy mj mk l ml mm">Exception in thread "main" java.lang.NullPointerException: Cannot invoke "java.lang.Integer.compareTo(java.lang.Integer)" because the return value of "nullPointers.Person.getAge()" is null<br/> at nullPointers.NullPointer.main(NullPointer.java:6)</span><span id="87a3" class="kz la in ma b gy mn mk l ml mm">Process finished with exit code 1</span></pre><p id="eb43" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">npe 非常常见，虽然大多数时候很容易找出问题所在，但偶尔也会遇到两三个变量起作用的情况。现在，一旦出现错误，您就拥有了解决问题所需的一切。</p><h2 id="be15" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">增强型伪随机数生成器[Java 17]</h2><p id="143c" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">为了使未来的<em class="ky">伪随机数发生器(PRNG) </em>技术更容易开发或使用，引入了一个名为<code class="fe lx ly lz ma b"><strong class="kc io">RandomGenerator</strong></code>的新接口。以下代码生成所有 Java 17 PRNG 算法:</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="1c12" class="kz la in ma b gy mj mk l ml mm">RandomGeneratorFactory.all()<br/>        .map(fac -&gt; fac.group()+ " : " + fac.name())<br/>        .sorted()<br/>        .forEach(<em class="ky">System</em>.out::println);</span></pre><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mo"><img src="../Images/ff54e8ba7423c147e871d8c2fb8ad4b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VG_pQAB5EtcgYsHATZ3M_Q.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><em class="mp">运行伪随机数生成器</em>后的输出</figcaption></figure><p id="4dfd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以下示例利用新的 Java 17 <code class="fe lx ly lz ma b"><strong class="kc io">RandomGeneratorFactory</strong></code>使用<code class="fe lx ly lz ma b"><strong class="kc io">Xoshiro256PlusPlus</strong></code> <strong class="kc io"> <em class="ky"> </em> </strong> PRNG 算法创建 0 到 10 之间的随机数。将相同的种子传递给 random，然后调用它，将得到相同的一组数字:</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="4f35" class="kz la in ma b gy mj mk l ml mm">public class <em class="ky">PseudoRandomNumberGenerator </em>{<br/>    public static void main(<em class="ky">String</em>[] <em class="ky">args</em>) {</span><span id="5aee" class="kz la in ma b gy mn mk l ml mm">        <em class="ky">RandomGenerator </em>randomGenerator1 = <em class="ky">RandomGeneratorFactory</em>.<em class="ky">of</em>("Xoshiro256PlusPlus").create(999);</span><span id="daa7" class="kz la in ma b gy mn mk l ml mm"><em class="ky">System</em>.out.println(randomGenerator1.getClass());</span><span id="b706" class="kz la in ma b gy mn mk l ml mm">for (int i = 0; i &lt; 10; i++) {<br/>            <em class="ky">System</em>.out.println(randomGenerator1.nextInt(11));<br/>        }<br/>    }<br/>}</span></pre><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mq"><img src="../Images/a0fd24d8265fa4cb83bf56c63b4094d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qcK0tghQ-nE0AvY71y3jSQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><em class="mp">运行伪随机数生成器</em>后的输出</figcaption></figure><p id="4440" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">像<code class="fe lx ly lz ma b"><strong class="kc io">java.util.Random</strong></code>、<code class="fe lx ly lz ma b"><strong class="kc io">SplittableRandom</strong></code>和<code class="fe lx ly lz ma b"><strong class="kc io">SecureRandom</strong></code> <strong class="kc io"> </strong>这样的遗留随机类也被重构以扩展新的<code class="fe lx ly lz ma b"><strong class="kc io">RandomGenerator</strong></code> <strong class="kc io"> </strong>接口。</p><h2 id="b996" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">文本块[Java 15]</h2><p id="3c27" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">文本块是一种使<strong class="kc io"> <em class="ky">编写多行字符串</em> </strong>更容易的方法，它允许<em class="ky">新行被解释</em>和<strong class="kc io"> <em class="ky">缩进被保持</em> </strong>而不需要转义字符。这个值仍然是一个字符串，但是它包含了新的行和制表符。</p><p id="c0b4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要创建文本块，只需使用以下语法:</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="2336" class="kz la in ma b gy mj mk l ml mm">package <em class="ky">textBlocks</em>;</span><span id="f42f" class="kz la in ma b gy mn mk l ml mm">public class <em class="ky">TextBlock </em>{<br/>    public static void main(<em class="ky">String</em>[] <em class="ky">args</em>) {<br/>        <em class="ky">String </em>text = """<br/>                Hello<br/>                World!<br/>                -----<br/>                Hello<br/>                World!<br/>                """;<br/>        <em class="ky">System</em>.out.println(text);<br/>    }<br/>}</span></pre><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mr"><img src="../Images/0aa0cec8d39ccd7da8d9c9e6f10d23e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SbfQU5lkPeyHXFwzLzP6JA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">运行 TextBlock 后的输出</figcaption></figure><p id="4e45" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">同样，如果您希望使用引号，也不需要任何转义字符。该程序将无任何抱怨地运行:</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="9e18" class="kz la in ma b gy mj mk l ml mm"><em class="ky">String </em>text = """<br/>        Hello<br/>        World!<br/>        -----<br/>        "Hello"<br/>        "World!"<br/>        """;</span></pre><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ms"><img src="../Images/a48b752d403865bed8ca848691202c9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xQpQoakr9vnjUWmWxSQVzw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">运行 TextBlock 后的输出</figcaption></figure><p id="b9f6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">除此之外，您可以使用字符串的<code class="fe lx ly lz ma b"><strong class="kc io">format()</strong></code>函数来格式化您键入的内容，允许您使用动态值快速更改文本块中的数据:</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="f792" class="kz la in ma b gy mj mk l ml mm"><em class="ky">String </em>name = "Ani";<br/><em class="ky">String </em>text = <em class="ky">String</em>.<em class="ky">format</em>("""<br/>        Hello<br/>        World!<br/>        -----<br/>        My name is %s.<br/>        """, name);</span></pre><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mt"><img src="../Images/1a906359b8cfeea45ca962db0107e2f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iRLQbkbmgpOKZHdPWBUGEg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">运行 TextBlock 后的输出</figcaption></figure><p id="bdb2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">文本块使得<strong class="kc io"> <em class="ky">将代码粘贴到字符串</em> </strong>中变得非常容易，此外，它还能够<strong class="kc io"> <em class="ky">明显地在格式</em> </strong>中烘焙一大块单词。因为保留了缩进，所以你可以创建一个 HTML 或 Python 的块，或者任何其他语言的块，然后把它包装在" "。文本块也可以用来创建 JSON，而<code class="fe lx ly lz ma b"><strong class="kc io">format()</strong></code>函数可以用来简单地填充数据。</p><h2 id="d359" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">弃用、删除和限制[Java 17]</h2><p id="1d25" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">Java 的最新版本也带来了几个<em class="ky">弃用</em>、<em class="ky">移除</em>、<em class="ky">增加限制</em>。</p><p id="de8b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">JDK 内部 的<strong class="kc io"> <em class="ky">封装是一个已经被移除的东西。如果用户试图使用反射或类似方法来避免访问正常内部 API 的典型约束，这将在<em class="ky"> Java 9 </em>中发出<em class="ky">运行时警告</em>。Java 16 </em>中的默认行为从警告变为<em class="ky">通过引发异常</em>禁止访问，但是修改行为的命令行参数被保留。在<em class="ky"> Java 17 </em>中已经删除了<em class="ky">命令行参数</em>，并且这个限制不能再被取消，这意味着对那些内部 API 的任何非法访问现在都被强有力地封装了。</strong></p><p id="4b27" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Java 17 去掉了之前的默认语义，所有的<strong class="kc io"> <em class="ky">浮点运算</em> </strong>现在都做为严格。关键字<code class="fe lx ly lz ma b">strictfp</code>仍然存在，但没有任何效果，并产生一个编译时警告<em class="ky">。</em></p><p id="b8c6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> <em class="ky">【提前(AOT) </em> </strong> <strong class="kc io"> <em class="ky">编译</em> </strong>和<strong class="kc io"> <em class="ky"> RMI 激活</em> </strong>被删除。<strong class="kc io"> <em class="ky"> Applet API </em> </strong>已被标记为删除，当试图从命令行或在运行时动态设置<strong class="kc io"> <em class="ky">安全管理器</em> </strong>时，JVM 将生成运行时警告。</p></div><div class="ab cl mu mv hr mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ig ih ii ij ik"><p id="8129" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">迁移到 Java 17 <em class="ky">宜早不宜迟</em>通常是最好的选择，因为它未来的<strong class="kc io"> <em class="ky">减少了迁移费用</em> </strong>。您还将从近年来取得的所有进步 中获益<strong class="kc io">，包括<strong class="kc io"> <em class="ky">增加了对容器中操作的支持</em> </strong>和新的<strong class="kc io"> <em class="ky">低延迟垃圾收集器</em> </strong>实现。</strong></p><p id="3b8d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">即使你不打算从以前的版本迁移到这个版本，跟上语言中开发的新特性 也是一个好主意。</p><p id="08db" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当然，这些并不是从 Java 12 到 Java 17 的唯一变化，但是它们引起了我的注意。如果你的顶级功能列表与我的不同，请在下面的评论区 与我们分享。</p><p id="c1ad" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> <em class="ky">敬请关注，不要错过以下教程！</em>T29】</strong></p></div></div>    
</body>
</html>