# 设计模式—构建器

> 原文：<https://blog.devgenius.io/design-pattern-builder-1ad55ed26120?source=collection_archive---------1----------------------->

Builder 设计模式的详细讨论

![](img/68678400e642e623bd3219d9f586e92f.png)

由[马腾·戴克斯](https://unsplash.com/@maartendeckers?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

生成器设计模式是另一种非常常见的设计模式。它是四人帮(g Of)创造的设计模式之一。当您必须创建一个需要多个参数的复杂对象时，这是一个很好的模式。

# 什么是生成器设计模式？

这种设计模式在我们的代码中经常使用，但是我们很少看到人们创建他们的构建器模式。例如 StringBuilder。它非常适合创建有几个参数的对象，但是一旦所有的参数都设置好了，它应该是不可变的。

当我们有一个需要多个参数的复杂构造函数时，这种模式非常有用。生成器模式可以有效地处理大量的参数。通常，由构建器模式创建的对象是不可变的。

# 例子

您可能见过或使用过构建器设计模式的实例—

*   Java——Java 中的 StringBuilder API 是最常见的例子。另一个例子是 DocumentBuilder。

StringBuilder——构建器设计模式的范例

从上面可以看出，您正在尝试构建一个复杂的字符串。一旦字符串被构建，它是不可变的。或者，您可以使用字符串连接来实现这一点，但是想象一个包含不同类型数据的大字符串要连接。

# 生成器设计模式解决的问题

一个类可以有多个构造函数。在确定使用哪个构造函数以及在什么场景中使用时，有时会令人困惑。

*   **简化了复杂对象的创建** —在构建器类的帮助下，简化了复杂对象的创建过程。
*   **职责分离** —复杂类的对象创建职责被分离到不同的构建器类中，允许原始类专注于其状态和动作。
*   **暴露的设置器** —使用构建器模式，我们不必暴露设置器。所需的对象通常是不可变的。
*   **伸缩式构造器** —我们可以去掉构造器的网格。我们不需要在一个构造函数内部调用另一个构造函数。
*   **调用适当的构造函数**——使用构建器模式，我们不需要选择构造函数。构建器可以选择使用哪个构造函数。

我们将在下面详细讨论这些问题。

# 暴露的 setters

假设您必须创建一个 Person 类的对象。Person 类看起来像这样—

从上面的代码中，您可以看到它有一个默认的构造函数。它有四名成员。每个人至少应该有个名字。有大学学历，房子或者车子都是可选的。任何人都可以拥有这些数据的任意组合。只看类，不清楚什么是必须有，什么是可以有属性。所以合同没有明确的定义。

此外，这个类有每个成员变量的 setters，我们可以在类创建后更改属性。

因此，这里的问题是，它没有与外界签订任何合同。并且它公开了所有的 setters，这是不必要的。此外，对象一旦创建就是可变的。

“添加一个好的构造函数”，你可能会问。当然，让我们看看这种方法。

# 伸缩式建筑工人

现在，我们要给这个 person 类添加一些构造函数，去掉所有的 setter。

如果你仔细观察，你会发现一个参数数量较多的构造函数使用另一个参数数量较少的构造函数。例如有四个参数的构造函数——*姓名、学位、汽车&房屋*使用一个有三个参数——*姓名、学位&汽车*的构造函数。这种方法被称为伸缩构造器。

这太棒了。但是，这里有一些问题。如果这个人有名字，有房子呢？她没有大学文凭，也没有车。我们可以将 null 传递给带有四个参数的构造函数，但这并不优雅。对于这样的问题，前面的方法听起来稍微好一点。让我们将构建器模式应用于这个问题。

# 实践中的构建器设计模式

![](img/002dd753d5ae5da64f6133ca97104d62.png)

照片由[雅各布·欧文斯](https://unsplash.com/@jakobowens1?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

现在，我们尝试将构建器模式应用于创建 Person 类对象的问题。看看当我们将构建器设计模式应用于它时，解决方案变得多么优雅。

这是具有生成器设计模式的 Person 类。从上面可以看出，PersonBuilder 是一个内部类。下面重点介绍了一些要点—

*   **不变性**—Person 类的所有属性都是最终的。一旦创建了对象，就不能对其进行修改。唯一的构造函数是私有的，它将 builder 作为参数来初始化 Person 类的所有属性。
*   **内部类** —大多数构建器类都是内部静态类。然而，这并不是构建器设计模式的要求。
*   **重复属性** —内部构建器类与外部类具有相同的属性。这些重复的属性用于正确创建构建器对象。
*   **公共设置器** —内部类中的所有属性都有一个公共设置器。这些 setters 用于在 builder 对象中填充数据。参考下面的代码片段了解如何使用它。在创建最终可变对象之前，可以根据需要修改 builder 类的属性任意次。
*   **链接** —内部类中的所有 setters 都返回‘this’，即 builder 类的对象。这对于提供方法的链接很重要。再次参考我们如何用链条设定汽车&度。
*   **契约** —使用内部类，我们达成了一个契约，每个人至少应该有一个名字。你不能创造一个没有名字的人。同样，所有的 Person 对象都将使用一个 builder 对象来创建。
*   **灵活性** —在下面关于如何使用我们创建的 builder 类的示例代码中，注意我们没有填充 builder 的 house 属性。这是因为我们不需要。一个人可能有也可能没有房子，如果这个人没有，我们就不必调用带有 null 的 setHouse()方法。我们可以跳过一个电话，它会工作得很好。

下面是使用它的示例代码—

看看创建 person 对象变得多么优雅。

附注:汽车、大学学历或你拥有的房子类型，并不能定义一个人。这只是为了演示如何使用生成器设计模式。J

# 何时使用生成器设计模式？

*   创建一个对象并不简单，因为 *new Person()*
*   创建一个对象需要多个参数
*   一旦对象被创建，我们可能永远不会改变它的属性

# 限制

这种设计模式没有重大问题。然而，下面列出了一些问题—

*   **预见设计** —在实现你的类之前，你需要预见生成器设计模式的使用。如果我们在设计阶段就考虑到这一点，会比在重构中添加更容易。
*   **静态内部类** —构建器类通常使用静态内部类来实现。然而，这不是必需的，我们可以单独实现 builder 类。例如 StringBuilder。
*   **不可变对象** —用这种设计模式创建的对象是不可变的。如果我们的对象是可变的，构建器可能不是正确的模式。
*   **复杂**——我们用构建器类做的事情也可以只用构造器来完成，但是那个解决方案不如用构建器的解决方案优雅。生成器设计模式确实增加了一点复杂性。

# 摘要

*   几乎没有任何缺点或限制。
*   将对象的创建与代码的其余部分分离开来。
*   一种处理复杂性和复杂对象创建的好而优雅的方式
*   不可变对象。
*   不太复杂，但复杂性是可控的。
*   如果我们在设计阶段选择这个，会更容易。

*撰写&编辑——维韦克·米塔尔*

[](https://www.linkedin.com/in/vivekmittal06) [## Vivek Mittal -首席软件工程师- Nuance Communications | LinkedIn

### 我是一名经验丰富的软件工程师，在软件工程方面有超过 10 年的经验。我有广泛的…

www.linkedin.com](https://www.linkedin.com/in/vivekmittal06) 

# 附加阅读

[](https://stellarsoftwarecompany.medium.com/software-design-patterns-1b41de14ab8b) [## 软件设计模式

### 软件设计模式概述

stellarsoftwarecompany.medium.com](https://stellarsoftwarecompany.medium.com/software-design-patterns-1b41de14ab8b) [](https://stellarsoftwarecompany.medium.com/design-pattern-singleton-fa0f676a5d16) [## 设计模式—单例

### 最常见的设计模式——单一模式的详细讨论

stellarsoftwarecompany.medium.com](https://stellarsoftwarecompany.medium.com/design-pattern-singleton-fa0f676a5d16)