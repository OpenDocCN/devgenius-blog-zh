<html>
<head>
<title>Trees,Binary Search Trees and Traversal</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">树、二分搜索法树和遍历</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/trees-binary-search-trees-and-traversal-ab63e192f3a7?source=collection_archive---------8-----------------------#2020-08-06">https://blog.devgenius.io/trees-binary-search-trees-and-traversal-ab63e192f3a7?source=collection_archive---------8-----------------------#2020-08-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="3bf7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你将学到关于树木的深刻而清晰的知识😇</p><h1 id="1c0f" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated"><strong class="ak">什么是树？</strong>🤔</h1><p id="5e28" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">树是一种类似于链表的数据结构，但不是每个节点简单地以线性方式指向下一个节点，而是每个节点指向多个节点。树是非线性数据结构的一个例子。树形结构是一种以图形形式表示结构层次性质的方式。</p><p id="a39e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在树 ADT(抽象数据类型)中，元素的顺序并不重要。如果我们需要排序信息，像链表、栈、队列等线性数据结构。可以使用。</p><p id="ec2a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意:树中使用的术语请参考此<a class="ae ll" href="https://www.gatevidyalay.com/tree-data-structure-tree-terminology/" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi lm"><img src="../Images/b51da4477bbe0e3adfaa7c8fbaa5eebf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PdNpMNcWTUR9Aubbg0BhdQ.jpeg"/></div></div></figure><h1 id="607b" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">二叉树的类型</h1><p id="767f" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">通常有三种类型的二叉树:</p><p id="084e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">全二叉树</strong>:每个节点有 0 或 2 个子节点。</p><p id="db70" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">完全二叉树</strong>:除了最后一级树完全填充，最后一级从左到右填充。</p><p id="ebb5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">完美二叉树</strong>:所有内部节点都有两个子节点，所有叶子都应该在同一层。</p><h1 id="cb43" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">二叉树的性质</h1><p id="03ba" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">对于下面的属性，让我们假设树的高度是 h。同样，假设根节点的高度为零。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi ly"><img src="../Images/af08bfcc5a896c945ef54a69104fb74a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bmQF2uNqBh4m7QKtBRtTKA.png"/></div></div></figure><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/3c3d8d1acdcbd82fe7e8c7d77ec88783.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/1*oEblM2LpbAoexd1NhJf2Ag.png"/></div></figure><p id="c59c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从图中我们可以推断出以下性质:</p><ul class=""><li id="13f5" class="ma mb in jm b jn jo jr js jv mc jz md kd me kh mf mg mh mi bi translated">一棵完整的二叉树中的节点数 n 是 2h+1–1。因为有 h 个级别，所以我们需要在每个级别添加所有节点[2 0+2 1+2 2 ++ 2h = 2h+1–1]。</li><li id="e5b8" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">一棵完全二叉树中的节点数 n 介于 2 h(最小)和 2h+1–1(最大)之间。有关这方面的更多信息，请参阅优先级队列章节。</li><li id="cede" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">一棵完全二叉树的叶节点数是 2 h。</li><li id="a837" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">在 n 个节点的完整二叉树中，空链接(浪费的指针)的数量是 n + 1。</li></ul><h1 id="1ec6" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">二叉树的结构</h1><p id="1c1e" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">现在让我们定义二叉树的结构。为简单起见，假设节点的数据是整数。表示节点(包含数据)的一种方法是使用两个链接，这两个链接分别指向左侧和右侧的子节点以及数据字段，如下所示:</p><pre class="ln lo lp lq gt mo mp mq mr aw ms bi"><span id="f5d4" class="mt kj in mp b gy mu mv l mw mx">class Node:<br/>    def __init__(self,data):<br/>        self.data = data<br/>        self.left = None<br/>        self.right = None</span></pre><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div class="gh gi my"><img src="../Images/687eed962e2480a6946f9fc62aed4910.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/1*70QMLq5qPbRharwHxQpzmw.png"/></div></figure><h1 id="f77b" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">二叉树的运算</h1><h2 id="55ce" class="mt kj in bd kk mz na dn ko nb nc dp ks jv nd ne kw jz nf ng la kd nh ni le nj bi translated">基本操作</h2><ul class=""><li id="208c" class="ma mb in jm b jn lg jr lh jv nk jz nl kd nm kh mf mg mh mi bi translated">将元素插入树中</li><li id="4ec6" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">从树中删除元素</li><li id="b40b" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">搜索元素</li><li id="cdbb" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">遍历树</li></ul><h2 id="9377" class="mt kj in bd kk mz na dn ko nb nc dp ks jv nd ne kw jz nf ng la kd nh ni le nj bi translated">辅助操作</h2><ul class=""><li id="49bc" class="ma mb in jm b jn lg jr lh jv nk jz nl kd nm kh mf mg mh mi bi translated">寻找树的大小</li><li id="3e88" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">找到树的高度</li><li id="33e7" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">寻找具有最大和的级别</li><li id="d643" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">查找给定节点对的最小公共祖先(LCA ),等等。</li></ul><p id="fa7c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以下是二叉树发挥重要作用的一些应用:</p><ul class=""><li id="5616" class="ma mb in jm b jn jo jr js jv mc jz md kd me kh mf mg mh mi bi translated">表达式树用于编译器中。</li><li id="ca47" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">数据压缩算法中使用的霍夫曼编码树。</li><li id="7c05" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">二叉查找树(BST)，它支持在 O(logn) (average)中对一组项目进行搜索、插入和删除。</li><li id="ceb4" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">优先级队列(PQ)，它支持在对数时间内(在最坏的情况下)搜索和删除一组项目中的最小值(或最大值)。</li></ul><h1 id="5f75" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">通用树(N 元树)</h1><p id="bc74" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">在上一节中，我们讨论了二叉树，其中每个节点最多可以有两个子节点，这些子节点很容易用两个指针来表示。但是假设我们有一棵树，它的每个节点都有很多孩子，如果我们不知道一个节点可以有多少个孩子，我们如何表示他们呢？</p><p id="3f43" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，考虑下面显示的树:</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi nn"><img src="../Images/4312ec6005e155dfba146fdee8f585d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SnEtnHyDEdo5c0VuhWnBxA.png"/></div></div></figure><h1 id="4510" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">我们如何表示通用树？</h1><p id="e6a3" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">在上面的树中，有 6 个子节点、3 个子节点、2 子节点、1 子节点和零子节点(叶子)。为了呈现这个树，我们必须考虑最坏的情况(6 个子节点),并且为每个节点分配那么多子节点指针。</p><p id="8517" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因为我们没有在所有情况下都使用所有的指针，所以有很多内存浪费。另一个问题是我们事先不知道每个节点的子节点的数量。为了解决这个问题，我们需要一个最小化浪费的表示，并且还接受具有任意数量子节点的节点。</p><h1 id="53ff" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">类属树的表示</h1><p id="6fa7" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">由于我们的目标是到达树的所有节点，因此可能的解决方案如下:</p><ul class=""><li id="a151" class="ma mb in jm b jn jo jr js jv mc jz md kd me kh mf mg mh mi bi translated">在每个节点上，从左到右链接相同父节点(兄弟节点)的子节点。</li><li id="8880" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">除了第一个孩子，删除从父到所有孩子的链接。</li></ul><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi no"><img src="../Images/1a422e25888e9a82e8cc741311c05081.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_rmLMoN33No0PwT8aRyUzQ.png"/></div></div></figure><p id="7e2c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面这些陈述说的是，如果我们在孩子之间有一个链接，那么我们不需要从父母到所有孩子的额外链接。这是因为我们可以从父元素的第一个子元素开始遍历所有元素。因此，如果我们有一个父节点和第一个子节点之间的链接，以及同一个父节点的所有子节点之间的链接，那么这就解决了我们的问题。</p><blockquote class="np nq nr"><p id="4332" class="jk jl ns jm b jn jo jp jq jr js jt ju nt jw jx jy nu ka kb kc nv ke kf kg kh ig bi translated">这种表示有时被称为第一个孩子/下一个兄弟姐妹表示。类属树的第一个子/下一个兄弟表示如上所示。该树的实际表示为:</p></blockquote><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi nw"><img src="../Images/4378fd2ca6caf01a27a5117f90f0f5b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qvywi4dMyq26rDy1ktKbsQ.png"/></div></div></figure><h1 id="89a1" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">二分搜索法树</h1><h2 id="70da" class="mt kj in bd kk mz na dn ko nb nc dp ks jv nd ne kw jz nf ng la kd nh ni le nj bi translated">为什么是二分搜索法树？</h2><p id="588b" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi nx translated">在前面的中，我们已经讨论了不同的树形表示，在所有这些表示中，我们都没有对节点数据施加任何限制。因此，要搜索一个元素，我们需要同时检查左子树和右子树。因此，搜索操作的最坏情况复杂度是 O(n)。</p><p id="0d56" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里，我们将讨论二叉树的另一种变体:二分搜索法树。顾名思义，这种表示法主要用于搜索。在这种表示中，我们对节点可以包含的数据种类施加了限制。因此，它将最坏情况下的平均搜索操作减少到 O(logn)。</p><h1 id="b6ee" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">二叉查找树房产</h1><p id="4a18" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">在二分搜索法树中，所有左边的子树元素应该小于根数据，所有右边的子树元素应该大于根数据。这就是所谓的二叉查找树财产。注意，树中的每个节点都应该满足这个属性。</p><ul class=""><li id="d3ce" class="ma mb in jm b jn jo jr js jv mc jz md kd me kh mf mg mh mi bi translated">节点的左子树只包含键小于节点键的节点。</li><li id="5e23" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">节点的右边子树只包含键大于节点键的节点。</li><li id="c729" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">左右子树也必须是二分搜索法树</li></ul><h1 id="77eb" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">二分搜索法树上的操作</h1><p id="bd9f" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated"><strong class="jm io">主要作业</strong>:以下是二分搜索法树支持的主要作业:</p><ul class=""><li id="3728" class="ma mb in jm b jn jo jr js jv mc jz md kd me kh mf mg mh mi bi translated">在二分搜索法树中查找/查找最小/查找最大元素</li><li id="416b" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">在二分搜索法树中插入元素</li><li id="9efd" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">从二分搜索法树中删除元素</li></ul><p id="f5bd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">辅助操作</strong>:检查给定的树是否是二叉查找树</p><ul class=""><li id="713d" class="ma mb in jm b jn jo jr js jv mc jz md kd me kh mf mg mh mi bi translated">寻找树中第 k 个最小的元素</li><li id="62b8" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">整理二叉查找树和其他许多元素</li></ul><h1 id="f2d3" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">插入来自二叉查找树的元素</h1><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div class="gh gi og"><img src="../Images/af3ad9c9751c09bf2b1b9266c0514cb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*DGHO5Vlknuph97lAKTvQzQ.png"/></div></figure><p id="d849" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要将数据插入二叉查找树，首先我们需要找到该元素的位置。我们可以通过遵循与查找操作相同的机制来找到插入的位置。在寻找位置时，如果数据已经在那里，那么我们可以简单地忽略并出来。否则，在遍历路径的最后一个位置插入数据。</p><p id="8f98" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">作为一个例子，让我们考虑下面的树。虚线节点表示要插入的元素(5)。要插入 5，使用 find 函数遍历树。在键为 4 的节点，我们需要向右，但是没有子树，所以 5 不在树中，这是正确的插入位置。</p><pre class="ln lo lp lq gt mo mp mq mr aw ms bi"><span id="7ab4" class="mt kj in mp b gy mu mv l mw mx">class BinarySearchTree:<br/><br/>    def addNodeRecursively(self, root , ele):<br/>        if root is None:<br/>            return Node(ele)<br/>        if ele &lt; root.data:<br/>            root.left = self.addNodeRecursively(root.left,ele)<br/>        else:<br/>            root.right = self.addNodeRecursively(root.right,ele)<br/>        return root<br/>    <br/>root = None<br/>instance = BinarySearchTree()<br/>for ele in [4,6,7,9,2,10]:<br/>    root = instance.addNodeRecursively(root,ele)</span></pre><p id="75e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">递归:-时间复杂度:O(n)，空间复杂度:O(n)</p><p id="4695" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">迭代:空间复杂度为 O(1)。</p><h1 id="756b" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">在二分搜索法树中寻找元素</h1><p id="e461" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">BST 中的查找操作非常简单。从根开始，使用 BST 属性继续向左或向右移动。如果我们搜索的数据与节点数据相同，那么我们返回当前节点。</p><p id="a1ec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们搜索的数据少于节点数据，则搜索当前节点的左子树；否则搜索当前节点的右子树。如果数据不存在，我们就会以空链接结束。</p><pre class="ln lo lp lq gt mo mp mq mr aw ms bi"><span id="4728" class="mt kj in mp b gy mu mv l mw mx">    def search(self , root , ele):<br/>        if root is None or root.data is ele:<br/>            return root<br/>        if root.data &gt; ele:<br/>            return self.search(root.left , ele)<br/>        else:<br/>            return self.search(root.right , ele)</span><span id="1710" class="mt kj in mp b gy oh mv l mw mx"><strong class="mp io">#Out side class , you can test it by writing below codes</strong></span><span id="c0c0" class="mt kj in mp b gy oh mv l mw mx">searchedEle = instance.search(root,7)<br/>if searchedEle is None:<br/>    print("elemet is not found")<br/>else:<br/>    print(searchedEle.data)</span></pre><p id="efbc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">递归:-时间复杂度:O(n)，在最坏的情况下(当 BST 是斜树时)。空间复杂度:O(n)。</p><p id="3529" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">时间复杂度:O(n)。空间复杂度:O(1)</p><h1 id="011b" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">在二分搜索法树中寻找最小元素</h1><p id="8655" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">在 BSTs 中，最小元素是最左边的节点，它没有左边的子元素。</p><pre class="ln lo lp lq gt mo mp mq mr aw ms bi"><span id="f0e2" class="mt kj in mp b gy mu mv l mw mx">    def minumum(self,root):<br/>        current = root<br/>        while current.left is not None :<br/>            current = current.left<br/>        return current.data</span><span id="1c9b" class="mt kj in mp b gy oh mv l mw mx"><strong class="mp io">#Out side class , you can test it by writing below codes</strong></span><span id="b3a1" class="mt kj in mp b gy oh mv l mw mx">minimumEle = instance.minumum(root)<br/>print(minimumEle)</span></pre><p id="d65e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">递归:-时间复杂度:O(n)，最坏情况下(BST 为左斜树时)，空间复杂度:O(n)。</p><p id="91ff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">时间复杂度:O(n)。空间复杂度:O(1)。</p><h1 id="408a" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">寻找二分搜索法树中的最大元素</h1><p id="c104" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">在 BSTs 中，最大元素是最右边的节点，它没有右边的子元素。</p><pre class="ln lo lp lq gt mo mp mq mr aw ms bi"><span id="ea6b" class="mt kj in mp b gy mu mv l mw mx">    def maximum(self,root):<br/>        current = root<br/>        while current.right is not None :<br/>            current = current.right<br/>            <br/>        return current.data</span><span id="9c02" class="mt kj in mp b gy oh mv l mw mx"><strong class="mp io">#Out side class , you can test it by writing below codes</strong></span><span id="2694" class="mt kj in mp b gy oh mv l mw mx">maximumEle = instance.maximum(root)<br/>print(maximumEle)</span></pre><p id="4ca2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">递归:-时间复杂度:O(n)，最坏情况下(当 BST 是右斜树时)，空间复杂度:O(n)</p><p id="c99f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">时间复杂度:O(n)。空间复杂度:O(1)。</p><h1 id="125a" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">Inorder 的前任和继任者在哪里？</h1><p id="fb8d" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">如果 X 有两个孩子，那么它的 inordcr 前任是它的左子树中的最大值，它的 inorder 继任者是它的右子树中的最小值。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/215ee6eb010c317f278354f24004d857.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*Rn2JeBq7TURBki3cJw5rFQ.png"/></div></figure><h2 id="fe74" class="mt kj in bd kk mz na dn ko nb nc dp ks jv nd ne kw jz nf ng la kd nh ni le nj bi translated">有序继任者</h2><pre class="ln lo lp lq gt mo mp mq mr aw ms bi"><span id="f50a" class="mt kj in mp b gy mu mv l mw mx">    def inorderSuccessor(self,root):<br/>        root = root.right<br/>        while root.left:<br/>            root = root.left</span><span id="6c7e" class="mt kj in mp b gy oh mv l mw mx"><strong class="mp io">#Out side class , you can test it by writing below codes</strong></span><span id="1316" class="mt kj in mp b gy oh mv l mw mx">print(instance.inorderSuccessor(root))</span></pre><h2 id="b59f" class="mt kj in bd kk mz na dn ko nb nc dp ks jv nd ne kw jz nf ng la kd nh ni le nj bi translated">为了前辈</h2><pre class="ln lo lp lq gt mo mp mq mr aw ms bi"><span id="6431" class="mt kj in mp b gy mu mv l mw mx">    def inorderPredecessor(self,root):<br/>        root = root.left<br/>        while root.right:<br/>            root = root.right</span><span id="c1b4" class="mt kj in mp b gy oh mv l mw mx"><strong class="mp io">#Out side class , you can test it by writing below codes</strong></span><span id="0fb4" class="mt kj in mp b gy oh mv l mw mx">print(instance.inorderPredecessor(root))</span></pre><h1 id="969b" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">从二叉查找树中删除元素</h1><p id="2d21" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">删除操作比其他操作更复杂。这是因为要删除的元素可能不是叶节点。同样在这个操作中，首先我们需要找到想要删除的元素的位置。</p><p id="abb9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦我们找到要删除的节点，考虑以下情况:</p><ul class=""><li id="0079" class="ma mb in jm b jn jo jr js jv mc jz md kd me kh mf mg mh mi bi translated">如果要删除的元素是叶节点:向其父节点返回 NULL。这意味着使相应的子指针为空。在下面的树中删除 5，将 NULL 设置为它的父节点 2。</li></ul><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/c130acef23f3e86b75bdfb43c5130e7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*84AEoCJOYZT84HvR8RhnUQ.png"/></div></figure><ul class=""><li id="d258" class="ma mb in jm b jn jo jr js jv mc jz md kd me kh mf mg mh mi bi translated">如果要删除的元素只有一个子元素:在这种情况下，我们只需要将当前节点的子元素发送给它的父元素。在下面的树中，删除 4，4 左子树被设置为它的父节点 2。</li></ul><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/e4f9760cca093fa06654025d220222ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/format:webp/1*HP1sMPxZ99Jg3NU9ANDvvw.png"/></div></figure><ul class=""><li id="4a05" class="ma mb in jm b jn jo jr js jv mc jz md kd me kh mf mg mh mi bi translated">如果要删除的元素有两个子元素:一般的策略是用左子树最大的元素替换这个节点的键，递归删除那个节点(现在是空的)。左子树中最大的节点不能有右子节点，所以第二次删除很容易。作为一个例子，让我们考虑下面的树。在下面的树中，删除 8，它是根的右子。键值是 8。它被替换为左子树中最大的键(7)，然后像以前一样删除该节点(第二种情况)。</li></ul><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi ol"><img src="../Images/411057a7e55631a2a3d5abda7d226d55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jHL-S-t3xgGKmuRImXUMVQ.png"/></div></div></figure><pre class="ln lo lp lq gt mo mp mq mr aw ms bi"><span id="512a" class="mt kj in mp b gy mu mv l mw mx">def deletion(self, root, key):<br/>  if not root:<br/>   return "Not Found"<br/> <br/>  if key &lt; root.data:<br/>   root.left = self.deletion(root.left, key)<br/>  elif key &gt; root.data:<br/>   root.right = self.deletion(root.right, key)<br/>  else:<br/>   if not (root.left or root.right):<br/>    root = None<br/> <br/>   elif root.right:<br/>    root.data = self.successor(root)<br/>    root.right = self.deletion(root.right, root.data)<br/> <br/>   else:<br/>    root.data = self.predecessor(root)<br/>    root.left = self.deletion(root.left, root.data)<br/>  return root</span></pre><p id="5a8f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">递归:-时间复杂度:O(n)。空间复杂度:O(n)。</p><p id="8e3f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">迭代:-空间复杂度为 O(1)。</p><h1 id="3d1b" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">有序遍历(左、根、右)</h1><p id="6b2a" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">在有序遍历中，在子树之间访问根。有序遍历的定义如下:</p><ul class=""><li id="477d" class="ma mb in jm b jn jo jr js jv mc jz md kd me kh mf mg mh mi bi translated">按顺序遍历左子树。</li><li id="bfce" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">访根。</li><li id="44fc" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">依次遍历右边的子树</li></ul><h1 id="09a6" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">关于二分搜索法树的重要说明</h1><ul class=""><li id="6d9b" class="ma mb in jm b jn lg jr lh jv nk jz nl kd nm kh mf mg mh mi bi translated">因为根数据总是在左子树数据和右子树数据之间，所以对二叉查找树进行有序遍历会产生一个有序列表。</li></ul><h2 id="9d85" class="mt kj in bd kk mz na dn ko nb nc dp ks jv nd ne kw jz nf ng la kd nh ni le nj bi translated">为了递归</h2><pre class="ln lo lp lq gt mo mp mq mr aw ms bi"><span id="d0b4" class="mt kj in mp b gy mu mv l mw mx">    def inorderRecursively(self,root):<br/>        if root is None:<br/>            return<br/>        self.inorderRecursively(root.left)<br/>        print(root.data)<br/>        self.inorderRecursively(root.right)</span><span id="0710" class="mt kj in mp b gy oh mv l mw mx"><strong class="mp io">#Out side class , you can test it by writing below codes</strong></span><span id="9b51" class="mt kj in mp b gy oh mv l mw mx">instance.inorderRecursively(root)</span></pre><h2 id="6856" class="mt kj in bd kk mz na dn ko nb nc dp ks jv nd ne kw jz nf ng la kd nh ni le nj bi translated">不可避免地</h2><pre class="ln lo lp lq gt mo mp mq mr aw ms bi"><span id="d335" class="mt kj in mp b gy mu mv l mw mx">    def inorderItteratevely(self,root):<br/>        current = root<br/>        stack = []<br/>        <br/>        while True:<br/>            if current is not None:<br/>                stack.append(current)<br/>                current = current.left<br/>                <br/>            elif stack :<br/>                current = stack.pop()<br/>                print(current.data)<br/>                current = current.right<br/>            else:<br/>                break</span><span id="240b" class="mt kj in mp b gy oh mv l mw mx"><strong class="mp io">#Out side class , you can test it by writing below codes</strong></span><span id="671a" class="mt kj in mp b gy oh mv l mw mx">instance.inorderItteratevely(root)</span></pre><h1 id="c1c4" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">前序遍历(根，左，右)</h1><p id="b47d" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">在前序遍历中，每个节点都在其任一子树之前被处理。这是最容易理解的遍历。然而，即使每个节点在子树之前被处理，它仍然要求在向下移动树时必须维护一些信息。</p><p id="1841" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">前序遍历定义如下:</strong></p><ul class=""><li id="c0f3" class="ma mb in jm b jn jo jr js jv mc jz md kd me kh mf mg mh mi bi translated">访根。</li><li id="1c65" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">按前序遍历左子树。</li><li id="0dbc" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">按前序遍历右边的子树。</li></ul><h2 id="764f" class="mt kj in bd kk mz na dn ko nb nc dp ks jv nd ne kw jz nf ng la kd nh ni le nj bi translated">递归预排序</h2><pre class="ln lo lp lq gt mo mp mq mr aw ms bi"><span id="a5de" class="mt kj in mp b gy mu mv l mw mx">    def preorderRecursively(self,root):<br/>        if root is None:<br/>            return<br/>        print(root.data)<br/>        self.preorderRecursively(root.left)<br/>        self.preorderRecursively(root.right)</span><span id="7111" class="mt kj in mp b gy oh mv l mw mx"><strong class="mp io">#Out side class , you can test it by writing below codes</strong></span><span id="c401" class="mt kj in mp b gy oh mv l mw mx">instance.preorderRecursively(root)</span></pre><h2 id="785e" class="mt kj in bd kk mz na dn ko nb nc dp ks jv nd ne kw jz nf ng la kd nh ni le nj bi translated">预定不确定</h2><pre class="ln lo lp lq gt mo mp mq mr aw ms bi"><span id="2b73" class="mt kj in mp b gy mu mv l mw mx">    def preorderItteratevely(self,root):<br/>        if root is None:<br/>            return<br/>        stack = []<br/>        stack.append(root)<br/>        while stack:<br/>            current = stack.pop()<br/>            print(current.data)<br/>            <br/>            if current.right:<br/>                stack.append(current.right)<br/>            if current.left:<br/>                stack.append(current.left)</span><span id="70a1" class="mt kj in mp b gy oh mv l mw mx"><strong class="mp io">#Out side class , you can test it by writing below codes</strong></span><span id="cd39" class="mt kj in mp b gy oh mv l mw mx">instance.preorderItteratevely(root)</span></pre><h1 id="7c8a" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">后序遍历(左、右、根)</h1><p id="e62f" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">在后序遍历中，在两个子树之后访问根。后序遍历定义如下:</p><ul class=""><li id="7490" class="ma mb in jm b jn jo jr js jv mc jz md kd me kh mf mg mh mi bi translated">按后序遍历左边的子树。</li><li id="4e89" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">按后序遍历右边的子树。</li><li id="25ae" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">访根。</li></ul><h2 id="805f" class="mt kj in bd kk mz na dn ko nb nc dp ks jv nd ne kw jz nf ng la kd nh ni le nj bi translated">递归后置</h2><pre class="ln lo lp lq gt mo mp mq mr aw ms bi"><span id="1854" class="mt kj in mp b gy mu mv l mw mx">    def postorderRecurseveluy(self,root):<br/>        if root is None:<br/>            return<br/>        self.postorderRecurseveluy(root.left)<br/>        self.postorderRecurseveluy(root.right)<br/>        print(root.data)</span><span id="25f4" class="mt kj in mp b gy oh mv l mw mx"><strong class="mp io">#Out side class , you can test it by writing below codes</strong></span><span id="fb22" class="mt kj in mp b gy oh mv l mw mx">instance.postorderRecurseveluy(root)</span></pre><h2 id="b24e" class="mt kj in bd kk mz na dn ko nb nc dp ks jv nd ne kw jz nf ng la kd nh ni le nj bi translated">后期订单</h2><pre class="ln lo lp lq gt mo mp mq mr aw ms bi"><span id="f2a6" class="mt kj in mp b gy mu mv l mw mx">    def postorderItteratively(self,root):<br/>        if root is None:<br/>            return<br/>        recursiveStack = []<br/>        resultStack = []<br/>        recursiveStack.append(root)<br/>        <br/>        while recursiveStack:<br/>            current = recursiveStack.pop()<br/>            resultStack.append(current)<br/>            <br/>            if current.left:<br/>                recursiveStack.append(current.left)<br/>            if current.right:<br/>                recursiveStack.append(current.right)<br/>        <br/>        while resultStack:<br/>            current = resultStack.pop()<br/>            print(current.data)</span><span id="dc67" class="mt kj in mp b gy oh mv l mw mx"><strong class="mp io">#Out side class , you can test it by writing below codes</strong></span><span id="209e" class="mt kj in mp b gy oh mv l mw mx">instance.postorderItteratively(root)</span></pre><h1 id="6df4" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">计算 BST 中的节点数</h1><pre class="ln lo lp lq gt mo mp mq mr aw ms bi"><span id="0d94" class="mt kj in mp b gy mu mv l mw mx">    def countNodes(self , root):<br/>        if root is None :<br/>            return 0 <br/>        return 1 + self.countNodes(root.left) + self.countNodes(root.right)</span><span id="725a" class="mt kj in mp b gy oh mv l mw mx"><strong class="mp io">#Out side class , you can test it by writing below codes</strong></span><span id="483b" class="mt kj in mp b gy oh mv l mw mx">print(instance.countNodes(root))</span></pre><h1 id="fb33" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">计算 BST 中的叶子数</h1><pre class="ln lo lp lq gt mo mp mq mr aw ms bi"><span id="c78e" class="mt kj in mp b gy mu mv l mw mx">    def countLeaf(self , root):<br/>        if root is None:<br/>            return 0 <br/>        if root.left is None and root.right is None:<br/>            return 1<br/>        else:<br/>            return self.countLeaf(root.left) + self.countLeaf(root.right)</span><span id="fec2" class="mt kj in mp b gy oh mv l mw mx"><strong class="mp io">#Out side class , you can test it by writing below codes</strong></span><span id="e626" class="mt kj in mp b gy oh mv l mw mx">print(instance.countLeaf(root))</span></pre><h1 id="442d" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">计算 BST 的最大深度</h1><pre class="ln lo lp lq gt mo mp mq mr aw ms bi"><span id="5c8d" class="mt kj in mp b gy mu mv l mw mx">    def maxDepth(self, root):<br/>        if root is None:<br/>            return 0 <br/>        else:<br/>            leftDepth = self.maxDepth(root.left)<br/>            rightDepth = self.maxDepth(root.right)<br/>            if leftDepth &gt; rightDepth:<br/>                return leftDepth + 1<br/>            elif rightDepth &gt; leftDepth:<br/>                return rightDepth + 1<br/>            else:<br/>                return leftDepth + 1 #if both are equal then any one</span><span id="a6d9" class="mt kj in mp b gy oh mv l mw mx"><strong class="mp io">#Out side class , you can test it by writing below codes</strong></span><span id="aef8" class="mt kj in mp b gy oh mv l mw mx">print(instance.maxDepth(root))</span></pre><h1 id="14f6" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">表达式树</h1><p id="c84c" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi nx translated"><span class="l ny nz oa bm ob oc od oe of di">代表一个表达式的</span>树叫做表达式树。在表达式树中，叶节点是操作数，非叶节点是运算符。这意味着，表达式树是一个二叉树，其中内部节点是操作符，叶子是操作数。表达式树由二进制表达式组成。但是对于一个 u 进制操作符，一个子树将是空的。下图显示了(A + B * C) / D 的简单表达式树。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi om"><img src="../Images/719440f37b3385330c8418ef03517fbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kc_Nx6F1Y8LQ7N6EgRpeuA.png"/></div></div></figure><h2 id="1536" class="mt kj in bd kk mz na dn ko nb nc dp ks jv nd ne kw jz nf ng la kd nh ni le nj bi translated">用树进行表达式求值</h2><pre class="ln lo lp lq gt mo mp mq mr aw ms bi"><span id="8765" class="mt kj in mp b gy mu mv l mw mx">class ExpressionTree:<br/>   def evaluate(self, root):<br/>       if root is None:<br/>           return 0<br/>       if root.left == None and root.right == None:<br/>           return int(root.data)<br/> <br/>       left = self.evaluate(root.left)<br/>       right = self.evaluate(root.right)<br/>       if root.data == '+':<br/>           return left + right<br/>       elif root.data == '*':<br/>           return left * right<br/>       elif root.data == '-':<br/>           return left - right <br/>       elif root.data == '/':<br/>          return left /right<br/>       elif root.data == '^':<br/>          return left ** right</span><span id="c57e" class="mt kj in mp b gy oh mv l mw mx"><strong class="mp io">#Out side class , you can test it by writing below codes</strong></span><span id="8171" class="mt kj in mp b gy oh mv l mw mx">root = Node('*')<br/>root.left = Node('+')<br/>root.right = Node('*')<br/>root.left.left = Node('2')<br/>root.left.right = Node('3')<br/>root.right.left = Node('4')<br/>root.right.right = Node('+')<br/>root.right.right.left = Node('5')<br/>root.right.right.right = Node('6')<br/>e = ExpressionTree()<br/>result = e.evaluate(root)<br/>print(result)</span></pre></div><div class="ab cl on oo hr op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="ig ih ii ij ik"><p id="e758" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了定义的目的，我用了 DS 制作的简易书</p><h1 id="e7a4" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">来源</h1><p id="77ef" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">我的 LinkedIn:-【linkedin.com/in/my-pro-file】<strong class="jm io"/></p><h1 id="4ef8" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">您可能感兴趣的主题:</h1><ul class=""><li id="c6c5" class="ma mb in jm b jn lg jr lh jv nk jz nl kd nm kh mf mg mh mi bi translated"><strong class="jm io">堆和优先队列</strong>:<a class="ae ll" href="https://medium.com/@mdcode2021/heap-and-priority-queue-fbd41333dc0d" rel="noopener">https://medium . com/@ MD code 2021/Heap-and-priority-Queue-FBD 41333 dc0d</a></li><li id="3a59" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated"><strong class="jm io">所有关于双向链表:</strong><a class="ae ll" href="https://medium.com/@mdcode2021/all-about-doubly-linked-list-30f0f08afb9c" rel="noopener">https://medium . com/@ MD code 2021/All-About-double-Linked-List-30 f 0f 08 AFB 9 c</a></li><li id="bdd5" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated"><strong class="jm io">合并排序</strong>:<a class="ae ll" href="https://medium.com/swlh/title-1692d9fb5ced" rel="noopener">https://medium.com/swlh/title-1692d9fb5ced</a></li><li id="d7d8" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated"><strong class="jm io">插入排序</strong>:<a class="ae ll" href="https://medium.com/dev-genius/insertion-sort-program-in-swift-31740a454573" rel="noopener">https://medium . com/dev-genius/Insertion-Sort-program-in-swift-31740 a 454573</a></li><li id="5cb1" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated"><strong class="jm io">计数排序</strong>:<a class="ae ll" href="https://medium.com/@mdcode2021/counting-sort-algorithm-c32d71f2cc79" rel="noopener">https://medium . com/@ MD code 2021/Counting-Sort-algorithm-c 32d 71 F2 cc 79</a></li><li id="603c" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated"><strong class="jm io">选择排序</strong>:<a class="ae ll" href="https://medium.com/@mdcode2021/line-by-line-selection-sort-algorithm-explained-in-c-dd49638b15e" rel="noopener">https://medium . com/@ MD code 2021/line-by-line-Selection-Sort-algorithm-explained-in-c-DD 49638 b15e</a></li></ul></div></div>    
</body>
</html>