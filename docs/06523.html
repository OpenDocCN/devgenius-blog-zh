<html>
<head>
<title>Custom Terraform Provider Design: Part 01</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">定制地形提供商设计:第 1 部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/custom-terraform-provider-design-c39287c816e9?source=collection_archive---------3-----------------------#2022-01-14">https://blog.devgenius.io/custom-terraform-provider-design-c39287c816e9?source=collection_archive---------3-----------------------#2022-01-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/342791b1b2b3f69515cc6c0fe4d3cd44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DPpvJuzLQ5d_FUF2lLtXLg.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">图片来源:Sourav Patnaik(我自己)|ଯେତେଦେଖୁଥିଲେନୂଆଦିଶୁଥାଇସୁନ୍ଦରତୃପ୍ତିରଅବସାଦନାହିଁ|奥迪沙岛 Baleswar 的蓝湖</figcaption></figure><blockquote class="jz ka kb"><p id="f8d7" class="kc kd ke kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">这是创建一个定制的 Terraform 提供者来管理我们的应用程序的第 1 部分。</p></blockquote><p id="95ef" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi le translated"><span class="l lf lg lh bm li lj lk ll lm di"> T </span> <strong class="kf io"> erraform </strong>是一款开源的<strong class="kf io">基础设施 as Code (IaC) </strong>软件工具。基础设施即代码(IaC)是将基础设施定义保留在代码中并随后保留在版本控制中的实践。在这个开源工具的帮助下，我们可以将我们想要应用的指令应用到我们的基础设施，而不是手动操作。</p><p id="1dbc" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">简单地说，手动创建的基础设施是由个人创建的，而不是用代码记录的，可能是用文本格式记录的，或者更糟的是，根本不是；最终，团队或组织由于害怕破坏而不愿意接触这个基础设施。甚至我以前也遵循这种不好的做法:(但是<strong class="kf io"> IaC </strong>让我的生活更轻松。</p><p id="5752" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">让我们举一个在 Azure 上配置虚拟机的例子。在 Azure 中请求一个 VM 实例只需要注册 Azure，提供一堆值，然后点击“创建”按钮。“资源”将在几分钟内准备好，这是传统的做法。甚至可以使用 Azure CLI 并提供 CLI 参数来创建 VM。Terraform 提供了一种方法，以配置的形式获取这些凭证和输入，并处理它们以在目标云中创建资源。这些配置基本上是“<strong class="kf io">声明性的</strong>”语法，用 Terraform 理解的语言描述资源。</p><p id="1415" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">"<strong class="kf io"> Declarative </strong>"语法，即声明您希望 IaC 实现的最终状态。“给我一杯拿铁”，是陈述性的；你为了给我带杯拿铁面临什么不同的挑战，我不在乎。很无情吧。<strong class="kf io"> Terraform 遵循声明式方法</strong>让我们的生活变得更简单。“去自助餐厅，拿一杯新鲜的，装满拿铁的，放在我桌上”这是<strong class="kf io">命令式</strong>。这里你一步一步提到了你将如何得到一杯拿铁；通常你是在<strong class="kf io"> Ansible </strong>中做的。</p><p id="7e50" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">有了 IaC ，你不仅能够管理你基础设施(IaC 的主要宗旨是仅此而已)，你还能够在某些环境中部署你的应用，配置你的应用，放大/缩小你的应用，创建文件等等。</p><p id="1445" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">因此，基本上在这里您将编写一个文件(这里我们称之为 terraform 文件),其中包含您希望的目标环境中资源的状态。<strong class="kf io"> Terraform </strong>读取此文件，并通过与目标环境通信，将环境中的实际状态与您在 Terraform 文件中提到的所需状态进行比较，尝试在目标环境中创建/更新/获取/删除指定的资源。</p><h1 id="bb6c" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">Terraform 如何工作</h1><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ml"><img src="../Images/fd4153d2aecc2675e4227f9a06a4cc85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xgbWYOsi43OTLAC0cAK0qg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><a class="ae mq" href="https://learn.hashicorp.com/tutorials/terraform/provider-use" rel="noopener ugc nofollow" target="_blank">地形如何工作</a></figcaption></figure><ol class=""><li id="4521" class="mr ms in kf b kg kh kk kl lb mt lc mu ld mv la mw mx my mz bi translated">当你在你的系统/服务器/集群/基础设施中安装<strong class="kf io"> Terraform </strong>时，基本上你是在安装<strong class="kf io"> TERRAFORM 核心</strong>二进制文件(上图中的第一块)。这是一个 CLI 工具，用 Go 编写，它通常验证一个 terraform 文件，并构建一个<a class="ae mq" href="https://www.terraform.io/internals/graph" rel="noopener ugc nofollow" target="_blank">资源依赖图</a>，然后用数据对<strong class="kf io"> TERRAFORM 提供者</strong>进行 RPC 调用。Terraform 文件有。tf 文件扩展名，例如 main.tf</li><li id="c99f" class="mr ms in kf b kg na kk nb lb nc lc nd ld ne la mw mx my mz bi translated"><strong class="kf io"> TERRAFORM 插件/提供者</strong>桥接<strong class="kf io"> TERRAFORM 核心</strong>及其各自的目标 API。Terraform provider 插件通过基本的 CRUD APIs 实现资源，以便与第三方服务进行通信。Terraform 提供了<a class="ae mq" href="https://www.terraform.io/plugin/sdkv2/sdkv2-intro" rel="noopener ugc nofollow" target="_blank"> <strong class="kf io"> SDKv2 </strong> </a>和<a class="ae mq" href="https://www.terraform.io/plugin/framework" rel="noopener ugc nofollow" target="_blank"> <strong class="kf io"> Terraform 插件框架</strong> </a>来创建自定义的 Terraform 提供者。我们将在 Golang 中使用<a class="ae mq" href="https://www.terraform.io/plugin/sdkv2/sdkv2-intro" rel="noopener ugc nofollow" target="_blank"> <strong class="kf io"> SDKv2 </strong> </a>创建一个定制的 Terraform 提供者。</li><li id="66fa" class="mr ms in kf b kg na kk nb lb nc lc nd ld ne la mw mx my mz bi translated">直接访问我们资源的公开目标 API 是不安全的。在这种情况下，我们的整个系统将是紧密耦合的，这不是保持软件项目模块化的最佳现代编码实践。所以我们需要开发一个<strong class="kf io">客户端库</strong>，通过它我们可以与我们的目标 API 进行通信。我们将把这个<strong class="kf io">客户端库</strong>导入到我们的<strong class="kf io">平台提供者</strong>代码中，以访问<strong class="kf io">目标 API</strong>。</li><li id="f90e" class="mr ms in kf b kg na kk nb lb nc lc nd ld ne la mw mx my mz bi translated">最后，上图中的第四个模块<strong class="kf io">目标 API</strong>是我们的主应用程序，您已经在其中定义了应用程序的逻辑来实际执行操作。</li></ol><p id="fe24" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">在<code class="fe nf ng nh ni b">terraform plan</code>或<code class="fe nf ng nh ni b">terraform apply</code>时，<strong class="kf io">地形核心</strong>通过 RPC 接口请求<strong class="kf io">地形提供者</strong>执行一个动作。提供者试图通过对目标 API 的客户端库调用 CRUD 操作来完成请求。这个过程加强了关注点的清晰分离。提供者能够充当客户端库的抽象。</p><p id="3782" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated"><strong class="kf io">虽然大多数 Terraform 提供商管理云基础设施(例如 AWS、Azure 和 GCP 提供商)，但提供商可以充当任何 API 的接口，并允许 Terraform 潜在地管理任何资源。</strong></p></div><div class="ab cl nj nk hr nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ig ih ii ij ik"><blockquote class="jz ka kb"><p id="0d99" class="kc kd ke kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">在这篇博客中，我们将创建自定义的 Terraform 提供程序来管理我们的应用程序。</p></blockquote><h1 id="1392" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated"><strong class="ak">所以，我为什么要创建自定义的地形提供商</strong></h1><p id="d7e2" class="pw-post-body-paragraph kc kd in kf b kg nq ki kj kk nr km kn lb ns kq kr lc nt ku kv ld nu ky kz la ig bi translated">我用 Golang 写了一个名为<a class="ae mq" href="https://github.com/sourav977/avengers-backend" rel="noopener ugc nofollow" target="_blank"> <strong class="kf io">复仇者</strong> </a>的后端应用，它创建、更新、删除、获取所有<strong class="kf io">复仇者</strong>，并使用<strong class="kf io"> MongoDB </strong>存储数据。<a class="ae mq" href="https://hub.docker.com/repository/docker/souravpatnaik/avengers" rel="noopener ugc nofollow" target="_blank"> <strong class="kf io"> Docker 图像</strong> </a>也可用于此应用。您可以使用 docker-compose up 轻松运行或创建该应用程序的实例。之后可以使用任何 API 测试平台对这个应用进行 REST API 调用，管理<a class="ae mq" href="https://hub.docker.com/repository/docker/souravpatnaik/avengers#:~:text=Readme-,avengers,-Its%20a%20simple" rel="noopener ugc nofollow" target="_blank"> <strong class="kf io">复仇者</strong>资源</a>。</p><p id="6c7e" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">我想通过 Terraform 管理我的<a class="ae mq" href="https://github.com/sourav977/avengers-backend" rel="noopener ugc nofollow" target="_blank">复仇者联盟</a>资源。目前，还没有支持管理复仇者联盟资源的平台提供商。所以我必须手动创建一个新的提供者，并将其推送到<a class="ae mq" href="https://registry.terraform.io/providers/sourav977/avengers/latest" rel="noopener ugc nofollow" target="_blank"> Terraform Registry </a>，这样复仇者联盟的资源就可以轻松管理。我将用<a class="ae mq" href="https://www.terraform.io/plugin/sdkv2/sdkv2-intro" rel="noopener ugc nofollow" target="_blank"> SDKv2 </a>创建一个名为<a class="ae mq" href="https://github.com/sourav977/terraform-provider-avengers" rel="noopener ugc nofollow" target="_blank"><em class="ke">Terraform-Provider-avangers</em></a>的自定义 terra form 提供者，因为<a class="ae mq" href="https://www.terraform.io/plugin/framework" rel="noopener ugc nofollow" target="_blank"> Terraform 插件框架</a>还不够成熟。之后我会写一个 terraform.tf 文件来创建/获取/更新/删除复仇者，由 terraform 核心读取，然后传递给<a class="ae mq" href="https://github.com/sourav977/terraform-provider-avengers" rel="noopener ugc nofollow" target="_blank">terra form-provider-avangers</a>。</p><p id="35cc" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">由于<a class="ae mq" href="https://github.com/sourav977/avengers-backend" rel="noopener ugc nofollow" target="_blank"> <strong class="kf io">复仇者</strong> </a>是一个后端服务器端应用程序，我们将创建一个客户端应用程序或库来访问<a class="ae mq" href="https://github.com/sourav977/avengers-backend" rel="noopener ugc nofollow" target="_blank"> <strong class="kf io">复仇者</strong> </a> <strong class="kf io"> </strong>从<strong class="kf io"/><a class="ae mq" href="https://github.com/sourav977/terraform-provider-avengers" rel="noopener ugc nofollow" target="_blank"><strong class="kf io">terra form-provider-avangers</strong></a><strong class="kf io">。</strong>我已经创建了名为<a class="ae mq" href="https://github.com/sourav977/avengers-client" rel="noopener ugc nofollow" target="_blank"> <strong class="kf io">复仇者联盟-客户端</strong> </a>的库。</p><p id="bbb8" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">于是我们将<a class="ae mq" href="https://github.com/sourav977/avengers-client" rel="noopener ugc nofollow" target="_blank"> <strong class="kf io">复仇者-客户端</strong> </a> <strong class="kf io"> </strong>导入到<strong class="kf io"/><a class="ae mq" href="https://github.com/sourav977/terraform-provider-avengers" rel="noopener ugc nofollow" target="_blank"><strong class="kf io">terraform-provider-avangers</strong></a><strong class="kf io"/>中，与<strong class="kf io"> </strong> <a class="ae mq" href="https://github.com/sourav977/avengers-backend" rel="noopener ugc nofollow" target="_blank"> <strong class="kf io">复仇者</strong> </a> <strong class="kf io">进行通信。</strong></p><p id="3f5e" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">为了让学习变得简单，我设计了所有的 API，没有任何认证和授权。</p><blockquote class="jz ka kb"><p id="ea0c" class="kc kd ke kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">上述实现的图示将如下。将它与上面的 Terraform 如何工作图像进行比较。</p></blockquote><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nv"><img src="../Images/753042cfaa5c5a53a456d3b8be0574b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AnCejdmKr2njlJnUOnLGEA.png"/></div></div></figure><h2 id="145a" class="nw lo in bd lp nx ny dn lt nz oa dp lx lb ob oc mb lc od oe mf ld of og mj oh bi translated">参考:</h2><ul class=""><li id="a044" class="mr ms in kf b kg nq kk nr lb oi lc oj ld ok la ol mx my mz bi translated"><strong class="kf io">复仇者联盟-后端</strong>:【https://github.com/sourav977/avengers-backend】T2</li><li id="7b8e" class="mr ms in kf b kg na kk nb lb nc lc nd ld ne la ol mx my mz bi translated">【复仇者联盟-客户端:<a class="ae mq" href="https://github.com/sourav977/avengers-client" rel="noopener ugc nofollow" target="_blank">https://github.com/sourav977/avengers-client</a></li><li id="79ae" class="mr ms in kf b kg na kk nb lb nc lc nd ld ne la ol mx my mz bi translated"><strong class="kf io">地形供应商复仇者</strong>:<a class="ae mq" href="https://github.com/sourav977/terraform-provider-avengers" rel="noopener ugc nofollow" target="_blank">https://github.com/sourav977/terraform-provider-avengers</a></li><li id="fc74" class="mr ms in kf b kg na kk nb lb nc lc nd ld ne la ol mx my mz bi translated"><strong class="kf io"> Terraform 注册表</strong>:<a class="ae mq" href="https://registry.terraform.io/providers/sourav977/avengers/latest" rel="noopener ugc nofollow" target="_blank">https://Registry . terra form . io/providers/sourav 977/Avengers/latest</a></li></ul><p id="c70c" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">我已经按照 Terraform 网站提到的<a class="ae mq" href="https://learn.hashicorp.com/collections/terraform/providers" rel="noopener ugc nofollow" target="_blank"> <strong class="kf io">教程创建了自定义的 Terraform 提供者</strong> </a>。由于我的应用程序需求与教程不同，我对它们做了相应的修改。</p><h1 id="fe18" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">先决条件</h1><ul class=""><li id="3efa" class="mr ms in kf b kg nq kk nr lb oi lc oj ld ok la ol mx my mz bi translated">Golang 1.14+</li><li id="b1ad" class="mr ms in kf b kg na kk nb lb nc lc nd ld ne la ol mx my mz bi translated">本地安装的 Terraform 0.14+ CLI 。</li><li id="f312" class="mr ms in kf b kg na kk nb lb nc lc nd ld ne la ol mx my mz bi translated"><a class="ae mq" href="https://www.docker.com/products/docker-desktop" rel="noopener ugc nofollow" target="_blank"> Docker </a>在本地运行<a class="ae mq" href="https://github.com/sourav977/avengers-backend" rel="noopener ugc nofollow" target="_blank"> <strong class="kf io">复仇者</strong> </a> <strong class="kf io"> </strong>的实例。</li><li id="1d75" class="mr ms in kf b kg na kk nb lb nc lc nd ld ne la ol mx my mz bi translated">用于代码编辑的 VSCode</li><li id="62ea" class="mr ms in kf b kg na kk nb lb nc lc nd ld ne la ol mx my mz bi translated">我在我的 Mac 电脑上做这个项目，因为 windows 会做相应的改变。</li><li id="f39e" class="mr ms in kf b kg na kk nb lb nc lc nd ld ne la ol mx my mz bi translated">我还假设你熟悉通常的地形规划/应用工作流程。如果您不熟悉 Terraform 本身，请首先参考<a class="ae mq" href="https://learn.hashicorp.com/collections/terraform/aws-get-started" rel="noopener ugc nofollow" target="_blank">入门指南</a>。</li></ul><h1 id="8d44" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated"><strong class="ak">第一步:在本地运行复仇者联盟后端的一个实例</strong></h1><ul class=""><li id="53cd" class="mr ms in kf b kg nq kk nr lb oi lc oj ld ok la ol mx my mz bi translated">首先，我们需要一个正在运行的复仇者联盟后端实例</li><li id="8f61" class="mr ms in kf b kg na kk nb lb nc lc nd ld ne la ol mx my mz bi translated">打开一个新的终端，git 克隆<a class="ae mq" href="https://github.com/sourav977/avengers-backend" rel="noopener ugc nofollow" target="_blank">https://github.com/sourav977/avengers-backend</a></li><li id="55be" class="mr ms in kf b kg na kk nb lb nc lc nd ld ne la ol mx my mz bi translated">复仇者联盟-后端</li><li id="abcf" class="mr ms in kf b kg na kk nb lb nc lc nd ld ne la ol mx my mz bi translated">docker-排版</li><li id="e4b8" class="mr ms in kf b kg na kk nb lb nc lc nd ld ne la ol mx my mz bi translated">将终端留在这里，我们的定制平台提供商将在开发完成后与之通信。</li><li id="447e" class="mr ms in kf b kg na kk nb lb nc lc nd ld ne la ol mx my mz bi translated">验证应用程序是否成功运行。打开 Postman 并向<a class="ae mq" href="http://localhost:8000/healthcheck" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/health check</a>发出 GET 请求</li></ul><h1 id="33f6" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">步骤 2:设置开发环境</h1><ul class=""><li id="5853" class="mr ms in kf b kg nq kk nr lb oi lc oj ld ok la ol mx my mz bi translated">创建了一个 Github 库<strong class="kf io">地形供应商复仇者联盟</strong>。</li><li id="091f" class="mr ms in kf b kg na kk nb lb nc lc nd ld ne la ol mx my mz bi translated"><strong class="kf io">注意</strong>回购名称应始终以<strong class="kf io">terra form-provider-&lt;provider-name&gt;</strong>开头。这里<strong class="kf io">提供者名称</strong>我选择了<strong class="kf io">复仇者</strong>。</li><li id="4464" class="mr ms in kf b kg na kk nb lb nc lc nd ld ne la ol mx my mz bi translated">在 new terminal 中，将刚刚创建的提供者存储库克隆到本地 go 工作区中。</li><li id="8a32" class="mr ms in kf b kg na kk nb lb nc lc nd ld ne la ol mx my mz bi translated">git 克隆 https://github.com/username/terraform-provider-<provider-name>&amp; &amp; CD 平台提供者- <provider-name/></provider-name></li><li id="9eca" class="mr ms in kf b kg na kk nb lb nc lc nd ld ne la ol mx my mz bi translated">现在将<a class="ae mq" href="https://github.com/hashicorp/terraform-provider-hashicups" rel="noopener ugc nofollow" target="_blank"><strong class="kf io">terra form hashi cups Provider repository</strong></a>的样板文件分支的内容复制到您本地的 terra form-Provider-&lt;Provider-name&gt;目录中。这是我们的提供者工作区的样板。<strong class="kf io">Ref</strong>:<a class="ae mq" href="https://github.com/hashicorp/terraform-provider-hashicups/tree/boilerplate" rel="noopener ugc nofollow" target="_blank">https://github . com/hashi corp/terra form-provider-hashi cups/tree/boilerplate</a></li><li id="a96f" class="mr ms in kf b kg na kk nb lb nc lc nd ld ne la ol mx my mz bi translated">同时编辑<strong class="kf io"> main.go </strong>文件中的<provider-name>包名。我赶上了<strong class="kf io">包复仇者联盟</strong></provider-name></li><li id="0b6f" class="mr ms in kf b kg na kk nb lb nc lc nd ld ne la ol mx my mz bi translated">我把 hashicups 目录改名为<provider-name>。我正在创建一个复仇者联盟供应商，所以我在这里将其重命名为复仇者联盟。<em class="ke">这符合创建定制地形供应商标准。</em></provider-name></li><li id="387f" class="mr ms in kf b kg na kk nb lb nc lc nd ld ne la ol mx my mz bi translated">正如我重命名目录，现在在复仇者联盟/供应商中重命名包名。转到<strong class="kf io">包复仇者联盟</strong></li><li id="8595" class="mr ms in kf b kg na kk nb lb nc lc nd ld ne la ol mx my mz bi translated">复制完成后，运行:<strong class="kf io">go mod init&amp;T45】go mod 整理</strong></li><li id="1951" class="mr ms in kf b kg na kk nb lb nc lc nd ld ne la ol mx my mz bi translated">已删除 docker_compose 目录，现在不需要。</li><li id="8ffa" class="mr ms in kf b kg na kk nb lb nc lc nd ld ne la ol mx my mz bi translated">现在，我的工作区如下所示:</li></ul><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi om"><img src="../Images/b3455f93770775a2b1b69e1bd6c76c69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KK2gdEHz6XMpTDXsrqn12w.png"/></div></div></figure><h1 id="58c7" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">探索您的开发环境</h1><ul class=""><li id="b995" class="mr ms in kf b kg nq kk nr lb oi lc oj ld ok la ol mx my mz bi translated"><strong class="kf io">main . go</strong>:main 函数消耗 Plugin SDK 的插件库，在那里我们传递 ProviderFunc Provider()，Provider func Provider()在 avengers 包中实现，方便 Terraform 核心和插件之间的 RPC 通信。Provider()是这个应用程序的核心。</li></ul><pre class="mm mn mo mp gt on ni oo op aw oq bi"><span id="8ccf" class="nw lo in ni b gy or os l ot ou">package main<br/><br/><br/>import (<br/>    "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"<br/>    "github.com/hashicorp/terraform-plugin-sdk/v2/plugin"<br/><br/><br/>    avenger "github.com/sourav977/terraform-provider-avengers/avengers"<br/>)<br/><br/><br/>func main() {<br/>    plugin.Serve(&amp;plugin.ServeOpts{<br/>        ProviderFunc: func() *schema.Provider {<br/>            return avenger.Provider()<br/>        },<br/>    })<br/>}</span></pre><ul class=""><li id="bd0d" class="mr ms in kf b kg kh kk kl lb mt lc mu ld mv la ol mx my mz bi translated"><strong class="kf io"> Makefile </strong>:包含 make 目标，用于在本地构建、打包和安装 custom-terraform-provider。</li><li id="6022" class="mr ms in kf b kg na kk nb lb nc lc nd ld ne la ol mx my mz bi translated">Do ' <strong class="kf io"> go env </strong>'并取出 GOHOSTOS 和 GOHOSTARCH 值，并在此处填充 OS 和 OS_ARCH 字段。比如 OS =达尔文 OS_ARCH=amd64。</li><li id="f589" class="mr ms in kf b kg na kk nb lb nc lc nd ld ne la ol mx my mz bi translated">HOSTNAME=github.com 我已经选择了，你可以给它你自己的喜欢 myinfrastracture.com 或 mydatabase.org 等</li><li id="6d32" class="mr ms in kf b kg na kk nb lb nc lc nd ld ne la ol mx my mz bi translated">命名空间，一个正确定义应用程序的名称</li><li id="be83" class="mr ms in kf b kg na kk nb lb nc lc nd ld ne la ol mx my mz bi translated">名字，提供者的名字，在这里我选择作为复仇者</li><li id="5f8c" class="mr ms in kf b kg na kk nb lb nc lc nd ld ne la ol mx my mz bi translated">这很重要。当你运行 make build 时，它会构建项目并在 Mac 中的<strong class="kf io">~/. terraform . d/plugins/$ { HOSTNAME }/$ { NAMESPACE }/$ { NAME }/$ { VERSION }/$ { OS } _ $ { OS _ ARCH }</strong>中保存二进制文件。实际上，当您键入 terraform init 时，Terraform Core 首先会在~/.terraform.d/plugins/中搜索其中提到的提供者二进制文件。如果没有找到，它将在 Terraform 注册表中搜索并下载提供者二进制文件副本并保存在此。当您构建自己的自定义 terraform 提供程序时，它既不会出现在<strong class="kf io"> ~/.terraform.d/plugins/ </strong>中，也不会出现在<strong class="kf io"> Terraform 注册表</strong>中。因此，在成功构建之后，将您的二进制文件保存在<strong class="kf io">~/. terraform . d/plugins/$ { HOSTNAME }/$ { NAMESPACE }/$ { VERSION }/$ { OS } _ $ { OS _ ARCH }</strong>中，对于这个项目，make install 将为您做到这一点。</li><li id="8cf6" class="mr ms in kf b kg na kk nb lb nc lc nd ld ne la ol mx my mz bi translated"><strong class="kf io">示例</strong>:包含一个样本 terraform 文件来测试您的提供者。</li><li id="1cad" class="mr ms in kf b kg na kk nb lb nc lc nd ld ne la ol mx my mz bi translated">复仇者联盟:这是最重要的包，包含了主要的提供者代码。这将是定义提供者的资源和数据源实现的地方。</li><li id="1a8d" class="mr ms in kf b kg na kk nb lb nc lc nd ld ne la ol mx my mz bi translated"><strong class="kf io"> avengers/provider.go </strong>:当前定义了一个空的提供者。</li></ul><pre class="mm mn mo mp gt on ni oo op aw oq bi"><span id="2897" class="nw lo in ni b gy or os l ot ou">package avengers<br/><br/><br/>import (<br/>  "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"<br/>)<br/><br/><br/>// Provider -<br/>func Provider() *schema.Provider {<br/>  return &amp;schema.Provider{<br/>    ResourcesMap: map[string]*schema.Resource{},<br/>    DataSourcesMap: map[string]*schema.Resource{},<br/>  }<br/>}</span></pre><ul class=""><li id="65f6" class="mr ms in kf b kg kh kk kl lb mt lc mu ld mv la ol mx my mz bi translated"><strong class="kf io"> ResourcesMap </strong>是一个映射，其中键属于<strong class="kf io">字符串</strong>，值属于<strong class="kf io">资源</strong>。基本上<strong class="kf io">映射键</strong>是一个<strong class="kf io"> provider_resourceName </strong>格式的资源名，如“aws_vm”、“aws_iam”、“aws_storage”等。<strong class="kf io">资源</strong>是<strong class="kf io">函数名</strong>，其中定义了目标资源的模式(在 aws_vm 中，vm 的模式表示您为创建 vm 提供的不同值，如名称、类型、大小、vCPU 号、ram 大小等)以及管理该资源的不同方法，如创建、读取、更新、删除方法。</li><li id="1046" class="mr ms in kf b kg na kk nb lb nc lc nd ld ne la ol mx my mz bi translated">意思是，当你要在一个 terraform 文件中编写，创建一个资源的例子:</li></ul><pre class="mm mn mo mp gt on ni oo op aw oq bi"><span id="d4b7" class="nw lo in ni b gy or os l ot ou">resource "aws_vm" "dev_vm" {<br/>  name = "dev_ubuntu_18"<br/>  ram = "2G"<br/>  vcpu = "2"<br/>}</span></pre><p id="8665" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">它会将上述代码解组到您定义的模式字段中，并传递给相应的创建、读取、更新、删除方法。同样，我创建了一个资源“avengers_resource”和相应的创建、读取、更新、删除方法。我们将在第 2 部分中讨论这个问题。</p><ul class=""><li id="a54d" class="mr ms in kf b kg kh kk kl lb mt lc mu ld mv la ol mx my mz bi translated"><strong class="kf io"> DataSourcesMap </strong>也是一个映射，其中键是字符串，值是资源。通常我们用它来获取所有的资源信息。这很重要。我们不应该在它上面实现创建、更新和删除方法。它与 ResourcesMap 相同，但只有 Get all/Read all 方法。</li><li id="5c1f" class="mr ms in kf b kg na kk nb lb nc lc nd ld ne la ol mx my mz bi translated">在这里，您将编写模式来保存获取的所有资源信息。一旦您读取了资源的所有信息，您就可以将结果整理到模式字段中。<a class="ae mq" href="https://souravpatnaik.medium.com/custom-terraform-provider-design-part-02-e67436752706" rel="noopener"> <strong class="kf io">我们会在第二部</strong> </a> <strong class="kf io">中那样做。</strong></li></ul><blockquote class="jz ka kb"><p id="93be" class="kc kd ke kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">第一部分到此结束。查看 <strong class="kf io"> <em class="in">参考上面的</em> </strong> <em class="in">部分了解更多详情。</em></p></blockquote><p id="9196" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">第 02 部分可用<a class="ae mq" href="https://souravpatnaik.medium.com/custom-terraform-provider-design-part-02-e67436752706" rel="noopener">此处</a>。</p><p id="2323" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">我在我的<a class="ae mq" href="https://www.linkedin.com/pulse/create-custom-terraform-provider-part-01-sourav-patnaik" rel="noopener ugc nofollow" target="_blank"> <strong class="kf io"> LinkedIn 文章</strong> </a>里也发布过同样的内容。</p><p id="17d4" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">Sourav Patnaik</p></div></div>    
</body>
</html>