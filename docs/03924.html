<html>
<head>
<title>Browser Automation with Python and Selenium — 5: Waits</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python和Selenium实现浏览器自动化— 5:等待</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/browser-automation-with-python-and-selenium-5-waits-4b9e4636548c?source=collection_archive---------0-----------------------#2021-01-04">https://blog.devgenius.io/browser-automation-with-python-and-selenium-5-waits-4b9e4636548c?source=collection_archive---------0-----------------------#2021-01-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="67f8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">确保它在那里</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/518a7dcbd68e182e616980438223b7f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DCjkjcm5QDUpqIp_"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@mike_van_den_bos?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">迈克·范·登博斯</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="9db0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<a class="ae kv" href="https://medium.com/python-in-plain-english/browser-automation-with-python-and-selenium-4-locating-elements-171ea5100490" rel="noopener">上一篇</a>文章中，我们研究了如何在与元素交互之前定位元素。在本文中，我们将探讨Selenium中的等待是如何确保元素在与它们交互之前出现在DOM中的。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="0895" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">HTML <code class="fe lz ma mb mc b">document</code>的<code class="fe lz ma mb mc b">document.readyState</code>属性描述了当前文档的加载状态。默认情况下，当就绪状态变为<code class="fe lz ma mb mc b">complete</code>时，<code class="fe lz ma mb mc b">driver.get</code>请求会返回给调用者。</p><p id="9f89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Selenium WebDriver 有三种<a class="ae kv" href="https://www.selenium.dev/documentation/en/webdriver/page_loading_strategy/" rel="noopener ugc nofollow" target="_blank">页面加载策略。</a></p><p id="d258" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">正常</strong></p><p id="1ad0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">等待整个页面加载完毕，这是由<code class="fe lz ma mb mc b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/load_event" rel="noopener ugc nofollow" target="_blank">load</a></code>事件决定的。</p><p id="dfab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">急切的</strong></p><p id="55e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">等到初始HTML文档被完全加载和解析，没有样式表、图像和由<code class="fe lz ma mb mc b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Document/DOMContentLoaded_event" rel="noopener ugc nofollow" target="_blank">DOMContentLoaded</a></code>事件指定的子框架。</p><p id="3cb9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">无</strong></p><p id="5ded" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果页面加载策略设置为none，Selenium WebDriver只会等到初始页面下载完毕。</p><p id="36b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当Selenium WebDriver加载页面时，它默认使用<code class="fe lz ma mb mc b">normal</code>策略。</p><p id="01dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">页面上的不同元素可以在不同的时间加载。这可能会导致定位元素失败。如果一个元素不在DOM结构中，当我们试图访问和操作它时，我们会得到一个异常。这些问题可以通过Selenium中的等待来解决。</p><p id="8e7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在文档完成加载后添加的元素无法通过<code class="fe lz ma mb mc b">find_*</code>方法找到。在这种情况下，我们的自动化代码将引发<code class="fe lz ma mb mc b">NoSuchElementException</code>。等待允许自动任务执行在继续下一步之前经过一段时间。</p><p id="2774" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有3种等待:</p><ol class=""><li id="d395" class="md me iq ky b kz la lc ld lf mf lj mg ln mh lr mi mj mk ml bi translated">含蓄的</li><li id="6f0b" class="md me iq ky b kz mm lc mn lf mo lj mp ln mq lr mi mj mk ml bi translated">明确的</li><li id="dcbc" class="md me iq ky b kz mm lc mn lf mo lj mp ln mq lr mi mj mk ml bi translated">流利的</li></ol><h2 id="93f3" class="mr ms iq bd mt mu mv dn mw mx my dp mz lf na nb nc lj nd ne nf ln ng nh ni nj bi translated">隐式等待</h2><p id="a0e9" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">使用隐式等待，WebDriver在引发异常之前会在指定的时间内轮询DOM。默认设置为0。一旦设置，它在WebDriver实例的整个生命周期内都有效。</p><p id="d652" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下面的例子中，<em class="np"> id </em>被故意错误地赋予了<code class="fe lz ma mb mc b">find_element_by_id</code>方法。因为我们将隐式等待设置为10秒，所以我们将在等待10秒后得到异常。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><pre class="kg kh ki kj gt ns mc nt nu aw nv bi"><span id="7052" class="mr ms iq mc b gy nw nx l ny nz"># output after 10 seconds<br/>Message: Unable to locate element: [id="typer"]</span></pre><p id="fd94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">隐式等待很容易使用，但是由于等待间隔对所有元素都有效，并且在WebDriver实例的生命周期内，它们会增加总的执行时间。</p><p id="464b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Selenium提供显式等待来避免这些硬编码全局等待的缺点。</p><h2 id="ba63" class="mr ms iq bd mt mu mv dn mw mx my dp mz lf na nb nc lj nd ne nf ln ng nh ni nj bi translated">显式等待</h2><p id="17cb" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">与硬编码的隐式等待不同，显式等待等待特定条件的发生。它也仅适用于给定的特定元素，而不是全局的所有元素。</p><p id="f500" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以一定的频率(默认为0.5秒)调用该条件，直到等待超时。如果条件失败，则引发<code class="fe lz ma mb mc b">TimeoutException</code>。</p><p id="3af8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Selenium Python API为常见情况提供了一些方法。</p><p id="6c40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它们在<code class="fe lz ma mb mc b">selenium.webdriver.support</code>包下的<code class="fe lz ma mb mc b">expected_conditions</code>模块<a class="ae kv" href="https://github.com/SeleniumHQ/selenium/blob/trunk/py/selenium/webdriver/support/expected_conditions.py" rel="noopener ugc nofollow" target="_blank">中定义。</a></p><p id="9efe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">预期条件列表</p><pre class="kg kh ki kj gt ns mc nt nu aw nv bi"><span id="b08f" class="mr ms iq mc b gy nw nx l ny nz">* alert_is_present<br/>* element_located_selection_state_to_be<br/>* element_located_to_be_selected<br/>* element_selection_state_to_be<br/>* element_to_be_clickable<br/>* element_to_be_selected<br/>* frame_to_be_available_and_switch_to_it<br/>* invisibility_of_element<br/>* invisibility_of_element_located<br/>* new_window_is_opened<br/>* number_of_windows_to_be<br/>* presence_of_all_elements_located<br/>* presence_of_element_located<br/>* staleness_of<br/>* text_to_be_present_in_element<br/>* text_to_be_present_in_element_value<br/>* title_contains<br/>* title_is<br/>* url_changes<br/>* url_contains<br/>* url_matches<br/>* url_to_be<br/>* visibility_of<br/>* visibility_of_all_elements_located<br/>* visibility_of_any_elements_located<br/>* visibility_of_element_located</span></pre><p id="a82e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<a class="ae kv" href="https://github.com/coskundeniz/selenium-examples/blob/main/waits/explicit_wait.py" rel="noopener ugc nofollow" target="_blank">接下来的示例</a>中，检查文本的结尾是否有动画元素。一旦满足条件，wait返回true，就可以打印全文。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><pre class="kg kh ki kj gt ns mc nt nu aw nv bi"><span id="8c6c" class="mr ms iq mc b gy nw nx l ny nz"># output<br/>Full text typed: Ask Doctor Python to fix your code...</span></pre><p id="4095" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">自定义等待条件</strong></p><p id="ef8d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果前面的方法不能满足您的要求，您还可以创建自己的自定义等待条件。可以使用带有<code class="fe lz ma mb mc b">__call__</code>方法的类创建一个定制的等待条件，当条件不匹配时，该方法返回<code class="fe lz ma mb mc b">False</code>。</p><p id="1580" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的示例显示了一个自定义等待条件实现，该实现检查元素是否具有特定的css类。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="f171" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为隐式等待是全局应用的，所以建议不要混合隐式和显式等待。</p><h2 id="8089" class="mr ms iq bd mt mu mv dn mw mx my dp mz lf na nb nc lj nd ne nf ln ng nh ni nj bi translated">流畅的等待</h2><p id="9ef1" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated"><code class="fe lz ma mb mc b">FluentWait</code>定义等待条件的最长时间，以及检查条件的频率。Python API没有<code class="fe lz ma mb mc b">FluentWait</code>类，但是它用关键字参数支持它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="c9e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">建议你看一下马丁福勒的<a class="ae kv" href="https://www.martinfowler.com/bliki/FluentInterface.html" rel="noopener ugc nofollow" target="_blank">流畅界面贴。</a></p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="0c98" class="mr ms iq bd mt mu mv dn mw mx my dp mz lf na nb nc lj nd ne nf ln ng nh ni nj bi translated">要记住的事情</h2><ul class=""><li id="2d53" class="md me iq ky b kz nk lc nl lf oa lj ob ln oc lr od mj mk ml bi translated">当Selenium WebDriver加载页面时，它默认使用<code class="fe lz ma mb mc b">normal</code>页面加载策略，等待<code class="fe lz ma mb mc b">load</code>事件从<code class="fe lz ma mb mc b">driver.get</code>请求返回给调用者。</li><li id="eeeb" class="md me iq ky b kz mm lc mn lf mo lj mp ln mq lr od mj mk ml bi translated">使用隐式等待，WebDriver在引发异常之前会在指定的时间内轮询DOM。一旦设置，它对WebDriver实例的整个生命周期和页面上的所有元素都有效。</li><li id="4f0f" class="md me iq ky b kz mm lc mn lf mo lj mp ln mq lr od mj mk ml bi translated">显式等待等待特定元素的特定条件发生。</li></ul><p id="614a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下一篇文章中，我将讲述URL、窗口和框架之间的导航。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="3b4e" class="mr ms iq bd mt mu mv dn mw mx my dp mz lf na nb nc lj nd ne nf ln ng nh ni nj bi translated">参考</h2><ol class=""><li id="9e84" class="md me iq ky b kz nk lc nl lf oa lj ob ln oc lr mi mj mk ml bi translated"><a class="ae kv" href="https://www.selenium.dev/documentation/en/webdriver/waits/" rel="noopener ugc nofollow" target="_blank">https://www.selenium.dev/documentation/en/webdriver/waits/</a></li><li id="e393" class="md me iq ky b kz mm lc mn lf mo lj mp ln mq lr mi mj mk ml bi translated"><a class="ae kv" href="https://www.softwaretestingo.com/selenium-wait-commands/" rel="noopener ugc nofollow" target="_blank">https://www.softwaretestingo.com/selenium-wait-commands/</a></li><li id="4d54" class="md me iq ky b kz mm lc mn lf mo lj mp ln mq lr mi mj mk ml bi translated"><a class="ae kv" href="https://selenium-python.readthedocs.io/waits.html" rel="noopener ugc nofollow" target="_blank">https://selenium-python.readthedocs.io/waits.html</a></li><li id="3614" class="md me iq ky b kz mm lc mn lf mo lj mp ln mq lr mi mj mk ml bi translated"><a class="ae kv" href="https://github.com/SeleniumHQ/selenium/blob/trunk/py/selenium/webdriver/support/wait.py" rel="noopener ugc nofollow" target="_blank">https://github . com/selenium HQ/selenium/blob/trunk/py/selenium/web driver/support/wait . py</a></li></ol><p id="5f46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">谢谢你的时间。</p></div></div>    
</body>
</html>