<html>
<head>
<title>WordPress, Object Cache, and Redis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">WordPress、对象缓存和 Redis</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/wordpress-object-cache-and-redis-f5d665f01115?source=collection_archive---------12-----------------------#2022-08-16">https://blog.devgenius.io/wordpress-object-cache-and-redis-f5d665f01115?source=collection_archive---------12-----------------------#2022-08-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="82ac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你想在提升你的 WP 编程技能的同时让你的 WordPress 网站更快吗？对象缓存可能是你的答案！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d0b3985f78d34f3aa66a9d886cc0187a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N6VqSiCiEeNd25WjdLUaBg.jpeg"/></div></div></figure><p id="0036" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<a class="ae ku" href="https://felipeelia.dev/what-is-an-api/" rel="noopener ugc nofollow" target="_blank">什么是 API </a>的帖子中，我简要提到了 WordPress 对象缓存以及我如何在博客中使用 Redis。在这篇文章中，我们将对这两个问题进行更深入的探讨。</p><h1 id="90da" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">在我们进入对象缓存之前…什么是缓存？</h1><p id="80e2" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">在我们开始讨论 Redis 之前，我们需要讨论一下对象缓存。在我们谈论对象缓存之前——您已经看到了它的到来——我们需要从总体上谈论缓存。</p><p id="3f50" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在互联网上寻找什么是缓存的定义，常识似乎是这样的:</p><blockquote class="ly lz ma"><p id="4b47" class="jk jl mb jm b jn jo jp jq jr js jt ju mc jw jx jy md ka kb kc me ke kf kg kh ig bi translated"><em class="in">缓存是一个具有快速访问</em>  <em class="in">的</em> <strong class="jm io"> <em class="in">中间存储，放置在消费者和主存储之间，潜在地节省了更长的行程。</em></strong></p></blockquote><p id="8bc2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">看看下面的例子。在第一个请求中，我们一直通过原始服务器，但是服务器缓存保存了响应的副本。在第二个请求中，提供副本，<strong class="jm io">通过不去原始服务器</strong>来节省时间。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mf"><img src="../Images/1c5ad259e6b0c365a1df4970ed07d528.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FBdFB5TttIceeApCW3grHA.jpeg"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">图片致谢:<a class="ae ku" href="https://www.keycdn.com/support/cache-definition-explanation" rel="noopener ugc nofollow" target="_blank">key dn 博客</a>。</figcaption></figure><p id="d383" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">考虑到这一点，我们可以开始考虑访问一个网站所需的所有几次旅行，以及我们可以插入以节省时间的所有中间步骤:</p><p id="b547" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">浏览器缓存:</strong>在你的浏览器和站点服务器之间，如果你的电脑上有<strong class="jm io">页面的有效副本</strong>，我们就省了一趟。事实上，在这种情况下，我们节省了整个行程。</p><p id="91eb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> CDN: </strong>如果你在网站上使用 Cloudflare 之类的 CDN，并且<strong class="jm io">CDN</strong>中有内容的有效副本，就没有理由要求新的副本。只发送副本就足够了，我们省去了一趟。</p><p id="5552" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> WP 的缓存:</strong>在你的 WordPress 网站中，如果一篇文章已经从数据库中带来，并且<strong class="jm io">如果这篇文章在内存中的版本仍然有效</strong>，为什么还要再去数据库？</p><p id="08b7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">还有许多其他中间位置，我们可以保存信息的版本，这些只是一些例子。</p><h1 id="1944" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">WordPress 对象缓存</h1><blockquote class="ly lz ma"><p id="0e72" class="jk jl mb jm b jn jo jp jq jr js jt ju mc jw jx jy md ka kb kc me ke kf kg kh ig bi translated">WordPress 对象缓存<em class="in">很简单，理解它的工作原理会在你下一次工作面试中产生影响；——)</em></p></blockquote><p id="81c6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如我在<a class="ae ku" href="https://felipeelia.dev/what-is-an-api/" rel="noopener ugc nofollow" target="_blank">什么是 API </a>一文中所说，内存访问总是比磁盘访问快。记住这一点，<strong class="jm io">如果我们从数据库中取出一个帖子，并把它放在内存中，我们就不需要再去数据库取回它了</strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/bd9fbfc9075c4f29e0ae6994ffaf5f73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/0*fF6OrNzhGy9FR_tO.png"/></div></figure><p id="09a0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">问题是，在 WordPress 的默认实现中，<strong class="jm io">只会在请求</strong>结束之前一直在内存中。如果用户刷新页面，我们将需要再次访问数据库。</p><p id="00d5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">MySQL 足够智能，可以注意到最近是否有信息被请求，并以更快的方式使其可用(基本上是将其存储在自己的内存部分)。<strong class="jm io">虽然更快，但不会像完全不上 MySQL 那么快。</strong></p><p id="1592" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">默认情况下，在执行开始时请求的这个 post(或任何其他信息)是使用一个名为<a class="ae ku" href="https://developer.wordpress.org/reference/classes/wp_object_cache" rel="noopener ugc nofollow" target="_blank"><strong class="jm io">WP _ Object _ Cache</strong></a>的类<strong class="jm io">存储的。它的主要目标是节省到数据库的行程，它基本上使用键-值对工作。问题是，就像我说的，只有一个要求。下一次，我们必须从头再来。</strong></p><h1 id="ef38" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">如何在内存中“储存”东西？Redis 或 Memcached</h1><p id="e483" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated"><strong class="jm io">像</strong><a class="ae ku" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io">Redis</strong></a><strong class="jm io">或者</strong><a class="ae ku" href="https://memcached.org/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io">Memcached</strong></a><strong class="jm io">这样的软件都是内存数据库。他们能做的不止这些——尤其是 Redis——但是对于 WordPress 的问题，它的密钥对值内存存储是我们所需要的一切。</strong></p><p id="3fce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这篇文章中，我将使用 Redis 作为例子，但是 Memcached 的安装和使用非常相似。</p><h1 id="92e2" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">在 Redis 中使用 WordPress 对象缓存需要什么？</h1><p id="2ba2" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">在 Redis 中使用 WordPress 对象缓存的要求非常简单:</p><ul class=""><li id="5f9a" class="ml mm in jm b jn jo jr js jv mn jz mo kd mp kh mq mr ms mt bi translated">WordPress 网站</li><li id="7659" class="ml mm in jm b jn mu jr mv jv mw jz mx kd my kh mq mr ms mt bi translated">Redis 在您的基础架构中运行</li><li id="d53c" class="ml mm in jm b jn mu jr mv jv mw jz mx kd my kh mq mr ms mt bi translated">一个连接 WP 和 Redis 的插件</li></ul><p id="e6d7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">完成第二步的最好方法是联系你的主机提供商。例如，在 Cloudways 上，你需要点击仪表板上的一个按钮来安装 Redis。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/ca5ed16d76d117532febf8c8d99d406e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MgGTgdRIRepAA0Ik.jpg"/></div></div></figure><h1 id="d97f" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">Redis 对象缓存插件</h1><p id="fc9a" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">正如我在另一篇文章中所说，我使用的插件是<a class="ae ku" href="https://wordpress.org/plugins/redis-cache/" rel="noopener ugc nofollow" target="_blank"> Redis 对象缓存</a>。安装和配置它并不难。开箱即用，它将尝试使用 Redis 数据库号<code class="fe na nb nc nd b">0</code>在端口<code class="fe na nb nc nd b">6379</code>上连接到同一服务器(<code class="fe na nb nc nd b">127.0.0.1</code>)中的 Redis 实例。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/b983c48750e69fc329d25c1c24070458.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3FJCKazQVy0baCic.png"/></div></div></figure><p id="840f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了让插件工作，它需要把它的<code class="fe na nb nc nd b">object-cache.php</code>文件从它自己的<em class="mb"> includes </em>文件夹复制到你的 WordPress 安装的<em class="mb"> wp-content </em>文件夹。如果由于目录权限等原因，无法自动复制文件，则需要手动复制。</p><h1 id="091d" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">同一服务器上不同站点的相同 Redis</h1><p id="c678" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">我有另一个博客运行在同一台服务器上，共享相同的 Redis 安装。为了避免每个站点存储信息之间的冲突，我必须在一个站点上定义<code class="fe na nb nc nd b">define( 'WP_REDIS_DATABASE', 0 );</code>,在另一个站点上定义<code class="fe na nb nc nd b">define( 'WP_REDIS_DATABASE', 1 );</code>。</p><p id="b302" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了调整配置，你需要在你的<em class="mb">wp-config.php</em>文件中放置一些常量。设置的完整列表可在<a class="ae ku" href="https://github.com/rhubarbgroup/redis-cache/wiki/Connection-Parameters" rel="noopener ugc nofollow" target="_blank">插件 wiki </a>上获得。</p><h1 id="9247" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">对象缓存插件如何工作</h1><p id="1abe" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">在 WordPress 加载流开始时执行的<a class="ae ku" href="https://developer.wordpress.org/reference/functions/wp_start_object_cache/" rel="noopener ugc nofollow" target="_blank">wp _ start _ object _ cache()</a>函数内部(见下)，WP 会检测是否有<code class="fe na nb nc nd b">object-cache.php</code>插件。如果该文件可用，则加载该文件，否则使用默认实现。之后，缓存被启动。</p><pre class="kj kk kl km gt nf nd ng nh aw ni bi"><span id="0e0e" class="nj kw in nd b gy nk nl l nm nn">function wp_start_object_cache() {<br/>	...<br/>		if ( file_exists( WP_CONTENT_DIR . '/object-cache.php' ) ) {<br/>			<strong class="nd io">require_once WP_CONTENT_DIR . '/object-cache.php';</strong><br/>			...<br/>		}<br/>	...<br/> </span><span id="26b8" class="nj kw in nd b gy no nl l nm nn">	<strong class="nd io">// If there is no external cache, loads WP's.</strong><br/>	if ( ! wp_using_ext_object_cache() ) {<br/>		require_once ABSPATH . WPINC . '/cache.php';<br/> 	}<br/> <br/>	require_once ABSPATH . WPINC . '/cache-compat.php';<br/> <br/>	...<br/>	<strong class="nd io">wp_cache_init();</strong><br/>	...<br/>}</span></pre><p id="e74c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mb"> Redis 对象缓存</em>的<code class="fe na nb nc nd b">object-cache.php</code>内容可以在这里看到<a class="ae ku" href="https://plugins.trac.wordpress.org/browser/redis-cache/trunk/includes/object-cache.php" rel="noopener ugc nofollow" target="_blank">。它由<code class="fe na nb nc nd b">WP_Object_Cache</code>类(文件的最后一部分)和几个使用它的函数(如<code class="fe na nb nc nd b">wp_cache_add</code>、<code class="fe na nb nc nd b">wp_cache_get</code>和<code class="fe na nb nc nd b">wp_cache_delete</code>)的实现构成。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/3fe4d67b34448dac194e2574c5d79731.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*9Uwuj6LSMOrmUviOjruMuQ.gif"/></div></figure><h1 id="295b" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">让我们来看看一些代码</h1><p id="b8d0" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">如果你需要一些代码来更好地理解事情，那没关系，我也是其中之一。下面是你在 WordPress 6.0.1 中调用<code class="fe na nb nc nd b">get_post( 123 );</code>时执行的一部分代码。</p><p id="3228" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">代码从<a class="ae ku" href="https://github.com/WordPress/WordPress/blob/6.0.1/wp-includes/post.php#L990" rel="noopener ugc nofollow" target="_blank"> wp-includes/post.php </a>开始，其中 get_post 调用<code class="fe na nb nc nd b">WP_Post::get_instance( $post )</code>。</p><p id="73af" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后，在<a class="ae ku" href="https://github.com/WordPress/WordPress/blob/6.0.1/wp-includes/class-wp-post.php#L231" rel="noopener ugc nofollow" target="_blank">WP-includes/class-WP-post . PHP</a>中:</p><pre class="kj kk kl km gt nf nd ng nh aw ni bi"><span id="c430" class="nj kw in nd b gy nk nl l nm nn">final class WP_Post {<br/>	...<br/>	public static function get_instance( $post_id ) {<br/>		<strong class="nd io">$_post = wp_cache_get( $post_id, 'posts' );</strong></span><span id="57af" class="nj kw in nd b gy no nl l nm nn">		if ( ! $_post ) {<br/>			...<br/>			<strong class="nd io">wp_cache_add( $_post-&gt;ID, $_post, 'posts' );</strong><br/>		} <br/>		...<br/>	}<br/>}</span></pre><p id="1f19" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，它检查缓存的值是否存在(<code class="fe na nb nc nd b">wp_cache_get</code>)。如果它存在，就使用它，否则，获取帖子，然后缓存(<code class="fe na nb nc nd b">wp_cache_add</code>)。</p><p id="e33b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们看一下<code class="fe na nb nc nd b">wp_cache_add</code>函数代码，我们可以看到它只不过是存储在全局变量<code class="fe na nb nc nd b">$wp_object_cache</code>中的<code class="fe na nb nc nd b">WP_Object_Cache</code>实例的<code class="fe na nb nc nd b">add</code>方法的简单包装。</p><pre class="kj kk kl km gt nf nd ng nh aw ni bi"><span id="3b57" class="nj kw in nd b gy nk nl l nm nn">function wp_cache_add( $key, $data, $group = '', $expire = 0 ) {<br/>    global $wp_object_cache;<br/> <br/>    return $wp_object_cache-&gt;add( $key, $data, $group, (int) $expire );<br/>}</span></pre><h1 id="d0b7" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">WordPress 中可用的缓存功能</h1><p id="fed6" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">官方文档列出了一些最重要的缓存函数，我在这里抄录下来。WordPress 的核心本身在几个地方使用它们，但是你也可以在你的主题或者插件中调用它们。</p><pre class="kj kk kl km gt nf nd ng nh aw ni bi"><span id="f48a" class="nj kw in nd b gy nk nl l nm nn">wp_cache_add( $key, $data, $group = '', $expire = 0 ) // If exists, do not overwrite<br/>wp_cache_set( $key, $data, $group = '', $expire = 0 ) // If exists, overwrite<br/>wp_cache_replace( $key, $data, $group, $expire ) // If does not exist, do nothing<br/>wp_cache_get( $key, $group = '', $force = false, $found = null )<br/>wp_cache_delete( $key, $group = '' )<br/>wp_cache_flush()</span></pre><h1 id="b806" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">密钥、值、组和到期</h1><p id="98ec" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">大多数<code class="fe na nb nc nd b">wp_cache_*</code>功能使用四个参数:</p><ul class=""><li id="a4ac" class="ml mm in jm b jn jo jr js jv mn jz mo kd mp kh mq mr ms mt bi translated"><strong class="jm io">关键字:</strong>存储在缓存中的对象的标识符。例如，文章 ID。</li><li id="f3e2" class="ml mm in jm b jn mu jr mv jv mw jz mx kd my kh mq mr ms mt bi translated"><strong class="jm io">值:</strong>缓存中存储的对象。在我们的例子中，邮报。</li><li id="7c7c" class="ml mm in jm b jn mu jr mv jv mw jz mx kd my kh mq mr ms mt bi translated"><strong class="jm io">分组(可选):</strong>可以对值进行分组。以前，它只是用来整理东西，但在 WordPress 6.1 中，将有一个新的<a class="ae ku" href="https://core.trac.wordpress.org/ticket/4476" rel="noopener ugc nofollow" target="_blank">功能</a> <code class="fe na nb nc nd b"><a class="ae ku" href="https://core.trac.wordpress.org/ticket/4476" rel="noopener ugc nofollow" target="_blank">wp_cache_flush_group</a></code> <a class="ae ku" href="https://core.trac.wordpress.org/ticket/4476" rel="noopener ugc nofollow" target="_blank">来刷新某个组的所有对象。例如，你可以删除某个插件的密钥。</a></li><li id="182d" class="ml mm in jm b jn mu jr mv jv mw jz mx kd my kh mq mr ms mt bi translated"><strong class="jm io"> Expiration(可选):</strong>缓存的值在多长时间内有效。现在让我们仔细看看。</li></ul><h1 id="18f5" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">呼气</h1><p id="9cfa" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">当我们谈论缓存时，最重要的概念之一是过期。我们掌握的信息仍然有效吗？这是任何缓存实现的关键部分，包括 WordPress 对象缓存。</p><p id="2007" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么，我们如何决定一个缓存的对象在多长时间内应该被认为是有效的呢？</p><h2 id="c1e1" class="nj kw in bd kx nq nr dn lb ns nt dp lf jv nu nv lj jz nw nx ln kd ny nz lr oa bi translated">事件驱动的</h2><p id="0392" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">假设您正在缓存最大内容的帖子列表。你得到所有的文章，在所有的文章中应用<code class="fe na nb nc nd b">the_content</code>过滤器，并检查它们有多少字符。相当密集，对吧？这值得缓存。</p><p id="1985" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">什么可以改变这个过程的结果？只有在文章被创建、删除或编辑的情况下，对吗？</p><p id="81d4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种情况下，我们的缓存不需要过期。<strong class="jm io">使用一个相关的</strong> <a class="ae ku" href="https://felipeelia.com.br/o-que-sao-hooks/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">钩子</strong> </a>就足以使结果无效。</p><h2 id="a520" class="nj kw in bd kx nq nr dn lb ns nt dp lf jv nu nv lj jz nw nx ln kd ny nz lr oa bi translated">时间驱动的</h2><p id="1cd1" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">如果你缓存的东西来自于外部，比如 API，<strong class="jm io">使缓存无效的事件不在我们的控制之下</strong>。在这种情况下，我们需要<strong class="jm io">不时地在外部 API 中</strong>检查结果，并更新我们已经存储的值。</p><h1 id="65c5" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">瞬态 API 和对象缓存</h1><p id="1262" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">如果你读过这篇文章或者看过 YouTube 上关于<a class="ae ku" href="https://felipeelia.com.br/cache-facil-no-wordpress-transients-api/" rel="noopener ugc nofollow" target="_blank"> WordPress Transients API </a>的视频，这里的中心思想并不新鲜:<strong class="jm io">避免长时间过程的键值对是这两件事情背后的基本思想</strong>。其实从某个方面来说，确实是一回事。看看<code class="fe na nb nc nd b">get_transient</code>函数的实现:</p><pre class="kj kk kl km gt nf nd ng nh aw ni bi"><span id="db53" class="nj kw in nd b gy nk nl l nm nn">function get_transient( $transient ) {<br/>    if ( wp_using_ext_object_cache() || wp_installing() ) {<br/>        $value = <strong class="nd io">wp_cache_get( $transient, 'transient' )</strong>;<br/>    } else {<br/>		...<br/>    }<br/>	...<br/>}</span></pre><p id="94d4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">基本上，如果您使用外部机制进行对象缓存，瞬态将存储在那里。否则，将使用常规数据库。有趣吧。一定要检查内容！</p></div></div>    
</body>
</html>