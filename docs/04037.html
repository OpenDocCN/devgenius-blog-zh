<html>
<head>
<title>Linked List Cycle: solved</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">链表循环:已解决</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/linked-list-cycle-solved-f09f71d5754d?source=collection_archive---------5-----------------------#2021-01-18">https://blog.devgenius.io/linked-list-cycle-solved-f09f71d5754d?source=collection_archive---------5-----------------------#2021-01-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/aae5d6a1960e7fb070e2905f5312d975.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4ENTv5SsXJ_vuUgjKbs0dg.png"/></div></div></figure><p id="93ea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">匆忙解决Leetcode问题，找到了这个:<a class="ae kt" href="https://leetcode.com/problems/linked-list-cycle/" rel="noopener ugc nofollow" target="_blank">链表循环</a>。在这篇博客中，我将使用两点法来解决这个问题。</p><p id="47b9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的任务是确定链表中是否有循环。如果链表中有循环，则返回true。否则，返回false。</p><p id="e8c6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">什么被认为是循环？如果链表中有某个节点可以通过连续跟随下一个指针再次到达，那么链表中就存在循环。看看这个例子。</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div class="gh gi ku"><img src="../Images/220d96c77811c2d879cb6415abb8e69b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/1*CsHDdNpzUEBm1ZkNx-p8uw.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">leetcode.com</figcaption></figure><p id="d6c8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">输入:</strong> head = [3，2，0，-4]，pos = 1(tail的下一个指针所连接的节点的索引；未作为参数传递)<br/> <strong class="jx io">输出:</strong>真<br/> <strong class="jx io">解释:</strong>链表中有一个循环，其尾部连接到第1个节点(索引为0)。</p><p id="1986" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是我发现的最直观的方法。它被称为具有慢速指针和快速指针的双指针方法。</p><p id="1c66" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以，我们的第一步是创建两个指针。第一个比较慢，因为它只从前一个位置移动了一个节点。第二个是快速的，它从前一个位置移动了两个节点。</p><p id="3c7b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，我们将创建一个while循环，并在每次迭代中检查:</p><ul class=""><li id="7ce0" class="ld le in jx b jy jz kc kd kg lf kk lg ko lh ks li lj lk ll bi translated">快速指针是否到达终点。如果是，返回false，因为它不是一个循环。</li><li id="4ea8" class="ld le in jx b jy lm kc ln kg lo kk lp ko lq ks li lj lk ll bi translated">快速指针和慢速指针是否在同一个节点。如果是的话，那就有一个循环，因为没有循环就不可能回到同样的位置。</li></ul><p id="6975" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以，我的代码是:</p><pre class="kv kw kx ky gt lr ls lt lu aw lv bi"><span id="43a8" class="lw lx in ls b gy ly lz l ma mb">var hasCycle = function(head) {</span><span id="66d9" class="lw lx in ls b gy mc lz l ma mb">    if(head === null) return false; //if there is no head node, there is no cycle</span><span id="cc1c" class="lw lx in ls b gy mc lz l ma mb">    let slow = head;<br/>    let fast = head.next;</span><span id="a856" class="lw lx in ls b gy mc lz l ma mb">    while(slow !== fast &amp;&amp; fast !== null) {<br/>        if(fast.next === null) return false<br/>        fast = fast.next.next<br/>        slow = slow.next<br/>    }<br/>    return slow === fast ? true : false<br/>};</span></pre><p id="ec01" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">希望这对你有帮助！</p></div></div>    
</body>
</html>